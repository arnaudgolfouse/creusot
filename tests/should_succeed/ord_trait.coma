module M_ord_trait__x
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_0: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  type t_DeepModelTy
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  function deep_model'1 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'1
  
  let rec le (self_: t_T) (other: t_T) (return' (x: bool)) = {[@expl:le 'self_' type invariant] inv'1 self_}
    {[@expl:le 'other' type invariant] inv'1 other}
    any [ return''0 (result: bool) -> {result = le_log (deep_model'1 self_) (deep_model'1 other)} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec x (x'0: t_T) (return' (x'1: bool)) = {[@expl:x 'x' type invariant] inv'0 x'0}
    (! bb0
    [ bb0 = s0 [ s0 = le {x'1} {x'1} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return''0 {_0} ]
    [ & _0: bool = Any.any_l () | & x'1: t_T = x'0 ])
    [ return''0 (result: bool) -> {[@expl:x ensures] result = true} (! return' {result}) ]
end
module M_ord_trait__gt_or_le
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_0: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  type t_DeepModelTy
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  function deep_model'1 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'1
  
  let rec ge (self_: t_T) (other: t_T) (return' (x: bool)) = {[@expl:ge 'self_' type invariant] inv'1 self_}
    {[@expl:ge 'other' type invariant] inv'1 other}
    any [ return''0 (result: bool) -> {result = ge_log (deep_model'1 self_) (deep_model'1 other)} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec gt_or_le (x: t_T) (y: t_T) (return' (x'0: bool)) = {[@expl:gt_or_le 'x' type invariant] inv'0 x}
    {[@expl:gt_or_le 'y' type invariant] inv'0 y}
    (! bb0
    [ bb0 = s0 [ s0 = ge {x'0} {y'0} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return''0 {_0} ]
    [ & _0: bool = Any.any_l () | & x'0: t_T = x | & y'0: t_T = y ])
    [ return''0 (result: bool) -> {[@expl:gt_or_le ensures] result = le_log (deep_model y) (deep_model x)}
      (! return' {result}) ]
end
module M_ord_trait__gt_or_le_int
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec gt_or_le_int (x: UInt64.t) (y: UInt64.t) (return' (x'0: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- UInt64.le x'0 y'0 ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: bool = Any.any_l () | & x'0: UInt64.t = x | & y'0: UInt64.t = y ])
    [ return''0 (result: bool) -> {[@expl:gt_or_le_int ensures] result = (UInt64.t'int x <= UInt64.t'int y)}
      (! return' {result}) ]
end
