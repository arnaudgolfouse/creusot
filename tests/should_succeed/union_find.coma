module M_union_find__implementation__qyi17232405883558456141__eq (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  let rec addr_eq (p: Opaque.ptr) (q: Opaque.ptr) (return (x: bool)) = any
    [ return' (result: bool) -> {result = (Ptr.addr_logic_u64 p = Ptr.addr_logic_u64 q)} (! return {result}) ]
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Element) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq (self: t_Element) (other: t_Element) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = addr_eq {self.t_Element__0} {other.t_Element__0} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ] [ & _0: bool = Any.any_l () | & self: t_Element = self | & other: t_Element = other ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (deep_model'0 self = deep_model'0 other)}
      (! return {result}) ]
end
module M_union_find__implementation__qyi10464084137166016688__clone (* <implementation::Element<T> as creusot_contracts::Clone> *)
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: t_Element) (return (x: t_Element)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { t_Element__0 = self.t_Element__0 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Element = Any.any_l () | & self: t_Element = self ])
    [ return (result: t_Element) -> {[@expl:clone ensures] self = result} (! return {result}) ]
end
module M_union_find__implementation__qyi1944850640244667852__domain (* implementation::UnionFind<T> *)
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant' [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UnionFind
  
  function domain (self: t_UnionFind) : Fset.fset t_Element
  
  goal vc_domain: inv'4 self
    -> (let result = (self.t_UnionFind__0).t_UFInner__domain in [@expl:domain ensures] forall e1: t_Element, e2: t_Element. contains result e1
        /\ contains result e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
end
module M_union_find__implementation__qyi1944850640244667852__roots_map (* implementation::UnionFind<T> *)
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant' [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains (domain self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UnionFind
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element
  
  goal vc_roots_map: inv'4 self
    -> (let result = (self.t_UnionFind__0).t_UFInner__roots in [@expl:roots_map ensures] forall e: t_Element. in_domain self e
      -> in_domain self (index_logic'1 result e)
      /\ index_logic'1 result e = index_logic'1 result (index_logic'1 result e))
end
module M_union_find__implementation__new
  use set.Fset
  use creusot.prelude.Opaque
  use map.Map
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_T
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : t_Node
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant' (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant' x
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''0 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) = inv'2 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 (_1: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_Element. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = ext_eq self empty
  
  let rec new (return (x: t_FMap)) = any
    [ return' (result: t_FMap) -> {inv'3 result} {is_empty result} (! return {result}) ]
  
  let rec into_inner (self: t_FMap) (return (x: t_FMap)) = {[@expl:into_inner 'self' type invariant] inv'3 self}
    any [ return' (result: t_FMap) -> {inv'2 result} {result = self} (! return {result}) ]
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (Map.map t_Element t_T) bool) (a: Map.map t_Element t_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (Map.map t_Element t_T) bool) : Map.map t_Element t_T
  
  axiom such_that_spec'0:
    forall p: Map.map (Map.map t_Element t_T) bool. (exists x: Map.map t_Element t_T. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  predicate index_logic'2 [@inline:trivial] (self: Map.map (Map.map t_Element int) bool) (a: Map.map t_Element int) =
    Map.get self a
  
  meta "rewrite_def" predicate index_logic'2
  
  function such_that'1 (p: Map.map (Map.map t_Element int) bool) : Map.map t_Element int
  
  axiom such_that_spec'1:
    forall p: Map.map (Map.map t_Element int) bool. (exists x: Map.map t_Element int. index_logic'2 p x)
      -> index_logic'2 p (such_that'1 p)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map (Map.map t_Element t_Element) bool) (a: Map.map t_Element t_Element) =
    Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'2 (p: Map.map (Map.map t_Element t_Element) bool) : Map.map t_Element t_Element
  
  axiom such_that_spec'2:
    forall p: Map.map (Map.map t_Element t_Element) bool. (exists x: Map.map t_Element t_Element. index_logic'3 p x)
      -> index_logic'3 p (such_that'2 p)
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  function index_logic'4 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'4
  
  function index_logic'5 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'5
  
  function index_logic'6 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'6
  
  predicate invariant''2 [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains'0 (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains'0 (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains'0 (self.t_UnionFind__0).t_UFInner__domain e
      -> contains (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains'0 (self.t_UnionFind__0).t_UFInner__domain (index_logic'4 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'4 (self.t_UnionFind__0).t_UFInner__roots (index_logic'4 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'4 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'4 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains'0 (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'4 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'4 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'4 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'5 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'6 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'6 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'6 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_1: t_UFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UFInner [inv'4 x]. inv'4 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'5 (_1: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'5 x]. inv'5 x
      = (invariant''2 x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'4 a_0
        end)
  
  predicate invariant''3 [@inline:trivial] (self: t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x = invariant''3 x
  
  let rec new'0 (x: t_UnionFind) (return (x'0: t_UnionFind)) = {[@expl:new 'x' type invariant] inv'5 x}
    any [ return' (result: t_UnionFind) -> {inv'6 result} {result = x} (! return {result}) ]
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'5 self
      -> (forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
          /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'1 (return (x: t_UnionFind)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- Fset.empty: Fset.fset t_Element ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: t_FMap) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_inner {_7} (fun (_ret: t_FMap) -> [ &_6 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_8 <- such_that'0 (fun (__0: Map.map t_Element t_T) -> true) ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = [ &_10 <- such_that'1 (fun (__0: Map.map t_Element int) -> true) ] s1 | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &_12 <- such_that'2 (fun (__0: Map.map t_Element t_Element) -> true) ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &_14 <- 0 ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_3 <- { t_UFInner__domain = _4;
                        t_UFInner__perms = _6;
                        t_UFInner__payloads = _8;
                        t_UFInner__roots = _12;
                        t_UFInner__depth = _10;
                        t_UFInner__max_depth = _14 } ] s1
      | s1 = [ &_2 <- { t_UnionFind__0 = _3 } ] s2
      | s2 = new'0 {_2} (fun (_ret: t_UnionFind) -> [ &_0 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = return {_0} ]
    [ & _0: t_UnionFind = Any.any_l ()
    | & _2: t_UnionFind = Any.any_l ()
    | & _3: t_UFInner = Any.any_l ()
    | & _4: Fset.fset t_Element = Any.any_l ()
    | & _6: t_FMap = Any.any_l ()
    | & _7: t_FMap = Any.any_l ()
    | & _8: Map.map t_Element t_T = Any.any_l ()
    | & _10: Map.map t_Element int = Any.any_l ()
    | & _12: Map.map t_Element t_Element = Any.any_l ()
    | & _14: int = Any.any_l () ])
    [ return (result: t_UnionFind) -> {[@expl:new result type invariant] inv'6 result}
      {[@expl:new ensures] Fset.is_empty (domain result)}
      (! return {result}) ]
end
module M_union_find__implementation__make
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec new (return (x: t_PeanoInt)) = any
    [ return' (result: t_PeanoInt) -> {result.t_PeanoInt__0 = (0: UInt64.t)} (! return {result}) ]
  
  type t_T
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn
  
  type tuple = { f0: Opaque.ptr; f1: t_PtrOwn }
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'0 x]. inv'0 x
      = match x with
        | C_Root rank payload -> inv payload
        | C_Link a_0 -> true
        end
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : t_Node
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'1 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'1 x]. inv'1 x = true
  
  predicate invariant' (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'1 (ptr self)
  
  predicate inv'2 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'2 x]. inv'2 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) = inv'2 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'3 (_1: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 (_1: tuple)
  
  axiom inv_axiom'3 [@rewrite]: forall x: tuple [inv'4 x]. inv'4 x = (let {f0 = x0; f1 = x1} = x in inv'3 x1)
  
  let rec new'0 (v: t_Node) (return (x: tuple)) = {[@expl:new 'v' type invariant] inv'0 v}
    any
    [ return' (result: tuple) -> {inv'4 result} {ptr result.f1 = result.f0 /\ val' result.f1 = v} (! return {result}) ]
  
  let rec into_inner (self: t_PtrOwn) (return (x: t_PtrOwn)) = {[@expl:into_inner 'self' type invariant] inv'3 self}
    any [ return' (result: t_PtrOwn) -> {inv'2 result} {result = self} (! return {result}) ]
  
  type t_FMap
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant''1 [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'5 (_1: t_Element)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Element [inv'5 x]. inv'5 x = true
  
  predicate invariant''2 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv'5 k /\ inv'2 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'6 (_1: t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_FMap [inv'6 x]. inv'6 x = invariant''2 x
  
  predicate inv'7 (_1: t_UFInner)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UFInner [inv'7 x]. inv'7 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'6 perms
        end
  
  predicate inv'8 (_1: t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UnionFind [inv'8 x]. inv'8 x
      = (invariant''1 x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'7 a_0
        end)
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'9 x]. inv'9 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'9 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'10 x]. inv'10 x = invariant''4 x
  
  let rec into_inner'0 (self: MutBorrow.t t_UnionFind) (return (x: MutBorrow.t t_UnionFind)) =
    {[@expl:into_inner 'self' type invariant] inv'10 self}
    any [ return' (result: MutBorrow.t t_UnionFind) -> {inv'9 result} {result = self} (! return {result}) ]
  
  type tuple'0 = { f0'0: t_PtrOwn; f1'0: MutBorrow.t t_UnionFind }
  
  predicate index_logic'4 [@inline:trivial] (self: Map.map t_Element bool) (a: t_Element) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'4
  
  function such_that'0 (p: Map.map t_Element bool) : t_Element
  
  axiom such_that_spec'0: forall p: Map.map t_Element bool. (exists x: t_Element. index_logic'4 p x)
      -> index_logic'4 p (such_that'0 p)
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'8 self
      -> (forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains (domain self) e
  
  let rec into_ghost (self: Opaque.ptr) (return (x: Opaque.ptr)) = any
    [ return' (result: Opaque.ptr) -> {result = self} (! return {result}) ]
  
  let rec into_inner'1 (self: Opaque.ptr) (return (x: Opaque.ptr)) = any
    [ return' (result: Opaque.ptr) -> {result = self} (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''5 [@inline:trivial] (self: t_FMap) = inv'6 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'11 (_1: t_FMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_FMap [inv'11 x]. inv'11 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: t_PtrOwn) = inv'2 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'12 (_1: t_PtrOwn)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''6 x
  
  predicate inv'13 (_1: t_Option'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'12 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Element) (return (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] inv'11 self}
    any
    [ return' (result: t_Option'0) -> {inv'13 result}
      {result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return {result}) ]
  
  let rec v_Some (input: t_Option'0) (ret (field_0: t_PtrOwn)) = any
    [ good (field_0: t_PtrOwn) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_PtrOwn [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'14 (_1: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'14 x]. inv'14 x = invariant''7 x
  
  let rec disjoint_lemma (own1: MutBorrow.t t_PtrOwn) (own2: t_PtrOwn) (return (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] inv'14 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] inv'12 own2}
    any
    [ return' (result: ()) -> {Ptr.addr_logic_u64 (ptr own1.current) <> Ptr.addr_logic_u64 (ptr own2)}
      {own1.current = own1.final}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_FMap) = inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'15 (_1: MutBorrow.t t_FMap)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'15 x]. inv'15 x = invariant''8 x
  
  predicate inv'16 (_1: t_Option)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Option [inv'16 x]. inv'16 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function insert (self: t_FMap) (k: t_Element) (v: t_PtrOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Element, v: t_PtrOwn. view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Element, v: t_PtrOwn. len (insert self k v)
      = (if contains'0 self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_Element) (value: t_PtrOwn) (return (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] inv'15 self}
    {[@expl:insert_ghost 'value' type invariant] inv'2 value}
    any
    [ return' (result: t_Option) -> {inv'16 result}
      {self.final = insert self.current key value}
      {result = get self.current key}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (_1: t_PtrOwn) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (self: t_Option) =
    match self with
      | C_Some x -> resolve'1 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_Option) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  function insert'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) : Fset.fset t_Element = Fset.add e self
  
  meta "rewrite_def" function insert'0
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: MutBorrow.t t_UnionFind) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  let rec new'1 (x: ()) (return (x'0: ())) = any [ return' (result: ()) -> {result = x} (! return {result}) ]
  
  function fin [@inline:trivial] (self: MutBorrow.t t_UnionFind) : t_UnionFind = self.final
  
  meta "rewrite_def" function fin
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element = (self.t_UnionFind__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. inv'8 self
      -> (forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function payloads_map (self: t_UnionFind) : Map.map t_Element t_T = (self.t_UnionFind__0).t_UFInner__payloads
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec make (uf: MutBorrow.t t_UnionFind) (payload: t_T) (return (x: t_Element)) =
    {[@expl:make 'uf' type invariant] inv'10 uf}
    {[@expl:make 'payload' type invariant] inv payload}
    (! bb0
    [ bb0 = s0 [ s0 = [ &payload_snap <- payload ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: t_PeanoInt) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_12 <- C_Root _13 payload ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = new'0 {_12} (fun (_ret: tuple) -> [ &_11 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &ptr'0 <- _11.f0 ] s1
      | s1 = [ &perm <- _11.f1 ] s2
      | s2 = [ &elt <- { t_Element__0 = ptr'0 } ] s3
      | s3 = into_inner {perm} (fun (_ret: t_PtrOwn) -> [ &_22 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0 [ s0 = into_inner'0 {uf} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_24 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_21 <- { f0'0 = _22; f1'0 = _24 } ] s1
      | s1 = [ &perm'0 <- _21.f0'0 ] s2
      | s2 = [ &uf'0 <- _21.f1'0 ] s3
      | s3 = [ &other_elt_ptr_snap <- (such_that'0 (fun (e: t_Element) -> in_domain uf'0.current e
        /\ deep_model e = deep_model elt)).t_Element__0 ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = into_ghost {other_elt_ptr_snap} (fun (_ret: Opaque.ptr) -> [ &_30 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = into_inner'1 {_30} (fun (_ret: Opaque.ptr) -> [ &_29 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &other_elt <- { t_Element__0 = _29 } ] s1
      | s1 = [ &_36 <- other_elt ] s2
      | s2 = get_ghost {((uf'0.current).t_UnionFind__0).t_UFInner__perms} {_36}
          (fun (_ret: t_Option'0) -> [ &_33 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = any [ br0 -> {_33 = C_None'0} (! bb16) | br1 (x0: t_PtrOwn) -> {_33 = C_Some'0 x0} (! bb13) ]
    | bb13 = s0
      [ s0 = v_Some {_33} (fun (r0: t_PtrOwn) -> [ &other_perm <- r0 ] s1)
      | s1 = {inv'2 perm'0}
        MutBorrow.borrow_mut <t_PtrOwn> {perm'0}
          (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_40 <- _ret ] -{inv'2 _ret.final}- [ &perm'0 <- _ret.final ] s2)
      | s2 = {inv'2 _40.current}
        MutBorrow.borrow_final <t_PtrOwn> {_40.current} {MutBorrow.get_id _40}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_39 <- _ret ] -{inv'2 _ret.final}-
            [ &_40 <- { _40 with current = _ret.final } ] s3)
      | s3 = disjoint_lemma {_39} {other_perm} (fun (_ret: ()) -> [ &_32 <- _ret ] s4)
      | s4 = bb15 ]
    | bb15 = s0 [ s0 = {[@expl:type invariant] inv'14 _40} s1 | s1 = -{resolve'0 _40}- s2 | s2 = bb16 ]
    | bb16 = s0
      [ s0 = {inv'6 ((uf'0.current).t_UnionFind__0).t_UFInner__perms}
        MutBorrow.borrow_final <t_FMap> {((uf'0.current).t_UnionFind__0).t_UFInner__perms}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id uf'0) 1) 2}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_43 <- _ret ] -{inv'6 _ret.final}-
            [ &uf'0 <- { uf'0 with current = { t_UnionFind__0 = { (uf'0.current).t_UnionFind__0 with t_UFInner__perms = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_43} {elt} {perm'0} (fun (_ret: t_Option) -> [ &_42 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'16 _42} s3
      | s3 = -{resolve'3 _42}- s4
      | s4 = bb17 ]
    | bb17 = s0 [ s0 = [ &_46 <- insert'0 ((uf'0.current).t_UnionFind__0).t_UFInner__domain elt ] s1 | s1 = bb18 ]
    | bb18 = s0
      [ s0 =
        [ &uf'0 <- { uf'0 with current = { t_UnionFind__0 = { (uf'0.current).t_UnionFind__0 with t_UFInner__domain = _46 } } } ]
        s1
      | s1 = [ &_48 <- Map.set ((uf'0.current).t_UnionFind__0).t_UFInner__payloads elt payload_snap ] s2
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 =
        [ &uf'0 <- { uf'0 with current = { t_UnionFind__0 = { (uf'0.current).t_UnionFind__0 with t_UFInner__payloads = _48 } } } ]
        s1
      | s1 =
        [ &_50 <- Map.set ((uf'0.current).t_UnionFind__0).t_UFInner__depth elt ((uf'0.current).t_UnionFind__0).t_UFInner__max_depth ]
        s2
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 =
        [ &uf'0 <- { uf'0 with current = { t_UnionFind__0 = { (uf'0.current).t_UnionFind__0 with t_UFInner__depth = _50 } } } ]
        s1
      | s1 = [ &_52 <- Map.set ((uf'0.current).t_UnionFind__0).t_UFInner__roots elt elt ] s2
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 =
        [ &uf'0 <- { uf'0 with current = { t_UnionFind__0 = { (uf'0.current).t_UnionFind__0 with t_UFInner__roots = _52 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'9 uf'0} s2
      | s2 = -{resolve'5 uf'0}- s3
      | s3 = new'1 {_18} (fun (_ret: ()) -> [ &_17 <- _ret ] s4)
      | s4 = bb22 ]
    | bb22 = s0 [ s0 = [ &_0 <- elt ] s1 | s1 = bb23 ]
    | bb23 = return {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind = uf
    | & payload: t_T = payload
    | & payload_snap: t_T = Any.any_l ()
    | & ptr'0: Opaque.ptr = Any.any_l ()
    | & perm: t_PtrOwn = Any.any_l ()
    | & _11: tuple = Any.any_l ()
    | & _12: t_Node = Any.any_l ()
    | & _13: t_PeanoInt = Any.any_l ()
    | & elt: t_Element = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: () = Any.any_l ()
    | & perm'0: t_PtrOwn = Any.any_l ()
    | & uf'0: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _21: tuple'0 = Any.any_l ()
    | & _22: t_PtrOwn = Any.any_l ()
    | & _24: MutBorrow.t t_UnionFind = Any.any_l ()
    | & other_elt_ptr_snap: Opaque.ptr = Any.any_l ()
    | & other_elt: t_Element = Any.any_l ()
    | & _29: Opaque.ptr = Any.any_l ()
    | & _30: Opaque.ptr = Any.any_l ()
    | & _32: () = Any.any_l ()
    | & _33: t_Option'0 = Any.any_l ()
    | & _36: t_Element = Any.any_l ()
    | & other_perm: t_PtrOwn = Any.any_l ()
    | & _39: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _40: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _42: t_Option = Any.any_l ()
    | & _43: MutBorrow.t t_FMap = Any.any_l ()
    | & _46: Fset.fset t_Element = Any.any_l ()
    | & _48: Map.map t_Element t_T = Any.any_l ()
    | & _50: Map.map t_Element int = Any.any_l ()
    | & _52: Map.map t_Element t_Element = Any.any_l () ])
    [ return (result: t_Element) -> {[@expl:make ensures #0] not in_domain uf.current result}
      {[@expl:make ensures #1] domain (fin uf) = insert'0 (domain uf.current) result}
      {[@expl:make ensures #2] roots_map (fin uf) = Map.set (roots_map uf.current) result result}
      {[@expl:make ensures #3] payloads_map (fin uf) = Map.set (payloads_map uf.current) result payload}
      (! return {result}) ]
end
module M_union_find__implementation__find_inner
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant' [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'6 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'8 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  let rec deref (self: MutBorrow.t t_UnionFind) (return (x: MutBorrow.t t_UnionFind)) =
    {[@expl:deref 'self' type invariant] inv'7 self}
    any [ return' (result: MutBorrow.t t_UnionFind) -> {inv'8 result} {result = self} (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''6 [@inline:trivial] (self: t_FMap) = inv'2 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'9 (_1: t_FMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_FMap [inv'9 x]. inv'9 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: t_PtrOwn) = inv'1 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'10 (_1: t_PtrOwn)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PtrOwn [inv'10 x]. inv'10 x = invariant''7 x
  
  predicate inv'11 (_1: t_Option'0)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'0 [inv'11 x]. inv'11 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'10 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Element) (return (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] inv'9 self}
    any
    [ return' (result: t_Option'0) -> {inv'11 result}
      {result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: t_PtrOwn)) = {[@expl:unwrap 'self_' type invariant] inv'11 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: t_PtrOwn) -> {inv'10 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate invariant''8 [@inline:trivial] (self: t_PtrOwn) = inv'10 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_1: t_PtrOwn)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''8 x
  
  let rec new (x: t_PtrOwn) (return (x'0: t_PtrOwn)) = {[@expl:new 'x' type invariant] inv'10 x}
    any [ return' (result: t_PtrOwn) -> {inv'12 result} {result = x} (! return {result}) ]
  
  predicate inv'13 (_1: t_T)
  
  predicate inv'14 (_1: t_Node)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Node [inv'14 x]. inv'14 x
      = match x with
        | C_Root rank payload -> inv'13 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''9 [@inline:trivial] (self: t_Node) = inv'14 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'15 (_1: t_Node)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Node [inv'15 x]. inv'15 x = invariant''9 x
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return (x: t_Node)) =
    {[@expl:as_ref 'own' type invariant] inv'12 own}
    {[@expl:as_ref requires] ptr'0 = ptr own}
    any [ return' (result: t_Node) -> {inv'15 result} {result = val' own} (! return {result}) ]
  
  let rec v_Link (input: t_Node) (ret (field_0: t_Element)) = any
    [ good (field_0: t_Element) -> {C_Link field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Element [C_Link field_0: t_Node]. C_Link field_0 <> input} (! {false} any) ]
  
  predicate invariant''10 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'16 (_1: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'16 x]. inv'16 x = invariant''10 x
  
  predicate invariant''11 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'17 (_1: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'17 x]. inv'17 x = invariant''11 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] inv'16 self}
    any
    [ return' (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {inv'17 result} {result = self} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_UnionFind) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  let rec new'0 (x: MutBorrow.t t_UnionFind) (return (x'0: MutBorrow.t t_UnionFind)) =
    {[@expl:new 'x' type invariant] inv'5 x}
    any [ return' (result: MutBorrow.t t_UnionFind) -> {inv'6 result} {result = x} (! return {result}) ]
  
  predicate invariant''12 [@inline:trivial] (self: MutBorrow.t t_UFInner) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'18 (_1: MutBorrow.t t_UFInner)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_UFInner [inv'18 x]. inv'18 x = invariant''12 x
  
  predicate invariant''13 [@inline:trivial] (self: MutBorrow.t t_UFInner) = inv'18 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'19 (_1: MutBorrow.t t_UFInner)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_UFInner [inv'19 x]. inv'19 x = invariant''13 x
  
  let rec new'1 (x: MutBorrow.t t_UFInner) (return (x'0: MutBorrow.t t_UFInner)) =
    {[@expl:new 'x' type invariant] inv'18 x}
    any [ return' (result: MutBorrow.t t_UFInner) -> {inv'19 result} {result = x} (! return {result}) ]
  
  predicate invariant''14 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    inv'19 self.current /\ inv'19 self.final
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'20 (_1: MutBorrow.t (MutBorrow.t t_UFInner))
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UFInner) [inv'20 x]. inv'20 x = invariant''14 x
  
  predicate invariant''15 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    inv'18 self.current /\ inv'18 self.final
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'21 (_1: MutBorrow.t (MutBorrow.t t_UFInner))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UFInner) [inv'21 x]. inv'21 x = invariant''15 x
  
  let rec deref_mut'0 (self: MutBorrow.t (MutBorrow.t t_UFInner)) (return (x: MutBorrow.t (MutBorrow.t t_UFInner))) =
    {[@expl:deref_mut 'self' type invariant] inv'20 self}
    any [ return' (result: MutBorrow.t (MutBorrow.t t_UFInner)) -> {inv'21 result} {result = self} (! return {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_PtrOwn)
  
  predicate invariant''16 [@inline:trivial] (self: MutBorrow.t t_FMap) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'22 (_1: MutBorrow.t t_FMap)
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'22 x]. inv'22 x = invariant''16 x
  
  predicate invariant''17 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'23 (_1: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'23 x]. inv'23 x = invariant''17 x
  
  predicate inv'24 (_1: t_Option'1)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_Option'1 [inv'24 x]. inv'24 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'23 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Element) (return (x: t_Option'1)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv'22 self}
    any
    [ return' (result: t_Option'1) -> {inv'24 result}
      {if contains'0 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'0 self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {forall k: t_Element. k <> key -> get self.current k = get self.final k}
      {len self.current = len self.final}
      (! return {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return (x: MutBorrow.t t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] inv'24 self_}
    {[@expl:unwrap requires] self_ <> C_None'1}
    any [ return' (result: MutBorrow.t t_PtrOwn) -> {inv'23 result} {C_Some'1 result = self_} (! return {result}) ]
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner)) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate invariant''18 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'23 self
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'25 (_1: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'24 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'25 x]. inv'25 x = invariant''18 x
  
  let rec new'2 (x: MutBorrow.t t_PtrOwn) (return (x'0: MutBorrow.t t_PtrOwn)) =
    {[@expl:new 'x' type invariant] inv'23 x}
    any [ return' (result: MutBorrow.t t_PtrOwn) -> {inv'25 result} {result = x} (! return {result}) ]
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = resolve'5 _1
  
  meta "rewrite_def" predicate resolve'6
  
  predicate invariant''19 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'14 self.current /\ inv'14 self.final
  
  meta "rewrite_def" predicate invariant''19
  
  predicate inv'26 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'25 [@rewrite]: forall x: MutBorrow.t t_Node [inv'26 x]. inv'26 x = invariant''19 x
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PtrOwn) : t_PtrOwn = self.final
  
  meta "rewrite_def" function fin
  
  let rec as_mut (ptr'0: Opaque.ptr) (own: MutBorrow.t t_PtrOwn) (return (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'own' type invariant] inv'25 own}
    {[@expl:as_mut requires] ptr'0 = ptr own.current}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'26 result}
      {result.current = val' own.current}
      {ptr (fin own) = ptr own.current}
      {val' (fin own) = result.final}
      (! return {result}) ]
  
  predicate resolve'7 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'7 _1
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 [@inline:trivial] (self: MutBorrow.t t_UFInner) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'9
  
  predicate resolve'10 [@inline:trivial] (_1: MutBorrow.t t_UFInner) = resolve'9 _1
  
  meta "rewrite_def" predicate resolve'10
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_UFInner) = resolve'10 self
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_1: MutBorrow.t t_UFInner) = resolve'11 _1
  
  meta "rewrite_def" predicate resolve'12
  
  predicate resolve'13 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = resolve'2 self
  
  meta "rewrite_def" predicate resolve'13
  
  predicate resolve'14 [@inline:trivial] (_1: MutBorrow.t t_UnionFind) = resolve'13 _1
  
  meta "rewrite_def" predicate resolve'14
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains (domain self) e
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element = (self.t_UnionFind__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root (self: t_UnionFind) (e: t_Element) : t_Element = index_logic'1 (roots_map self) e
  
  function payloads_map (self: t_UnionFind) : Map.map t_Element t_T = (self.t_UnionFind__0).t_UFInner__payloads
  
  predicate unchanged (self: MutBorrow.t t_UnionFind) =
    domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  function fin'0 [@inline:trivial] (self: MutBorrow.t t_UnionFind) : t_UnionFind = self.final
  
  meta "rewrite_def" function fin'0
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find_inner (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find_inner 'uf' type invariant] inv'6 uf}
    {[@expl:find_inner requires] in_domain uf.current elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref {uf} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_13 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_16 <- elem ] s1
      | s1 = get_ghost {((_13.current).t_UnionFind__0).t_UFInner__perms} {_16}
          (fun (_ret: t_Option'0) -> [ &_11 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_11} (fun (_ret: t_PtrOwn) -> [ &_10 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_10} (fun (_ret: t_PtrOwn) -> [ &perm <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = as_ref {elem.t_Element__0} {perm} (fun (_ret: t_Node) -> [ &_17 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_17 = C_Root x0 x1} (! bb7)
      | br1 (x0: t_Element) -> {_17 = C_Link x0} (! bb8) ]
    | bb8 = s0
      [ s0 = v_Link {_17} (fun (r0: t_Element) -> [ &e <- r0 ] s1)
      | s1 = {inv'6 uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_28 <- _ret ] -{inv'6 _ret.final}-
            [ &uf <- _ret.final ] s2)
      | s2 = deref_mut {_28} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_27 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'4 (_27.current).current}
        MutBorrow.borrow_mut <t_UnionFind> {(_27.current).current}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_26 <- _ret ] -{inv'4 _ret.final}-
            [ &_27 <- { _27 with current = { _27.current with current = _ret.final } } ] s1)
      | s1 = {inv'4 _26.current}
        MutBorrow.borrow_final <t_UnionFind> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_25 <- _ret ] -{inv'4 _ret.final}-
            [ &_26 <- { _26 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'17 _27} s3
      | s3 = -{resolve'0 _27}- s4
      | s4 = {[@expl:type invariant] inv'5 _26} s5
      | s5 = -{resolve'2 _26}- s6
      | s6 = {inv'4 _25.current}
        MutBorrow.borrow_final <t_UnionFind> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_24 <- _ret ] -{inv'4 _ret.final}-
            [ &_25 <- { _25 with current = _ret.final } ] s7)
      | s7 = new'0 {_24} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_23 <- _ret ] s8)
      | s8 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'5 _25} s1
      | s1 = -{resolve'2 _25}- s2
      | s2 = find_inner {_23} {e} (fun (_ret: t_Element) -> [ &root'0 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = {inv'6 uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_32 <- _ret ] -{inv'6 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut {_32} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_31 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = {inv'3 ((_31.current).current).t_UnionFind__0}
        MutBorrow.borrow_mut <t_UFInner> {((_31.current).current).t_UnionFind__0}
          (fun (_ret: MutBorrow.t t_UFInner) ->
            [ &__temp <- _ret ] -{inv'3 _ret.final}-
            [ &_31 <- { _31 with current = { _31.current with current = { t_UnionFind__0 = _ret.final } } } ] s1)
      | s1 = new'1 {__temp} (fun (_ret: MutBorrow.t t_UFInner) -> [ &uf'0 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {[@expl:assertion] index_logic'3 (uf'0.current).t_UFInner__depth elem
        < index_logic'3 (uf'0.current).t_UFInner__depth root'0}
        s1
      | s1 = {inv'19 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_43 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'0 <- _ret.final ] s2)
      | s2 = deref_mut'0 {_43} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_42 <- _ret ] s3)
      | s3 = bb15 ]
    | bb15 = s0
      [ s0 = [ &_45 <- elem ] s1
      | s1 = {inv'2 ((_42.current).current).t_UFInner__perms}
        MutBorrow.borrow_mut <t_FMap> {((_42.current).current).t_UFInner__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_41 <- _ret ] -{inv'2 _ret.final}-
            [ &_42 <- { _42 with current = { _42.current with current = { (_42.current).current with t_UFInner__perms = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_41} {_45} (fun (_ret: t_Option'1) -> [ &_40 <- _ret ] s3)
      | s3 = bb16 ]
    | bb16 = s0 [ s0 = unwrap'0 {_40} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_39 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'21 _42} s1
      | s1 = -{resolve'4 _42}- s2
      | s2 = {inv'1 _39.current}
        MutBorrow.borrow_final <t_PtrOwn> {_39.current} {MutBorrow.get_id _39}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_38 <- _ret ] -{inv'1 _ret.final}-
            [ &_39 <- { _39 with current = _ret.final } ] s3)
      | s3 = new'2 {_38} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &mut_perm <- _ret ] s4)
      | s4 = bb18 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'23 _39} s1
      | s1 = -{resolve'6 _39}- s2
      | s2 = [ &_47 <- C_Link root'0 ] s3
      | s3 = as_mut {elem.t_Element__0} {mut_perm} (fun (_ret: MutBorrow.t t_Node) -> [ &_49 <- _ret ] s4)
      | s4 = bb20 ]
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv'14 _49.current} s1
      | s1 = [ &_49 <- { _49 with current = _47 } ] s2
      | s2 = {[@expl:type invariant] inv'26 _49} s3
      | s3 = -{resolve'8 _49}- s4
      | s4 = {[@expl:type invariant] inv'19 uf'0} s5
      | s5 = -{resolve'12 uf'0}- s6
      | s6 = {[@expl:type invariant] inv'17 _31} s7
      | s7 = -{resolve'0 _31}- s8
      | s8 = {[@expl:type invariant] inv'6 uf} s9
      | s9 = -{resolve'14 uf}- s10
      | s10 = bb22 ]
    | bb22 = s0 [ s0 = [ &_0 <- root'0 ] s1 | s1 = bb23 ]
    | bb7 = s0 [ s0 = {[@expl:type invariant] inv'6 uf} s1 | s1 = -{resolve'14 uf}- s2 | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- elem ] s1 | s1 = bb23 ]
    | bb23 = return {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind = uf
    | & elem: t_Element = elem
    | & perm: t_PtrOwn = Any.any_l ()
    | & _10: t_PtrOwn = Any.any_l ()
    | & _11: t_Option'0 = Any.any_l ()
    | & _13: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _16: t_Element = Any.any_l ()
    | & _17: t_Node = Any.any_l ()
    | & e: t_Element = Any.any_l ()
    | & root'0: t_Element = Any.any_l ()
    | & _23: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _24: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _25: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _26: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _27: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _28: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & __temp: MutBorrow.t t_UFInner = Any.any_l ()
    | & _31: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _32: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & uf'0: MutBorrow.t t_UFInner = Any.any_l ()
    | & mut_perm: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _38: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _39: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _40: t_Option'1 = Any.any_l ()
    | & _41: MutBorrow.t t_FMap = Any.any_l ()
    | & _42: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _43: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _45: t_Element = Any.any_l ()
    | & _47: t_Node = Any.any_l ()
    | & _49: MutBorrow.t t_Node = Any.any_l () ]
    [ find_inner (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (_ret (_r: t_Element)) ->
    {[@expl:function variant] well_founded_relation function_variant (((uf.current).t_UnionFind__0).t_UFInner__max_depth
      - index_logic'3 ((uf.current).t_UnionFind__0).t_UFInner__depth elem)}
      find_inner {uf} {elem} (_ret) ]
    [ function_variant: int = ((uf.current).t_UnionFind__0).t_UFInner__max_depth
    - index_logic'3 ((uf.current).t_UnionFind__0).t_UFInner__depth elem ])
    [ return (result: t_Element) -> {[@expl:find_inner ensures #0] result = root uf.current elem}
      {[@expl:find_inner ensures #1] unchanged uf}
      {[@expl:find_inner ensures #2] ((fin'0 uf).t_UnionFind__0).t_UFInner__depth
      = ((uf.current).t_UnionFind__0).t_UFInner__depth}
      {[@expl:find_inner ensures #3] index_logic'3 ((uf.current).t_UnionFind__0).t_UFInner__depth result
      >= index_logic'3 ((uf.current).t_UnionFind__0).t_UFInner__depth elem}
      (! return {result}) ]
end
module M_union_find__implementation__find
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  function index_logic [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic'0 p x)
      -> index_logic'0 p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'1 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant' [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'1 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'2 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__roots (index_logic'2 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'2 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'1 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'2 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'2 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'2 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'1 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv k /\ inv'1 (index_logic'1 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'6 x]. inv'6 x = invariant''3 x
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains (domain self) e
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element = (self.t_UnionFind__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'2 (roots_map self) e)
        /\ index_logic'2 (roots_map self) e = index_logic'2 (roots_map self) (index_logic'2 (roots_map self) e))
  
  function root (self: t_UnionFind) (e: t_Element) : t_Element = index_logic'2 (roots_map self) e
  
  function payloads_map (self: t_UnionFind) : Map.map t_Element t_T = (self.t_UnionFind__0).t_UFInner__payloads
  
  predicate unchanged (self: MutBorrow.t t_UnionFind) =
    domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  function fin [@inline:trivial] (self: MutBorrow.t t_UnionFind) : t_UnionFind = self.final
  
  meta "rewrite_def" function fin
  
  let rec find_inner (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find_inner 'uf' type invariant] inv'6 uf}
    {[@expl:find_inner requires] in_domain uf.current elem}
    any
    [ return' (result: t_Element) -> {result = root uf.current elem}
      {unchanged uf}
      {((fin uf).t_UnionFind__0).t_UFInner__depth = ((uf.current).t_UnionFind__0).t_UFInner__depth}
      {index_logic ((uf.current).t_UnionFind__0).t_UFInner__depth result
      >= index_logic ((uf.current).t_UnionFind__0).t_UFInner__depth elem}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find 'uf' type invariant] inv'6 uf}
    {[@expl:find requires] in_domain uf.current elem}
    (! bb0
    [ bb0 = s0 [ s0 = find_inner {uf} {elem} (fun (_ret: t_Element) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ]
    [ & _0: t_Element = Any.any_l () | & uf: MutBorrow.t t_UnionFind = uf | & elem: t_Element = elem ])
    [ return (result: t_Element) -> {[@expl:find ensures #0] result = root uf.current elem}
      {[@expl:find ensures #1] unchanged uf}
      (! return {result}) ]
end
module M_union_find__implementation__get
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant' [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_UnionFind) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_UnionFind) = inv'6 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'8 (_1: t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  let rec deref (self: t_UnionFind) (return (x: t_UnionFind)) = {[@expl:deref 'self' type invariant] inv'7 self}
    any [ return' (result: t_UnionFind) -> {inv'8 result} {result = self} (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''6 [@inline:trivial] (self: t_FMap) = inv'2 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'9 (_1: t_FMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_FMap [inv'9 x]. inv'9 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: t_PtrOwn) = inv'1 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'10 (_1: t_PtrOwn)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PtrOwn [inv'10 x]. inv'10 x = invariant''7 x
  
  predicate inv'11 (_1: t_Option'0)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'0 [inv'11 x]. inv'11 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'10 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Element) (return (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] inv'9 self}
    any
    [ return' (result: t_Option'0) -> {inv'11 result}
      {result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: t_PtrOwn)) = {[@expl:unwrap 'self_' type invariant] inv'11 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: t_PtrOwn) -> {inv'10 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate invariant''8 [@inline:trivial] (self: t_PtrOwn) = inv'10 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_1: t_PtrOwn)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''8 x
  
  let rec new (x: t_PtrOwn) (return (x'0: t_PtrOwn)) = {[@expl:new 'x' type invariant] inv'10 x}
    any [ return' (result: t_PtrOwn) -> {inv'12 result} {result = x} (! return {result}) ]
  
  predicate inv'13 (_1: t_T)
  
  predicate inv'14 (_1: t_Node)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Node [inv'14 x]. inv'14 x
      = match x with
        | C_Root rank payload -> inv'13 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''9 [@inline:trivial] (self: t_Node) = inv'14 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'15 (_1: t_Node)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Node [inv'15 x]. inv'15 x = invariant''9 x
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return (x: t_Node)) =
    {[@expl:as_ref 'own' type invariant] inv'12 own}
    {[@expl:as_ref requires] ptr'0 = ptr own}
    any [ return' (result: t_Node) -> {inv'15 result} {result = val' own} (! return {result}) ]
  
  let rec v_Root (input: t_Node) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {C_Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [C_Root rank payload: t_Node]. C_Root rank payload <> input}
      (! {false}
      any) ]
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains (domain self) e
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element = (self.t_UnionFind__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root (self: t_UnionFind) (e: t_Element) : t_Element = index_logic'1 (roots_map self) e
  
  predicate invariant''10 [@inline:trivial] (self: t_T) = inv'13 self
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'16 (_1: t_T)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_T [inv'16 x]. inv'16 x = invariant''10 x
  
  function payloads_map (self: t_UnionFind) : Map.map t_Element t_T = (self.t_UnionFind__0).t_UFInner__payloads
  
  function payload (self: t_UnionFind) (e: t_Element) : t_T = index_logic'2 (payloads_map self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get'0 (uf: t_UnionFind) (elem: t_Element) (return (x: t_T)) = {[@expl:get 'uf' type invariant] inv'6 uf}
    {[@expl:get requires #0] in_domain uf elem}
    {[@expl:get requires #1] root uf elem = elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref {uf} (fun (_ret: t_UnionFind) -> [ &_10 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_13 <- elem ] s1
      | s1 = get_ghost {(_10.t_UnionFind__0).t_UFInner__perms} {_13} (fun (_ret: t_Option'0) -> [ &_8 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_8} (fun (_ret: t_PtrOwn) -> [ &_7 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_7} (fun (_ret: t_PtrOwn) -> [ &perm <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = as_ref {elem.t_Element__0} {perm} (fun (_ret: t_Node) -> [ &_14 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_14 = C_Root x0 x1} (! bb8)
      | br1 (x0: t_Element) -> {_14 = C_Link x0} (! bb6) ]
    | bb6 = {false} any
    | bb8 = s0
      [ s0 = v_Root {_14} (fun (rrank: t_PeanoInt) (rpayload: t_T) -> [ &payload'0 <- rpayload ] s1)
      | s1 = [ &_0 <- payload'0 ] s2
      | s2 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & uf: t_UnionFind = uf
    | & elem: t_Element = elem
    | & perm: t_PtrOwn = Any.any_l ()
    | & _7: t_PtrOwn = Any.any_l ()
    | & _8: t_Option'0 = Any.any_l ()
    | & _10: t_UnionFind = Any.any_l ()
    | & _13: t_Element = Any.any_l ()
    | & _14: t_Node = Any.any_l ()
    | & payload'0: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:get result type invariant] inv'16 result}
      {[@expl:get ensures] result = payload uf elem}
      (! return {result}) ]
end
module M_union_find__implementation__equiv
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant' [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'8 (_1: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'8 x]. inv'8 x = invariant''5 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] inv'7 self}
    any
    [ return' (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {inv'8 result} {result = self} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_UnionFind) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  let rec new (x: MutBorrow.t t_UnionFind) (return (x'0: MutBorrow.t t_UnionFind)) =
    {[@expl:new 'x' type invariant] inv'5 x}
    any [ return' (result: MutBorrow.t t_UnionFind) -> {inv'6 result} {result = x} (! return {result}) ]
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains (domain self) e
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element = (self.t_UnionFind__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root (self: t_UnionFind) (e: t_Element) : t_Element = index_logic'1 (roots_map self) e
  
  function payloads_map (self: t_UnionFind) : Map.map t_Element t_T = (self.t_UnionFind__0).t_UFInner__payloads
  
  predicate unchanged (self: MutBorrow.t t_UnionFind) =
    domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  let rec find (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find 'uf' type invariant] inv'6 uf}
    {[@expl:find requires] in_domain uf.current elem}
    any [ return' (result: t_Element) -> {result = root uf.current elem} {unchanged uf} (! return {result}) ]
  
  function deep_model'0 [@inline:trivial] (self: t_Element) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  let rec eq (self: t_Element) (other: t_Element) (return (x: bool)) = any
    [ return' (result: bool) -> {result = (deep_model'0 self = deep_model'0 other)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec equiv (uf: MutBorrow.t t_UnionFind) (e1: t_Element) (e2: t_Element) (return (x: bool)) =
    {[@expl:equiv 'uf' type invariant] inv'6 uf}
    {[@expl:equiv requires #0] in_domain uf.current e1}
    {[@expl:equiv requires #1] in_domain uf.current e2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'6 uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_14 <- _ret ] -{inv'6 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_13 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'4 (_13.current).current}
        MutBorrow.borrow_mut <t_UnionFind> {(_13.current).current}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_12 <- _ret ] -{inv'4 _ret.final}-
            [ &_13 <- { _13 with current = { _13.current with current = _ret.final } } ] s1)
      | s1 = {inv'4 _12.current}
        MutBorrow.borrow_final <t_UnionFind> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_11 <- _ret ] -{inv'4 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'8 _13} s3
      | s3 = -{resolve'0 _13}- s4
      | s4 = {[@expl:type invariant] inv'5 _12} s5
      | s5 = -{resolve'2 _12}- s6
      | s6 = {inv'4 _11.current}
        MutBorrow.borrow_final <t_UnionFind> {_11.current} {MutBorrow.get_id _11}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_10 <- _ret ] -{inv'4 _ret.final}-
            [ &_11 <- { _11 with current = _ret.final } ] s7)
      | s7 = new {_10} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_9 <- _ret ] s8)
      | s8 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'5 _11} s1
      | s1 = -{resolve'2 _11}- s2
      | s2 = find {_9} {e1} (fun (_ret: t_Element) -> [ &r1 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0 [ s0 = find {uf} {e2} (fun (_ret: t_Element) -> [ &r2 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = eq {r1} {r2} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind = uf
    | & e1: t_Element = e1
    | & e2: t_Element = e2
    | & r1: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _10: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _11: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _12: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _13: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _14: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & r2: t_Element = Any.any_l () ])
    [ return (result: bool) -> {[@expl:equiv ensures #0] result = (root uf.current e1 = root uf.current e2)}
      {[@expl:equiv ensures #1] unchanged uf}
      (! return {result}) ]
end
module M_union_find__implementation__link
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Element) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  let rec eq (self: t_Element) (other: t_Element) (return (x: bool)) = any
    [ return' (result: bool) -> {result = (deep_model'0 self = deep_model'0 other)} (! return {result}) ]
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant' [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_UnionFind) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_UnionFind) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = resolve'0 self
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_UnionFind) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'8 (_1: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'8 x]. inv'8 x = invariant''5 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] inv'7 self}
    any
    [ return' (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {inv'8 result} {result = self} (! return {result}) ]
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_UFInner) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'9 (_1: MutBorrow.t t_UFInner)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_UFInner [inv'9 x]. inv'9 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_UFInner) = inv'9 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'10 (_1: MutBorrow.t t_UFInner)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_UFInner [inv'10 x]. inv'10 x = invariant''7 x
  
  let rec new (x: MutBorrow.t t_UFInner) (return (x'0: MutBorrow.t t_UFInner)) =
    {[@expl:new 'x' type invariant] inv'9 x}
    any [ return' (result: MutBorrow.t t_UFInner) -> {inv'10 result} {result = x} (! return {result}) ]
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'11 (_1: MutBorrow.t (MutBorrow.t t_UFInner))
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UFInner) [inv'11 x]. inv'11 x = invariant''8 x
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'12 (_1: MutBorrow.t (MutBorrow.t t_UFInner))
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UFInner) [inv'12 x]. inv'12 x = invariant''9 x
  
  let rec deref_mut'0 (self: MutBorrow.t (MutBorrow.t t_UFInner)) (return (x: MutBorrow.t (MutBorrow.t t_UFInner))) =
    {[@expl:deref_mut 'self' type invariant] inv'11 self}
    any [ return' (result: MutBorrow.t (MutBorrow.t t_UFInner)) -> {inv'12 result} {result = self} (! return {result}) ]
  
  type tuple = { f0: MutBorrow.t t_PtrOwn; f1: MutBorrow.t t_FMap }
  
  predicate invariant''10 [@inline:trivial] (self: MutBorrow.t t_FMap) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'13 (_1: MutBorrow.t t_FMap)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'13 x]. inv'13 x = invariant''10 x
  
  predicate invariant''11 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'14 (_1: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'14 x]. inv'14 x = invariant''11 x
  
  predicate inv'15 (_1: tuple)
  
  axiom inv_axiom'15 [@rewrite]: forall x: tuple [inv'15 x]. inv'15 x
      = (let {f0 = x0; f1 = x1} = x in inv'14 x0 /\ inv'13 x1)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function remove (self: t_FMap) (k: t_Element) : t_FMap
  
  axiom remove_spec: forall self: t_FMap, k: t_Element. view (remove self k) = Map.set (view self) k (C_None)
  
  axiom remove_spec'0: forall self: t_FMap, k: t_Element. len (remove self k)
      = (if contains'0 self k then len self - 1 else len self)
  
  function insert (self: t_FMap) (k: t_Element) (v: t_PtrOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Element, v: t_PtrOwn. view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Element, v: t_PtrOwn. len (insert self k v)
      = (if contains'0 self k then len self else len self + 1)
  
  let rec split_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Element) (return (x: tuple)) =
    {[@expl:split_mut_ghost 'self' type invariant] inv'13 self}
    {[@expl:split_mut_ghost requires] contains'0 self.current key}
    any
    [ return' (result: tuple) -> {inv'15 result}
      {(result.f1).current = remove self.current key}
      {index_logic'0 self.current key = (result.f0).current
      /\ self.final = insert (result.f1).final key (result.f0).final}
      (! return {result}) ]
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner)) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate invariant''12 [@inline:trivial] (self: tuple) = inv'15 self
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'16 (_1: tuple)
  
  axiom inv_axiom'16 [@rewrite]: forall x: tuple [inv'16 x]. inv'16 x = invariant''12 x
  
  let rec new'0 (x: tuple) (return (x'0: tuple)) = {[@expl:new 'x' type invariant] inv'15 x}
    any [ return' (result: tuple) -> {inv'16 result} {result = x} (! return {result}) ]
  
  type tuple'0 = { f0'0: MutBorrow.t t_PtrOwn; f1'0: MutBorrow.t t_FMap }
  
  predicate invariant''13 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'14 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'17 (_1: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'17 x]. inv'17 x = invariant''13 x
  
  predicate invariant''14 [@inline:trivial] (self: MutBorrow.t t_FMap) = inv'13 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'18 (_1: MutBorrow.t t_FMap)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'18 x]. inv'18 x = invariant''14 x
  
  predicate inv'19 (_1: tuple'0)
  
  axiom inv_axiom'19 [@rewrite]: forall x: tuple'0 [inv'19 x]. inv'19 x
      = (let {f0'0 = x0; f1'0 = x1} = x in inv'17 x0 /\ inv'18 x1)
  
  let rec split (self: tuple) (return (x: tuple'0)) = {[@expl:split 'self' type invariant] inv'16 self}
    any
    [ return' (result: tuple'0) -> {inv'19 result} {self.f0 = result.f0'0} {self.f1 = result.f1'0} (! return {result}) ]
  
  predicate inv'20 (_1: t_T)
  
  predicate inv'21 (_1: t_Node)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Node [inv'21 x]. inv'21 x
      = match x with
        | C_Root rank payload -> inv'20 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''15 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'21 self.current /\ inv'21 self.final
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'22 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t t_Node [inv'22 x]. inv'22 x = invariant''15 x
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PtrOwn) : t_PtrOwn = self.final
  
  meta "rewrite_def" function fin
  
  let rec as_mut (ptr'0: Opaque.ptr) (own: MutBorrow.t t_PtrOwn) (return (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'own' type invariant] inv'17 own}
    {[@expl:as_mut requires] ptr'0 = ptr own.current}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'22 result}
      {result.current = val' own.current}
      {ptr (fin own) = ptr own.current}
      {val' (fin own) = result.final}
      (! return {result}) ]
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'5 _1
  
  meta "rewrite_def" predicate resolve'6
  
  predicate invariant''16 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap)) =
    inv'18 self.current /\ inv'18 self.final
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'23 (_1: MutBorrow.t (MutBorrow.t t_FMap))
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_FMap) [inv'23 x]. inv'23 x = invariant''16 x
  
  predicate invariant''17 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap)) =
    inv'13 self.current /\ inv'13 self.final
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'24 (_1: MutBorrow.t (MutBorrow.t t_FMap))
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_FMap) [inv'24 x]. inv'24 x = invariant''17 x
  
  let rec deref_mut'1 (self: MutBorrow.t (MutBorrow.t t_FMap)) (return (x: MutBorrow.t (MutBorrow.t t_FMap))) =
    {[@expl:deref_mut 'self' type invariant] inv'23 self}
    any [ return' (result: MutBorrow.t (MutBorrow.t t_FMap)) -> {inv'24 result} {result = self} (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_PtrOwn)
  
  predicate inv'25 (_1: t_Option'0)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_Option'0 [inv'25 x]. inv'25 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'14 a_0
        end
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Element) (return (x: t_Option'0)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv'13 self}
    any
    [ return' (result: t_Option'0) -> {inv'25 result}
      {if contains'0 self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains'0 self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {forall k: t_Element. k <> key -> get self.current k = get self.final k}
      {len self.current = len self.final}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] inv'25 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_PtrOwn) -> {inv'14 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate resolve'7 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap)) = resolve'7 _1
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'9
  
  predicate resolve'10 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = resolve'9 _1
  
  meta "rewrite_def" predicate resolve'10
  
  let rec new'1 (x: MutBorrow.t t_PtrOwn) (return (x'0: MutBorrow.t t_PtrOwn)) =
    {[@expl:new 'x' type invariant] inv'14 x}
    any [ return' (result: MutBorrow.t t_PtrOwn) -> {inv'17 result} {result = x} (! return {result}) ]
  
  let rec v_Root (input: t_Node) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {C_Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [C_Root rank payload: t_Node]. C_Root rank payload <> input}
      (! {false}
      any) ]
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_PeanoInt) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_1: MutBorrow.t t_PeanoInt) = resolve'11 _1
  
  meta "rewrite_def" predicate resolve'12
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'0 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'0
  
  let rec lt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = any
    [ return' (result: bool) -> {result = UInt64.lt (view'0 self) (view'0 other)} (! return {result}) ]
  
  predicate resolve'13 [@inline:trivial] (self: MutBorrow.t t_FMap) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'13
  
  predicate resolve'14 [@inline:trivial] (_1: MutBorrow.t t_FMap) = resolve'13 _1
  
  meta "rewrite_def" predicate resolve'14
  
  predicate resolve'15 [@inline:trivial] (self: MutBorrow.t t_FMap) = resolve'14 self
  
  meta "rewrite_def" predicate resolve'15
  
  predicate resolve'16 [@inline:trivial] (_1: MutBorrow.t t_FMap) = resolve'15 _1
  
  meta "rewrite_def" predicate resolve'16
  
  predicate resolve'17 [@inline:trivial] (self: MutBorrow.t t_UFInner) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'17
  
  predicate resolve'18 [@inline:trivial] (_1: MutBorrow.t t_UFInner) = resolve'17 _1
  
  meta "rewrite_def" predicate resolve'18
  
  predicate resolve'19 [@inline:trivial] (self: MutBorrow.t t_UFInner) = resolve'18 self
  
  meta "rewrite_def" predicate resolve'19
  
  predicate resolve'20 [@inline:trivial] (_1: MutBorrow.t t_UFInner) = resolve'19 _1
  
  meta "rewrite_def" predicate resolve'20
  
  predicate resolve'21 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'21
  
  predicate resolve'22 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve'21 _1
  
  meta "rewrite_def" predicate resolve'22
  
  let rec new'2 (x: ()) (return (x'0: ())) = any [ return' (result: ()) -> {result = x} (! return {result}) ]
  
  let rec eq'0 (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = any
    [ return' (result: bool) -> {result = (self = other)} (! return {result}) ]
  
  let rec incr (self: t_PeanoInt) (return (x: t_PeanoInt)) = any
    [ return' (result: t_PeanoInt) -> {UInt64.t'int result.t_PeanoInt__0 = UInt64.t'int self.t_PeanoInt__0 + 1}
      (! return {result}) ]
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains (domain self) e
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element = (self.t_UnionFind__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root (self: t_UnionFind) (e: t_Element) : t_Element = index_logic'1 (roots_map self) e
  
  predicate domain_unchanged (self: MutBorrow.t t_UnionFind) = domain self.current = domain self.final
  
  function payloads_map (self: t_UnionFind) : Map.map t_Element t_T = (self.t_UnionFind__0).t_UFInner__payloads
  
  predicate payloads_unchanged (self: MutBorrow.t t_UnionFind) = payloads_map self.current = payloads_map self.final
  
  function fin'0 [@inline:trivial] (self: MutBorrow.t t_UnionFind) : t_UnionFind = self.final
  
  meta "rewrite_def" function fin'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec link (uf: MutBorrow.t t_UnionFind) (x: t_Element) (y: t_Element) (return (x'0: t_Element)) =
    {[@expl:link 'uf' type invariant] inv'6 uf}
    {[@expl:link requires #0] in_domain uf.current x /\ in_domain uf.current y}
    {[@expl:link requires #1] root uf.current x = x /\ root uf.current y = y}
    (! bb0
    [ bb0 = s0 [ s0 = eq {x} {y} (fun (_ret: bool) -> [ &_11 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_11 = false} (! bb3) | br1 -> {_11} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'6 uf} s1 | s1 = -{resolve'2 uf}- s2 | s2 = [ &_0 <- x ] s3 | s3 = bb51 ]
    | bb3 = s0
      [ s0 = {inv'6 uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_17 <- _ret ] -{inv'6 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut {_17} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_16 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv'3 ((_16.current).current).t_UnionFind__0}
        MutBorrow.borrow_mut <t_UFInner> {((_16.current).current).t_UnionFind__0}
          (fun (_ret: MutBorrow.t t_UFInner) ->
            [ &__temp <- _ret ] -{inv'3 _ret.final}-
            [ &_16 <- { _16 with current = { _16.current with current = { t_UnionFind__0 = _ret.final } } } ] s1)
      | s1 = new {__temp} (fun (_ret: MutBorrow.t t_UFInner) -> [ &uf'0 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'10 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_27 <- _ret ] -{inv'10 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_27} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_26 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_29 <- x ] s1
      | s1 = {inv'2 ((_26.current).current).t_UFInner__perms}
        MutBorrow.borrow_mut <t_FMap> {((_26.current).current).t_UFInner__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_25 <- _ret ] -{inv'2 _ret.final}-
            [ &_26 <- { _26 with current = { _26.current with current = { (_26.current).current with t_UFInner__perms = _ret.final } } } ]
            s2)
      | s2 = split_mut_ghost {_25} {_29} (fun (_ret: tuple) -> [ &_24 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'12 _26} s1
      | s1 = -{resolve'4 _26}- s2
      | s2 = new'0 {_24} (fun (_ret: tuple) -> [ &_23 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = s0 [ s0 = split {_23} (fun (_ret: tuple'0) -> [ &_22 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &perm_x <- _22.f0'0 ] s1
      | s1 = [ &m <- _22.f1'0 ] s2
      | s2 = as_mut {x.t_Element__0} {perm_x} (fun (_ret: MutBorrow.t t_Node) -> [ &_31 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'21 _31.current}
        MutBorrow.borrow_final <t_Node> {_31.current} {MutBorrow.get_id _31}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &bx <- _ret ] -{inv'21 _ret.final}-
            [ &_31 <- { _31 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'22 _31} s2
      | s2 = -{resolve'6 _31}- s3
      | s3 = {inv'18 m}
        MutBorrow.borrow_mut <MutBorrow.t t_FMap> {m}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap)) ->
            [ &_44 <- _ret ] -{inv'18 _ret.final}-
            [ &m <- _ret.final ] s4)
      | s4 = deref_mut'1 {_44} (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap)) -> [ &_43 <- _ret ] s5)
      | s5 = bb11 ]
    | bb11 = s0
      [ s0 = [ &_46 <- y ] s1
      | s1 = {inv'2 (_43.current).current}
        MutBorrow.borrow_mut <t_FMap> {(_43.current).current}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_42 <- _ret ] -{inv'2 _ret.final}-
            [ &_43 <- { _43 with current = { _43.current with current = _ret.final } } ] s2)
      | s2 = get_mut_ghost {_42} {_46} (fun (_ret: t_Option'0) -> [ &_41 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_41} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_40 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = {inv'1 _40.current}
        MutBorrow.borrow_final <t_PtrOwn> {_40.current} {MutBorrow.get_id _40}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_39 <- _ret ] -{inv'1 _ret.final}-
            [ &_40 <- { _40 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'24 _43} s2
      | s2 = -{resolve'8 _43}- s3
      | s3 = {[@expl:type invariant] inv'14 _40} s4
      | s4 = -{resolve'10 _40}- s5
      | s5 = {inv'1 _39.current}
        MutBorrow.borrow_final <t_PtrOwn> {_39.current} {MutBorrow.get_id _39}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_38 <- _ret ] -{inv'1 _ret.final}-
            [ &_39 <- { _39 with current = _ret.final } ] s6)
      | s6 = new'1 {_38} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_37 <- _ret ] s7)
      | s7 = bb14 ]
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'14 _39} s1
      | s1 = -{resolve'10 _39}- s2
      | s2 = as_mut {y.t_Element__0} {_37} (fun (_ret: MutBorrow.t t_Node) -> [ &_35 <- _ret ] s3)
      | s3 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'21 _35.current}
        MutBorrow.borrow_final <t_Node> {_35.current} {MutBorrow.get_id _35}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &by' <- _ret ] -{inv'21 _ret.final}-
            [ &_35 <- { _35 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'22 _35} s2
      | s2 = -{resolve'6 _35}- s3
      | s3 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {bx.current = C_Root x0 x1} (! bb18)
        | br1 (x0: t_Element) -> {bx.current = C_Link x0} (! bb16) ] ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'22 by'} s1
      | s1 = -{resolve'6 by'}- s2
      | s2 = {[@expl:type invariant] inv'22 bx} s3
      | s3 = -{resolve'6 bx}- s4
      | s4 = {false} any ]
    | bb18 = s0
      [ s0 = v_Root {bx.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &rx <- _ret ] [ &bx <- { bx with current = C_Root _ret.final rpayload } ] s1))
      | s1 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {by'.current = C_Root x0 x1} (! bb21)
        | br1 (x0: t_Element) -> {by'.current = C_Link x0} (! bb19) ] ]
    | bb19 = s0
      [ s0 = -{resolve'12 rx}- s1
      | s1 = {[@expl:type invariant] inv'22 by'} s2
      | s2 = -{resolve'6 by'}- s3
      | s3 = {false} any ]
    | bb21 = s0
      [ s0 = v_Root {by'.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &ry <- _ret ] [ &by' <- { by' with current = C_Root _ret.final rpayload } ] s1))
      | s1 = lt {rx.current} {ry.current} (fun (_ret: bool) -> [ &_53 <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = any [ br0 -> {_53 = false} (! bb34) | br1 -> {_53} (! bb23) ]
    | bb23 = s0
      [ s0 = -{resolve'12 ry}- s1
      | s1 = -{resolve'12 rx}- s2
      | s2 = {[@expl:type invariant] inv'22 by'} s3
      | s3 = -{resolve'6 by'}- s4
      | s4 = {[@expl:type invariant] inv'18 m} s5
      | s5 = -{resolve'16 m}- s6
      | s6 = [ &_56 <- C_Link y ] s7
      | s7 = bb24 ]
    | bb24 = s0
      [ s0 = {[@expl:type invariant] inv'21 bx.current} s1
      | s1 = [ &bx <- { bx with current = _56 } ] s2
      | s2 = {[@expl:type invariant] inv'22 bx} s3
      | s3 = -{resolve'6 bx}- s4
      | s4 = bb26 ]
    | bb26 = s0
      [ s0 = [ &_60 <- fun (z: t_Element) -> if index_logic'1 (uf'0.current).t_UFInner__roots z = x then
          y
        else
          index_logic'1 (uf'0.current).t_UFInner__roots z
         ] s1
      | s1 = bb27 ]
    | bb27 = s0
      [ s0 = {inv'10 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_63 <- _ret ] -{inv'10 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_63} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_62 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0
      [ s0 =
        [ &_62 <- { _62 with current = { _62.current with current = { (_62.current).current with t_UFInner__roots = _60 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'12 _62} s2
      | s2 = -{resolve'4 _62}- s3
      | s3 = [ &_64 <- (uf'0.current).t_UFInner__max_depth + 1 ] s4
      | s4 = bb29 ]
    | bb29 = s0
      [ s0 = {inv'10 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_67 <- _ret ] -{inv'10 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_67} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_66 <- _ret ] s2)
      | s2 = bb30 ]
    | bb30 = s0
      [ s0 =
        [ &_66 <- { _66 with current = { _66.current with current = { (_66.current).current with t_UFInner__max_depth = _64 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'12 _66} s2
      | s2 = -{resolve'4 _66}- s3
      | s3 = [ &_68 <- Map.set (uf'0.current).t_UFInner__depth y (1
        + MinMax.max (index_logic'3 (uf'0.current).t_UFInner__depth x) (index_logic'3 (uf'0.current).t_UFInner__depth y)) ]
        s4
      | s4 = bb31 ]
    | bb31 = s0
      [ s0 = {inv'10 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_71 <- _ret ] -{inv'10 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_71} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_70 <- _ret ] s2)
      | s2 = bb32 ]
    | bb32 = s0
      [ s0 =
        [ &_70 <- { _70 with current = { _70.current with current = { (_70.current).current with t_UFInner__depth = _68 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'12 _70} s2
      | s2 = -{resolve'4 _70}- s3
      | s3 = {[@expl:type invariant] inv'10 uf'0} s4
      | s4 = -{resolve'20 uf'0}- s5
      | s5 = {[@expl:type invariant] inv'8 _16} s6
      | s6 = -{resolve'22 _16}- s7
      | s7 = {[@expl:type invariant] inv'6 uf} s8
      | s8 = -{resolve'2 uf}- s9
      | s9 = new'2 {_59} (fun (_ret: ()) -> [ &_58 <- _ret ] s10)
      | s10 = bb33 ]
    | bb33 = s0 [ s0 = [ &_0 <- y ] s1 | s1 = bb51 ]
    | bb34 = s0
      [ s0 = -{resolve'12 ry}- s1
      | s1 = eq'0 {rx.current} {ry.current} (fun (_ret: bool) -> [ &_73 <- _ret ] s2)
      | s2 = bb35 ]
    | bb35 = any [ br0 -> {_73 = false} (! bb38) | br1 -> {_73} (! bb36) ]
    | bb36 = s0
      [ s0 = -{resolve'12 rx}- s1 | s1 = incr {rx.current} (fun (_ret: t_PeanoInt) -> [ &_76 <- _ret ] s2) | s2 = bb37 ]
    | bb37 = s0 [ s0 = {[@expl:type invariant] inv'22 bx} s1 | s1 = -{resolve'6 bx}- s2 | s2 = bb39 ]
    | bb38 = s0
      [ s0 = -{resolve'12 rx}- s1 | s1 = {[@expl:type invariant] inv'22 bx} s2 | s2 = -{resolve'6 bx}- s3 | s3 = bb39 ]
    | bb39 = s0 [ s0 = [ &_78 <- C_Link x ] s1 | s1 = bb40 ]
    | bb40 = s0
      [ s0 = {[@expl:type invariant] inv'21 by'.current} s1
      | s1 = [ &by' <- { by' with current = _78 } ] s2
      | s2 = {[@expl:type invariant] inv'22 by'} s3
      | s3 = -{resolve'6 by'}- s4
      | s4 = {[@expl:type invariant] inv'18 m} s5
      | s5 = -{resolve'16 m}- s6
      | s6 = bb42 ]
    | bb42 = s0
      [ s0 = [ &_82 <- fun (z: t_Element) -> if index_logic'1 (uf'0.current).t_UFInner__roots z = y then
          x
        else
          index_logic'1 (uf'0.current).t_UFInner__roots z
         ] s1
      | s1 = bb43 ]
    | bb43 = s0
      [ s0 = {inv'10 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_85 <- _ret ] -{inv'10 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_85} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_84 <- _ret ] s2)
      | s2 = bb44 ]
    | bb44 = s0
      [ s0 =
        [ &_84 <- { _84 with current = { _84.current with current = { (_84.current).current with t_UFInner__roots = _82 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'12 _84} s2
      | s2 = -{resolve'4 _84}- s3
      | s3 = [ &_86 <- (uf'0.current).t_UFInner__max_depth + 1 ] s4
      | s4 = bb45 ]
    | bb45 = s0
      [ s0 = {inv'10 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_89 <- _ret ] -{inv'10 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_89} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_88 <- _ret ] s2)
      | s2 = bb46 ]
    | bb46 = s0
      [ s0 =
        [ &_88 <- { _88 with current = { _88.current with current = { (_88.current).current with t_UFInner__max_depth = _86 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'12 _88} s2
      | s2 = -{resolve'4 _88}- s3
      | s3 = [ &_90 <- Map.set (uf'0.current).t_UFInner__depth x (1
        + MinMax.max (index_logic'3 (uf'0.current).t_UFInner__depth x) (index_logic'3 (uf'0.current).t_UFInner__depth y)) ]
        s4
      | s4 = bb47 ]
    | bb47 = s0
      [ s0 = {inv'10 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_93 <- _ret ] -{inv'10 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_93} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_92 <- _ret ] s2)
      | s2 = bb48 ]
    | bb48 = s0
      [ s0 =
        [ &_92 <- { _92 with current = { _92.current with current = { (_92.current).current with t_UFInner__depth = _90 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'12 _92} s2
      | s2 = -{resolve'4 _92}- s3
      | s3 = {[@expl:type invariant] inv'10 uf'0} s4
      | s4 = -{resolve'20 uf'0}- s5
      | s5 = {[@expl:type invariant] inv'8 _16} s6
      | s6 = -{resolve'22 _16}- s7
      | s7 = {[@expl:type invariant] inv'6 uf} s8
      | s8 = -{resolve'2 uf}- s9
      | s9 = new'2 {_81} (fun (_ret: ()) -> [ &_80 <- _ret ] s10)
      | s10 = bb49 ]
    | bb49 = s0 [ s0 = [ &_0 <- x ] s1 | s1 = bb51 ]
    | bb51 = return {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind = uf
    | & x: t_Element = x
    | & y: t_Element = y
    | & _11: bool = Any.any_l ()
    | & __temp: MutBorrow.t t_UFInner = Any.any_l ()
    | & _16: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _17: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & uf'0: MutBorrow.t t_UFInner = Any.any_l ()
    | & perm_x: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & m: MutBorrow.t t_FMap = Any.any_l ()
    | & _22: tuple'0 = Any.any_l ()
    | & _23: tuple = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & _25: MutBorrow.t t_FMap = Any.any_l ()
    | & _26: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _27: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _29: t_Element = Any.any_l ()
    | & bx: MutBorrow.t t_Node = Any.any_l ()
    | & _31: MutBorrow.t t_Node = Any.any_l ()
    | & by': MutBorrow.t t_Node = Any.any_l ()
    | & _35: MutBorrow.t t_Node = Any.any_l ()
    | & _37: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _38: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _39: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _40: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _41: t_Option'0 = Any.any_l ()
    | & _42: MutBorrow.t t_FMap = Any.any_l ()
    | & _43: MutBorrow.t (MutBorrow.t t_FMap) = Any.any_l ()
    | & _44: MutBorrow.t (MutBorrow.t t_FMap) = Any.any_l ()
    | & _46: t_Element = Any.any_l ()
    | & rx: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & ry: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _53: bool = Any.any_l ()
    | & _56: t_Node = Any.any_l ()
    | & _58: () = Any.any_l ()
    | & _59: () = Any.any_l ()
    | & _60: Map.map t_Element t_Element = Any.any_l ()
    | & _62: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _63: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _64: int = Any.any_l ()
    | & _66: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _67: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _68: Map.map t_Element int = Any.any_l ()
    | & _70: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _71: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _73: bool = Any.any_l ()
    | & _76: t_PeanoInt = Any.any_l ()
    | & _78: t_Node = Any.any_l ()
    | & _80: () = Any.any_l ()
    | & _81: () = Any.any_l ()
    | & _82: Map.map t_Element t_Element = Any.any_l ()
    | & _84: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _85: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _86: int = Any.any_l ()
    | & _88: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _89: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _90: Map.map t_Element int = Any.any_l ()
    | & _92: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _93: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l () ])
    [ return (result: t_Element) -> {[@expl:link ensures #0] domain_unchanged uf /\ payloads_unchanged uf}
      {[@expl:link ensures #1] result = root uf.current x \/ result = root uf.current y}
      {[@expl:link ensures #2] result = root (fin'0 uf) result}
      {[@expl:link ensures #3] forall z: t_Element. in_domain uf.current z
        -> root (fin'0 uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return {result}) ]
end
module M_union_find__implementation__union
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate invariant' [@inline:trivial] (self: t_UnionFind) =
    (forall e1: t_Element, e2: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e1
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains (self.t_UnionFind__0).t_UFInner__domain e
      -> contains'0 (self.t_UnionFind__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) = e.t_Element__0
      /\ contains (self.t_UnionFind__0).t_UFInner__domain (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots (index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e <> e
          /\ contains (self.t_UnionFind__0).t_UFInner__domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e2
          | C_Root _ payload -> index_logic'1 (self.t_UnionFind__0).t_UFInner__roots e = e
          /\ index_logic'2 (self.t_UnionFind__0).t_UFInner__payloads e = payload
          end
      /\ match val' (index_logic'0 (self.t_UnionFind__0).t_UFInner__perms e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e
          < index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e2
          | C_Root _ _ -> true
          end
      /\ index_logic'3 (self.t_UnionFind__0).t_UFInner__depth e <= (self.t_UnionFind__0).t_UFInner__max_depth)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains'0 self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'8 (_1: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'8 x]. inv'8 x = invariant''5 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] inv'7 self}
    any
    [ return' (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {inv'8 result} {result = self} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_UnionFind) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  let rec new (x: MutBorrow.t t_UnionFind) (return (x'0: MutBorrow.t t_UnionFind)) =
    {[@expl:new 'x' type invariant] inv'5 x}
    any [ return' (result: MutBorrow.t t_UnionFind) -> {inv'6 result} {result = x} (! return {result}) ]
  
  function domain (self: t_UnionFind) : Fset.fset t_Element = (self.t_UnionFind__0).t_UFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains (domain self) e
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element = (self.t_UnionFind__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root (self: t_UnionFind) (e: t_Element) : t_Element = index_logic'1 (roots_map self) e
  
  function payloads_map (self: t_UnionFind) : Map.map t_Element t_T = (self.t_UnionFind__0).t_UFInner__payloads
  
  predicate unchanged (self: MutBorrow.t t_UnionFind) =
    domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  let rec find (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find 'uf' type invariant] inv'6 uf}
    {[@expl:find requires] in_domain uf.current elem}
    any [ return' (result: t_Element) -> {result = root uf.current elem} {unchanged uf} (! return {result}) ]
  
  predicate domain_unchanged (self: MutBorrow.t t_UnionFind) = domain self.current = domain self.final
  
  predicate payloads_unchanged (self: MutBorrow.t t_UnionFind) = payloads_map self.current = payloads_map self.final
  
  function fin [@inline:trivial] (self: MutBorrow.t t_UnionFind) : t_UnionFind = self.final
  
  meta "rewrite_def" function fin
  
  let rec link (uf: MutBorrow.t t_UnionFind) (x: t_Element) (y: t_Element) (return (x'0: t_Element)) =
    {[@expl:link 'uf' type invariant] inv'6 uf}
    {[@expl:link requires #0] in_domain uf.current x /\ in_domain uf.current y}
    {[@expl:link requires #1] root uf.current x = x /\ root uf.current y = y}
    any
    [ return' (result: t_Element) -> {domain_unchanged uf /\ payloads_unchanged uf}
      {result = root uf.current x \/ result = root uf.current y}
      {result = root (fin uf) result}
      {forall z: t_Element. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec union (uf: MutBorrow.t t_UnionFind) (x: t_Element) (y: t_Element) (return (x'0: t_Element)) =
    {[@expl:union 'uf' type invariant] inv'6 uf}
    {[@expl:union requires] in_domain uf.current x /\ in_domain uf.current y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'6 uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_14 <- _ret ] -{inv'6 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_13 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'4 (_13.current).current}
        MutBorrow.borrow_mut <t_UnionFind> {(_13.current).current}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_12 <- _ret ] -{inv'4 _ret.final}-
            [ &_13 <- { _13 with current = { _13.current with current = _ret.final } } ] s1)
      | s1 = {inv'4 _12.current}
        MutBorrow.borrow_final <t_UnionFind> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_11 <- _ret ] -{inv'4 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'8 _13} s3
      | s3 = -{resolve'0 _13}- s4
      | s4 = {[@expl:type invariant] inv'5 _12} s5
      | s5 = -{resolve'2 _12}- s6
      | s6 = {inv'4 _11.current}
        MutBorrow.borrow_final <t_UnionFind> {_11.current} {MutBorrow.get_id _11}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_10 <- _ret ] -{inv'4 _ret.final}-
            [ &_11 <- { _11 with current = _ret.final } ] s7)
      | s7 = new {_10} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_9 <- _ret ] s8)
      | s8 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'5 _11} s1
      | s1 = -{resolve'2 _11}- s2
      | s2 = find {_9} {x} (fun (_ret: t_Element) -> [ &rx <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'6 uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_22 <- _ret ] -{inv'6 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut {_22} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_21 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv'4 (_21.current).current}
        MutBorrow.borrow_mut <t_UnionFind> {(_21.current).current}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_20 <- _ret ] -{inv'4 _ret.final}-
            [ &_21 <- { _21 with current = { _21.current with current = _ret.final } } ] s1)
      | s1 = {inv'4 _20.current}
        MutBorrow.borrow_final <t_UnionFind> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_19 <- _ret ] -{inv'4 _ret.final}-
            [ &_20 <- { _20 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'8 _21} s3
      | s3 = -{resolve'0 _21}- s4
      | s4 = {[@expl:type invariant] inv'5 _20} s5
      | s5 = -{resolve'2 _20}- s6
      | s6 = {inv'4 _19.current}
        MutBorrow.borrow_final <t_UnionFind> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_18 <- _ret ] -{inv'4 _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s7)
      | s7 = new {_18} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_17 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'5 _19} s1
      | s1 = -{resolve'2 _19}- s2
      | s2 = find {_17} {y} (fun (_ret: t_Element) -> [ &ry <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = link {uf} {rx} {ry} (fun (_ret: t_Element) -> [ &_0 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind = uf
    | & x: t_Element = x
    | & y: t_Element = y
    | & rx: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _10: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _11: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _12: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _13: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _14: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & ry: t_Element = Any.any_l ()
    | & _17: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _18: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _19: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _20: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _22: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l () ])
    [ return (result: t_Element) -> {[@expl:union ensures #0] domain_unchanged uf /\ payloads_unchanged uf}
      {[@expl:union ensures #1] result = root uf.current x \/ result = root uf.current y}
      {[@expl:union ensures #2] forall z: t_Element. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return {result}) ]
end
module M_union_find__example
  use creusot.prelude.Opaque
  use set.Fset
  use creusot.int.Int32
  use map.Map
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element Int32.t;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate invariant' (self: t_UnionFind)
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt Int32.t | C_Link t_Element
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : t_Node
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_UnionFind) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  function deep_model (self: t_Element) : UInt64.t
  
  function domain (self: t_UnionFind) : Fset.fset t_Element
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
          /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  let rec new (return (x: t_UnionFind)) = any
    [ return' (result: t_UnionFind) -> {inv'5 result} {Fset.is_empty (domain result)} (! return {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_UnionFind) = inv'7 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'8 (_1: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  let rec borrow_mut (self: MutBorrow.t t_UnionFind) (return (x: MutBorrow.t t_UnionFind)) =
    {[@expl:borrow_mut 'self' type invariant] inv'6 self}
    any [ return' (result: MutBorrow.t t_UnionFind) -> {inv'8 result} {result = self} (! return {result}) ]
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains'0 (domain self) e
  
  function fin [@inline:trivial] (self: MutBorrow.t t_UnionFind) : t_UnionFind = self.final
  
  meta "rewrite_def" function fin
  
  function insert [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) : Fset.fset t_Element = Fset.add e self
  
  meta "rewrite_def" function insert
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function roots_map (self: t_UnionFind) : Map.map t_Element t_Element
  
  axiom roots_map_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function payloads_map (self: t_UnionFind) : Map.map t_Element Int32.t
  
  let rec make (uf: MutBorrow.t t_UnionFind) (payload: Int32.t) (return (x: t_Element)) =
    {[@expl:make 'uf' type invariant] inv'8 uf}
    any
    [ return' (result: t_Element) -> {not in_domain uf.current result}
      {domain (fin uf) = insert (domain uf.current) result}
      {roots_map (fin uf) = Map.set (roots_map uf.current) result result}
      {payloads_map (fin uf) = Map.set (payloads_map uf.current) result payload}
      (! return {result}) ]
  
  predicate invariant''6 [@inline:trivial] (self: t_UnionFind) = inv'5 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'9 (_1: t_UnionFind)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_UnionFind [inv'9 x]. inv'9 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: t_UnionFind) = inv'4 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'10 (_1: t_UnionFind)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_UnionFind [inv'10 x]. inv'10 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: t_UnionFind) = inv'10 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'11 (_1: t_UnionFind)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_UnionFind [inv'11 x]. inv'11 x = invariant''8 x
  
  let rec borrow (self: t_UnionFind) (return (x: t_UnionFind)) = {[@expl:borrow 'self' type invariant] inv'9 self}
    any [ return' (result: t_UnionFind) -> {inv'11 result} {result = self} (! return {result}) ]
  
  function root (self: t_UnionFind) (e: t_Element) : t_Element = index_logic'1 (roots_map self) e
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Element Int32.t) (a: t_Element) : Int32.t = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function payload (self: t_UnionFind) (e: t_Element) : Int32.t = index_logic'2 (payloads_map self) e
  
  let rec get'0 (uf: t_UnionFind) (elem: t_Element) (return (x: Int32.t)) = {[@expl:get 'uf' type invariant] inv'11 uf}
    {[@expl:get requires #0] in_domain uf elem}
    {[@expl:get requires #1] root uf elem = elem}
    any [ return' (result: Int32.t) -> {result = payload uf elem} (! return {result}) ]
  
  predicate domain_unchanged (self: MutBorrow.t t_UnionFind) = domain self.current = domain self.final
  
  predicate payloads_unchanged (self: MutBorrow.t t_UnionFind) = payloads_map self.current = payloads_map self.final
  
  let rec union (uf: MutBorrow.t t_UnionFind) (x: t_Element) (y: t_Element) (return (x'0: t_Element)) =
    {[@expl:union 'uf' type invariant] inv'8 uf}
    {[@expl:union requires] in_domain uf.current x /\ in_domain uf.current y}
    any
    [ return' (result: t_Element) -> {domain_unchanged uf /\ payloads_unchanged uf}
      {result = root uf.current x \/ result = root uf.current y}
      {forall z: t_Element. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return {result}) ]
  
  predicate unchanged (self: MutBorrow.t t_UnionFind) =
    domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  let rec equiv (uf: MutBorrow.t t_UnionFind) (e1: t_Element) (e2: t_Element) (return (x: bool)) =
    {[@expl:equiv 'uf' type invariant] inv'8 uf}
    {[@expl:equiv requires #0] in_domain uf.current e1}
    {[@expl:equiv requires #1] in_domain uf.current e2}
    any
    [ return' (result: bool) -> {result = (root uf.current e1 = root uf.current e2)}
      {unchanged uf}
      (! return {result}) ]
  
  let rec find (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find 'uf' type invariant] inv'8 uf}
    {[@expl:find requires] in_domain uf.current elem}
    any [ return' (result: t_Element) -> {result = root uf.current elem} {unchanged uf} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new (fun (_ret: t_UnionFind) -> [ &uf <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'5 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_4 <- _ret ] -{inv'5 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_4} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_3 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = make {_3} {(1: Int32.t)} (fun (_ret: t_Element) -> [ &x <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'5 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_7 <- _ret ] -{inv'5 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_7} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_6 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = make {_6} {(2: Int32.t)} (fun (_ret: t_Element) -> [ &y <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'5 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_10 <- _ret ] -{inv'5 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_10} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_9 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = make {_9} {(3: Int32.t)} (fun (_ret: t_Element) -> [ &z <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_15 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = get'0 {_15} {x} (fun (_ret: Int32.t) -> [ &_14 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_12 <- _14 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] ]
    | bb10 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_23 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = get'0 {_23} {y} (fun (_ret: Int32.t) -> [ &_22 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_20 <- _22 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_20 = false} (! bb15) | br1 -> {_20} (! bb14) ] ]
    | bb14 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_31 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = s0 [ s0 = get'0 {_31} {z} (fun (_ret: Int32.t) -> [ &_30 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_28 <- _30 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_28 = false} (! bb19) | br1 -> {_28} (! bb18) ] ]
    | bb18 = s0
      [ s0 = {inv'5 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_37 <- _ret ] -{inv'5 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_37} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_36 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = union {_36} {x} {y} (fun (_ret: t_Element) -> [ &_35 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = s0
      [ s0 = {inv'5 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_43 <- _ret ] -{inv'5 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_43} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_42 <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = s0 [ s0 = equiv {_42} {x} {y} (fun (_ret: bool) -> [ &_41 <- _ret ] s1) | s1 = bb23 ]
    | bb23 = any [ br0 -> {_41 = false} (! bb25) | br1 -> {_41} (! bb24) ]
    | bb24 = s0
      [ s0 = {inv'5 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_49 <- _ret ] -{inv'5 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_49} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_48 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = s0 [ s0 = find {_48} {x} (fun (_ret: t_Element) -> [ &xr <- _ret ] s1) | s1 = bb27 ]
    | bb27 = s0
      [ s0 = {inv'5 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_53 <- _ret ] -{inv'5 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_53} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_52 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0 [ s0 = find {_52} {y} (fun (_ret: t_Element) -> [ &yr <- _ret ] s1) | s1 = bb29 ]
    | bb29 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_59 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0 [ s0 = get'0 {_59} {xr} (fun (_ret: Int32.t) -> [ &_58 <- _ret ] s1) | s1 = bb31 ]
    | bb31 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_64 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0 [ s0 = get'0 {_64} {yr} (fun (_ret: Int32.t) -> [ &_63 <- _ret ] s1) | s1 = bb33 ]
    | bb33 = s0 [ s0 = [ &_56 <- _58 = _63 ] s1 | s1 = any [ br0 -> {_56 = false} (! bb35) | br1 -> {_56} (! bb34) ] ]
    | bb34 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_72 <- _ret ] s1) | s1 = bb36 ]
    | bb36 = s0 [ s0 = get'0 {_72} {z} (fun (_ret: Int32.t) -> [ &_71 <- _ret ] s1) | s1 = bb37 ]
    | bb37 = s0
      [ s0 = [ &_69 <- _71 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_69 = false} (! bb39) | br1 -> {_69} (! bb38) ] ]
    | bb38 = return {_0}
    | bb39 = {false} any
    | bb35 = {false} any
    | bb25 = {false} any
    | bb19 = {false} any
    | bb15 = {false} any
    | bb11 = {false} any ]
    [ & _0: () = Any.any_l ()
    | & uf: t_UnionFind = Any.any_l ()
    | & x: t_Element = Any.any_l ()
    | & _3: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _4: MutBorrow.t t_UnionFind = Any.any_l ()
    | & y: t_Element = Any.any_l ()
    | & _6: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _7: MutBorrow.t t_UnionFind = Any.any_l ()
    | & z: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _10: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _15: t_UnionFind = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _23: t_UnionFind = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: Int32.t = Any.any_l ()
    | & _31: t_UnionFind = Any.any_l ()
    | & _35: t_Element = Any.any_l ()
    | & _36: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _37: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _41: bool = Any.any_l ()
    | & _42: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _43: MutBorrow.t t_UnionFind = Any.any_l ()
    | & xr: t_Element = Any.any_l ()
    | & _48: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _49: MutBorrow.t t_UnionFind = Any.any_l ()
    | & yr: t_Element = Any.any_l ()
    | & _52: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _53: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: Int32.t = Any.any_l ()
    | & _59: t_UnionFind = Any.any_l ()
    | & _63: Int32.t = Any.any_l ()
    | & _64: t_UnionFind = Any.any_l ()
    | & _69: bool = Any.any_l ()
    | & _71: Int32.t = Any.any_l ()
    | & _72: t_UnionFind = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_union_find__example_addrs_eq
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  use set.Fset
  use map.Map
  use creusot.prelude.Ptr
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  function deep_model (self: t_Element) : UInt64.t
  
  function deep_model'0 [@inline:trivial] (self: t_Element) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  let rec eq (self: t_Element) (other: t_Element) (return (x: bool)) = any
    [ return' (result: bool) -> {result = (deep_model'0 self = deep_model'0 other)} (! return {result}) ]
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Element;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Element t_T;
    t_UFInner__roots: Map.map t_Element t_Element;
    t_UFInner__depth: Map.map t_Element int;
    t_UFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_UFInner }
  
  predicate invariant' (self: t_UnionFind)
  
  type t_PtrOwn
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Element t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Element) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Element) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_Element)
  
  axiom inv_axiom [@rewrite]: forall x: t_Element [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Element
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : t_Node
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv'0 (_1: Opaque.ptr)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Opaque.ptr [inv'0 x]. inv'0 x = true
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv'0 (ptr self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. (exists x: t_PtrOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Element) : t_PtrOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Element) : t_PtrOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_Element. contains self k -> inv k /\ inv'1 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_1: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_UFInner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UFInner [inv'3 x]. inv'3 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots; t_UFInner__depth = depth; t_UFInner__max_depth = max_depth} -> inv'2 perms
        end
  
  predicate inv'4 (_1: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'3 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_UnionFind) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  function domain (self: t_UnionFind) : Fset.fset t_Element
  
  axiom domain_spec: forall self: t_UnionFind. inv'4 self
      -> (forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
          /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain (self: t_UnionFind) (e: t_Element) = contains'0 (domain self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example_addrs_eq (uf: t_UnionFind) (e1: t_Element) (e2: t_Element) (return (x: ())) =
    {[@expl:example_addrs_eq 'uf' type invariant] inv'5 uf}
    {[@expl:example_addrs_eq requires] in_domain uf e1 /\ in_domain uf e2}
    (! bb0
    [ bb0 = s0 [ s0 = eq {e1} {e2} (fun (_ret: bool) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb2) ]
    | bb2 = s0 [ s0 = {[@expl:assertion] e1 = e2} s1 | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: () = Any.any_l () | & e1: t_Element = e1 | & e2: t_Element = e2 | & _5: bool = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_union_find__implementation__qyi17232405883558456141__eq__refines (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  function deep_model [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.t_Element__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Element) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Element. forall rhs: t_Element. forall result: bool. result
            = (deep_model'0 self_ = deep_model'0 rhs) -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
