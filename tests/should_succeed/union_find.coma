module M_union_find__implementation__qyi17232405883558456141__eq [#"union_find.rs" 18 8 18 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find = "union_find.rs" 17 18 17 69
  let%span sunion_find'0 = "union_find.rs" 24 8 24 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 109 22 109 66
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  let rec addr_eq (p: Opaque.ptr) (q: Opaque.ptr) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#sptr] result = (addr_logic p = addr_logic q)} (! return' {result}) ]
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'0] addr_logic self.t_Element__0
  
  function deep_model'0 (self: t_Element) : UInt64.t = [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq [#"union_find.rs" 18 8 18 42] (self: t_Element) (other: t_Element) (return' (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = addr_eq {self'0.t_Element__0} {other'0.t_Element__0} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return''0 {_0} ] [ & _0: bool = Any.any_l () | & self'0: t_Element = self | & other'0: t_Element = other ])
    [ return''0 (result: bool) -> {[@expl:eq ensures] [%#sunion_find] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
end
module M_union_find__implementation__qyi15934775324707434347__addr [#"union_find.rs" 33 8 33 40] (* implementation::Element<T> *)
  let%span sunion_find = "union_find.rs" 34 12 34 40
  let%span sunion_find'0 = "union_find.rs" 32 18 32 46
  let%span sunion_find'1 = "union_find.rs" 24 8 24 16
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'1] addr_logic self.t_Element__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec addr [#"union_find.rs" 33 8 33 40] (self: t_Element) (return' (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- [%#sunion_find] deep_model self'0 ] s1 | s1 = bb1 ] | bb1 = return''0 {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & self'0: t_Element = self ])
    [ return''0 (result: UInt64.t) -> {[@expl:addr ensures] [%#sunion_find'0] result = deep_model self}
      (! return' {result}) ]
end
module M_union_find__implementation__qyi10464084137166016688__clone [#"union_find.rs" 46 8 46 31] (* <implementation::Element<T> as creusot_contracts::Clone> *)
  let%span sunion_find = "union_find.rs" 44 18 44 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' [#"union_find.rs" 46 8 46 31] (self: t_Element) (return' (x: t_Element)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { t_Element__0 = self'0.t_Element__0 } ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: t_Element = Any.any_l () | & self'0: t_Element = self ])
    [ return''0 (result: t_Element) -> {[@expl:clone ensures] [%#sunion_find] self = result} (! return' {result}) ]
end
module M_union_find__implementation__qyi1944850640244667852__domain [#"union_find.rs" 117 8 117 47] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 115 19 115 28
  let%span sunion_find'0 = "union_find.rs" 116 18 116 150
  let%span sunion_find'1 = "union_find.rs" 114 8 114 16
  let%span sunion_find'2 = "union_find.rs" 24 8 24 16
  let%span sunion_find'3 = "union_find.rs" 80 12 80 39
  let%span sunion_find'4 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'2] addr_logic self.t_Element__0
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'0] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap] get self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'4] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'3] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'3] forall k: UInt64.t. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UnionFind
  
  function domain [#"union_find.rs" 117 8 117 47] (self'0: t_UnionFind) : Fset.fset t_Element
  
  goal vc_domain: ([%#sunion_find] inv'6 self)
    -> (let result = (self.t_UnionFind__0).t_HFInner__domain in [@expl:domain ensures] [%#sunion_find'0] forall e1: t_Element, e2: t_Element. contains result e1
        /\ contains result e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
end
module M_union_find__implementation__qyi1944850640244667852__roots_map [#"union_find.rs" 138 8 138 65] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 133 19 133 28
  let%span sunion_find'0 = "union_find.rs" 134 18 136 42
  let%span sunion_find'1 = "union_find.rs" 132 8 132 16
  let%span sunion_find'2 = "union_find.rs" 122 8 122 16
  let%span sunion_find'3 = "union_find.rs" 115 19 115 28
  let%span sunion_find'4 = "union_find.rs" 116 18 116 150
  let%span sunion_find'5 = "union_find.rs" 114 8 114 16
  let%span sunion_find'6 = "union_find.rs" 80 12 80 39
  let%span sunion_find'7 = "union_find.rs" 24 8 24 16
  let%span sunion_find'8 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'7] addr_logic self.t_Element__0
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'0] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap] get self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'8] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'6] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'3] forall k: UInt64.t. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'5] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'3] inv'6 self)
      -> ([%#sunion_find'4] forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'2] contains (domain self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UnionFind
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self'0: t_UnionFind) : Map.map t_Element t_Element
  
  goal vc_roots_map: ([%#sunion_find] inv'6 self)
    -> (let result = (self.t_UnionFind__0).t_HFInner__roots in [@expl:roots_map ensures] [%#sunion_find'0] forall e: t_Element. in_domain self e
      -> in_domain self (index_logic'1 result e)
      /\ index_logic'1 result e = index_logic'1 result (index_logic'1 result e))
end
module M_union_find__implementation__new [#"union_find.rs" 195 4 195 42]
  let%span sunion_find = "union_find.rs" 199 28 199 52
  let%span sunion_find'0 = "union_find.rs" 201 30 201 60
  let%span sunion_find'1 = "union_find.rs" 202 30 202 60
  let%span sunion_find'2 = "union_find.rs" 203 27 203 57
  let%span sunion_find'3 = "union_find.rs" 204 31 204 43
  let%span sunion_find'4 = "union_find.rs" 195 23 195 42
  let%span sunion_find'5 = "union_find.rs" 194 4 194 42
  let%span sunion_find'6 = "union_find.rs" 115 19 115 28
  let%span sunion_find'7 = "union_find.rs" 116 18 116 150
  let%span sunion_find'8 = "union_find.rs" 114 8 114 16
  let%span sunion_find'9 = "union_find.rs" 24 8 24 16
  let%span sunion_find'10 = "union_find.rs" 80 12 80 39
  let%span sunion_find'11 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 276 4 276 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 274 4 274 33
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 120 4 120 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 197 22 197 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 197 4 199 17
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 195 14 195 29
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  
  use set.Fset
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_T
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'6] Map.get (view self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap'9] get self k <> C_None
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant' (self: t_PtrOwn) = [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''0 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant' x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val'} -> inv'2 val'
        end)
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'11] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'10] lookup self key
  
  predicate invariant''1 (self: t_FMap) =
    [%#sfmap'8] forall k: UInt64.t. contains self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''1 x
  
  predicate invariant''2 (self: t_FMap) = [%#sghost'5] inv'4 self
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) =
    [%#sfmap'3] let _ = () in forall k: UInt64.t. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'2] ext_eq self other = (self = other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'7] len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'4] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'5] view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = [%#sfmap'1] ext_eq self empty
  
  let rec new (return' (x: t_FMap)) = any
    [ return''0 (result: t_FMap) -> {[%#sfmap] inv'5 result} {[%#sfmap'0] is_empty result} (! return' {result}) ]
  
  let rec into_inner (self: t_FMap) (return' (x: t_FMap)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'5 self}
    any [ return''0 (result: t_FMap) -> {[%#sghost'0] inv'4 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  predicate index_logic'1 (self: Map.map (Map.map t_Element t_T) bool) (a: Map.map t_Element t_T) =
    [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Map.map t_Element t_T) bool) : Map.map t_Element t_T
  
  axiom such_that_spec'0:
    forall p: Map.map (Map.map t_Element t_T) bool. ([%#sutil] exists x: Map.map t_Element t_T. index_logic'1 p x)
      -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  predicate index_logic'2 (self: Map.map (Map.map t_Element int) bool) (a: Map.map t_Element int) =
    [%#smapping] Map.get self a
  
  function such_that'1 (p: Map.map (Map.map t_Element int) bool) : Map.map t_Element int
  
  axiom such_that_spec'1:
    forall p: Map.map (Map.map t_Element int) bool. ([%#sutil] exists x: Map.map t_Element int. index_logic'2 p x)
      -> ([%#sutil'0] index_logic'2 p (such_that'1 p))
  
  predicate index_logic'3 (self: Map.map (Map.map t_Element t_Element) bool) (a: Map.map t_Element t_Element) =
    [%#smapping] Map.get self a
  
  function such_that'2 (p: Map.map (Map.map t_Element t_Element) bool) : Map.map t_Element t_Element
  
  axiom such_that_spec'2:
    forall p: Map.map (Map.map t_Element t_Element) bool. ([%#sutil] exists x: Map.map t_Element t_Element. index_logic'3 p x)
      -> ([%#sutil'0] index_logic'3 p (such_that'2 p))
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'9] addr_logic self.t_Element__0
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'11] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'4 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'5 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'6 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant''3 [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'10] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains'0 domain e1
          /\ contains'0 domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains'0 domain e -> contains (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains'0 domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains'0 domain e
        -> index_logic'4 (self.t_UnionFind__0).t_HFInner__roots (index_logic'4 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'4 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains'0 domain e
        -> contains'0 domain (index_logic'4 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains'0 domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains'0 domain e2
          /\ index_logic'4 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'4 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'5 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'4 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains'0 domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'6 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'6 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains'0 domain e
        -> 0 <= index_logic'6 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'6 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains'0 domain e
      -> match val' (get_perm self (index_logic'4 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv'6 (_0: t_HFInner)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_HFInner [inv'6 x]. inv'6 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
      = (invariant''3 x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'6 a_0
        end)
  
  predicate invariant''4 (self: t_UnionFind) = [%#sghost'5] inv'7 self
  
  predicate inv'8 (_0: t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UnionFind [inv'8 x]. inv'8 x = invariant''4 x
  
  let rec new'0 (x: t_UnionFind) (return' (x'0: t_UnionFind)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'7 x}
    any
    [ return''0 (result: t_UnionFind) -> {[%#sghost'3] inv'8 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'8] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'6] inv'7 self)
      -> ([%#sunion_find'7] forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
          /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'1 [#"union_find.rs" 195 4 195 42] (return' (x: t_UnionFind)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- [%#sunion_find] Fset.empty: Fset.fset t_Element ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: t_FMap) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_inner {_7} (fun (_ret: t_FMap) -> [ &_6 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_8 <- [%#sunion_find'0] such_that'0 (fun (__0: Map.map t_Element t_T) -> true) ] s1 | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_10 <- [%#sunion_find'1] such_that'1 (fun (__0: Map.map t_Element int) -> true) ] s1 | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_12 <- [%#sunion_find'2] such_that'2 (fun (__0: Map.map t_Element t_Element) -> true) ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &_14 <- [%#sunion_find'3] 0 ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_3 <- { t_HFInner__domain = _4;
                        t_HFInner__map = _6;
                        t_HFInner__payloads = _8;
                        t_HFInner__distance = _10;
                        t_HFInner__roots = _12;
                        t_HFInner__max_depth = _14 } ] s1
      | s1 = [ &_2 <- { t_UnionFind__0 = _3 } ] s2
      | s2 = new'0 {_2} (fun (_ret: t_UnionFind) -> [ &_0 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = return''0 {_0} ]
    [ & _0: t_UnionFind = Any.any_l ()
    | & _2: t_UnionFind = Any.any_l ()
    | & _3: t_HFInner = Any.any_l ()
    | & _4: Fset.fset t_Element = Any.any_l ()
    | & _6: t_FMap = Any.any_l ()
    | & _7: t_FMap = Any.any_l ()
    | & _8: Map.map t_Element t_T = Any.any_l ()
    | & _10: Map.map t_Element int = Any.any_l ()
    | & _12: Map.map t_Element t_Element = Any.any_l ()
    | & _14: int = Any.any_l () ])
    [ return''0 (result: t_UnionFind) -> {[@expl:new result type invariant] [%#sunion_find'4] inv'8 result}
      {[@expl:new ensures] [%#sunion_find'5] Fset.is_empty (domain result)}
      (! return' {result}) ]
end
module M_union_find__implementation__make [#"union_find.rs" 214 4 214 78]
  let%span sunion_find = "union_find.rs" 215 27 215 45
  let%span sunion_find'0 = "union_find.rs" 226 24 226 60
  let%span sunion_find'1 = "union_find.rs" 227 26 227 76
  let%span sunion_find'2 = "union_find.rs" 228 26 228 64
  let%span sunion_find'3 = "union_find.rs" 229 23 229 64
  let%span sunion_find'4 = "union_find.rs" 214 23 214 25
  let%span sunion_find'5 = "union_find.rs" 214 53 214 60
  let%span sunion_find'6 = "union_find.rs" 210 4 210 37
  let%span sunion_find'7 = "union_find.rs" 211 14 211 58
  let%span sunion_find'8 = "union_find.rs" 212 14 212 69
  let%span sunion_find'9 = "union_find.rs" 213 14 213 76
  let%span sunion_find'10 = "union_find.rs" 32 18 32 46
  let%span sunion_find'11 = "union_find.rs" 122 8 122 16
  let%span sunion_find'12 = "union_find.rs" 115 19 115 28
  let%span sunion_find'13 = "union_find.rs" 116 18 116 150
  let%span sunion_find'14 = "union_find.rs" 114 8 114 16
  let%span sunion_find'15 = "union_find.rs" 133 19 133 28
  let%span sunion_find'16 = "union_find.rs" 134 18 136 42
  let%span sunion_find'17 = "union_find.rs" 132 8 132 16
  let%span sunion_find'18 = "union_find.rs" 153 8 153 16
  let%span sunion_find'19 = "union_find.rs" 24 8 24 16
  let%span sunion_find'20 = "union_find.rs" 80 12 80 39
  let%span sunion_find'21 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 62 8 62 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 377 30 377 34
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 377 4 377 62
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 366 14 374 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 375 14 375 73
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 376 44
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 442 29 442 33
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 442 43 442 48
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 442 4 442 65
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 440 14 440 49
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 441 14 441 40
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 55 15 55 16
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 55 4 55 53
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 54 14 54 64
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 138 26 138 30
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 138 48 138 52
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 135 14 135 64
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 136 14 136 28
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 197 22 197 26
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 197 4 199 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 195 14 195 29
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 119 8 119 22
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span speano = "../../creusot-contracts/src/peano.rs" 111 14 111 30
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec new (return' (x: t_PeanoInt)) = any
    [ return''0 (result: t_PeanoInt) -> {[%#speano] result.t_PeanoInt__0 = (0: UInt64.t)} (! return' {result}) ]
  
  type t_T
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type tuple = { _p0: Opaque.ptr; _p1: t_PtrOwn }
  
  predicate inv (_0: t_T)
  
  predicate inv'0 (_0: t_Content)
  
  axiom inv_axiom [@rewrite]: forall x: t_Content [inv'0 x]. inv'0 x
      = match x with
        | C_Root rank payload -> inv payload
        | C_Link a_0 -> true
        end
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant' (self: t_PtrOwn) = [%#sptr_own'6] not is_null_logic (ptr self)
  
  predicate invariant''0 (self: t_Content) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate inv'2 (_0: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'2 x]. inv'2 x
      = (invariant' x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val'} -> inv'1 val'
        end)
  
  predicate invariant''1 (self: t_PtrOwn) = [%#sghost'8] inv'2 self
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: tuple)
  
  axiom inv_axiom'3 [@rewrite]: forall x: tuple [inv'4 x]. inv'4 x = (let {_p0 = x0; _p1 = x1} = x in inv'3 x1)
  
  function val' (self: t_PtrOwn) : t_Content
  
  let rec new'0 (v: t_Content) (return' (x: tuple)) = {[@expl:new 'v' type invariant] [%#sptr_own] inv'0 v}
    any
    [ return''0 (result: tuple) -> {[%#sptr_own'0] inv'4 result}
      {[%#sptr_own'1] ptr result._p1 = result._p0 /\ val' result._p1 = v}
      (! return' {result}) ]
  
  type t_FMap
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset'0] Fset.mem e self
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'19] addr_logic self.t_Element__0
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'11] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap'9] get self k <> C_None
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'16] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'10] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'21] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant''2 [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'20] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv'5 (_0: UInt64.t)
  
  axiom inv_axiom'4 [@rewrite]: forall x: UInt64.t [inv'5 x]. inv'5 x = true
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'15] forall k: UInt64.t. contains'0 self k -> inv'5 k /\ inv'2 (index_logic'0 self k)
  
  predicate inv'6 (_0: t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_FMap [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate inv'7 (_0: t_HFInner)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_HFInner [inv'7 x]. inv'7 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'6 map
        end
  
  predicate inv'8 (_0: t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UnionFind [inv'8 x]. inv'8 x
      = (invariant''2 x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'7 a_0
        end)
  
  predicate invariant''4 (self: MutBorrow.t t_UnionFind) = [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) = [%#sghost'8] inv'9 self
  
  predicate inv'10 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'10 x]. inv'10 x = invariant''5 x
  
  predicate invariant''6 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'11 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'11 x]. inv'11 x = invariant''6 x
  
  predicate invariant''7 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'12 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'12 x]. inv'12 x = invariant''7 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return' (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'11 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {[%#sghost'0] inv'12 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  let rec into_inner (self: t_PtrOwn) (return' (x: t_PtrOwn)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'2] inv'3 self}
    any
    [ return''0 (result: t_PtrOwn) -> {[%#sghost'3] inv'2 result} {[%#sghost'4] result = self} (! return' {result}) ]
  
  let rec addr (self: t_Element) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#sunion_find'10] result = deep_model self} (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_PtrOwn)
  
  predicate invariant''8 (self: MutBorrow.t t_FMap) = [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'13 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'13 x]. inv'13 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_PtrOwn) = [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'14 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'14 x]. inv'14 x = invariant''9 x
  
  predicate inv'15 (_0: t_Option'0)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Option'0 [inv'15 x]. inv'15 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'14 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'12] len self >= 0
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: UInt64.t) (return' (x: t_Option'0)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap] inv'13 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'15 result}
      {[%#sfmap'1] if contains'0 self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains'0 self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap'2] forall k: UInt64.t. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'3] len self.current = len self.final}
      (! return' {result}) ]
  
  let rec v_Some (input: t_Option'0) (ret (field_0: MutBorrow.t t_PtrOwn)) = any
    [ good (field_0: MutBorrow.t t_PtrOwn) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_PtrOwn [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  predicate invariant''10 (self: t_PtrOwn) = [%#sinvariant'0] inv'2 self
  
  predicate inv'16 (_0: t_PtrOwn)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_PtrOwn [inv'16 x]. inv'16 x = invariant''10 x
  
  let rec disjoint_lemma (own1: MutBorrow.t t_PtrOwn) (own2: t_PtrOwn) (return' (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] [%#sptr_own'2] inv'14 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#sptr_own'3] inv'16 own2}
    any
    [ return''0 (result: ()) -> {[%#sptr_own'4] addr_logic (ptr own1.current) <> addr_logic (ptr own2)}
      {[%#sptr_own'5] own1.current = own1.final}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_PtrOwn) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_PtrOwn) = resolve _0
  
  predicate inv'17 (_0: t_Option)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Option [inv'17 x]. inv'17 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  function insert (self: t_FMap) (k: UInt64.t) (v: t_PtrOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: UInt64.t, v: t_PtrOwn. [%#sfmap'13] view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: UInt64.t, v: t_PtrOwn. [%#sfmap'14] len (insert self k v)
      = (if contains'0 self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: UInt64.t) (value: t_PtrOwn) (return' (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'4] inv'13 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'5] inv'2 value}
    any
    [ return''0 (result: t_Option) -> {[%#sfmap'6] inv'17 result}
      {[%#sfmap'7] self.final = insert self.current key value}
      {[%#sfmap'8] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve'1 (_0: t_PtrOwn) = true
  
  predicate resolve'2 (self: t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve'1 x
      | C_None -> true
      end
  
  predicate resolve'3 (_0: t_Option) = resolve'2 _0
  
  function insert'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) : Fset.fset t_Element =
    [%#sfset] Fset.add e self
  
  predicate invariant''11 (self: MutBorrow.t t_HFInner) = [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'18 (_0: MutBorrow.t t_HFInner)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_HFInner [inv'18 x]. inv'18 x = invariant''11 x
  
  predicate resolve'4 (self: MutBorrow.t t_HFInner) = [%#sresolve] self.final = self.current
  
  predicate resolve'5 (_0: MutBorrow.t t_HFInner) = resolve'4 _0
  
  predicate resolve'6 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve'6 _0
  
  predicate resolve'8 (self: MutBorrow.t t_UnionFind) = [%#sresolve] self.final = self.current
  
  predicate resolve'9 (_0: MutBorrow.t t_UnionFind) = resolve'8 _0
  
  predicate resolve'10 (self: MutBorrow.t t_UnionFind) = [%#sghost'7] resolve'9 self
  
  predicate resolve'11 (_0: MutBorrow.t t_UnionFind) = resolve'10 _0
  
  let rec new'1 (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'5] result = x} (! return' {result}) ]
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'14] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'12] inv'8 self)
      -> ([%#sunion_find'13] forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'11] contains (domain self) e
  
  function fin (self: MutBorrow.t t_UnionFind) : t_UnionFind = [%#sghost'6] self.final
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'17] (self.t_UnionFind__0).t_HFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. ([%#sunion_find'15] inv'8 self)
      -> ([%#sunion_find'16] forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function payloads_map [#"union_find.rs" 154 8 154 59] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'18] (self.t_UnionFind__0).t_HFInner__payloads
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec make [#"union_find.rs" 214 4 214 78] (uf: MutBorrow.t t_UnionFind) (payload: t_T) (return' (x: t_Element)) =
    {[@expl:make 'uf' type invariant] [%#sunion_find'4] inv'10 uf}
    {[@expl:make 'payload' type invariant] [%#sunion_find'5] inv payload}
    (! bb0
    [ bb0 = s0 [ s0 = [ &payload_snap <- [%#sunion_find] payload'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: t_PeanoInt) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_12 <- C_Root _13 payload'0 ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = new'0 {_12} (fun (_ret: tuple) -> [ &_11 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &ptr'0 <- _11._p0 ] s1
      | s1 = [ &perm <- _11._p1 ] s2
      | s2 = [ &element <- { t_Element__0 = ptr'0 } ] s3
      | s3 = {inv'10 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_21 <- _ret ] -{inv'10 _ret.final}-
            [ &uf'0 <- _ret.final ] s4)
      | s4 = deref_mut {_21} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_20 <- _ret ] s5)
      | s5 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'7 ((_20.current).current).t_UnionFind__0}
        MutBorrow.borrow_mut <t_HFInner> {((_20.current).current).t_UnionFind__0}
          (fun (_ret: MutBorrow.t t_HFInner) ->
            [ &uf'1 <- _ret ] -{inv'7 _ret.final}-
            [ &_20 <- { _20 with current = { _20.current with current = { t_UnionFind__0 = _ret.final } } } ] s1)
      | s1 = into_inner {perm} (fun (_ret: t_PtrOwn) -> [ &perm'0 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = addr {element} (fun (_ret: UInt64.t) -> [ &_29 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_28 <- _29 ] s1
      | s1 = {inv'6 (uf'1.current).t_HFInner__map}
        MutBorrow.borrow_mut <t_FMap> {(uf'1.current).t_HFInner__map}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_26 <- _ret ] -{inv'6 _ret.final}-
            [ &uf'1 <- { uf'1 with current = { uf'1.current with t_HFInner__map = _ret.final } } ] s2)
      | s2 = get_mut_ghost {_26} {_28} (fun (_ret: t_Option'0) -> [ &_25 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = any [ br0 -> {_25 = C_None'0} (! bb14) | br1 (x0: MutBorrow.t t_PtrOwn) -> {_25 = C_Some'0 x0} (! bb11) ]
    | bb11 = s0
      [ s0 = v_Some {_25} (fun (r0: MutBorrow.t t_PtrOwn) -> [ &other_perm <- r0 ] s1)
      | s1 = [ &_35 <- perm'0 ] s2
      | s2 = {inv'2 other_perm.current}
        MutBorrow.borrow_final <t_PtrOwn> {other_perm.current} {MutBorrow.get_id other_perm}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_33 <- _ret ] -{inv'2 _ret.final}-
            [ &other_perm <- { other_perm with current = _ret.final } ] s3)
      | s3 = disjoint_lemma {_33} {_35} (fun (_ret: ()) -> [ &_24 <- _ret ] s4)
      | s4 = bb13 ]
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'14 other_perm} s1 | s1 = -{resolve'0 other_perm}- s2 | s2 = bb14 ]
    | bb14 = s0 [ s0 = addr {element} (fun (_ret: UInt64.t) -> [ &_38 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'6 (uf'1.current).t_HFInner__map}
        MutBorrow.borrow_final <t_FMap> {(uf'1.current).t_HFInner__map} {MutBorrow.inherit_id (MutBorrow.get_id uf'1) 2}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_37 <- _ret ] -{inv'6 _ret.final}-
            [ &uf'1 <- { uf'1 with current = { uf'1.current with t_HFInner__map = _ret.final } } ] s1)
      | s1 = insert_ghost {_37} {_38} {perm'0} (fun (_ret: t_Option) -> [ &_36 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'17 _36} s3
      | s3 = -{resolve'3 _36}- s4
      | s4 = bb17 ]
    | bb17 = s0 [ s0 = [ &_41 <- [%#sunion_find'0] insert'0 (uf'1.current).t_HFInner__domain element ] s1 | s1 = bb18 ]
    | bb18 = s0
      [ s0 = [ &uf'1 <- { uf'1 with current = { uf'1.current with t_HFInner__domain = _41 } } ] s1
      | s1 = [ &_43 <- [%#sunion_find'1] Map.set (uf'1.current).t_HFInner__payloads element payload_snap ] s2
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = [ &uf'1 <- { uf'1 with current = { uf'1.current with t_HFInner__payloads = _43 } } ] s1
      | s1 = [ &_45 <- [%#sunion_find'2] Map.set (uf'1.current).t_HFInner__distance element 0 ] s2
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 = [ &uf'1 <- { uf'1 with current = { uf'1.current with t_HFInner__distance = _45 } } ] s1
      | s1 = [ &_47 <- [%#sunion_find'3] Map.set (uf'1.current).t_HFInner__roots element element ] s2
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = [ &uf'1 <- { uf'1 with current = { uf'1.current with t_HFInner__roots = _47 } } ] s1
      | s1 = {[@expl:type invariant] inv'18 uf'1} s2
      | s2 = -{resolve'5 uf'1}- s3
      | s3 = {[@expl:type invariant] inv'12 _20} s4
      | s4 = -{resolve'7 _20}- s5
      | s5 = {[@expl:type invariant] inv'10 uf'0} s6
      | s6 = -{resolve'11 uf'0}- s7
      | s7 = bb22 ]
    | bb22 = s0 [ s0 = new'1 {_18} (fun (_ret: ()) -> [ &_17 <- _ret ] s1) | s1 = bb23 ]
    | bb23 = s0 [ s0 = [ &_0 <- element ] s1 | s1 = bb24 ]
    | bb24 = return''0 {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf'0: MutBorrow.t t_UnionFind = uf
    | & payload'0: t_T = payload
    | & payload_snap: t_T = Any.any_l ()
    | & ptr'0: Opaque.ptr = Any.any_l ()
    | & perm: t_PtrOwn = Any.any_l ()
    | & _11: tuple = Any.any_l ()
    | & _12: t_Content = Any.any_l ()
    | & _13: t_PeanoInt = Any.any_l ()
    | & element: t_Element = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: () = Any.any_l ()
    | & uf'1: MutBorrow.t t_HFInner = Any.any_l ()
    | & _20: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & perm'0: t_PtrOwn = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: t_Option'0 = Any.any_l ()
    | & _26: MutBorrow.t t_FMap = Any.any_l ()
    | & _28: UInt64.t = Any.any_l ()
    | & _29: UInt64.t = Any.any_l ()
    | & other_perm: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _33: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _35: t_PtrOwn = Any.any_l ()
    | & _36: t_Option = Any.any_l ()
    | & _37: MutBorrow.t t_FMap = Any.any_l ()
    | & _38: UInt64.t = Any.any_l ()
    | & _41: Fset.fset t_Element = Any.any_l ()
    | & _43: Map.map t_Element t_T = Any.any_l ()
    | & _45: Map.map t_Element int = Any.any_l ()
    | & _47: Map.map t_Element t_Element = Any.any_l () ])
    [ return''0 (result: t_Element) -> {[@expl:make ensures #0] [%#sunion_find'6] not in_domain uf.current result}
      {[@expl:make ensures #1] [%#sunion_find'7] domain (fin uf) = insert'0 (domain uf.current) result}
      {[@expl:make ensures #2] [%#sunion_find'8] roots_map (fin uf) = Map.set (roots_map uf.current) result result}
      {[@expl:make ensures #3] [%#sunion_find'9] payloads_map (fin uf)
      = Map.set (payloads_map uf.current) result payload}
      (! return' {result}) ]
end
module M_union_find__implementation__find_inner [#"union_find.rs" 241 4 241 86]
  let%span sunion_find = "union_find.rs" 241 25 241 27
  let%span sunion_find'0 = "union_find.rs" 235 4 235 35
  let%span sunion_find'1 = "union_find.rs" 236 14 236 37
  let%span sunion_find'2 = "union_find.rs" 237 4 237 30
  let%span sunion_find'3 = "union_find.rs" 239 14 239 41
  let%span sunion_find'4 = "union_find.rs" 240 14 240 58
  let%span sunion_find'5 = "union_find.rs" 32 18 32 46
  let%span sunion_find'6 = "union_find.rs" 122 8 122 16
  let%span sunion_find'7 = "union_find.rs" 146 8 146 16
  let%span sunion_find'8 = "union_find.rs" 173 16 175 64
  let%span sunion_find'9 = "union_find.rs" 24 8 24 16
  let%span sunion_find'10 = "union_find.rs" 115 19 115 28
  let%span sunion_find'11 = "union_find.rs" 116 18 116 150
  let%span sunion_find'12 = "union_find.rs" 114 8 114 16
  let%span sunion_find'13 = "union_find.rs" 133 19 133 28
  let%span sunion_find'14 = "union_find.rs" 134 18 136 42
  let%span sunion_find'15 = "union_find.rs" 132 8 132 16
  let%span sunion_find'16 = "union_find.rs" 153 8 153 16
  let%span sunion_find'17 = "union_find.rs" 80 12 80 39
  let%span sunion_find'18 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 344 22 344 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 344 4 344 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 343 14 343 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 377 30 377 34
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 377 4 377 62
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 366 14 374 9
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 375 14 375 73
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 376 44
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 81 41 81 44
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 78 15 78 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 81 4 81 70
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 79 14 79 35
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 99 41 99 44
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 95 15 95 31
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 99 4 99 78
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 96 14 96 35
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 97 14 97 39
  let%span sptr_own'8 = "../../creusot-contracts/src/ptr_own.rs" 98 14 98 38
  let%span sptr_own'9 = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 70 14 70 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 70 4 70 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 69 14 69 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 119 8 119 22
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'9] addr_logic self.t_Element__0
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'7] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap'8] get self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'12] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'9] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'18] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'17] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own'9] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'11] forall k: UInt64.t. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 (self: MutBorrow.t t_UnionFind) = [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self: MutBorrow.t t_UnionFind) = [%#sghost'10] inv'7 self
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) = [%#sinvariant'0] inv'8 self
  
  predicate inv'9 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 (self: MutBorrow.t t_UnionFind) = [%#sinvariant'0] inv'7 self
  
  predicate inv'10 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref (self: MutBorrow.t t_UnionFind) (return' (x: MutBorrow.t t_UnionFind)) =
    {[@expl:deref 'self' type invariant] [%#sghost] inv'9 self}
    any
    [ return''0 (result: MutBorrow.t t_UnionFind) -> {[%#sghost'0] inv'10 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  let rec addr (self: t_Element) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#sunion_find'5] result = deep_model self} (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''7 (self: t_FMap) = [%#sinvariant'0] inv'4 self
  
  predicate inv'11 (_0: t_FMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_FMap [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: t_PtrOwn) = [%#sinvariant'0] inv'3 self
  
  predicate inv'12 (_0: t_PtrOwn)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate inv'13 (_0: t_Option'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'12 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: UInt64.t) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'11 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'13 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'13 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any [ return''0 (result: t_PtrOwn) -> {inv'12 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  predicate invariant''9 (self: t_PtrOwn) = [%#sghost'10] inv'12 self
  
  predicate inv'14 (_0: t_PtrOwn)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_PtrOwn [inv'14 x]. inv'14 x = invariant''9 x
  
  let rec new (x: t_PtrOwn) (return' (x'0: t_PtrOwn)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'12 x}
    any [ return''0 (result: t_PtrOwn) -> {[%#sghost'3] inv'14 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  predicate invariant''10 (self: t_Content) = [%#sinvariant'0] inv'1 self
  
  predicate inv'15 (_0: t_Content)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Content [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return' (x: t_Content)) =
    {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'14 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any
    [ return''0 (result: t_Content) -> {[%#sptr_own'1] inv'15 result}
      {[%#sptr_own'2] result = val' own}
      (! return' {result}) ]
  
  let rec v_Link (input: t_Content) (ret (field_0: t_Element)) = any
    [ good (field_0: t_Element) -> {C_Link field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Element [C_Link field_0: t_Content]. C_Link field_0 <> input} (! {false} any) ]
  
  predicate invariant''11 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'16 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'16 x]. inv'16 x = invariant''11 x
  
  predicate invariant''12 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'17 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'17 x]. inv'17 x = invariant''12 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return' (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'16 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {[%#sghost'6] inv'17 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_UnionFind) = [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_UnionFind) = resolve'1 _0
  
  let rec new'0 (x: MutBorrow.t t_UnionFind) (return' (x'0: MutBorrow.t t_UnionFind)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'7 x}
    any
    [ return''0 (result: MutBorrow.t t_UnionFind) -> {[%#sghost'3] inv'8 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate invariant''13 (self: MutBorrow.t t_FMap) = [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'18 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'18 x]. inv'18 x = invariant''13 x
  
  predicate invariant''14 (self: MutBorrow.t t_FMap) = [%#sghost'10] inv'18 self
  
  predicate inv'19 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec new'1 (x: MutBorrow.t t_FMap) (return' (x'0: MutBorrow.t t_FMap)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'18 x}
    any
    [ return''0 (result: MutBorrow.t t_FMap) -> {[%#sghost'3] inv'19 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate invariant''15 (self: MutBorrow.t (MutBorrow.t t_FMap)) =
    [%#sinvariant] inv'19 self.current /\ inv'19 self.final
  
  predicate inv'20 (_0: MutBorrow.t (MutBorrow.t t_FMap))
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_FMap) [inv'20 x]. inv'20 x = invariant''15 x
  
  predicate invariant''16 (self: MutBorrow.t (MutBorrow.t t_FMap)) =
    [%#sinvariant] inv'18 self.current /\ inv'18 self.final
  
  predicate inv'21 (_0: MutBorrow.t (MutBorrow.t t_FMap))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_FMap) [inv'21 x]. inv'21 x = invariant''16 x
  
  let rec deref_mut'0 (self: MutBorrow.t (MutBorrow.t t_FMap)) (return' (x: MutBorrow.t (MutBorrow.t t_FMap))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'20 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_FMap)) -> {[%#sghost'6] inv'21 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_PtrOwn)
  
  predicate invariant''17 (self: MutBorrow.t t_PtrOwn) = [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'22 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'22 x]. inv'22 x = invariant''17 x
  
  predicate inv'23 (_0: t_Option'1)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_Option'1 [inv'23 x]. inv'23 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'22 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'10] len self >= 0
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: UInt64.t) (return' (x: t_Option'1)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'2] inv'18 self}
    any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'3] inv'23 result}
      {[%#sfmap'4] if contains'0 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'0 self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'5] forall k: UInt64.t. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'6] len self.current = len self.final}
      (! return' {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return' (x: MutBorrow.t t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'23 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result: MutBorrow.t t_PtrOwn) -> {inv'22 result}
      {[%#soption'1] C_Some'1 result = self_}
      (! return' {result}) ]
  
  predicate resolve'3 (self: MutBorrow.t (MutBorrow.t t_FMap)) = [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t (MutBorrow.t t_FMap)) = resolve'3 _0
  
  predicate invariant''18 (self: MutBorrow.t t_PtrOwn) = [%#sghost'10] inv'22 self
  
  predicate inv'24 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'24 x]. inv'24 x = invariant''18 x
  
  let rec new'2 (x: MutBorrow.t t_PtrOwn) (return' (x'0: MutBorrow.t t_PtrOwn)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'22 x}
    any
    [ return''0 (result: MutBorrow.t t_PtrOwn) -> {[%#sghost'3] inv'24 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate resolve'5 (self: MutBorrow.t t_PtrOwn) = [%#sresolve] self.final = self.current
  
  predicate resolve'6 (_0: MutBorrow.t t_PtrOwn) = resolve'5 _0
  
  predicate invariant''19 (self: MutBorrow.t t_Content) = [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'25 (_0: MutBorrow.t t_Content)
  
  axiom inv_axiom'24 [@rewrite]: forall x: MutBorrow.t t_Content [inv'25 x]. inv'25 x = invariant''19 x
  
  function fin (self: MutBorrow.t t_PtrOwn) : t_PtrOwn = [%#sghost'8] self.final
  
  let rec as_mut (ptr'0: Opaque.ptr) (own: MutBorrow.t t_PtrOwn) (return' (x: MutBorrow.t t_Content)) =
    {[@expl:as_mut 'own' type invariant] [%#sptr_own'3] inv'24 own}
    {[@expl:as_mut requires] [%#sptr_own'4] ptr'0 = ptr own.current}
    any
    [ return''0 (result: MutBorrow.t t_Content) -> {[%#sptr_own'5] inv'25 result}
      {[%#sptr_own'6] result.current = val' own.current}
      {[%#sptr_own'7] ptr (fin own) = ptr own.current}
      {[%#sptr_own'8] val' (fin own) = result.final}
      (! return' {result}) ]
  
  predicate resolve'7 (self: MutBorrow.t t_Content) = [%#sresolve] self.final = self.current
  
  predicate resolve'8 (_0: MutBorrow.t t_Content) = resolve'7 _0
  
  predicate resolve'9 (self: MutBorrow.t t_FMap) = [%#sresolve] self.final = self.current
  
  predicate resolve'10 (_0: MutBorrow.t t_FMap) = resolve'9 _0
  
  predicate resolve'11 (self: MutBorrow.t t_FMap) = [%#sghost'9] resolve'10 self
  
  predicate resolve'12 (_0: MutBorrow.t t_FMap) = resolve'11 _0
  
  predicate resolve'13 (self: MutBorrow.t t_UnionFind) = [%#sghost'9] resolve'2 self
  
  predicate resolve'14 (_0: MutBorrow.t t_UnionFind) = resolve'13 _0
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'12] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'10] inv'6 self)
      -> ([%#sunion_find'11] forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'6] contains (domain self) e
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'15] (self.t_UnionFind__0).t_HFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. ([%#sunion_find'13] inv'6 self)
      -> ([%#sunion_find'14] forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find.rs" 148 8 148 54] (self: t_UnionFind) (e: t_Element) : t_Element =
    [%#sunion_find'7] index_logic'1 (roots_map self) e
  
  function payloads_map [#"union_find.rs" 154 8 154 59] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'16] (self.t_UnionFind__0).t_HFInner__payloads
  
  predicate unchanged [#"union_find.rs" 171 8 171 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'8] domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  predicate resolve'15 (self: MutBorrow.t (Map.map t_Element int)) = [%#sresolve] self.final = self.current
  
  predicate resolve'16 (_0: MutBorrow.t (Map.map t_Element int)) = resolve'15 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find_inner [#"union_find.rs" 241 4 241 86] (uf: MutBorrow.t t_UnionFind) (elem: t_Element)
    (return' (x: t_Element)) = {[@expl:find_inner 'uf' type invariant] [%#sunion_find] inv'8 uf}
    {[@expl:find_inner requires] [%#sunion_find'0] in_domain uf.current elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref {uf'0} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_12 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = addr {elem'0} (fun (_ret: UInt64.t) -> [ &_16 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_15 <- _16 ] s1
      | s1 = get_ghost {((_12.current).t_UnionFind__0).t_HFInner__map} {_15}
          (fun (_ret: t_Option'0) -> [ &_10 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = unwrap {_10} (fun (_ret: t_PtrOwn) -> [ &_9 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_9} (fun (_ret: t_PtrOwn) -> [ &perm <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = as_ref {elem'0.t_Element__0} {perm} (fun (_ret: t_Content) -> [ &value <- _ret ] s1) | s1 = bb6 ]
    | bb6 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {value = C_Root x0 x1} (! bb10)
      | br1 (x0: t_Element) -> {value = C_Link x0} (! bb9) ]
    | bb9 = s0
      [ s0 = v_Link {value} (fun (r0: t_Element) -> [ &e <- r0 ] s1)
      | s1 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_29 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s2)
      | s2 = deref_mut {_29} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_28 <- _ret ] s3)
      | s3 = bb11 ]
    | bb11 = s0
      [ s0 = {inv'6 (_28.current).current}
        MutBorrow.borrow_mut <t_UnionFind> {(_28.current).current}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_27 <- _ret ] -{inv'6 _ret.final}-
            [ &_28 <- { _28 with current = { _28.current with current = _ret.final } } ] s1)
      | s1 = {inv'6 _27.current}
        MutBorrow.borrow_final <t_UnionFind> {_27.current} {MutBorrow.get_id _27}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_26 <- _ret ] -{inv'6 _ret.final}-
            [ &_27 <- { _27 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'17 _28} s3
      | s3 = -{resolve'0 _28}- s4
      | s4 = {[@expl:type invariant] inv'7 _27} s5
      | s5 = -{resolve'2 _27}- s6
      | s6 = {inv'6 _26.current}
        MutBorrow.borrow_final <t_UnionFind> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_25 <- _ret ] -{inv'6 _ret.final}-
            [ &_26 <- { _26 with current = _ret.final } ] s7)
      | s7 = new'0 {_25} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_24 <- _ret ] s8)
      | s8 = bb12 ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'7 _26} s1
      | s1 = -{resolve'2 _26}- s2
      | s2 = find_inner {_24} {e} (fun (_ret: t_Element) -> [ &root'0 <- _ret ] s3)
      | s3 = bb13 ]
    | bb13 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_33 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_33} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_32 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {inv'4 (((_32.current).current).t_UnionFind__0).t_HFInner__map}
        MutBorrow.borrow_mut <t_FMap> {(((_32.current).current).t_UnionFind__0).t_HFInner__map}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &__temp <- _ret ] -{inv'4 _ret.final}-
            [ &_32 <- { _32 with current = { _32.current with current = { t_UnionFind__0 = { ((_32.current).current).t_UnionFind__0 with t_HFInner__map = _ret.final } } } } ]
            s1)
      | s1 = new'1 {__temp} (fun (_ret: MutBorrow.t t_FMap) -> [ &map <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'19 map}
        MutBorrow.borrow_mut <MutBorrow.t t_FMap> {map}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap)) ->
            [ &_42 <- _ret ] -{inv'19 _ret.final}-
            [ &map <- _ret.final ] s1)
      | s1 = deref_mut'0 {_42} (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap)) -> [ &_41 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0 [ s0 = addr {elem'0} (fun (_ret: UInt64.t) -> [ &_45 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_44 <- _45 ] s1
      | s1 = {inv'4 (_41.current).current}
        MutBorrow.borrow_mut <t_FMap> {(_41.current).current}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_40 <- _ret ] -{inv'4 _ret.final}-
            [ &_41 <- { _41 with current = { _41.current with current = _ret.final } } ] s2)
      | s2 = get_mut_ghost {_40} {_44} (fun (_ret: t_Option'1) -> [ &_39 <- _ret ] s3)
      | s3 = bb18 ]
    | bb18 = s0 [ s0 = unwrap'0 {_39} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_38 <- _ret ] s1) | s1 = bb19 ]
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'21 _41} s1
      | s1 = -{resolve'4 _41}- s2
      | s2 = {inv'3 _38.current}
        MutBorrow.borrow_final <t_PtrOwn> {_38.current} {MutBorrow.get_id _38}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_37 <- _ret ] -{inv'3 _ret.final}-
            [ &_38 <- { _38 with current = _ret.final } ] s3)
      | s3 = new'2 {_37} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &mut_perm <- _ret ] s4)
      | s4 = bb20 ]
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv'22 _38} s1
      | s1 = -{resolve'6 _38}- s2
      | s2 = [ &_48 <- C_Link root'0 ] s3
      | s3 = as_mut {elem'0.t_Element__0} {mut_perm} (fun (_ret: MutBorrow.t t_Content) -> [ &_50 <- _ret ] s4)
      | s4 = bb22 ]
    | bb22 = s0
      [ s0 = {[@expl:type invariant] inv'1 _50.current} s1
      | s1 = [ &_50 <- { _50 with current = _48 } ] s2
      | s2 = {[@expl:type invariant] inv'25 _50} s3
      | s3 = -{resolve'8 _50}- s4
      | s4 = {[@expl:type invariant] inv'19 map} s5
      | s5 = -{resolve'12 map}- s6
      | s6 = {[@expl:type invariant] inv'17 _32} s7
      | s7 = -{resolve'0 _32}- s8
      | s8 = {[@expl:type invariant] inv'8 uf'0} s9
      | s9 = -{resolve'14 uf'0}- s10
      | s10 = bb24 ]
    | bb24 = s0 [ s0 = [ &_0 <- root'0 ] s1 | s1 = bb25 ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'8 uf'0} s1
      | s1 = -{resolve'14 uf'0}- s2
      | s2 = [ &_0 <- elem'0 ] s3
      | s3 = bb25 ]
    | bb25 = return''0 {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf'0: MutBorrow.t t_UnionFind = uf
    | & elem'0: t_Element = elem
    | & perm: t_PtrOwn = Any.any_l ()
    | & _9: t_PtrOwn = Any.any_l ()
    | & _10: t_Option'0 = Any.any_l ()
    | & _12: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _15: UInt64.t = Any.any_l ()
    | & _16: UInt64.t = Any.any_l ()
    | & value: t_Content = Any.any_l ()
    | & e: t_Element = Any.any_l ()
    | & root'0: t_Element = Any.any_l ()
    | & _24: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _25: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _26: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _27: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _28: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _29: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & __temp: MutBorrow.t t_FMap = Any.any_l ()
    | & _32: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _33: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & map: MutBorrow.t t_FMap = Any.any_l ()
    | & mut_perm: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _37: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _38: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _39: t_Option'1 = Any.any_l ()
    | & _40: MutBorrow.t t_FMap = Any.any_l ()
    | & _41: MutBorrow.t (MutBorrow.t t_FMap) = Any.any_l ()
    | & _42: MutBorrow.t (MutBorrow.t t_FMap) = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _45: UInt64.t = Any.any_l ()
    | & _48: t_Content = Any.any_l ()
    | & _50: MutBorrow.t t_Content = Any.any_l () ])
    [ return''0 (result: t_Element) -> {[@expl:find_inner ensures #0] [%#sunion_find'1] result = root uf.current elem}
      {[@expl:find_inner ensures #1] [%#sunion_find'2] unchanged uf}
      {[@expl:find_inner ensures #2] [%#sunion_find'3] resolve'16 (MutBorrow.borrow_logic ((uf.current).t_UnionFind__0).t_HFInner__distance ((uf.final).t_UnionFind__0).t_HFInner__distance (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id uf) 1) 4))}
      {[@expl:find_inner ensures #3] [%#sunion_find'4] index_logic'3 ((uf.current).t_UnionFind__0).t_HFInner__distance result
      >= index_logic'3 ((uf.current).t_UnionFind__0).t_HFInner__distance elem}
      (! return' {result}) ]
end
module M_union_find__implementation__find [#"union_find.rs" 261 4 261 80]
  let%span sunion_find = "union_find.rs" 261 19 261 21
  let%span sunion_find'0 = "union_find.rs" 258 4 258 35
  let%span sunion_find'1 = "union_find.rs" 259 14 259 37
  let%span sunion_find'2 = "union_find.rs" 260 4 260 30
  let%span sunion_find'3 = "union_find.rs" 241 25 241 27
  let%span sunion_find'4 = "union_find.rs" 235 4 235 35
  let%span sunion_find'5 = "union_find.rs" 236 14 236 37
  let%span sunion_find'6 = "union_find.rs" 237 4 237 30
  let%span sunion_find'7 = "union_find.rs" 239 14 239 41
  let%span sunion_find'8 = "union_find.rs" 240 14 240 58
  let%span sunion_find'9 = "union_find.rs" 122 8 122 16
  let%span sunion_find'10 = "union_find.rs" 146 8 146 16
  let%span sunion_find'11 = "union_find.rs" 173 16 175 64
  let%span sunion_find'12 = "union_find.rs" 115 19 115 28
  let%span sunion_find'13 = "union_find.rs" 116 18 116 150
  let%span sunion_find'14 = "union_find.rs" 114 8 114 16
  let%span sunion_find'15 = "union_find.rs" 133 19 133 28
  let%span sunion_find'16 = "union_find.rs" 134 18 136 42
  let%span sunion_find'17 = "union_find.rs" 132 8 132 16
  let%span sunion_find'18 = "union_find.rs" 153 8 153 16
  let%span sunion_find'19 = "union_find.rs" 24 8 24 16
  let%span sunion_find'20 = "union_find.rs" 80 12 80 39
  let%span sunion_find'21 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'19] addr_logic self.t_Element__0
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'0] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap] get self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'21] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'20] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'3] forall k: UInt64.t. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 (self: MutBorrow.t t_UnionFind) = [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self: MutBorrow.t t_UnionFind) = [%#sghost] inv'7 self
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''4 x
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'14] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'12] inv'6 self)
      -> ([%#sunion_find'13] forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'9] contains (domain self) e
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'17] (self.t_UnionFind__0).t_HFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. ([%#sunion_find'15] inv'6 self)
      -> ([%#sunion_find'16] forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find.rs" 148 8 148 54] (self: t_UnionFind) (e: t_Element) : t_Element =
    [%#sunion_find'10] index_logic'1 (roots_map self) e
  
  function payloads_map [#"union_find.rs" 154 8 154 59] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'18] (self.t_UnionFind__0).t_HFInner__payloads
  
  predicate unchanged [#"union_find.rs" 171 8 171 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'11] domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  predicate resolve (self: MutBorrow.t (Map.map t_Element int)) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t (Map.map t_Element int)) = resolve _0
  
  let rec find_inner (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return' (x: t_Element)) =
    {[@expl:find_inner 'uf' type invariant] [%#sunion_find'3] inv'8 uf}
    {[@expl:find_inner requires] [%#sunion_find'4] in_domain uf.current elem}
    any
    [ return''0 (result: t_Element) -> {[%#sunion_find'5] result = root uf.current elem}
      {[%#sunion_find'6] unchanged uf}
      {[%#sunion_find'7] resolve'0 (MutBorrow.borrow_logic ((uf.current).t_UnionFind__0).t_HFInner__distance ((uf.final).t_UnionFind__0).t_HFInner__distance (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id uf) 1) 4))}
      {[%#sunion_find'8] index_logic'3 ((uf.current).t_UnionFind__0).t_HFInner__distance result
      >= index_logic'3 ((uf.current).t_UnionFind__0).t_HFInner__distance elem}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find [#"union_find.rs" 261 4 261 80] (uf: MutBorrow.t t_UnionFind) (elem: t_Element)
    (return' (x: t_Element)) = {[@expl:find 'uf' type invariant] [%#sunion_find] inv'8 uf}
    {[@expl:find requires] [%#sunion_find'0] in_domain uf.current elem}
    (! bb0
    [ bb0 = s0 [ s0 = find_inner {uf'0} {elem'0} (fun (_ret: t_Element) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return''0 {_0} ]
    [ & _0: t_Element = Any.any_l () | & uf'0: MutBorrow.t t_UnionFind = uf | & elem'0: t_Element = elem ])
    [ return''0 (result: t_Element) -> {[@expl:find ensures #0] [%#sunion_find'1] result = root uf.current elem}
      {[@expl:find ensures #1] [%#sunion_find'2] unchanged uf}
      (! return' {result}) ]
end
module M_union_find__implementation__get [#"union_find.rs" 271 4 271 67]
  let%span sunion_find = "union_find.rs" 271 18 271 20
  let%span sunion_find'0 = "union_find.rs" 268 4 268 35
  let%span sunion_find'1 = "union_find.rs" 269 15 269 36
  let%span sunion_find'2 = "union_find.rs" 271 65 271 67
  let%span sunion_find'3 = "union_find.rs" 270 14 270 41
  let%span sunion_find'4 = "union_find.rs" 32 18 32 46
  let%span sunion_find'5 = "union_find.rs" 122 8 122 16
  let%span sunion_find'6 = "union_find.rs" 146 8 146 16
  let%span sunion_find'7 = "union_find.rs" 162 8 162 16
  let%span sunion_find'8 = "union_find.rs" 24 8 24 16
  let%span sunion_find'9 = "union_find.rs" 115 19 115 28
  let%span sunion_find'10 = "union_find.rs" 116 18 116 150
  let%span sunion_find'11 = "union_find.rs" 114 8 114 16
  let%span sunion_find'12 = "union_find.rs" 133 19 133 28
  let%span sunion_find'13 = "union_find.rs" 134 18 136 42
  let%span sunion_find'14 = "union_find.rs" 132 8 132 16
  let%span sunion_find'15 = "union_find.rs" 153 8 153 16
  let%span sunion_find'16 = "union_find.rs" 80 12 80 39
  let%span sunion_find'17 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 344 22 344 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 344 4 344 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 343 14 343 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 81 41 81 44
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 78 15 78 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 81 4 81 70
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 79 14 79 35
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 70 14 70 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 70 4 70 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 69 14 69 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'8] addr_logic self.t_Element__0
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'2] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap'3] get self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'6] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'5] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'17] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'16] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own'3] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'4] forall k: UInt64.t. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 (self: t_UnionFind) = [%#sinvariant] inv'6 self
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self: t_UnionFind) = [%#sghost'5] inv'7 self
  
  predicate inv'8 (_0: t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UnionFind [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate invariant''5 (self: t_UnionFind) = [%#sinvariant] inv'8 self
  
  predicate inv'9 (_0: t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_UnionFind [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 (self: t_UnionFind) = [%#sinvariant] inv'7 self
  
  predicate inv'10 (_0: t_UnionFind)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_UnionFind [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref (self: t_UnionFind) (return' (x: t_UnionFind)) =
    {[@expl:deref 'self' type invariant] [%#sghost] inv'9 self}
    any
    [ return''0 (result: t_UnionFind) -> {[%#sghost'0] inv'10 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  let rec addr (self: t_Element) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#sunion_find'4] result = deep_model self} (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''7 (self: t_FMap) = [%#sinvariant] inv'4 self
  
  predicate inv'11 (_0: t_FMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_FMap [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: t_PtrOwn) = [%#sinvariant] inv'3 self
  
  predicate inv'12 (_0: t_PtrOwn)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate inv'13 (_0: t_Option'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'12 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: UInt64.t) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'11 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'13 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'13 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any [ return''0 (result: t_PtrOwn) -> {inv'12 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  predicate invariant''9 (self: t_PtrOwn) = [%#sghost'5] inv'12 self
  
  predicate inv'14 (_0: t_PtrOwn)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_PtrOwn [inv'14 x]. inv'14 x = invariant''9 x
  
  let rec new (x: t_PtrOwn) (return' (x'0: t_PtrOwn)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'12 x}
    any [ return''0 (result: t_PtrOwn) -> {[%#sghost'3] inv'14 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  predicate invariant''10 (self: t_Content) = [%#sinvariant] inv'1 self
  
  predicate inv'15 (_0: t_Content)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Content [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return' (x: t_Content)) =
    {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'14 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any
    [ return''0 (result: t_Content) -> {[%#sptr_own'1] inv'15 result}
      {[%#sptr_own'2] result = val' own}
      (! return' {result}) ]
  
  let rec v_Root (input: t_Content) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {C_Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [C_Root rank payload: t_Content]. C_Root rank payload <> input}
      (! {false}
      any) ]
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'11] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'9] inv'6 self)
      -> ([%#sunion_find'10] forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'5] contains (domain self) e
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'14] (self.t_UnionFind__0).t_HFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. ([%#sunion_find'12] inv'6 self)
      -> ([%#sunion_find'13] forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find.rs" 148 8 148 54] (self: t_UnionFind) (e: t_Element) : t_Element =
    [%#sunion_find'6] index_logic'1 (roots_map self) e
  
  predicate invariant''11 (self: t_T) = [%#sinvariant] inv'0 self
  
  predicate inv'16 (_0: t_T)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_T [inv'16 x]. inv'16 x = invariant''11 x
  
  function payloads_map [#"union_find.rs" 154 8 154 59] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'15] (self.t_UnionFind__0).t_HFInner__payloads
  
  function payload [#"union_find.rs" 164 8 164 48] (self: t_UnionFind) (e: t_Element) : t_T =
    [%#sunion_find'7] index_logic'2 (payloads_map self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get'0 [#"union_find.rs" 271 4 271 67] (uf: t_UnionFind) (elem: t_Element) (return' (x: t_T)) =
    {[@expl:get 'uf' type invariant] [%#sunion_find] inv'8 uf}
    {[@expl:get requires #0] [%#sunion_find'0] in_domain uf elem}
    {[@expl:get requires #1] [%#sunion_find'1] root uf elem = elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref {uf'0} (fun (_ret: t_UnionFind) -> [ &_10 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = addr {elem'0} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_13 <- _14 ] s1
      | s1 = get_ghost {(_10.t_UnionFind__0).t_HFInner__map} {_13} (fun (_ret: t_Option'0) -> [ &_8 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = unwrap {_8} (fun (_ret: t_PtrOwn) -> [ &_7 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_7} (fun (_ret: t_PtrOwn) -> [ &perm <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = as_ref {elem'0.t_Element__0} {perm} (fun (_ret: t_Content) -> [ &_16 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_16 = C_Root x0 x1} (! bb9)
      | br1 (x0: t_Element) -> {_16 = C_Link x0} (! bb10) ]
    | bb10 = bb10'0 [ bb10'0 = (! bb10'0) ]
    | bb9 = s0
      [ s0 = v_Root {_16} (fun (rrank: t_PeanoInt) (rpayload: t_T) -> [ &payload'0 <- rpayload ] s1)
      | s1 = [ &_0 <- payload'0 ] s2
      | s2 = return''0 {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & uf'0: t_UnionFind = uf
    | & elem'0: t_Element = elem
    | & perm: t_PtrOwn = Any.any_l ()
    | & _7: t_PtrOwn = Any.any_l ()
    | & _8: t_Option'0 = Any.any_l ()
    | & _10: t_UnionFind = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _16: t_Content = Any.any_l ()
    | & payload'0: t_T = Any.any_l () ])
    [ return''0 (result: t_T) -> {[@expl:get result type invariant] [%#sunion_find'2] inv'16 result}
      {[@expl:get ensures] [%#sunion_find'3] result = payload uf elem}
      (! return' {result}) ]
end
module M_union_find__implementation__equiv [#"union_find.rs" 284 4 284 93]
  let%span sunion_find = "union_find.rs" 284 24 284 26
  let%span sunion_find'0 = "union_find.rs" 280 4 280 33
  let%span sunion_find'1 = "union_find.rs" 281 4 281 33
  let%span sunion_find'2 = "union_find.rs" 282 14 282 52
  let%span sunion_find'3 = "union_find.rs" 283 4 283 30
  let%span sunion_find'4 = "union_find.rs" 261 19 261 21
  let%span sunion_find'5 = "union_find.rs" 258 4 258 35
  let%span sunion_find'6 = "union_find.rs" 259 14 259 37
  let%span sunion_find'7 = "union_find.rs" 260 4 260 30
  let%span sunion_find'8 = "union_find.rs" 122 8 122 16
  let%span sunion_find'9 = "union_find.rs" 146 8 146 16
  let%span sunion_find'10 = "union_find.rs" 173 16 175 64
  let%span sunion_find'11 = "union_find.rs" 115 19 115 28
  let%span sunion_find'12 = "union_find.rs" 116 18 116 150
  let%span sunion_find'13 = "union_find.rs" 114 8 114 16
  let%span sunion_find'14 = "union_find.rs" 133 19 133 28
  let%span sunion_find'15 = "union_find.rs" 134 18 136 42
  let%span sunion_find'16 = "union_find.rs" 132 8 132 16
  let%span sunion_find'17 = "union_find.rs" 153 8 153 16
  let%span sunion_find'18 = "union_find.rs" 80 12 80 39
  let%span sunion_find'19 = "union_find.rs" 24 8 24 16
  let%span sunion_find'20 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 109 22 109 66
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'1 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'19] addr_logic self.t_Element__0
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'0] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap] get self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'20] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'18] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'1] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr'0] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'3] forall k: UInt64.t. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 (self: MutBorrow.t t_UnionFind) = [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self: MutBorrow.t t_UnionFind) = [%#sghost'5] inv'7 self
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate invariant''5 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'10 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return' (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'9 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {[%#sghost'0] inv'10 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_UnionFind) = [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_UnionFind) = resolve'1 _0
  
  let rec new (x: MutBorrow.t t_UnionFind) (return' (x'0: MutBorrow.t t_UnionFind)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'7 x}
    any
    [ return''0 (result: MutBorrow.t t_UnionFind) -> {[%#sghost'3] inv'8 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'13] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'11] inv'6 self)
      -> ([%#sunion_find'12] forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'8] contains (domain self) e
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'16] (self.t_UnionFind__0).t_HFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. ([%#sunion_find'14] inv'6 self)
      -> ([%#sunion_find'15] forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find.rs" 148 8 148 54] (self: t_UnionFind) (e: t_Element) : t_Element =
    [%#sunion_find'9] index_logic'1 (roots_map self) e
  
  function payloads_map [#"union_find.rs" 154 8 154 59] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'17] (self.t_UnionFind__0).t_HFInner__payloads
  
  predicate unchanged [#"union_find.rs" 171 8 171 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'10] domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  let rec find (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return' (x: t_Element)) =
    {[@expl:find 'uf' type invariant] [%#sunion_find'4] inv'8 uf}
    {[@expl:find requires] [%#sunion_find'5] in_domain uf.current elem}
    any
    [ return''0 (result: t_Element) -> {[%#sunion_find'6] result = root uf.current elem}
      {[%#sunion_find'7] unchanged uf}
      (! return' {result}) ]
  
  let rec addr_eq (p: Opaque.ptr) (q: Opaque.ptr) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#sptr] result = (addr_logic p = addr_logic q)} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec equiv [#"union_find.rs" 284 4 284 93] (uf: MutBorrow.t t_UnionFind) (e1: t_Element) (e2: t_Element)
    (return' (x: bool)) = {[@expl:equiv 'uf' type invariant] [%#sunion_find] inv'8 uf}
    {[@expl:equiv requires #0] [%#sunion_find'0] in_domain uf.current e1}
    {[@expl:equiv requires #1] [%#sunion_find'1] in_domain uf.current e2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_14 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_13 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'6 (_13.current).current}
        MutBorrow.borrow_mut <t_UnionFind> {(_13.current).current}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_12 <- _ret ] -{inv'6 _ret.final}-
            [ &_13 <- { _13 with current = { _13.current with current = _ret.final } } ] s1)
      | s1 = {inv'6 _12.current}
        MutBorrow.borrow_final <t_UnionFind> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_11 <- _ret ] -{inv'6 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'10 _13} s3
      | s3 = -{resolve'0 _13}- s4
      | s4 = {[@expl:type invariant] inv'7 _12} s5
      | s5 = -{resolve'2 _12}- s6
      | s6 = {inv'6 _11.current}
        MutBorrow.borrow_final <t_UnionFind> {_11.current} {MutBorrow.get_id _11}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_10 <- _ret ] -{inv'6 _ret.final}-
            [ &_11 <- { _11 with current = _ret.final } ] s7)
      | s7 = new {_10} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_9 <- _ret ] s8)
      | s8 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'7 _11} s1
      | s1 = -{resolve'2 _11}- s2
      | s2 = find {_9} {e1'0} (fun (_ret: t_Element) -> [ &r1 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0 [ s0 = find {uf'0} {e2'0} (fun (_ret: t_Element) -> [ &r2 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = addr_eq {r1.t_Element__0} {r2.t_Element__0} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = return''0 {_0} ]
    [ & _0: bool = Any.any_l ()
    | & uf'0: MutBorrow.t t_UnionFind = uf
    | & e1'0: t_Element = e1
    | & e2'0: t_Element = e2
    | & r1: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _10: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _11: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _12: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _13: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _14: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & r2: t_Element = Any.any_l () ])
    [ return''0 (result: bool) -> {[@expl:equiv ensures #0] [%#sunion_find'2] result
      = (root uf.current e1 = root uf.current e2)}
      {[@expl:equiv ensures #1] [%#sunion_find'3] unchanged uf}
      (! return' {result}) ]
end
module M_union_find__implementation__link [#"union_find.rs" 300 4 300 92]
  let%span sunion_find = "union_find.rs" 319 27 319 92
  let%span sunion_find'0 = "union_find.rs" 320 31 320 59
  let%span sunion_find'1 = "union_find.rs" 321 30 321 99
  let%span sunion_find'2 = "union_find.rs" 336 27 336 92
  let%span sunion_find'3 = "union_find.rs" 337 31 337 59
  let%span sunion_find'4 = "union_find.rs" 338 30 338 99
  let%span sunion_find'5 = "union_find.rs" 300 19 300 21
  let%span sunion_find'6 = "union_find.rs" 291 4 291 51
  let%span sunion_find'7 = "union_find.rs" 292 15 292 49
  let%span sunion_find'8 = "union_find.rs" 293 4 293 64
  let%span sunion_find'9 = "union_find.rs" 294 14 294 58
  let%span sunion_find'10 = "union_find.rs" 295 14 295 42
  let%span sunion_find'11 = "union_find.rs" 296 14 298 98
  let%span sunion_find'12 = "union_find.rs" 17 18 17 69
  let%span sunion_find'13 = "union_find.rs" 32 18 32 46
  let%span sunion_find'14 = "union_find.rs" 122 8 122 16
  let%span sunion_find'15 = "union_find.rs" 146 8 146 16
  let%span sunion_find'16 = "union_find.rs" 183 24 183 60
  let%span sunion_find'17 = "union_find.rs" 190 24 190 72
  let%span sunion_find'18 = "union_find.rs" 24 8 24 16
  let%span sunion_find'19 = "union_find.rs" 115 19 115 28
  let%span sunion_find'20 = "union_find.rs" 116 18 116 150
  let%span sunion_find'21 = "union_find.rs" 114 8 114 16
  let%span sunion_find'22 = "union_find.rs" 133 19 133 28
  let%span sunion_find'23 = "union_find.rs" 134 18 136 42
  let%span sunion_find'24 = "union_find.rs" 132 8 132 16
  let%span sunion_find'25 = "union_find.rs" 153 8 153 16
  let%span sunion_find'26 = "union_find.rs" 80 12 80 39
  let%span sunion_find'27 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 344 22 344 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 344 4 344 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 343 14 343 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 377 30 377 34
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 377 4 377 62
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 366 14 374 9
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 375 14 375 73
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 376 44
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 81 41 81 44
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 78 15 78 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 81 4 81 70
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 79 14 79 35
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 99 41 99 44
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 95 15 95 31
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 99 4 99 78
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 96 14 96 35
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 97 14 97 39
  let%span sptr_own'8 = "../../creusot-contracts/src/ptr_own.rs" 98 14 98 38
  let%span sptr_own'9 = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 70 14 70 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 70 4 70 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 69 14 69 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 119 8 119 22
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span speano = "../../creusot-contracts/src/peano.rs" 142 14 142 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 132 14 132 38
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'18] addr_logic self.t_Element__0
  
  function deep_model'0 (self: t_Element) : UInt64.t = [%#smodel] deep_model self
  
  let rec eq (self: t_Element) (other: t_Element) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#sunion_find'12] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'7] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap'8] get self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'12] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'9] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'27] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'26] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own'9] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'11] forall k: UInt64.t. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 (self: MutBorrow.t t_UnionFind) = [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self: MutBorrow.t t_UnionFind) = [%#sghost'10] inv'7 self
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate resolve (self: MutBorrow.t t_UnionFind) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_UnionFind) = resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_UnionFind) = [%#sghost'9] resolve'0 self
  
  predicate resolve'2 (_0: MutBorrow.t t_UnionFind) = resolve'1 _0
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) = [%#sinvariant'0] inv'8 self
  
  predicate inv'9 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 (self: MutBorrow.t t_UnionFind) = [%#sinvariant'0] inv'7 self
  
  predicate inv'10 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref (self: MutBorrow.t t_UnionFind) (return' (x: MutBorrow.t t_UnionFind)) =
    {[@expl:deref 'self' type invariant] [%#sghost] inv'9 self}
    any
    [ return''0 (result: MutBorrow.t t_UnionFind) -> {[%#sghost'0] inv'10 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  let rec addr (self: t_Element) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#sunion_find'13] result = deep_model self} (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''7 (self: t_FMap) = [%#sinvariant'0] inv'4 self
  
  predicate inv'11 (_0: t_FMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_FMap [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: t_PtrOwn) = [%#sinvariant'0] inv'3 self
  
  predicate inv'12 (_0: t_PtrOwn)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate inv'13 (_0: t_Option'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'12 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: UInt64.t) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'11 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'13 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'13 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any [ return''0 (result: t_PtrOwn) -> {inv'12 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  predicate invariant''9 (self: t_PtrOwn) = [%#sghost'10] inv'12 self
  
  predicate inv'14 (_0: t_PtrOwn)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_PtrOwn [inv'14 x]. inv'14 x = invariant''9 x
  
  let rec new (x: t_PtrOwn) (return' (x'0: t_PtrOwn)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'12 x}
    any [ return''0 (result: t_PtrOwn) -> {[%#sghost'3] inv'14 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  predicate invariant''10 (self: t_Content) = [%#sinvariant'0] inv'1 self
  
  predicate inv'15 (_0: t_Content)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Content [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return' (x: t_Content)) =
    {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'14 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any
    [ return''0 (result: t_Content) -> {[%#sptr_own'1] inv'15 result}
      {[%#sptr_own'2] result = val' own}
      (! return' {result}) ]
  
  let rec v_Root (input: t_Content) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {C_Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [C_Root rank payload: t_Content]. C_Root rank payload <> input}
      (! {false}
      any) ]
  
  let rec to_u64 (self: t_PeanoInt) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#speano] result = self.t_PeanoInt__0} (! return' {result}) ]
  
  predicate invariant''11 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'16 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'16 x]. inv'16 x = invariant''11 x
  
  predicate invariant''12 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'17 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'17 x]. inv'17 x = invariant''12 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return' (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'16 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {[%#sghost'6] inv'17 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  predicate invariant''13 (self: MutBorrow.t t_HFInner) = [%#sinvariant] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'18 (_0: MutBorrow.t t_HFInner)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_HFInner [inv'18 x]. inv'18 x = invariant''13 x
  
  predicate invariant''14 (self: MutBorrow.t t_HFInner) = [%#sghost'10] inv'18 self
  
  predicate inv'19 (_0: MutBorrow.t t_HFInner)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_HFInner [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec new'0 (x: MutBorrow.t t_HFInner) (return' (x'0: MutBorrow.t t_HFInner)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'18 x}
    any
    [ return''0 (result: MutBorrow.t t_HFInner) -> {[%#sghost'3] inv'19 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate invariant''15 (self: MutBorrow.t (MutBorrow.t t_HFInner)) =
    [%#sinvariant] inv'19 self.current /\ inv'19 self.final
  
  predicate inv'20 (_0: MutBorrow.t (MutBorrow.t t_HFInner))
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_HFInner) [inv'20 x]. inv'20 x = invariant''15 x
  
  predicate invariant''16 (self: MutBorrow.t (MutBorrow.t t_HFInner)) =
    [%#sinvariant] inv'18 self.current /\ inv'18 self.final
  
  predicate inv'21 (_0: MutBorrow.t (MutBorrow.t t_HFInner))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_HFInner) [inv'21 x]. inv'21 x = invariant''16 x
  
  let rec deref_mut'0 (self: MutBorrow.t (MutBorrow.t t_HFInner)) (return' (x: MutBorrow.t (MutBorrow.t t_HFInner))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'20 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_HFInner)) -> {[%#sghost'6] inv'21 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_PtrOwn)
  
  predicate invariant''17 (self: MutBorrow.t t_FMap) = [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'22 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'22 x]. inv'22 x = invariant''17 x
  
  predicate invariant''18 (self: MutBorrow.t t_PtrOwn) = [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'23 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'23 x]. inv'23 x = invariant''18 x
  
  predicate inv'24 (_0: t_Option'1)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_Option'1 [inv'24 x]. inv'24 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'23 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'10] len self >= 0
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: UInt64.t) (return' (x: t_Option'1)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'2] inv'22 self}
    any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'3] inv'24 result}
      {[%#sfmap'4] if contains'0 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'0 self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'5] forall k: UInt64.t. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'6] len self.current = len self.final}
      (! return' {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return' (x: MutBorrow.t t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'24 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result: MutBorrow.t t_PtrOwn) -> {inv'23 result}
      {[%#soption'1] C_Some'1 result = self_}
      (! return' {result}) ]
  
  predicate resolve'3 (self: MutBorrow.t (MutBorrow.t t_HFInner)) = [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t (MutBorrow.t t_HFInner)) = resolve'3 _0
  
  predicate invariant''19 (self: MutBorrow.t t_PtrOwn) = [%#sghost'10] inv'23 self
  
  predicate inv'25 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'24 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'25 x]. inv'25 x = invariant''19 x
  
  let rec new'1 (x: MutBorrow.t t_PtrOwn) (return' (x'0: MutBorrow.t t_PtrOwn)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'23 x}
    any
    [ return''0 (result: MutBorrow.t t_PtrOwn) -> {[%#sghost'3] inv'25 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate resolve'5 (self: MutBorrow.t t_PtrOwn) = [%#sresolve] self.final = self.current
  
  predicate resolve'6 (_0: MutBorrow.t t_PtrOwn) = resolve'5 _0
  
  predicate invariant''20 (self: MutBorrow.t t_Content) = [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'26 (_0: MutBorrow.t t_Content)
  
  axiom inv_axiom'25 [@rewrite]: forall x: MutBorrow.t t_Content [inv'26 x]. inv'26 x = invariant''20 x
  
  function fin (self: MutBorrow.t t_PtrOwn) : t_PtrOwn = [%#sghost'8] self.final
  
  let rec as_mut (ptr'0: Opaque.ptr) (own: MutBorrow.t t_PtrOwn) (return' (x: MutBorrow.t t_Content)) =
    {[@expl:as_mut 'own' type invariant] [%#sptr_own'3] inv'25 own}
    {[@expl:as_mut requires] [%#sptr_own'4] ptr'0 = ptr own.current}
    any
    [ return''0 (result: MutBorrow.t t_Content) -> {[%#sptr_own'5] inv'26 result}
      {[%#sptr_own'6] result.current = val' own.current}
      {[%#sptr_own'7] ptr (fin own) = ptr own.current}
      {[%#sptr_own'8] val' (fin own) = result.final}
      (! return' {result}) ]
  
  predicate resolve'7 (self: MutBorrow.t t_Content) = [%#sresolve] self.final = self.current
  
  predicate resolve'8 (_0: MutBorrow.t t_Content) = resolve'7 _0
  
  predicate resolve'9 (self: MutBorrow.t t_HFInner) = [%#sresolve] self.final = self.current
  
  predicate resolve'10 (_0: MutBorrow.t t_HFInner) = resolve'9 _0
  
  predicate resolve'11 (self: MutBorrow.t t_HFInner) = [%#sghost'9] resolve'10 self
  
  predicate resolve'12 (_0: MutBorrow.t t_HFInner) = resolve'11 _0
  
  predicate resolve'13 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = [%#sresolve] self.final = self.current
  
  predicate resolve'14 (_0: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve'13 _0
  
  let rec new'2 (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'4] result = x} (! return' {result}) ]
  
  let rec incr (self: t_PeanoInt) (return' (x: t_PeanoInt)) = any
    [ return''0 (result: t_PeanoInt) -> {[%#speano'0] UInt64.t'int result.t_PeanoInt__0
      = UInt64.t'int self.t_PeanoInt__0 + 1}
      (! return' {result}) ]
  
  predicate resolve'15 (self: MutBorrow.t t_PeanoInt) = [%#sresolve] self.final = self.current
  
  predicate resolve'16 (_0: MutBorrow.t t_PeanoInt) = resolve'15 _0
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'21] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'19] inv'6 self)
      -> ([%#sunion_find'20] forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'14] contains (domain self) e
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'24] (self.t_UnionFind__0).t_HFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. ([%#sunion_find'22] inv'6 self)
      -> ([%#sunion_find'23] forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find.rs" 148 8 148 54] (self: t_UnionFind) (e: t_Element) : t_Element =
    [%#sunion_find'15] index_logic'1 (roots_map self) e
  
  predicate domain_unchanged [#"union_find.rs" 182 8 182 50] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'16] domain self.current = domain self.final
  
  function payloads_map [#"union_find.rs" 154 8 154 59] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'25] (self.t_UnionFind__0).t_HFInner__payloads
  
  predicate payloads_unchanged [#"union_find.rs" 189 8 189 52] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'17] payloads_map self.current = payloads_map self.final
  
  function fin'0 (self: MutBorrow.t t_UnionFind) : t_UnionFind = [%#sghost'8] self.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec link [#"union_find.rs" 300 4 300 92] (uf: MutBorrow.t t_UnionFind) (x: t_Element) (y: t_Element)
    (return' (x'0: t_Element)) = {[@expl:link 'uf' type invariant] [%#sunion_find'5] inv'8 uf}
    {[@expl:link requires #0] [%#sunion_find'6] in_domain uf.current x /\ in_domain uf.current y}
    {[@expl:link requires #1] [%#sunion_find'7] root uf.current x = x /\ root uf.current y = y}
    (! bb0
    [ bb0 = s0 [ s0 = eq {x'0} {y'0} (fun (_ret: bool) -> [ &_11 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_11 = false} (! bb3) | br1 -> {_11} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'8 uf'0} s1 | s1 = -{resolve'2 uf'0}- s2 | s2 = [ &_0 <- x'0 ] s3 | s3 = bb77 ]
    | bb3 = s0 [ s0 = deref {uf'0} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_19 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = addr {x'0} (fun (_ret: UInt64.t) -> [ &_23 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_22 <- _23 ] s1
      | s1 = get_ghost {((_19.current).t_UnionFind__0).t_HFInner__map} {_22}
          (fun (_ret: t_Option'0) -> [ &_17 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = unwrap {_17} (fun (_ret: t_PtrOwn) -> [ &_16 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = new {_16} (fun (_ret: t_PtrOwn) -> [ &perm_x <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = deref {uf'0} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_29 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0 [ s0 = addr {y'0} (fun (_ret: UInt64.t) -> [ &_33 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0
      [ s0 = [ &_32 <- _33 ] s1
      | s1 = get_ghost {((_29.current).t_UnionFind__0).t_HFInner__map} {_32}
          (fun (_ret: t_Option'0) -> [ &_27 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0 [ s0 = unwrap {_27} (fun (_ret: t_PtrOwn) -> [ &_26 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = new {_26} (fun (_ret: t_PtrOwn) -> [ &perm_y <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = as_ref {x'0.t_Element__0} {perm_x} (fun (_ret: t_Content) -> [ &_36 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_36 = C_Root x0 x1} (! bb17)
      | br1 (x0: t_Element) -> {_36 = C_Link x0} (! bb15) ]
    | bb15 = s0 [ s0 = {[@expl:type invariant] inv'8 uf'0} s1 | s1 = -{resolve'2 uf'0}- s2 | s2 = {false} any ]
    | bb17 = s0
      [ s0 = v_Root {_36} (fun (rrank: t_PeanoInt) (rpayload: t_T) -> [ &rank <- rrank ] s1)
      | s1 = to_u64 {rank} (fun (_ret: UInt64.t) -> [ &rx <- _ret ] s2)
      | s2 = bb18 ]
    | bb18 = s0 [ s0 = as_ref {y'0.t_Element__0} {perm_y} (fun (_ret: t_Content) -> [ &_44 <- _ret ] s1) | s1 = bb19 ]
    | bb19 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_44 = C_Root x0 x1} (! bb22)
      | br1 (x0: t_Element) -> {_44 = C_Link x0} (! bb20) ]
    | bb20 = s0 [ s0 = {[@expl:type invariant] inv'8 uf'0} s1 | s1 = -{resolve'2 uf'0}- s2 | s2 = {false} any ]
    | bb22 = s0
      [ s0 = v_Root {_44} (fun (rrank: t_PeanoInt) (rpayload: t_T) -> [ &rank'0 <- rrank ] s1)
      | s1 = to_u64 {rank'0} (fun (_ret: UInt64.t) -> [ &ry <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0
      [ s0 = [ &_51 <- UInt64.lt rx ry ] s1 | s1 = any [ br0 -> {_51 = false} (! bb25) | br1 -> {_51} (! bb24) ] ]
    | bb24 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_56 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_56} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_55 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = s0
      [ s0 = {inv'5 ((_55.current).current).t_UnionFind__0}
        MutBorrow.borrow_mut <t_HFInner> {((_55.current).current).t_UnionFind__0}
          (fun (_ret: MutBorrow.t t_HFInner) ->
            [ &__temp <- _ret ] -{inv'5 _ret.final}-
            [ &_55 <- { _55 with current = { _55.current with current = { t_UnionFind__0 = _ret.final } } } ] s1)
      | s1 = new'0 {__temp} (fun (_ret: MutBorrow.t t_HFInner) -> [ &uf'1 <- _ret ] s2)
      | s2 = bb27 ]
    | bb27 = s0
      [ s0 = {inv'19 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_65 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_65} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_64 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0 [ s0 = addr {x'0} (fun (_ret: UInt64.t) -> [ &_68 <- _ret ] s1) | s1 = bb29 ]
    | bb29 = s0
      [ s0 = [ &_67 <- _68 ] s1
      | s1 = {inv'4 ((_64.current).current).t_HFInner__map}
        MutBorrow.borrow_mut <t_FMap> {((_64.current).current).t_HFInner__map}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_63 <- _ret ] -{inv'4 _ret.final}-
            [ &_64 <- { _64 with current = { _64.current with current = { (_64.current).current with t_HFInner__map = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_63} {_67} (fun (_ret: t_Option'1) -> [ &_62 <- _ret ] s3)
      | s3 = bb30 ]
    | bb30 = s0 [ s0 = unwrap'0 {_62} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_61 <- _ret ] s1) | s1 = bb31 ]
    | bb31 = s0
      [ s0 = {[@expl:type invariant] inv'21 _64} s1
      | s1 = -{resolve'4 _64}- s2
      | s2 = {inv'3 _61.current}
        MutBorrow.borrow_final <t_PtrOwn> {_61.current} {MutBorrow.get_id _61}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_60 <- _ret ] -{inv'3 _ret.final}-
            [ &_61 <- { _61 with current = _ret.final } ] s3)
      | s3 = new'1 {_60} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &perm_mut_x <- _ret ] s4)
      | s4 = bb32 ]
    | bb32 = s0
      [ s0 = {[@expl:type invariant] inv'23 _61} s1
      | s1 = -{resolve'6 _61}- s2
      | s2 = [ &_71 <- C_Link y'0 ] s3
      | s3 = as_mut {x'0.t_Element__0} {perm_mut_x} (fun (_ret: MutBorrow.t t_Content) -> [ &_73 <- _ret ] s4)
      | s4 = bb34 ]
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'1 _73.current} s1
      | s1 = [ &_73 <- { _73 with current = _71 } ] s2
      | s2 = {[@expl:type invariant] inv'26 _73} s3
      | s3 = -{resolve'8 _73}- s4
      | s4 = bb36 ]
    | bb36 = s0
      [ s0 = [ &_78 <- [%#sunion_find] fun (z: t_Element) -> if index_logic'1 (uf'1.current).t_HFInner__roots z
        = x'0 then
          y'0
        else
          index_logic'1 (uf'1.current).t_HFInner__roots z
         ] s1
      | s1 = bb37 ]
    | bb37 = s0
      [ s0 = {inv'19 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_81 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_81} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_80 <- _ret ] s2)
      | s2 = bb38 ]
    | bb38 = s0
      [ s0 =
        [ &_80 <- { _80 with current = { _80.current with current = { (_80.current).current with t_HFInner__roots = _78 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'21 _80} s2
      | s2 = -{resolve'4 _80}- s3
      | s3 = [ &_82 <- [%#sunion_find'0] (uf'1.current).t_HFInner__max_depth + 1 ] s4
      | s4 = bb39 ]
    | bb39 = s0
      [ s0 = {inv'19 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_85 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_85} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_84 <- _ret ] s2)
      | s2 = bb40 ]
    | bb40 = s0
      [ s0 =
        [ &_84 <- { _84 with current = { _84.current with current = { (_84.current).current with t_HFInner__max_depth = _82 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'21 _84} s2
      | s2 = -{resolve'4 _84}- s3
      | s3 = [ &_86 <- [%#sunion_find'1] Map.set (uf'1.current).t_HFInner__distance y'0 (1
        + MinMax.max (index_logic'3 (uf'1.current).t_HFInner__distance x'0) (index_logic'3 (uf'1.current).t_HFInner__distance y'0)) ]
        s4
      | s4 = bb41 ]
    | bb41 = s0
      [ s0 = {inv'19 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_89 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_89} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_88 <- _ret ] s2)
      | s2 = bb42 ]
    | bb42 = s0
      [ s0 =
        [ &_88 <- { _88 with current = { _88.current with current = { (_88.current).current with t_HFInner__distance = _86 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'21 _88} s2
      | s2 = -{resolve'4 _88}- s3
      | s3 = {[@expl:type invariant] inv'19 uf'1} s4
      | s4 = -{resolve'12 uf'1}- s5
      | s5 = {[@expl:type invariant] inv'17 _55} s6
      | s6 = -{resolve'14 _55}- s7
      | s7 = {[@expl:type invariant] inv'8 uf'0} s8
      | s8 = -{resolve'2 uf'0}- s9
      | s9 = new'2 {_77} (fun (_ret: ()) -> [ &_76 <- _ret ] s10)
      | s10 = bb43 ]
    | bb43 = s0 [ s0 = [ &_0 <- y'0 ] s1 | s1 = bb77 ]
    | bb25 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_92 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_92} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_91 <- _ret ] s2)
      | s2 = bb44 ]
    | bb44 = s0
      [ s0 = {inv'5 ((_91.current).current).t_UnionFind__0}
        MutBorrow.borrow_mut <t_HFInner> {((_91.current).current).t_UnionFind__0}
          (fun (_ret: MutBorrow.t t_HFInner) ->
            [ &__temp'0 <- _ret ] -{inv'5 _ret.final}-
            [ &_91 <- { _91 with current = { _91.current with current = { t_UnionFind__0 = _ret.final } } } ] s1)
      | s1 = new'0 {__temp'0} (fun (_ret: MutBorrow.t t_HFInner) -> [ &uf'2 <- _ret ] s2)
      | s2 = bb45 ]
    | bb45 = s0
      [ s0 = {inv'19 uf'2}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'2}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_101 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'2 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_101} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_100 <- _ret ] s2)
      | s2 = bb46 ]
    | bb46 = s0 [ s0 = addr {y'0} (fun (_ret: UInt64.t) -> [ &_104 <- _ret ] s1) | s1 = bb47 ]
    | bb47 = s0
      [ s0 = [ &_103 <- _104 ] s1
      | s1 = {inv'4 ((_100.current).current).t_HFInner__map}
        MutBorrow.borrow_mut <t_FMap> {((_100.current).current).t_HFInner__map}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_99 <- _ret ] -{inv'4 _ret.final}-
            [ &_100 <- { _100 with current = { _100.current with current = { (_100.current).current with t_HFInner__map = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_99} {_103} (fun (_ret: t_Option'1) -> [ &_98 <- _ret ] s3)
      | s3 = bb48 ]
    | bb48 = s0 [ s0 = unwrap'0 {_98} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_97 <- _ret ] s1) | s1 = bb49 ]
    | bb49 = s0
      [ s0 = {[@expl:type invariant] inv'21 _100} s1
      | s1 = -{resolve'4 _100}- s2
      | s2 = {inv'3 _97.current}
        MutBorrow.borrow_final <t_PtrOwn> {_97.current} {MutBorrow.get_id _97}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_96 <- _ret ] -{inv'3 _ret.final}-
            [ &_97 <- { _97 with current = _ret.final } ] s3)
      | s3 = new'1 {_96} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &perm_mut_y <- _ret ] s4)
      | s4 = bb50 ]
    | bb50 = s0
      [ s0 = {[@expl:type invariant] inv'23 _97} s1
      | s1 = -{resolve'6 _97}- s2
      | s2 = [ &_107 <- C_Link x'0 ] s3
      | s3 = as_mut {y'0.t_Element__0} {perm_mut_y} (fun (_ret: MutBorrow.t t_Content) -> [ &_109 <- _ret ] s4)
      | s4 = bb52 ]
    | bb52 = s0
      [ s0 = {[@expl:type invariant] inv'1 _109.current} s1
      | s1 = [ &_109 <- { _109 with current = _107 } ] s2
      | s2 = {[@expl:type invariant] inv'26 _109} s3
      | s3 = -{resolve'8 _109}- s4
      | s4 = bb54 ]
    | bb54 = s0 [ s0 = [ &_113 <- rx = ry ] s1 | s1 = any [ br0 -> {_113 = false} (! bb68) | br1 -> {_113} (! bb55) ] ]
    | bb55 = s0
      [ s0 = {inv'19 uf'2}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'2}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_122 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'2 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_122} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_121 <- _ret ] s2)
      | s2 = bb56 ]
    | bb56 = s0 [ s0 = addr {x'0} (fun (_ret: UInt64.t) -> [ &_125 <- _ret ] s1) | s1 = bb57 ]
    | bb57 = s0
      [ s0 = [ &_124 <- _125 ] s1
      | s1 = {inv'4 ((_121.current).current).t_HFInner__map}
        MutBorrow.borrow_mut <t_FMap> {((_121.current).current).t_HFInner__map}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_120 <- _ret ] -{inv'4 _ret.final}-
            [ &_121 <- { _121 with current = { _121.current with current = { (_121.current).current with t_HFInner__map = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_120} {_124} (fun (_ret: t_Option'1) -> [ &_119 <- _ret ] s3)
      | s3 = bb58 ]
    | bb58 = s0 [ s0 = unwrap'0 {_119} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_118 <- _ret ] s1) | s1 = bb59 ]
    | bb59 = s0
      [ s0 = {[@expl:type invariant] inv'21 _121} s1
      | s1 = -{resolve'4 _121}- s2
      | s2 = {inv'3 _118.current}
        MutBorrow.borrow_final <t_PtrOwn> {_118.current} {MutBorrow.get_id _118}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_117 <- _ret ] -{inv'3 _ret.final}-
            [ &_118 <- { _118 with current = _ret.final } ] s3)
      | s3 = new'1 {_117} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &perm_mut_x'0 <- _ret ] s4)
      | s4 = bb60 ]
    | bb60 = s0
      [ s0 = {[@expl:type invariant] inv'23 _118} s1
      | s1 = -{resolve'6 _118}- s2
      | s2 = as_mut {x'0.t_Element__0} {perm_mut_x'0} (fun (_ret: MutBorrow.t t_Content) -> [ &_127 <- _ret ] s3)
      | s3 = bb61 ]
    | bb61 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_127.current = C_Root x0 x1} (! bb64)
      | br1 (x0: t_Element) -> {_127.current = C_Link x0} (! bb62) ]
    | bb62 = s0 [ s0 = {[@expl:type invariant] inv'26 _127} s1 | s1 = -{resolve'8 _127}- s2 | s2 = bb68 ]
    | bb64 = s0
      [ s0 = v_Root {_127.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_final <t_PeanoInt> {rrank} {MutBorrow.inherit_id (MutBorrow.get_id _127) 1}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &rank'1 <- _ret ] [ &_127 <- { _127 with current = C_Root _ret.final rpayload } ] s1))
      | s1 = incr {rank'1.current} (fun (_ret: t_PeanoInt) -> [ &_132 <- _ret ] s2)
      | s2 = bb65 ]
    | bb65 = s0
      [ s0 = [ &rank'1 <- { rank'1 with current = _132 } ] s1
      | s1 = -{resolve'16 rank'1}- s2
      | s2 = {[@expl:type invariant] inv'26 _127} s3
      | s3 = -{resolve'8 _127}- s4
      | s4 = bb68 ]
    | bb68 = s0
      [ s0 = [ &_136 <- [%#sunion_find'2] fun (z: t_Element) -> if index_logic'1 (uf'2.current).t_HFInner__roots z
        = y'0 then
          x'0
        else
          index_logic'1 (uf'2.current).t_HFInner__roots z
         ] s1
      | s1 = bb69 ]
    | bb69 = s0
      [ s0 = {inv'19 uf'2}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'2}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_139 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'2 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_139} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_138 <- _ret ] s2)
      | s2 = bb70 ]
    | bb70 = s0
      [ s0 =
        [ &_138 <- { _138 with current = { _138.current with current = { (_138.current).current with t_HFInner__roots = _136 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'21 _138} s2
      | s2 = -{resolve'4 _138}- s3
      | s3 = [ &_140 <- [%#sunion_find'3] (uf'2.current).t_HFInner__max_depth + 1 ] s4
      | s4 = bb71 ]
    | bb71 = s0
      [ s0 = {inv'19 uf'2}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'2}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_143 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'2 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_143} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_142 <- _ret ] s2)
      | s2 = bb72 ]
    | bb72 = s0
      [ s0 =
        [ &_142 <- { _142 with current = { _142.current with current = { (_142.current).current with t_HFInner__max_depth = _140 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'21 _142} s2
      | s2 = -{resolve'4 _142}- s3
      | s3 = [ &_144 <- [%#sunion_find'4] Map.set (uf'2.current).t_HFInner__distance x'0 (1
        + MinMax.max (index_logic'3 (uf'2.current).t_HFInner__distance x'0) (index_logic'3 (uf'2.current).t_HFInner__distance y'0)) ]
        s4
      | s4 = bb73 ]
    | bb73 = s0
      [ s0 = {inv'19 uf'2}
        MutBorrow.borrow_mut <MutBorrow.t t_HFInner> {uf'2}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) ->
            [ &_147 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'2 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_147} (fun (_ret: MutBorrow.t (MutBorrow.t t_HFInner)) -> [ &_146 <- _ret ] s2)
      | s2 = bb74 ]
    | bb74 = s0
      [ s0 =
        [ &_146 <- { _146 with current = { _146.current with current = { (_146.current).current with t_HFInner__distance = _144 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'21 _146} s2
      | s2 = -{resolve'4 _146}- s3
      | s3 = {[@expl:type invariant] inv'19 uf'2} s4
      | s4 = -{resolve'12 uf'2}- s5
      | s5 = {[@expl:type invariant] inv'17 _91} s6
      | s6 = -{resolve'14 _91}- s7
      | s7 = {[@expl:type invariant] inv'8 uf'0} s8
      | s8 = -{resolve'2 uf'0}- s9
      | s9 = new'2 {_135} (fun (_ret: ()) -> [ &_134 <- _ret ] s10)
      | s10 = bb75 ]
    | bb75 = s0 [ s0 = [ &_0 <- x'0 ] s1 | s1 = bb77 ]
    | bb77 = return''0 {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf'0: MutBorrow.t t_UnionFind = uf
    | & x'0: t_Element = x
    | & y'0: t_Element = y
    | & _11: bool = Any.any_l ()
    | & perm_x: t_PtrOwn = Any.any_l ()
    | & _16: t_PtrOwn = Any.any_l ()
    | & _17: t_Option'0 = Any.any_l ()
    | & _19: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _22: UInt64.t = Any.any_l ()
    | & _23: UInt64.t = Any.any_l ()
    | & perm_y: t_PtrOwn = Any.any_l ()
    | & _26: t_PtrOwn = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _29: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _32: UInt64.t = Any.any_l ()
    | & _33: UInt64.t = Any.any_l ()
    | & rx: UInt64.t = Any.any_l ()
    | & _36: t_Content = Any.any_l ()
    | & rank: t_PeanoInt = Any.any_l ()
    | & ry: UInt64.t = Any.any_l ()
    | & _44: t_Content = Any.any_l ()
    | & rank'0: t_PeanoInt = Any.any_l ()
    | & _51: bool = Any.any_l ()
    | & __temp: MutBorrow.t t_HFInner = Any.any_l ()
    | & _55: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _56: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & uf'1: MutBorrow.t t_HFInner = Any.any_l ()
    | & perm_mut_x: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _60: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _61: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _62: t_Option'1 = Any.any_l ()
    | & _63: MutBorrow.t t_FMap = Any.any_l ()
    | & _64: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _65: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _67: UInt64.t = Any.any_l ()
    | & _68: UInt64.t = Any.any_l ()
    | & _71: t_Content = Any.any_l ()
    | & _73: MutBorrow.t t_Content = Any.any_l ()
    | & _76: () = Any.any_l ()
    | & _77: () = Any.any_l ()
    | & _78: Map.map t_Element t_Element = Any.any_l ()
    | & _80: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _81: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _82: int = Any.any_l ()
    | & _84: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _85: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _86: Map.map t_Element int = Any.any_l ()
    | & _88: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _89: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & __temp'0: MutBorrow.t t_HFInner = Any.any_l ()
    | & _91: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _92: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & uf'2: MutBorrow.t t_HFInner = Any.any_l ()
    | & perm_mut_y: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _96: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _97: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _98: t_Option'1 = Any.any_l ()
    | & _99: MutBorrow.t t_FMap = Any.any_l ()
    | & _100: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _101: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _103: UInt64.t = Any.any_l ()
    | & _104: UInt64.t = Any.any_l ()
    | & _107: t_Content = Any.any_l ()
    | & _109: MutBorrow.t t_Content = Any.any_l ()
    | & _113: bool = Any.any_l ()
    | & perm_mut_x'0: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _117: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _118: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _119: t_Option'1 = Any.any_l ()
    | & _120: MutBorrow.t t_FMap = Any.any_l ()
    | & _121: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _122: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _124: UInt64.t = Any.any_l ()
    | & _125: UInt64.t = Any.any_l ()
    | & _127: MutBorrow.t t_Content = Any.any_l ()
    | & rank'1: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _132: t_PeanoInt = Any.any_l ()
    | & _134: () = Any.any_l ()
    | & _135: () = Any.any_l ()
    | & _136: Map.map t_Element t_Element = Any.any_l ()
    | & _138: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _139: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _140: int = Any.any_l ()
    | & _142: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _143: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _144: Map.map t_Element int = Any.any_l ()
    | & _146: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l ()
    | & _147: MutBorrow.t (MutBorrow.t t_HFInner) = Any.any_l () ])
    [ return''0 (result: t_Element) -> {[@expl:link ensures #0] [%#sunion_find'8] domain_unchanged uf
      /\ payloads_unchanged uf}
      {[@expl:link ensures #1] [%#sunion_find'9] result = root uf.current x \/ result = root uf.current y}
      {[@expl:link ensures #2] [%#sunion_find'10] result = root (fin'0 uf) result}
      {[@expl:link ensures #3] [%#sunion_find'11] forall z: t_Element. in_domain uf.current z
        -> root (fin'0 uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return' {result}) ]
end
module M_union_find__implementation__union [#"union_find.rs" 353 4 353 97]
  let%span sunion_find = "union_find.rs" 353 24 353 26
  let%span sunion_find'0 = "union_find.rs" 345 4 345 51
  let%span sunion_find'1 = "union_find.rs" 346 4 346 64
  let%span sunion_find'2 = "union_find.rs" 347 14 347 58
  let%span sunion_find'3 = "union_find.rs" 348 14 351 31
  let%span sunion_find'4 = "union_find.rs" 261 19 261 21
  let%span sunion_find'5 = "union_find.rs" 258 4 258 35
  let%span sunion_find'6 = "union_find.rs" 259 14 259 37
  let%span sunion_find'7 = "union_find.rs" 260 4 260 30
  let%span sunion_find'8 = "union_find.rs" 300 19 300 21
  let%span sunion_find'9 = "union_find.rs" 291 4 291 51
  let%span sunion_find'10 = "union_find.rs" 292 15 292 49
  let%span sunion_find'11 = "union_find.rs" 293 4 293 64
  let%span sunion_find'12 = "union_find.rs" 294 14 294 58
  let%span sunion_find'13 = "union_find.rs" 295 14 295 42
  let%span sunion_find'14 = "union_find.rs" 296 14 298 98
  let%span sunion_find'15 = "union_find.rs" 122 8 122 16
  let%span sunion_find'16 = "union_find.rs" 183 24 183 60
  let%span sunion_find'17 = "union_find.rs" 190 24 190 72
  let%span sunion_find'18 = "union_find.rs" 146 8 146 16
  let%span sunion_find'19 = "union_find.rs" 173 16 175 64
  let%span sunion_find'20 = "union_find.rs" 115 19 115 28
  let%span sunion_find'21 = "union_find.rs" 116 18 116 150
  let%span sunion_find'22 = "union_find.rs" 114 8 114 16
  let%span sunion_find'23 = "union_find.rs" 153 8 153 16
  let%span sunion_find'24 = "union_find.rs" 133 19 133 28
  let%span sunion_find'25 = "union_find.rs" 134 18 136 42
  let%span sunion_find'26 = "union_find.rs" 132 8 132 16
  let%span sunion_find'27 = "union_find.rs" 80 12 80 39
  let%span sunion_find'28 = "union_find.rs" 24 8 24 16
  let%span sunion_find'29 = "union_find.rs" 108 8 108 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'28] addr_logic self.t_Element__0
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'0] Map.get (view self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap] get self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 109 8 109 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'29] index_logic'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e)
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element t_T) (a: t_Element) : t_T = [%#smapping] Map.get self a
  
  function index_logic'3 (self: Map.map t_Element int) (a: t_Element) : int = [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind) =
    [%#sunion_find'27] let domain = (self.t_UnionFind__0).t_HFInner__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
          /\ contains domain e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
    /\ (forall e: t_Element. contains domain e -> contains'0 (self.t_UnionFind__0).t_HFInner__map (deep_model e))
    /\ (forall e: t_Element. contains domain e -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
        -> index_logic'1 (self.t_UnionFind__0).t_HFInner__roots (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
        = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)
    /\ (forall e: t_Element. contains domain e
        -> contains domain (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e))
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> e <> e2
          /\ contains domain e2
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e
          = index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e2
          | C_Root _ v -> index_logic'2 (self.t_UnionFind__0).t_HFInner__payloads e = v
          /\ index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e = e
          end)
    /\ (forall e: t_Element. contains domain e
        -> match val' (get_perm self e) with
          | C_Link e2 -> index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
          < index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e2
          | C_Root _ _ -> true
          end)
    /\ (self.t_UnionFind__0).t_HFInner__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
        -> 0 <= index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e
        /\ index_logic'3 (self.t_UnionFind__0).t_HFInner__distance e <= (self.t_UnionFind__0).t_HFInner__max_depth)
    /\ (forall e: t_Element. contains domain e
      -> match val' (get_perm self (index_logic'1 (self.t_UnionFind__0).t_HFInner__roots e)) with
        | C_Root _ _ -> true
        | C_Link _ -> false
        end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'3] forall k: UInt64.t. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 (self: MutBorrow.t t_UnionFind) = [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self: MutBorrow.t t_UnionFind) = [%#sghost'6] inv'7 self
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate invariant''5 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 (self: MutBorrow.t (MutBorrow.t t_UnionFind)) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'10 (_0: MutBorrow.t (MutBorrow.t t_UnionFind))
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UnionFind) [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UnionFind)) (return' (x: MutBorrow.t (MutBorrow.t t_UnionFind))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'9 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UnionFind)) -> {[%#sghost'0] inv'10 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_UnionFind)) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t (MutBorrow.t t_UnionFind)) = resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_UnionFind) = [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_UnionFind) = resolve'1 _0
  
  let rec new (x: MutBorrow.t t_UnionFind) (return' (x'0: MutBorrow.t t_UnionFind)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'7 x}
    any
    [ return''0 (result: MutBorrow.t t_UnionFind) -> {[%#sghost'3] inv'8 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'22] (self.t_UnionFind__0).t_HFInner__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'20] inv'6 self)
      -> ([%#sunion_find'21] forall e1: t_Element, e2: t_Element. contains (domain self) e1
          /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'15] contains (domain self) e
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'26] (self.t_UnionFind__0).t_HFInner__roots
  
  axiom roots_map_spec: forall self: t_UnionFind. ([%#sunion_find'24] inv'6 self)
      -> ([%#sunion_find'25] forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find.rs" 148 8 148 54] (self: t_UnionFind) (e: t_Element) : t_Element =
    [%#sunion_find'18] index_logic'1 (roots_map self) e
  
  function payloads_map [#"union_find.rs" 154 8 154 59] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'23] (self.t_UnionFind__0).t_HFInner__payloads
  
  predicate unchanged [#"union_find.rs" 171 8 171 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'19] domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  let rec find (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return' (x: t_Element)) =
    {[@expl:find 'uf' type invariant] [%#sunion_find'4] inv'8 uf}
    {[@expl:find requires] [%#sunion_find'5] in_domain uf.current elem}
    any
    [ return''0 (result: t_Element) -> {[%#sunion_find'6] result = root uf.current elem}
      {[%#sunion_find'7] unchanged uf}
      (! return' {result}) ]
  
  predicate domain_unchanged [#"union_find.rs" 182 8 182 50] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'16] domain self.current = domain self.final
  
  predicate payloads_unchanged [#"union_find.rs" 189 8 189 52] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'17] payloads_map self.current = payloads_map self.final
  
  function fin (self: MutBorrow.t t_UnionFind) : t_UnionFind = [%#sghost'5] self.final
  
  let rec link (uf: MutBorrow.t t_UnionFind) (x: t_Element) (y: t_Element) (return' (x'0: t_Element)) =
    {[@expl:link 'uf' type invariant] [%#sunion_find'8] inv'8 uf}
    {[@expl:link requires #0] [%#sunion_find'9] in_domain uf.current x /\ in_domain uf.current y}
    {[@expl:link requires #1] [%#sunion_find'10] root uf.current x = x /\ root uf.current y = y}
    any
    [ return''0 (result: t_Element) -> {[%#sunion_find'11] domain_unchanged uf /\ payloads_unchanged uf}
      {[%#sunion_find'12] result = root uf.current x \/ result = root uf.current y}
      {[%#sunion_find'13] result = root (fin uf) result}
      {[%#sunion_find'14] forall z: t_Element. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec union [#"union_find.rs" 353 4 353 97] (uf: MutBorrow.t t_UnionFind) (x: t_Element) (y: t_Element)
    (return' (x'0: t_Element)) = {[@expl:union 'uf' type invariant] [%#sunion_find] inv'8 uf}
    {[@expl:union requires] [%#sunion_find'0] in_domain uf.current x /\ in_domain uf.current y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_14 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_13 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'6 (_13.current).current}
        MutBorrow.borrow_mut <t_UnionFind> {(_13.current).current}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_12 <- _ret ] -{inv'6 _ret.final}-
            [ &_13 <- { _13 with current = { _13.current with current = _ret.final } } ] s1)
      | s1 = {inv'6 _12.current}
        MutBorrow.borrow_final <t_UnionFind> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_11 <- _ret ] -{inv'6 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'10 _13} s3
      | s3 = -{resolve'0 _13}- s4
      | s4 = {[@expl:type invariant] inv'7 _12} s5
      | s5 = -{resolve'2 _12}- s6
      | s6 = {inv'6 _11.current}
        MutBorrow.borrow_final <t_UnionFind> {_11.current} {MutBorrow.get_id _11}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_10 <- _ret ] -{inv'6 _ret.final}-
            [ &_11 <- { _11 with current = _ret.final } ] s7)
      | s7 = new {_10} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_9 <- _ret ] s8)
      | s8 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'7 _11} s1
      | s1 = -{resolve'2 _11}- s2
      | s2 = find {_9} {x'0} (fun (_ret: t_Element) -> [ &rx <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) ->
            [ &_22 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_22} (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind)) -> [ &_21 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv'6 (_21.current).current}
        MutBorrow.borrow_mut <t_UnionFind> {(_21.current).current}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_20 <- _ret ] -{inv'6 _ret.final}-
            [ &_21 <- { _21 with current = { _21.current with current = _ret.final } } ] s1)
      | s1 = {inv'6 _20.current}
        MutBorrow.borrow_final <t_UnionFind> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_19 <- _ret ] -{inv'6 _ret.final}-
            [ &_20 <- { _20 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'10 _21} s3
      | s3 = -{resolve'0 _21}- s4
      | s4 = {[@expl:type invariant] inv'7 _20} s5
      | s5 = -{resolve'2 _20}- s6
      | s6 = {inv'6 _19.current}
        MutBorrow.borrow_final <t_UnionFind> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_UnionFind) ->
            [ &_18 <- _ret ] -{inv'6 _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s7)
      | s7 = new {_18} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_17 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'7 _19} s1
      | s1 = -{resolve'2 _19}- s2
      | s2 = find {_17} {y'0} (fun (_ret: t_Element) -> [ &ry <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = link {uf'0} {rx} {ry} (fun (_ret: t_Element) -> [ &_0 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = return''0 {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf'0: MutBorrow.t t_UnionFind = uf
    | & x'0: t_Element = x
    | & y'0: t_Element = y
    | & rx: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _10: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _11: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _12: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _13: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _14: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & ry: t_Element = Any.any_l ()
    | & _17: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _18: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _19: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _20: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l ()
    | & _22: MutBorrow.t (MutBorrow.t t_UnionFind) = Any.any_l () ])
    [ return''0 (result: t_Element) -> {[@expl:union ensures #0] [%#sunion_find'1] domain_unchanged uf
      /\ payloads_unchanged uf}
      {[@expl:union ensures #1] [%#sunion_find'2] result = root uf.current x \/ result = root uf.current y}
      {[@expl:union ensures #2] [%#sunion_find'3] forall z: t_Element. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return' {result}) ]
end
module M_union_find__example [#"union_find.rs" 363 0 363 16]
  let%span sunion_find = "union_find.rs" 366 34 366 35
  let%span sunion_find'0 = "union_find.rs" 367 34 367 35
  let%span sunion_find'1 = "union_find.rs" 368 34 368 35
  let%span sunion_find'2 = "union_find.rs" 370 36 370 37
  let%span sunion_find'3 = "union_find.rs" 371 36 371 37
  let%span sunion_find'4 = "union_find.rs" 372 36 372 37
  let%span sunion_find'5 = "union_find.rs" 381 36 381 37
  let%span sunion_find'6 = "union_find.rs" 381 12 381 37
  let%span sunion_find'7 = "union_find.rs" 380 12 380 58
  let%span sunion_find'8 = "union_find.rs" 375 12 375 40
  let%span sunion_find'9 = "union_find.rs" 372 12 372 37
  let%span sunion_find'10 = "union_find.rs" 371 12 371 37
  let%span sunion_find'11 = "union_find.rs" 370 12 370 37
  let%span sunion_find'12 = "union_find.rs" 195 23 195 42
  let%span sunion_find'13 = "union_find.rs" 194 4 194 42
  let%span sunion_find'14 = "union_find.rs" 214 23 214 25
  let%span sunion_find'15 = "union_find.rs" 210 4 210 37
  let%span sunion_find'16 = "union_find.rs" 211 14 211 58
  let%span sunion_find'17 = "union_find.rs" 212 14 212 69
  let%span sunion_find'18 = "union_find.rs" 213 14 213 76
  let%span sunion_find'19 = "union_find.rs" 271 18 271 20
  let%span sunion_find'20 = "union_find.rs" 268 4 268 35
  let%span sunion_find'21 = "union_find.rs" 269 15 269 36
  let%span sunion_find'22 = "union_find.rs" 270 14 270 41
  let%span sunion_find'23 = "union_find.rs" 353 24 353 26
  let%span sunion_find'24 = "union_find.rs" 345 4 345 51
  let%span sunion_find'25 = "union_find.rs" 346 4 346 64
  let%span sunion_find'26 = "union_find.rs" 347 14 347 58
  let%span sunion_find'27 = "union_find.rs" 348 14 351 31
  let%span sunion_find'28 = "union_find.rs" 284 24 284 26
  let%span sunion_find'29 = "union_find.rs" 280 4 280 33
  let%span sunion_find'30 = "union_find.rs" 281 4 281 33
  let%span sunion_find'31 = "union_find.rs" 282 14 282 52
  let%span sunion_find'32 = "union_find.rs" 283 4 283 30
  let%span sunion_find'33 = "union_find.rs" 261 19 261 21
  let%span sunion_find'34 = "union_find.rs" 258 4 258 35
  let%span sunion_find'35 = "union_find.rs" 259 14 259 37
  let%span sunion_find'36 = "union_find.rs" 260 4 260 30
  let%span sunion_find'37 = "union_find.rs" 115 19 115 28
  let%span sunion_find'38 = "union_find.rs" 116 18 116 150
  let%span sunion_find'39 = "union_find.rs" 122 8 122 16
  let%span sunion_find'40 = "union_find.rs" 133 19 133 28
  let%span sunion_find'41 = "union_find.rs" 134 18 136 42
  let%span sunion_find'42 = "union_find.rs" 146 8 146 16
  let%span sunion_find'43 = "union_find.rs" 162 8 162 16
  let%span sunion_find'44 = "union_find.rs" 183 24 183 60
  let%span sunion_find'45 = "union_find.rs" 190 24 190 72
  let%span sunion_find'46 = "union_find.rs" 173 16 175 64
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 62 8 62 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 142 27 142 31
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 142 4 142 49
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 141 14 141 36
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 134 19 134 23
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 134 4 134 37
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 133 14 133 32
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use creusot.int.Int32
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element Int32.t;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt Int32.t | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'2] Map.get (view self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap'0] get self k <> C_None
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'0 x]. inv'0 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val'} -> true
        end)
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'3] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'1] lookup self key
  
  predicate invariant''1 (self: t_FMap) =
    [%#sfmap] forall k: UInt64.t. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  predicate inv'1 (_0: t_FMap)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant''1 x
  
  predicate inv'2 (_0: t_HFInner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_HFInner [inv'2 x]. inv'2 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'1 map
        end
  
  predicate inv'3 (_0: t_UnionFind)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind [inv'3 x]. inv'3 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'2 a_0
        end)
  
  predicate invariant''2 (self: t_UnionFind) = [%#sghost'6] inv'3 self
  
  predicate inv'4 (_0: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset'0] Fset.mem e self
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'37] inv'3 self)
      -> ([%#sunion_find'38] forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
          /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  let rec new (return' (x: t_UnionFind)) = any
    [ return''0 (result: t_UnionFind) -> {[%#sunion_find'12] inv'4 result}
      {[%#sunion_find'13] Fset.is_empty (domain result)}
      (! return' {result}) ]
  
  predicate invariant''3 (self: MutBorrow.t t_UnionFind) = [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self: MutBorrow.t t_UnionFind) = [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) = [%#sghost'6] inv'6 self
  
  predicate inv'7 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'7 x]. inv'7 x = invariant''5 x
  
  let rec borrow_mut (self: MutBorrow.t t_UnionFind) (return' (x: MutBorrow.t t_UnionFind)) =
    {[@expl:borrow_mut 'self' type invariant] [%#sghost] inv'5 self}
    any
    [ return''0 (result: MutBorrow.t t_UnionFind) -> {[%#sghost'0] inv'7 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'39] contains'0 (domain self) e
  
  function fin (self: MutBorrow.t t_UnionFind) : t_UnionFind = [%#sghost'5] self.final
  
  function insert [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) : Fset.fset t_Element =
    [%#sfset] Fset.add e self
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element = [%#smapping] Map.get self a
  
  function roots_map [#"union_find.rs" 138 8 138 65] (self: t_UnionFind) : Map.map t_Element t_Element
  
  axiom roots_map_spec: forall self: t_UnionFind. ([%#sunion_find'40] inv'3 self)
      -> ([%#sunion_find'41] forall e: t_Element. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function payloads_map [#"union_find.rs" 154 8 154 59] (self: t_UnionFind) : Map.map t_Element Int32.t
  
  let rec make (uf: MutBorrow.t t_UnionFind) (payload: Int32.t) (return' (x: t_Element)) =
    {[@expl:make 'uf' type invariant] [%#sunion_find'14] inv'7 uf}
    any
    [ return''0 (result: t_Element) -> {[%#sunion_find'15] not in_domain uf.current result}
      {[%#sunion_find'16] domain (fin uf) = insert (domain uf.current) result}
      {[%#sunion_find'17] roots_map (fin uf) = Map.set (roots_map uf.current) result result}
      {[%#sunion_find'18] payloads_map (fin uf) = Map.set (payloads_map uf.current) result payload}
      (! return' {result}) ]
  
  predicate invariant''6 (self: t_UnionFind) = [%#sinvariant'0] inv'4 self
  
  predicate inv'8 (_0: t_UnionFind)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_UnionFind [inv'8 x]. inv'8 x = invariant''6 x
  
  predicate invariant''7 (self: t_UnionFind) = [%#sinvariant'0] inv'3 self
  
  predicate inv'9 (_0: t_UnionFind)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_UnionFind [inv'9 x]. inv'9 x = invariant''7 x
  
  predicate invariant''8 (self: t_UnionFind) = [%#sghost'6] inv'9 self
  
  predicate inv'10 (_0: t_UnionFind)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_UnionFind [inv'10 x]. inv'10 x = invariant''8 x
  
  let rec borrow (self: t_UnionFind) (return' (x: t_UnionFind)) =
    {[@expl:borrow 'self' type invariant] [%#sghost'2] inv'8 self}
    any
    [ return''0 (result: t_UnionFind) -> {[%#sghost'3] inv'10 result}
      {[%#sghost'4] result = self}
      (! return' {result}) ]
  
  function root [#"union_find.rs" 148 8 148 54] (self: t_UnionFind) (e: t_Element) : t_Element =
    [%#sunion_find'42] index_logic'1 (roots_map self) e
  
  function index_logic'2 (self: Map.map t_Element Int32.t) (a: t_Element) : Int32.t = [%#smapping] Map.get self a
  
  function payload [#"union_find.rs" 164 8 164 48] (self: t_UnionFind) (e: t_Element) : Int32.t =
    [%#sunion_find'43] index_logic'2 (payloads_map self) e
  
  let rec get'0 (uf: t_UnionFind) (elem: t_Element) (return' (x: Int32.t)) =
    {[@expl:get 'uf' type invariant] [%#sunion_find'19] inv'10 uf}
    {[@expl:get requires #0] [%#sunion_find'20] in_domain uf elem}
    {[@expl:get requires #1] [%#sunion_find'21] root uf elem = elem}
    any [ return''0 (result: Int32.t) -> {[%#sunion_find'22] result = payload uf elem} (! return' {result}) ]
  
  predicate domain_unchanged [#"union_find.rs" 182 8 182 50] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'44] domain self.current = domain self.final
  
  predicate payloads_unchanged [#"union_find.rs" 189 8 189 52] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'45] payloads_map self.current = payloads_map self.final
  
  let rec union (uf: MutBorrow.t t_UnionFind) (x: t_Element) (y: t_Element) (return' (x'0: t_Element)) =
    {[@expl:union 'uf' type invariant] [%#sunion_find'23] inv'7 uf}
    {[@expl:union requires] [%#sunion_find'24] in_domain uf.current x /\ in_domain uf.current y}
    any
    [ return''0 (result: t_Element) -> {[%#sunion_find'25] domain_unchanged uf /\ payloads_unchanged uf}
      {[%#sunion_find'26] result = root uf.current x \/ result = root uf.current y}
      {[%#sunion_find'27] forall z: t_Element. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return' {result}) ]
  
  predicate unchanged [#"union_find.rs" 171 8 171 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'46] domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  let rec equiv (uf: MutBorrow.t t_UnionFind) (e1: t_Element) (e2: t_Element) (return' (x: bool)) =
    {[@expl:equiv 'uf' type invariant] [%#sunion_find'28] inv'7 uf}
    {[@expl:equiv requires #0] [%#sunion_find'29] in_domain uf.current e1}
    {[@expl:equiv requires #1] [%#sunion_find'30] in_domain uf.current e2}
    any
    [ return''0 (result: bool) -> {[%#sunion_find'31] result = (root uf.current e1 = root uf.current e2)}
      {[%#sunion_find'32] unchanged uf}
      (! return' {result}) ]
  
  let rec find (uf: MutBorrow.t t_UnionFind) (elem: t_Element) (return' (x: t_Element)) =
    {[@expl:find 'uf' type invariant] [%#sunion_find'33] inv'7 uf}
    {[@expl:find requires] [%#sunion_find'34] in_domain uf.current elem}
    any
    [ return''0 (result: t_Element) -> {[%#sunion_find'35] result = root uf.current elem}
      {[%#sunion_find'36] unchanged uf}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example [#"union_find.rs" 363 0 363 16] (return' (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new (fun (_ret: t_UnionFind) -> [ &uf <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_4 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_4} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_3 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = make {_3} {[%#sunion_find] (1: Int32.t)} (fun (_ret: t_Element) -> [ &x <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_7 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_7} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_6 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = make {_6} {[%#sunion_find'0] (2: Int32.t)} (fun (_ret: t_Element) -> [ &y <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_10 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_10} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_9 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = make {_9} {[%#sunion_find'1] (3: Int32.t)} (fun (_ret: t_Element) -> [ &z <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_15 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = get'0 {_15} {x} (fun (_ret: Int32.t) -> [ &_14 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_12 <- _14 = ([%#sunion_find'2] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_12 = false} (! bb10) | br1 -> {_12} (! bb12) ] ]
    | bb12 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_23 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = get'0 {_23} {y} (fun (_ret: Int32.t) -> [ &_22 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0
      [ s0 = [ &_20 <- _22 = ([%#sunion_find'3] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_20 = false} (! bb15) | br1 -> {_20} (! bb17) ] ]
    | bb17 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_31 <- _ret ] s1) | s1 = bb18 ]
    | bb18 = s0 [ s0 = get'0 {_31} {z} (fun (_ret: Int32.t) -> [ &_30 <- _ret ] s1) | s1 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_28 <- _30 = ([%#sunion_find'4] (3: Int32.t)) ] s1
      | s1 = any [ br0 -> {_28 = false} (! bb20) | br1 -> {_28} (! bb22) ] ]
    | bb22 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_37 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_37} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_36 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0 [ s0 = union {_36} {x} {y} (fun (_ret: t_Element) -> [ &_35 <- _ret ] s1) | s1 = bb24 ]
    | bb24 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_43 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_43} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_42 <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0 [ s0 = equiv {_42} {x} {y} (fun (_ret: bool) -> [ &_41 <- _ret ] s1) | s1 = bb26 ]
    | bb26 = any [ br0 -> {_41 = false} (! bb27) | br1 -> {_41} (! bb29) ]
    | bb29 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_49 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_49} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_48 <- _ret ] s2)
      | s2 = bb30 ]
    | bb30 = s0 [ s0 = find {_48} {x} (fun (_ret: t_Element) -> [ &xr <- _ret ] s1) | s1 = bb31 ]
    | bb31 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_53 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_53} (fun (_ret: MutBorrow.t t_UnionFind) -> [ &_52 <- _ret ] s2)
      | s2 = bb32 ]
    | bb32 = s0 [ s0 = find {_52} {y} (fun (_ret: t_Element) -> [ &yr <- _ret ] s1) | s1 = bb33 ]
    | bb33 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_59 <- _ret ] s1) | s1 = bb34 ]
    | bb34 = s0 [ s0 = get'0 {_59} {xr} (fun (_ret: Int32.t) -> [ &_58 <- _ret ] s1) | s1 = bb35 ]
    | bb35 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_64 <- _ret ] s1) | s1 = bb36 ]
    | bb36 = s0 [ s0 = get'0 {_64} {yr} (fun (_ret: Int32.t) -> [ &_63 <- _ret ] s1) | s1 = bb37 ]
    | bb37 = s0 [ s0 = [ &_56 <- _58 = _63 ] s1 | s1 = any [ br0 -> {_56 = false} (! bb38) | br1 -> {_56} (! bb40) ] ]
    | bb40 = s0 [ s0 = borrow {uf} (fun (_ret: t_UnionFind) -> [ &_72 <- _ret ] s1) | s1 = bb41 ]
    | bb41 = s0 [ s0 = get'0 {_72} {z} (fun (_ret: Int32.t) -> [ &_71 <- _ret ] s1) | s1 = bb42 ]
    | bb42 = s0
      [ s0 = [ &_69 <- _71 = ([%#sunion_find'5] (3: Int32.t)) ] s1
      | s1 = any [ br0 -> {_69 = false} (! bb43) | br1 -> {_69} (! bb45) ] ]
    | bb45 = return''0 {_0}
    | bb43 = {[%#sunion_find'6] false} any
    | bb38 = {[%#sunion_find'7] false} any
    | bb27 = {[%#sunion_find'8] false} any
    | bb20 = {[%#sunion_find'9] false} any
    | bb15 = {[%#sunion_find'10] false} any
    | bb10 = {[%#sunion_find'11] false} any ]
    [ & _0: () = Any.any_l ()
    | & uf: t_UnionFind = Any.any_l ()
    | & x: t_Element = Any.any_l ()
    | & _3: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _4: MutBorrow.t t_UnionFind = Any.any_l ()
    | & y: t_Element = Any.any_l ()
    | & _6: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _7: MutBorrow.t t_UnionFind = Any.any_l ()
    | & z: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _10: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _15: t_UnionFind = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _23: t_UnionFind = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: Int32.t = Any.any_l ()
    | & _31: t_UnionFind = Any.any_l ()
    | & _35: t_Element = Any.any_l ()
    | & _36: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _37: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _41: bool = Any.any_l ()
    | & _42: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _43: MutBorrow.t t_UnionFind = Any.any_l ()
    | & xr: t_Element = Any.any_l ()
    | & _48: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _49: MutBorrow.t t_UnionFind = Any.any_l ()
    | & yr: t_Element = Any.any_l ()
    | & _52: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _53: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: Int32.t = Any.any_l ()
    | & _59: t_UnionFind = Any.any_l ()
    | & _63: Int32.t = Any.any_l ()
    | & _64: t_UnionFind = Any.any_l ()
    | & _69: bool = Any.any_l ()
    | & _71: Int32.t = Any.any_l ()
    | & _72: t_UnionFind = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_union_find__example_addrs_eq [#"union_find.rs" 385 0 385 77]
  let%span sunion_find = "union_find.rs" 389 22 389 30
  let%span sunion_find'0 = "union_find.rs" 385 27 385 29
  let%span sunion_find'1 = "union_find.rs" 384 0 384 49
  let%span sunion_find'2 = "union_find.rs" 17 18 17 69
  let%span sunion_find'3 = "union_find.rs" 122 8 122 16
  let%span sunion_find'4 = "union_find.rs" 115 19 115 28
  let%span sunion_find'5 = "union_find.rs" 116 18 116 150
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 261 4 261 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 44 4 44 12
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  use set.Fset
  use map.Map
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t
  
  function deep_model'0 (self: t_Element) : UInt64.t = [%#smodel] deep_model self
  
  let rec eq (self: t_Element) (other: t_Element) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#sunion_find'2] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  type t_FMap
  
  type t_T
  
  type t_HFInner = {
    t_HFInner__domain: Fset.fset t_Element;
    t_HFInner__map: t_FMap;
    t_HFInner__payloads: Map.map t_Element t_T;
    t_HFInner__distance: Map.map t_Element int;
    t_HFInner__roots: Map.map t_Element t_Element;
    t_HFInner__max_depth: int }
  
  type t_UnionFind = { t_UnionFind__0: t_HFInner }
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 79 8 79 34] (self: t_UnionFind)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Content = C_Root t_PeanoInt t_T | C_Link t_Element
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option = [%#sfmap'2] Map.get (view self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) = [%#sfmap'0] get self k <> C_None
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant''0 (self: t_PtrOwn) = [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Content) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val'} -> inv'2 val'
        end)
  
  predicate index_logic (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#sutil] exists x: t_PtrOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn = [%#sfmap'3] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn = [%#sfmap'1] lookup self key
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap] forall k: UInt64.t. contains self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_HFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_HFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_HFInner__domain = domain; t_HFInner__map = map; t_HFInner__payloads = payloads; t_HFInner__distance = distance; t_HFInner__roots = roots; t_HFInner__max_depth = max_depth} -> inv'4 map
        end
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UnionFind__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 (self: t_UnionFind) = [%#sinvariant] inv'6 self
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = [%#sfset] Fset.mem e self
  
  function domain [#"union_find.rs" 117 8 117 47] (self: t_UnionFind) : Fset.fset t_Element
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'4] inv'6 self)
      -> ([%#sunion_find'5] forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
          /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2 -> e1 = e2)
  
  predicate in_domain [#"union_find.rs" 124 8 124 53] (self: t_UnionFind) (e: t_Element) =
    [%#sunion_find'3] contains'0 (domain self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example_addrs_eq [#"union_find.rs" 385 0 385 77] (uf: t_UnionFind) (e1: t_Element) (e2: t_Element)
    (return' (x: ())) = {[@expl:example_addrs_eq 'uf' type invariant] [%#sunion_find'0] inv'7 uf}
    {[@expl:example_addrs_eq requires] [%#sunion_find'1] in_domain uf e1 /\ in_domain uf e2}
    (! bb0
    [ bb0 = s0 [ s0 = eq {e1'0} {e2'0} (fun (_ret: bool) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb2) ]
    | bb2 = s0 [ s0 = {[@expl:assertion] [%#sunion_find] e1'0 = e2'0} s1 | s1 = bb4 ]
    | bb4 = return''0 {_0} ]
    [ & _0: () = Any.any_l () | & e1'0: t_Element = e1 | & e2'0: t_Element = e2 | & _5: bool = Any.any_l () ])
    [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_union_find__implementation__qyi17232405883558456141__eq__refines [#"union_find.rs" 18 8 18 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find = "union_find.rs" 18 8 18 42
  let%span sunion_find'0 = "union_find.rs" 24 8 24 16
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  type t_Element = { t_Element__0: Opaque.ptr }
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'0] addr_logic self.t_Element__0
  
  function deep_model'0 (self: t_Element) : UInt64.t = [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sunion_find] forall self_: t_Element. forall rhs: t_Element. forall result: bool. result
            = (deep_model'0 self_ = deep_model'0 rhs) -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
