module M_unsized_quant__l [#"unsized_quant.rs" 16 0 16 10]
  let%span sunsized_quant = "unsized_quant.rs" 15 10 15 13
  let%span sunsized_quant'0 = "unsized_quant.rs" 16 11 16 13
  let%span sunsized_quant'1 = "unsized_quant.rs" 7 8 7 38
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  
  use creusot.slice.Slice64
  use creusot.int.Int32
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  function index_logic (self: Map.map (Slice64.slice Int32.t) int) (a: Slice64.slice Int32.t) : int =
    [%#smapping] Map.get self a
  
  predicate f [#"unsized_quant.rs" 5 0 5 18] =
    [%#sunsized_quant'1] let len = fun (x: Slice64.slice Int32.t) -> Seq.length (Slice64.view x) in forall x: Slice64.slice Int32.t, y: Slice64.slice Int32.t. index_logic len x
        + index_logic len y
      >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function l [#"unsized_quant.rs" 16 0 16 10] : ()
  
  goal vc_l: [@expl:l ensures] [%#sunsized_quant] f
end
