module M_logic_vcgen__bor_1_2 [#"logic_vcgen.rs" 9 0 9 30]
  let%span slogic_vcgen = "logic_vcgen.rs" 7 11 7 35
  let%span slogic_vcgen'0 = "logic_vcgen.rs" 8 10 8 22
  let%span slogic_vcgen'1 = "logic_vcgen.rs" 10 16 10 29
  
  use creusot.prelude.MutBorrow
  use creusot.int.Int32
  use mach.int.Int
  
  constant x  : MutBorrow.t Int32.t
  
  function bor_1_2 [#"logic_vcgen.rs" 9 0 9 30] (x'0 : MutBorrow.t Int32.t) : int
  
  goal vc_bor_1_2 : ([%#slogic_vcgen] Int32.to_int x.current = 1 /\ Int32.to_int x.final = 2)
   -> ([%#slogic_vcgen'0] Int32.to_int x.current - Int32.to_int x.final = - 1)
end
module M_logic_vcgen__f [#"logic_vcgen.rs" 18 0 18 41]
  let%span slogic_vcgen = "logic_vcgen.rs" 15 11 15 26
  let%span slogic_vcgen'0 = "logic_vcgen.rs" 16 11 16 26
  let%span slogic_vcgen'1 = "logic_vcgen.rs" 17 10 17 16
  let%span slogic_vcgen'2 = "logic_vcgen.rs" 7 11 7 35
  let%span slogic_vcgen'3 = "logic_vcgen.rs" 8 10 8 22
  let%span slogic_vcgen'4 = "logic_vcgen.rs" 19 4 19 33
  let%span slogic_vcgen'5 = "logic_vcgen.rs" 10 16 10 29
  let%span sindex = "../../../creusot-contracts/src/logic/ops/index.rs" 74 8 74 31
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use creusot.int.Int32
  use seq.Seq
  use mach.int.Int
  
  type tuple  =
    { _p0: Int32.t; _p1: Int32.t }
  
  function index_logic [@inline:trivial] (self : Slice64.array tuple) (ix : int) : tuple =
    [%#sindex] Seq.get (Slice64.id self) ix
  
  function bor_1_2 [#"logic_vcgen.rs" 9 0 9 30] (x : MutBorrow.t Int32.t) : int =
    [%#slogic_vcgen'5] Int32.to_int x.current - Int32.to_int x.final
  
  axiom bor_1_2_spec : forall x : MutBorrow.t Int32.t . ([%#slogic_vcgen'2] Int32.to_int x.current = 1
  /\ Int32.to_int x.final = 2)  -> ([%#slogic_vcgen'3] bor_1_2 x = - 1)
  
  constant x  : MutBorrow.t (Slice64.array tuple)
  
  function f [#"logic_vcgen.rs" 18 0 18 41] (x'0 : MutBorrow.t (Slice64.array tuple)) : bool
  
  goal vc_f : ([%#slogic_vcgen] Int32.to_int (index_logic x.current 2)._p0 = 1)
   -> ([%#slogic_vcgen'0] Int32.to_int (index_logic x.final 2)._p0 = 2)
   -> ([@expl:bor_1_2 requires] [%#slogic_vcgen'2] Int32.to_int (MutBorrow.borrow_logic (index_logic x.current 2)._p0 (index_logic x.final 2)._p0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1)).current
  = 1
  /\ Int32.to_int (MutBorrow.borrow_logic (index_logic x.current 2)._p0 (index_logic x.final 2)._p0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1)).final
  = 2)
  /\ (([%#slogic_vcgen'3] bor_1_2 (MutBorrow.borrow_logic (index_logic x.current 2)._p0 (index_logic x.final 2)._p0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1))
  = - 1)
   -> ([%#slogic_vcgen'1] bor_1_2 (MutBorrow.borrow_logic (index_logic x.current 2)._p0 (index_logic x.final 2)._p0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1))
  = - 1))
end
module M_logic_vcgen__bool_of_int [#"logic_vcgen.rs" 25 0 25 34]
  let%span slogic_vcgen = "logic_vcgen.rs" 24 11 24 26
  let%span slogic_vcgen'0 = "logic_vcgen.rs" 26 4 26 37
  
  use mach.int.Int
  
  constant x  : int
  
  function bool_of_int [#"logic_vcgen.rs" 25 0 25 34] (x'0 : int) : bool
  
  goal vc_bool_of_int : true
end
module M_logic_vcgen__g [#"logic_vcgen.rs" 33 0 33 24]
  let%span slogic_vcgen = "logic_vcgen.rs" 31 11 31 26
  let%span slogic_vcgen'0 = "logic_vcgen.rs" 32 10 32 16
  let%span slogic_vcgen'1 = "logic_vcgen.rs" 24 11 24 26
  let%span slogic_vcgen'2 = "logic_vcgen.rs" 34 14 34 73
  let%span slogic_vcgen'3 = "logic_vcgen.rs" 34 4 34 74
  let%span slogic_vcgen'4 = "logic_vcgen.rs" 26 4 26 37
  
  use mach.int.Int
  use map.Map
  
  function bool_of_int [#"logic_vcgen.rs" 25 0 25 34] (x : int) : bool =
    [%#slogic_vcgen'4] if x = 0 then true else false
  
  constant x  : int
  
  function g [#"logic_vcgen.rs" 33 0 33 24] (x'0 : int) : bool
  
  goal vc_g : ([%#slogic_vcgen] 0 <= x /\ x < 2)
   -> (forall x'0 : int . if 0 <= x'0 then
    if x'0 < 2 then [@expl:bool_of_int requires] [%#slogic_vcgen'1] 0 <= 1 - x'0 /\ 1 - x'0 < 2 else true
  else
    true
  )
  /\ (let map = [%#slogic_vcgen'2] fun (x'0 : int) -> if 0 <= x'0 /\ x'0 < 2 then
    bool_of_int (1 - x'0)
  else
    true
   in if Map.get map x then [%#slogic_vcgen'0] true else [%#slogic_vcgen'0] Map.get map (1 - x))
end
