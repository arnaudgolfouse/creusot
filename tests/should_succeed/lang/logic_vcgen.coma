module M_bor_1_2
  use creusot.prelude.MutBorrow
  use creusot.int.Int32
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : MutBorrow.t Int32.t
  
  function bor_1_2 (x: MutBorrow.t Int32.t) : int
  
  goal vc_bor_1_2: Int32.to_int x.current = 1 /\ Int32.to_int x.final = 2
    -> ([@expl:bor_1_2 ensures] Int32.to_int x.current - Int32.to_int x.final = - 1)
end
module M_f
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use creusot.int.Int32
  use seq.Seq
  use mach.int.Int
  
  type tup2_i32_i32 = { f0: Int32.t; f1: Int32.t }
  
  function index_array_tup2_i32_i32_5 [@inline:trivial] (self: Slice64.array tup2_i32_i32) (ix: int) : tup2_i32_i32 =
    Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_array_tup2_i32_i32_5
  
  function bor_1_2 (x: MutBorrow.t Int32.t) : int = Int32.to_int x.current - Int32.to_int x.final
  
  axiom bor_1_2_spec: forall x: MutBorrow.t Int32.t. Int32.to_int x.current = 1 /\ Int32.to_int x.final = 2
      -> bor_1_2 x = - 1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : MutBorrow.t (Slice64.array tup2_i32_i32)
  
  predicate f (x: MutBorrow.t (Slice64.array tup2_i32_i32))
  
  goal vc_f: Int32.to_int (index_array_tup2_i32_i32_5 x.current 2).f0 = 1
    -> Int32.to_int (index_array_tup2_i32_i32_5 x.final 2).f0 = 2
    -> ([@expl:bor_1_2 requires] Int32.to_int (MutBorrow.borrow_logic (index_array_tup2_i32_i32_5 x.current 2).f0 (index_array_tup2_i32_i32_5 x.final 2).f0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1)).current
        = 1
      /\ Int32.to_int (MutBorrow.borrow_logic (index_array_tup2_i32_i32_5 x.current 2).f0 (index_array_tup2_i32_i32_5 x.final 2).f0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1)).final
      = 2)
    /\ (bor_1_2 (MutBorrow.borrow_logic (index_array_tup2_i32_i32_5 x.current 2).f0 (index_array_tup2_i32_i32_5 x.final 2).f0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1))
      = - 1
    -> ([@expl:f ensures] bor_1_2 (MutBorrow.borrow_logic (index_array_tup2_i32_i32_5 x.current 2).f0 (index_array_tup2_i32_i32_5 x.final 2).f0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1))
    = - 1))
end
module M_bool_of_int
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  predicate bool_of_int (x: int)
  
  goal vc_bool_of_int: true
end
module M_g
  use mach.int.Int
  use map.Map
  
  predicate bool_of_int (x: int) = if x = 0 then true else false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  predicate g (x: int)
  
  goal vc_g: 0 <= x /\ x < 2
    -> (forall x'0: int. if 0 <= x'0 then
          if x'0 < 2 then [@expl:bool_of_int requires] 0 <= 1 - x'0 /\ 1 - x'0 < 2 else true
        else
          true
      )
    /\ (let map = fun (x'0: int) -> if 0 <= x'0 /\ x'0 < 2 then bool_of_int (1 - x'0) else true in if Map.get map x then
      [@expl:g ensures] true
    else
      [@expl:g ensures] Map.get map (1 - x)
    )
end
