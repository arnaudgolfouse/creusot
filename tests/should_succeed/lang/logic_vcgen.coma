module M_logic_vcgen__bor_1_2
  use creusot.prelude.MutBorrow
  use creusot.int.Int32
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : MutBorrow.t Int32.t
  
  function bor_1_2 (x'0: MutBorrow.t Int32.t) : int
  
  goal vc_bor_1_2: Int32.to_int x.current = 1 /\ Int32.to_int x.final = 2
    -> ([@expl:bor_1_2 ensures] Int32.to_int x.current - Int32.to_int x.final = - 1)
end
module M_logic_vcgen__f
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use creusot.int.Int32
  use seq.Seq
  use mach.int.Int
  
  type tuple = { _p0: Int32.t; _p1: Int32.t }
  
  function index_logic [@inline:trivial] (self: Slice64.array tuple) (ix: int) : tuple = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function bor_1_2 (x: MutBorrow.t Int32.t) : int = Int32.to_int x.current - Int32.to_int x.final
  
  axiom bor_1_2_spec: forall x: MutBorrow.t Int32.t. Int32.to_int x.current = 1 /\ Int32.to_int x.final = 2
      -> bor_1_2 x = - 1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : MutBorrow.t (Slice64.array tuple)
  
  predicate f (x'0: MutBorrow.t (Slice64.array tuple))
  
  goal vc_f: Int32.to_int (index_logic x.current 2)._p0 = 1
    -> Int32.to_int (index_logic x.final 2)._p0 = 2
    -> ([@expl:bor_1_2 requires] Int32.to_int (MutBorrow.borrow_logic (index_logic x.current 2)._p0 (index_logic x.final 2)._p0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1)).current
        = 1
      /\ Int32.to_int (MutBorrow.borrow_logic (index_logic x.current 2)._p0 (index_logic x.final 2)._p0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1)).final
      = 2)
    /\ (bor_1_2 (MutBorrow.borrow_logic (index_logic x.current 2)._p0 (index_logic x.final 2)._p0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1))
      = - 1
    -> ([@expl:f ensures] bor_1_2 (MutBorrow.borrow_logic (index_logic x.current 2)._p0 (index_logic x.final 2)._p0 (MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id x) 2) 1))
    = - 1))
end
module M_logic_vcgen__bool_of_int
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  predicate bool_of_int (x'0: int)
  
  goal vc_bool_of_int: true
end
module M_logic_vcgen__g
  use mach.int.Int
  use map.Map
  
  predicate bool_of_int (x: int) = if x = 0 then true else false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  predicate g (x'0: int)
  
  goal vc_g: 0 <= x /\ x < 2
    -> (forall x'0: int. if 0 <= x'0 then
          if x'0 < 2 then [@expl:bool_of_int requires] 0 <= 1 - x'0 /\ 1 - x'0 < 2 else true
        else
          true
      )
    /\ (let map = fun (x'0: int) -> if 0 <= x'0 /\ x'0 < 2 then bool_of_int (1 - x'0) else true in if Map.get map x then
      [@expl:g ensures] true
    else
      [@expl:g ensures] Map.get map (1 - x)
    )
end
