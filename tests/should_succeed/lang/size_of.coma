module M_size_of__f [#"size_of.rs" 7 0 7 10]
  let%span ssize_of = "size_of.rs" 8 18 8 46
  let%span ssize_of'0 = "size_of.rs" 9 18 9 46
  let%span ssize_of'1 = "size_of.rs" 10 18 10 44
  let%span ssize_of'2 = "size_of.rs" 11 18 11 45
  let%span ssize_of'3 = "size_of.rs" 12 18 12 44
  let%span ssize_of'4 = "size_of.rs" 13 18 13 51
  let%span ssize_of'5 = "size_of.rs" 14 18 14 49
  let%span ssize_of'6 = "size_of.rs" 15 18 15 51
  let%span smem = "../../../creusot-contracts/src/std/mem.rs" 72 10 72 21
  let%span smem'0 = "../../../creusot-contracts/src/std/mem.rs" 83 10 83 66
  let%span smem'1 = "../../../creusot-contracts/src/std/mem.rs" 84 10 84 45
  
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  constant size_of_bool: int = 1
  
  axiom size_of_bool_spec: [%#smem] 0 <= size_of_bool
  
  constant size_of_char: int = 4
  
  axiom size_of_char_spec: [%#smem] 0 <= size_of_char
  
  constant size_of_u8: int = 1
  
  axiom size_of_u8_spec: [%#smem] 0 <= size_of_u8
  
  constant size_of_u64: int = 8
  
  axiom size_of_u64_spec: [%#smem] 0 <= size_of_u64
  
  constant size_of_unit: int = 0
  
  axiom size_of_unit_spec: [%#smem] 0 <= size_of_unit
  
  constant size_of_array_u32_5: int = 20
  
  axiom size_of_array_u32_5_spec: [%#smem] 0 <= size_of_array_u32_5
  
  constant size_of_array_unit_5: int = 0
  
  axiom size_of_array_unit_5_spec: [%#smem] 0 <= size_of_array_unit_5
  
  constant align_of_logic: UInt64.t = 8
  
  axiom align_of_logic_spec: [%#smem'0] (0: UInt64.t) <> align_of_logic
    /\ UInt64.bw_and align_of_logic (UInt64.sub align_of_logic (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_logic_spec'0: [%#smem'1] Int.mod size_of_u64 (UInt64.t'int align_of_logic) = 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f [#"size_of.rs" 7 0 7 10] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] [%#ssize_of] size_of_bool = 1} s1
      | s1 = {[@expl:assertion] [%#ssize_of'0] size_of_char = 4} s2
      | s2 = {[@expl:assertion] [%#ssize_of'1] size_of_u8 = 1} s3
      | s3 = {[@expl:assertion] [%#ssize_of'2] size_of_u64 = 8} s4
      | s4 = {[@expl:assertion] [%#ssize_of'3] size_of_unit = 0} s5
      | s5 = {[@expl:assertion] [%#ssize_of'4] size_of_array_u32_5 = 20} s6
      | s6 = {[@expl:assertion] [%#ssize_of'5] size_of_array_unit_5 = 0} s7
      | s7 = {[@expl:assertion] [%#ssize_of'6] align_of_logic = (8: UInt64.t)} s8
      | s8 = return''0 {_0} ] ] [ & _0: () = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_size_of__g [#"size_of.rs" 18 0 18 13]
  let%span ssize_of = "size_of.rs" 20 18 20 49
  let%span ssize_of'0 = "size_of.rs" 21 18 21 67
  let%span ssize_of'1 = "size_of.rs" 22 18 22 73
  let%span ssize_of'2 = "size_of.rs" 23 18 23 71
  let%span ssize_of'3 = "size_of.rs" 24 18 24 75
  let%span ssize_of'4 = "size_of.rs" 25 18 25 79
  let%span ssize_of'5 = "size_of.rs" 26 18 26 71
  let%span ssize_of'6 = "size_of.rs" 27 18 27 48
  let%span smem = "../../../creusot-contracts/src/std/mem.rs" 36 22 36 53
  let%span smem'0 = "../../../creusot-contracts/src/std/mem.rs" 72 10 72 21
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant size_of_T : int
  
  axiom size_of_T_spec: [%#smem'0] 0 <= size_of_T
  
  constant size_of_array_T_2: int = size_of_T * 2
  
  axiom size_of_array_T_2_spec: [%#smem'0] 0 <= size_of_array_T_2
  
  let rec size_of (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#smem] UInt64.t'int result = size_of_array_T_2} (! return' {result}) ]
  
  constant size_of_ref_T: int = 8
  
  axiom size_of_ref_T_spec: [%#smem'0] 0 <= size_of_ref_T
  
  constant size_of_usize: int = 8
  
  axiom size_of_usize_spec: [%#smem'0] 0 <= size_of_usize
  
  constant size_of_ptr_T: int = 8
  
  axiom size_of_ptr_T_spec: [%#smem'0] 0 <= size_of_ptr_T
  
  constant size_of_Box_T_Global: int = 8
  
  axiom size_of_Box_T_Global_spec: [%#smem'0] 0 <= size_of_Box_T_Global
  
  constant size_of_Option_ref_T: int = 8
  
  axiom size_of_Option_ref_T_spec: [%#smem'0] 0 <= size_of_Option_ref_T
  
  constant size_of_Option_Box_T_Global: int = 8
  
  axiom size_of_Option_Box_T_Global_spec: [%#smem'0] 0 <= size_of_Option_Box_T_Global
  
  constant size_of_array_T_5: int = size_of_T * 5
  
  axiom size_of_array_T_5_spec: [%#smem'0] 0 <= size_of_array_T_5
  
  constant size_of_array_T_0: int = size_of_T * 0
  
  axiom size_of_array_T_0_spec: [%#smem'0] 0 <= size_of_array_T_0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec g [#"size_of.rs" 18 0 18 13] (return' (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = size_of (fun (_ret: UInt64.t) -> [ &t2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#ssize_of] UInt64.t'int t2 = 2 * size_of_T} s1
      | s1 = {[@expl:assertion] [%#ssize_of'0] size_of_ref_T = size_of_usize} s2
      | s2 = {[@expl:assertion] [%#ssize_of'1] size_of_ptr_T = size_of_usize} s3
      | s3 = {[@expl:assertion] [%#ssize_of'2] size_of_Box_T_Global = size_of_usize} s4
      | s4 = {[@expl:assertion] [%#ssize_of'3] size_of_Option_ref_T = size_of_usize} s5
      | s5 = {[@expl:assertion] [%#ssize_of'4] size_of_Option_Box_T_Global = size_of_usize} s6
      | s6 = {[@expl:assertion] [%#ssize_of'5] size_of_array_T_5 = 5 * size_of_T} s7
      | s7 = {[@expl:assertion] [%#ssize_of'6] size_of_array_T_0 = 0} s8
      | s8 = return''0 {_0} ] ] [ & _0: () = Any.any_l () | & t2: UInt64.t = Any.any_l () ])
    [ return''0 (result: ()) -> (! return' {result}) ]
end
