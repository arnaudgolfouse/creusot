module M_f
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  constant size_of_bool: int = 1
  
  meta "rewrite_def" constant size_of_bool
  
  axiom size_of_bool_spec: 0 <= size_of_bool
  
  constant size_of_char: int = 4
  
  meta "rewrite_def" constant size_of_char
  
  axiom size_of_char_spec: 0 <= size_of_char
  
  constant size_of_u8: int = 1
  
  meta "rewrite_def" constant size_of_u8
  
  axiom size_of_u8_spec: 0 <= size_of_u8
  
  constant size_of_u64: int = 8
  
  meta "rewrite_def" constant size_of_u64
  
  axiom size_of_u64_spec: 0 <= size_of_u64
  
  constant size_of_unit: int = 0
  
  meta "rewrite_def" constant size_of_unit
  
  axiom size_of_unit_spec: 0 <= size_of_unit
  
  constant size_of_array_u32_5: int = 20
  
  meta "rewrite_def" constant size_of_array_u32_5
  
  axiom size_of_array_u32_5_spec: 0 <= size_of_array_u32_5
  
  constant size_of_array_unit_5: int = 0
  
  meta "rewrite_def" constant size_of_array_unit_5
  
  axiom size_of_array_unit_5_spec: 0 <= size_of_array_unit_5
  
  constant align_of_u64: UInt64.t = 8
  
  meta "rewrite_def" constant align_of_u64
  
  axiom align_of_u64_spec: (0: UInt64.t) <> align_of_u64
    /\ UInt64.bw_and align_of_u64 (UInt64.sub align_of_u64 (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_u64_spec'0: Int.mod size_of_u64 (UInt64.t'int align_of_u64) = 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] size_of_bool = 1} s1
      | s1 = {[@expl:assertion] size_of_char = 4} s2
      | s2 = {[@expl:assertion] size_of_u8 = 1} s3
      | s3 = {[@expl:assertion] size_of_u64 = 8} s4
      | s4 = {[@expl:assertion] size_of_unit = 0} s5
      | s5 = {[@expl:assertion] size_of_array_u32_5 = 20} s6
      | s6 = {[@expl:assertion] size_of_array_unit_5 = 0} s7
      | s7 = {[@expl:assertion] align_of_u64 = (8: UInt64.t)} s8
      | s8 = return {_0} ] ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_g
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant size_of_array_T_2: int = size_of_T * 2
  
  meta "rewrite_def" constant size_of_array_T_2
  
  axiom size_of_array_T_2_spec: 0 <= size_of_array_T_2
  
  let rec size_of_array_T_2'0 (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {UInt64.t'int result = size_of_array_T_2} (! return {result}) ]
  
  constant size_of_ref_T: int = 8
  
  meta "rewrite_def" constant size_of_ref_T
  
  axiom size_of_ref_T_spec: 0 <= size_of_ref_T
  
  constant size_of_usize: int = 8
  
  meta "rewrite_def" constant size_of_usize
  
  axiom size_of_usize_spec: 0 <= size_of_usize
  
  constant size_of_ptr_T: int = 8
  
  meta "rewrite_def" constant size_of_ptr_T
  
  axiom size_of_ptr_T_spec: 0 <= size_of_ptr_T
  
  constant size_of_Box_T_Global: int = 8
  
  meta "rewrite_def" constant size_of_Box_T_Global
  
  axiom size_of_Box_T_Global_spec: 0 <= size_of_Box_T_Global
  
  constant size_of_Option_ref_T: int = 8
  
  meta "rewrite_def" constant size_of_Option_ref_T
  
  axiom size_of_Option_ref_T_spec: 0 <= size_of_Option_ref_T
  
  constant size_of_Option_Box_T_Global: int = 8
  
  meta "rewrite_def" constant size_of_Option_Box_T_Global
  
  axiom size_of_Option_Box_T_Global_spec: 0 <= size_of_Option_Box_T_Global
  
  constant size_of_array_T_5: int = size_of_T * 5
  
  meta "rewrite_def" constant size_of_array_T_5
  
  axiom size_of_array_T_5_spec: 0 <= size_of_array_T_5
  
  constant size_of_array_T_0: int = size_of_T * 0
  
  meta "rewrite_def" constant size_of_array_T_0
  
  axiom size_of_array_T_0_spec: 0 <= size_of_array_T_0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec g_T (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = size_of_array_T_2'0 (fun (_ret: UInt64.t) -> [ &t2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] UInt64.t'int t2 = 2 * size_of_T} s1
      | s1 = {[@expl:assertion] size_of_ref_T = size_of_usize} s2
      | s2 = {[@expl:assertion] size_of_ptr_T = size_of_usize} s3
      | s3 = {[@expl:assertion] size_of_Box_T_Global = size_of_usize} s4
      | s4 = {[@expl:assertion] size_of_Option_ref_T = size_of_usize} s5
      | s5 = {[@expl:assertion] size_of_Option_Box_T_Global = size_of_usize} s6
      | s6 = {[@expl:assertion] size_of_array_T_5 = 5 * size_of_T} s7
      | s7 = {[@expl:assertion] size_of_array_T_0 = 0} s8
      | s8 = return {_0} ] ] [ & _0: () = Any.any_l () | & t2: UInt64.t = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
