module M_const__foo
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  constant const_FOO: UInt64.t = (42: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec foo (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- const_FOO ] s1 | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:foo ensures] result = (42: UInt64.t)} (! return {result}) ]
end
module M_const__array
  use creusot.slice.Slice64
  use creusot.int.Int32
  use seq.Seq
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  predicate inv [@inline:trivial] (_1: Seq.seq Int32.t) = true
  
  meta "rewrite_def" predicate inv
  
  predicate invariant' (self: Slice64.array Int32.t) =
    inv (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (9: UInt64.t)
  
  predicate inv'0 [@inline:trivial] (_1: Slice64.array Int32.t) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  constant const_X : Slice64.array Int32.t
  
  axiom const_X_spec: inv'0 const_X
  
  let rec set_X (ret) = bb0
    [ bb0 = s0
      [ s0 = Slice64.create <Int32.t> {(9: UInt64.t)} {fun (_: int) -> (1: Int32.t)}
          (fun (_res: Slice64.array Int32.t) -> [ &_0 <- _res ] s1)
      | s1 = const_ret {_0} ] ] [ & _0: Slice64.array Int32.t = Any.any_l () ]
    [ const_ret (_const: Slice64.array Int32.t) -> -{const_X = _const}- ret ]
  
  let rec len (self_: Slice64.slice Int32.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {Seq.length (Slice64.view self_) = UInt64.t'int result} (! return {result}) ]
  
  predicate invariant''0 (self: Slice64.array Int32.t) =
    inv (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (43: UInt64.t)
  
  predicate inv'1 [@inline:trivial] (_1: Slice64.array Int32.t) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  constant const_Y : Slice64.array Int32.t
  
  axiom const_Y_spec: inv'1 const_Y
  
  let rec set_Y (ret) = bb0
    [ bb0 = s0
      [ s0 = Slice64.create <Int32.t> {(43: UInt64.t)} {fun (_: int) -> (1: Int32.t)}
          (fun (_res: Slice64.array Int32.t) -> [ &_0 <- _res ] s1)
      | s1 = const_ret {_0} ] ] [ & _0: Slice64.array Int32.t = Any.any_l () ]
    [ const_ret (_const: Slice64.array Int32.t) -> -{const_Y = _const}- ret ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec array (return (x: UInt64.t)) = set_Y
      (set_X
        ((! bb0
        [ bb0 = s0
          [ s0 = bb0'0
            [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- const_X ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
            [ & _0'0: Slice64.array Int32.t = Any.any_l () ]
            [ _const_ret (_const: Slice64.array Int32.t) -> [ &_11 <- _const ] s1 ]
          | s1 = len {_11} (fun (_ret: UInt64.t) -> [ &_2 <- _ret ] s2)
          | s2 = bb1 ]
        | bb1 = s0
          [ s0 = bb0'0
            [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- const_Y ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
            [ & _0'0: Slice64.array Int32.t = Any.any_l () ]
            [ _const_ret (_const: Slice64.array Int32.t) -> [ &_10 <- _const ] s1 ]
          | s1 = len {_10} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s2)
          | s2 = bb2 ]
        | bb2 = s0 [ s0 = UInt64.add {_2} {_6} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
        [ & _0: UInt64.t = Any.any_l ()
        | & _2: UInt64.t = Any.any_l ()
        | & _6: UInt64.t = Any.any_l ()
        | & _10: Slice64.array Int32.t = Any.any_l ()
        | & _11: Slice64.array Int32.t = Any.any_l () ])
        [ return (result: UInt64.t) -> {[@expl:array ensures] result = (52: UInt64.t)} (! return {result}) ]))
end
module M_const__array_param
  use creusot.int.UInt32
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use seq.Seq
  
  constant const_N : UInt64.t
  
  let rec len (self_: Slice64.slice UInt32.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {Seq.length (Slice64.view self_) = UInt64.t'int result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec array_param (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = Slice64.create <UInt32.t> {const_N} {fun (_: int) -> (1: UInt32.t)}
              (fun (_res: Slice64.array UInt32.t) -> [ &_0'0 <- _res ] s1'0)
          | s1'0 = _const_ret {_0'0} ] ] [ & _0'0: Slice64.array UInt32.t = Any.any_l () ]
        [ _const_ret (_const: Slice64.array UInt32.t) -> [ &x <- _const ] s1 ]
      | s1 = len {x} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = return {_0} ] [ & _0: UInt64.t = Any.any_l () | & x: Slice64.array UInt32.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:array_param ensures] result = const_N} (! return {result}) ]
end
module M_const__add_one
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_N : UInt64.t
  
  type tuple = { f0: UInt64.t; f1: bool }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec add_one (return (x: UInt64.t)) = {[@expl:add_one requires] UInt64.lt const_N const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- let (_fst, _snd) = UInt64.add_with_overflow const_N (1: UInt64.t) in { f0 = _fst;
                                                                                                   f1 = _snd } ] s1'0
          | s1'0 = {[@expl:Add overflow] not _1.f1} s2
          | s2 = bb1 ]
        | bb1 = s0'0 [ s0'0 = [ &_0'0 <- _1.f0 ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () | & _1: tuple = Any.any_l () ]
        [ _const_ret (_const: UInt64.t) -> [ &_0 <- _const ] s1 ]
      | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:add_one ensures] UInt64.t'int result = UInt64.t'int const_N + 1}
      (! return {result}) ]
end
module M_const__add_one_2
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  constant const_M : UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  let rec add_one (return (x: UInt64.t)) = {[@expl:add_one requires] UInt64.lt const_M const_MAX}
    any [ return (result: UInt64.t) -> {UInt64.t'int result = UInt64.t'int const_M + 1} (! return {result}) ]
  
  constant add_one_logic: int = UInt64.t'int const_M + 1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec add_one_2 (return (x: UInt64.t)) = {[@expl:add_one_2 requires] UInt64.lt const_M const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = add_one (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:add_one_2 ensures] UInt64.t'int result = add_one_logic} (! return {result}) ]
end
module M_const__nat
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  constant const_VALUE : UInt64.t
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec nat (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- const_VALUE ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () ] [ _const_ret (_const: UInt64.t) -> [ &_0 <- _const ] s1 ]
      | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:nat ensures] result = const_VALUE} (! return {result}) ]
end
module M_const__Parent__child
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_M : UInt64.t
  
  constant const_N : UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate precondition (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in UInt64.t'int const_N
          + UInt64.t'int const_M
        <= UInt64.t'int const_MAX) -> precondition () args
  
  predicate postcondition_once (self: ()) (args: ()) (result: UInt64.t)
  
  axiom postcondition_fndef:
    forall args: (), res: UInt64.t [postcondition_once () args res]. postcondition_once () args res
      -> (let () = args in true)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec child (return (x: UInt64.t)) = {[@expl:child requires] UInt64.t'int const_N + UInt64.t'int const_M
    <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.add {const_N} {const_M} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () ]) [ return (result: UInt64.t) -> (! return {result}) ]
end
module M_const__nat_i
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  constant const_N : UInt64.t
  
  constant const_VALUE: UInt64.t = const_N
  
  let rec nat (return (x: UInt64.t)) = any [ return (result: UInt64.t) -> {result = const_VALUE} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec nat_i (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = nat (fun (_ret: UInt64.t) -> [ &_0'0 <- _ret ] s1'0) | s1'0 = bb1 ]
        | bb1 = _const_ret {_0'0} ] [ & _0'0: UInt64.t = Any.any_l () ]
        [ _const_ret (_const: UInt64.t) -> [ &_0 <- _const ] s1 ]
      | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:nat_i ensures] result = const_N} (! return {result}) ]
end
module M_const__nat_i2
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  constant const_VALUE : UInt64.t
  
  constant const_VALUE'0: UInt64.t = const_VALUE
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec nat_i2 (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- const_VALUE'0 ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () ] [ _const_ret (_const: UInt64.t) -> [ &_0 <- _const ] s1 ]
      | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:nat_i2 ensures] result = const_VALUE} (! return {result}) ]
end
module M_const__tuple
  use creusot.int.UInt64
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type tuple = { f0: UInt64.t; f1: Int32.t }
  
  constant const_TUP: tuple = { f0 = (42: UInt64.t); f1 = (24: Int32.t) }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec tuple (return (x: tuple)) = {[@expl:tuple requires] const_TUP.f0 = (42: UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- const_TUP ] s1 | s1 = return {_0} ] ] [ & _0: tuple = Any.any_l () ])
    [ return (result: tuple) -> {[@expl:tuple ensures] const_TUP.f1 = (24: Int32.t)} (! return {result}) ]
end
module M_const__inline_tuple
  use creusot.int.UInt64
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type tuple = { f0: UInt64.t; f1: Int32.t }
  
  constant const_ITUP: tuple = { f0 = (42: UInt64.t); f1 = (24: Int32.t) }
  
  constant const_TUP: tuple = { f0 = (42: UInt64.t); f1 = (24: Int32.t) }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec inline_tuple (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = {[@expl:assertion] const_ITUP = const_TUP} s1 | s1 = return {_0} ] ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_const__nat_i3
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_VALUE : UInt64.t
  
  type tuple = { f0: UInt64.t; f1: bool }
  
  constant const_VALUE'0 : UInt64.t
  
  let rec set_VALUE (ret) = bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- let (_fst, _snd) = UInt64.add_with_overflow const_VALUE const_VALUE in { f0 = _fst;
                                                                                                     f1 = _snd } ] s1'0
          | s1'0 = {[@expl:Add overflow] not _1.f1} s2
          | s2 = bb1 ]
        | bb1 = s0'0 [ s0'0 = [ &_0'0 <- _1.f0 ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () | & _1: tuple = Any.any_l () ]
        [ _const_ret (_const: UInt64.t) -> [ &_0 <- _const ] s1 ]
      | s1 = const_ret {_0} ] ] [ & _0: UInt64.t = Any.any_l () ]
    [ const_ret (_const: UInt64.t) -> -{const_VALUE'0 = _const}- ret ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec nat_i3 (return (x: ())) = set_VALUE
      ((! bb0
      [ bb0 = s0
        [ s0 = {[@expl:assertion] UInt64.t'int const_VALUE'0 = UInt64.t'int const_VALUE + UInt64.t'int const_VALUE} s1
        | s1 = return {_0} ] ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ])
end
module M_const__nat_i3_logic
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_VALUE : UInt64.t
  
  type tuple = { f0: UInt64.t; f1: bool }
  
  constant const_VALUE'0 : UInt64.t
  
  let rec set_VALUE (ret) = bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- let (_fst, _snd) = UInt64.add_with_overflow const_VALUE const_VALUE in { f0 = _fst;
                                                                                                     f1 = _snd } ] s1'0
          | s1'0 = {[@expl:Add overflow] not _1.f1} s2
          | s2 = bb1 ]
        | bb1 = s0'0 [ s0'0 = [ &_0'0 <- _1.f0 ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () | & _1: tuple = Any.any_l () ]
        [ _const_ret (_const: UInt64.t) -> [ &_0 <- _const ] s1 ]
      | s1 = const_ret {_0} ] ] [ & _0: UInt64.t = Any.any_l () ]
    [ const_ret (_const: UInt64.t) -> -{const_VALUE'0 = _const}- ret ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function nat_i3_logic : ()
  
  let rec vc_nat_i3_logic (ret) = set_VALUE
      ({[@expl:nat_i3_logic ensures] UInt64.t'int const_VALUE'0 = UInt64.t'int const_VALUE + UInt64.t'int const_VALUE}
      ret)
end
module M_const__qyi4420995221928654116__clone (* <Peano as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_Peano = C_Z | C_S t_Peano
  
  let rec v_S (input: t_Peano) (ret (field_0: t_Peano)) = any
    [ good (field_0: t_Peano) -> {C_S field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Peano [C_S field_0: t_Peano]. C_S field_0 <> input} (! {false} any) ]
  
  let rec clone' (self_: t_Peano) (return (x: t_Peano)) = any
    [ return (result: t_Peano) -> {result = self_} (! return {result}) ]
  
  type tuple = { f0: t_Peano; f1: t_Peano }
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: t_Peano) (result: t_Peano) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: t_Peano) (result_state: ()) (result: t_Peano) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: t_Peano) (res: t_Peano) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_Peano, res: t_Peano. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Peano) (res_state: ()) (res: t_Peano) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Peano, res_state: (), res: t_Peano. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: t_Peano) (result: t_Peano) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: t_Peano) (res: t_Peano) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Peano, res: t_Peano. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_Peano) (res_state: ()) (res: t_Peano) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Peano, res_state: (), res: t_Peano. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''0 (self: t_Peano) (return (x: t_Peano)) = (! bb0
    [ bb0 = any [ br0 -> {self = C_Z} (! bb4) | br1 (x0: t_Peano) -> {self = C_S x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_S {self} (fun (r0: t_Peano) -> [ &v0_1 <- r0 ] s1)
      | s1 = [ &_8 <- v0_1 ] s2
      | s2 = clone' {_8} (fun (_ret: t_Peano) -> [ &_6 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_S _6 ] s1 | s1 = bb6 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_Z ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_Peano = Any.any_l ()
    | & self: t_Peano = self
    | & v0_1: t_Peano = Any.any_l ()
    | & _6: t_Peano = Any.any_l ()
    | & _8: t_Peano = Any.any_l () ])
    [ return (result: t_Peano) -> {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = C_Z; f1 = C_Z} -> true
        | {f0 = C_S v0_1; f1 = C_S v0_r} -> postcondition () v0_1 v0_r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_const__zero
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Peano = C_Z | C_S t_Peano
  
  predicate inv [@inline:trivial] (_1: Seq.seq t_Peano) = true
  
  meta "rewrite_def" predicate inv
  
  predicate invariant' (self: Slice64.array t_Peano) =
    inv (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (2: UInt64.t)
  
  predicate inv'0 [@inline:trivial] (_1: Slice64.array t_Peano) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  constant const_PEANOS : Slice64.array t_Peano
  
  axiom const_PEANOS_spec: inv'0 const_PEANOS
  
  let rec set_PEANOS (ret) = bb0
    [ bb0 = s0
      [ s0 = [ &_1 <- C_Z ] s1
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1'0 <- C_Z ] s1'0 | s1'0 = [ &_0'0 <- _1'0 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Peano = Any.any_l () | & _1'0: t_Peano = Any.any_l () ]
        [ _const_ret (_const: t_Peano) -> [ &_6 <- _const ] s2 ]
      | s2 = [ &_4 <- _6 ] s3
      | s3 = [ &_2 <- C_S _4 ] s4
      | s4 = any
        [ any_ (__arr_temp: Slice64.array t_Peano) -> (! -{Seq.get __arr_temp.Slice64.elts 0 = _1
          /\ Seq.get __arr_temp.Slice64.elts 1 = _2 /\ Seq.length __arr_temp.Slice64.elts = 2}-
          [ &_0 <- __arr_temp ] s5) ]
      | s5 = const_ret {_0} ] ]
    [ & _0: Slice64.array t_Peano = Any.any_l ()
    | & _1: t_Peano = Any.any_l ()
    | & _2: t_Peano = Any.any_l ()
    | & _4: t_Peano = Any.any_l ()
    | & _6: t_Peano = Any.any_l () ] [ const_ret (_const: Slice64.array t_Peano) -> -{const_PEANOS = _const}- ret ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec zero (return (x: t_Peano)) = set_PEANOS
      ((! bb0
      [ bb0 = s0
        [ s0 = [ &_2 <- const_PEANOS ] s1
        | s1 = [ &_3 <- (0: UInt64.t) ] s2
        | s2 = [ &_4 <- UInt64.lt _3 (2: UInt64.t) ] s3
        | s3 = {[@expl:index in bounds] _4} s4
        | s4 = bb1 ]
      | bb1 = s0 [ s0 = Slice64.get <t_Peano> {_2} {_3} (fun (r: t_Peano) -> [ &_0 <- r ] s1) | s1 = return {_0} ] ]
      [ & _0: t_Peano = Any.any_l ()
      | & _2: Slice64.array t_Peano = Any.any_l ()
      | & _3: UInt64.t = Any.any_l ()
      | & _4: bool = Any.any_l () ])
      [ return (result: t_Peano) -> {[@expl:zero ensures] result = C_Z} (! return {result}) ])
end
module M_const__str
  use creusot.prelude.Any
  
  constant const_STR : string
  
  let rec set_STR (ret) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- "Hello" ] s1 | s1 = const_ret {_0} ] ] [ & _0: string = Any.any_l () ]
    [ const_ret (_const: string) -> -{const_STR = _const}- ret ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec str (return (x: string)) = set_STR
      ((! bb0
      [ bb0 = s0 [ s0 = [ &_0 <- const_STR ] s1 | s1 = return {_0} ] ] [ & _0: string = Any.any_l () ])
      [ return (result: string) -> {[@expl:str ensures] result = const_STR} (! return {result}) ])
end
module M_const__is_zst
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  let rec size_of (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {UInt64.t'int result = size_of_T} (! return {result}) ]
  
  constant const_IS_ZST : bool
  
  let rec set_IS_ZST (ret) = bb0
    [ bb0 = s0 [ s0 = size_of (fun (_ret: UInt64.t) -> [ &_1 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- _1 = (0: UInt64.t) ] s1 | s1 = const_ret {_0} ] ]
    [ & _0: bool = Any.any_l () | & _1: UInt64.t = Any.any_l () ]
    [ const_ret (_const: bool) -> -{const_IS_ZST = _const}- ret ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_zst (return (x: bool)) = set_IS_ZST
      ((! bb0
      [ bb0 = s0
        [ s0 = bb0'0
          [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- const_IS_ZST ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
          [ & _0'0: bool = Any.any_l () ] [ _const_ret (_const: bool) -> [ &_0 <- _const ] s1 ]
        | s1 = return {_0} ] ] [ & _0: bool = Any.any_l () ])
      [ return (result: bool) -> {[@expl:is_zst ensures] result = const_IS_ZST} (! return {result}) ])
end
module M_const__is_zst_z
  use creusot.prelude.Any
  
  constant const_IS_ZST: bool = true
  
  let rec is_zst (return (x: bool)) = any [ return (result: bool) -> {result = const_IS_ZST} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_zst_z (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = is_zst (fun (_ret: bool) -> [ &_0'0 <- _ret ] s1'0) | s1'0 = bb1 ]
        | bb1 = _const_ret {_0'0} ] [ & _0'0: bool = Any.any_l () ]
        [ _const_ret (_const: bool) -> [ &_0 <- _const ] s1 ]
      | s1 = return {_0} ] ] [ & _0: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:is_zst_z ensures] result} (! return {result}) ]
end
module M_const__max_entries_capacity
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant const_MAX_ENTRIES_CAPACITY: UInt64.t = (1152921504606846975: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec max_entries_capacity (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = {[@expl:assertion] UInt64.t'int const_MAX_ENTRIES_CAPACITY > 0} s1 | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_const__some_fn_pointer
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec some_fn_pointer (return (x: Int32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (2: Int32.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int32.t = Any.any_l () ])
    [ return (result: Int32.t) -> {[@expl:some_fn_pointer ensures] Int32.to_int result = 2} (! return {result}) ]
end
module M_const__fn_pointer_test
  use creusot.prelude.Any
  use creusot.int.Int32
  
  let rec some_fn_pointer (return (x: Int32.t)) = any
    [ return (result: Int32.t) -> {Int32.to_int result = 2} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec fn_pointer_test (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- () ] s1'0 | s1'0 = _const_ret {_0'0} ] ] [ & _0'0: () = Any.any_l () ]
        [ _const_ret (_const: ()) -> [ &_7 <- _const ] s1 ]
      | s1 = [ &x <- _7 ] s2
      | s2 = some_fn_pointer (fun (_ret: Int32.t) -> [ &y <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = {[@expl:assertion] Int32.to_int y = 2} s1 | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l () | & x: () = Any.any_l () | & y: Int32.t = Any.any_l () | & _7: () = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
