module M_bdd__hashmap__qyi1953663170559623169__hash (* <(U, V) as hashmap::Hash> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_U
  
  type t_V
  
  type tuple = { f0: t_U; f1: t_V }
  
  predicate inv (_1: t_U)
  
  predicate invariant' [@inline:trivial] (self: t_U) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: t_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_U [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition (self: ()) (args: t_U)
  
  axiom precondition_fndef: forall args: t_U [precondition () args]. (let self = args in inv'0 self)
      -> precondition () args
  
  type t_DeepModelTy
  
  function hash_log (_1: t_DeepModelTy) : int
  
  function deep_model (self: t_U) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_U) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate postcondition_once (self: ()) (args: t_U) (result: UInt64.t)
  
  axiom postcondition_fndef:
    forall args: t_U, res: UInt64.t [postcondition_once () args res]. postcondition_once () args res
      -> (let self = args in UInt64.t'int res = hash_log (deep_model'0 self))
  
  let rec hash (self: t_U) (return (x: UInt64.t)) = {[@expl:hash requires] precondition () self}
    any [ return (result: UInt64.t) -> {postcondition_once () self result} (! return {result}) ]
  
  predicate inv'1 (_1: t_V)
  
  predicate invariant''0 [@inline:trivial] (self: t_V) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_V [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition'0 (self: ()) (args: t_V)
  
  axiom precondition_fndef'0: forall args: t_V [precondition'0 () args]. (let self = args in inv'2 self)
      -> precondition'0 () args
  
  type t_DeepModelTy'0
  
  function hash_log'0 (_1: t_DeepModelTy'0) : int
  
  function deep_model'1 (self: t_V) : t_DeepModelTy'0
  
  function deep_model'2 [@inline:trivial] (self: t_V) : t_DeepModelTy'0 = deep_model'1 self
  
  meta "rewrite_def" function deep_model'2
  
  predicate postcondition_once'0 (self: ()) (args: t_V) (result: UInt64.t)
  
  axiom postcondition_fndef'0:
    forall args: t_V, res: UInt64.t [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let self = args in UInt64.t'int res = hash_log'0 (deep_model'2 self))
  
  let rec hash'0 (self: t_V) (return (x: UInt64.t)) = {[@expl:hash requires] precondition'0 () self}
    any [ return (result: UInt64.t) -> {postcondition_once'0 () self result} (! return {result}) ]
  
  let rec wrapping_mul (self_: UInt64.t) (rhs: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = UInt64.mul self_ rhs} (! return {result}) ]
  
  let rec wrapping_add (self_: UInt64.t) (rhs: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = UInt64.add self_ rhs} (! return {result}) ]
  
  predicate inv'3 (_1: tuple)
  
  axiom inv_axiom'1 [@rewrite]: forall x: tuple [inv'3 x]. inv'3 x = (let {f0 = x0; f1 = x1} = x in inv x0 /\ inv'1 x1)
  
  predicate invariant''1 [@inline:trivial] (self: tuple) = inv'3 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: tuple)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple [inv'4 x]. inv'4 x = invariant''1 x
  
  type tuple'0 = { f0'0: t_DeepModelTy; f1'0: t_DeepModelTy'0 }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log'1 (x: tuple'0) : int = Int.mod (hash_log x.f0'0 + hash_log'0 x.f1'0 * 17) (UInt64.t'int const_MAX
    + 1)
  
  function deep_model'3 [@inline:trivial] (self: tuple) : tuple'0 = { f0'0 = deep_model self.f0;
                                                                      f1'0 = deep_model'1 self.f1 }
  
  meta "rewrite_def" function deep_model'3
  
  function deep_model'4 [@inline:trivial] (self: tuple) : tuple'0 = deep_model'3 self
  
  meta "rewrite_def" function deep_model'4
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash'1 (self: tuple) (return (x: UInt64.t)) = {[@expl:hash 'self' type invariant] inv'4 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash {self.f0} (fun (_ret: UInt64.t) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = hash'0 {self.f1} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = wrapping_mul {_6} {(17: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = wrapping_add {_3} {_5} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self: tuple = self
    | & _3: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:hash ensures] UInt64.t'int result = hash_log'1 (deep_model'4 self)}
      (! return {result}) ]
end
module M_bdd__qyi2024536649982164874__assert_receiver_is_total_eq (* <Node<'arena> as std::cmp::Eq> *)
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq (self: t_Node) (return (x: ())) = (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_bdd__qyi4854841669736991510__eq (* <Node<'arena> as creusot_contracts::PartialEq> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type tuple = { f0: t_Node; f1: t_Node }
  
  let rec v_If (input: t_Node) (ret (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ good (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
        <> input}
      (! {false}
      any) ]
  
  function deep_model [@inline:trivial] (self: t_Bdd) : UInt64.t = self.t_Bdd__1
  
  meta "rewrite_def" function deep_model
  
  function view [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function view
  
  let rec eq (self: t_Bdd) (o: t_Bdd) (return (x: bool)) = any
    [ return (result: bool) -> {result = (view self = view o)} (! return {result}) ]
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function deep_model'0 (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'1 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model'0 self
  
  meta "rewrite_def" function deep_model'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq'0 (self: t_Node) (rhs: t_Node) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- { f0 = self; f1 = rhs } ] s1
      | s1 = any
        [ br0 -> {_4.f0 = C_False} (! bb2)
        | br1 -> {_4.f0 = C_True} (! bb4)
        | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_4.f0 = C_If x0 x1 x2} (! bb6) ] ]
    | bb6 = any
      [ br0 -> {_4.f1 = C_False} (! bb1)
      | br1 -> {_4.f1 = C_True} (! bb1)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_4.f1 = C_If x0 x1 x2} (! bb8) ]
    | bb8 = s0
      [ s0 = v_If {_4.f0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v_1 <- rv ] s1)
      | s1 = v_If {_4.f0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt_1 <- rchildt ] s2)
      | s2 = v_If {_4.f0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf_1 <- rchildf ] s3)
      | s3 = v_If {_4.f1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v_2 <- rv ] s4)
      | s4 = v_If {_4.f1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt_2 <- rchildt ] s5)
      | s5 = v_If {_4.f1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf_2 <- rchildf ] s6)
      | s6 = eq {childf_1} {childf_2} (fun (_ret: bool) -> [ &_17 <- _ret ] s7)
      | s7 = bb11 ]
    | bb11 = any [ br0 -> {_17 = false} (! bb19) | br1 -> {_17} (! bb12) ]
    | bb12 = s0 [ s0 = eq {childt_1} {childt_2} (fun (_ret: bool) -> [ &_20 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = any [ br0 -> {_20 = false} (! bb19) | br1 -> {_20} (! bb14) ]
    | bb14 = s0 [ s0 = [ &_23 <- v_1 = v_2 ] s1 | s1 = any [ br0 -> {_23 = false} (! bb19) | br1 -> {_23} (! bb15) ] ]
    | bb15 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb21 ]
    | bb19 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb21 ]
    | bb4 = any
      [ br0 -> {_4.f1 = C_False} (! bb1)
      | br1 -> {_4.f1 = C_True} (! bb9)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_4.f1 = C_If x0 x1 x2} (! bb1) ]
    | bb9 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb21 ]
    | bb2 = any
      [ br0 -> {_4.f1 = C_False} (! bb10)
      | br1 -> {_4.f1 = C_True} (! bb1)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_4.f1 = C_If x0 x1 x2} (! bb1) ]
    | bb1 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb21 ]
    | bb10 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb21 ]
    | bb21 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_Node = self
    | & rhs: t_Node = rhs
    | & _4: tuple = Any.any_l ()
    | & v_1: UInt64.t = Any.any_l ()
    | & childt_1: t_Bdd = Any.any_l ()
    | & childf_1: t_Bdd = Any.any_l ()
    | & v_2: UInt64.t = Any.any_l ()
    | & childt_2: t_Bdd = Any.any_l ()
    | & childf_2: t_Bdd = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _23: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (deep_model'1 self = deep_model'1 rhs)}
      (! return {result}) ]
end
module M_bdd__qyi17981791245757283426__clone (* <Node<'arena> as creusot_contracts::Clone> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  let rec v_If (input: t_Node) (ret (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ good (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
        <> input}
      (! {false}
      any) ]
  
  let rec clone' (self_: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = self_} (! return {result}) ]
  
  let rec clone''0 (self: t_Bdd) (return (x: t_Bdd)) = any
    [ return (result: t_Bdd) -> {result = self} (! return {result}) ]
  
  type tuple = { f0: t_Node; f1: t_Node }
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: UInt64.t) (result_state: ()) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate postcondition_once'0 [@inline:trivial] (self: ()) (args: t_Bdd) (result: t_Bdd) =
    let self'0 = args in result = self'0
  
  meta "rewrite_def" predicate postcondition_once'0
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 [@inline:trivial] (self: ()) (args: t_Bdd) (result_state: ()) (result: t_Bdd) =
    let self'0 = args in result = self'0
  
  meta "rewrite_def" predicate postcondition_mut'0
  
  function fn_mut_once'0 (self: ()) (args: t_Bdd) (res: t_Bdd) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: t_Bdd, res: t_Bdd. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: t_Bdd) (res_state: ()) (res: t_Bdd) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: t_Bdd, res_state: (), res: t_Bdd. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 [@inline:trivial] (self: ()) (args: t_Bdd) (result: t_Bdd) =
    let self'0 = args in result = self'0
  
  meta "rewrite_def" predicate postcondition'0
  
  function fn_once'0 (self: ()) (args: t_Bdd) (res: t_Bdd) : ()
  
  axiom fn_once_spec'0: forall self: (), args: t_Bdd, res: t_Bdd. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: t_Bdd) (res_state: ()) (res: t_Bdd) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: t_Bdd, res_state: (), res: t_Bdd. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''1 (self: t_Node) (return (x: t_Node)) = (! bb0
    [ bb0 = any
      [ br0 -> {self = C_False} (! bb6)
      | br1 -> {self = C_True} (! bb5)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {self = C_If x0 x1 x2} (! bb4) ]
    | bb4 = s0
      [ s0 = v_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v_1 <- rv ] s1)
      | s1 = v_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt_1 <- rchildt ] s2)
      | s2 = v_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf_1 <- rchildf ] s3)
      | s3 = [ &_9 <- v_1 ] s4
      | s4 = clone' {_9} (fun (_ret: UInt64.t) -> [ &_7 <- _ret ] s5)
      | s5 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_12 <- childt_1 ] s1 | s1 = clone''0 {_12} (fun (_ret: t_Bdd) -> [ &_10 <- _ret ] s2) | s2 = bb8 ]
    | bb8 = s0
      [ s0 = [ &_15 <- childf_1 ] s1 | s1 = clone''0 {_15} (fun (_ret: t_Bdd) -> [ &_13 <- _ret ] s2) | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- C_If _7 _10 _13 ] s1 | s1 = bb10 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_True ] s1 | s1 = bb10 ]
    | bb6 = s0 [ s0 = [ &_0 <- C_False ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Node = Any.any_l ()
    | & self: t_Node = self
    | & v_1: UInt64.t = Any.any_l ()
    | & childt_1: t_Bdd = Any.any_l ()
    | & childf_1: t_Bdd = Any.any_l ()
    | & _7: UInt64.t = Any.any_l ()
    | & _9: UInt64.t = Any.any_l ()
    | & _10: t_Bdd = Any.any_l ()
    | & _12: t_Bdd = Any.any_l ()
    | & _13: t_Bdd = Any.any_l ()
    | & _15: t_Bdd = Any.any_l () ])
    [ return (result: t_Node) -> {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = C_False; f1 = C_False} -> true
        | {f0 = C_True; f1 = C_True} -> true
        | {f0 = C_If v_1 childt_1 childf_1; f1 = C_If v_r childt_r childf_r} -> postcondition () v_1 v_r
        /\ postcondition'0 () childt_1 childt_r /\ postcondition'0 () childf_1 childf_r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_bdd__qyi1284786238026687571__assert_receiver_is_total_eq (* <Bdd<'arena> as std::cmp::Eq> *)
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq (self: t_Bdd) (return (x: ())) = (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_bdd__qyi2820858787824331484__clone (* <Bdd<'arena> as creusot_contracts::Clone> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: t_Bdd) (return (x: t_Bdd)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = return {_0} ] ] [ & _0: t_Bdd = Any.any_l () | & self: t_Bdd = self ])
    [ return (result: t_Bdd) -> {[@expl:clone ensures] result = self} (! return {result}) ]
end
module M_bdd__qyi699402059438633899__hash (* <Node<'arena> as hashmap::Hash> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  let rec v_If (input: t_Node) (ret (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ good (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
        <> input}
      (! {false}
      any) ]
  
  let rec wrapping_mul (self_: UInt64.t) (rhs: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = UInt64.mul self_ rhs} (! return {result}) ]
  
  let rec wrapping_add (self_: UInt64.t) (rhs: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = UInt64.add self_ rhs} (! return {result}) ]
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log (x: t_NodeLog) : int = match x with
      | C_False'0 -> 1
      | C_True'0 -> 2
      | C_If'0 v childt childf -> Int.mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int const_MAX + 1)
      end
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash (self: t_Node) (return (x: UInt64.t)) = (! bb0
    [ bb0 = any
      [ br0 -> {self = C_False} (! bb6)
      | br1 -> {self = C_True} (! bb5)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {self = C_If x0 x1 x2} (! bb4) ]
    | bb4 = s0
      [ s0 = v_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v <- rv ] s1)
      | s1 = v_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt <- rchildt ] s2)
      | s2 = v_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf <- rchildf ] s3)
      | s3 = wrapping_mul {childt.t_Bdd__1} {(5: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_9 <- _ret ] s4)
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = wrapping_add {v} {_9} (fun (_ret: UInt64.t) -> [ &_7 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0
      [ s0 = wrapping_mul {childf.t_Bdd__1} {(7: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_11 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0 [ s0 = wrapping_add {_7} {_11} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = bb11 ]
    | bb5 = s0 [ s0 = [ &_0 <- (2: UInt64.t) ] s1 | s1 = bb11 ]
    | bb6 = s0 [ s0 = [ &_0 <- (1: UInt64.t) ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self: t_Node = self
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & _7: UInt64.t = Any.any_l ()
    | & _9: UInt64.t = Any.any_l ()
    | & _11: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:hash ensures] UInt64.t'int result = hash_log (view self)}
      (! return {result}) ]
end
module M_bdd__qyi14323183011761258016__hash (* <Bdd<'arena> as hashmap::Hash> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function hash_log [@inline:trivial] (x: UInt64.t) : int = UInt64.t'int x
  
  meta "rewrite_def" function hash_log
  
  function deep_model [@inline:trivial] (self: t_Bdd) : UInt64.t = self.t_Bdd__1
  
  meta "rewrite_def" function deep_model
  
  function view [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash (self: t_Bdd) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self.t_Bdd__1 ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & self: t_Bdd = self ])
    [ return (result: UInt64.t) -> {[@expl:hash ensures] UInt64.t'int result = hash_log (view self)}
      (! return {result}) ]
end
module M_bdd__qyi2581120635339165136__eq (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [@inline:trivial] (self: t_Bdd) : UInt64.t = self.t_Bdd__1
  
  meta "rewrite_def" function deep_model
  
  function view [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq (self: t_Bdd) (o: t_Bdd) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self.t_Bdd__1 = o.t_Bdd__1 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self: t_Bdd = self | & o: t_Bdd = o ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (view self = view o)} (! return {result}) ]
end
module M_bdd__qyi13535665294507397779__size (* Bdd<'arena> *)
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Bdd
  
  function size (self: t_Bdd) : int
  
  goal vc_size: match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> [@expl:size ensures] 0 >= 0
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> [@expl:size ensures] 0 >= 0
      | {t_Bdd__0 = C_If _ childt childf; t_Bdd__1 = _} -> size childt >= 0
      -> (let ht = size childt in size childf >= 0 -> (let hf = size childf in [@expl:size ensures] 1 + ht + hf >= 0))
      end
end
module M_bdd__qyi11078426090797403070__grows_is_valid_bdd (* Context<'arena> *)
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'0 (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view self.current.t_Context__cnt) (view self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'0 self.current.t_Context__hashcons) n with
        | C_Some b -> Map.get (view'0 self.final.t_Context__hashcons) n = C_Some b
        | C_None -> true
        end)
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'1 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'1
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view'0 self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_Context
  
  constant b : t_Bdd
  
  function grows_is_valid_bdd (self: MutBorrow.t t_Context) (b: t_Bdd) : ()
  
  goal vc_grows_is_valid_bdd: grows self
    -> is_valid_bdd self.current b -> ([@expl:grows_is_valid_bdd ensures] is_valid_bdd self.final b)
end
module M_bdd__qyi11078426090797403070__grows_trans (* Context<'arena> *)
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'0 (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view self.current.t_Context__cnt) (view self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'0 self.current.t_Context__hashcons) n with
        | C_Some b -> Map.get (view'0 self.final.t_Context__hashcons) n = C_Some b
        | C_None -> true
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_Context
  
  constant o : MutBorrow.t t_Context
  
  constant oo : MutBorrow.t t_Context
  
  function grows_trans (self: MutBorrow.t t_Context) (o: MutBorrow.t t_Context) (oo: MutBorrow.t t_Context) : ()
  
  goal vc_grows_trans: grows self
    -> grows o
    -> self.final = o.current
    -> self.current = oo.current /\ self.final = oo.final -> ([@expl:grows_trans ensures] grows oo)
end
module M_bdd__qyi11078426090797403070__set_irrelevent_var (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'0
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view self.t_Context__hashcons) (view'0 b.t_Bdd__0) = C_Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'1 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'1
  
  function view'2 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'3 (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
          | C_Some b -> view'0 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'1 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'2 self.t_Context__not_memo) bm with
          | C_None -> true
          | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                  t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'3 self.t_Context__and_memo) abm with
        | C_None -> true
        | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                 t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Context
  
  constant a : t_Bdd
  
  constant x : UInt64.t
  
  constant v : Map.map UInt64.t bool
  
  constant b : bool
  
  function set_irrelevent_var (self: t_Context) (a: t_Bdd) (x: UInt64.t) (v: Map.map UInt64.t bool) (b: bool) : ()
  
  goal vc_set_irrelevent_var: inv self
    -> is_valid_bdd self a
    -> UInt64.t'int x < leastvar a
    -> match a with
      | {t_Bdd__0 = C_If _ childt childf; t_Bdd__1 = _} -> (([@expl:set_irrelevent_var requires #0] inv self)
        && ([@expl:set_irrelevent_var requires #1] is_valid_bdd self childt)
        && ([@expl:set_irrelevent_var requires #2] UInt64.t'int x < leastvar childt))
      /\ (interp childt v = interp childt (Map.set v x b)
      -> (let _ = set_irrelevent_var self childt x v b in (([@expl:set_irrelevent_var requires #0] inv self)
        && ([@expl:set_irrelevent_var requires #1] is_valid_bdd self childf)
        && ([@expl:set_irrelevent_var requires #2] UInt64.t'int x < leastvar childf))
      /\ (interp childf v = interp childf (Map.set v x b)
      -> (let _ = set_irrelevent_var self childf x v b in [@expl:set_irrelevent_var ensures] interp a v
      = interp a (Map.set v x b)))))
      | _ -> [@expl:set_irrelevent_var ensures] interp a v = interp a (Map.set v x b)
      end
end
module M_bdd__qyi11078426090797403070__discr_valuation (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  function size (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_If _ childt childf; t_Bdd__1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. size self >= 0
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'0
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view self.t_Context__hashcons) (view'0 b.t_Bdd__0) = C_Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'1 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'1
  
  function view'2 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'3 (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
          | C_Some b -> view'0 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'1 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'2 self.t_Context__not_memo) bm with
          | C_None -> true
          | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                  t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'3 self.t_Context__and_memo) abm with
        | C_None -> true
        | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                 t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  function set_irrelevent_var (self: t_Context) (a: t_Bdd) (x: UInt64.t) (v: Map.map UInt64.t bool) (b: bool) : () =
    match a with
      | {t_Bdd__0 = C_If _ childt childf; t_Bdd__1 = _} -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var_spec:
    forall self: t_Context, a: t_Bdd, x: UInt64.t, v: Map.map UInt64.t bool, b: bool. inv self
      -> is_valid_bdd self a -> UInt64.t'int x < leastvar a -> interp a v = interp a (Map.set v x b)
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Context
  
  constant a : t_Bdd
  
  constant b : t_Bdd
  
  function discr_valuation (self: t_Context) (a: t_Bdd) (b: t_Bdd) : Map.map UInt64.t bool
  
  goal vc_discr_valuation: inv self
    -> is_valid_bdd self a
    -> is_valid_bdd self b
    -> a <> b
    -> (if leastvar a < leastvar b then
      match a with
        | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if childf <> b then
          ((([@expl:discr_valuation requires #0] inv self)
              && ([@expl:discr_valuation requires #1] is_valid_bdd self childf)
              && ([@expl:discr_valuation requires #2] is_valid_bdd self b)
              && ([@expl:discr_valuation requires #3] childf <> b))
            /\ well_founded_relation (size a + size b) (size childf + size b))
          /\ (interp childf (discr_valuation self childf b) <> interp b (discr_valuation self childf b)
          -> (let result = Map.set (discr_valuation self childf b) v false in [@expl:discr_valuation ensures] interp a result
          <> interp b result))
        else
          ((([@expl:discr_valuation requires #0] inv self)
              && ([@expl:discr_valuation requires #1] is_valid_bdd self childt)
              && ([@expl:discr_valuation requires #2] is_valid_bdd self b)
              && ([@expl:discr_valuation requires #3] childt <> b))
            /\ well_founded_relation (size a + size b) (size childt + size b))
          /\ (interp childt (discr_valuation self childt b) <> interp b (discr_valuation self childt b)
          -> (let result = Map.set (discr_valuation self childt b) v true in [@expl:discr_valuation ensures] interp a result
          <> interp b result))
        
        | _ -> let result = Const.const true in [@expl:discr_valuation ensures] interp a result <> interp b result
        end
    else
      if leastvar a > leastvar b then
        match b with
          | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if childf <> a then
            ((([@expl:discr_valuation requires #0] inv self)
                && ([@expl:discr_valuation requires #1] is_valid_bdd self a)
                && ([@expl:discr_valuation requires #2] is_valid_bdd self childf)
                && ([@expl:discr_valuation requires #3] a <> childf))
              /\ well_founded_relation (size a + size b) (size a + size childf))
            /\ (interp a (discr_valuation self a childf) <> interp childf (discr_valuation self a childf)
            -> (let result = Map.set (discr_valuation self a childf) v false in [@expl:discr_valuation ensures] interp a result
            <> interp b result))
          else
            ((([@expl:discr_valuation requires #0] inv self)
                && ([@expl:discr_valuation requires #1] is_valid_bdd self a)
                && ([@expl:discr_valuation requires #2] is_valid_bdd self childt)
                && ([@expl:discr_valuation requires #3] a <> childt))
              /\ well_founded_relation (size a + size b) (size a + size childt))
            /\ (interp a (discr_valuation self a childt) <> interp childt (discr_valuation self a childt)
            -> (let result = Map.set (discr_valuation self a childt) v true in [@expl:discr_valuation ensures] interp a result
            <> interp b result))
          
          | _ -> let result = Const.const true in [@expl:discr_valuation ensures] interp a result <> interp b result
          end
      else
        match a with
          | {t_Bdd__0 = C_If v childta childfa; t_Bdd__1 = _} -> match b with
            | {t_Bdd__0 = C_If _ childtb childfb; t_Bdd__1 = _} -> if childfa <> childfb then
              ((([@expl:discr_valuation requires #0] inv self)
                  && ([@expl:discr_valuation requires #1] is_valid_bdd self childfa)
                  && ([@expl:discr_valuation requires #2] is_valid_bdd self childfb)
                  && ([@expl:discr_valuation requires #3] childfa <> childfb))
                /\ well_founded_relation (size a + size b) (size childfa + size childfb))
              /\ (interp childfa (discr_valuation self childfa childfb)
                <> interp childfb (discr_valuation self childfa childfb)
              -> (let result = Map.set (discr_valuation self childfa childfb) v false in [@expl:discr_valuation ensures] interp a result
              <> interp b result))
            else
              ((([@expl:discr_valuation requires #0] inv self)
                  && ([@expl:discr_valuation requires #1] is_valid_bdd self childta)
                  && ([@expl:discr_valuation requires #2] is_valid_bdd self childtb)
                  && ([@expl:discr_valuation requires #3] childta <> childtb))
                /\ well_founded_relation (size a + size b) (size childta + size childtb))
              /\ (interp childta (discr_valuation self childta childtb)
                <> interp childtb (discr_valuation self childta childtb)
              -> (let result = Map.set (discr_valuation self childta childtb) v true in [@expl:discr_valuation ensures] interp a result
              <> interp b result))
            
            | _ -> let result = Const.const true in [@expl:discr_valuation ensures] interp a result <> interp b result
            end
          | _ -> let result = Const.const true in [@expl:discr_valuation ensures] interp a result <> interp b result
          end
    
    )
end
module M_bdd__qyi11078426090797403070__bdd_canonical (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'0
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view self.t_Context__hashcons) (view'0 b.t_Bdd__0) = C_Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'1 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'1
  
  function view'2 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'3 (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
          | C_Some b -> view'0 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'1 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'2 self.t_Context__not_memo) bm with
          | C_None -> true
          | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                  t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'3 self.t_Context__and_memo) abm with
        | C_None -> true
        | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                 t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  function size (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_If _ childt childf; t_Bdd__1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. size self >= 0
  
  function discr_valuation (self: t_Context) (a: t_Bdd) (b: t_Bdd) : Map.map UInt64.t bool
  
  axiom discr_valuation_def: forall self: t_Context, a: t_Bdd, b: t_Bdd. inv self
      -> is_valid_bdd self a
      -> is_valid_bdd self b
      -> a <> b
      -> discr_valuation self a b
      = (if leastvar a < leastvar b then
        match a with
          | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if childf <> b then
            Map.set (discr_valuation self childf b) v false
          else
            Map.set (discr_valuation self childt b) v true
          
          | _ -> Const.const true
          end
      else
        if leastvar a > leastvar b then
          match b with
            | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if childf <> a then
              Map.set (discr_valuation self a childf) v false
            else
              Map.set (discr_valuation self a childt) v true
            
            | _ -> Const.const true
            end
        else
          match a with
            | {t_Bdd__0 = C_If v childta childfa; t_Bdd__1 = _} -> match b with
              | {t_Bdd__0 = C_If _ childtb childfb; t_Bdd__1 = _} -> if childfa <> childfb then
                Map.set (discr_valuation self childfa childfb) v false
              else
                Map.set (discr_valuation self childta childtb) v true
              
              | _ -> Const.const true
              end
            | _ -> Const.const true
            end
      
      )
  
  axiom discr_valuation_spec: forall self: t_Context, a: t_Bdd, b: t_Bdd. inv self
      -> is_valid_bdd self a
      -> is_valid_bdd self b -> a <> b -> interp a (discr_valuation self a b) <> interp b (discr_valuation self a b)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Context
  
  constant a : t_Bdd
  
  constant b : t_Bdd
  
  function bdd_canonical (self: t_Context) (a: t_Bdd) (b: t_Bdd) : ()
  
  goal vc_bdd_canonical: inv self
    -> is_valid_bdd self a
    -> is_valid_bdd self b
    -> (forall v: Map.map UInt64.t bool. interp a v = interp b v) -> ([@expl:bdd_canonical ensures] a = b)
end
module M_bdd__qyi11078426090797403070__new (* Context<'arena> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  use map.Map
  use map.Const
  use mach.int.Int
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option = C_None | C_Some t_Bdd
  
  function view (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  let rec new (return (x: t_MyHashMap)) = any
    [ return (result: t_MyHashMap) -> {view result = Const.const (C_None)} (! return {result}) ]
  
  type t_MyHashMap'0
  
  function view'0 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  let rec new'0 (return (x: t_MyHashMap'0)) = any
    [ return (result: t_MyHashMap'0) -> {view'0 result = Const.const (C_None)} (! return {result}) ]
  
  type t_MyHashMap'1
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'1 (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  let rec new'1 (return (x: t_MyHashMap'1)) = any
    [ return (result: t_MyHashMap'1) -> {view'1 result = Const.const (C_None)} (! return {result}) ]
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec new'2 (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {result.t_PeanoInt__0 = (0: UInt64.t)} (! return {result}) ]
  
  type t_Bump
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'2
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view self.t_Context__hashcons) (view'2 b.t_Bdd__0) = C_Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'3
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
          | C_Some b -> view'2 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'3 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'0 self.t_Context__not_memo) bm with
          | C_None -> true
          | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                  t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'1 self.t_Context__and_memo) abm with
        | C_None -> true
        | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                 t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'3 (alloc: t_Bump) (return (x: t_Context)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &alloc <- C_True ] s1'0 | s1'0 = [ &_0'0 <- alloc ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Node = Any.any_l () | & alloc: t_Node = Any.any_l () ]
        [ _const_ret (_const: t_Node) -> [ &_11 <- _const ] s1 ]
      | s1 = [ &t <- _11 ] s2
      | s2 = new (fun (_ret: t_MyHashMap) -> [ &_5 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = [ &_6 <- Const.const t ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = new'0 (fun (_ret: t_MyHashMap'0) -> [ &_8 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new'1 (fun (_ret: t_MyHashMap'1) -> [ &_9 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = new'2 (fun (_ret: t_PeanoInt) -> [ &_10 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_0 <- { t_Context__alloc = alloc;
                        t_Context__hashcons = _5;
                        t_Context__hashcons_ghost = _6;
                        t_Context__not_memo = _8;
                        t_Context__and_memo = _9;
                        t_Context__cnt = _10 } ] s1
      | s1 = return {_0} ] ]
    [ & _0: t_Context = Any.any_l ()
    | & alloc: t_Bump = alloc
    | & t: t_Node = Any.any_l ()
    | & _5: t_MyHashMap = Any.any_l ()
    | & _6: Map.map UInt64.t t_Node = Any.any_l ()
    | & _8: t_MyHashMap'0 = Any.any_l ()
    | & _9: t_MyHashMap'1 = Any.any_l ()
    | & _10: t_PeanoInt = Any.any_l ()
    | & _11: t_Node = Any.any_l () ])
    [ return (result: t_Context) -> {[@expl:new result type invariant] inv result} (! return {result}) ]
end
module M_bdd__qyi11078426090797403070__hashcons (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_Bump
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Bdd
  
  function view (self: t_MyHashMap) : Map.map t_NodeLog t_Option'0
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  let rec get (self: t_MyHashMap) (key: t_Node) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {match result with
        | C_Some v -> Map.get (view self) (deep_model'0 key) = C_Some'0 v
        | C_None -> Map.get (view self) (deep_model'0 key) = C_None'0
        end}
      (! return {result}) ]
  
  let rec alloc (self: t_Bump) (val': t_Node) (return (x: MutBorrow.t t_Node)) = any
    [ return (result: MutBorrow.t t_Node) -> {result.current = val'} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec add (self: MutBorrow.t t_MyHashMap) (key: t_Node) (val': t_Bdd) (return (x: ())) = any
    [ return (result: ()) -> {forall i: t_NodeLog. Map.get (view self.final) i
        = (if i = deep_model key then C_Some'0 val' else Map.get (view self.current) i)}
      (! return {result}) ]
  
  let rec incr (self: t_PeanoInt) (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {UInt64.t'int result.t_PeanoInt__0 = UInt64.t'int self.t_PeanoInt__0 + 1}
      (! return {result}) ]
  
  function view'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'0
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view self.t_Context__hashcons) (view'0 b.t_Bdd__0) = C_Some'0 b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'1 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'1
  
  function view'2 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option'0
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'3 (self: t_MyHashMap'1) : Map.map tuple t_Option'0
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
          | C_Some'0 b -> view'0 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'1 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None'0 -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'2 self.t_Context__not_memo) bm with
          | C_None'0 -> true
          | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                    t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'3 self.t_Context__and_memo) abm with
        | C_None'0 -> true
        | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                  t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                   t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc'0; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Context) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_1: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Context) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Context) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Bdd)) = any
    [ good (field_0: t_Bdd) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Bdd [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view'1 self.current.t_Context__cnt) (view'1 self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view self.current.t_Context__hashcons) n with
        | C_Some'0 b -> Map.get (view self.final.t_Context__hashcons) n = C_Some'0 b
        | C_None'0 -> true
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashcons (self: MutBorrow.t t_Context) (n: t_Node) (return (x: t_Bdd)) =
    {[@expl:hashcons 'self' type invariant] inv'0 self}
    {[@expl:hashcons requires] is_valid_node self.current n}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_11 <- n ] s1
      | s1 = get {self.current.t_Context__hashcons} {_11} (fun (_ret: t_Option) -> [ &_8 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = any [ br0 -> {_8 = C_None} (! bb4) | br1 (x0: t_Bdd) -> {_8 = C_Some x0} (! bb2) ]
    | bb4 = s0
      [ s0 = alloc {self.current.t_Context__alloc} {n} (fun (_ret: MutBorrow.t t_Node) -> [ &_19 <- _ret ] s1)
      | s1 = bb5 ]
    | bb5 = s0
      [ s0 = -{resolve'0 _19}- s1
      | s1 = [ &r'0 <- { t_Bdd__0 = _19.current; t_Bdd__1 = self.current.t_Context__cnt.t_PeanoInt__0 } ] s2
      | s2 = MutBorrow.borrow_final <t_MyHashMap> {self.current.t_Context__hashcons}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_MyHashMap) ->
            [ &_24 <- _ret ] [ &self <- { self with current = { self.current with t_Context__hashcons = _ret.final } } ]
            s3)
      | s3 = add {_24} {n} {r'0} (fun (_ret: ()) -> [ &_23 <- _ret ] s4)
      | s4 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_27 <- Map.set self.current.t_Context__hashcons_ghost r'0.t_Bdd__1 r'0.t_Bdd__0 ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &self <- { self with current = { self.current with t_Context__hashcons_ghost = _27 } } ] s1
      | s1 = incr {self.current.t_Context__cnt} (fun (_ret: t_PeanoInt) -> [ &_29 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = [ &self <- { self with current = { self.current with t_Context__cnt = _29 } } ] s1
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'2 self}- s3
      | s3 = [ &_0 <- r'0 ] s4
      | s4 = bb9 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'2 self}- s2 | s2 = bb3 ]
    | bb3 = s0
      [ s0 = v_Some {_8} (fun (r0: t_Bdd) -> [ &r <- r0 ] s1)
      | s1 = {[@expl:assertion] view'0 r.t_Bdd__0 = view'0 n} s2
      | s2 = [ &_0 <- r ] s3
      | s3 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & n: t_Node = n
    | & _8: t_Option = Any.any_l ()
    | & _11: t_Node = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _19: MutBorrow.t t_Node = Any.any_l ()
    | & _23: () = Any.any_l ()
    | & _24: MutBorrow.t t_MyHashMap = Any.any_l ()
    | & _27: Map.map UInt64.t t_Node = Any.any_l ()
    | & _29: t_PeanoInt = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:hashcons ensures #0] result.t_Bdd__0 = n}
      {[@expl:hashcons ensures #1] grows self}
      {[@expl:hashcons ensures #2] is_valid_bdd self.final result}
      (! return {result}) ]
end
module M_bdd__qyi11078426090797403070__node (* Context<'arena> *)
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [@inline:trivial] (self: t_Bdd) : UInt64.t = self.t_Bdd__1
  
  meta "rewrite_def" function deep_model
  
  function view [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function view
  
  let rec eq (self: t_Bdd) (o: t_Bdd) (return (x: bool)) = any
    [ return (result: bool) -> {result = (view self = view o)} (! return {result}) ]
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'0 (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model'0 (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'1 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model'0 self
  
  meta "rewrite_def" function view'1
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view'0 self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'2 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'2
  
  function view'3 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'4 (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view'0 self.t_Context__hashcons) n with
          | C_Some b -> view'1 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'2 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'3 self.t_Context__not_memo) bm with
          | C_None -> true
          | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                  t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'4 self.t_Context__and_memo) abm with
        | C_None -> true
        | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                 t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Context) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_1: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Context) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Context) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view'2 self.current.t_Context__cnt) (view'2 self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'0 self.current.t_Context__hashcons) n with
        | C_Some b -> Map.get (view'0 self.final.t_Context__hashcons) n = C_Some b
        | C_None -> true
        end)
  
  let rec hashcons (self: MutBorrow.t t_Context) (n: t_Node) (return (x: t_Bdd)) =
    {[@expl:hashcons 'self' type invariant] inv'0 self}
    {[@expl:hashcons requires] is_valid_node self.current n}
    any
    [ return (result: t_Bdd) -> {result.t_Bdd__0 = n}
      {grows self}
      {is_valid_bdd self.final result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec node (self: MutBorrow.t t_Context) (x: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:node 'self' type invariant] inv'0 self}
    {[@expl:node requires #0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    (! bb0
    [ bb0 = s0 [ s0 = eq {childt} {childf} (fun (_ret: bool) -> [ &_13 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_13 = false} (! bb3) | br1 -> {_13} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 = [ &_0 <- childt ] s3
      | s3 = bb5 ]
    | bb3 = s0
      [ s0 = [ &_18 <- C_If x childt childf ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_final <t_Context> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_17 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = hashcons {_17} {_18} (fun (_ret: t_Bdd) -> [ &_0 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & x: UInt64.t = x
    | & childt: t_Bdd = childt
    | & childf: t_Bdd = childf
    | & _13: bool = Any.any_l ()
    | & _17: MutBorrow.t t_Context = Any.any_l ()
    | & _18: t_Node = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:node ensures #0] grows self}
      {[@expl:node ensures #1] is_valid_bdd self.final result}
      {[@expl:node ensures #2] forall v: Map.map UInt64.t bool. interp result v
        = (if Map.get v x then interp childt v else interp childf v)}
      {[@expl:node ensures #3] UInt64.t'int x <= leastvar result}
      (! return {result}) ]
end
module M_bdd__qyi11078426090797403070__trueqy95z (* Context<'arena> *)
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'0
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view self.t_Context__hashcons) (view'0 b.t_Bdd__0) = C_Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'1 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'1
  
  function view'2 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'3 (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
          | C_Some b -> view'0 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'1 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'2 self.t_Context__not_memo) bm with
          | C_None -> true
          | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                  t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'3 self.t_Context__and_memo) abm with
        | C_None -> true
        | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                 t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Context) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_1: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view'1 self.current.t_Context__cnt) (view'1 self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view self.current.t_Context__hashcons) n with
        | C_Some b -> Map.get (view self.final.t_Context__hashcons) n = C_Some b
        | C_None -> true
        end)
  
  let rec hashcons (self: MutBorrow.t t_Context) (n: t_Node) (return (x: t_Bdd)) =
    {[@expl:hashcons 'self' type invariant] inv'0 self}
    {[@expl:hashcons requires] is_valid_node self.current n}
    any
    [ return (result: t_Bdd) -> {result.t_Bdd__0 = n}
      {grows self}
      {is_valid_bdd self.final result}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Context) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Context) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec trueqy95z (self: MutBorrow.t t_Context) (return (x: t_Bdd)) = {[@expl:true_ 'self' type invariant] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- C_True ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_final <t_Context> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_6 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = hashcons {_6} {_7} (fun (_ret: t_Bdd) -> [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return {_0} ] ]
    [ & _0: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & _6: MutBorrow.t t_Context = Any.any_l ()
    | & _7: t_Node = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:true_ ensures #0] grows self}
      {[@expl:true_ ensures #1] is_valid_bdd self.final result}
      {[@expl:true_ ensures #2] forall v: Map.map UInt64.t bool. interp result v}
      {[@expl:true_ ensures #3] UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
end
module M_bdd__qyi11078426090797403070__falseqy95z (* Context<'arena> *)
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'0
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view self.t_Context__hashcons) (view'0 b.t_Bdd__0) = C_Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'1 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'1
  
  function view'2 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'3 (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
          | C_Some b -> view'0 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'1 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'2 self.t_Context__not_memo) bm with
          | C_None -> true
          | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                  t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'3 self.t_Context__and_memo) abm with
        | C_None -> true
        | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                 t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Context) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_1: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view'1 self.current.t_Context__cnt) (view'1 self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view self.current.t_Context__hashcons) n with
        | C_Some b -> Map.get (view self.final.t_Context__hashcons) n = C_Some b
        | C_None -> true
        end)
  
  let rec hashcons (self: MutBorrow.t t_Context) (n: t_Node) (return (x: t_Bdd)) =
    {[@expl:hashcons 'self' type invariant] inv'0 self}
    {[@expl:hashcons requires] is_valid_node self.current n}
    any
    [ return (result: t_Bdd) -> {result.t_Bdd__0 = n}
      {grows self}
      {is_valid_bdd self.final result}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Context) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Context) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec falseqy95z (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:false_ 'self' type invariant] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- C_False ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_final <t_Context> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_6 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = hashcons {_6} {_7} (fun (_ret: t_Bdd) -> [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return {_0} ] ]
    [ & _0: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & _6: MutBorrow.t t_Context = Any.any_l ()
    | & _7: t_Node = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:false_ ensures #0] grows self}
      {[@expl:false_ ensures #1] is_valid_bdd self.final result}
      {[@expl:false_ ensures #2] forall v: Map.map UInt64.t bool. not interp result v}
      {[@expl:false_ ensures #3] UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
end
module M_bdd__qyi11078426090797403070__v (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Bump
  
  type t_MyHashMap
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'0;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view'0
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view self.t_Context__hashcons) (view'0 b.t_Bdd__0) = C_Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'1 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'1
  
  function view'2 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'3 (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
          | C_Some b -> view'0 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'1 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'2 self.t_Context__not_memo) bm with
          | C_None -> true
          | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                  t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'3 self.t_Context__and_memo) abm with
        | C_None -> true
        | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                 t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Context) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_1: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view'1 self.current.t_Context__cnt) (view'1 self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view self.current.t_Context__hashcons) n with
        | C_Some b -> Map.get (view self.final.t_Context__hashcons) n = C_Some b
        | C_None -> true
        end)
  
  let rec trueqy95z (self: MutBorrow.t t_Context) (return (x: t_Bdd)) = {[@expl:true_ 'self' type invariant] inv'0 self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec falseqy95z (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:false_ 'self' type invariant] inv'0 self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. not interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec node (self: MutBorrow.t t_Context) (x: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:node 'self' type invariant] inv'0 self}
    {[@expl:node requires #0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v = (if Map.get v x then interp childt v else interp childf v)}
      {UInt64.t'int x <= leastvar result}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Context) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Context) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec v (self: MutBorrow.t t_Context) (x: UInt64.t) (return (x'0: t_Bdd)) =
    {[@expl:v 'self' type invariant] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_7 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = trueqy95z {_7} (fun (_ret: t_Bdd) -> [ &t <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_9 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = falseqy95z {_9} (fun (_ret: t_Bdd) -> [ &f <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_final <t_Context> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_10 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = node {_10} {x} {t} {f} (fun (_ret: t_Bdd) -> [ &_0 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return {_0} ] ]
    [ & _0: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & x: UInt64.t = x
    | & t: t_Bdd = Any.any_l ()
    | & _7: MutBorrow.t t_Context = Any.any_l ()
    | & f: t_Bdd = Any.any_l ()
    | & _9: MutBorrow.t t_Context = Any.any_l ()
    | & _10: MutBorrow.t t_Context = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:v ensures #0] grows self}
      {[@expl:v ensures #1] is_valid_bdd self.final result}
      {[@expl:v ensures #2] forall v'0: Map.map UInt64.t bool. interp result v'0 = Map.get v'0 x}
      (! return {result}) ]
end
module M_bdd__qyi11078426090797403070__not (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  type t_Bump
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap'0;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap;
    t_Context__and_memo: t_MyHashMap'1;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Bdd
  
  function view (self: t_MyHashMap) : Map.map UInt64.t t_Option'0
  
  function deep_model [@inline:trivial] (self: t_Bdd) : UInt64.t = self.t_Bdd__1
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  let rec get (self: t_MyHashMap) (key: t_Bdd) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {match result with
        | C_Some v -> Map.get (view self) (deep_model'0 key) = C_Some'0 v
        | C_None -> Map.get (view self) (deep_model'0 key) = C_None'0
        end}
      (! return {result}) ]
  
  let rec v_If (input: t_Node) (ret (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ good (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
        <> input}
      (! {false}
      any) ]
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'0 (self: t_MyHashMap'0) : Map.map t_NodeLog t_Option'0
  
  function deep_model'1 (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'1 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model'1 self
  
  meta "rewrite_def" function view'1
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view'0 self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some'0 b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'2 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'2
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  function view'3 (self: t_MyHashMap'1) : Map.map tuple t_Option'0
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view'0 self.t_Context__hashcons) n with
          | C_Some'0 b -> view'1 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'2 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None'0 -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view self.t_Context__not_memo) bm with
          | C_None'0 -> true
          | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                    t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple. match Map.get (view'3 self.t_Context__and_memo) abm with
        | C_None'0 -> true
        | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0;
                                  t_Bdd__1 = abm.f0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1;
                                                                   t_Bdd__1 = abm.f1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Context) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_1: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view'2 self.current.t_Context__cnt) (view'2 self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'0 self.current.t_Context__hashcons) n with
        | C_Some'0 b -> Map.get (view'0 self.final.t_Context__hashcons) n = C_Some'0 b
        | C_None'0 -> true
        end)
  
  let rec node (self: MutBorrow.t t_Context) (x: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:node 'self' type invariant] inv'0 self}
    {[@expl:node requires #0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v = (if Map.get v x then interp childt v else interp childf v)}
      {UInt64.t'int x <= leastvar result}
      (! return {result}) ]
  
  let rec falseqy95z (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:false_ 'self' type invariant] inv'0 self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. not interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec trueqy95z (self: MutBorrow.t t_Context) (return (x: t_Bdd)) = {[@expl:true_ 'self' type invariant] inv'0 self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec add (self: MutBorrow.t t_MyHashMap) (key: t_Bdd) (val': t_Bdd) (return (x: ())) = any
    [ return (result: ()) -> {forall i: UInt64.t. Map.get (view self.final) i
        = (if i = deep_model key then C_Some'0 val' else Map.get (view self.current) i)}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Context) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Context) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Bdd)) = any
    [ good (field_0: t_Bdd) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Bdd [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function size (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_If _ childt childf; t_Bdd__1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. size self >= 0
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec not' (self: MutBorrow.t t_Context) (x: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:not 'self' type invariant] inv'0 self}
    {[@expl:not requires] is_valid_bdd self.current x}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_13 <- x ] s1
      | s1 = get {self.current.t_Context__not_memo} {_13} (fun (_ret: t_Option) -> [ &_10 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = any [ br0 -> {_10 = C_None} (! bb4) | br1 (x0: t_Bdd) -> {_10 = C_Some x0} (! bb2) ]
    | bb4 = any
      [ br0 -> {x.t_Bdd__0 = C_False} (! bb9)
      | br1 -> {x.t_Bdd__0 = C_True} (! bb10)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {x.t_Bdd__0 = C_If x0 x1 x2} (! bb8) ]
    | bb8 = s0
      [ s0 = v_If {x.t_Bdd__0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v <- rv ] s1)
      | s1 = v_If {x.t_Bdd__0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt <- rchildt ] s2)
      | s2 = v_If {x.t_Bdd__0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf <- rchildf ] s3)
      | s3 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_25 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s4)
      | s4 = not' {_25} {childt} (fun (_ret: t_Bdd) -> [ &childt'0 <- _ret ] s5)
      | s5 = bb13 ]
    | bb13 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_28 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = not' {_28} {childf} (fun (_ret: t_Bdd) -> [ &childf'0 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_30 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = node {_30} {v} {childt'0} {childf'0} (fun (_ret: t_Bdd) -> [ &r'0 <- _ret ] s2)
      | s2 = bb16 ]
    | bb10 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_19 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = falseqy95z {_19} (fun (_ret: t_Bdd) -> [ &r'0 <- _ret ] s2)
      | s2 = bb16 ]
    | bb9 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_20 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = trueqy95z {_20} (fun (_ret: t_Bdd) -> [ &r'0 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = MutBorrow.borrow_final <t_MyHashMap> {self.current.t_Context__not_memo}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 4}
          (fun (_ret: MutBorrow.t t_MyHashMap) ->
            [ &_35 <- _ret ] [ &self <- { self with current = { self.current with t_Context__not_memo = _ret.final } } ]
            s1)
      | s1 = add {_35} {x} {r'0} (fun (_ret: ()) -> [ &_34 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = [ &_0 <- r'0 ] s3 | s3 = bb18 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb3 ]
    | bb3 = s0 [ s0 = v_Some {_10} (fun (r0: t_Bdd) -> [ &r <- r0 ] s1) | s1 = [ &_0 <- r ] s2 | s2 = bb18 ]
    | bb18 = return {_0} ]
    [ & _0: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & x: t_Bdd = x
    | & _10: t_Option = Any.any_l ()
    | & _13: t_Bdd = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _19: MutBorrow.t t_Context = Any.any_l ()
    | & _20: MutBorrow.t t_Context = Any.any_l ()
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & childt'0: t_Bdd = Any.any_l ()
    | & _25: MutBorrow.t t_Context = Any.any_l ()
    | & childf'0: t_Bdd = Any.any_l ()
    | & _28: MutBorrow.t t_Context = Any.any_l ()
    | & _30: MutBorrow.t t_Context = Any.any_l ()
    | & _34: () = Any.any_l ()
    | & _35: MutBorrow.t t_MyHashMap = Any.any_l () ]
    [ not' (self: MutBorrow.t t_Context) (x: t_Bdd) (_ret (_r: t_Bdd)) ->
    {[@expl:function variant] well_founded_relation function_variant (size x)}
      not' {self} {x} (_ret) ] [ function_variant: int = size x ])
    [ return (result: t_Bdd) -> {[@expl:not ensures #0] grows self}
      {[@expl:not ensures #1] is_valid_bdd self.final result}
      {[@expl:not ensures #2] forall v: Map.map UInt64.t bool. interp result v = (not interp x v)}
      {[@expl:not ensures #3] leastvar x <= leastvar result}
      (! return {result}) ]
end
module M_bdd__qyi11078426090797403070__and (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  type tuple = { f0: t_Bdd; f1: t_Bdd }
  
  type t_MyHashMap
  
  type t_Bump
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Context = {
    t_Context__alloc: t_Bump;
    t_Context__hashcons: t_MyHashMap'0;
    t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
    t_Context__not_memo: t_MyHashMap'1;
    t_Context__and_memo: t_MyHashMap;
    t_Context__cnt: t_PeanoInt }
  
  type t_Option = C_None | C_Some t_Bdd
  
  type tuple'0 = { f0'0: UInt64.t; f1'0: UInt64.t }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Bdd
  
  function view (self: t_MyHashMap) : Map.map tuple'0 t_Option'0
  
  function deep_model [@inline:trivial] (self: t_Bdd) : UInt64.t = self.t_Bdd__1
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: tuple) : tuple'0 = { f0'0 = deep_model self.f0;
                                                                      f1'0 = deep_model self.f1 }
  
  meta "rewrite_def" function deep_model'0
  
  function deep_model'1 [@inline:trivial] (self: tuple) : tuple'0 = deep_model'0 self
  
  meta "rewrite_def" function deep_model'1
  
  let rec get (self: t_MyHashMap) (key: tuple) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {match result with
        | C_Some v -> Map.get (view self) (deep_model'1 key) = C_Some'0 v
        | C_None -> Map.get (view self) (deep_model'1 key) = C_None'0
        end}
      (! return {result}) ]
  
  type tuple'1 = { f0'1: t_Node; f1'1: t_Node }
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'0 (self: t_MyHashMap'0) : Map.map t_NodeLog t_Option'0
  
  function deep_model'2 (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'1 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model'2 self
  
  meta "rewrite_def" function view'1
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view'0 self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some'0 b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> UInt64.t'int const_MAX + 1
      | {t_Bdd__0 = C_If v _ _; t_Bdd__1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'2 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view'2
  
  function view'3 (self: t_MyHashMap'1) : Map.map UInt64.t t_Option'0
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  predicate invariant' [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view'0 self.t_Context__hashcons) n with
          | C_Some'0 b -> view'1 b.t_Bdd__0 = n
          /\ is_valid_node self b.t_Bdd__0
          /\ UInt64.lt b.t_Bdd__1 (view'2 self.t_Context__cnt)
          /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
          | C_None'0 -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view'3 self.t_Context__not_memo) bm with
          | C_None'0 -> true
          | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                    t_Bdd__1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tuple'0. match Map.get (view self.t_Context__and_memo) abm with
        | C_None'0 -> true
        | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f0'0;
                                  t_Bdd__1 = abm.f0'0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm.f1'0;
                                                                     t_Bdd__1 = abm.f1'0 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Context__alloc = alloc; t_Context__hashcons = hashcons; t_Context__hashcons_ghost = hashcons_ghost; t_Context__not_memo = not_memo; t_Context__and_memo = and_memo; t_Context__cnt = cnt} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Context) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_1: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Context) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Context) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_If (input: t_Node) (ret (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ good (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
        <> input}
      (! {false}
      any) ]
  
  function cmp_log'0 (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp'0 (x: int) (y: int) : ()
  
  axiom eq_cmp_spec'0: forall x: int, y: int. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: int) (y: int) : ()
  
  axiom antisym2_spec'0: forall x: int, y: int. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: int) (y: int) : ()
  
  axiom antisym1_spec'0: forall x: int, y: int. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: int, y: int, z: int, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: int) : ()
  
  axiom refl_spec'0: forall x: int. cmp_log'0 x x = C_Equal
  
  function cmp_gt_log'0 (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec'0: forall x: int, y: int. (x > y) = (cmp_log'0 x y = C_Greater)
  
  function cmp_ge_log'0 (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec'0: forall x: int, y: int. (x >= y) = (cmp_log'0 x y <> C_Less)
  
  function cmp_lt_log'0 (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec'0: forall x: int, y: int. (x < y) = (cmp_log'0 x y = C_Less)
  
  function cmp_le_log'0 (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec'0: forall x: int, y: int. (x <= y) = (cmp_log'0 x y <> C_Greater)
  
  function deep_model'3 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model'3
  
  let rec cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Ordering)) = any
    [ return (result: t_Ordering) -> {result = cmp_log'0 (deep_model'3 self_) (deep_model'3 rhs)} (! return {result}) ]
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view'2 self.current.t_Context__cnt) (view'2 self.final.t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'0 self.current.t_Context__hashcons) n with
        | C_Some'0 b -> Map.get (view'0 self.final.t_Context__hashcons) n = C_Some'0 b
        | C_None'0 -> true
        end)
  
  let rec node (self: MutBorrow.t t_Context) (x: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:node 'self' type invariant] inv'0 self}
    {[@expl:node requires #0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v = (if Map.get v x then interp childt v else interp childf v)}
      {UInt64.t'int x <= leastvar result}
      (! return {result}) ]
  
  let rec falseqy95z (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:false_ 'self' type invariant] inv'0 self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. not interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec add (self: MutBorrow.t t_MyHashMap) (key: tuple) (val': t_Bdd) (return (x: ())) = any
    [ return (result: ()) -> {forall i: tuple'0. Map.get (view self.final) i
        = (if i = deep_model'0 key then C_Some'0 val' else Map.get (view self.current) i)}
      (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Bdd)) = any
    [ good (field_0: t_Bdd) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Bdd [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function size (self: t_Bdd) : int = match self with
      | {t_Bdd__0 = C_True; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_False; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_If _ childt childf; t_Bdd__1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. size self >= 0
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec and (self: MutBorrow.t t_Context) (a: t_Bdd) (b: t_Bdd) (return (x: t_Bdd)) =
    {[@expl:and 'self' type invariant] inv'0 self}
    {[@expl:and requires #0] is_valid_bdd self.current a}
    {[@expl:and requires #1] is_valid_bdd self.current b}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_16 <- { f0 = a; f1 = b } ] s1
      | s1 = [ &_15 <- _16 ] s2
      | s2 = get {self.current.t_Context__and_memo} {_15} (fun (_ret: t_Option) -> [ &_12 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = any [ br0 -> {_12 = C_None} (! bb4) | br1 (x0: t_Bdd) -> {_12 = C_Some x0} (! bb2) ]
    | bb4 = s0
      [ s0 = [ &_23 <- { f0'1 = a.t_Bdd__0; f1'1 = b.t_Bdd__0 } ] s1
      | s1 = any
        [ br0 -> {_23.f0'1 = C_False} (! bb5)
        | br1 -> {_23.f0'1 = C_True} (! bb16)
        | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_23.f0'1 = C_If x0 x1 x2} (! bb5) ] ]
    | bb5 = any
      [ br0 -> {_23.f1'1 = C_False} (! bb7)
      | br1 -> {_23.f1'1 = C_True} (! bb15)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_23.f1'1 = C_If x0 x1 x2} (! bb7) ]
    | bb7 = any
      [ br0 -> {_23.f0'1 = C_False} (! bb14)
      | br1 -> {_23.f0'1 = C_True} (! bb9)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_23.f0'1 = C_If x0 x1 x2} (! bb9) ]
    | bb9 = any
      [ br0 -> {_23.f1'1 = C_False} (! bb14)
      | br1 -> {_23.f1'1 = C_True} (! bb10)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_23.f1'1 = C_If x0 x1 x2} (! bb11) ]
    | bb11 = any
      [ br0 -> {_23.f0'1 = C_False} (! bb10)
      | br1 -> {_23.f0'1 = C_True} (! bb10)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_23.f0'1 = C_If x0 x1 x2} (! bb12) ]
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = {false} any ]
    | bb12 = s0
      [ s0 = v_If {_23.f0'1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &va <- rv ] s1)
      | s1 = v_If {_23.f0'1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childta <- rchildt ] s2)
      | s2 = v_If {_23.f0'1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childfa <- rchildf ] s3)
      | s3 = v_If {_23.f1'1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &vb <- rv ] s4)
      | s4 = v_If {_23.f1'1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childtb <- rchildt ] s5)
      | s5 = v_If {_23.f1'1} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childfb <- rchildf ] s6)
      | s6 = [ &_45 <- vb ] s7
      | s7 = cmp {va} {_45} (fun (_ret: t_Ordering) -> [ &_42 <- _ret ] s8)
      | s8 = bb18 ]
    | bb18 = any
      [ br0 -> {_42 = C_Less} (! bb23) | br1 -> {_42 = C_Equal} (! bb22) | br2 -> {_42 = C_Greater} (! bb24) ]
    | bb24 = s0
      [ s0 = [ &v <- vb ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_49 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = and {_49} {a} {childtb} (fun (_ret: t_Bdd) -> [ &_48 <- _ret ] s3)
      | s3 = bb25 ]
    | bb25 = s0
      [ s0 = [ &childt <- _48 ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_53 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = and {_53} {a} {childfb} (fun (_ret: t_Bdd) -> [ &_52 <- _ret ] s3)
      | s3 = bb26 ]
    | bb26 = s0 [ s0 = [ &childf <- _52 ] s1 | s1 = bb31 ]
    | bb22 = s0
      [ s0 = [ &v <- va ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_67 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = and {_67} {childta} {childtb} (fun (_ret: t_Bdd) -> [ &_66 <- _ret ] s3)
      | s3 = bb29 ]
    | bb29 = s0
      [ s0 = [ &childt <- _66 ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_71 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = and {_71} {childfa} {childfb} (fun (_ret: t_Bdd) -> [ &_70 <- _ret ] s3)
      | s3 = bb30 ]
    | bb30 = s0 [ s0 = [ &childf <- _70 ] s1 | s1 = bb31 ]
    | bb23 = s0
      [ s0 = [ &v <- va ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_58 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = and {_58} {childta} {b} (fun (_ret: t_Bdd) -> [ &_57 <- _ret ] s3)
      | s3 = bb27 ]
    | bb27 = s0
      [ s0 = [ &childt <- _57 ] s1
      | s1 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_62 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s2)
      | s2 = and {_62} {childfa} {b} (fun (_ret: t_Bdd) -> [ &_61 <- _ret ] s3)
      | s3 = bb28 ]
    | bb28 = s0 [ s0 = [ &childf <- _61 ] s1 | s1 = bb31 ]
    | bb31 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_74 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = node {_74} {v} {childt} {childf} (fun (_ret: t_Bdd) -> [ &r'0 <- _ret ] s2)
      | s2 = bb33 ]
    | bb14 = s0
      [ s0 = {inv self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_ret: MutBorrow.t t_Context) ->
            [ &_31 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = falseqy95z {_31} (fun (_ret: t_Bdd) -> [ &r'0 <- _ret ] s2)
      | s2 = bb33 ]
    | bb15 = s0 [ s0 = [ &r'0 <- a ] s1 | s1 = bb33 ]
    | bb16 = s0 [ s0 = [ &r'0 <- b ] s1 | s1 = bb33 ]
    | bb33 = s0
      [ s0 = [ &_80 <- { f0 = a; f1 = b } ] s1
      | s1 = MutBorrow.borrow_final <t_MyHashMap> {self.current.t_Context__and_memo}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 5}
          (fun (_ret: MutBorrow.t t_MyHashMap) ->
            [ &_79 <- _ret ] [ &self <- { self with current = { self.current with t_Context__and_memo = _ret.final } } ]
            s2)
      | s2 = add {_79} {_80} {r'0} (fun (_ret: ()) -> [ &_78 <- _ret ] s3)
      | s3 = bb34 ]
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = [ &_0 <- r'0 ] s3 | s3 = bb35 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb3 ]
    | bb3 = s0 [ s0 = v_Some {_12} (fun (r0: t_Bdd) -> [ &r <- r0 ] s1) | s1 = [ &_0 <- r ] s2 | s2 = bb35 ]
    | bb35 = return {_0} ]
    [ & _0: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & a: t_Bdd = a
    | & b: t_Bdd = b
    | & _12: t_Option = Any.any_l ()
    | & _15: tuple = Any.any_l ()
    | & _16: tuple = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _23: tuple'1 = Any.any_l ()
    | & _31: MutBorrow.t t_Context = Any.any_l ()
    | & va: UInt64.t = Any.any_l ()
    | & childta: t_Bdd = Any.any_l ()
    | & childfa: t_Bdd = Any.any_l ()
    | & vb: UInt64.t = Any.any_l ()
    | & childtb: t_Bdd = Any.any_l ()
    | & childfb: t_Bdd = Any.any_l ()
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & _42: t_Ordering = Any.any_l ()
    | & _45: UInt64.t = Any.any_l ()
    | & _48: t_Bdd = Any.any_l ()
    | & _49: MutBorrow.t t_Context = Any.any_l ()
    | & _52: t_Bdd = Any.any_l ()
    | & _53: MutBorrow.t t_Context = Any.any_l ()
    | & _57: t_Bdd = Any.any_l ()
    | & _58: MutBorrow.t t_Context = Any.any_l ()
    | & _61: t_Bdd = Any.any_l ()
    | & _62: MutBorrow.t t_Context = Any.any_l ()
    | & _66: t_Bdd = Any.any_l ()
    | & _67: MutBorrow.t t_Context = Any.any_l ()
    | & _70: t_Bdd = Any.any_l ()
    | & _71: MutBorrow.t t_Context = Any.any_l ()
    | & _74: MutBorrow.t t_Context = Any.any_l ()
    | & _78: () = Any.any_l ()
    | & _79: MutBorrow.t t_MyHashMap = Any.any_l ()
    | & _80: tuple = Any.any_l () ]
    [ and (self: MutBorrow.t t_Context) (a: t_Bdd) (b: t_Bdd) (_ret (_r: t_Bdd)) ->
    {[@expl:function variant] well_founded_relation function_variant (size a + size b)}
      and {self} {a} {b} (_ret) ] [ function_variant: int = size a + size b ])
    [ return (result: t_Bdd) -> {[@expl:and ensures #0] grows self}
      {[@expl:and ensures #1] is_valid_bdd self.final result}
      {[@expl:and ensures #2] forall v: Map.map UInt64.t bool. interp result v = (interp a v /\ interp b v)}
      {[@expl:and ensures #3] leastvar a <= leastvar result \/ leastvar b <= leastvar result}
      (! return {result}) ]
end
module M_bdd__hashmap__qyi1953663170559623169__hash__refines (* <(U, V) as hashmap::Hash> *)
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_U
  
  type t_V
  
  type tuple = { f0: t_U; f1: t_V }
  
  predicate inv (_1: t_U)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: tuple)
  
  axiom inv_axiom [@rewrite]: forall x: tuple [inv'1 x]. inv'1 x = (let {f0 = x0; f1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate invariant' [@inline:trivial] (self: tuple) = inv'1 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 (_1: tuple)
  
  axiom inv_axiom'0 [@rewrite]: forall x: tuple [inv'2 x]. inv'2 x = invariant' x
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type tuple'0 = { f0'0: t_DeepModelTy; f1'0: t_DeepModelTy'0 }
  
  function hash_log (_1: t_DeepModelTy) : int
  
  function hash_log'0 (_1: t_DeepModelTy'0) : int
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log'1 (x: tuple'0) : int = Int.mod (hash_log x.f0'0 + hash_log'0 x.f1'0 * 17) (UInt64.t'int const_MAX
    + 1)
  
  function deep_model (self: t_U) : t_DeepModelTy
  
  function deep_model'0 (self: t_V) : t_DeepModelTy'0
  
  function deep_model'1 [@inline:trivial] (self: tuple) : tuple'0 = { f0'0 = deep_model self.f0;
                                                                      f1'0 = deep_model'0 self.f1 }
  
  meta "rewrite_def" function deep_model'1
  
  function deep_model'2 [@inline:trivial] (self: tuple) : tuple'0 = deep_model'1 self
  
  meta "rewrite_def" function deep_model'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tuple. inv'2 self
      -> inv'2 self
      /\ (forall result: UInt64.t. UInt64.t'int result = hash_log'1 (deep_model'2 self)
        -> UInt64.t'int result = hash_log'1 (deep_model'2 self))
end
module M_bdd__qyi699402059438633899__hash__refines (* <Node<'arena> as hashmap::Hash> *)
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NodeLog = C_False | C_True | C_If UInt64.t UInt64.t UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log (x: t_NodeLog) : int = match x with
      | C_False -> 1
      | C_True -> 2
      | C_If v childt childf -> Int.mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int const_MAX + 1)
      end
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False'0 | C_True'0 | C_If'0 UInt64.t t_Bdd t_Bdd
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False'0 -> C_False
      | C_True'0 -> C_True
      | C_If'0 v childt childf -> C_If v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function view
  
  function deep_model'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Node. forall result: UInt64.t. UInt64.t'int result = hash_log (view self)
        -> UInt64.t'int result = hash_log (deep_model'0 self)
end
module M_bdd__qyi14323183011761258016__hash__refines (* <Bdd<'arena> as hashmap::Hash> *)
  use creusot.int.UInt64
  
  function hash_log [@inline:trivial] (x: UInt64.t) : int = UInt64.t'int x
  
  meta "rewrite_def" function hash_log
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [@inline:trivial] (self: t_Bdd) : UInt64.t = self.t_Bdd__1
  
  meta "rewrite_def" function deep_model
  
  function view [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function view
  
  function deep_model'0 [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Bdd. forall result: UInt64.t. UInt64.t'int result = hash_log (view self)
        -> UInt64.t'int result = hash_log (deep_model'0 self)
end
module M_bdd__qyi4854841669736991510__eq__refines (* <Node<'arena> as creusot_contracts::PartialEq> *)
  use creusot.int.UInt64
  
  type t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  
  type t_NodeLog = C_False'0 | C_True'0 | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function deep_model (self: t_Node) : t_NodeLog = match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'0 [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Node. forall rhs: t_Node. forall result: bool. result
            = (deep_model'0 self_ = deep_model'0 rhs) -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_bdd__qyi2581120635339165136__eq__refines (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  use creusot.int.UInt64
  
  type t_Node = C_False | C_True | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [@inline:trivial] (self: t_Bdd) : UInt64.t = self.t_Bdd__1
  
  meta "rewrite_def" function deep_model
  
  function view [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function view
  
  function deep_model'0 [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Bdd. forall rhs: t_Bdd. forall result: bool. result = (view self_ = view rhs)
          -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
