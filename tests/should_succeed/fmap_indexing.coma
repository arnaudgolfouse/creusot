module M_fmap_indexing__foo
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  type t_Option = C_None | C_Some int
  
  function view (self: t_FMap) : Map.map int t_Option
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None)
  
  function get [@inline:trivial] (self: t_FMap) (k: int) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: int) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: int) (v: int) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: int, v: int. view (insert self k v) = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: int, v: int. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  predicate index_logic [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : int = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: int) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: int) : int = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: int) : int = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec foo (return' (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = [ &map <- empty ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_3 <- insert map 1 3 ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &map <- _3 ] s1
      | s1 = {[@expl:assertion] index_logic'0 map 1 = 3} s2
      | s2 = [ &_7 <- insert map 2 42 ] s3
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = [ &map <- _7 ] s1
      | s1 = {[@expl:assertion] index_logic'0 map 1 = 3 /\ index_logic'0 map 2 = 42} s2
      | s2 = [ &_11 <- insert map 1 4 ] s3
      | s3 = bb4 ]
    | bb4 = s0
      [ s0 = [ &map <- _11 ] s1
      | s1 = {[@expl:assertion] index_logic'0 map 1 = 4 /\ index_logic'0 map 2 = 42} s2
      | s2 = return''0 {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & map: t_FMap = Any.any_l ()
    | & _3: t_FMap = Any.any_l ()
    | & _7: t_FMap = Any.any_l ()
    | & _11: t_FMap = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
