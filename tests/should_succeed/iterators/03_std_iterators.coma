module M_03_std_iterators__slice_iter
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter = { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 (_1: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_1: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 (self: Slice64.slice t_T) = inv'1 (Slice64.view self)
  
  predicate inv'2 (_1: Slice64.slice t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Slice64.slice t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: Slice64.slice t_T) = inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 (_1: Slice64.slice t_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Slice64.slice t_T [inv'3 x]. inv'3 x = invariant''2 x
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  let rec iter (self_: Slice64.slice t_T) (return (x: t_Iter)) = {[@expl:iter 'self_' type invariant] inv'3 self_}
    any [ return (result: t_Iter) -> {view result = self_} (! return {result}) ]
  
  let rec into_iter (self_: t_Iter) (return (x: t_Iter)) = any
    [ return (result: t_Iter) -> {result = self_} (! return {result}) ]
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  function produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : () = ()
  
  axiom produces_trans_spec: forall a: t_Iter, ab: Seq.seq t_T, b: t_Iter, bc: Seq.seq t_T, c: t_Iter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Iter) : () = ()
  
  axiom produces_refl_spec: forall self: t_Iter. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv'4 (_1: t_Iter)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Iter [inv'4 x]. inv'4 x = true
  
  predicate invariant''3 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 (_1: t_T)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_T [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self: t_T) = inv'5 self
  
  predicate inv'6 (_1: t_T)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_T [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'6 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'7 (_1: Seq.seq t_T)
  
  axiom inv_axiom'6 [@rewrite]: forall x: Seq.seq t_T [inv'7 x]. inv'7 x = invariant''5 x
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv'8 (_1: t_Option)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Option [inv'8 x]. inv'8 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'5 a_0
        end
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Iter) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_Iter) =
    resolve self /\ Slice64.view (view self.current) = (Seq.empty: Seq.seq t_T)
  
  let rec next (self_: MutBorrow.t t_Iter) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {inv'8 result}
      {match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Iter) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec slice_iter (slice: Slice64.slice t_T) (return (x: UInt64.t)) =
    {[@expl:slice_iter 'slice' type invariant] inv'3 slice}
    {[@expl:slice_iter requires] Seq.length (Slice64.view slice) < 1000}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &i <- (0: UInt64.t) ] s1 | s1 = iter {slice} (fun (_ret: t_Iter) -> [ &_7 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = into_iter {_7} (fun (_ret: t_Iter) -> [ &iter'0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &iter_old <- iter'0 ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq t_T ] s1 | s1 = bb5 ]
    | bb5 = bb5
      [ bb5 = {[@expl:for invariant] inv'7 produced}
        {[@expl:for invariant] inv'4 iter'0}
        {[@expl:for invariant] produces iter_old produced iter'0}
        {[@expl:loop invariant] UInt64.t'int i = Seq.length produced}
        (! s0)
        [ s0 = bb6 ]
        [ bb6 = s0
          [ s0 = MutBorrow.borrow_mut <t_Iter> {iter'0}
              (fun (_ret: MutBorrow.t t_Iter) -> [ &_21 <- _ret ] [ &iter'0 <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Iter> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret: MutBorrow.t t_Iter) -> [ &_20 <- _ret ] [ &_21 <- { _21 with current = _ret.final } ] s2)
          | s2 = next {_20} (fun (_ret: t_Option) -> [ &_19 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve'0 _21}- s1
          | s1 = any [ br0 -> {_19 = C_None} (! bb10) | br1 (x0: t_T) -> {_19 = C_Some x0} (! bb11) ] ]
        | bb11 = s0
          [ s0 = v_Some {_19} (fun (r0: t_T) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_24 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb12 ]
        | bb12 = s0
          [ s0 = [ &produced <- _24 ] s1
          | s1 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s2)
          | s2 = bb5 ] ] ]
    | bb10 = s0 [ s0 = [ &_0 <- i ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & slice: Slice64.slice t_T = slice
    | & i: UInt64.t = Any.any_l ()
    | & iter'0: t_Iter = Any.any_l ()
    | & _7: t_Iter = Any.any_l ()
    | & iter_old: t_Iter = Any.any_l ()
    | & produced: Seq.seq t_T = Any.any_l ()
    | & _19: t_Option = Any.any_l ()
    | & _20: MutBorrow.t t_Iter = Any.any_l ()
    | & _21: MutBorrow.t t_Iter = Any.any_l ()
    | & __creusot_proc_iter_elem: t_T = Any.any_l ()
    | & _24: Seq.seq t_T = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:slice_iter ensures] UInt64.t'int result = Seq.length (Slice64.view slice)}
      (! return {result}) ]
end
module M_03_std_iterators__vec_iter
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.slice.Slice64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter = { t_Iter__ptr: t_NonNull'0; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 (_1: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_1: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = inv'1 (view self)
  
  predicate inv'2 (_1: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_Vec) = inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 (_1: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''2 x
  
  function view'0 (self: t_Iter) : Slice64.slice t_T
  
  let rec into_iter (self_: t_Vec) (return (x: t_Iter)) = {[@expl:into_iter 'self_' type invariant] inv'3 self_}
    any [ return (result: t_Iter) -> {view self_ = Slice64.view (view'0 result)} (! return {result}) ]
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view'0 self) = Seq.(++) visited (to_ref_seq (view'0 tl))
  
  function produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : () = ()
  
  axiom produces_trans_spec: forall a: t_Iter, ab: Seq.seq t_T, b: t_Iter, bc: Seq.seq t_T, c: t_Iter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Iter) : () = ()
  
  axiom produces_refl_spec: forall self: t_Iter. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv'4 (_1: t_Iter)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Iter [inv'4 x]. inv'4 x = true
  
  predicate invariant''3 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 (_1: t_T)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_T [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self: t_T) = inv'5 self
  
  predicate inv'6 (_1: t_T)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_T [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'6 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'7 (_1: Seq.seq t_T)
  
  axiom inv_axiom'6 [@rewrite]: forall x: Seq.seq t_T [inv'7 x]. inv'7 x = invariant''5 x
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv'8 (_1: t_Option)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Option [inv'8 x]. inv'8 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'5 a_0
        end
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Iter) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_Iter) =
    resolve self /\ Slice64.view (view'0 self.current) = (Seq.empty: Seq.seq t_T)
  
  let rec next (self_: MutBorrow.t t_Iter) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {inv'8 result}
      {match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Iter) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec vec_iter (vec: t_Vec) (return (x: UInt64.t)) = {[@expl:vec_iter 'vec' type invariant] inv'3 vec}
    {[@expl:vec_iter requires] Seq.length (view vec) < 1000}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &i <- (0: UInt64.t) ] s1 | s1 = into_iter {vec} (fun (_ret: t_Iter) -> [ &iter <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq t_T ] s1 | s1 = bb4 ]
    | bb4 = bb4
      [ bb4 = {[@expl:for invariant] inv'7 produced}
        {[@expl:for invariant] inv'4 iter}
        {[@expl:for invariant] produces iter_old produced iter}
        {[@expl:loop invariant] UInt64.t'int i = Seq.length produced}
        (! s0)
        [ s0 = bb5 ]
        [ bb5 = s0
          [ s0 = MutBorrow.borrow_mut <t_Iter> {iter}
              (fun (_ret: MutBorrow.t t_Iter) -> [ &_20 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Iter> {_20.current} {MutBorrow.get_id _20}
              (fun (_ret: MutBorrow.t t_Iter) -> [ &_19 <- _ret ] [ &_20 <- { _20 with current = _ret.final } ] s2)
          | s2 = next {_19} (fun (_ret: t_Option) -> [ &_18 <- _ret ] s3)
          | s3 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve'0 _20}- s1
          | s1 = any [ br0 -> {_18 = C_None} (! bb9) | br1 (x0: t_T) -> {_18 = C_Some x0} (! bb10) ] ]
        | bb10 = s0
          [ s0 = v_Some {_18} (fun (r0: t_T) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_23 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb11 ]
        | bb11 = s0
          [ s0 = [ &produced <- _23 ] s1
          | s1 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s2)
          | s2 = bb4 ] ] ]
    | bb9 = s0 [ s0 = [ &_0 <- i ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & vec: t_Vec = vec
    | & i: UInt64.t = Any.any_l ()
    | & iter: t_Iter = Any.any_l ()
    | & iter_old: t_Iter = Any.any_l ()
    | & produced: Seq.seq t_T = Any.any_l ()
    | & _18: t_Option = Any.any_l ()
    | & _19: MutBorrow.t t_Iter = Any.any_l ()
    | & _20: MutBorrow.t t_Iter = Any.any_l ()
    | & __creusot_proc_iter_elem: t_T = Any.any_l ()
    | & _23: Seq.seq t_T = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:vec_iter ensures] UInt64.t'int result = Seq.length (view vec)}
      (! return {result}) ]
end
module M_03_std_iterators__all_zero
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  let rec deref_mut (self_: MutBorrow.t t_Vec) (return (x: MutBorrow.t (Slice64.slice UInt64.t))) = any
    [ return (result: MutBorrow.t (Slice64.slice UInt64.t)) -> {Slice64.view result.current = view self_.current}
      {Slice64.view result.final = view self_.final}
      (! return {result}) ]
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut = { t_IterMut__ptr: t_NonNull'0; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  function view'0 (self: t_IterMut) : MutBorrow.t (Slice64.slice UInt64.t)
  
  axiom view_spec'0: forall self: t_IterMut. Seq.length (Slice64.view (view'0 self).final)
      = Seq.length (Slice64.view (view'0 self).current)
  
  let rec iter_mut (self_: MutBorrow.t (Slice64.slice UInt64.t)) (return (x: t_IterMut)) = any
    [ return (result: t_IterMut) -> {view'0 result = self_} (! return {result}) ]
  
  let rec into_iter (self_: t_IterMut) (return (x: t_IterMut)) = any
    [ return (result: t_IterMut) -> {result = self_} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt64.t)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice UInt64.t)) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  function index_logic [@inline:trivial] (self: Slice64.slice UInt64.t) (ix: int) : UInt64.t =
    Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_mut_seq (self: MutBorrow.t (Slice64.slice UInt64.t)) : Seq.seq (MutBorrow.t UInt64.t)
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice UInt64.t). Seq.length (to_mut_seq self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice UInt64.t). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq self)
        -> Seq.get (to_mut_seq self) i
        = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t UInt64.t)) (tl: t_IterMut) =
    to_mut_seq (view'0 self) = Seq.(++) visited (to_mut_seq (view'0 tl))
  
  function produces_trans (a: t_IterMut) (ab: Seq.seq (MutBorrow.t UInt64.t)) (b: t_IterMut) (bc: Seq.seq (MutBorrow.t UInt64.t)) (c: t_IterMut) : ()
   = ()
  
  axiom produces_trans_spec:
    forall a: t_IterMut, ab: Seq.seq (MutBorrow.t UInt64.t), b: t_IterMut, bc: Seq.seq (MutBorrow.t UInt64.t), c: t_IterMut. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IterMut) : () = ()
  
  axiom produces_refl_spec: forall self: t_IterMut. produces self (Seq.empty: Seq.seq (MutBorrow.t UInt64.t)) self
  
  predicate inv (_1: t_IterMut)
  
  axiom inv_axiom [@rewrite]: forall x: t_IterMut [inv x]. inv x = true
  
  predicate inv'0 (_1: Seq.seq (MutBorrow.t UInt64.t))
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq (MutBorrow.t UInt64.t) [inv'0 x]. inv'0 x = true
  
  type t_Option = C_None | C_Some (MutBorrow.t UInt64.t)
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_IterMut) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate completed (self: MutBorrow.t t_IterMut) =
    resolve'1 self /\ Slice64.view (view'0 self.current).current = (Seq.empty: Seq.seq UInt64.t)
  
  let rec next (self_: MutBorrow.t t_IterMut) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_IterMut) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  let rec v_Some (input: t_Option) (ret (field_0: MutBorrow.t UInt64.t)) = any
    [ good (field_0: MutBorrow.t UInt64.t) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t UInt64.t [C_Some field_0: t_Option]. C_Some field_0 <> input}
      (! {false}
      any) ]
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t UInt64.t) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t UInt64.t) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (self: t_IterMut) = (view'0 self).current = (view'0 self).final
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_1: t_IterMut) = resolve'5 _1
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (self: MutBorrow.t t_Vec) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_1: MutBorrow.t t_Vec) = resolve'7 _1
  
  meta "rewrite_def" predicate resolve'8
  
  function index_logic'0 [@inline:trivial] (self: t_Vec) (ix: int) : UInt64.t = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec all_zero (v: MutBorrow.t t_Vec) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_Vec> {v.current} {MutBorrow.get_id v}
          (fun (_ret: MutBorrow.t t_Vec) -> [ &_8 <- _ret ] [ &v <- { v with current = _ret.final } ] s1)
      | s1 = deref_mut {_8} (fun (_ret: MutBorrow.t (Slice64.slice UInt64.t)) -> [ &_7 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt64.t> {_7.current} {MutBorrow.get_id _7}
          (fun (_ret: MutBorrow.t (Slice64.slice UInt64.t)) ->
            [ &_6 <- _ret ] [ &_7 <- { _7 with current = _ret.final } ] s1)
      | s1 = iter_mut {_6} (fun (_ret: t_IterMut) -> [ &_5 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = into_iter {_5} (fun (_ret: t_IterMut) -> [ &iter <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = -{resolve'0 _7}- s1 | s1 = [ &iter_old <- iter ] s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq (MutBorrow.t UInt64.t) ] s1 | s1 = bb6 ]
    | bb6 = bb6
      [ bb6 = {[@expl:for invariant] inv'0 produced}
        {[@expl:for invariant] inv iter}
        {[@expl:for invariant] produces iter_old produced iter}
        {[@expl:loop invariant] forall i: int. 0 <= i /\ i < Seq.length produced
          -> UInt64.t'int (Seq.get produced i).final = 0}
        (! s0)
        [ s0 = bb7 ]
        [ bb7 = s0
          [ s0 = MutBorrow.borrow_mut <t_IterMut> {iter}
              (fun (_ret: MutBorrow.t t_IterMut) -> [ &_21 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_IterMut> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret: MutBorrow.t t_IterMut) -> [ &_20 <- _ret ] [ &_21 <- { _21 with current = _ret.final } ] s2)
          | s2 = next {_20} (fun (_ret: t_Option) -> [ &_19 <- _ret ] s3)
          | s3 = bb8 ]
        | bb8 = s0
          [ s0 = -{resolve'2 _21}- s1
          | s1 = any [ br0 -> {_19 = C_None} (! bb11) | br1 (x0: MutBorrow.t UInt64.t) -> {_19 = C_Some x0} (! bb12) ] ]
        | bb12 = s0
          [ s0 = v_Some {_19} (fun (r0: MutBorrow.t UInt64.t) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_24 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb13 ]
        | bb13 = s0
          [ s0 = [ &produced <- _24 ] s1
          | s1 = [ &x <- __creusot_proc_iter_elem ] s2
          | s2 = [ &x <- { x with current = (0: UInt64.t) } ] s3
          | s3 = -{resolve'4 x}- s4
          | s4 = bb6 ] ] ]
    | bb11 = s0 [ s0 = -{resolve'6 iter}- s1 | s1 = -{resolve'8 v}- s2 | s2 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & v: MutBorrow.t t_Vec = v
    | & iter: t_IterMut = Any.any_l ()
    | & _5: t_IterMut = Any.any_l ()
    | & _6: MutBorrow.t (Slice64.slice UInt64.t) = Any.any_l ()
    | & _7: MutBorrow.t (Slice64.slice UInt64.t) = Any.any_l ()
    | & _8: MutBorrow.t t_Vec = Any.any_l ()
    | & iter_old: t_IterMut = Any.any_l ()
    | & produced: Seq.seq (MutBorrow.t UInt64.t) = Any.any_l ()
    | & _19: t_Option = Any.any_l ()
    | & _20: MutBorrow.t t_IterMut = Any.any_l ()
    | & _21: MutBorrow.t t_IterMut = Any.any_l ()
    | & __creusot_proc_iter_elem: MutBorrow.t UInt64.t = Any.any_l ()
    | & _24: Seq.seq (MutBorrow.t UInt64.t) = Any.any_l ()
    | & x: MutBorrow.t UInt64.t = Any.any_l () ])
    [ return (result: ()) -> {[@expl:all_zero ensures #0] Seq.length (view v.final) = Seq.length (view v.current)}
      {[@expl:all_zero ensures #1] forall i: int. 0 <= i /\ i < Seq.length (view v.current)
        -> UInt64.t'int (index_logic'0 v.final i) = 0}
      (! return {result}) ]
end
module M_03_std_iterators__skip_take
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.prelude.Any
  
  type t_I
  
  type t_Take = { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type tuple = { f0: t_I; f1: UInt64.t }
  
  predicate inv (_1: t_I)
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = n} = args in inv self_)
      -> precondition () args
  
  predicate inv'0 (_1: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
      = match x with
        | {t_Take__iter = iter; t_Take__n = n} -> inv iter
        end
  
  function iter (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. inv'0 self -> inv (iter self)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. n self >= 0 /\ n self <= UInt64.t'int const_MAX
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Take)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Take [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = n'0} = args in iter res = self_ /\ n res = UInt64.t'int n'0 /\ inv'0 res)
  
  let rec take (self_: t_I) (n'0: UInt64.t) (return (x: t_Take)) = {[@expl:take requires] precondition () { f0 = self_;
                                                                                                            f1 = n'0 }}
    any [ return (result: t_Take) -> {postcondition_once () { f0 = self_; f1 = n'0 } result} (! return {result}) ]
  
  type t_Skip = { t_Skip__iter: t_Take; t_Skip__n: UInt64.t }
  
  predicate inv'1 (_1: t_Skip)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Skip [inv'1 x]. inv'1 x
      = match x with
        | {t_Skip__iter = iter'0; t_Skip__n = n'0} -> inv'0 iter'0
        end
  
  function iter'0 (self: t_Skip) : t_Take
  
  axiom iter_spec'0: forall self: t_Skip. inv'1 self -> inv'0 (iter'0 self)
  
  function n'0 (self: t_Skip) : int
  
  axiom n_spec'0: forall self: t_Skip. n'0 self >= 0 /\ n'0 self <= UInt64.t'int const_MAX
  
  let rec skip (self_: t_Take) (n'1: UInt64.t) (return (x: t_Skip)) = {[@expl:skip 'self_' type invariant] inv'0 self_}
    any
    [ return (result: t_Skip) -> {inv'1 result}
      {iter'0 result = self_ /\ n'0 result = UInt64.t'int n'1}
      (! return {result}) ]
  
  type t_Item
  
  type t_Option = C_None | C_Some t_Item
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_Skip) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 (_1: MutBorrow.t t_Skip)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Skip [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_1: t_Item)
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take) =
    n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  function produces_trans'0 (a: t_Take) (ab: Seq.seq t_Item) (b: t_Take) (bc: Seq.seq t_Item) (c: t_Take) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Take, ab: Seq.seq t_Item, b: t_Take, bc: Seq.seq t_Item, c: t_Take. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Take) : ()
  
  axiom produces_refl_spec'0: forall self: t_Take. produces'0 self (Seq.empty: Seq.seq t_Item) self
  
  predicate resolve (_1: t_Item)
  
  predicate produces'1 (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n'0 self
      /\ produces'0 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve (Seq.get s i)))
  
  function produces_trans'1 (a: t_Skip) (ab: Seq.seq t_Item) (b: t_Skip) (bc: Seq.seq t_Item) (c: t_Skip) : ()
  
  axiom produces_trans_spec'1:
    forall a: t_Skip, ab: Seq.seq t_Item, b: t_Skip, bc: Seq.seq t_Item, c: t_Skip. produces'1 a ab b
      -> produces'1 b bc c -> produces'1 a (Seq.(++) ab bc) c
  
  function produces_refl'1 (self: t_Skip) : ()
  
  axiom produces_refl_spec'1: forall self: t_Skip. produces'1 self (Seq.empty: Seq.seq t_Item) self
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Take) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_Take) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate completed (self: MutBorrow.t t_I)
  
  function iter_mut (self: MutBorrow.t t_Take) : MutBorrow.t t_I
  
  axiom iter_mut_spec: forall self: MutBorrow.t t_Take. iter self.current = (iter_mut self).current
      /\ iter self.final = (iter_mut self).final
  
  predicate completed'0 (self: MutBorrow.t t_Take) =
    n self.current = 0 /\ resolve'1 self
    \/ n self.current > 0 /\ n self.current = n self.final + 1 /\ completed (iter_mut self)
  
  predicate completed'1 (self: MutBorrow.t t_Skip) =
    n'0 self.final = 0
    /\ (exists s: Seq.seq t_Item, i: MutBorrow.t t_Take. Seq.length s <= n'0 self.current
      /\ produces'0 (iter'0 self.current) s i.current
      /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length s -> resolve (Seq.get s i'0))
      /\ completed'0 i /\ i.final = iter'0 self.final)
  
  let rec next (self_: MutBorrow.t t_Skip) (return (x: t_Option)) = {[@expl:next 'self_' type invariant] inv'2 self_}
    any
    [ return (result: t_Option) -> {inv'4 result}
      {match result with
        | C_None -> completed'1 self_
        | C_Some v -> produces'1 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'2 (_1: t_I)
  
  predicate resolve'3 [@inline:trivial] (self: t_Take) = resolve'2 (iter self)
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: t_Take) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (self: t_Skip) = resolve'4 (iter'0 self)
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_1: t_Skip) = resolve'5 _1
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (self: t_Option) =
    match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_1: t_Option) = resolve'7 _1
  
  meta "rewrite_def" predicate resolve'8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec skip_take (iter'1: t_I) (n'1: UInt64.t) (return (x: ())) =
    {[@expl:skip_take 'iter' type invariant] inv iter'1}
    (! bb0
    [ bb0 = s0 [ s0 = take {iter'1} {n'1} (fun (_ret: t_Take) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = skip {_6} {n'1} (fun (_ret: t_Skip) -> [ &_5 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv'1 _5}
        MutBorrow.borrow_mut <t_Skip> {_5}
          (fun (_ret: MutBorrow.t t_Skip) -> [ &_4 <- _ret ] -{inv'1 _ret.final}- [ &_5 <- _ret.final ] s1)
      | s1 = next {_4} (fun (_ret: t_Option) -> [ &res <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'1 _5} s1
      | s1 = -{resolve'6 _5}- s2
      | s2 = {[@expl:type invariant] inv'4 res} s3
      | s3 = -{resolve'8 res}- s4
      | s4 = bb4 ]
    | bb4 = s0 [ s0 = {[@expl:assertion] res = C_None} s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & iter'1: t_I = iter'1
    | & n'1: UInt64.t = n'1
    | & res: t_Option = Any.any_l ()
    | & _4: MutBorrow.t t_Skip = Any.any_l ()
    | & _5: t_Skip = Any.any_l ()
    | & _6: t_Take = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_03_std_iterators__counter
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.slice.Slice64
  use creusot.int.UInt32
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt32.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  let rec deref (self_: t_Vec) (return (x: Slice64.slice UInt32.t)) = any
    [ return (result: Slice64.slice UInt32.t) -> {Slice64.view result = view self_} (! return {result}) ]
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter = { t_Iter__ptr: t_NonNull'0; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  function view'0 (self: t_Iter) : Slice64.slice UInt32.t
  
  let rec iter (self_: Slice64.slice UInt32.t) (return (x: t_Iter)) = any
    [ return (result: t_Iter) -> {view'0 result = self_} (! return {result}) ]
  
  type closure0 = { c0: MutBorrow.t UInt64.t }
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t closure0) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t closure0) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  type tuple = { f0: UInt32.t; f1: Seq.seq UInt32.t }
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t UInt64.t) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t UInt64.t) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: closure0) = resolve'2 _1.c0
  
  meta "rewrite_def" predicate resolve'3
  
  predicate hist_inv [@inline:trivial] (self: closure0) (result_state: closure0) = result_state.c0.final = self.c0.final
  
  meta "rewrite_def" predicate hist_inv
  
  let rec closure0 [@coma:extspec] (self: MutBorrow.t closure0) (x: UInt32.t) (_prod: Seq.seq UInt32.t)
    (return (x'0: UInt32.t)) = bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] UInt64.t'int self.current.c0.current = Seq.length _prod} s1
      | s1 = UInt64.add {self.current.c0.current} {(1: UInt64.t)}
          (fun (_ret: UInt64.t) ->
            [ &self <- { self with current = { c0 = { self.current.c0 with current = _ret } } } ] s2)
      | s2 = -{resolve'0 self}- s3
      | s3 = [ &_0 <- x ] s4
      | s4 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l ()
    | & self: MutBorrow.t closure0 = self
    | & x: UInt32.t = x
    | & _prod: Seq.seq UInt32.t = _prod ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate postcondition_once [@inline:trivial] (self: closure0) (args: tuple) (result: UInt32.t) =
    let {f0 = x; f1 = _prod} = args in exists e: closure0. (exists bor_self: MutBorrow.t closure0. bor_self.current
            = self
          /\ bor_self.final = e /\ closure0'post'return bor_self x _prod result /\ hist_inv self e)
      /\ resolve'3 e
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate postcondition_mut [@inline:trivial] (self: closure0) (args: tuple) (result_state: closure0) (result: UInt32.t) =
    let {f0 = x; f1 = _prod} = args in exists bor_self: MutBorrow.t closure0. bor_self.current = self
      /\ bor_self.final = result_state /\ closure0'post'return bor_self x _prod result /\ hist_inv self result_state
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: closure0) (args: tuple) (res: UInt32.t) : ()
  
  axiom fn_mut_once_spec: forall self: closure0, args: tuple, res: UInt32.t. postcondition_once self args res
      = (exists res_state: closure0. postcondition_mut self args res_state res /\ resolve'3 res_state)
  
  function hist_inv_trans (self: closure0) (b: closure0) (c: closure0) : ()
  
  axiom hist_inv_trans_spec: forall self: closure0, b: closure0, c: closure0. hist_inv self b
      -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: closure0) : ()
  
  axiom hist_inv_refl_spec: forall self: closure0. hist_inv self self
  
  function postcondition_mut_hist_inv (self: closure0) (args: tuple) (res_state: closure0) (res: UInt32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: closure0, args: tuple, res_state: closure0, res: UInt32.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function index_logic [@inline:trivial] (self: Slice64.slice UInt32.t) (ix: int) : UInt32.t =
    Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice UInt32.t) : Seq.seq UInt32.t
  
  axiom to_ref_seq_spec: forall self: Slice64.slice UInt32.t. Seq.length (to_ref_seq self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice UInt32.t. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq self) -> Seq.get (to_ref_seq self) i = index_logic self i
  
  predicate produces (self: t_Iter) (visited: Seq.seq UInt32.t) (tl: t_Iter) =
    to_ref_seq (view'0 self) = Seq.(++) visited (to_ref_seq (view'0 tl))
  
  function produces_trans (a: t_Iter) (ab: Seq.seq UInt32.t) (b: t_Iter) (bc: Seq.seq UInt32.t) (c: t_Iter) : () = ()
  
  axiom produces_trans_spec:
    forall a: t_Iter, ab: Seq.seq UInt32.t, b: t_Iter, bc: Seq.seq UInt32.t, c: t_Iter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Iter) : () = ()
  
  axiom produces_refl_spec: forall self: t_Iter. produces self (Seq.empty: Seq.seq UInt32.t) self
  
  function produces_trans'0 (a: t_Iter) (ab: Seq.seq UInt32.t) (b: t_Iter) (bc: Seq.seq UInt32.t) (c: t_Iter) : () = ()
  
  axiom produces_trans_spec'0:
    forall a: t_Iter, ab: Seq.seq UInt32.t, b: t_Iter, bc: Seq.seq UInt32.t, c: t_Iter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Iter) : () = ()
  
  axiom produces_refl_spec'0: forall self: t_Iter. produces self (Seq.empty: Seq.seq UInt32.t) self
  
  type t_MapInv = { t_MapInv__iter: t_Iter; t_MapInv__func: closure0; t_MapInv__produced: Seq.seq UInt32.t }
  
  predicate precondition [@inline:trivial] (self: closure0) (args: tuple) =
    let {f0 = x; f1 = _prod} = args in forall bor_self: MutBorrow.t closure0. bor_self.current = self
      -> closure0'pre bor_self x _prod
  
  meta "rewrite_def" predicate precondition
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_Iter) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate completed (self: MutBorrow.t t_Iter) =
    resolve'4 self /\ Slice64.view (view'0 self.current) = (Seq.empty: Seq.seq UInt32.t)
  
  predicate next_precondition (iter'0: t_Iter) (func: closure0) (produced: Seq.seq UInt32.t) =
    forall e: UInt32.t, i: t_Iter. produces iter'0 (Seq.singleton e) i -> precondition func { f0 = e; f1 = produced }
  
  predicate preservation (iter'0: t_Iter) (func: closure0) =
    forall s: Seq.seq UInt32.t, e1: UInt32.t, e2: UInt32.t, f: MutBorrow.t closure0, b: UInt32.t, i: t_Iter. hist_inv func f.current
      -> produces iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current { f0 = e1; f1 = s }
      -> postcondition_mut f.current { f0 = e1; f1 = s } f.final b
      -> precondition f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize =
    forall iter'0: MutBorrow.t t_Iter, func: closure0. completed iter'0
      -> next_precondition iter'0.final func (Seq.empty: Seq.seq UInt32.t) /\ preservation iter'0.final func
  
  predicate preservation_inv (iter'0: t_Iter) (func: closure0) (produced: Seq.seq UInt32.t)
  
  axiom preservation_inv_spec: forall iter'0: t_Iter, func: closure0, produced: Seq.seq UInt32.t. produced
        = (Seq.empty: Seq.seq UInt32.t) -> preservation_inv iter'0 func produced = preservation iter'0 func
  
  predicate invariant' (self: t_MapInv) =
    reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  predicate inv (_1: t_MapInv)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_MapInv__iter = iter'0; t_MapInv__func = func; t_MapInv__produced = produced} -> true
        end)
  
  let rec map_inv (self: t_Iter) (func: closure0) (return (x: t_MapInv)) =
    {[@expl:map_inv requires #0] forall e: UInt32.t, i2: t_Iter. produces self (Seq.singleton e) i2
      -> precondition func { f0 = e; f1 = Seq.empty: Seq.seq UInt32.t }}
    {[@expl:map_inv requires #1] reinitialize}
    {[@expl:map_inv requires #2] preservation self func}
    any
    [ return (result: t_MapInv) -> {inv result}
      {result = { t_MapInv__iter = self; t_MapInv__func = func; t_MapInv__produced = Seq.empty: Seq.seq UInt32.t }}
      (! return {result}) ]
  
  predicate resolve'5 [@inline:trivial] (_1: t_Iter) = true
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (self: t_MapInv) =
    resolve'5 self.t_MapInv__iter /\ resolve'3 self.t_MapInv__func
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: t_MapInv) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq UInt32.t) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t closure0). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq UInt32.t. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current { f0 = Seq.get s i;
                                                   f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  function produces_trans'1 (a: t_MapInv) (ab: Seq.seq UInt32.t) (b: t_MapInv) (bc: Seq.seq UInt32.t) (c: t_MapInv) : ()
  
  axiom produces_trans_spec'1:
    forall a: t_MapInv, ab: Seq.seq UInt32.t, b: t_MapInv, bc: Seq.seq UInt32.t, c: t_MapInv. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'1 (self: t_MapInv) : ()
  
  axiom produces_refl_spec'1: forall self: t_MapInv. produces'0 self (Seq.empty: Seq.seq UInt32.t) self
  
  predicate completed'0 (self: MutBorrow.t t_MapInv) =
    self.final.t_MapInv__produced = (Seq.empty: Seq.seq UInt32.t)
    /\ completed (MutBorrow.borrow_logic self.current.t_MapInv__iter self.final.t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ self.current.t_MapInv__func = self.final.t_MapInv__func
  
  predicate from_iter_post (prod: Seq.seq UInt32.t) (res: t_Vec) = prod = view res
  
  let rec collect (self_: t_MapInv) (return (x: t_Vec)) = {[@expl:collect 'self_' type invariant] inv self_}
    any
    [ return (result: t_Vec) -> {exists done': MutBorrow.t t_MapInv, prod: Seq.seq UInt32.t. resolve'7 done'.final
        /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec counter (v: t_Vec) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &cnt <- (0: UInt64.t) ] s1
      | s1 = deref {v} (fun (_ret: Slice64.slice UInt32.t) -> [ &_7 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = iter {_7} (fun (_ret: t_Iter) -> [ &_5 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = MutBorrow.borrow_mut <UInt64.t> {cnt}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &_10 <- _ret ] [ &cnt <- _ret.final ] s1)
      | s1 = [ &_9 <- { c0 = _10 } ] s2
      | s2 = map_inv {_5} {_9} (fun (_ret: t_MapInv) -> [ &_4 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0 [ s0 = collect {_4} (fun (_ret: t_Vec) -> [ &x <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:assertion] Seq.length (view x) = Seq.length (view v)} s1
      | s1 = {[@expl:assertion] Seq.(==) (view x) (view v)} s2
      | s2 = {[@expl:assertion] UInt64.t'int cnt = Seq.length (view x)} s3
      | s3 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & v: t_Vec = v
    | & cnt: UInt64.t = Any.any_l ()
    | & x: t_Vec = Any.any_l ()
    | & _4: t_MapInv = Any.any_l ()
    | & _5: t_Iter = Any.any_l ()
    | & _7: Slice64.slice UInt32.t = Any.any_l ()
    | & _9: closure0 = Any.any_l ()
    | & _10: MutBorrow.t UInt64.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_03_std_iterators__sum_range
  use creusot.int.Int64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Range = { t_Range__start: Int64.t; t_Range__end: Int64.t }
  
  let rec into_iter (self_: t_Range) (return (x: t_Range)) = any
    [ return (result: t_Range) -> {result = self_} (! return {result}) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int64.t) : ()
  
  axiom refl_spec: forall x: Int64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  predicate produces (self: t_Range) (visited: Seq.seq Int64.t) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  function produces_trans (a: t_Range) (ab: Seq.seq Int64.t) (b: t_Range) (bc: Seq.seq Int64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec:
    forall a: t_Range, ab: Seq.seq Int64.t, b: t_Range, bc: Seq.seq Int64.t, c: t_Range. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Range) : ()
  
  axiom produces_refl_spec: forall self: t_Range. produces self (Seq.empty: Seq.seq Int64.t) self
  
  predicate inv (_1: t_Range)
  
  axiom inv_axiom [@rewrite]: forall x: t_Range [inv x]. inv x = true
  
  predicate inv'0 (_1: Seq.seq Int64.t)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq Int64.t [inv'0 x]. inv'0 x = true
  
  type t_Option = C_None | C_Some Int64.t
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Range) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_Range) =
    resolve self /\ deep_model self.current.t_Range__start >= deep_model self.current.t_Range__end
  
  let rec next (self_: MutBorrow.t t_Range) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Range) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: Int64.t)) = any
    [ good (field_0: Int64.t) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: Int64.t [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec sum_range (n: Int64.t) (return (x: Int64.t)) = {[@expl:sum_range requires] Int64.to_int n >= 0}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &i <- (0: Int64.t) ] s1
      | s1 = [ &_7 <- { t_Range__start = (0: Int64.t); t_Range__end = n } ] s2
      | s2 = into_iter {_7} (fun (_ret: t_Range) -> [ &iter <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq Int64.t ] s1 | s1 = bb4 ]
    | bb4 = bb4
      [ bb4 = {[@expl:for invariant] inv'0 produced}
        {[@expl:for invariant] inv iter}
        {[@expl:for invariant] produces iter_old produced iter}
        {[@expl:loop invariant] Int64.to_int i = Seq.length produced /\ Int64.le i n}
        (! s0)
        [ s0 = bb5 ]
        [ bb5 = s0
          [ s0 = MutBorrow.borrow_mut <t_Range> {iter}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_21 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Range> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_20 <- _ret ] [ &_21 <- { _21 with current = _ret.final } ] s2)
          | s2 = next {_20} (fun (_ret: t_Option) -> [ &_19 <- _ret ] s3)
          | s3 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve'0 _21}- s1
          | s1 = any [ br0 -> {_19 = C_None} (! bb9) | br1 (x0: Int64.t) -> {_19 = C_Some x0} (! bb10) ] ]
        | bb10 = s0
          [ s0 = v_Some {_19} (fun (r0: Int64.t) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_24 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb11 ]
        | bb11 = s0
          [ s0 = [ &produced <- _24 ] s1
          | s1 = Int64.add {i} {(1: Int64.t)} (fun (_ret: Int64.t) -> [ &i <- _ret ] s2)
          | s2 = bb4 ] ] ]
    | bb9 = s0 [ s0 = [ &_0 <- i ] s1 | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l ()
    | & n: Int64.t = n
    | & i: Int64.t = Any.any_l ()
    | & iter: t_Range = Any.any_l ()
    | & _7: t_Range = Any.any_l ()
    | & iter_old: t_Range = Any.any_l ()
    | & produced: Seq.seq Int64.t = Any.any_l ()
    | & _19: t_Option = Any.any_l ()
    | & _20: MutBorrow.t t_Range = Any.any_l ()
    | & _21: MutBorrow.t t_Range = Any.any_l ()
    | & __creusot_proc_iter_elem: Int64.t = Any.any_l ()
    | & _24: Seq.seq Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:sum_range ensures] result = n} (! return {result}) ]
end
module M_03_std_iterators__enumerate_range
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Range = { t_Range__start: UInt64.t; t_Range__end: UInt64.t }
  
  type t_Enumerate = { t_Enumerate__iter: t_Range; t_Enumerate__count: UInt64.t }
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  predicate produces (self: t_Range) (visited: Seq.seq UInt64.t) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  function produces_trans (a: t_Range) (ab: Seq.seq UInt64.t) (b: t_Range) (bc: Seq.seq UInt64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec:
    forall a: t_Range, ab: Seq.seq UInt64.t, b: t_Range, bc: Seq.seq UInt64.t, c: t_Range. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Range) : ()
  
  axiom produces_refl_spec: forall self: t_Range. produces self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Range) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_Range) =
    resolve self /\ deep_model self.current.t_Range__start >= deep_model self.current.t_Range__end
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant' (self: t_Enumerate)
  
  predicate inv (_1: t_Enumerate)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Enumerate__iter = iter; t_Enumerate__count = count} -> true
        end)
  
  predicate inv'0 (_1: t_Range)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Range [inv'0 x]. inv'0 x = true
  
  function iter (self: t_Enumerate) : t_Range
  
  axiom iter_spec: forall self: t_Enumerate. inv self -> inv'0 (iter self)
  
  function n (self: t_Enumerate) : int
  
  let rec enumerate (self_: t_Range) (return (x: t_Enumerate)) =
    {[@expl:enumerate requires #0] forall i: MutBorrow.t t_Range. completed i
      -> produces i.current (Seq.empty: Seq.seq UInt64.t) i.final}
    {[@expl:enumerate requires #1] forall s: Seq.seq UInt64.t, i: t_Range. produces self_ s i
      -> Seq.length s < UInt64.t'int const_MAX}
    any [ return (result: t_Enumerate) -> {inv result} {iter result = self_ /\ n result = 0} (! return {result}) ]
  
  let rec into_iter (self_: t_Enumerate) (return (x: t_Enumerate)) =
    {[@expl:into_iter 'self_' type invariant] inv self_}
    any [ return (result: t_Enumerate) -> {inv result} {result = self_} (! return {result}) ]
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  predicate produces'0 (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate) =
    Seq.length visited = n o - n self
    /\ (exists s: Seq.seq UInt64.t. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = n self + i /\ (Seq.get visited i).f1 = Seq.get s i))
  
  function produces_trans'0 (a: t_Enumerate) (ab: Seq.seq tuple) (b: t_Enumerate) (bc: Seq.seq tuple) (c: t_Enumerate) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Enumerate, ab: Seq.seq tuple, b: t_Enumerate, bc: Seq.seq tuple, c: t_Enumerate. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Enumerate) : ()
  
  axiom produces_refl_spec'0: forall self: t_Enumerate. produces'0 self (Seq.empty: Seq.seq tuple) self
  
  predicate inv'1 (_1: Seq.seq tuple)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq tuple [inv'1 x]. inv'1 x = true
  
  type t_Option = C_None | C_Some tuple
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Enumerate) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: MutBorrow.t t_Enumerate)
  
  axiom inv_axiom'2 [@rewrite]: forall x: MutBorrow.t t_Enumerate [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate completed'0 (self: MutBorrow.t t_Enumerate) =
    exists inner: MutBorrow.t t_Range. inner.current = iter self.current
      /\ inner.final = iter self.final /\ completed inner /\ n self.current = n self.final
  
  let rec next (self_: MutBorrow.t t_Enumerate) (return (x: t_Option)) =
    {[@expl:next 'self_' type invariant] inv'2 self_}
    any
    [ return (result: t_Option) -> {match result with
        | C_None -> completed'0 self_
        | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Enumerate) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_Enumerate) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  let rec v_Some (input: t_Option) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec enumerate_range (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_3 <- { t_Range__start = (0: UInt64.t); t_Range__end = (10: UInt64.t) } ] s1
      | s1 = enumerate {_3} (fun (_ret: t_Enumerate) -> [ &_2 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = into_iter {_2} (fun (_ret: t_Enumerate) -> [ &iter'0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &iter_old <- iter'0 ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq tuple ] s1 | s1 = bb5 ]
    | bb5 = bb5
      [ bb5 = {[@expl:for invariant] inv'1 produced}
        {[@expl:for invariant] inv iter'0}
        {[@expl:for invariant] produces'0 iter_old produced iter'0}
        {[@expl:loop invariant] forall i: int. 0 <= i /\ i < Seq.length produced
          -> (Seq.get produced i).f0 = (Seq.get produced i).f1}
        (! s0)
        [ s0 = bb6 ]
        [ bb6 = s0
          [ s0 = {inv iter'0}
            MutBorrow.borrow_mut <t_Enumerate> {iter'0}
              (fun (_ret: MutBorrow.t t_Enumerate) -> [ &_16 <- _ret ] -{inv _ret.final}- [ &iter'0 <- _ret.final ] s1)
          | s1 = {inv _16.current}
            MutBorrow.borrow_final <t_Enumerate> {_16.current} {MutBorrow.get_id _16}
              (fun (_ret: MutBorrow.t t_Enumerate) ->
                [ &_15 <- _ret ] -{inv _ret.final}-
                [ &_16 <- { _16 with current = _ret.final } ] s2)
          | s2 = next {_15} (fun (_ret: t_Option) -> [ &_14 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = {[@expl:type invariant] inv'2 _16} s1
          | s1 = -{resolve'1 _16}- s2
          | s2 = any [ br0 -> {_14 = C_None} (! bb10) | br1 (x0: tuple) -> {_14 = C_Some x0} (! bb11) ] ]
        | bb11 = s0
          [ s0 = v_Some {_14} (fun (r0: tuple) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_19 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb12 ]
        | bb12 = s0
          [ s0 = [ &produced <- _19 ] s1
          | s1 = [ &ix <- __creusot_proc_iter_elem.f0 ] s2
          | s2 = [ &x <- __creusot_proc_iter_elem.f1 ] s3
          | s3 = bb5 ] ] ]
    | bb10 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & iter'0: t_Enumerate = Any.any_l ()
    | & _2: t_Enumerate = Any.any_l ()
    | & _3: t_Range = Any.any_l ()
    | & iter_old: t_Enumerate = Any.any_l ()
    | & produced: Seq.seq tuple = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_Enumerate = Any.any_l ()
    | & _16: MutBorrow.t t_Enumerate = Any.any_l ()
    | & __creusot_proc_iter_elem: tuple = Any.any_l ()
    | & _19: Seq.seq tuple = Any.any_l ()
    | & ix: UInt64.t = Any.any_l ()
    | & x: UInt64.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_03_std_iterators__my_reverse
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use seq.Permut
  use creusot.prelude.Any
  use seq.Reverse
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 (_1: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_1: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 (self: Slice64.slice t_T) = inv'1 (Slice64.view self)
  
  predicate inv'2 (_1: Slice64.slice t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Slice64.slice t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: Slice64.slice t_T) = inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 (_1: Slice64.slice t_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Slice64.slice t_T [inv'3 x]. inv'3 x = invariant''2 x
  
  let rec len (self_: Slice64.slice t_T) (return (x: UInt64.t)) = {[@expl:len 'self_' type invariant] inv'3 self_}
    any [ return (result: UInt64.t) -> {Seq.length (Slice64.view self_) = UInt64.t'int result} (! return {result}) ]
  
  type t_Range = { t_Range__start: UInt64.t; t_Range__end: UInt64.t }
  
  type t_Zip = { t_Zip__a: t_Range; t_Zip__b: t_Range; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t }
  
  predicate precondition [@inline:trivial] (self: ()) (args: t_Range) = let self_ = args in true
  
  meta "rewrite_def" predicate precondition
  
  let rec into_iter (self_: t_Range) (return (x: t_Range)) = any
    [ return (result: t_Range) -> {result = self_} (! return {result}) ]
  
  predicate inv'4 (_1: t_Zip)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Zip [inv'4 x]. inv'4 x = true
  
  predicate inv'5 (_1: t_Range)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Range [inv'5 x]. inv'5 x = true
  
  function itera (self: t_Zip) : t_Range
  
  axiom itera_spec: forall self: t_Zip. inv'4 self -> inv'5 (itera self)
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: t_Range) (result: t_Range) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: t_Range) (result_state: ()) (result: t_Range) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: t_Range) (res: t_Range) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_Range, res: t_Range. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Range) (res_state: ()) (res: t_Range) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Range, res_state: (), res: t_Range. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: t_Range) (result: t_Range) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: t_Range) (res: t_Range) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Range, res: t_Range. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_Range) (res_state: ()) (res: t_Range) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Range, res_state: (), res: t_Range. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  function iterb (self: t_Zip) : t_Range
  
  axiom iterb_spec: forall self: t_Zip. inv'4 self -> inv'5 (iterb self)
  
  let rec zip (self_: t_Range) (other: t_Range) (return (x: t_Zip)) = {[@expl:zip requires] precondition () other}
    any [ return (result: t_Zip) -> {itera result = self_} {postcondition () other (iterb result)} (! return {result}) ]
  
  let rec into_iter'0 (self_: t_Zip) (return (x: t_Zip)) = any
    [ return (result: t_Zip) -> {result = self_} (! return {result}) ]
  
  type tuple = { f0: UInt64.t; f1: UInt64.t }
  
  predicate equiv_reverse_range (s1: Seq.seq t_T) (s2: Seq.seq t_T) (l: int) (u: int) (n: int) =
    forall i: int. l <= i /\ i < u -> Seq.get s1 i = Seq.get s2 (n - i)
  
  predicate equiv_range (s1: Seq.seq t_T) (s2: Seq.seq t_T) (l: int) (u: int) =
    forall i: int. l <= i /\ i < u -> Seq.get s1 i = Seq.get s2 i
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  predicate produces (self: t_Range) (visited: Seq.seq UInt64.t) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  function produces_trans (a: t_Range) (ab: Seq.seq UInt64.t) (b: t_Range) (bc: Seq.seq UInt64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec:
    forall a: t_Range, ab: Seq.seq UInt64.t, b: t_Range, bc: Seq.seq UInt64.t, c: t_Range. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Range) : ()
  
  axiom produces_refl_spec: forall self: t_Range. produces self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate produces'0 (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip) =
    exists p1: Seq.seq UInt64.t, p2: Seq.seq UInt64.t. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces (itera self) p1 (itera o) /\ produces (iterb self) p2 (iterb o)
  
  function produces_trans'0 (a: t_Zip) (ab: Seq.seq tuple) (b: t_Zip) (bc: Seq.seq tuple) (c: t_Zip) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Zip, ab: Seq.seq tuple, b: t_Zip, bc: Seq.seq tuple, c: t_Zip. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Zip) : ()
  
  axiom produces_refl_spec'0: forall self: t_Zip. produces'0 self (Seq.empty: Seq.seq tuple) self
  
  predicate inv'6 (_1: Seq.seq tuple)
  
  axiom inv_axiom'5 [@rewrite]: forall x: Seq.seq tuple [inv'6 x]. inv'6 x = true
  
  type t_Option = C_None | C_Some tuple
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Range) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate completed (self: MutBorrow.t t_Range) =
    resolve'0 self /\ deep_model self.current.t_Range__start >= deep_model self.current.t_Range__end
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_Range) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate inv'7 (_1: UInt64.t)
  
  axiom inv_axiom'6 [@rewrite]: forall x: UInt64.t [inv'7 x]. inv'7 x = true
  
  predicate resolve'2 [@inline:trivial] (_1: UInt64.t) = true
  
  meta "rewrite_def" predicate resolve'2
  
  predicate completed'0 (self: MutBorrow.t t_Zip) =
    exists a: MutBorrow.t t_Range, b: MutBorrow.t t_Range. a.current = itera self.current
      /\ b.current = iterb self.current
      /\ a.final = itera self.final
      /\ b.final = iterb self.final
      /\ (completed a /\ resolve'1 b
      \/ (exists x: UInt64.t. inv'7 x /\ produces a.current (Seq.singleton x) a.final /\ resolve'2 x /\ completed b))
  
  let rec next (self_: MutBorrow.t t_Zip) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {match result with
        | C_None -> completed'0 self_
        | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Zip) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Zip) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  let rec v_Some (input: t_Option) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: MutBorrow.t (Slice64.slice t_T))
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t (Slice64.slice t_T) [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec swap (self_: MutBorrow.t (Slice64.slice t_T)) (i: UInt64.t) (j: UInt64.t) (return (x: ())) =
    {[@expl:swap 'self_' type invariant] inv'8 self_}
    {[@expl:swap requires #0] UInt64.t'int i < Seq.length (Slice64.view self_.current)}
    {[@expl:swap requires #1] UInt64.t'int j < Seq.length (Slice64.view self_.current)}
    any
    [ return (result: ()) ->
    {Permut.exchange (Slice64.view self_.final) (Slice64.view self_.current) (UInt64.t'int i) (UInt64.t'int j)}
      (! return {result}) ]
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = resolve'5 _1
  
  meta "rewrite_def" predicate resolve'6
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec my_reverse (slice: MutBorrow.t (Slice64.slice t_T)) (return (x: ())) =
    {[@expl:my_reverse 'slice' type invariant] inv'8 slice}
    (! bb0
    [ bb0 = s0 [ s0 = len {slice.current} (fun (_ret: UInt64.t) -> [ &n <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &old_v <- Slice64.view slice.current ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_12 <- (2: UInt64.t) = (0: UInt64.t) ] s1 | s1 = {[@expl:division by zero] not _12} s2 | s2 = bb3 ]
    | bb3 = s0
      [ s0 = UInt64.div {n} {(2: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_10 <- _ret ] s1)
      | s1 = [ &_9 <- { t_Range__start = (0: UInt64.t); t_Range__end = _10 } ] s2
      | s2 = [ &_16 <- (2: UInt64.t) = (0: UInt64.t) ] s3
      | s3 = {[@expl:division by zero] not _16} s4
      | s4 = bb4 ]
    | bb4 = s0
      [ s0 = UInt64.div {n} {(2: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s1)
      | s1 = [ &_13 <- { t_Range__start = (0: UInt64.t); t_Range__end = _14 } ] s2
      | s2 = zip {_9} {_13} (fun (_ret: t_Zip) -> [ &_8 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = into_iter'0 {_8} (fun (_ret: t_Zip) -> [ &iter <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb7 ]
    | bb7 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq tuple ] s1 | s1 = bb8 ]
    | bb8 = s0 [ s0 = [ &old_9_0 <- slice ] s1 | s1 = bb9 ]
    | bb9 = bb9
      [ bb9 = {[@expl:mut invariant] old_9_0.final = slice.final}
        {[@expl:for invariant] inv'6 produced}
        {[@expl:for invariant] inv'4 iter}
        {[@expl:for invariant] produces'0 iter_old produced iter}
        {[@expl:loop invariant #0] UInt64.t'int n = Seq.length (Slice64.view slice.current)}
        {[@expl:loop invariant #1] equiv_range (Slice64.view slice.current) old_v (Seq.length produced) (UInt64.t'int n
        - Seq.length produced)}
        {[@expl:loop invariant #2] equiv_reverse_range (Slice64.view slice.current) old_v 0 (Seq.length produced) (UInt64.t'int n
        - 1)}
        {[@expl:loop invariant #3] equiv_reverse_range (Slice64.view slice.current) old_v (UInt64.t'int n
        - Seq.length produced) (UInt64.t'int n) (UInt64.t'int n - 1)}
        (! s0)
        [ s0 = bb10 ]
        [ bb10 = s0
          [ s0 = MutBorrow.borrow_mut <t_Zip> {iter}
              (fun (_ret: MutBorrow.t t_Zip) -> [ &_32 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Zip> {_32.current} {MutBorrow.get_id _32}
              (fun (_ret: MutBorrow.t t_Zip) -> [ &_31 <- _ret ] [ &_32 <- { _32 with current = _ret.final } ] s2)
          | s2 = next {_31} (fun (_ret: t_Option) -> [ &_30 <- _ret ] s3)
          | s3 = bb11 ]
        | bb11 = s0
          [ s0 = -{resolve'4 _32}- s1
          | s1 = any [ br0 -> {_30 = C_None} (! bb14) | br1 (x0: tuple) -> {_30 = C_Some x0} (! bb15) ] ]
        | bb15 = s0
          [ s0 = v_Some {_30} (fun (r0: tuple) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_35 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb16 ]
        | bb16 = s0
          [ s0 = [ &produced <- _35 ] s1
          | s1 = [ &i <- __creusot_proc_iter_elem.f0 ] s2
          | s2 = [ &j <- __creusot_proc_iter_elem.f1 ] s3
          | s3 = UInt64.sub {n} {j} (fun (_ret: UInt64.t) -> [ &_43 <- _ret ] s4)
          | s4 = UInt64.sub {_43} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_42 <- _ret ] s5)
          | s5 = {inv'2 slice.current}
            MutBorrow.borrow_mut <Slice64.slice t_T> {slice.current}
              (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
                [ &_40 <- _ret ] -{inv'2 _ret.final}-
                [ &slice <- { slice with current = _ret.final } ] s6)
          | s6 = swap {_40} {i} {_42} (fun (_ret: ()) -> [ &_39 <- _ret ] s7)
          | s7 = bb17 ]
        | bb17 = s0
          [ s0 = {[@expl:assertion] i = j} s1
          | s1 = {[@expl:assertion] Seq.get (Slice64.view slice.current) (UInt64.t'int i)
            = Seq.get old_v (UInt64.t'int n - UInt64.t'int j - 1)}
            s2
          | s2 = {[@expl:assertion] Seq.get (Slice64.view slice.current) (UInt64.t'int n - UInt64.t'int j - 1)
            = Seq.get old_v (UInt64.t'int i)}
            s3
          | s3 = bb9 ] ] ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'8 slice} s1 | s1 = -{resolve'6 slice}- s2 | s2 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & slice: MutBorrow.t (Slice64.slice t_T) = slice
    | & n: UInt64.t = Any.any_l ()
    | & old_v: Seq.seq t_T = Any.any_l ()
    | & iter: t_Zip = Any.any_l ()
    | & _8: t_Zip = Any.any_l ()
    | & _9: t_Range = Any.any_l ()
    | & _10: UInt64.t = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: t_Range = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & iter_old: t_Zip = Any.any_l ()
    | & produced: Seq.seq tuple = Any.any_l ()
    | & _30: t_Option = Any.any_l ()
    | & _31: MutBorrow.t t_Zip = Any.any_l ()
    | & _32: MutBorrow.t t_Zip = Any.any_l ()
    | & __creusot_proc_iter_elem: tuple = Any.any_l ()
    | & _35: Seq.seq tuple = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & j: UInt64.t = Any.any_l ()
    | & _39: () = Any.any_l ()
    | & _40: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _42: UInt64.t = Any.any_l ()
    | & _43: UInt64.t = Any.any_l ()
    | & old_9_0: MutBorrow.t (Slice64.slice t_T) = Any.any_l () ])
    [ return (result: ()) ->
    {[@expl:my_reverse ensures] Seq.(==) (Slice64.view slice.final) (Reverse.reverse (Slice64.view slice.current))}
      (! return {result}) ]
end
