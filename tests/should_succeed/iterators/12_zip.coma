module M_impl_Iterator_for_Zip_A_B__produces_refl (* <Zip<A, B> as common::Iterator> *)
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip_A_B = { a: t_A; b: t_B }
  
  type t_Item
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a'0: t_A) (ab: Seq.seq t_Item) (b'0: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec:
    forall a'0: t_A, ab: Seq.seq t_Item, b'0: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a'0 ab b'0
      -> produces_A b'0 bc c -> produces_A a'0 (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  type t_Item'0
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a'0: t_B) (ab: Seq.seq t_Item'0) (b'0: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a'0: t_B, ab: Seq.seq t_Item'0, b'0: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a'0 ab b'0
      -> produces_B b'0 bc c -> produces_B a'0 (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (tl: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A self.a p1 tl.a /\ produces_B self.b p2 tl.b
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Zip_A_B
  
  function produces_refl_Zip_A_B (self: t_Zip_A_B) : ()
  
  goal vc_produces_refl_Zip_A_B:
    [@expl:produces_refl ensures] produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
end
module M_impl_Iterator_for_Zip_A_B__produces_trans (* <Zip<A, B> as common::Iterator> *)
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip_A_B = { a: t_A; b: t_B }
  
  type t_Item
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a'0: t_A) (ab: Seq.seq t_Item) (b'0: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec:
    forall a'0: t_A, ab: Seq.seq t_Item, b'0: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a'0 ab b'0
      -> produces_A b'0 bc c -> produces_A a'0 (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  type t_Item'0
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a'0: t_B) (ab: Seq.seq t_Item'0) (b'0: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a'0: t_B, ab: Seq.seq t_Item'0, b'0: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a'0 ab b'0
      -> produces_B b'0 bc c -> produces_B a'0 (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (tl: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A self.a p1 tl.a /\ produces_B self.b p2 tl.b
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a'0 : t_Zip_A_B
  
  constant ab : Seq.seq tup2_Item_Item
  
  constant b'0 : t_Zip_A_B
  
  constant bc : Seq.seq tup2_Item_Item
  
  constant c : t_Zip_A_B
  
  function produces_trans_Zip_A_B (a'0: t_Zip_A_B) (ab: Seq.seq tup2_Item_Item) (b'0: t_Zip_A_B) (bc: Seq.seq tup2_Item_Item) (c: t_Zip_A_B) : ()
  
  goal vc_produces_trans_Zip_A_B: produces_Zip_A_B a'0 ab b'0
    -> produces_Zip_A_B b'0 bc c -> ([@expl:produces_trans ensures] produces_Zip_A_B a'0 (Seq.(++) ab bc) c)
end
module M_impl_Iterator_for_Zip_A_B__next (* <Zip<A, B> as common::Iterator> *)
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip_A_B = { a: t_A; b: t_B }
  
  predicate inv_A (_1: t_A)
  
  type t_Item
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a'0: t_A) (ab: Seq.seq t_Item) (b'0: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec:
    forall a'0: t_A, ab: Seq.seq t_Item, b'0: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a'0 ab b'0
      -> produces_A b'0 bc c -> produces_A a'0 (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  type t_Option_Item = None | Some t_Item
  
  predicate invariant_ref_A [@inline:trivial] (self: MutBorrow.t t_A) = inv_A self.current /\ inv_A self.final
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: MutBorrow.t t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_next (self: ()) (args: MutBorrow.t t_A)
  
  axiom precondition_fndef:
    forall args: MutBorrow.t t_A [precondition_next () args]. (let self = args in inv_ref_A self)
      -> precondition_next () args
  
  predicate completed_A (self: MutBorrow.t t_A)
  
  predicate inv_Item (_1: t_Item)
  
  predicate inv_Option_Item (_1: t_Option_Item)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_Item [inv_Option_Item x]. inv_Option_Item x
      = match x with
        | None -> true
        | Some f0 -> inv_Item f0
        end
  
  predicate postcondition_once_next (self: ()) (args: MutBorrow.t t_A) (result: t_Option_Item)
  
  axiom postcondition_fndef:
    forall args: MutBorrow.t t_A, res: t_Option_Item [postcondition_once_next () args res]. postcondition_once_next () args res
      -> (let self = args in match res with
          | None -> completed_A self
          | Some v -> produces_A self.current (Seq.singleton v) self.final
          end
      /\ inv_Option_Item res)
  
  let rec next_A (self: MutBorrow.t t_A) (return (x: t_Option_Item)) = {[@expl:next requires] precondition_next () self}
    any [ return (result: t_Option_Item) -> {postcondition_once_next () self result} (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Item) (ret (f0: t_Item)) = any
    [ good (f0: t_Item) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Item [Some f0: t_Option_Item]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_B (_1: t_B)
  
  type t_Item'0
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a'0: t_B) (ab: Seq.seq t_Item'0) (b'0: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a'0: t_B, ab: Seq.seq t_Item'0, b'0: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a'0 ab b'0
      -> produces_B b'0 bc c -> produces_B a'0 (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  type t_Option_Item'0 = None'0 | Some'0 t_Item'0
  
  predicate invariant_ref_B [@inline:trivial] (self: MutBorrow.t t_B) = inv_B self.current /\ inv_B self.final
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: MutBorrow.t t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_next'0 (self: ()) (args: MutBorrow.t t_B)
  
  axiom precondition_fndef'0:
    forall args: MutBorrow.t t_B [precondition_next'0 () args]. (let self = args in inv_ref_B self)
      -> precondition_next'0 () args
  
  predicate completed_B (self: MutBorrow.t t_B)
  
  predicate inv_Item'0 (_1: t_Item'0)
  
  predicate inv_Option_Item'0 (_1: t_Option_Item'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_Item'0 [inv_Option_Item'0 x]. inv_Option_Item'0 x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_Item'0 f0
        end
  
  predicate postcondition_once_next'0 (self: ()) (args: MutBorrow.t t_B) (result: t_Option_Item'0)
  
  axiom postcondition_fndef'0:
    forall args: MutBorrow.t t_B, res: t_Option_Item'0 [postcondition_once_next'0 () args res]. postcondition_once_next'0 () args res
      -> (let self = args in match res with
          | None'0 -> completed_B self
          | Some'0 v -> produces_B self.current (Seq.singleton v) self.final
          end
      /\ inv_Option_Item'0 res)
  
  let rec next_B (self: MutBorrow.t t_B) (return (x: t_Option_Item'0)) =
    {[@expl:next requires] precondition_next'0 () self}
    any [ return (result: t_Option_Item'0) -> {postcondition_once_next'0 () self result} (! return {result}) ]
  
  predicate inv_Zip_A_B (_1: t_Zip_A_B)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Zip_A_B [inv_Zip_A_B x]. inv_Zip_A_B x = (inv_A x.a /\ inv_B x.b)
  
  predicate invariant_ref_Zip_A_B [@inline:trivial] (self: MutBorrow.t t_Zip_A_B) =
    inv_Zip_A_B self.current /\ inv_Zip_A_B self.final
  
  meta "rewrite_def" predicate invariant_ref_Zip_A_B
  
  predicate inv_ref_Zip_A_B [@inline:trivial] (_1: MutBorrow.t t_Zip_A_B) = invariant_ref_Zip_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Zip_A_B
  
  predicate resolve_ref_Zip_A_B [@inline:trivial] (_1: MutBorrow.t t_Zip_A_B) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Zip_A_B
  
  let rec elim_Some'0 (input: t_Option_Item'0) (ret (f0: t_Item'0)) = any
    [ good (f0: t_Item'0) -> {Some'0 f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Item'0 [Some'0 f0: t_Option_Item'0]. Some'0 f0 <> input} (! {false} any) ]
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_Option_tup2_Item_Item = None'1 | Some'1 tup2_Item_Item
  
  predicate resolve_Item (_1: t_Item)
  
  predicate inv_tup2_Item_Item [@inline:trivial] (_1: tup2_Item_Item) = inv_Item _1.f0 /\ inv_Item'0 _1.f1
  
  meta "rewrite_def" predicate inv_tup2_Item_Item
  
  predicate inv_Option_tup2_Item_Item (_1: t_Option_tup2_Item_Item)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_tup2_Item_Item [inv_Option_tup2_Item_Item x]. inv_Option_tup2_Item_Item x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_tup2_Item_Item f0'0
        end
  
  predicate completed_Zip_A_B (self: MutBorrow.t t_Zip_A_B) =
    completed_A (MutBorrow.borrow_logic self.current.a self.final.a (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
      /\ self.current.b = self.final.b
    \/ (exists x: t_Item. produces_A self.current.a (Seq.singleton x) self.final.a
      /\ resolve_Item x
      /\ completed_B (MutBorrow.borrow_logic self.current.b self.final.b (MutBorrow.inherit_id (MutBorrow.get_id self) 2)))
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (tl: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A self.a p1 tl.a /\ produces_B self.b p2 tl.b
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_Zip_A_B (self: MutBorrow.t t_Zip_A_B) (return (x: t_Option_tup2_Item_Item)) =
    {[@expl:next 'self' type invariant] inv_ref_Zip_A_B self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_A self.current.a}
        MutBorrow.borrow_final <t_A> {self.current.a} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_A) ->
            [ &_5 <- _ret ] -{inv_A _ret.final}-
            [ &self <- { self with current = { self.current with a = _ret.final } } ] s1)
      | s1 = next_A {_5} (fun (_ret: t_Option_Item) -> [ &_4 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb3) | br1 (x0: t_Item) -> {_4 = Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = elim_Some {_4} (fun (r0: t_Item) -> [ &x'0 <- r0 ] s1) | s1 = [ &x <- x'0 ] s2 | s2 = bb7 ]
    | bb7 = s0
      [ s0 = {inv_B self.current.b}
        MutBorrow.borrow_final <t_B> {self.current.b} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_B) ->
            [ &_11 <- _ret ] -{inv_B _ret.final}-
            [ &self <- { self with current = { self.current with b = _ret.final } } ] s1)
      | s1 = next_B {_11} (fun (_ret: t_Option_Item'0) -> [ &_10 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Zip_A_B self} s1
      | s1 = -{resolve_ref_Zip_A_B self}- s2
      | s2 = any [ br0 -> {_10 = None'0} (! bb10) | br1 (x0: t_Item'0) -> {_10 = Some'0 x0} (! bb11) ] ]
    | bb11 = s0 [ s0 = elim_Some'0 {_10} (fun (r0: t_Item'0) -> [ &y'0 <- r0 ] s1) | s1 = [ &y <- y'0 ] s2 | s2 = bb14 ]
    | bb14 = s0 [ s0 = [ &_15 <- { f0 = x; f1 = y } ] s1 | s1 = bb16 ]
    | bb16 = s0 [ s0 = [ &_0 <- Some'1 _15 ] s1 | s1 = bb23 ]
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv_Item x} s1 | s1 = -{resolve_Item x}- s2 | s2 = bb12 ]
    | bb12 = s0 [ s0 = [ &_0 <- None'1 ] s1 | s1 = bb23 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Zip_A_B self} s1 | s1 = -{resolve_ref_Zip_A_B self}- s2 | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- None'1 ] s1 | s1 = bb23 ]
    | bb23 = return {_0} ]
    [ & _0: t_Option_tup2_Item_Item = Any.any_l ()
    | & self: MutBorrow.t t_Zip_A_B = self
    | & x: t_Item = Any.any_l ()
    | & _4: t_Option_Item = Any.any_l ()
    | & _5: MutBorrow.t t_A = Any.any_l ()
    | & x'0: t_Item = Any.any_l ()
    | & y: t_Item'0 = Any.any_l ()
    | & _10: t_Option_Item'0 = Any.any_l ()
    | & _11: MutBorrow.t t_B = Any.any_l ()
    | & y'0: t_Item'0 = Any.any_l ()
    | & _15: tup2_Item_Item = Any.any_l () ])
    [ return (result: t_Option_tup2_Item_Item) -> {[@expl:next result type invariant] inv_Option_tup2_Item_Item result}
      {[@expl:next ensures] match result with
        | None'1 -> completed_Zip_A_B self
        | Some'1 v -> produces_Zip_A_B self.current (Seq.singleton v) self.final
        end}
      (! return {result}) ]
end
module M_impl_Iterator_for_Zip_A_B__next__refines (* <Zip<A, B> as common::Iterator> *)
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip_A_B = { a: t_A; b: t_B }
  
  predicate inv_A (_1: t_A)
  
  predicate inv_B (_1: t_B)
  
  predicate inv_Zip_A_B (_1: t_Zip_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip_A_B [inv_Zip_A_B x]. inv_Zip_A_B x = (inv_A x.a /\ inv_B x.b)
  
  predicate invariant_ref_Zip_A_B [@inline:trivial] (self: MutBorrow.t t_Zip_A_B) =
    inv_Zip_A_B self.current /\ inv_Zip_A_B self.final
  
  meta "rewrite_def" predicate invariant_ref_Zip_A_B
  
  predicate inv_ref_Zip_A_B [@inline:trivial] (_1: MutBorrow.t t_Zip_A_B) = invariant_ref_Zip_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Zip_A_B
  
  type t_Item
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a'0: t_A) (ab: Seq.seq t_Item) (b'0: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec:
    forall a'0: t_A, ab: Seq.seq t_Item, b'0: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a'0 ab b'0
      -> produces_A b'0 bc c -> produces_A a'0 (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  type t_Item'0
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a'0: t_B) (ab: Seq.seq t_Item'0) (b'0: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a'0: t_B, ab: Seq.seq t_Item'0, b'0: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a'0 ab b'0
      -> produces_B b'0 bc c -> produces_B a'0 (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_Option_tup2_Item_Item = None | Some tup2_Item_Item
  
  predicate completed_A (self: MutBorrow.t t_A)
  
  predicate resolve_Item (_1: t_Item)
  
  predicate completed_B (self: MutBorrow.t t_B)
  
  predicate completed_Zip_A_B (self: MutBorrow.t t_Zip_A_B) =
    completed_A (MutBorrow.borrow_logic self.current.a self.final.a (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
      /\ self.current.b = self.final.b
    \/ (exists x: t_Item. produces_A self.current.a (Seq.singleton x) self.final.a
      /\ resolve_Item x
      /\ completed_B (MutBorrow.borrow_logic self.current.b self.final.b (MutBorrow.inherit_id (MutBorrow.get_id self) 2)))
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (tl: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A self.a p1 tl.a /\ produces_B self.b p2 tl.b
  
  predicate inv_Item (_1: t_Item)
  
  predicate inv_Item'0 (_1: t_Item'0)
  
  predicate inv_tup2_Item_Item [@inline:trivial] (_1: tup2_Item_Item) = inv_Item _1.f0 /\ inv_Item'0 _1.f1
  
  meta "rewrite_def" predicate inv_tup2_Item_Item
  
  predicate inv_Option_tup2_Item_Item (_1: t_Option_tup2_Item_Item)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_tup2_Item_Item [inv_Option_tup2_Item_Item x]. inv_Option_tup2_Item_Item x
      = match x with
        | None -> true
        | Some f0'0 -> inv_tup2_Item_Item f0'0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t t_Zip_A_B. inv_ref_Zip_A_B self
      -> inv_ref_Zip_A_B self
      /\ (forall result: t_Option_tup2_Item_Item. match result with
              | None -> completed_Zip_A_B self
              | Some v -> produces_Zip_A_B self.current (Seq.singleton v) self.final
              end
          /\ inv_Option_tup2_Item_Item result
        -> match result with
            | None -> completed_Zip_A_B self
            | Some v -> produces_Zip_A_B self.current (Seq.singleton v) self.final
            end
        /\ inv_Option_tup2_Item_Item result)
end
module M_impl_Iterator_for_Zip_A_B__produces_trans__refines (* <Zip<A, B> as common::Iterator> *)
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip_A_B = { a: t_A; b: t_B }
  
  type t_Item
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a'0: t_A) (ab: Seq.seq t_Item) (b'0: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec:
    forall a'0: t_A, ab: Seq.seq t_Item, b'0: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a'0 ab b'0
      -> produces_A b'0 bc c -> produces_A a'0 (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  type t_Item'0
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a'0: t_B) (ab: Seq.seq t_Item'0) (b'0: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a'0: t_B, ab: Seq.seq t_Item'0, b'0: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a'0 ab b'0
      -> produces_B b'0 bc c -> produces_B a'0 (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (tl: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A self.a p1 tl.a /\ produces_B self.b p2 tl.b
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a'0: t_Zip_A_B. forall ab: Seq.seq tup2_Item_Item. forall b'0: t_Zip_A_B. forall bc: Seq.seq tup2_Item_Item. forall c: t_Zip_A_B. produces_Zip_A_B b'0 bc c
                /\ produces_Zip_A_B a'0 ab b'0
              -> produces_Zip_A_B b'0 bc c
              /\ produces_Zip_A_B a'0 ab b'0
              /\ (forall result: (). produces_Zip_A_B a'0 (Seq.(++) ab bc) c -> produces_Zip_A_B a'0 (Seq.(++) ab bc) c)
end
module M_impl_Iterator_for_Zip_A_B__produces_refl__refines (* <Zip<A, B> as common::Iterator> *)
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip_A_B = { a: t_A; b: t_B }
  
  type t_Item
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a'0: t_A) (ab: Seq.seq t_Item) (b'0: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec:
    forall a'0: t_A, ab: Seq.seq t_Item, b'0: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a'0 ab b'0
      -> produces_A b'0 bc c -> produces_A a'0 (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  type t_Item'0
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a'0: t_B) (ab: Seq.seq t_Item'0) (b'0: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a'0: t_B, ab: Seq.seq t_Item'0, b'0: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a'0 ab b'0
      -> produces_B b'0 bc c -> produces_B a'0 (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (tl: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A self.a p1 tl.a /\ produces_B self.b p2 tl.b
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Zip_A_B. forall result: (). produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
        -> produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
end
