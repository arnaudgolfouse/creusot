module M_maybe_uninit
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition_default (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition_default () args]. (let () = args in true)
      -> precondition_default () args
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once_default () args res]. postcondition_once_default () args res
      -> (let () = args in inv_T res)
  
  let rec default_T (return (x: t_T)) = {[@expl:default requires] precondition_default () ()}
    any [ return (result: t_T) -> {postcondition_once_default () () result} (! return {result}) ]
  
  predicate resolve_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec maybe_uninit_T (b: bool) (y: t_T) (return (x: t_T)) = {[@expl:maybe_uninit 'y' type invariant] inv_T y}
    (! bb0
    [ bb0 = any [ br0 -> {b = false} (! bb8) | br1 -> {b} (! bb1) ]
    | bb1 = s0 [ s0 = default_T (fun (_ret: t_T) -> [ &_6 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &x <- _6 ] s1 | s1 = {[@expl:type invariant] inv_T x} s2 | s2 = -{resolve_T x}- s3 | s3 = bb8 ]
    | bb8 = s0 [ s0 = [ &x <- y ] s1 | s1 = bb10 ]
    | bb10 = s0 [ s0 = [ &_0 <- x ] s1 | s1 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & b: bool = b | & y: t_T = y | & x: t_T = Any.any_l () | & _6: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:maybe_uninit result type invariant] inv_T result} (! return {result}) ]
end
module M_init_join
  use creusot.prelude.MutBorrow
  use creusot.int.Int32
  use creusot.prelude.Any
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec init_join (b: bool) (x: Int32.t) (return (x'0: ())) = (! bb0
    [ bb0 = any [ br0 -> {b = false} (! bb2) | br1 -> {b} (! bb1) ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {x}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_8 <- _ret ] [ &x <- _ret.final ] s1)
      | s1 = MutBorrow.borrow_final <Int32.t> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_7 <- _ret ] [ &_8 <- { _8 with current = _ret.final } ] s2)
      | s2 = [ &z <- _7 ] s3
      | s3 = -{resolve_ref_i32 _8}- s4
      | s4 = MutBorrow.borrow_final <Int32.t> {z.current} {MutBorrow.get_id z}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_10 <- _ret ] [ &z <- { z with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <Int32.t> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_9 <- _ret ] [ &_10 <- { _10 with current = _ret.final } ] s6)
      | s6 = [ &y <- _9 ] s7
      | s7 = -{resolve_ref_i32 _10}- s8
      | s8 = bb7 ]
    | bb7 = s0 [ s0 = -{resolve_ref_i32 z}- s1 | s1 = bb3 ]
    | bb2 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {x}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_12 <- _ret ] [ &x <- _ret.final ] s1)
      | s1 = MutBorrow.borrow_final <Int32.t> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_11 <- _ret ] [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = [ &y <- _11 ] s3
      | s3 = -{resolve_ref_i32 _12}- s4
      | s4 = bb3 ]
    | bb3 = s0
      [ s0 = [ &y <- { y with current = (5: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 y}- s2
      | s2 = [ &_14 <- x = (5: Int32.t) ] s3
      | s3 = any [ br0 -> {_14 = false} (! bb5) | br1 -> {_14} (! bb4) ] ]
    | bb4 = return {_0}
    | bb5 = {false} any ]
    [ & _0: () = Any.any_l ()
    | & b: bool = b
    | & x: Int32.t = x
    | & y: MutBorrow.t Int32.t = Any.any_l ()
    | & z: MutBorrow.t Int32.t = Any.any_l ()
    | & _7: MutBorrow.t Int32.t = Any.any_l ()
    | & _8: MutBorrow.t Int32.t = Any.any_l ()
    | & _9: MutBorrow.t Int32.t = Any.any_l ()
    | & _10: MutBorrow.t Int32.t = Any.any_l ()
    | & _11: MutBorrow.t Int32.t = Any.any_l ()
    | & _12: MutBorrow.t Int32.t = Any.any_l ()
    | & _14: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
