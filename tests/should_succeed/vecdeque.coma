module M_test_deque
  use creusot.int.UInt64
  use seq.Seq
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_VecDeque_u32_Global
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_VecDeque_u32_Global (self: t_VecDeque_u32_Global) : Seq.seq UInt32.t
  
  axiom view_VecDeque_u32_Global_spec: forall self: t_VecDeque_u32_Global. Seq.length (view_VecDeque_u32_Global self)
      <= UInt64.t'int const_MAX
  
  let rec with_capacity_u32 (capacity: UInt64.t) (return (x: t_VecDeque_u32_Global)) = any
    [ return (result: t_VecDeque_u32_Global) -> {Seq.length (view_VecDeque_u32_Global result) = 0} (! return {result}) ]
  
  let rec is_empty_u32 (self_: t_VecDeque_u32_Global) (return (x: bool)) = any
    [ return (result: bool) -> {result = (Seq.length (view_VecDeque_u32_Global self_) = 0)} (! return {result}) ]
  
  let rec len_u32 (self_: t_VecDeque_u32_Global) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {UInt64.t'int result = Seq.length (view_VecDeque_u32_Global self_)}
      (! return {result}) ]
  
  let rec new_u32 (return (x: t_VecDeque_u32_Global)) = any
    [ return (result: t_VecDeque_u32_Global) -> {Seq.length (view_VecDeque_u32_Global result) = 0} (! return {result}) ]
  
  type t_Option_u32 = None | Some UInt32.t
  
  function push_front_u32 [@inline:trivial] (self: Seq.seq UInt32.t) (x: UInt32.t) : Seq.seq UInt32.t = Seq.cons x self
  
  meta "rewrite_def" function push_front_u32
  
  let rec pop_front_u32 (self_: MutBorrow.t t_VecDeque_u32_Global) (return (x: t_Option_u32)) = any
    [ return (result: t_Option_u32) -> {match result with
        | Some t -> view_VecDeque_u32_Global self_.final
          = Seq.([..]) (view_VecDeque_u32_Global self_.current) 1 (Seq.length (view_VecDeque_u32_Global self_.current))
        /\ view_VecDeque_u32_Global self_.current = push_front_u32 (view_VecDeque_u32_Global self_.final) t
        | None -> self_.current = self_.final /\ Seq.length (view_VecDeque_u32_Global self_.current) = 0
        end}
      (! return {result}) ]
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  function deep_model_Option_u32 [@inline:trivial] (self: t_Option_u32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_u32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_u32
  
  function deep_model_ref_Option_u32 [@inline:trivial] (self: t_Option_u32) : t_Option_Int = deep_model_Option_u32 self
  
  meta "rewrite_def" function deep_model_ref_Option_u32
  
  let rec eq_Option_u32 (self_: t_Option_u32) (rhs: t_Option_u32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_u32 self_ = deep_model_ref_Option_u32 rhs)}
      (! return {result}) ]
  
  let rec pop_back_u32 (self_: MutBorrow.t t_VecDeque_u32_Global) (return (x: t_Option_u32)) = any
    [ return (result: t_Option_u32) -> {match result with
        | Some t -> view_VecDeque_u32_Global self_.final
          = Seq.([..]) (view_VecDeque_u32_Global self_.current) 0 (Seq.length (view_VecDeque_u32_Global self_.current)
          - 1)
        /\ view_VecDeque_u32_Global self_.current = Seq.snoc (view_VecDeque_u32_Global self_.final) t
        | None -> self_.current = self_.final /\ Seq.length (view_VecDeque_u32_Global self_.current) = 0
        end}
      (! return {result}) ]
  
  let rec push_front_u32'0 (self_: MutBorrow.t t_VecDeque_u32_Global) (value: UInt32.t) (return (x: ())) = any
    [ return (result: ()) -> {Seq.length (view_VecDeque_u32_Global self_.final)
      = Seq.length (view_VecDeque_u32_Global self_.current) + 1}
      {view_VecDeque_u32_Global self_.final = push_front_u32 (view_VecDeque_u32_Global self_.current) value}
      (! return {result}) ]
  
  let rec push_back_u32 (self_: MutBorrow.t t_VecDeque_u32_Global) (value: UInt32.t) (return (x: ())) = any
    [ return (result: ()) -> {view_VecDeque_u32_Global self_.final
      = Seq.snoc (view_VecDeque_u32_Global self_.current) value}
      (! return {result}) ]
  
  let rec clear_u32 (self_: MutBorrow.t t_VecDeque_u32_Global) (return (x: ())) = any
    [ return (result: ()) -> {Seq.length (view_VecDeque_u32_Global self_.final) = 0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_deque (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = with_capacity_u32 {(5: UInt64.t)} (fun (_ret: t_VecDeque_u32_Global) -> [ &deque <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = is_empty_u32 {deque} (fun (_ret: bool) -> [ &_3 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]
    | bb3 = s0 [ s0 = len_u32 {deque} (fun (_ret: UInt64.t) -> [ &_8 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_7 <- _8 = (0: UInt64.t) ] s1 | s1 = any [ br0 -> {_7 = false} (! bb7) | br1 -> {_7} (! bb6) ] ]
    | bb6 = s0 [ s0 = new_u32 (fun (_ret: t_VecDeque_u32_Global) -> [ &deque'0 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = is_empty_u32 {deque'0} (fun (_ret: bool) -> [ &_13 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = any [ br0 -> {_13 = false} (! bb11) | br1 -> {_13} (! bb10) ]
    | bb10 = s0 [ s0 = len_u32 {deque'0} (fun (_ret: UInt64.t) -> [ &_18 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = [ &_17 <- _18 = (0: UInt64.t) ] s1 | s1 = any [ br0 -> {_17 = false} (! bb14) | br1 -> {_17} (! bb13) ] ]
    | bb13 = s0
      [ s0 = MutBorrow.borrow_mut <t_VecDeque_u32_Global> {deque'0}
          (fun (_ret: MutBorrow.t t_VecDeque_u32_Global) -> [ &_25 <- _ret ] [ &deque'0 <- _ret.final ] s1)
      | s1 = pop_front_u32 {_25} (fun (_ret: t_Option_u32) -> [ &_24 <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_u32 = Any.any_l () | & _1: t_Option_u32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_u32) -> [ &_68 <- _const ] s1 ]
      | s1 = eq_Option_u32 {_24} {_68} (fun (_ret: bool) -> [ &_22 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = any [ br0 -> {_22 = false} (! bb18) | br1 -> {_22} (! bb17) ]
    | bb17 = s0
      [ s0 = MutBorrow.borrow_mut <t_VecDeque_u32_Global> {deque'0}
          (fun (_ret: MutBorrow.t t_VecDeque_u32_Global) -> [ &_33 <- _ret ] [ &deque'0 <- _ret.final ] s1)
      | s1 = pop_back_u32 {_33} (fun (_ret: t_Option_u32) -> [ &_32 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_u32 = Any.any_l () | & _1: t_Option_u32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_u32) -> [ &_67 <- _const ] s1 ]
      | s1 = eq_Option_u32 {_32} {_67} (fun (_ret: bool) -> [ &_30 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = any [ br0 -> {_30 = false} (! bb22) | br1 -> {_30} (! bb21) ]
    | bb21 = s0
      [ s0 = MutBorrow.borrow_mut <t_VecDeque_u32_Global> {deque'0}
          (fun (_ret: MutBorrow.t t_VecDeque_u32_Global) -> [ &_38 <- _ret ] [ &deque'0 <- _ret.final ] s1)
      | s1 = push_front_u32'0 {_38} {(1: UInt32.t)} (fun (_ret: ()) -> [ &_37 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0
      [ s0 = MutBorrow.borrow_mut <t_VecDeque_u32_Global> {deque'0}
          (fun (_ret: MutBorrow.t t_VecDeque_u32_Global) -> [ &_40 <- _ret ] [ &deque'0 <- _ret.final ] s1)
      | s1 = push_front_u32'0 {_40} {(2: UInt32.t)} (fun (_ret: ()) -> [ &_39 <- _ret ] s2)
      | s2 = bb24 ]
    | bb24 = s0
      [ s0 = MutBorrow.borrow_mut <t_VecDeque_u32_Global> {deque'0}
          (fun (_ret: MutBorrow.t t_VecDeque_u32_Global) -> [ &_42 <- _ret ] [ &deque'0 <- _ret.final ] s1)
      | s1 = push_back_u32 {_42} {(3: UInt32.t)} (fun (_ret: ()) -> [ &_41 <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0
      [ s0 = MutBorrow.borrow_mut <t_VecDeque_u32_Global> {deque'0}
          (fun (_ret: MutBorrow.t t_VecDeque_u32_Global) -> [ &_47 <- _ret ] [ &deque'0 <- _ret.final ] s1)
      | s1 = pop_front_u32 {_47} (fun (_ret: t_Option_u32) -> [ &_46 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: UInt32.t) ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_u32 = Any.any_l () | & _1: t_Option_u32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_u32) -> [ &_66 <- _const ] s1 ]
      | s1 = eq_Option_u32 {_46} {_66} (fun (_ret: bool) -> [ &_44 <- _ret ] s2)
      | s2 = bb27 ]
    | bb27 = any [ br0 -> {_44 = false} (! bb29) | br1 -> {_44} (! bb28) ]
    | bb28 = s0
      [ s0 = MutBorrow.borrow_mut <t_VecDeque_u32_Global> {deque'0}
          (fun (_ret: MutBorrow.t t_VecDeque_u32_Global) -> [ &_55 <- _ret ] [ &deque'0 <- _ret.final ] s1)
      | s1 = pop_back_u32 {_55} (fun (_ret: t_Option_u32) -> [ &_54 <- _ret ] s2)
      | s2 = bb30 ]
    | bb30 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (3: UInt32.t) ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_u32 = Any.any_l () | & _1: t_Option_u32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_u32) -> [ &_65 <- _const ] s1 ]
      | s1 = eq_Option_u32 {_54} {_65} (fun (_ret: bool) -> [ &_52 <- _ret ] s2)
      | s2 = bb31 ]
    | bb31 = any [ br0 -> {_52 = false} (! bb33) | br1 -> {_52} (! bb32) ]
    | bb32 = s0
      [ s0 = MutBorrow.borrow_mut <t_VecDeque_u32_Global> {deque'0}
          (fun (_ret: MutBorrow.t t_VecDeque_u32_Global) -> [ &_60 <- _ret ] [ &deque'0 <- _ret.final ] s1)
      | s1 = clear_u32 {_60} (fun (_ret: ()) -> [ &_59 <- _ret ] s2)
      | s2 = bb34 ]
    | bb34 = s0 [ s0 = is_empty_u32 {deque'0} (fun (_ret: bool) -> [ &_62 <- _ret ] s1) | s1 = bb35 ]
    | bb35 = any [ br0 -> {_62 = false} (! bb37) | br1 -> {_62} (! bb39) ]
    | bb39 = return {_0}
    | bb37 = {false} any
    | bb33 = {false} any
    | bb29 = {false} any
    | bb22 = {false} any
    | bb18 = {false} any
    | bb14 = {false} any
    | bb11 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _0: () = Any.any_l ()
    | & deque: t_VecDeque_u32_Global = Any.any_l ()
    | & _3: bool = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: UInt64.t = Any.any_l ()
    | & deque'0: t_VecDeque_u32_Global = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: UInt64.t = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option_u32 = Any.any_l ()
    | & _25: MutBorrow.t t_VecDeque_u32_Global = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _32: t_Option_u32 = Any.any_l ()
    | & _33: MutBorrow.t t_VecDeque_u32_Global = Any.any_l ()
    | & _37: () = Any.any_l ()
    | & _38: MutBorrow.t t_VecDeque_u32_Global = Any.any_l ()
    | & _39: () = Any.any_l ()
    | & _40: MutBorrow.t t_VecDeque_u32_Global = Any.any_l ()
    | & _41: () = Any.any_l ()
    | & _42: MutBorrow.t t_VecDeque_u32_Global = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & _46: t_Option_u32 = Any.any_l ()
    | & _47: MutBorrow.t t_VecDeque_u32_Global = Any.any_l ()
    | & _52: bool = Any.any_l ()
    | & _54: t_Option_u32 = Any.any_l ()
    | & _55: MutBorrow.t t_VecDeque_u32_Global = Any.any_l ()
    | & _59: () = Any.any_l ()
    | & _60: MutBorrow.t t_VecDeque_u32_Global = Any.any_l ()
    | & _62: bool = Any.any_l ()
    | & _65: t_Option_u32 = Any.any_l ()
    | & _66: t_Option_u32 = Any.any_l ()
    | & _67: t_Option_u32 = Any.any_l ()
    | & _68: t_Option_u32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
