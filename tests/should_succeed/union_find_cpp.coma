module M_union_find_cpp__implementation__qyi8727259475583274922__eq [#"union_find_cpp.rs" 18 8 18 42] (* <implementation::Elem<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find_cpp = "union_find_cpp.rs" 17 18 17 69
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 24 8 24 24
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 157 22 157 66
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  let rec addr_eq (p: Opaque.ptr) (q: Opaque.ptr) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#sptr] result = (Opaque.addr_logic_u64 p = Opaque.addr_logic_u64 q)}
      (! return' {result}) ]
  
  function deep_model [#"union_find_cpp.rs" 25 8 25 36] [@inline:trivial] (self: t_Elem) : UInt64.t =
    [%#sunion_find_cpp'0] Opaque.addr_logic_u64 self.t_Elem__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Elem) : UInt64.t = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq [#"union_find_cpp.rs" 18 8 18 42] (self: t_Elem) (other: t_Elem) (return' (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = addr_eq {self'0.t_Elem__0} {other'0.t_Elem__0} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return''0 {_0} ] [ & _0: bool = Any.any_l () | & self'0: t_Elem = self | & other'0: t_Elem = other ])
    [ return''0 (result: bool) -> {[@expl:eq ensures] [%#sunion_find_cpp] result
      = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
end
module M_union_find_cpp__implementation__qyi522541565276843360__clone [#"union_find_cpp.rs" 38 8 38 31] (* <implementation::Elem<T> as creusot_contracts::Clone> *)
  let%span sunion_find_cpp = "union_find_cpp.rs" 36 18 36 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' [#"union_find_cpp.rs" 38 8 38 31] (self: t_Elem) (return' (x: t_Elem)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { t_Elem__0 = self'0.t_Elem__0 } ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: t_Elem = Any.any_l () | & self'0: t_Elem = self ])
    [ return''0 (result: t_Elem) -> {[@expl:clone ensures] [%#sunion_find_cpp] self = result} (! return' {result}) ]
end
module M_union_find_cpp__implementation__qyi10913086124150880335__roots_map [#"union_find_cpp.rs" 109 8 109 59] (* implementation::UF<T> *)
  let%span sunion_find_cpp = "union_find_cpp.rs" 104 19 104 28
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 105 18 107 42
  let%span sunion_find_cpp'1 = "union_find_cpp.rs" 103 8 103 16
  let%span sunion_find_cpp'2 = "union_find_cpp.rs" 94 8 94 22
  let%span sunion_find_cpp'3 = "union_find_cpp.rs" 86 8 86 16
  let%span sunion_find_cpp'4 = "union_find_cpp.rs" 66 12 79 17
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span soption = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Elem;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Elem t_T;
    t_UFInner__roots: Map.map t_Elem t_Elem }
  
  type t_UF = { t_UF__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Elem
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Elem t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_Option = [%#sfmap'1] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Elem) = [%#sfmap] get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#slogic] exists x: t_PtrOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_PtrOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Elem) : t_PtrOwn = [%#sfmap'0] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  predicate invariant' [#"union_find_cpp.rs" 64 8 64 34] [@inline:trivial] (self: t_UF) =
    [%#sunion_find_cpp'4] forall e: t_Elem. contains (self.t_UF__0).t_UFInner__domain e
      -> contains'0 (self.t_UF__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UF__0).t_UFInner__perms e) = e.t_Elem__0
      /\ contains (self.t_UF__0).t_UFInner__domain (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UF__0).t_UFInner__roots (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UF__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UF__0).t_UFInner__perms e) with
        | C_Link e2 -> contains (self.t_UF__0).t_UFInner__domain e2
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e <> e
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e = index_logic'1 (self.t_UF__0).t_UFInner__roots e2
        | C_Root _ payload -> index_logic'1 (self.t_UF__0).t_UFInner__roots e = e
        /\ index_logic'2 (self.t_UF__0).t_UFInner__payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_0: t_Elem)
  
  axiom inv_axiom [@rewrite]: forall x: t_Elem [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_FMap) =
    [%#sfmap'3] forall k: t_Elem. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_UFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots} -> inv'4 perms
        end
  
  predicate inv'6 (_0: t_UF)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UF [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UF__0 = a_0} -> inv'5 a_0
        end)
  
  function domain [#"union_find_cpp.rs" 89 8 89 44] (self: t_UF) : Fset.fset t_Elem =
    [%#sunion_find_cpp'3] (self.t_UF__0).t_UFInner__domain
  
  predicate in_domain [#"union_find_cpp.rs" 95 8 95 50] (self: t_UF) (e: t_Elem) =
    [%#sunion_find_cpp'2] contains (domain self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UF
  
  function roots_map [#"union_find_cpp.rs" 109 8 109 59] (self'0: t_UF) : Map.map t_Elem t_Elem
  
  goal vc_roots_map: ([%#sunion_find_cpp] inv'6 self)
    -> (let result = (self.t_UF__0).t_UFInner__roots in [@expl:roots_map ensures] [%#sunion_find_cpp'0] forall e: t_Elem. in_domain self e
      -> in_domain self (index_logic'1 result e)
      /\ index_logic'1 result e = index_logic'1 result (index_logic'1 result e))
end
module M_union_find_cpp__implementation__new [#"union_find_cpp.rs" 161 4 161 35]
  let%span sunion_find_cpp = "union_find_cpp.rs" 165 38 165 51
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 167 40 167 59
  let%span sunion_find_cpp'1 = "union_find_cpp.rs" 168 37 168 56
  let%span sunion_find_cpp'2 = "union_find_cpp.rs" 161 23 161 35
  let%span sunion_find_cpp'3 = "union_find_cpp.rs" 160 4 160 42
  let%span sunion_find_cpp'4 = "union_find_cpp.rs" 86 8 86 16
  let%span sunion_find_cpp'5 = "union_find_cpp.rs" 66 12 79 17
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 269 4 269 33
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 112 4 112 18
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 174 14 174 39
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 177 12 177 35
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 51 14 51 31
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 43
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 203 22 203 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 203 4 205 17
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 201 14 201 29
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 181 15 181 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 181 4 183 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 179 14 179 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  
  use set.Fset
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  type t_FMap
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_T
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Elem
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Elem t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_Option = [%#sfmap'6] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Elem) = [%#sfmap'9] get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_0: t_Elem)
  
  axiom inv_axiom [@rewrite]: forall x: t_Elem [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : t_Node
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant' [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''0 (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant' x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#slogic] exists x: t_PtrOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_PtrOwn = [%#sfmap'11] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Elem) : t_PtrOwn = [%#sfmap'10] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    [%#sfmap'8] forall k: t_Elem. contains self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_FMap) = [%#sghost'5] inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = [%#sfmap'3] forall k: t_Elem. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'2] ext_eq self other = (self = other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'7] len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'4] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'5] view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = [%#sfmap'1] ext_eq self empty
  
  let rec new (return' (x: t_FMap)) = any
    [ return''0 (result: t_FMap) -> {[%#sfmap] inv'5 result} {[%#sfmap'0] is_empty result} (! return' {result}) ]
  
  let rec into_inner (self: t_FMap) (return' (x: t_FMap)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'5 self}
    any [ return''0 (result: t_FMap) -> {[%#sghost'0] inv'4 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (Map.map t_Elem t_T) bool) (a: Map.map t_Elem t_T) =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (Map.map t_Elem t_T) bool) : Map.map t_Elem t_T
  
  axiom such_that_spec'0:
    forall p: Map.map (Map.map t_Elem t_T) bool. ([%#slogic] exists x: Map.map t_Elem t_T. index_logic'1 p x)
      -> ([%#slogic'0] index_logic'1 p (such_that'0 p))
  
  predicate index_logic'2 [@inline:trivial] (self: Map.map (Map.map t_Elem t_Elem) bool) (a: Map.map t_Elem t_Elem) =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic'2
  
  function such_that'1 (p: Map.map (Map.map t_Elem t_Elem) bool) : Map.map t_Elem t_Elem
  
  axiom such_that_spec'1:
    forall p: Map.map (Map.map t_Elem t_Elem) bool. ([%#slogic] exists x: Map.map t_Elem t_Elem. index_logic'2 p x)
      -> ([%#slogic'0] index_logic'2 p (such_that'1 p))
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Elem;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Elem t_T;
    t_UFInner__roots: Map.map t_Elem t_Elem }
  
  type t_UF = { t_UF__0: t_UFInner }
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  function index_logic'4 [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'4
  
  predicate invariant''3 [#"union_find_cpp.rs" 64 8 64 34] [@inline:trivial] (self: t_UF) =
    [%#sunion_find_cpp'5] forall e: t_Elem. contains'0 (self.t_UF__0).t_UFInner__domain e
      -> contains (self.t_UF__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UF__0).t_UFInner__perms e) = e.t_Elem__0
      /\ contains'0 (self.t_UF__0).t_UFInner__domain (index_logic'3 (self.t_UF__0).t_UFInner__roots e)
      /\ index_logic'3 (self.t_UF__0).t_UFInner__roots (index_logic'3 (self.t_UF__0).t_UFInner__roots e)
        = index_logic'3 (self.t_UF__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UF__0).t_UFInner__perms e) with
        | C_Link e2 -> contains'0 (self.t_UF__0).t_UFInner__domain e2
        /\ index_logic'3 (self.t_UF__0).t_UFInner__roots e <> e
        /\ index_logic'3 (self.t_UF__0).t_UFInner__roots e = index_logic'3 (self.t_UF__0).t_UFInner__roots e2
        | C_Root _ payload -> index_logic'3 (self.t_UF__0).t_UFInner__roots e = e
        /\ index_logic'4 (self.t_UF__0).t_UFInner__payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_0: t_UFInner)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UFInner [inv'6 x]. inv'6 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots} -> inv'4 perms
        end
  
  predicate inv'7 (_0: t_UF)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UF [inv'7 x]. inv'7 x
      = (invariant''3 x
      /\ match x with
        | {t_UF__0 = a_0} -> inv'6 a_0
        end)
  
  predicate invariant''4 [@inline:trivial] (self: t_UF) = [%#sghost'5] inv'7 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'8 (_0: t_UF)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UF [inv'8 x]. inv'8 x = invariant''4 x
  
  let rec new'0 (x: t_UF) (return' (x'0: t_UF)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'7 x}
    any [ return''0 (result: t_UF) -> {[%#sghost'3] inv'8 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  function domain [#"union_find_cpp.rs" 89 8 89 44] (self: t_UF) : Fset.fset t_Elem =
    [%#sunion_find_cpp'4] (self.t_UF__0).t_UFInner__domain
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'1 [#"union_find_cpp.rs" 161 4 161 35] (return' (x: t_UF)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- [%#sunion_find_cpp] Fset.empty: Fset.fset t_Elem ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: t_FMap) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_inner {_7} (fun (_ret: t_FMap) -> [ &_6 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_8 <- [%#sunion_find_cpp'0] such_that'0 (fun (__0: Map.map t_Elem t_T) -> true) ] s1 | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_10 <- [%#sunion_find_cpp'1] such_that'1 (fun (__0: Map.map t_Elem t_Elem) -> true) ] s1 | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_3 <- { t_UFInner__domain = _4;
                        t_UFInner__perms = _6;
                        t_UFInner__payloads = _8;
                        t_UFInner__roots = _10 } ] s1
      | s1 = [ &_2 <- { t_UF__0 = _3 } ] s2
      | s2 = new'0 {_2} (fun (_ret: t_UF) -> [ &_0 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = return''0 {_0} ]
    [ & _0: t_UF = Any.any_l ()
    | & _2: t_UF = Any.any_l ()
    | & _3: t_UFInner = Any.any_l ()
    | & _4: Fset.fset t_Elem = Any.any_l ()
    | & _6: t_FMap = Any.any_l ()
    | & _7: t_FMap = Any.any_l ()
    | & _8: Map.map t_Elem t_T = Any.any_l ()
    | & _10: Map.map t_Elem t_Elem = Any.any_l () ])
    [ return''0 (result: t_UF) -> {[@expl:new result type invariant] [%#sunion_find_cpp'2] inv'8 result}
      {[@expl:new ensures] [%#sunion_find_cpp'3] Fset.is_empty (domain result)}
      (! return' {result}) ]
end
module M_union_find_cpp__implementation__make [#"union_find_cpp.rs" 178 4 178 68]
  let%span sunion_find_cpp = "union_find_cpp.rs" 179 37 179 44
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 191 26 191 60
  let%span sunion_find_cpp'1 = "union_find_cpp.rs" 192 28 192 76
  let%span sunion_find_cpp'2 = "union_find_cpp.rs" 193 25 193 60
  let%span sunion_find_cpp'3 = "union_find_cpp.rs" 178 23 178 25
  let%span sunion_find_cpp'4 = "union_find_cpp.rs" 178 46 178 53
  let%span sunion_find_cpp'5 = "union_find_cpp.rs" 174 4 174 37
  let%span sunion_find_cpp'6 = "union_find_cpp.rs" 175 14 175 58
  let%span sunion_find_cpp'7 = "union_find_cpp.rs" 176 14 176 69
  let%span sunion_find_cpp'8 = "union_find_cpp.rs" 177 14 177 76
  let%span sunion_find_cpp'9 = "union_find_cpp.rs" 94 8 94 22
  let%span sunion_find_cpp'10 = "union_find_cpp.rs" 86 8 86 16
  let%span sunion_find_cpp'11 = "union_find_cpp.rs" 104 19 104 28
  let%span sunion_find_cpp'12 = "union_find_cpp.rs" 105 18 107 42
  let%span sunion_find_cpp'13 = "union_find_cpp.rs" 103 8 103 16
  let%span sunion_find_cpp'14 = "union_find_cpp.rs" 123 8 123 16
  let%span sunion_find_cpp'15 = "union_find_cpp.rs" 66 12 79 17
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 55 8 55 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 346 22 346 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 346 4 346 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 345 14 345 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 437 29 437 33
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 437 43 437 48
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 437 4 437 65
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 435 14 435 49
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 436 14 436 40
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 68 14 68 46
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 88
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 772 8 775 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 55 15 55 16
  let%span sptr_own'0 = "../../creusot-contracts/src/ghost/ptr_own.rs" 55 4 55 52
  let%span sptr_own'1 = "../../creusot-contracts/src/ghost/ptr_own.rs" 54 14 54 64
  let%span sptr_own'2 = "../../creusot-contracts/src/ghost/ptr_own.rs" 208 26 208 30
  let%span sptr_own'3 = "../../creusot-contracts/src/ghost/ptr_own.rs" 208 48 208 52
  let%span sptr_own'4 = "../../creusot-contracts/src/ghost/ptr_own.rs" 205 14 205 64
  let%span sptr_own'5 = "../../creusot-contracts/src/ghost/ptr_own.rs" 206 14 206 28
  let%span sptr_own'6 = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 203 22 203 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 203 4 205 17
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 201 14 201 29
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 179 14 179 26
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span speano = "../../creusot-contracts/src/peano.rs" 128 14 128 30
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec new (return' (x: t_PeanoInt)) = any
    [ return''0 (result: t_PeanoInt) -> {[%#speano] result.t_PeanoInt__0 = (0: UInt64.t)} (! return' {result}) ]
  
  type t_T
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Elem
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }
  
  type tuple = { _p0: Opaque.ptr; _p1: t_PtrOwn }
  
  predicate inv (_0: t_T)
  
  predicate inv'0 (_0: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'0 x]. inv'0 x
      = match x with
        | C_Root rank payload -> inv payload
        | C_Link a_0 -> true
        end
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : t_Node
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant' [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own'6] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant'
  
  predicate invariant''0 (self: t_Node) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate inv'2 (_0: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'2 x]. inv'2 x
      = (invariant' x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'1 val''0
        end)
  
  predicate invariant''1 [@inline:trivial] (self: t_PtrOwn) = [%#sghost'4] inv'2 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: tuple)
  
  axiom inv_axiom'3 [@rewrite]: forall x: tuple [inv'4 x]. inv'4 x = (let {_p0 = x0; _p1 = x1} = x in inv'3 x1)
  
  let rec new'0 (v: t_Node) (return' (x: tuple)) = {[@expl:new 'v' type invariant] [%#sptr_own] inv'0 v}
    any
    [ return''0 (result: tuple) -> {[%#sptr_own'0] inv'4 result}
      {[%#sptr_own'1] ptr result._p1 = result._p0 /\ val' result._p1 = v}
      (! return' {result}) ]
  
  let rec into_inner (self: t_PtrOwn) (return' (x: t_PtrOwn)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'3 self}
    any
    [ return''0 (result: t_PtrOwn) -> {[%#sghost'0] inv'2 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_FMap
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Elem;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Elem t_T;
    t_UFInner__roots: Map.map t_Elem t_Elem }
  
  type t_UF = { t_UF__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = [%#sfset'0] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Elem t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_Option = [%#sfmap'7] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Elem) = [%#sfmap'12] get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#slogic] exists x: t_PtrOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'2] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_PtrOwn = [%#sfmap'14] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Elem) : t_PtrOwn = [%#sfmap'13] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  predicate invariant''2 [#"union_find_cpp.rs" 64 8 64 34] [@inline:trivial] (self: t_UF) =
    [%#sunion_find_cpp'15] forall e: t_Elem. contains (self.t_UF__0).t_UFInner__domain e
      -> contains'0 (self.t_UF__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UF__0).t_UFInner__perms e) = e.t_Elem__0
      /\ contains (self.t_UF__0).t_UFInner__domain (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UF__0).t_UFInner__roots (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UF__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UF__0).t_UFInner__perms e) with
        | C_Link e2 -> contains (self.t_UF__0).t_UFInner__domain e2
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e <> e
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e = index_logic'1 (self.t_UF__0).t_UFInner__roots e2
        | C_Root _ payload -> index_logic'1 (self.t_UF__0).t_UFInner__roots e = e
        /\ index_logic'2 (self.t_UF__0).t_UFInner__payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_0: t_Elem)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Elem [inv'5 x]. inv'5 x = true
  
  predicate invariant''3 [@inline:trivial] (self: t_FMap) =
    [%#sfmap'10] forall k: t_Elem. contains'0 self k -> inv'5 k /\ inv'2 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_0: t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_FMap [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate inv'7 (_0: t_UFInner)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UFInner [inv'7 x]. inv'7 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots} -> inv'6 perms
        end
  
  predicate inv'8 (_0: t_UF)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UF [inv'8 x]. inv'8 x
      = (invariant''2 x
      /\ match x with
        | {t_UF__0 = a_0} -> inv'7 a_0
        end)
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_UF) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_UF [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sghost'4] inv'9 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'10 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_UF [inv'10 x]. inv'10 x = invariant''5 x
  
  let rec into_inner'0 (self: MutBorrow.t t_UF) (return' (x: MutBorrow.t t_UF)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'10 self}
    any
    [ return''0 (result: MutBorrow.t t_UF) -> {[%#sghost'0] inv'9 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  type tuple'0 = { _p0'0: t_PtrOwn; _p1'0: MutBorrow.t t_UF }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''6 [@inline:trivial] (self: t_FMap) = [%#sinvariant'0] inv'6 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'11 (_0: t_FMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_FMap [inv'11 x]. inv'11 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: t_PtrOwn) = [%#sinvariant'0] inv'2 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'12 (_0: t_PtrOwn)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''7 x
  
  predicate inv'13 (_0: t_Option'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'12 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = [%#soption] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Elem) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'11 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'13 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return' {result}) ]
  
  let rec v_Some (input: t_Option'0) (ret (field_0: t_PtrOwn)) = any
    [ good (field_0: t_PtrOwn) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_PtrOwn [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'14 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'14 x]. inv'14 x = invariant''8 x
  
  let rec disjoint_lemma (own1: MutBorrow.t t_PtrOwn) (own2: t_PtrOwn) (return' (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] [%#sptr_own'2] inv'14 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#sptr_own'3] inv'12 own2}
    any
    [ return''0 (result: ()) -> {[%#sptr_own'4] Opaque.addr_logic_u64 (ptr own1.current)
      <> Opaque.addr_logic_u64 (ptr own2)}
      {[%#sptr_own'5] own1.current = own1.final}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_PtrOwn) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'15 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'15 x]. inv'15 x = invariant''9 x
  
  predicate inv'16 (_0: t_Option)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Option [inv'16 x]. inv'16 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'11] len self >= 0
  
  function insert (self: t_FMap) (k: t_Elem) (v: t_PtrOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Elem, v: t_PtrOwn. [%#sfmap'8] view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Elem, v: t_PtrOwn. [%#sfmap'9] len (insert self k v)
      = (if contains'0 self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_Elem) (value: t_PtrOwn) (return' (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'2] inv'15 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'3] inv'2 value}
    any
    [ return''0 (result: t_Option) -> {[%#sfmap'4] inv'16 result}
      {[%#sfmap'5] self.final = insert self.current key value}
      {[%#sfmap'6] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (_0: t_PtrOwn) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (self: t_Option) =
    [%#soption'0] match self with
      | C_Some x -> resolve'1 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: t_Option) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  function insert'0 [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) : Fset.fset t_Elem =
    [%#sfset] Fset.add e self
  
  meta "rewrite_def" function insert'0
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_0: MutBorrow.t t_UF) = resolve'4 _0
  
  meta "rewrite_def" predicate resolve'5
  
  let rec new'1 (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'2] result = x} (! return' {result}) ]
  
  function domain [#"union_find_cpp.rs" 89 8 89 44] (self: t_UF) : Fset.fset t_Elem =
    [%#sunion_find_cpp'10] (self.t_UF__0).t_UFInner__domain
  
  predicate in_domain [#"union_find_cpp.rs" 95 8 95 50] (self: t_UF) (e: t_Elem) =
    [%#sunion_find_cpp'9] contains (domain self) e
  
  function fin [@inline:trivial] (self: MutBorrow.t t_UF) : t_UF = [%#sghost'3] self.final
  
  meta "rewrite_def" function fin
  
  function roots_map [#"union_find_cpp.rs" 109 8 109 59] (self: t_UF) : Map.map t_Elem t_Elem =
    [%#sunion_find_cpp'13] (self.t_UF__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UF. ([%#sunion_find_cpp'11] inv'8 self)
      -> ([%#sunion_find_cpp'12] forall e: t_Elem. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function payloads_map [#"union_find_cpp.rs" 124 8 124 56] (self: t_UF) : Map.map t_Elem t_T =
    [%#sunion_find_cpp'14] (self.t_UF__0).t_UFInner__payloads
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec make [#"union_find_cpp.rs" 178 4 178 68] (uf: MutBorrow.t t_UF) (payload: t_T) (return' (x: t_Elem)) =
    {[@expl:make 'uf' type invariant] [%#sunion_find_cpp'3] inv'10 uf}
    {[@expl:make 'payload' type invariant] [%#sunion_find_cpp'4] inv payload}
    (! bb0
    [ bb0 = s0 [ s0 = [ &payload_snap <- [%#sunion_find_cpp] payload'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: t_PeanoInt) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_12 <- C_Root _13 payload'0 ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = new'0 {_12} (fun (_ret: tuple) -> [ &_11 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &ptr'0 <- _11._p0 ] s1
      | s1 = [ &perm <- _11._p1 ] s2
      | s2 = [ &elt <- { t_Elem__0 = ptr'0 } ] s3
      | s3 = into_inner {perm} (fun (_ret: t_PtrOwn) -> [ &_22 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0 [ s0 = into_inner'0 {uf'0} (fun (_ret: MutBorrow.t t_UF) -> [ &_24 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &_21 <- { _p0'0 = _22; _p1'0 = _24 } ] s1 | s1 = bb7 ]
    | bb7 = s0 [ s0 = [ &perm'0 <- _21._p0'0 ] s1 | s1 = [ &uf'1 <- _21._p1'0 ] s2 | s2 = bb8 ]
    | bb8 = s0
      [ s0 = [ &_30 <- elt ] s1
      | s1 = get_ghost {((uf'1.current).t_UF__0).t_UFInner__perms} {_30} (fun (_ret: t_Option'0) -> [ &_27 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = any [ br0 -> {_27 = C_None'0} (! bb15) | br1 (x0: t_PtrOwn) -> {_27 = C_Some'0 x0} (! bb12) ]
    | bb12 = s0
      [ s0 = v_Some {_27} (fun (r0: t_PtrOwn) -> [ &other_perm <- r0 ] s1)
      | s1 = {inv'2 perm'0}
        MutBorrow.borrow_mut <t_PtrOwn> {perm'0}
          (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_34 <- _ret ] -{inv'2 _ret.final}- [ &perm'0 <- _ret.final ] s2)
      | s2 = {inv'2 _34.current}
        MutBorrow.borrow_final <t_PtrOwn> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_33 <- _ret ] -{inv'2 _ret.final}-
            [ &_34 <- { _34 with current = _ret.final } ] s3)
      | s3 = disjoint_lemma {_33} {other_perm} (fun (_ret: ()) -> [ &_26 <- _ret ] s4)
      | s4 = bb14 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'14 _34} s1 | s1 = -{resolve'0 _34}- s2 | s2 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'6 ((uf'1.current).t_UF__0).t_UFInner__perms}
        MutBorrow.borrow_final <t_FMap> {((uf'1.current).t_UF__0).t_UFInner__perms}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id uf'1) 1) 2}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_37 <- _ret ] -{inv'6 _ret.final}-
            [ &uf'1 <- { uf'1 with current = { t_UF__0 = { (uf'1.current).t_UF__0 with t_UFInner__perms = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_37} {elt} {perm'0} (fun (_ret: t_Option) -> [ &_36 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'16 _36} s3
      | s3 = -{resolve'3 _36}- s4
      | s4 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_40 <- [%#sunion_find_cpp'0] insert'0 ((uf'1.current).t_UF__0).t_UFInner__domain elt ] s1 | s1 = bb18 ]
    | bb18 = s0
      [ s0 = [ &uf'1 <- { uf'1 with current = { t_UF__0 = { (uf'1.current).t_UF__0 with t_UFInner__domain = _40 } } } ]
        s1
      | s1 = [ &_42 <- [%#sunion_find_cpp'1] Map.set ((uf'1.current).t_UF__0).t_UFInner__payloads elt payload_snap ] s2
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 =
        [ &uf'1 <- { uf'1 with current = { t_UF__0 = { (uf'1.current).t_UF__0 with t_UFInner__payloads = _42 } } } ] s1
      | s1 = [ &_44 <- [%#sunion_find_cpp'2] Map.set ((uf'1.current).t_UF__0).t_UFInner__roots elt elt ] s2
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 = [ &uf'1 <- { uf'1 with current = { t_UF__0 = { (uf'1.current).t_UF__0 with t_UFInner__roots = _44 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'9 uf'1} s2
      | s2 = -{resolve'5 uf'1}- s3
      | s3 = bb21 ]
    | bb21 = s0 [ s0 = new'1 {_18} (fun (_ret: ()) -> [ &_17 <- _ret ] s1) | s1 = bb22 ]
    | bb22 = s0 [ s0 = [ &_0 <- elt ] s1 | s1 = bb23 ]
    | bb23 = return''0 {_0} ]
    [ & _0: t_Elem = Any.any_l ()
    | & uf'0: MutBorrow.t t_UF = uf
    | & payload'0: t_T = payload
    | & payload_snap: t_T = Any.any_l ()
    | & ptr'0: Opaque.ptr = Any.any_l ()
    | & perm: t_PtrOwn = Any.any_l ()
    | & _11: tuple = Any.any_l ()
    | & _12: t_Node = Any.any_l ()
    | & _13: t_PeanoInt = Any.any_l ()
    | & elt: t_Elem = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: () = Any.any_l ()
    | & perm'0: t_PtrOwn = Any.any_l ()
    | & uf'1: MutBorrow.t t_UF = Any.any_l ()
    | & _21: tuple'0 = Any.any_l ()
    | & _22: t_PtrOwn = Any.any_l ()
    | & _24: MutBorrow.t t_UF = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _30: t_Elem = Any.any_l ()
    | & other_perm: t_PtrOwn = Any.any_l ()
    | & _33: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _34: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _36: t_Option = Any.any_l ()
    | & _37: MutBorrow.t t_FMap = Any.any_l ()
    | & _40: Fset.fset t_Elem = Any.any_l ()
    | & _42: Map.map t_Elem t_T = Any.any_l ()
    | & _44: Map.map t_Elem t_Elem = Any.any_l () ])
    [ return''0 (result: t_Elem) -> {[@expl:make ensures #0] [%#sunion_find_cpp'5] not in_domain uf.current result}
      {[@expl:make ensures #1] [%#sunion_find_cpp'6] domain (fin uf) = insert'0 (domain uf.current) result}
      {[@expl:make ensures #2] [%#sunion_find_cpp'7] roots_map (fin uf) = Map.set (roots_map uf.current) result result}
      {[@expl:make ensures #3] [%#sunion_find_cpp'8] payloads_map (fin uf)
      = Map.set (payloads_map uf.current) result payload}
      (! return' {result}) ]
end
module M_union_find_cpp__implementation__find [#"union_find_cpp.rs" 202 4 202 71]
  let%span sunion_find_cpp = "union_find_cpp.rs" 202 23 202 25
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 199 4 199 35
  let%span sunion_find_cpp'1 = "union_find_cpp.rs" 200 14 200 37
  let%span sunion_find_cpp'2 = "union_find_cpp.rs" 201 4 201 30
  let%span sunion_find_cpp'3 = "union_find_cpp.rs" 94 8 94 22
  let%span sunion_find_cpp'4 = "union_find_cpp.rs" 117 8 117 22
  let%span sunion_find_cpp'5 = "union_find_cpp.rs" 141 16 143 64
  let%span sunion_find_cpp'6 = "union_find_cpp.rs" 86 8 86 16
  let%span sunion_find_cpp'7 = "union_find_cpp.rs" 104 19 104 28
  let%span sunion_find_cpp'8 = "union_find_cpp.rs" 105 18 107 42
  let%span sunion_find_cpp'9 = "union_find_cpp.rs" 103 8 103 16
  let%span sunion_find_cpp'10 = "union_find_cpp.rs" 123 8 123 16
  let%span sunion_find_cpp'11 = "union_find_cpp.rs" 66 12 79 17
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 346 22 346 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 346 4 346 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 345 14 345 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 379 30 379 34
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 379 4 379 62
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 368 14 376 9
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 377 14 377 73
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 378 14 378 44
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 136 40 136 43
  let%span sptr_own'0 = "../../creusot-contracts/src/ghost/ptr_own.rs" 132 15 132 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ghost/ptr_own.rs" 136 4 136 69
  let%span sptr_own'2 = "../../creusot-contracts/src/ghost/ptr_own.rs" 133 14 133 35
  let%span sptr_own'3 = "../../creusot-contracts/src/ghost/ptr_own.rs" 166 40 166 43
  let%span sptr_own'4 = "../../creusot-contracts/src/ghost/ptr_own.rs" 161 15 161 31
  let%span sptr_own'5 = "../../creusot-contracts/src/ghost/ptr_own.rs" 166 4 166 77
  let%span sptr_own'6 = "../../creusot-contracts/src/ghost/ptr_own.rs" 162 14 162 35
  let%span sptr_own'7 = "../../creusot-contracts/src/ghost/ptr_own.rs" 163 14 163 39
  let%span sptr_own'8 = "../../creusot-contracts/src/ghost/ptr_own.rs" 164 14 164 38
  let%span sptr_own'9 = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 80 14 80 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 80 4 80 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 78 14 78 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 181 15 181 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 181 4 183 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 179 14 179 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 91 22 91 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 91 4 91 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 89 14 89 35
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 125 8 125 22
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Elem;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Elem t_T;
    t_UFInner__roots: Map.map t_Elem t_Elem }
  
  type t_UF = { t_UF__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Elem
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Elem t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_Option = [%#sfmap'7] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Elem) = [%#sfmap'8] get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#slogic] exists x: t_PtrOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_PtrOwn = [%#sfmap'12] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Elem) : t_PtrOwn = [%#sfmap'9] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  predicate invariant' [#"union_find_cpp.rs" 64 8 64 34] [@inline:trivial] (self: t_UF) =
    [%#sunion_find_cpp'11] forall e: t_Elem. contains (self.t_UF__0).t_UFInner__domain e
      -> contains'0 (self.t_UF__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UF__0).t_UFInner__perms e) = e.t_Elem__0
      /\ contains (self.t_UF__0).t_UFInner__domain (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UF__0).t_UFInner__roots (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UF__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UF__0).t_UFInner__perms e) with
        | C_Link e2 -> contains (self.t_UF__0).t_UFInner__domain e2
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e <> e
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e = index_logic'1 (self.t_UF__0).t_UFInner__roots e2
        | C_Root _ payload -> index_logic'1 (self.t_UF__0).t_UFInner__roots e = e
        /\ index_logic'2 (self.t_UF__0).t_UFInner__payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_0: t_Elem)
  
  axiom inv_axiom [@rewrite]: forall x: t_Elem [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own'9] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_FMap) =
    [%#sfmap'11] forall k: t_Elem. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_UFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots} -> inv'4 perms
        end
  
  predicate inv'6 (_0: t_UF)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UF [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UF__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UF) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'7 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UF [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sghost'10] inv'7 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'8 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UF [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sinvariant'0] inv'8 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'9 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_UF [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sinvariant'0] inv'7 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_UF [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref (self: MutBorrow.t t_UF) (return' (x: MutBorrow.t t_UF)) =
    {[@expl:deref 'self' type invariant] [%#sghost] inv'9 self}
    any
    [ return''0 (result: MutBorrow.t t_UF) -> {[%#sghost'0] inv'10 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''7 [@inline:trivial] (self: t_FMap) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'11 (_0: t_FMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_FMap [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: t_PtrOwn) = [%#sinvariant'0] inv'3 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_0: t_PtrOwn)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate inv'13 (_0: t_Option'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'12 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Elem) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'11 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'13 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'13 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any [ return''0 (result: t_PtrOwn) -> {inv'12 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  predicate invariant''9 [@inline:trivial] (self: t_PtrOwn) = [%#sghost'10] inv'12 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'14 (_0: t_PtrOwn)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_PtrOwn [inv'14 x]. inv'14 x = invariant''9 x
  
  let rec new (x: t_PtrOwn) (return' (x'0: t_PtrOwn)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'12 x}
    any [ return''0 (result: t_PtrOwn) -> {[%#sghost'3] inv'14 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  predicate invariant''10 [@inline:trivial] (self: t_Node) = [%#sinvariant'0] inv'1 self
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'15 (_0: t_Node)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Node [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return' (x: t_Node)) =
    {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'14 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any
    [ return''0 (result: t_Node) -> {[%#sptr_own'1] inv'15 result}
      {[%#sptr_own'2] result = val' own}
      (! return' {result}) ]
  
  let rec v_Link (input: t_Node) (ret (field_0: t_Elem)) = any
    [ good (field_0: t_Elem) -> {C_Link field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Elem [C_Link field_0: t_Node]. C_Link field_0 <> input} (! {false} any) ]
  
  predicate invariant''11 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'16 (_0: MutBorrow.t (MutBorrow.t t_UF))
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UF) [inv'16 x]. inv'16 x = invariant''11 x
  
  predicate invariant''12 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'17 (_0: MutBorrow.t (MutBorrow.t t_UF))
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UF) [inv'17 x]. inv'17 x = invariant''12 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UF)) (return' (x: MutBorrow.t (MutBorrow.t t_UF))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'16 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UF)) -> {[%#sghost'6] inv'17 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (MutBorrow.t t_UF)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_UF) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  let rec new'0 (x: MutBorrow.t t_UF) (return' (x'0: MutBorrow.t t_UF)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'7 x}
    any
    [ return''0 (result: MutBorrow.t t_UF) -> {[%#sghost'3] inv'8 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate invariant''13 [@inline:trivial] (self: MutBorrow.t t_UFInner) =
    [%#sinvariant] inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'18 (_0: MutBorrow.t t_UFInner)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_UFInner [inv'18 x]. inv'18 x = invariant''13 x
  
  predicate invariant''14 [@inline:trivial] (self: MutBorrow.t t_UFInner) = [%#sghost'10] inv'18 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'19 (_0: MutBorrow.t t_UFInner)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_UFInner [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec new'1 (x: MutBorrow.t t_UFInner) (return' (x'0: MutBorrow.t t_UFInner)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'18 x}
    any
    [ return''0 (result: MutBorrow.t t_UFInner) -> {[%#sghost'3] inv'19 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate invariant''15 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    [%#sinvariant] inv'19 self.current /\ inv'19 self.final
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'20 (_0: MutBorrow.t (MutBorrow.t t_UFInner))
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UFInner) [inv'20 x]. inv'20 x = invariant''15 x
  
  predicate invariant''16 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    [%#sinvariant] inv'18 self.current /\ inv'18 self.final
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'21 (_0: MutBorrow.t (MutBorrow.t t_UFInner))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UFInner) [inv'21 x]. inv'21 x = invariant''16 x
  
  let rec deref_mut'0 (self: MutBorrow.t (MutBorrow.t t_UFInner)) (return' (x: MutBorrow.t (MutBorrow.t t_UFInner))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'20 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UFInner)) -> {[%#sghost'6] inv'21 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_PtrOwn)
  
  predicate invariant''17 [@inline:trivial] (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'22 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'22 x]. inv'22 x = invariant''17 x
  
  predicate invariant''18 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'23 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'23 x]. inv'23 x = invariant''18 x
  
  predicate inv'24 (_0: t_Option'1)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_Option'1 [inv'24 x]. inv'24 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'23 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'10] len self >= 0
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Elem) (return' (x: t_Option'1)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'2] inv'22 self}
    any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'3] inv'24 result}
      {[%#sfmap'4] if contains'0 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'0 self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'5] forall k: t_Elem. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'6] len self.current = len self.final}
      (! return' {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return' (x: MutBorrow.t t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'24 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result: MutBorrow.t t_PtrOwn) -> {inv'23 result}
      {[%#soption'1] C_Some'1 result = self_}
      (! return' {result}) ]
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t (MutBorrow.t t_UFInner)) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  predicate invariant''19 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = [%#sghost'10] inv'23 self
  
  meta "rewrite_def" predicate invariant''19
  
  predicate inv'25 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'24 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'25 x]. inv'25 x = invariant''19 x
  
  let rec new'2 (x: MutBorrow.t t_PtrOwn) (return' (x'0: MutBorrow.t t_PtrOwn)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'23 x}
    any
    [ return''0 (result: MutBorrow.t t_PtrOwn) -> {[%#sghost'3] inv'25 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate invariant''20 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''20
  
  predicate inv'26 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'25 [@rewrite]: forall x: MutBorrow.t t_Node [inv'26 x]. inv'26 x = invariant''20 x
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PtrOwn) : t_PtrOwn = [%#sghost'8] self.final
  
  meta "rewrite_def" function fin
  
  let rec as_mut (ptr'0: Opaque.ptr) (own: MutBorrow.t t_PtrOwn) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'own' type invariant] [%#sptr_own'3] inv'25 own}
    {[@expl:as_mut requires] [%#sptr_own'4] ptr'0 = ptr own.current}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {[%#sptr_own'5] inv'26 result}
      {[%#sptr_own'6] result.current = val' own.current}
      {[%#sptr_own'7] ptr (fin own) = ptr own.current}
      {[%#sptr_own'8] val' (fin own) = result.final}
      (! return' {result}) ]
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'5 _0
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (self: MutBorrow.t t_UFInner) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_0: MutBorrow.t t_UFInner) = resolve'7 _0
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 [@inline:trivial] (self: MutBorrow.t t_UFInner) = [%#sghost'9] resolve'8 self
  
  meta "rewrite_def" predicate resolve'9
  
  predicate resolve'10 [@inline:trivial] (_0: MutBorrow.t t_UFInner) = resolve'9 _0
  
  meta "rewrite_def" predicate resolve'10
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sghost'9] resolve'2 self
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_0: MutBorrow.t t_UF) = resolve'11 _0
  
  meta "rewrite_def" predicate resolve'12
  
  function domain [#"union_find_cpp.rs" 89 8 89 44] (self: t_UF) : Fset.fset t_Elem =
    [%#sunion_find_cpp'6] (self.t_UF__0).t_UFInner__domain
  
  predicate in_domain [#"union_find_cpp.rs" 95 8 95 50] (self: t_UF) (e: t_Elem) =
    [%#sunion_find_cpp'3] contains (domain self) e
  
  function roots_map [#"union_find_cpp.rs" 109 8 109 59] (self: t_UF) : Map.map t_Elem t_Elem =
    [%#sunion_find_cpp'9] (self.t_UF__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UF. ([%#sunion_find_cpp'7] inv'6 self)
      -> ([%#sunion_find_cpp'8] forall e: t_Elem. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find_cpp.rs" 118 8 118 48] (self: t_UF) (e: t_Elem) : t_Elem =
    [%#sunion_find_cpp'4] index_logic'1 (roots_map self) e
  
  function payloads_map [#"union_find_cpp.rs" 124 8 124 56] (self: t_UF) : Map.map t_Elem t_T =
    [%#sunion_find_cpp'10] (self.t_UF__0).t_UFInner__payloads
  
  predicate unchanged [#"union_find_cpp.rs" 139 8 139 43] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'5] domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find [#"union_find_cpp.rs" 202 4 202 71] (uf: MutBorrow.t t_UF) (elem: t_Elem) (return' (x: t_Elem)) =
    {[@expl:find 'uf' type invariant] [%#sunion_find_cpp] inv'8 uf}
    {[@expl:find requires] [%#sunion_find_cpp'0] in_domain uf.current elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref {uf'0} (fun (_ret: MutBorrow.t t_UF) -> [ &_9 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_12 <- elem'0 ] s1
      | s1 = get_ghost {((_9.current).t_UF__0).t_UFInner__perms} {_12} (fun (_ret: t_Option'0) -> [ &_7 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_7} (fun (_ret: t_PtrOwn) -> [ &__temp <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {__temp} (fun (_ret: t_PtrOwn) -> [ &perm <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = as_ref {elem'0.t_Elem__0} {perm} (fun (_ret: t_Node) -> [ &_15 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_15 = C_Root x0 x1} (! bb9) | br1 (x0: t_Elem) -> {_15 = C_Link x0} (! bb8) ]
    | bb8 = s0
      [ s0 = v_Link {_15} (fun (r0: t_Elem) -> [ &e <- r0 ] s1)
      | s1 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UF> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) ->
            [ &_26 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s2)
      | s2 = deref_mut {_26} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) -> [ &_25 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'6 (_25.current).current}
        MutBorrow.borrow_mut <t_UF> {(_25.current).current}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_24 <- _ret ] -{inv'6 _ret.final}-
            [ &_25 <- { _25 with current = { _25.current with current = _ret.final } } ] s1)
      | s1 = {inv'6 _24.current}
        MutBorrow.borrow_final <t_UF> {_24.current} {MutBorrow.get_id _24}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_23 <- _ret ] -{inv'6 _ret.final}-
            [ &_24 <- { _24 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'17 _25} s3
      | s3 = -{resolve'0 _25}- s4
      | s4 = {[@expl:type invariant] inv'7 _24} s5
      | s5 = -{resolve'2 _24}- s6
      | s6 = {inv'6 _23.current}
        MutBorrow.borrow_final <t_UF> {_23.current} {MutBorrow.get_id _23}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_22 <- _ret ] -{inv'6 _ret.final}-
            [ &_23 <- { _23 with current = _ret.final } ] s7)
      | s7 = new'0 {_22} (fun (_ret: MutBorrow.t t_UF) -> [ &_21 <- _ret ] s8)
      | s8 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'7 _23} s1
      | s1 = -{resolve'2 _23}- s2
      | s2 = find {_21} {e} (fun (_ret: t_Elem) -> [ &root'0 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UF> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) ->
            [ &_30 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_30} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) -> [ &_29 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = {inv'5 ((_29.current).current).t_UF__0}
        MutBorrow.borrow_mut <t_UFInner> {((_29.current).current).t_UF__0}
          (fun (_ret: MutBorrow.t t_UFInner) ->
            [ &__temp'0 <- _ret ] -{inv'5 _ret.final}-
            [ &_29 <- { _29 with current = { _29.current with current = { t_UF__0 = _ret.final } } } ] s1)
      | s1 = new'1 {__temp'0} (fun (_ret: MutBorrow.t t_UFInner) -> [ &uf'1 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {inv'19 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_37 <- _ret ] -{inv'19 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_37} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_36 <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = [ &_39 <- elem'0 ] s1
      | s1 = {inv'4 ((_36.current).current).t_UFInner__perms}
        MutBorrow.borrow_mut <t_FMap> {((_36.current).current).t_UFInner__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_35 <- _ret ] -{inv'4 _ret.final}-
            [ &_36 <- { _36 with current = { _36.current with current = { (_36.current).current with t_UFInner__perms = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_35} {_39} (fun (_ret: t_Option'1) -> [ &_34 <- _ret ] s3)
      | s3 = bb16 ]
    | bb16 = s0 [ s0 = unwrap'0 {_34} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &__temp'1 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'21 _36} s1
      | s1 = -{resolve'4 _36}- s2
      | s2 = new'2 {__temp'1} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &mut_perm <- _ret ] s3)
      | s3 = bb18 ]
    | bb18 = s0
      [ s0 = [ &_43 <- C_Link root'0 ] s1
      | s1 = as_mut {elem'0.t_Elem__0} {mut_perm} (fun (_ret: MutBorrow.t t_Node) -> [ &_45 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv'1 _45.current} s1
      | s1 = [ &_45 <- { _45 with current = _43 } ] s2
      | s2 = {[@expl:type invariant] inv'26 _45} s3
      | s3 = -{resolve'6 _45}- s4
      | s4 = {[@expl:type invariant] inv'19 uf'1} s5
      | s5 = -{resolve'10 uf'1}- s6
      | s6 = {[@expl:type invariant] inv'17 _29} s7
      | s7 = -{resolve'0 _29}- s8
      | s8 = {[@expl:type invariant] inv'8 uf'0} s9
      | s9 = -{resolve'12 uf'0}- s10
      | s10 = bb22 ]
    | bb22 = s0 [ s0 = [ &_0 <- root'0 ] s1 | s1 = bb23 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'8 uf'0} s1
      | s1 = -{resolve'12 uf'0}- s2
      | s2 = [ &_0 <- elem'0 ] s3
      | s3 = bb23 ]
    | bb23 = return''0 {_0} ]
    [ & _0: t_Elem = Any.any_l ()
    | & uf'0: MutBorrow.t t_UF = uf
    | & elem'0: t_Elem = elem
    | & __temp: t_PtrOwn = Any.any_l ()
    | & _7: t_Option'0 = Any.any_l ()
    | & _9: MutBorrow.t t_UF = Any.any_l ()
    | & _12: t_Elem = Any.any_l ()
    | & perm: t_PtrOwn = Any.any_l ()
    | & _15: t_Node = Any.any_l ()
    | & e: t_Elem = Any.any_l ()
    | & root'0: t_Elem = Any.any_l ()
    | & _21: MutBorrow.t t_UF = Any.any_l ()
    | & _22: MutBorrow.t t_UF = Any.any_l ()
    | & _23: MutBorrow.t t_UF = Any.any_l ()
    | & _24: MutBorrow.t t_UF = Any.any_l ()
    | & _25: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & _26: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & __temp'0: MutBorrow.t t_UFInner = Any.any_l ()
    | & _29: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & _30: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & uf'1: MutBorrow.t t_UFInner = Any.any_l ()
    | & __temp'1: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _34: t_Option'1 = Any.any_l ()
    | & _35: MutBorrow.t t_FMap = Any.any_l ()
    | & _36: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _37: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _39: t_Elem = Any.any_l ()
    | & mut_perm: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _43: t_Node = Any.any_l ()
    | & _45: MutBorrow.t t_Node = Any.any_l () ])
    [ return''0 (result: t_Elem) -> {[@expl:find ensures #0] [%#sunion_find_cpp'1] result = root uf.current elem}
      {[@expl:find ensures #1] [%#sunion_find_cpp'2] unchanged uf}
      (! return' {result}) ]
end
module M_union_find_cpp__implementation__get [#"union_find_cpp.rs" 223 4 223 57]
  let%span sunion_find_cpp = "union_find_cpp.rs" 223 18 223 20
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 220 4 220 35
  let%span sunion_find_cpp'1 = "union_find_cpp.rs" 221 15 221 36
  let%span sunion_find_cpp'2 = "union_find_cpp.rs" 223 55 223 57
  let%span sunion_find_cpp'3 = "union_find_cpp.rs" 222 14 222 41
  let%span sunion_find_cpp'4 = "union_find_cpp.rs" 94 8 94 22
  let%span sunion_find_cpp'5 = "union_find_cpp.rs" 117 8 117 22
  let%span sunion_find_cpp'6 = "union_find_cpp.rs" 132 8 132 22
  let%span sunion_find_cpp'7 = "union_find_cpp.rs" 86 8 86 16
  let%span sunion_find_cpp'8 = "union_find_cpp.rs" 104 19 104 28
  let%span sunion_find_cpp'9 = "union_find_cpp.rs" 105 18 107 42
  let%span sunion_find_cpp'10 = "union_find_cpp.rs" 103 8 103 16
  let%span sunion_find_cpp'11 = "union_find_cpp.rs" 123 8 123 16
  let%span sunion_find_cpp'12 = "union_find_cpp.rs" 66 12 79 17
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 346 22 346 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 346 4 346 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 345 14 345 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 136 40 136 43
  let%span sptr_own'0 = "../../creusot-contracts/src/ghost/ptr_own.rs" 132 15 132 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ghost/ptr_own.rs" 136 4 136 69
  let%span sptr_own'2 = "../../creusot-contracts/src/ghost/ptr_own.rs" 133 14 133 35
  let%span sptr_own'3 = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 80 14 80 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 80 4 80 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 78 14 78 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 181 15 181 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 181 4 183 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 179 14 179 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Elem;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Elem t_T;
    t_UFInner__roots: Map.map t_Elem t_Elem }
  
  type t_UF = { t_UF__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Elem
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Elem t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_Option = [%#sfmap'2] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Elem) = [%#sfmap'3] get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#slogic] exists x: t_PtrOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_PtrOwn = [%#sfmap'6] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Elem) : t_PtrOwn = [%#sfmap'4] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  predicate invariant' [#"union_find_cpp.rs" 64 8 64 34] [@inline:trivial] (self: t_UF) =
    [%#sunion_find_cpp'12] forall e: t_Elem. contains (self.t_UF__0).t_UFInner__domain e
      -> contains'0 (self.t_UF__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UF__0).t_UFInner__perms e) = e.t_Elem__0
      /\ contains (self.t_UF__0).t_UFInner__domain (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UF__0).t_UFInner__roots (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UF__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UF__0).t_UFInner__perms e) with
        | C_Link e2 -> contains (self.t_UF__0).t_UFInner__domain e2
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e <> e
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e = index_logic'1 (self.t_UF__0).t_UFInner__roots e2
        | C_Root _ payload -> index_logic'1 (self.t_UF__0).t_UFInner__roots e = e
        /\ index_logic'2 (self.t_UF__0).t_UFInner__payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_0: t_Elem)
  
  axiom inv_axiom [@rewrite]: forall x: t_Elem [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own'3] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_FMap) =
    [%#sfmap'5] forall k: t_Elem. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_UFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots} -> inv'4 perms
        end
  
  predicate inv'6 (_0: t_UF)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UF [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UF__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 [@inline:trivial] (self: t_UF) = [%#sinvariant] inv'6 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'7 (_0: t_UF)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UF [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_UF) = [%#sghost'5] inv'7 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'8 (_0: t_UF)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UF [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: t_UF) = [%#sinvariant] inv'8 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'9 (_0: t_UF)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_UF [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: t_UF) = [%#sinvariant] inv'7 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_0: t_UF)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_UF [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref (self: t_UF) (return' (x: t_UF)) = {[@expl:deref 'self' type invariant] [%#sghost] inv'9 self}
    any [ return''0 (result: t_UF) -> {[%#sghost'0] inv'10 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PtrOwn
  
  predicate invariant''7 [@inline:trivial] (self: t_FMap) = [%#sinvariant] inv'4 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'11 (_0: t_FMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_FMap [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: t_PtrOwn) = [%#sinvariant] inv'3 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_0: t_PtrOwn)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PtrOwn [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate inv'13 (_0: t_Option'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'12 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PtrOwn t_PtrOwn) : t_Option'0 = [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Elem) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'11 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'13 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PtrOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'13 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any [ return''0 (result: t_PtrOwn) -> {inv'12 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  predicate invariant''9 [@inline:trivial] (self: t_PtrOwn) = [%#sghost'5] inv'12 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'14 (_0: t_PtrOwn)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_PtrOwn [inv'14 x]. inv'14 x = invariant''9 x
  
  let rec new (x: t_PtrOwn) (return' (x'0: t_PtrOwn)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'12 x}
    any [ return''0 (result: t_PtrOwn) -> {[%#sghost'3] inv'14 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  predicate invariant''10 [@inline:trivial] (self: t_Node) = [%#sinvariant] inv'1 self
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'15 (_0: t_Node)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Node [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return' (x: t_Node)) =
    {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'14 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any
    [ return''0 (result: t_Node) -> {[%#sptr_own'1] inv'15 result}
      {[%#sptr_own'2] result = val' own}
      (! return' {result}) ]
  
  let rec v_Root (input: t_Node) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {C_Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [C_Root rank payload: t_Node]. C_Root rank payload <> input}
      (! {false}
      any) ]
  
  function domain [#"union_find_cpp.rs" 89 8 89 44] (self: t_UF) : Fset.fset t_Elem =
    [%#sunion_find_cpp'7] (self.t_UF__0).t_UFInner__domain
  
  predicate in_domain [#"union_find_cpp.rs" 95 8 95 50] (self: t_UF) (e: t_Elem) =
    [%#sunion_find_cpp'4] contains (domain self) e
  
  function roots_map [#"union_find_cpp.rs" 109 8 109 59] (self: t_UF) : Map.map t_Elem t_Elem =
    [%#sunion_find_cpp'10] (self.t_UF__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UF. ([%#sunion_find_cpp'8] inv'6 self)
      -> ([%#sunion_find_cpp'9] forall e: t_Elem. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find_cpp.rs" 118 8 118 48] (self: t_UF) (e: t_Elem) : t_Elem =
    [%#sunion_find_cpp'5] index_logic'1 (roots_map self) e
  
  predicate invariant''11 [@inline:trivial] (self: t_T) = [%#sinvariant] inv'0 self
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'16 (_0: t_T)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_T [inv'16 x]. inv'16 x = invariant''11 x
  
  function payloads_map [#"union_find_cpp.rs" 124 8 124 56] (self: t_UF) : Map.map t_Elem t_T =
    [%#sunion_find_cpp'11] (self.t_UF__0).t_UFInner__payloads
  
  function payload [#"union_find_cpp.rs" 133 8 133 45] (self: t_UF) (e: t_Elem) : t_T =
    [%#sunion_find_cpp'6] index_logic'2 (payloads_map self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get'0 [#"union_find_cpp.rs" 223 4 223 57] (uf: t_UF) (elem: t_Elem) (return' (x: t_T)) =
    {[@expl:get 'uf' type invariant] [%#sunion_find_cpp] inv'8 uf}
    {[@expl:get requires #0] [%#sunion_find_cpp'0] in_domain uf elem}
    {[@expl:get requires #1] [%#sunion_find_cpp'1] root uf elem = elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref {uf'0} (fun (_ret: t_UF) -> [ &_10 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_13 <- elem'0 ] s1
      | s1 = get_ghost {(_10.t_UF__0).t_UFInner__perms} {_13} (fun (_ret: t_Option'0) -> [ &_8 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_8} (fun (_ret: t_PtrOwn) -> [ &_7 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_7} (fun (_ret: t_PtrOwn) -> [ &perm <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = as_ref {elem'0.t_Elem__0} {perm} (fun (_ret: t_Node) -> [ &_14 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_14 = C_Root x0 x1} (! bb8) | br1 (x0: t_Elem) -> {_14 = C_Link x0} (! bb6) ]
    | bb6 = {false} any
    | bb8 = s0
      [ s0 = v_Root {_14} (fun (rrank: t_PeanoInt) (rpayload: t_T) -> [ &payload'0 <- rpayload ] s1)
      | s1 = [ &_0 <- payload'0 ] s2
      | s2 = return''0 {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & uf'0: t_UF = uf
    | & elem'0: t_Elem = elem
    | & perm: t_PtrOwn = Any.any_l ()
    | & _7: t_PtrOwn = Any.any_l ()
    | & _8: t_Option'0 = Any.any_l ()
    | & _10: t_UF = Any.any_l ()
    | & _13: t_Elem = Any.any_l ()
    | & _14: t_Node = Any.any_l ()
    | & payload'0: t_T = Any.any_l () ])
    [ return''0 (result: t_T) -> {[@expl:get result type invariant] [%#sunion_find_cpp'2] inv'16 result}
      {[@expl:get ensures] [%#sunion_find_cpp'3] result = payload uf elem}
      (! return' {result}) ]
end
module M_union_find_cpp__implementation__link [#"union_find_cpp.rs" 241 4 241 76]
  let%span sunion_find_cpp = "union_find_cpp.rs" 245 29 245 35
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 263 42 263 96
  let%span sunion_find_cpp'1 = "union_find_cpp.rs" 270 42 270 96
  let%span sunion_find_cpp'2 = "union_find_cpp.rs" 241 19 241 21
  let%span sunion_find_cpp'3 = "union_find_cpp.rs" 232 4 232 51
  let%span sunion_find_cpp'4 = "union_find_cpp.rs" 233 15 233 49
  let%span sunion_find_cpp'5 = "union_find_cpp.rs" 234 4 234 64
  let%span sunion_find_cpp'6 = "union_find_cpp.rs" 235 14 235 58
  let%span sunion_find_cpp'7 = "union_find_cpp.rs" 236 14 236 42
  let%span sunion_find_cpp'8 = "union_find_cpp.rs" 237 14 239 98
  let%span sunion_find_cpp'9 = "union_find_cpp.rs" 17 18 17 69
  let%span sunion_find_cpp'10 = "union_find_cpp.rs" 94 8 94 22
  let%span sunion_find_cpp'11 = "union_find_cpp.rs" 117 8 117 22
  let%span sunion_find_cpp'12 = "union_find_cpp.rs" 150 24 150 60
  let%span sunion_find_cpp'13 = "union_find_cpp.rs" 156 24 156 72
  let%span sunion_find_cpp'14 = "union_find_cpp.rs" 86 8 86 16
  let%span sunion_find_cpp'15 = "union_find_cpp.rs" 104 19 104 28
  let%span sunion_find_cpp'16 = "union_find_cpp.rs" 105 18 107 42
  let%span sunion_find_cpp'17 = "union_find_cpp.rs" 103 8 103 16
  let%span sunion_find_cpp'18 = "union_find_cpp.rs" 123 8 123 16
  let%span sunion_find_cpp'19 = "union_find_cpp.rs" 24 8 24 24
  let%span sunion_find_cpp'20 = "union_find_cpp.rs" 66 12 79 17
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 51 8 51 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 409 32 409 36
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 406 4 406 36
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 409 4 409 69
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 407 14 407 47
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 408 14 408 85
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 379 30 379 34
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 379 4 379 62
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 368 14 376 9
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 377 14 377 73
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 378 14 378 44
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 83 14 83 43
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 84 14 84 84
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 68 14 68 46
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 88
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'17 = "../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 208 26 208 30
  let%span sptr_own'0 = "../../creusot-contracts/src/ghost/ptr_own.rs" 208 48 208 52
  let%span sptr_own'1 = "../../creusot-contracts/src/ghost/ptr_own.rs" 205 14 205 64
  let%span sptr_own'2 = "../../creusot-contracts/src/ghost/ptr_own.rs" 206 14 206 28
  let%span sptr_own'3 = "../../creusot-contracts/src/ghost/ptr_own.rs" 166 40 166 43
  let%span sptr_own'4 = "../../creusot-contracts/src/ghost/ptr_own.rs" 161 15 161 31
  let%span sptr_own'5 = "../../creusot-contracts/src/ghost/ptr_own.rs" 166 4 166 77
  let%span sptr_own'6 = "../../creusot-contracts/src/ghost/ptr_own.rs" 162 14 162 35
  let%span sptr_own'7 = "../../creusot-contracts/src/ghost/ptr_own.rs" 163 14 163 39
  let%span sptr_own'8 = "../../creusot-contracts/src/ghost/ptr_own.rs" 164 14 164 38
  let%span sptr_own'9 = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 91 22 91 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 91 4 91 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 89 14 89 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 181 15 181 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 181 4 183 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 179 14 179 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 201 14 201 29
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 228 17 228 21
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 228 4 228 46
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 226 14 226 36
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 227 14 227 36
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 125 8 125 22
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span speano = "../../creusot-contracts/src/peano.rs" 149 14 149 38
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 41 4 41 26
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span ssnapshot = "../../creusot-contracts/src/snapshot.rs" 119 14 119 30
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 240 16 246 17
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Elem;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Elem t_T;
    t_UFInner__roots: Map.map t_Elem t_Elem }
  
  type t_UF = { t_UF__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Elem
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Elem t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_Option = [%#sfmap'15] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Elem) = [%#sfmap'9] get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#slogic] exists x: t_PtrOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'3] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_PtrOwn = [%#sfmap'18] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Elem) : t_PtrOwn = [%#sfmap'12] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  predicate invariant' [#"union_find_cpp.rs" 64 8 64 34] [@inline:trivial] (self: t_UF) =
    [%#sunion_find_cpp'20] forall e: t_Elem. contains (self.t_UF__0).t_UFInner__domain e
      -> contains'0 (self.t_UF__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UF__0).t_UFInner__perms e) = e.t_Elem__0
      /\ contains (self.t_UF__0).t_UFInner__domain (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UF__0).t_UFInner__roots (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UF__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UF__0).t_UFInner__perms e) with
        | C_Link e2 -> contains (self.t_UF__0).t_UFInner__domain e2
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e <> e
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e = index_logic'1 (self.t_UF__0).t_UFInner__roots e2
        | C_Root _ payload -> index_logic'1 (self.t_UF__0).t_UFInner__roots e = e
        /\ index_logic'2 (self.t_UF__0).t_UFInner__payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_0: t_Elem)
  
  axiom inv_axiom [@rewrite]: forall x: t_Elem [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own'9] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_FMap) =
    [%#sfmap'17] forall k: t_Elem. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_UFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots} -> inv'4 perms
        end
  
  predicate inv'6 (_0: t_UF)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UF [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UF__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UF) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'7 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UF [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sghost'12] inv'7 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'8 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UF [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'9 (_0: MutBorrow.t (MutBorrow.t t_UF))
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UF) [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_0: MutBorrow.t (MutBorrow.t t_UF))
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UF) [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UF)) (return' (x: MutBorrow.t (MutBorrow.t t_UF))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'9 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UF)) -> {[%#sghost'0] inv'10 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_UFInner) =
    [%#sinvariant] inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'11 (_0: MutBorrow.t t_UFInner)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_UFInner [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_UFInner) = [%#sghost'12] inv'11 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_0: MutBorrow.t t_UFInner)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_UFInner [inv'12 x]. inv'12 x = invariant''8 x
  
  let rec new (x: MutBorrow.t t_UFInner) (return' (x'0: MutBorrow.t t_UFInner)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'11 x}
    any
    [ return''0 (result: MutBorrow.t t_UFInner) -> {[%#sghost'3] inv'12 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  function deep_model [#"union_find_cpp.rs" 25 8 25 36] [@inline:trivial] (self: t_Elem) : UInt64.t =
    [%#sunion_find_cpp'19] Opaque.addr_logic_u64 self.t_Elem__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Elem) : UInt64.t = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  let rec eq (self: t_Elem) (other: t_Elem) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#sunion_find_cpp'9] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  let rec into_ghost (self: bool) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#ssnapshot] result = self} (! return' {result}) ]
  
  let rec into_inner (self: bool) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#sghost'5] result = self} (! return' {result}) ]
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    [%#sinvariant] inv'12 self.current /\ inv'12 self.final
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_0: MutBorrow.t (MutBorrow.t t_UFInner))
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UFInner) [inv'13 x]. inv'13 x = invariant''9 x
  
  predicate invariant''10 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    [%#sinvariant] inv'11 self.current /\ inv'11 self.final
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'14 (_0: MutBorrow.t (MutBorrow.t t_UFInner))
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UFInner) [inv'14 x]. inv'14 x = invariant''10 x
  
  let rec deref_mut'0 (self: MutBorrow.t (MutBorrow.t t_UFInner)) (return' (x: MutBorrow.t (MutBorrow.t t_UFInner))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'13 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UFInner)) -> {[%#sghost'0] inv'14 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  type tuple = { _p0: MutBorrow.t t_PtrOwn; _p1: MutBorrow.t t_FMap }
  
  predicate invariant''11 [@inline:trivial] (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'15 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate invariant''12 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'16 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'16 x]. inv'16 x = invariant''12 x
  
  predicate inv'17 (_0: tuple)
  
  axiom inv_axiom'16 [@rewrite]: forall x: tuple [inv'17 x]. inv'17 x
      = (let {_p0 = x0; _p1 = x1} = x in inv'16 x0 /\ inv'15 x1)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'16] len self >= 0
  
  function remove (self: t_FMap) (k: t_Elem) : t_FMap
  
  axiom remove_spec: forall self: t_FMap, k: t_Elem. [%#sfmap'10] view (remove self k) = Map.set (view self) k (C_None)
  
  axiom remove_spec'0: forall self: t_FMap, k: t_Elem. [%#sfmap'11] len (remove self k)
      = (if contains'0 self k then len self - 1 else len self)
  
  function insert (self: t_FMap) (k: t_Elem) (v: t_PtrOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Elem, v: t_PtrOwn. [%#sfmap'13] view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Elem, v: t_PtrOwn. [%#sfmap'14] len (insert self k v)
      = (if contains'0 self k then len self else len self + 1)
  
  let rec split_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Elem) (return' (x: tuple)) =
    {[@expl:split_mut_ghost 'self' type invariant] [%#sfmap] inv'15 self}
    {[@expl:split_mut_ghost requires] [%#sfmap'0] contains'0 self.current key}
    any
    [ return''0 (result: tuple) -> {[%#sfmap'1] inv'17 result}
      {[%#sfmap'2] (result._p1).current = remove self.current key}
      {[%#sfmap'3] index_logic'0 self.current key = (result._p0).current
      /\ self.final = insert (result._p1).final key (result._p0).final}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner)) =
    [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (MutBorrow.t t_UFInner)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_PtrOwn)
  
  predicate inv'18 (_0: t_Option'0)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Option'0 [inv'18 x]. inv'18 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'16 a_0
        end
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Elem) (return' (x: t_Option'0)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'4] inv'15 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'5] inv'18 result}
      {[%#sfmap'6] if contains'0 self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains'0 self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap'7] forall k: t_Elem. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'8] len self.current = len self.final}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t t_PtrOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'18 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_PtrOwn) -> {inv'16 result}
      {[%#soption'1] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate invariant''13 [@inline:trivial] (self: t_PtrOwn) = [%#sinvariant'0] inv'3 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'19 (_0: t_PtrOwn)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_PtrOwn [inv'19 x]. inv'19 x = invariant''13 x
  
  let rec disjoint_lemma (own1: MutBorrow.t t_PtrOwn) (own2: t_PtrOwn) (return' (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] [%#sptr_own] inv'16 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#sptr_own'0] inv'19 own2}
    any
    [ return''0 (result: ()) -> {[%#sptr_own'1] Opaque.addr_logic_u64 (ptr own1.current)
      <> Opaque.addr_logic_u64 (ptr own2)}
      {[%#sptr_own'2] own1.current = own1.final}
      (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_PtrOwn) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_FMap) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_FMap) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_UFInner) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_0: MutBorrow.t t_UFInner) = resolve'5 _0
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (self: MutBorrow.t t_UFInner) = [%#sghost'11] resolve'6 self
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_0: MutBorrow.t t_UFInner) = resolve'7 _0
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'9
  
  predicate resolve'10 [@inline:trivial] (_0: MutBorrow.t (MutBorrow.t t_UF)) = resolve'9 _0
  
  meta "rewrite_def" predicate resolve'10
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_0: MutBorrow.t t_UF) = resolve'11 _0
  
  meta "rewrite_def" predicate resolve'12
  
  predicate resolve'13 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sghost'11] resolve'12 self
  
  meta "rewrite_def" predicate resolve'13
  
  predicate resolve'14 [@inline:trivial] (_0: MutBorrow.t t_UF) = resolve'13 _0
  
  meta "rewrite_def" predicate resolve'14
  
  let rec new'0 (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'4] result = x} (! return' {result}) ]
  
  predicate invariant''14 [@inline:trivial] (self: tuple) = [%#sghost'12] inv'17 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'20 (_0: tuple)
  
  axiom inv_axiom'19 [@rewrite]: forall x: tuple [inv'20 x]. inv'20 x = invariant''14 x
  
  let rec new'1 (x: tuple) (return' (x'0: tuple)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'17 x}
    any [ return''0 (result: tuple) -> {[%#sghost'3] inv'20 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  type tuple'0 = { _p0'0: MutBorrow.t t_PtrOwn; _p1'0: MutBorrow.t t_FMap }
  
  predicate invariant''15 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = [%#sghost'12] inv'16 self
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'21 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'21 x]. inv'21 x = invariant''15 x
  
  predicate invariant''16 [@inline:trivial] (self: MutBorrow.t t_FMap) = [%#sghost'12] inv'15 self
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'22 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'22 x]. inv'22 x = invariant''16 x
  
  predicate inv'23 (_0: tuple'0)
  
  axiom inv_axiom'22 [@rewrite]: forall x: tuple'0 [inv'23 x]. inv'23 x
      = (let {_p0'0 = x0; _p1'0 = x1} = x in inv'21 x0 /\ inv'22 x1)
  
  let rec split (self: tuple) (return' (x: tuple'0)) = {[@expl:split 'self' type invariant] [%#sghost'6] inv'20 self}
    any
    [ return''0 (result: tuple'0) -> {[%#sghost'7] inv'23 result}
      {[%#sghost'8] self._p0 = result._p0'0}
      {[%#sghost'9] self._p1 = result._p1'0}
      (! return' {result}) ]
  
  predicate invariant''17 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'24 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_Node [inv'24 x]. inv'24 x = invariant''17 x
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PtrOwn) : t_PtrOwn = [%#sghost'10] self.final
  
  meta "rewrite_def" function fin
  
  let rec as_mut (ptr'0: Opaque.ptr) (own: MutBorrow.t t_PtrOwn) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'own' type invariant] [%#sptr_own'3] inv'21 own}
    {[@expl:as_mut requires] [%#sptr_own'4] ptr'0 = ptr own.current}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {[%#sptr_own'5] inv'24 result}
      {[%#sptr_own'6] result.current = val' own.current}
      {[%#sptr_own'7] ptr (fin own) = ptr own.current}
      {[%#sptr_own'8] val' (fin own) = result.final}
      (! return' {result}) ]
  
  predicate resolve'15 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'15
  
  predicate resolve'16 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'15 _0
  
  meta "rewrite_def" predicate resolve'16
  
  predicate invariant''18 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap)) =
    [%#sinvariant] inv'22 self.current /\ inv'22 self.final
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'25 (_0: MutBorrow.t (MutBorrow.t t_FMap))
  
  axiom inv_axiom'24 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_FMap) [inv'25 x]. inv'25 x = invariant''18 x
  
  predicate invariant''19 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap)) =
    [%#sinvariant] inv'15 self.current /\ inv'15 self.final
  
  meta "rewrite_def" predicate invariant''19
  
  predicate inv'26 (_0: MutBorrow.t (MutBorrow.t t_FMap))
  
  axiom inv_axiom'25 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_FMap) [inv'26 x]. inv'26 x = invariant''19 x
  
  let rec deref_mut'1 (self: MutBorrow.t (MutBorrow.t t_FMap)) (return' (x: MutBorrow.t (MutBorrow.t t_FMap))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'25 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_FMap)) -> {[%#sghost'0] inv'26 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate resolve'17 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap)) =
    [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'17
  
  predicate resolve'18 [@inline:trivial] (_0: MutBorrow.t (MutBorrow.t t_FMap)) = resolve'17 _0
  
  meta "rewrite_def" predicate resolve'18
  
  let rec new'2 (x: MutBorrow.t t_PtrOwn) (return' (x'0: MutBorrow.t t_PtrOwn)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'16 x}
    any
    [ return''0 (result: MutBorrow.t t_PtrOwn) -> {[%#sghost'3] inv'21 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  let rec v_Root (input: t_Node) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {C_Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [C_Root rank payload: t_Node]. C_Root rank payload <> input}
      (! {false}
      any) ]
  
  predicate resolve'19 [@inline:trivial] (self: MutBorrow.t t_PeanoInt) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'19
  
  predicate resolve'20 [@inline:trivial] (_0: MutBorrow.t t_PeanoInt) = resolve'19 _0
  
  meta "rewrite_def" predicate resolve'20
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function deep_model'1 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = [%#speano'0] self.t_PeanoInt__0
  
  meta "rewrite_def" function deep_model'1
  
  function deep_model'2 [@inline:trivial] (self: MutBorrow.t t_PeanoInt) : UInt64.t =
    [%#smodel'0] deep_model'1 self.current
  
  meta "rewrite_def" function deep_model'2
  
  function deep_model'3 [@inline:trivial] (self: MutBorrow.t t_PeanoInt) : UInt64.t = [%#smodel] deep_model'2 self
  
  meta "rewrite_def" function deep_model'3
  
  let rec lt (self_: MutBorrow.t t_PeanoInt) (other: MutBorrow.t t_PeanoInt) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#scmp] result = UInt64.lt (deep_model'3 self_) (deep_model'3 other)}
      (! return' {result}) ]
  
  predicate resolve'21 [@inline:trivial] (self: MutBorrow.t t_FMap) = [%#sghost'11] resolve'4 self
  
  meta "rewrite_def" predicate resolve'21
  
  predicate resolve'22 [@inline:trivial] (_0: MutBorrow.t t_FMap) = resolve'21 _0
  
  meta "rewrite_def" predicate resolve'22
  
  let rec eq'0 (self_: MutBorrow.t t_PeanoInt) (rhs: MutBorrow.t t_PeanoInt) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#scmp'0] result = (deep_model'3 self_ = deep_model'3 rhs)} (! return' {result}) ]
  
  let rec incr (self: t_PeanoInt) (return' (x: t_PeanoInt)) = any
    [ return''0 (result: t_PeanoInt) -> {[%#speano] UInt64.t'int result.t_PeanoInt__0
      = UInt64.t'int self.t_PeanoInt__0 + 1}
      (! return' {result}) ]
  
  function domain [#"union_find_cpp.rs" 89 8 89 44] (self: t_UF) : Fset.fset t_Elem =
    [%#sunion_find_cpp'14] (self.t_UF__0).t_UFInner__domain
  
  predicate in_domain [#"union_find_cpp.rs" 95 8 95 50] (self: t_UF) (e: t_Elem) =
    [%#sunion_find_cpp'10] contains (domain self) e
  
  function roots_map [#"union_find_cpp.rs" 109 8 109 59] (self: t_UF) : Map.map t_Elem t_Elem =
    [%#sunion_find_cpp'17] (self.t_UF__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UF. ([%#sunion_find_cpp'15] inv'6 self)
      -> ([%#sunion_find_cpp'16] forall e: t_Elem. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find_cpp.rs" 118 8 118 48] (self: t_UF) (e: t_Elem) : t_Elem =
    [%#sunion_find_cpp'11] index_logic'1 (roots_map self) e
  
  predicate domain_unchanged [#"union_find_cpp.rs" 149 8 149 50] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'12] domain self.current = domain self.final
  
  function payloads_map [#"union_find_cpp.rs" 124 8 124 56] (self: t_UF) : Map.map t_Elem t_T =
    [%#sunion_find_cpp'18] (self.t_UF__0).t_UFInner__payloads
  
  predicate payloads_unchanged [#"union_find_cpp.rs" 155 8 155 52] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'13] payloads_map self.current = payloads_map self.final
  
  function fin'0 [@inline:trivial] (self: MutBorrow.t t_UF) : t_UF = [%#sghost'10] self.final
  
  meta "rewrite_def" function fin'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec link [#"union_find_cpp.rs" 241 4 241 76] (uf: MutBorrow.t t_UF) (x: t_Elem) (y: t_Elem)
    (return' (x'0: t_Elem)) = {[@expl:link 'uf' type invariant] [%#sunion_find_cpp'2] inv'8 uf}
    {[@expl:link requires #0] [%#sunion_find_cpp'3] in_domain uf.current x /\ in_domain uf.current y}
    {[@expl:link requires #1] [%#sunion_find_cpp'4] root uf.current x = x /\ root uf.current y = y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UF> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) ->
            [ &_12 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_12} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) -> [ &_11 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'5 ((_11.current).current).t_UF__0}
        MutBorrow.borrow_mut <t_UFInner> {((_11.current).current).t_UF__0}
          (fun (_ret: MutBorrow.t t_UFInner) ->
            [ &__temp <- _ret ] -{inv'5 _ret.final}-
            [ &_11 <- { _11 with current = { _11.current with current = { t_UF__0 = _ret.final } } } ] s1)
      | s1 = new {__temp} (fun (_ret: MutBorrow.t t_UFInner) -> [ &uf'1 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = eq {x'0} {y'0} (fun (_ret: bool) -> [ &_16 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_16 = false} (! bb16) | br1 -> {_16} (! bb4) ]
    | bb4 = s0 [ s0 = [ &_24 <- [%#sunion_find_cpp] x'0 <> y'0 ] s1 | s1 = bb5 ]
    | bb5 = s0 [ s0 = into_ghost {_24} (fun (_ret: bool) -> [ &_23 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = into_inner {_23} (fun (_ret: bool) -> [ &_22 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = any [ br0 -> {_22 = false} (! bb14) | br1 -> {_22} (! bb8) ]
    | bb8 = s0
      [ s0 = {inv'12 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_31 <- _ret ] -{inv'12 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_31} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_30 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_33 <- x'0 ] s1
      | s1 = {inv'4 ((_30.current).current).t_UFInner__perms}
        MutBorrow.borrow_mut <t_FMap> {((_30.current).current).t_UFInner__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_29 <- _ret ] -{inv'4 _ret.final}-
            [ &_30 <- { _30 with current = { _30.current with current = { (_30.current).current with t_UFInner__perms = _ret.final } } } ]
            s2)
      | s2 = split_mut_ghost {_29} {_33} (fun (_ret: tuple) -> [ &_28 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = [ &perm_x <- _28._p0 ] s1
      | s1 = [ &m <- _28._p1 ] s2
      | s2 = {[@expl:type invariant] inv'14 _30} s3
      | s3 = -{resolve'0 _30}- s4
      | s4 = [ &_38 <- y'0 ] s5
      | s5 = {inv'4 m.current}
        MutBorrow.borrow_final <t_FMap> {m.current} {MutBorrow.get_id m}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_36 <- _ret ] -{inv'4 _ret.final}-
            [ &m <- { m with current = _ret.final } ] s6)
      | s6 = get_mut_ghost {_36} {_38} (fun (_ret: t_Option'0) -> [ &_35 <- _ret ] s7)
      | s7 = bb11 ]
    | bb11 = s0 [ s0 = unwrap {_35} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &perm_y <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = {inv'3 perm_x.current}
        MutBorrow.borrow_final <t_PtrOwn> {perm_x.current} {MutBorrow.get_id perm_x}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_40 <- _ret ] -{inv'3 _ret.final}-
            [ &perm_x <- { perm_x with current = _ret.final } ] s1)
      | s1 = disjoint_lemma {_40} {perm_y.current} (fun (_ret: ()) -> [ &_39 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'16 perm_y} s1
      | s1 = -{resolve'2 perm_y}- s2
      | s2 = {[@expl:type invariant] inv'15 m} s3
      | s3 = -{resolve'4 m}- s4
      | s4 = {[@expl:type invariant] inv'16 perm_x} s5
      | s5 = -{resolve'2 perm_x}- s6
      | s6 = {[@expl:type invariant] inv'12 uf'1} s7
      | s7 = -{resolve'8 uf'1}- s8
      | s8 = {[@expl:type invariant] inv'10 _11} s9
      | s9 = -{resolve'10 _11}- s10
      | s10 = {[@expl:type invariant] inv'8 uf'0} s11
      | s11 = -{resolve'14 uf'0}- s12
      | s12 = {false} any ]
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'12 uf'1} s1
      | s1 = -{resolve'8 uf'1}- s2
      | s2 = {[@expl:type invariant] inv'10 _11} s3
      | s3 = -{resolve'10 _11}- s4
      | s4 = {[@expl:type invariant] inv'8 uf'0} s5
      | s5 = -{resolve'14 uf'0}- s6
      | s6 = new'0 {_21} (fun (_ret: ()) -> [ &_20 <- _ret ] s7)
      | s7 = bb15 ]
    | bb15 = s0 [ s0 = [ &_0 <- x'0 ] s1 | s1 = bb54 ]
    | bb16 = s0
      [ s0 = {inv'12 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_50 <- _ret ] -{inv'12 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_50} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_49 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_52 <- x'0 ] s1
      | s1 = {inv'4 ((_49.current).current).t_UFInner__perms}
        MutBorrow.borrow_mut <t_FMap> {((_49.current).current).t_UFInner__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_48 <- _ret ] -{inv'4 _ret.final}-
            [ &_49 <- { _49 with current = { _49.current with current = { (_49.current).current with t_UFInner__perms = _ret.final } } } ]
            s2)
      | s2 = split_mut_ghost {_48} {_52} (fun (_ret: tuple) -> [ &_47 <- _ret ] s3)
      | s3 = bb18 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'14 _49} s1
      | s1 = -{resolve'0 _49}- s2
      | s2 = new'1 {_47} (fun (_ret: tuple) -> [ &_46 <- _ret ] s3)
      | s3 = bb19 ]
    | bb19 = s0 [ s0 = split {_46} (fun (_ret: tuple'0) -> [ &_45 <- _ret ] s1) | s1 = bb20 ]
    | bb20 = s0
      [ s0 = [ &perm_x'0 <- _45._p0'0 ] s1
      | s1 = [ &m'0 <- _45._p1'0 ] s2
      | s2 = as_mut {x'0.t_Elem__0} {perm_x'0} (fun (_ret: MutBorrow.t t_Node) -> [ &_54 <- _ret ] s3)
      | s3 = bb21 ]
    | bb21 = s0
      [ s0 = {inv'1 _54.current}
        MutBorrow.borrow_final <t_Node> {_54.current} {MutBorrow.get_id _54}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &bx <- _ret ] -{inv'1 _ret.final}-
            [ &_54 <- { _54 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'24 _54} s2
      | s2 = -{resolve'16 _54}- s3
      | s3 = {inv'22 m'0}
        MutBorrow.borrow_mut <MutBorrow.t t_FMap> {m'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap)) ->
            [ &_67 <- _ret ] -{inv'22 _ret.final}-
            [ &m'0 <- _ret.final ] s4)
      | s4 = deref_mut'1 {_67} (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap)) -> [ &_66 <- _ret ] s5)
      | s5 = bb22 ]
    | bb22 = s0
      [ s0 = [ &_69 <- y'0 ] s1
      | s1 = {inv'4 (_66.current).current}
        MutBorrow.borrow_mut <t_FMap> {(_66.current).current}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_65 <- _ret ] -{inv'4 _ret.final}-
            [ &_66 <- { _66 with current = { _66.current with current = _ret.final } } ] s2)
      | s2 = get_mut_ghost {_65} {_69} (fun (_ret: t_Option'0) -> [ &_64 <- _ret ] s3)
      | s3 = bb23 ]
    | bb23 = s0 [ s0 = unwrap {_64} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_63 <- _ret ] s1) | s1 = bb24 ]
    | bb24 = s0
      [ s0 = {inv'3 _63.current}
        MutBorrow.borrow_final <t_PtrOwn> {_63.current} {MutBorrow.get_id _63}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_62 <- _ret ] -{inv'3 _ret.final}-
            [ &_63 <- { _63 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'26 _66} s2
      | s2 = -{resolve'18 _66}- s3
      | s3 = {[@expl:type invariant] inv'16 _63} s4
      | s4 = -{resolve'2 _63}- s5
      | s5 = {inv'3 _62.current}
        MutBorrow.borrow_final <t_PtrOwn> {_62.current} {MutBorrow.get_id _62}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_61 <- _ret ] -{inv'3 _ret.final}-
            [ &_62 <- { _62 with current = _ret.final } ] s6)
      | s6 = new'2 {_61} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_60 <- _ret ] s7)
      | s7 = bb25 ]
    | bb25 = s0
      [ s0 = {[@expl:type invariant] inv'16 _62} s1
      | s1 = -{resolve'2 _62}- s2
      | s2 = as_mut {y'0.t_Elem__0} {_60} (fun (_ret: MutBorrow.t t_Node) -> [ &_58 <- _ret ] s3)
      | s3 = bb26 ]
    | bb26 = s0
      [ s0 = {inv'1 _58.current}
        MutBorrow.borrow_final <t_Node> {_58.current} {MutBorrow.get_id _58}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &by' <- _ret ] -{inv'1 _ret.final}-
            [ &_58 <- { _58 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'24 _58} s2
      | s2 = -{resolve'16 _58}- s3
      | s3 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {bx.current = C_Root x0 x1} (! bb29)
        | br1 (x0: t_Elem) -> {bx.current = C_Link x0} (! bb27) ] ]
    | bb27 = s0
      [ s0 = {[@expl:type invariant] inv'24 by'} s1
      | s1 = -{resolve'16 by'}- s2
      | s2 = {[@expl:type invariant] inv'24 bx} s3
      | s3 = -{resolve'16 bx}- s4
      | s4 = {false} any ]
    | bb29 = s0
      [ s0 = v_Root {bx.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &rx <- _ret ] [ &bx <- { bx with current = C_Root _ret.final rpayload } ] s1))
      | s1 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {by'.current = C_Root x0 x1} (! bb32)
        | br1 (x0: t_Elem) -> {by'.current = C_Link x0} (! bb30) ] ]
    | bb30 = s0
      [ s0 = -{resolve'20 rx}- s1
      | s1 = {[@expl:type invariant] inv'24 by'} s2
      | s2 = -{resolve'16 by'}- s3
      | s3 = {false} any ]
    | bb32 = s0
      [ s0 = v_Root {by'.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &ry <- _ret ] [ &by' <- { by' with current = C_Root _ret.final rpayload } ] s1))
      | s1 = MutBorrow.borrow_final <t_PeanoInt> {ry.current} {MutBorrow.get_id ry}
          (fun (_ret: MutBorrow.t t_PeanoInt) -> [ &_79 <- _ret ] [ &ry <- { ry with current = _ret.final } ] s2)
      | s2 = lt {rx} {_79} (fun (_ret: bool) -> [ &_76 <- _ret ] s3)
      | s3 = bb33 ]
    | bb33 = s0 [ s0 = -{resolve'20 _79}- s1 | s1 = any [ br0 -> {_76 = false} (! bb41) | br1 -> {_76} (! bb34) ] ]
    | bb34 = s0
      [ s0 = -{resolve'20 ry}- s1
      | s1 = -{resolve'20 rx}- s2
      | s2 = {[@expl:type invariant] inv'24 by'} s3
      | s3 = -{resolve'16 by'}- s4
      | s4 = {[@expl:type invariant] inv'22 m'0} s5
      | s5 = -{resolve'22 m'0}- s6
      | s6 = [ &_80 <- C_Link y'0 ] s7
      | s7 = bb35 ]
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv'1 bx.current} s1
      | s1 = [ &bx <- { bx with current = _80 } ] s2
      | s2 = {[@expl:type invariant] inv'24 bx} s3
      | s3 = -{resolve'16 bx}- s4
      | s4 = bb37 ]
    | bb37 = s0
      [ s0 = [ &_84 <- [%#sunion_find_cpp'0] fun (z: t_Elem) -> if index_logic'1 (uf'1.current).t_UFInner__roots z
        = x'0 then
          y'0
        else
          index_logic'1 (uf'1.current).t_UFInner__roots z
         ] s1
      | s1 = bb38 ]
    | bb38 = s0
      [ s0 = {inv'12 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_87 <- _ret ] -{inv'12 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_87} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_86 <- _ret ] s2)
      | s2 = bb39 ]
    | bb39 = s0
      [ s0 =
        [ &_86 <- { _86 with current = { _86.current with current = { (_86.current).current with t_UFInner__roots = _84 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'14 _86} s2
      | s2 = -{resolve'0 _86}- s3
      | s3 = {[@expl:type invariant] inv'12 uf'1} s4
      | s4 = -{resolve'8 uf'1}- s5
      | s5 = {[@expl:type invariant] inv'10 _11} s6
      | s6 = -{resolve'10 _11}- s7
      | s7 = {[@expl:type invariant] inv'8 uf'0} s8
      | s8 = -{resolve'14 uf'0}- s9
      | s9 = new'0 {_83} (fun (_ret: ()) -> [ &_82 <- _ret ] s10)
      | s10 = bb40 ]
    | bb40 = s0 [ s0 = [ &_0 <- y'0 ] s1 | s1 = bb54 ]
    | bb41 = s0 [ s0 = eq'0 {rx} {ry} (fun (_ret: bool) -> [ &_89 <- _ret ] s1) | s1 = bb42 ]
    | bb42 = s0 [ s0 = -{resolve'20 ry}- s1 | s1 = any [ br0 -> {_89 = false} (! bb45) | br1 -> {_89} (! bb43) ] ]
    | bb43 = s0
      [ s0 = -{resolve'20 rx}- s1 | s1 = incr {rx.current} (fun (_ret: t_PeanoInt) -> [ &_92 <- _ret ] s2) | s2 = bb44 ]
    | bb44 = s0 [ s0 = {[@expl:type invariant] inv'24 bx} s1 | s1 = -{resolve'16 bx}- s2 | s2 = bb46 ]
    | bb45 = s0
      [ s0 = -{resolve'20 rx}- s1 | s1 = {[@expl:type invariant] inv'24 bx} s2 | s2 = -{resolve'16 bx}- s3 | s3 = bb46 ]
    | bb46 = s0 [ s0 = [ &_94 <- C_Link x'0 ] s1 | s1 = bb47 ]
    | bb47 = s0
      [ s0 = {[@expl:type invariant] inv'1 by'.current} s1
      | s1 = [ &by' <- { by' with current = _94 } ] s2
      | s2 = {[@expl:type invariant] inv'24 by'} s3
      | s3 = -{resolve'16 by'}- s4
      | s4 = {[@expl:type invariant] inv'22 m'0} s5
      | s5 = -{resolve'22 m'0}- s6
      | s6 = bb49 ]
    | bb49 = s0
      [ s0 = [ &_98 <- [%#sunion_find_cpp'1] fun (z: t_Elem) -> if index_logic'1 (uf'1.current).t_UFInner__roots z
        = y'0 then
          x'0
        else
          index_logic'1 (uf'1.current).t_UFInner__roots z
         ] s1
      | s1 = bb50 ]
    | bb50 = s0
      [ s0 = {inv'12 uf'1}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner> {uf'1}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) ->
            [ &_101 <- _ret ] -{inv'12 _ret.final}-
            [ &uf'1 <- _ret.final ] s1)
      | s1 = deref_mut'0 {_101} (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner)) -> [ &_100 <- _ret ] s2)
      | s2 = bb51 ]
    | bb51 = s0
      [ s0 =
        [ &_100 <- { _100 with current = { _100.current with current = { (_100.current).current with t_UFInner__roots = _98 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'14 _100} s2
      | s2 = -{resolve'0 _100}- s3
      | s3 = {[@expl:type invariant] inv'12 uf'1} s4
      | s4 = -{resolve'8 uf'1}- s5
      | s5 = {[@expl:type invariant] inv'10 _11} s6
      | s6 = -{resolve'10 _11}- s7
      | s7 = {[@expl:type invariant] inv'8 uf'0} s8
      | s8 = -{resolve'14 uf'0}- s9
      | s9 = new'0 {_97} (fun (_ret: ()) -> [ &_96 <- _ret ] s10)
      | s10 = bb52 ]
    | bb52 = s0 [ s0 = [ &_0 <- x'0 ] s1 | s1 = bb54 ]
    | bb54 = return''0 {_0} ]
    [ & _0: t_Elem = Any.any_l ()
    | & uf'0: MutBorrow.t t_UF = uf
    | & x'0: t_Elem = x
    | & y'0: t_Elem = y
    | & __temp: MutBorrow.t t_UFInner = Any.any_l ()
    | & _11: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & _12: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & uf'1: MutBorrow.t t_UFInner = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _20: () = Any.any_l ()
    | & _21: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _23: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & perm_x: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & m: MutBorrow.t t_FMap = Any.any_l ()
    | & _28: tuple = Any.any_l ()
    | & _29: MutBorrow.t t_FMap = Any.any_l ()
    | & _30: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _31: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _33: t_Elem = Any.any_l ()
    | & perm_y: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _35: t_Option'0 = Any.any_l ()
    | & _36: MutBorrow.t t_FMap = Any.any_l ()
    | & _38: t_Elem = Any.any_l ()
    | & _39: () = Any.any_l ()
    | & _40: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & perm_x'0: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & m'0: MutBorrow.t t_FMap = Any.any_l ()
    | & _45: tuple'0 = Any.any_l ()
    | & _46: tuple = Any.any_l ()
    | & _47: tuple = Any.any_l ()
    | & _48: MutBorrow.t t_FMap = Any.any_l ()
    | & _49: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _50: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _52: t_Elem = Any.any_l ()
    | & bx: MutBorrow.t t_Node = Any.any_l ()
    | & _54: MutBorrow.t t_Node = Any.any_l ()
    | & by': MutBorrow.t t_Node = Any.any_l ()
    | & _58: MutBorrow.t t_Node = Any.any_l ()
    | & _60: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _61: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _62: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _63: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _64: t_Option'0 = Any.any_l ()
    | & _65: MutBorrow.t t_FMap = Any.any_l ()
    | & _66: MutBorrow.t (MutBorrow.t t_FMap) = Any.any_l ()
    | & _67: MutBorrow.t (MutBorrow.t t_FMap) = Any.any_l ()
    | & _69: t_Elem = Any.any_l ()
    | & rx: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & ry: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _76: bool = Any.any_l ()
    | & _79: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _80: t_Node = Any.any_l ()
    | & _82: () = Any.any_l ()
    | & _83: () = Any.any_l ()
    | & _84: Map.map t_Elem t_Elem = Any.any_l ()
    | & _86: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _87: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _89: bool = Any.any_l ()
    | & _92: t_PeanoInt = Any.any_l ()
    | & _94: t_Node = Any.any_l ()
    | & _96: () = Any.any_l ()
    | & _97: () = Any.any_l ()
    | & _98: Map.map t_Elem t_Elem = Any.any_l ()
    | & _100: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l ()
    | & _101: MutBorrow.t (MutBorrow.t t_UFInner) = Any.any_l () ])
    [ return''0 (result: t_Elem) -> {[@expl:link ensures #0] [%#sunion_find_cpp'5] domain_unchanged uf
      /\ payloads_unchanged uf}
      {[@expl:link ensures #1] [%#sunion_find_cpp'6] result = root uf.current x \/ result = root uf.current y}
      {[@expl:link ensures #2] [%#sunion_find_cpp'7] result = root (fin'0 uf) result}
      {[@expl:link ensures #3] [%#sunion_find_cpp'8] forall z: t_Elem. in_domain uf.current z
        -> root (fin'0 uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return' {result}) ]
end
module M_union_find_cpp__implementation__union [#"union_find_cpp.rs" 284 4 284 81]
  let%span sunion_find_cpp = "union_find_cpp.rs" 284 24 284 26
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 276 4 276 51
  let%span sunion_find_cpp'1 = "union_find_cpp.rs" 277 4 277 64
  let%span sunion_find_cpp'2 = "union_find_cpp.rs" 278 14 278 58
  let%span sunion_find_cpp'3 = "union_find_cpp.rs" 279 14 282 31
  let%span sunion_find_cpp'4 = "union_find_cpp.rs" 202 23 202 25
  let%span sunion_find_cpp'5 = "union_find_cpp.rs" 199 4 199 35
  let%span sunion_find_cpp'6 = "union_find_cpp.rs" 200 14 200 37
  let%span sunion_find_cpp'7 = "union_find_cpp.rs" 201 4 201 30
  let%span sunion_find_cpp'8 = "union_find_cpp.rs" 241 19 241 21
  let%span sunion_find_cpp'9 = "union_find_cpp.rs" 232 4 232 51
  let%span sunion_find_cpp'10 = "union_find_cpp.rs" 233 15 233 49
  let%span sunion_find_cpp'11 = "union_find_cpp.rs" 234 4 234 64
  let%span sunion_find_cpp'12 = "union_find_cpp.rs" 235 14 235 58
  let%span sunion_find_cpp'13 = "union_find_cpp.rs" 236 14 236 42
  let%span sunion_find_cpp'14 = "union_find_cpp.rs" 237 14 239 98
  let%span sunion_find_cpp'15 = "union_find_cpp.rs" 94 8 94 22
  let%span sunion_find_cpp'16 = "union_find_cpp.rs" 150 24 150 60
  let%span sunion_find_cpp'17 = "union_find_cpp.rs" 156 24 156 72
  let%span sunion_find_cpp'18 = "union_find_cpp.rs" 117 8 117 22
  let%span sunion_find_cpp'19 = "union_find_cpp.rs" 141 16 143 64
  let%span sunion_find_cpp'20 = "union_find_cpp.rs" 86 8 86 16
  let%span sunion_find_cpp'21 = "union_find_cpp.rs" 123 8 123 16
  let%span sunion_find_cpp'22 = "union_find_cpp.rs" 104 19 104 28
  let%span sunion_find_cpp'23 = "union_find_cpp.rs" 105 18 107 42
  let%span sunion_find_cpp'24 = "union_find_cpp.rs" 103 8 103 16
  let%span sunion_find_cpp'25 = "union_find_cpp.rs" 66 12 79 17
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span soption = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 91 22 91 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 91 4 91 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 89 14 89 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 181 15 181 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 181 4 183 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 179 14 179 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Elem;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Elem t_T;
    t_UFInner__roots: Map.map t_Elem t_Elem }
  
  type t_UF = { t_UF__0: t_UFInner }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt t_T | C_Link t_Elem
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Elem t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_Option = [%#sfmap'1] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_Elem) = [%#sfmap] get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#slogic] exists x: t_PtrOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_PtrOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Elem) : t_PtrOwn = [%#sfmap'0] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function val' (self: t_PtrOwn) : t_Node
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  predicate invariant' [#"union_find_cpp.rs" 64 8 64 34] [@inline:trivial] (self: t_UF) =
    [%#sunion_find_cpp'25] forall e: t_Elem. contains (self.t_UF__0).t_UFInner__domain e
      -> contains'0 (self.t_UF__0).t_UFInner__perms e
      /\ ptr (index_logic'0 (self.t_UF__0).t_UFInner__perms e) = e.t_Elem__0
      /\ contains (self.t_UF__0).t_UFInner__domain (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
      /\ index_logic'1 (self.t_UF__0).t_UFInner__roots (index_logic'1 (self.t_UF__0).t_UFInner__roots e)
        = index_logic'1 (self.t_UF__0).t_UFInner__roots e
      /\ match val' (index_logic'0 (self.t_UF__0).t_UFInner__perms e) with
        | C_Link e2 -> contains (self.t_UF__0).t_UFInner__domain e2
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e <> e
        /\ index_logic'1 (self.t_UF__0).t_UFInner__roots e = index_logic'1 (self.t_UF__0).t_UFInner__roots e2
        | C_Root _ payload -> index_logic'1 (self.t_UF__0).t_UFInner__roots e = e
        /\ index_logic'2 (self.t_UF__0).t_UFInner__payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_0: t_Elem)
  
  axiom inv_axiom [@rewrite]: forall x: t_Elem [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | C_Root rank payload -> inv'0 payload
        | C_Link a_0 -> true
        end
  
  predicate invariant''1 (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> inv'2 val''0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_FMap) =
    [%#sfmap'3] forall k: t_Elem. contains'0 self k -> inv k /\ inv'3 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_FMap [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_UFInner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UFInner [inv'5 x]. inv'5 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots} -> inv'4 perms
        end
  
  predicate inv'6 (_0: t_UF)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_UF [inv'6 x]. inv'6 x
      = (invariant' x
      /\ match x with
        | {t_UF__0 = a_0} -> inv'5 a_0
        end)
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UF) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'7 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UF [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sghost'6] inv'7 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'8 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UF [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'9 (_0: MutBorrow.t (MutBorrow.t t_UF))
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UF) [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_0: MutBorrow.t (MutBorrow.t t_UF))
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_UF) [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_UF)) (return' (x: MutBorrow.t (MutBorrow.t t_UF))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'9 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_UF)) -> {[%#sghost'0] inv'10 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF)) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (MutBorrow.t t_UF)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_UF) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  let rec new (x: MutBorrow.t t_UF) (return' (x'0: MutBorrow.t t_UF)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'7 x}
    any
    [ return''0 (result: MutBorrow.t t_UF) -> {[%#sghost'3] inv'8 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  function domain [#"union_find_cpp.rs" 89 8 89 44] (self: t_UF) : Fset.fset t_Elem =
    [%#sunion_find_cpp'20] (self.t_UF__0).t_UFInner__domain
  
  predicate in_domain [#"union_find_cpp.rs" 95 8 95 50] (self: t_UF) (e: t_Elem) =
    [%#sunion_find_cpp'15] contains (domain self) e
  
  function roots_map [#"union_find_cpp.rs" 109 8 109 59] (self: t_UF) : Map.map t_Elem t_Elem =
    [%#sunion_find_cpp'24] (self.t_UF__0).t_UFInner__roots
  
  axiom roots_map_spec: forall self: t_UF. ([%#sunion_find_cpp'22] inv'6 self)
      -> ([%#sunion_find_cpp'23] forall e: t_Elem. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function root [#"union_find_cpp.rs" 118 8 118 48] (self: t_UF) (e: t_Elem) : t_Elem =
    [%#sunion_find_cpp'18] index_logic'1 (roots_map self) e
  
  function payloads_map [#"union_find_cpp.rs" 124 8 124 56] (self: t_UF) : Map.map t_Elem t_T =
    [%#sunion_find_cpp'21] (self.t_UF__0).t_UFInner__payloads
  
  predicate unchanged [#"union_find_cpp.rs" 139 8 139 43] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'19] domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  let rec find (uf: MutBorrow.t t_UF) (elem: t_Elem) (return' (x: t_Elem)) =
    {[@expl:find 'uf' type invariant] [%#sunion_find_cpp'4] inv'8 uf}
    {[@expl:find requires] [%#sunion_find_cpp'5] in_domain uf.current elem}
    any
    [ return''0 (result: t_Elem) -> {[%#sunion_find_cpp'6] result = root uf.current elem}
      {[%#sunion_find_cpp'7] unchanged uf}
      (! return' {result}) ]
  
  predicate domain_unchanged [#"union_find_cpp.rs" 149 8 149 50] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'16] domain self.current = domain self.final
  
  predicate payloads_unchanged [#"union_find_cpp.rs" 155 8 155 52] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'17] payloads_map self.current = payloads_map self.final
  
  function fin [@inline:trivial] (self: MutBorrow.t t_UF) : t_UF = [%#sghost'5] self.final
  
  meta "rewrite_def" function fin
  
  let rec link (uf: MutBorrow.t t_UF) (x: t_Elem) (y: t_Elem) (return' (x'0: t_Elem)) =
    {[@expl:link 'uf' type invariant] [%#sunion_find_cpp'8] inv'8 uf}
    {[@expl:link requires #0] [%#sunion_find_cpp'9] in_domain uf.current x /\ in_domain uf.current y}
    {[@expl:link requires #1] [%#sunion_find_cpp'10] root uf.current x = x /\ root uf.current y = y}
    any
    [ return''0 (result: t_Elem) -> {[%#sunion_find_cpp'11] domain_unchanged uf /\ payloads_unchanged uf}
      {[%#sunion_find_cpp'12] result = root uf.current x \/ result = root uf.current y}
      {[%#sunion_find_cpp'13] result = root (fin uf) result}
      {[%#sunion_find_cpp'14] forall z: t_Elem. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec union [#"union_find_cpp.rs" 284 4 284 81] (uf: MutBorrow.t t_UF) (x: t_Elem) (y: t_Elem)
    (return' (x'0: t_Elem)) = {[@expl:union 'uf' type invariant] [%#sunion_find_cpp] inv'8 uf}
    {[@expl:union requires] [%#sunion_find_cpp'0] in_domain uf.current x /\ in_domain uf.current y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UF> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) ->
            [ &_14 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) -> [ &_13 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'6 (_13.current).current}
        MutBorrow.borrow_mut <t_UF> {(_13.current).current}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_12 <- _ret ] -{inv'6 _ret.final}-
            [ &_13 <- { _13 with current = { _13.current with current = _ret.final } } ] s1)
      | s1 = {inv'6 _12.current}
        MutBorrow.borrow_final <t_UF> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_11 <- _ret ] -{inv'6 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'10 _13} s3
      | s3 = -{resolve'0 _13}- s4
      | s4 = {[@expl:type invariant] inv'7 _12} s5
      | s5 = -{resolve'2 _12}- s6
      | s6 = {inv'6 _11.current}
        MutBorrow.borrow_final <t_UF> {_11.current} {MutBorrow.get_id _11}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_10 <- _ret ] -{inv'6 _ret.final}-
            [ &_11 <- { _11 with current = _ret.final } ] s7)
      | s7 = new {_10} (fun (_ret: MutBorrow.t t_UF) -> [ &_9 <- _ret ] s8)
      | s8 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'7 _11} s1
      | s1 = -{resolve'2 _11}- s2
      | s2 = find {_9} {x'0} (fun (_ret: t_Elem) -> [ &rx <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'8 uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UF> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) ->
            [ &_22 <- _ret ] -{inv'8 _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut {_22} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF)) -> [ &_21 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv'6 (_21.current).current}
        MutBorrow.borrow_mut <t_UF> {(_21.current).current}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_20 <- _ret ] -{inv'6 _ret.final}-
            [ &_21 <- { _21 with current = { _21.current with current = _ret.final } } ] s1)
      | s1 = {inv'6 _20.current}
        MutBorrow.borrow_final <t_UF> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_19 <- _ret ] -{inv'6 _ret.final}-
            [ &_20 <- { _20 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'10 _21} s3
      | s3 = -{resolve'0 _21}- s4
      | s4 = {[@expl:type invariant] inv'7 _20} s5
      | s5 = -{resolve'2 _20}- s6
      | s6 = {inv'6 _19.current}
        MutBorrow.borrow_final <t_UF> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_UF) ->
            [ &_18 <- _ret ] -{inv'6 _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s7)
      | s7 = new {_18} (fun (_ret: MutBorrow.t t_UF) -> [ &_17 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'7 _19} s1
      | s1 = -{resolve'2 _19}- s2
      | s2 = find {_17} {y'0} (fun (_ret: t_Elem) -> [ &ry <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = link {uf'0} {rx} {ry} (fun (_ret: t_Elem) -> [ &_0 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = return''0 {_0} ]
    [ & _0: t_Elem = Any.any_l ()
    | & uf'0: MutBorrow.t t_UF = uf
    | & x'0: t_Elem = x
    | & y'0: t_Elem = y
    | & rx: t_Elem = Any.any_l ()
    | & _9: MutBorrow.t t_UF = Any.any_l ()
    | & _10: MutBorrow.t t_UF = Any.any_l ()
    | & _11: MutBorrow.t t_UF = Any.any_l ()
    | & _12: MutBorrow.t t_UF = Any.any_l ()
    | & _13: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & _14: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & ry: t_Elem = Any.any_l ()
    | & _17: MutBorrow.t t_UF = Any.any_l ()
    | & _18: MutBorrow.t t_UF = Any.any_l ()
    | & _19: MutBorrow.t t_UF = Any.any_l ()
    | & _20: MutBorrow.t t_UF = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l ()
    | & _22: MutBorrow.t (MutBorrow.t t_UF) = Any.any_l () ])
    [ return''0 (result: t_Elem) -> {[@expl:union ensures #0] [%#sunion_find_cpp'1] domain_unchanged uf
      /\ payloads_unchanged uf}
      {[@expl:union ensures #1] [%#sunion_find_cpp'2] result = root uf.current x \/ result = root uf.current y}
      {[@expl:union ensures #2] [%#sunion_find_cpp'3] forall z: t_Elem. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return' {result}) ]
end
module M_union_find_cpp__example [#"union_find_cpp.rs" 293 0 293 16]
  let%span sunion_find_cpp = "union_find_cpp.rs" 296 34 296 35
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 297 34 297 35
  let%span sunion_find_cpp'1 = "union_find_cpp.rs" 298 34 298 35
  let%span sunion_find_cpp'2 = "union_find_cpp.rs" 300 36 300 37
  let%span sunion_find_cpp'3 = "union_find_cpp.rs" 301 36 301 37
  let%span sunion_find_cpp'4 = "union_find_cpp.rs" 302 36 302 37
  let%span sunion_find_cpp'5 = "union_find_cpp.rs" 310 36 310 37
  let%span sunion_find_cpp'6 = "union_find_cpp.rs" 310 12 310 37
  let%span sunion_find_cpp'7 = "union_find_cpp.rs" 309 12 309 58
  let%span sunion_find_cpp'8 = "union_find_cpp.rs" 302 12 302 37
  let%span sunion_find_cpp'9 = "union_find_cpp.rs" 301 12 301 37
  let%span sunion_find_cpp'10 = "union_find_cpp.rs" 300 12 300 37
  let%span sunion_find_cpp'11 = "union_find_cpp.rs" 161 23 161 35
  let%span sunion_find_cpp'12 = "union_find_cpp.rs" 160 4 160 42
  let%span sunion_find_cpp'13 = "union_find_cpp.rs" 178 23 178 25
  let%span sunion_find_cpp'14 = "union_find_cpp.rs" 174 4 174 37
  let%span sunion_find_cpp'15 = "union_find_cpp.rs" 175 14 175 58
  let%span sunion_find_cpp'16 = "union_find_cpp.rs" 176 14 176 69
  let%span sunion_find_cpp'17 = "union_find_cpp.rs" 177 14 177 76
  let%span sunion_find_cpp'18 = "union_find_cpp.rs" 223 18 223 20
  let%span sunion_find_cpp'19 = "union_find_cpp.rs" 220 4 220 35
  let%span sunion_find_cpp'20 = "union_find_cpp.rs" 221 15 221 36
  let%span sunion_find_cpp'21 = "union_find_cpp.rs" 222 14 222 41
  let%span sunion_find_cpp'22 = "union_find_cpp.rs" 284 24 284 26
  let%span sunion_find_cpp'23 = "union_find_cpp.rs" 276 4 276 51
  let%span sunion_find_cpp'24 = "union_find_cpp.rs" 277 4 277 64
  let%span sunion_find_cpp'25 = "union_find_cpp.rs" 278 14 278 58
  let%span sunion_find_cpp'26 = "union_find_cpp.rs" 279 14 282 31
  let%span sunion_find_cpp'27 = "union_find_cpp.rs" 202 23 202 25
  let%span sunion_find_cpp'28 = "union_find_cpp.rs" 199 4 199 35
  let%span sunion_find_cpp'29 = "union_find_cpp.rs" 200 14 200 37
  let%span sunion_find_cpp'30 = "union_find_cpp.rs" 201 4 201 30
  let%span sunion_find_cpp'31 = "union_find_cpp.rs" 94 8 94 22
  let%span sunion_find_cpp'32 = "union_find_cpp.rs" 104 19 104 28
  let%span sunion_find_cpp'33 = "union_find_cpp.rs" 105 18 107 42
  let%span sunion_find_cpp'34 = "union_find_cpp.rs" 117 8 117 22
  let%span sunion_find_cpp'35 = "union_find_cpp.rs" 132 8 132 22
  let%span sunion_find_cpp'36 = "union_find_cpp.rs" 150 24 150 60
  let%span sunion_find_cpp'37 = "union_find_cpp.rs" 156 24 156 72
  let%span sunion_find_cpp'38 = "union_find_cpp.rs" 141 16 143 64
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 55 8 55 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 148 27 148 31
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 148 4 148 49
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 147 14 147 36
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 140 19 140 23
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 140 4 140 37
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 139 14 139 32
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use creusot.int.Int32
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  type t_FMap
  
  type t_UFInner = {
    t_UFInner__domain: Fset.fset t_Elem;
    t_UFInner__perms: t_FMap;
    t_UFInner__payloads: Map.map t_Elem Int32.t;
    t_UFInner__roots: Map.map t_Elem t_Elem }
  
  type t_UF = { t_UF__0: t_UFInner }
  
  predicate invariant' [#"union_find_cpp.rs" 64 8 64 34] (self: t_UF)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Node = C_Root t_PeanoInt Int32.t | C_Link t_Elem
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }
  
  type t_Option = C_None | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map t_Elem t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_Option = [%#sfmap'2] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Elem) = [%#sfmap'0] get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_0: t_Elem)
  
  axiom inv_axiom [@rewrite]: forall x: t_Elem [inv x]. inv x = true
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate metadata_matches (_value: t_Node) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : t_Node
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'0 x]. inv'0 x
      = (invariant''0 x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> true
        end)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PtrOwn bool) (a: t_PtrOwn) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PtrOwn bool) : t_PtrOwn
  
  axiom such_that_spec: forall p: Map.map t_PtrOwn bool. ([%#slogic] exists x: t_PtrOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PtrOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PtrOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Elem) : t_PtrOwn = [%#sfmap'3] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Elem) : t_PtrOwn = [%#sfmap'1] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    [%#sfmap] forall k: t_Elem. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'1 (_0: t_FMap)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant''1 x
  
  predicate inv'2 (_0: t_UFInner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner [inv'2 x]. inv'2 x
      = match x with
        | {t_UFInner__domain = domain; t_UFInner__perms = perms; t_UFInner__payloads = payloads; t_UFInner__roots = roots} -> inv'1 perms
        end
  
  predicate inv'3 (_0: t_UF)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF [inv'3 x]. inv'3 x
      = (invariant' x
      /\ match x with
        | {t_UF__0 = a_0} -> inv'2 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_UF) = [%#sghost'6] inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_UF)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UF [inv'4 x]. inv'4 x = invariant''2 x
  
  function domain [#"union_find_cpp.rs" 89 8 89 44] (self: t_UF) : Fset.fset t_Elem
  
  let rec new (return' (x: t_UF)) = any
    [ return''0 (result: t_UF) -> {[%#sunion_find_cpp'11] inv'4 result}
      {[%#sunion_find_cpp'12] Fset.is_empty (domain result)}
      (! return' {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_UF) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_UF [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_UF) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'6 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_UF [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_UF) = [%#sghost'6] inv'6 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'7 (_0: MutBorrow.t t_UF)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UF [inv'7 x]. inv'7 x = invariant''5 x
  
  let rec borrow_mut (self: MutBorrow.t t_UF) (return' (x: MutBorrow.t t_UF)) =
    {[@expl:borrow_mut 'self' type invariant] [%#sghost] inv'5 self}
    any
    [ return''0 (result: MutBorrow.t t_UF) -> {[%#sghost'0] inv'7 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = [%#sfset'0] Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  predicate in_domain [#"union_find_cpp.rs" 95 8 95 50] (self: t_UF) (e: t_Elem) =
    [%#sunion_find_cpp'31] contains'0 (domain self) e
  
  function fin [@inline:trivial] (self: MutBorrow.t t_UF) : t_UF = [%#sghost'5] self.final
  
  meta "rewrite_def" function fin
  
  function insert [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) : Fset.fset t_Elem = [%#sfset] Fset.add e self
  
  meta "rewrite_def" function insert
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function roots_map [#"union_find_cpp.rs" 109 8 109 59] (self: t_UF) : Map.map t_Elem t_Elem
  
  axiom roots_map_spec: forall self: t_UF. ([%#sunion_find_cpp'32] inv'3 self)
      -> ([%#sunion_find_cpp'33] forall e: t_Elem. in_domain self e
        -> in_domain self (index_logic'1 (roots_map self) e)
        /\ index_logic'1 (roots_map self) e = index_logic'1 (roots_map self) (index_logic'1 (roots_map self) e))
  
  function payloads_map [#"union_find_cpp.rs" 124 8 124 56] (self: t_UF) : Map.map t_Elem Int32.t
  
  let rec make (uf: MutBorrow.t t_UF) (payload: Int32.t) (return' (x: t_Elem)) =
    {[@expl:make 'uf' type invariant] [%#sunion_find_cpp'13] inv'7 uf}
    any
    [ return''0 (result: t_Elem) -> {[%#sunion_find_cpp'14] not in_domain uf.current result}
      {[%#sunion_find_cpp'15] domain (fin uf) = insert (domain uf.current) result}
      {[%#sunion_find_cpp'16] roots_map (fin uf) = Map.set (roots_map uf.current) result result}
      {[%#sunion_find_cpp'17] payloads_map (fin uf) = Map.set (payloads_map uf.current) result payload}
      (! return' {result}) ]
  
  predicate invariant''6 [@inline:trivial] (self: t_UF) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'8 (_0: t_UF)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_UF [inv'8 x]. inv'8 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: t_UF) = [%#sinvariant'0] inv'3 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'9 (_0: t_UF)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_UF [inv'9 x]. inv'9 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: t_UF) = [%#sghost'6] inv'9 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'10 (_0: t_UF)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_UF [inv'10 x]. inv'10 x = invariant''8 x
  
  let rec borrow (self: t_UF) (return' (x: t_UF)) = {[@expl:borrow 'self' type invariant] [%#sghost'2] inv'8 self}
    any [ return''0 (result: t_UF) -> {[%#sghost'3] inv'10 result} {[%#sghost'4] result = self} (! return' {result}) ]
  
  function root [#"union_find_cpp.rs" 118 8 118 48] (self: t_UF) (e: t_Elem) : t_Elem =
    [%#sunion_find_cpp'34] index_logic'1 (roots_map self) e
  
  function index_logic'2 [@inline:trivial] (self: Map.map t_Elem Int32.t) (a: t_Elem) : Int32.t =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function payload [#"union_find_cpp.rs" 133 8 133 45] (self: t_UF) (e: t_Elem) : Int32.t =
    [%#sunion_find_cpp'35] index_logic'2 (payloads_map self) e
  
  let rec get'0 (uf: t_UF) (elem: t_Elem) (return' (x: Int32.t)) =
    {[@expl:get 'uf' type invariant] [%#sunion_find_cpp'18] inv'10 uf}
    {[@expl:get requires #0] [%#sunion_find_cpp'19] in_domain uf elem}
    {[@expl:get requires #1] [%#sunion_find_cpp'20] root uf elem = elem}
    any [ return''0 (result: Int32.t) -> {[%#sunion_find_cpp'21] result = payload uf elem} (! return' {result}) ]
  
  predicate domain_unchanged [#"union_find_cpp.rs" 149 8 149 50] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'36] domain self.current = domain self.final
  
  predicate payloads_unchanged [#"union_find_cpp.rs" 155 8 155 52] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'37] payloads_map self.current = payloads_map self.final
  
  let rec union (uf: MutBorrow.t t_UF) (x: t_Elem) (y: t_Elem) (return' (x'0: t_Elem)) =
    {[@expl:union 'uf' type invariant] [%#sunion_find_cpp'22] inv'7 uf}
    {[@expl:union requires] [%#sunion_find_cpp'23] in_domain uf.current x /\ in_domain uf.current y}
    any
    [ return''0 (result: t_Elem) -> {[%#sunion_find_cpp'24] domain_unchanged uf /\ payloads_unchanged uf}
      {[%#sunion_find_cpp'25] result = root uf.current x \/ result = root uf.current y}
      {[%#sunion_find_cpp'26] forall z: t_Elem. in_domain uf.current z
        -> root (fin uf) z
        = (if root uf.current z = root uf.current x \/ root uf.current z = root uf.current y then
          result
        else
          root uf.current z
        )}
      (! return' {result}) ]
  
  predicate unchanged [#"union_find_cpp.rs" 139 8 139 43] (self: MutBorrow.t t_UF) =
    [%#sunion_find_cpp'38] domain self.current = domain self.final
    /\ roots_map self.current = roots_map self.final /\ payloads_map self.current = payloads_map self.final
  
  let rec find (uf: MutBorrow.t t_UF) (elem: t_Elem) (return' (x: t_Elem)) =
    {[@expl:find 'uf' type invariant] [%#sunion_find_cpp'27] inv'7 uf}
    {[@expl:find requires] [%#sunion_find_cpp'28] in_domain uf.current elem}
    any
    [ return''0 (result: t_Elem) -> {[%#sunion_find_cpp'29] result = root uf.current elem}
      {[%#sunion_find_cpp'30] unchanged uf}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example [#"union_find_cpp.rs" 293 0 293 16] (return' (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new (fun (_ret: t_UF) -> [ &uf <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UF> {uf}
          (fun (_ret: MutBorrow.t t_UF) -> [ &_4 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_4} (fun (_ret: MutBorrow.t t_UF) -> [ &_3 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = make {_3} {[%#sunion_find_cpp] (1: Int32.t)} (fun (_ret: t_Elem) -> [ &x <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UF> {uf}
          (fun (_ret: MutBorrow.t t_UF) -> [ &_7 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_7} (fun (_ret: MutBorrow.t t_UF) -> [ &_6 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = make {_6} {[%#sunion_find_cpp'0] (2: Int32.t)} (fun (_ret: t_Elem) -> [ &y <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UF> {uf}
          (fun (_ret: MutBorrow.t t_UF) -> [ &_10 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_10} (fun (_ret: MutBorrow.t t_UF) -> [ &_9 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = make {_9} {[%#sunion_find_cpp'1] (3: Int32.t)} (fun (_ret: t_Elem) -> [ &z <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = borrow {uf} (fun (_ret: t_UF) -> [ &_15 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = get'0 {_15} {x} (fun (_ret: Int32.t) -> [ &_14 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_12 <- _14 = ([%#sunion_find_cpp'2] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_12 = false} (! bb10) | br1 -> {_12} (! bb12) ] ]
    | bb12 = s0 [ s0 = borrow {uf} (fun (_ret: t_UF) -> [ &_23 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = get'0 {_23} {y} (fun (_ret: Int32.t) -> [ &_22 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0
      [ s0 = [ &_20 <- _22 = ([%#sunion_find_cpp'3] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_20 = false} (! bb15) | br1 -> {_20} (! bb17) ] ]
    | bb17 = s0 [ s0 = borrow {uf} (fun (_ret: t_UF) -> [ &_31 <- _ret ] s1) | s1 = bb18 ]
    | bb18 = s0 [ s0 = get'0 {_31} {z} (fun (_ret: Int32.t) -> [ &_30 <- _ret ] s1) | s1 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_28 <- _30 = ([%#sunion_find_cpp'4] (3: Int32.t)) ] s1
      | s1 = any [ br0 -> {_28 = false} (! bb20) | br1 -> {_28} (! bb22) ] ]
    | bb22 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UF> {uf}
          (fun (_ret: MutBorrow.t t_UF) -> [ &_37 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_37} (fun (_ret: MutBorrow.t t_UF) -> [ &_36 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0 [ s0 = union {_36} {x} {y} (fun (_ret: t_Elem) -> [ &_35 <- _ret ] s1) | s1 = bb24 ]
    | bb24 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UF> {uf}
          (fun (_ret: MutBorrow.t t_UF) -> [ &_42 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_42} (fun (_ret: MutBorrow.t t_UF) -> [ &_41 <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0 [ s0 = find {_41} {x} (fun (_ret: t_Elem) -> [ &xr <- _ret ] s1) | s1 = bb26 ]
    | bb26 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UF> {uf}
          (fun (_ret: MutBorrow.t t_UF) -> [ &_46 <- _ret ] -{inv'4 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut {_46} (fun (_ret: MutBorrow.t t_UF) -> [ &_45 <- _ret ] s2)
      | s2 = bb27 ]
    | bb27 = s0 [ s0 = find {_45} {y} (fun (_ret: t_Elem) -> [ &yr <- _ret ] s1) | s1 = bb28 ]
    | bb28 = s0 [ s0 = borrow {uf} (fun (_ret: t_UF) -> [ &_52 <- _ret ] s1) | s1 = bb29 ]
    | bb29 = s0 [ s0 = get'0 {_52} {xr} (fun (_ret: Int32.t) -> [ &_51 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0 [ s0 = borrow {uf} (fun (_ret: t_UF) -> [ &_57 <- _ret ] s1) | s1 = bb31 ]
    | bb31 = s0 [ s0 = get'0 {_57} {yr} (fun (_ret: Int32.t) -> [ &_56 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0 [ s0 = [ &_49 <- _51 = _56 ] s1 | s1 = any [ br0 -> {_49 = false} (! bb33) | br1 -> {_49} (! bb35) ] ]
    | bb35 = s0 [ s0 = borrow {uf} (fun (_ret: t_UF) -> [ &_65 <- _ret ] s1) | s1 = bb36 ]
    | bb36 = s0 [ s0 = get'0 {_65} {z} (fun (_ret: Int32.t) -> [ &_64 <- _ret ] s1) | s1 = bb37 ]
    | bb37 = s0
      [ s0 = [ &_62 <- _64 = ([%#sunion_find_cpp'5] (3: Int32.t)) ] s1
      | s1 = any [ br0 -> {_62 = false} (! bb38) | br1 -> {_62} (! bb40) ] ]
    | bb40 = return''0 {_0}
    | bb38 = {[%#sunion_find_cpp'6] false} any
    | bb33 = {[%#sunion_find_cpp'7] false} any
    | bb20 = {[%#sunion_find_cpp'8] false} any
    | bb15 = {[%#sunion_find_cpp'9] false} any
    | bb10 = {[%#sunion_find_cpp'10] false} any ]
    [ & _0: () = Any.any_l ()
    | & uf: t_UF = Any.any_l ()
    | & x: t_Elem = Any.any_l ()
    | & _3: MutBorrow.t t_UF = Any.any_l ()
    | & _4: MutBorrow.t t_UF = Any.any_l ()
    | & y: t_Elem = Any.any_l ()
    | & _6: MutBorrow.t t_UF = Any.any_l ()
    | & _7: MutBorrow.t t_UF = Any.any_l ()
    | & z: t_Elem = Any.any_l ()
    | & _9: MutBorrow.t t_UF = Any.any_l ()
    | & _10: MutBorrow.t t_UF = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _15: t_UF = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _23: t_UF = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: Int32.t = Any.any_l ()
    | & _31: t_UF = Any.any_l ()
    | & _35: t_Elem = Any.any_l ()
    | & _36: MutBorrow.t t_UF = Any.any_l ()
    | & _37: MutBorrow.t t_UF = Any.any_l ()
    | & xr: t_Elem = Any.any_l ()
    | & _41: MutBorrow.t t_UF = Any.any_l ()
    | & _42: MutBorrow.t t_UF = Any.any_l ()
    | & yr: t_Elem = Any.any_l ()
    | & _45: MutBorrow.t t_UF = Any.any_l ()
    | & _46: MutBorrow.t t_UF = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: Int32.t = Any.any_l ()
    | & _52: t_UF = Any.any_l ()
    | & _56: Int32.t = Any.any_l ()
    | & _57: t_UF = Any.any_l ()
    | & _62: bool = Any.any_l ()
    | & _64: Int32.t = Any.any_l ()
    | & _65: t_UF = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_union_find_cpp__implementation__qyi8727259475583274922__eq__refines [#"union_find_cpp.rs" 18 8 18 42] (* <implementation::Elem<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find_cpp = "union_find_cpp.rs" 18 8 18 42
  let%span sunion_find_cpp'0 = "union_find_cpp.rs" 24 8 24 24
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  type t_Elem = { t_Elem__0: Opaque.ptr }
  
  function deep_model [#"union_find_cpp.rs" 25 8 25 36] [@inline:trivial] (self: t_Elem) : UInt64.t =
    [%#sunion_find_cpp'0] Opaque.addr_logic_u64 self.t_Elem__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Elem) : UInt64.t = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sunion_find_cpp] forall self_: t_Elem. forall rhs: t_Elem. forall result: bool. result
            = (deep_model'0 self_ = deep_model'0 rhs) -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
