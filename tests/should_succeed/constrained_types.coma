module M_constrained_types__uses_concrete_instance
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type tuple = { f0: UInt32.t; f1: UInt32.t }
  
  type tuple'0 = { f0'0: int; f1'0: int }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: tuple'0) (o: tuple'0) : t_Ordering = let r = cmp_log self.f0'0 o.f0'0 in if r = C_Equal then
      cmp_log self.f1'0 o.f1'0
    else
      r
  
  
  function eq_cmp'0 (x: tuple'0) (y: tuple'0) : ()
  
  axiom eq_cmp_spec'0: forall x: tuple'0, y: tuple'0. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: tuple'0) (y: tuple'0) : ()
  
  axiom antisym2_spec'0: forall x: tuple'0, y: tuple'0. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: tuple'0) (y: tuple'0) : ()
  
  axiom antisym1_spec'0: forall x: tuple'0, y: tuple'0. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: tuple'0) (y: tuple'0) (z: tuple'0) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: tuple'0, y: tuple'0, z: tuple'0, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: tuple'0) : ()
  
  axiom refl_spec'0: forall x: tuple'0. cmp_log'0 x x = C_Equal
  
  predicate gt_log (self: tuple'0) (o: tuple'0) = self.f0'0 = o.f0'0 /\ self.f1'0 > o.f1'0 \/ self.f0'0 > o.f0'0
  
  function cmp_gt_log'0 (x: tuple'0) (y: tuple'0) : ()
  
  axiom cmp_gt_log_spec'0: forall x: tuple'0, y: tuple'0. gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log (self: tuple'0) (o: tuple'0) = self.f0'0 = o.f0'0 /\ self.f1'0 >= o.f1'0 \/ self.f0'0 > o.f0'0
  
  function cmp_ge_log'0 (x: tuple'0) (y: tuple'0) : ()
  
  axiom cmp_ge_log_spec'0: forall x: tuple'0, y: tuple'0. ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log (self: tuple'0) (o: tuple'0) = self.f0'0 = o.f0'0 /\ self.f1'0 < o.f1'0 \/ self.f0'0 < o.f0'0
  
  function cmp_lt_log'0 (x: tuple'0) (y: tuple'0) : ()
  
  axiom cmp_lt_log_spec'0: forall x: tuple'0, y: tuple'0. lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log (self: tuple'0) (o: tuple'0) = self.f0'0 = o.f0'0 /\ self.f1'0 <= o.f1'0 \/ self.f0'0 < o.f0'0
  
  function cmp_le_log'0 (x: tuple'0) (y: tuple'0) : ()
  
  axiom cmp_le_log_spec'0: forall x: tuple'0, y: tuple'0. le_log x y = (cmp_log'0 x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: tuple) : tuple'0 = { f0'0 = deep_model self.f0;
                                                                      f1'0 = deep_model self.f1 }
  
  meta "rewrite_def" function deep_model'0
  
  function deep_model'1 [@inline:trivial] (self: tuple) : tuple'0 = deep_model'0 self
  
  meta "rewrite_def" function deep_model'1
  
  let rec lt (self_: tuple) (o: tuple) (return (x: bool)) = any
    [ return (result: bool) -> {result = lt_log (deep_model'1 self_) (deep_model'1 o)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec uses_concrete_instance (x: tuple) (y: tuple) (return (x'0: bool)) = (! bb0
    [ bb0 = s0 [ s0 = lt {x} {y} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: bool = Any.any_l () | & x: tuple = x | & y: tuple = y ]) [ return (result: bool) -> (! return {result}) ]
end
