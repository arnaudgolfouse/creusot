module M_uses_concrete_instance
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type tup2_u32_u32 = { f0: UInt32.t; f1: UInt32.t }
  
  type tup2_Int_Int = { f0'0: int; f1'0: int }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function cmp_log_tup2_Int_Int (self: tup2_Int_Int) (o: tup2_Int_Int) : t_Ordering =
    let r = cmp_log_Int self.f0'0 o.f0'0 in if r = Equal then cmp_log_Int self.f1'0 o.f1'0 else r
  
  function eq_cmp_tup2_Int_Int (x: tup2_Int_Int) (y: tup2_Int_Int) : ()
  
  axiom eq_cmp_tup2_Int_Int_spec: forall x: tup2_Int_Int, y: tup2_Int_Int. (x = y) = (cmp_log_tup2_Int_Int x y = Equal)
  
  function antisym2_tup2_Int_Int (x: tup2_Int_Int) (y: tup2_Int_Int) : ()
  
  axiom antisym2_tup2_Int_Int_spec: forall x: tup2_Int_Int, y: tup2_Int_Int. cmp_log_tup2_Int_Int x y = Greater
      -> cmp_log_tup2_Int_Int y x = Less
  
  function antisym1_tup2_Int_Int (x: tup2_Int_Int) (y: tup2_Int_Int) : ()
  
  axiom antisym1_tup2_Int_Int_spec: forall x: tup2_Int_Int, y: tup2_Int_Int. cmp_log_tup2_Int_Int x y = Less
      -> cmp_log_tup2_Int_Int y x = Greater
  
  function trans_tup2_Int_Int (x: tup2_Int_Int) (y: tup2_Int_Int) (z: tup2_Int_Int) (o: t_Ordering) : ()
  
  axiom trans_tup2_Int_Int_spec:
    forall x: tup2_Int_Int, y: tup2_Int_Int, z: tup2_Int_Int, o: t_Ordering. cmp_log_tup2_Int_Int x y = o
      -> cmp_log_tup2_Int_Int y z = o -> cmp_log_tup2_Int_Int x z = o
  
  function refl_tup2_Int_Int (x: tup2_Int_Int) : ()
  
  axiom refl_tup2_Int_Int_spec: forall x: tup2_Int_Int. cmp_log_tup2_Int_Int x x = Equal
  
  predicate gt_log_tup2_Int_Int (self: tup2_Int_Int) (o: tup2_Int_Int) =
    self.f0'0 = o.f0'0 /\ self.f1'0 > o.f1'0 \/ self.f0'0 > o.f0'0
  
  function cmp_gt_log_tup2_Int_Int (x: tup2_Int_Int) (y: tup2_Int_Int) : ()
  
  axiom cmp_gt_log_tup2_Int_Int_spec: forall x: tup2_Int_Int, y: tup2_Int_Int. gt_log_tup2_Int_Int x y
      = (cmp_log_tup2_Int_Int x y = Greater)
  
  predicate ge_log_tup2_Int_Int (self: tup2_Int_Int) (o: tup2_Int_Int) =
    self.f0'0 = o.f0'0 /\ self.f1'0 >= o.f1'0 \/ self.f0'0 > o.f0'0
  
  function cmp_ge_log_tup2_Int_Int (x: tup2_Int_Int) (y: tup2_Int_Int) : ()
  
  axiom cmp_ge_log_tup2_Int_Int_spec: forall x: tup2_Int_Int, y: tup2_Int_Int. ge_log_tup2_Int_Int x y
      = (cmp_log_tup2_Int_Int x y <> Less)
  
  predicate lt_log_tup2_Int_Int (self: tup2_Int_Int) (o: tup2_Int_Int) =
    self.f0'0 = o.f0'0 /\ self.f1'0 < o.f1'0 \/ self.f0'0 < o.f0'0
  
  function cmp_lt_log_tup2_Int_Int (x: tup2_Int_Int) (y: tup2_Int_Int) : ()
  
  axiom cmp_lt_log_tup2_Int_Int_spec: forall x: tup2_Int_Int, y: tup2_Int_Int. lt_log_tup2_Int_Int x y
      = (cmp_log_tup2_Int_Int x y = Less)
  
  predicate le_log_tup2_Int_Int (self: tup2_Int_Int) (o: tup2_Int_Int) =
    self.f0'0 = o.f0'0 /\ self.f1'0 <= o.f1'0 \/ self.f0'0 < o.f0'0
  
  function cmp_le_log_tup2_Int_Int (x: tup2_Int_Int) (y: tup2_Int_Int) : ()
  
  axiom cmp_le_log_tup2_Int_Int_spec: forall x: tup2_Int_Int, y: tup2_Int_Int. le_log_tup2_Int_Int x y
      = (cmp_log_tup2_Int_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  function deep_model_tup2_u32_u32 [@inline:trivial] (self: tup2_u32_u32) : tup2_Int_Int =
    { f0'0 = deep_model_u32 self.f0; f1'0 = deep_model_u32 self.f1 }
  
  meta "rewrite_def" function deep_model_tup2_u32_u32
  
  function deep_model_ref_tup2_u32_u32 [@inline:trivial] (self: tup2_u32_u32) : tup2_Int_Int =
    deep_model_tup2_u32_u32 self
  
  meta "rewrite_def" function deep_model_ref_tup2_u32_u32
  
  let rec lt_tup2_u32_u32 (self_: tup2_u32_u32) (o: tup2_u32_u32) (return (x: bool)) = any
    [ return (result: bool) -> {result
      = lt_log_tup2_Int_Int (deep_model_ref_tup2_u32_u32 self_) (deep_model_ref_tup2_u32_u32 o)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec uses_concrete_instance (x: tup2_u32_u32) (y: tup2_u32_u32) (return (x'0: bool)) = (! bb0
    [ bb0 = s0 [ s0 = lt_tup2_u32_u32 {x} {y} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ] [ & _0: bool = Any.any_l () | & x: tup2_u32_u32 = x | & y: tup2_u32_u32 = y ])
    [ return (result: bool) -> (! return {result}) ]
end
