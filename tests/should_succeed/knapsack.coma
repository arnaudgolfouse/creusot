module M_knapsack__max
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.MinMax
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec max (a: UInt64.t) (b: UInt64.t) (return (x: UInt64.t)) = {[@expl:max requires] true}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- UInt64.lt a b ] s1 | s1 = any [ br0 -> {_5 = false} (! bb2) | br1 -> {_5} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- b ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_0 <- a ] s1 | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & a: UInt64.t = a | & b: UInt64.t = b | & _5: bool = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:max ensures] UInt64.t'int result
      = MinMax.max (UInt64.t'int a) (UInt64.t'int b)}
      (! return {result}) ]
end
module M_knapsack__m
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant items : Seq.seq t_Item
  
  constant i : int
  
  constant w : int
  
  function m (items: Seq.seq t_Item) (i: int) (w: int) : int
  
  goal vc_m: 0 <= i /\ i <= Seq.length items
    -> 0 <= w
    -> (if i = 0 then
      [@expl:m ensures] 0 >= 0
    else
      if UInt64.t'int (Seq.get items (i - 1)).t_Item__weight > w then
        ((([@expl:m requires #0] 0 <= i - 1 /\ i - 1 <= Seq.length items) && ([@expl:m requires #1] 0 <= w))
          /\ well_founded_relation i (i - 1))
        /\ (m items (i - 1) w >= 0 -> ([@expl:m ensures] m items (i - 1) w >= 0))
      else
        ((([@expl:m requires #0] 0 <= i - 1 /\ i - 1 <= Seq.length items) && ([@expl:m requires #1] 0 <= w))
          /\ well_founded_relation i (i - 1))
        /\ (m items (i - 1) w >= 0
        -> ((([@expl:m requires #0] 0 <= i - 1 /\ i - 1 <= Seq.length items)
            && ([@expl:m requires #1] 0 <= w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight))
          /\ well_founded_relation i (i - 1))
        /\ (m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight) >= 0
        -> ([@expl:m ensures] MinMax.max (m items (i - 1) w) (m items (i - 1) (w
            - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight)
          + UInt64.t'int (Seq.get items (i - 1)).t_Item__value)
        >= 0)))
    
    )
end
module M_knapsack__knapsack01_dyn
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Vec
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : UInt64.t = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  let rec from_elem (elem: UInt64.t) (n: UInt64.t) (return (x: t_Vec)) = any
    [ return (result: t_Vec) -> {Seq.length (view result) = UInt64.t'int n}
      {forall i: int. 0 <= i /\ i < UInt64.t'int n -> index_logic result i = elem}
      (! return {result}) ]
  
  type t_Vec'0
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate inv (_1: t_Name)
  
  predicate inv'0 (_1: t_Item)
  
  axiom inv_axiom [@rewrite]: forall x: t_Item [inv'0 x]. inv'0 x
      = match x with
        | {t_Item__name = name; t_Item__weight = weight; t_Item__value = value} -> inv name
        end
  
  predicate invariant' (self: t_Item) = inv'0 self
  
  predicate inv'1 (_1: t_Item)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Item [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: Seq.seq t_Item)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_Item [inv'2 x]. inv'2 x = invariant''0 x
  
  function view'0 (self: t_Vec'0) : Seq.seq t_Item
  
  axiom view_spec'0: forall self: t_Vec'0. Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec'0) = inv'2 (view'0 self)
  
  predicate inv'3 (_1: t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec'0 [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_Vec'0) = inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_1: t_Vec'0)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Vec'0 [inv'4 x]. inv'4 x = invariant''2 x
  
  let rec len (self_: t_Vec'0) (return (x: UInt64.t)) = {[@expl:len 'self_' type invariant] inv'4 self_}
    any [ return (result: UInt64.t) -> {UInt64.t'int result = Seq.length (view'0 self_)} (! return {result}) ]
  
  type t_Vec'1
  
  function view'1 (self: t_Vec'1) : Seq.seq t_Vec
  
  axiom view_spec'1: forall self: t_Vec'1. Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  function index_logic'0 [@inline:trivial] (self: t_Vec'1) (ix: int) : t_Vec = Seq.get (view'1 self) ix
  
  meta "rewrite_def" function index_logic'0
  
  let rec from_elem'0 (elem: t_Vec) (n: UInt64.t) (return (x: t_Vec'1)) = any
    [ return (result: t_Vec'1) -> {Seq.length (view'1 result) = UInt64.t'int n}
      {forall i: int. 0 <= i /\ i < UInt64.t'int n -> index_logic'0 result i = elem}
      (! return {result}) ]
  
  function m (items: Seq.seq t_Item) (i: int) (w: int) : int
  
  axiom m_def: forall items: Seq.seq t_Item, i: int, w: int. 0 <= i /\ i <= Seq.length items
      -> 0 <= w
      -> m items i w
      = (if i = 0 then
        0
      else
        if UInt64.t'int (Seq.get items (i - 1)).t_Item__weight > w then
          m items (i - 1) w
        else
          MinMax.max (m items (i - 1) w) (m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight)
          + UInt64.t'int (Seq.get items (i - 1)).t_Item__value)
      
      )
  
  axiom m_spec: forall items: Seq.seq t_Item, i: int, w: int. 0 <= i /\ i <= Seq.length items
      -> 0 <= w -> m items i w >= 0
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Item) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  predicate invariant''3 [@inline:trivial] (self: t_Item) = inv'0 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 (_1: t_Item)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Item [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Item) (out: t_Item) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec index (self_: t_Vec'0) (ix: UInt64.t) (return (x: t_Item)) =
    {[@expl:index 'self_' type invariant] inv'4 self_}
    {[@expl:index requires] in_bounds ix (view'0 self_)}
    any [ return (result: t_Item) -> {inv'5 result} {has_value ix (view'0 self_) result} (! return {result}) ]
  
  predicate in_bounds'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds'0
  
  predicate has_value'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec) (out: t_Vec) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value'0
  
  let rec index'0 (self_: t_Vec'1) (ix: UInt64.t) (return (x: t_Vec)) =
    {[@expl:index requires] in_bounds'0 ix (view'1 self_)}
    any [ return (result: t_Vec) -> {has_value'0 ix (view'1 self_) result} (! return {result}) ]
  
  predicate in_bounds'1 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds'1
  
  predicate has_value'1 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value'1
  
  let rec index'1 (self_: t_Vec) (ix: UInt64.t) (return (x: UInt64.t)) =
    {[@expl:index requires] in_bounds'1 ix (view self_)}
    any [ return (result: UInt64.t) -> {has_value'1 ix (view self_) result} (! return {result}) ]
  
  let rec max (a: UInt64.t) (b: UInt64.t) (return (x: UInt64.t)) = {[@expl:max requires] true}
    any
    [ return (result: UInt64.t) -> {UInt64.t'int result = MinMax.max (UInt64.t'int a) (UInt64.t'int b)}
      (! return {result}) ]
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_Vec) (fin: Seq.seq t_Vec) =
    forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere
  
  let rec index_mut (self_: MutBorrow.t t_Vec'1) (ix: UInt64.t) (return (x: MutBorrow.t t_Vec)) =
    {[@expl:index_mut requires] in_bounds'0 ix (view'1 self_.current)}
    any
    [ return (result: MutBorrow.t t_Vec) -> {has_value'0 ix (view'1 self_.current) result.current}
      {has_value'0 ix (view'1 self_.final) result.final}
      {resolve_elswhere ix (view'1 self_.current) (view'1 self_.final)}
      {Seq.length (view'1 self_.final) = Seq.length (view'1 self_.current)}
      (! return {result}) ]
  
  predicate resolve_elswhere'0 [@inline:trivial] (self: UInt64.t) (old': Seq.seq UInt64.t) (fin: Seq.seq UInt64.t) =
    forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere'0
  
  let rec index_mut'0 (self_: MutBorrow.t t_Vec) (ix: UInt64.t) (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] in_bounds'1 ix (view self_.current)}
    any
    [ return (result: MutBorrow.t UInt64.t) -> {has_value'1 ix (view self_.current) result.current}
      {has_value'1 ix (view self_.final) result.final}
      {resolve_elswhere'0 ix (view self_.current) (view self_.final)}
      {Seq.length (view self_.final) = Seq.length (view self_.current)}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t UInt64.t) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t UInt64.t) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Vec) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Vec) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type t_Vec'2
  
  predicate invariant''4 (self: t_Item) = inv'5 self
  
  predicate inv'6 (_1: t_Item)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Item [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'6 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'7 (_1: Seq.seq t_Item)
  
  axiom inv_axiom'6 [@rewrite]: forall x: Seq.seq t_Item [inv'7 x]. inv'7 x = invariant''5 x
  
  function view'2 (self: t_Vec'2) : Seq.seq t_Item
  
  axiom view_spec'2: forall self: t_Vec'2. Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  predicate invariant''6 (self: t_Vec'2) = inv'7 (view'2 self)
  
  predicate inv'8 (_1: t_Vec'2)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Vec'2 [inv'8 x]. inv'8 x = invariant''6 x
  
  let rec with_capacity (capacity: UInt64.t) (return (x: t_Vec'2)) = any
    [ return (result: t_Vec'2) -> {inv'8 result} {Seq.length (view'2 result) = 0} (! return {result}) ]
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_Vec'2) = inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'9 (_1: MutBorrow.t t_Vec'2)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Vec'2 [inv'9 x]. inv'9 x = invariant''7 x
  
  let rec push (self_: MutBorrow.t t_Vec'2) (v: t_Item) (return (x: ())) =
    {[@expl:push 'self_' type invariant] inv'9 self_}
    {[@expl:push 'v' type invariant] inv'5 v}
    any [ return (result: ()) -> {view'2 self_.final = Seq.snoc (view'2 self_.current) v} (! return {result}) ]
  
  function index_logic'1 [@inline:trivial] (self: t_Vec'0) (ix: int) : t_Item = Seq.get (view'0 self) ix
  
  meta "rewrite_def" function index_logic'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec knapsack01_dyn (items: t_Vec'0) (max_weight: UInt64.t) (return (x: t_Vec'2)) =
    {[@expl:knapsack01_dyn 'items' type invariant] inv'4 items}
    {[@expl:knapsack01_dyn requires #0] Seq.length (view'0 items) < 10000000}
    {[@expl:knapsack01_dyn requires #1] UInt64.t'int max_weight < 10000000}
    {[@expl:knapsack01_dyn requires #2] forall i: int. 0 <= i /\ i < Seq.length (view'0 items)
      -> UInt64.t'int (index_logic'1 items i).t_Item__value <= 10000000}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.add {max_weight} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_8 <- _ret ] s1)
      | s1 = from_elem {(0: UInt64.t)} {_8} (fun (_ret: t_Vec) -> [ &_7 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = len {items} (fun (_ret: UInt64.t) -> [ &_11 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.add {_11} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_10 <- _ret ] s1)
      | s1 = from_elem'0 {_7} {_10} (fun (_ret: t_Vec'1) -> [ &best_value <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = [ &i <- (0: UInt64.t) ] s1 | s1 = bb4 ]
    | bb4 = bb4
      [ bb4 = {[@expl:loop invariant #0] Seq.length (view'0 items) + 1 = Seq.length (view'1 best_value)}
        {[@expl:loop invariant #1] forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'1 best_value)
          -> UInt64.t'int max_weight + 1 = Seq.length (view (index_logic'0 best_value i'0))}
        {[@expl:loop invariant #2] forall ii: int, ww: int. 0 <= ii
            /\ ii <= UInt64.t'int i /\ 0 <= ww /\ ww <= UInt64.t'int max_weight
          -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) = m (view'0 items) ii ww}
        {[@expl:loop invariant #3] forall ii: int, ww: int. 0 <= ii
            /\ ii <= Seq.length (view'0 items) /\ 0 <= ww /\ ww <= UInt64.t'int max_weight
          -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) <= 10000000 * ii}
        (! s0)
        [ s0 = bb5 ]
        [ bb5 = s0 [ s0 = len {items} (fun (_ret: UInt64.t) -> [ &_23 <- _ret ] s1) | s1 = bb6 ]
        | bb6 = s0
          [ s0 = [ &_21 <- UInt64.lt i _23 ] s1 | s1 = any [ br0 -> {_21 = false} (! bb25) | br1 -> {_21} (! bb7) ] ]
        | bb7 = s0 [ s0 = index {items} {i} (fun (_ret: t_Item) -> [ &_26 <- _ret ] s1) | s1 = bb8 ]
        | bb8 = s0 [ s0 = [ &it <- _26 ] s1 | s1 = [ &w <- (0: UInt64.t) ] s2 | s2 = bb9 ]
        | bb9 = bb9
          [ bb9 = {[@expl:loop invariant #0] Seq.length (view'0 items) + 1 = Seq.length (view'1 best_value)}
            {[@expl:loop invariant #1] forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'1 best_value)
              -> UInt64.t'int max_weight + 1 = Seq.length (view (index_logic'0 best_value i'0))}
            {[@expl:loop invariant #2] forall ii: int, ww: int. 0 <= ii
                /\ ii <= UInt64.t'int i /\ 0 <= ww /\ ww <= UInt64.t'int max_weight
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) = m (view'0 items) ii ww}
            {[@expl:loop invariant #3] forall ww: int. 0 <= ww /\ ww <= UInt64.t'int w - 1
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value (UInt64.t'int i + 1))) ww)
              = m (view'0 items) (UInt64.t'int i + 1) ww}
            {[@expl:loop invariant #4] forall ii: int, ww: int. 0 <= ii
                /\ ii <= Seq.length (view'0 items) /\ 0 <= ww /\ ww <= UInt64.t'int max_weight
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) <= 10000000 * ii}
            (! s0)
            [ s0 = bb10 ]
            [ bb10 = s0
              [ s0 = [ &_37 <- UInt64.le w max_weight ] s1
              | s1 = any [ br0 -> {_37 = false} (! bb24) | br1 -> {_37} (! bb11) ] ]
            | bb11 = s0
              [ s0 = [ &_41 <- UInt64.gt it.t_Item__weight w ] s1
              | s1 = any [ br0 -> {_41 = false} (! bb15) | br1 -> {_41} (! bb12) ] ]
            | bb12 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_46 <- _ret ] s1) | s1 = bb13 ]
            | bb13 = s0 [ s0 = index'1 {_46} {w} (fun (_ret: UInt64.t) -> [ &_44 <- _ret ] s1) | s1 = bb14 ]
            | bb14 = s0 [ s0 = [ &_40 <- _44 ] s1 | s1 = bb21 ]
            | bb15 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_53 <- _ret ] s1) | s1 = bb16 ]
            | bb16 = s0 [ s0 = index'1 {_53} {w} (fun (_ret: UInt64.t) -> [ &_51 <- _ret ] s1) | s1 = bb17 ]
            | bb17 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_61 <- _ret ] s1) | s1 = bb18 ]
            | bb18 = s0
              [ s0 = UInt64.sub {w} {it.t_Item__weight} (fun (_ret: UInt64.t) -> [ &_64 <- _ret ] s1)
              | s1 = index'1 {_61} {_64} (fun (_ret: UInt64.t) -> [ &_59 <- _ret ] s2)
              | s2 = bb19 ]
            | bb19 = s0
              [ s0 = UInt64.add {_59} {it.t_Item__value} (fun (_ret: UInt64.t) -> [ &_57 <- _ret ] s1)
              | s1 = max {_51} {_57} (fun (_ret: UInt64.t) -> [ &_40 <- _ret ] s2)
              | s2 = bb21 ]
            | bb21 = s0
              [ s0 = MutBorrow.borrow_mut <t_Vec'1> {best_value}
                  (fun (_ret: MutBorrow.t t_Vec'1) -> [ &_71 <- _ret ] [ &best_value <- _ret.final ] s1)
              | s1 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_72 <- _ret ] s2)
              | s2 = index_mut {_71} {_72} (fun (_ret: MutBorrow.t t_Vec) -> [ &_70 <- _ret ] s3)
              | s3 = bb22 ]
            | bb22 = s0
              [ s0 = MutBorrow.borrow_final <t_Vec> {_70.current} {MutBorrow.get_id _70}
                  (fun (_ret: MutBorrow.t t_Vec) -> [ &_69 <- _ret ] [ &_70 <- { _70 with current = _ret.final } ] s1)
              | s1 = index_mut'0 {_69} {w} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_68 <- _ret ] s2)
              | s2 = bb23 ]
            | bb23 = s0
              [ s0 = [ &_68 <- { _68 with current = _40 } ] s1
              | s1 = -{resolve'0 _68}- s2
              | s2 = -{resolve'2 _70}- s3
              | s3 = UInt64.add {w} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &w <- _ret ] s4)
              | s4 = bb9 ] ] ]
        | bb24 = s0 [ s0 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s1) | s1 = bb4 ] ] ]
    | bb25 = s0 [ s0 = len {items} (fun (_ret: UInt64.t) -> [ &_78 <- _ret ] s1) | s1 = bb26 ]
    | bb26 = s0 [ s0 = with_capacity {_78} (fun (_ret: t_Vec'2) -> [ &result <- _ret ] s1) | s1 = bb27 ]
    | bb27 = s0
      [ s0 = [ &left_weight <- max_weight ] s1
      | s1 = len {items} (fun (_ret: UInt64.t) -> [ &j <- _ret ] s2)
      | s2 = bb29 ]
    | bb29 = bb29
      [ bb29 = {[@expl:loop invariant #0] inv'8 result}
        {[@expl:loop invariant #1] UInt64.t'int j <= Seq.length (view'0 items)}
        {[@expl:loop invariant #2] UInt64.t'int left_weight <= UInt64.t'int max_weight}
        (! s0)
        [ s0 = bb30 ]
        [ bb30 = s0
          [ s0 = [ &_88 <- UInt64.lt (0: UInt64.t) j ] s1
          | s1 = any [ br0 -> {_88 = false} (! bb41) | br1 -> {_88} (! bb31) ] ]
        | bb31 = s0
          [ s0 = UInt64.sub {j} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &j <- _ret ] s1)
          | s1 = index {items} {j} (fun (_ret: t_Item) -> [ &_91 <- _ret ] s2)
          | s2 = bb32 ]
        | bb32 = s0
          [ s0 = [ &it'0 <- _91 ] s1
          | s1 = UInt64.add {j} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_100 <- _ret ] s2)
          | s2 = index'0 {best_value} {_100} (fun (_ret: t_Vec) -> [ &_98 <- _ret ] s3)
          | s3 = bb33 ]
        | bb33 = s0 [ s0 = index'1 {_98} {left_weight} (fun (_ret: UInt64.t) -> [ &_96 <- _ret ] s1) | s1 = bb34 ]
        | bb34 = s0 [ s0 = index'0 {best_value} {j} (fun (_ret: t_Vec) -> [ &_106 <- _ret ] s1) | s1 = bb35 ]
        | bb35 = s0 [ s0 = index'1 {_106} {left_weight} (fun (_ret: UInt64.t) -> [ &_104 <- _ret ] s1) | s1 = bb36 ]
        | bb36 = s0
          [ s0 = [ &_94 <- _96 <> _104 ] s1 | s1 = any [ br0 -> {_94 = false} (! bb29) | br1 -> {_94} (! bb37) ] ]
        | bb37 = s0
          [ s0 = {inv'8 result}
            MutBorrow.borrow_mut <t_Vec'2> {result}
              (fun (_ret: MutBorrow.t t_Vec'2) -> [ &_111 <- _ret ] -{inv'8 _ret.final}- [ &result <- _ret.final ] s1)
          | s1 = push {_111} {it'0} (fun (_ret: ()) -> [ &_110 <- _ret ] s2)
          | s2 = bb38 ]
        | bb38 = s0
          [ s0 = UInt64.sub {left_weight} {it'0.t_Item__weight} (fun (_ret: UInt64.t) -> [ &left_weight <- _ret ] s1)
          | s1 = bb29 ] ] ]
    | bb41 = s0 [ s0 = [ &_0 <- result ] s1 | s1 = bb43 ]
    | bb43 = return {_0} ]
    [ & _0: t_Vec'2 = Any.any_l ()
    | & items: t_Vec'0 = items
    | & max_weight: UInt64.t = max_weight
    | & best_value: t_Vec'1 = Any.any_l ()
    | & _7: t_Vec = Any.any_l ()
    | & _8: UInt64.t = Any.any_l ()
    | & _10: UInt64.t = Any.any_l ()
    | & _11: UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: UInt64.t = Any.any_l ()
    | & it: t_Item = Any.any_l ()
    | & _26: t_Item = Any.any_l ()
    | & w: UInt64.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _40: UInt64.t = Any.any_l ()
    | & _41: bool = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _46: t_Vec = Any.any_l ()
    | & _51: UInt64.t = Any.any_l ()
    | & _53: t_Vec = Any.any_l ()
    | & _57: UInt64.t = Any.any_l ()
    | & _59: UInt64.t = Any.any_l ()
    | & _61: t_Vec = Any.any_l ()
    | & _64: UInt64.t = Any.any_l ()
    | & _68: MutBorrow.t UInt64.t = Any.any_l ()
    | & _69: MutBorrow.t t_Vec = Any.any_l ()
    | & _70: MutBorrow.t t_Vec = Any.any_l ()
    | & _71: MutBorrow.t t_Vec'1 = Any.any_l ()
    | & _72: UInt64.t = Any.any_l ()
    | & result: t_Vec'2 = Any.any_l ()
    | & _78: UInt64.t = Any.any_l ()
    | & left_weight: UInt64.t = Any.any_l ()
    | & j: UInt64.t = Any.any_l ()
    | & _88: bool = Any.any_l ()
    | & it'0: t_Item = Any.any_l ()
    | & _91: t_Item = Any.any_l ()
    | & _94: bool = Any.any_l ()
    | & _96: UInt64.t = Any.any_l ()
    | & _98: t_Vec = Any.any_l ()
    | & _100: UInt64.t = Any.any_l ()
    | & _104: UInt64.t = Any.any_l ()
    | & _106: t_Vec = Any.any_l ()
    | & _110: () = Any.any_l ()
    | & _111: MutBorrow.t t_Vec'2 = Any.any_l () ])
    [ return (result: t_Vec'2) -> {[@expl:knapsack01_dyn result type invariant] inv'8 result} (! return {result}) ]
end
