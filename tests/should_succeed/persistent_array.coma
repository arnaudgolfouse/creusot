module M_persistent_array__implementation__qyi15164097500274694161__clone [#"persistent_array.rs" 45 8 45 31] (* <implementation::PersistentArray<T> as creusot_contracts::Clone> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 45 18 45 37
  let%span spersistent_array = "persistent_array.rs" 45 18 45 22
  let%span spersistent_array'0 = "persistent_array.rs" 45 27 45 31
  let%span spersistent_array'1 = "persistent_array.rs" 44 18 44 34
  let%span spersistent_array'2 = "persistent_array.rs" 76 16 76 41
  let%span spersistent_array'3 = "persistent_array.rs" 59 16 61 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 55 14 55 29
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 91 8 91 22
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  use seq.Seq
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1 = { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray = {
    t_PersistentArray__program_value: t_Rc;
    t_PersistentArray__contained_in_inv: t_Rc'0;
    t_PersistentArray__map_invariant: t_Rc'1 }
  
  type t_NonNull'2 = { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell = { t_UnsafeCell__value: t_Inner }
  
  type t_PCell = { t_PCell__0: t_UnsafeCell }
  
  function view (self: t_Rc) : t_PCell
  
  let rec clone' (self_: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src] view result = view self_} (! return' {result}) ]
  
  let rec clone''0 (self: t_Rc'0) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost] result = self} (! return' {result}) ]
  
  let rec clone''1 (self: t_Rc'1) (return' (x: t_Rc'1)) = any
    [ return''0 (result: t_Rc'1) -> {[%#sghost] result = self} (! return' {result}) ]
  
  type t_Resource
  
  type t_Id
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view'0 (self: t_Fragment) : tuple
  
  function view'1 (self: t_Fragment) : tuple = [%#sboxed] view'0 self
  
  function view'2 (self: t_Rc'0) : t_Fragment
  
  function view'3 (self: t_Rc'0) : t_Fragment = [%#sghost'0] view'2 self
  
  function id (self: t_PCell) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'4 (self: t_Rc'1) : t_LocalInvariant
  
  function view'5 (self: t_Rc'1) : t_LocalInvariant = [%#sghost'0] view'4 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant' [#"persistent_array.rs" 56 8 56 34] (self: t_PersistentArray) =
    [%#spersistent_array'3] (view'1 (view'3 self.t_PersistentArray__contained_in_inv))._p0
      = id (view self.t_PersistentArray__program_value)
    /\ id'0 (view'3 self.t_PersistentArray__contained_in_inv) = public (view'5 self.t_PersistentArray__map_invariant)
    /\ namespace (view'5 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv (_0: t_PersistentArray)
  
  axiom inv_axiom [@rewrite]: forall x: t_PersistentArray [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_PersistentArray__program_value = program_value; t_PersistentArray__contained_in_inv = contained_in_inv; t_PersistentArray__map_invariant = map_invariant} -> true
        end)
  
  predicate invariant''0 (self: t_PersistentArray) = [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_PersistentArray)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PersistentArray [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'6 [#"persistent_array.rs" 74 8 74 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'2] (view'1 (view'3 self.t_PersistentArray__contained_in_inv))._p1
  
  function view'7 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'6 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''2 [#"persistent_array.rs" 45 8 45 31] (self: t_PersistentArray) (return' (x: t_PersistentArray)) =
    {[@expl:clone 'self' type invariant] [%#spersistent_array] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = clone' {self'0.t_PersistentArray__program_value} (fun (_ret: t_Rc) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = clone''0 {self'0.t_PersistentArray__contained_in_inv} (fun (_ret: t_Rc'0) -> [ &_5 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0
      [ s0 = clone''1 {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc'1) -> [ &_7 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_0 <- { t_PersistentArray__program_value = _3;
                        t_PersistentArray__contained_in_inv = _5;
                        t_PersistentArray__map_invariant = _7 } ] s1
      | s1 = bb4 ]
    | bb4 = return''0 {_0} ]
    [ & _0: t_PersistentArray = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & _3: t_Rc = Any.any_l ()
    | & _5: t_Rc'0 = Any.any_l ()
    | & _7: t_Rc'1 = Any.any_l () ])
    [ return''0 (result: t_PersistentArray) -> {[@expl:clone result type invariant] [%#spersistent_array'0] inv result}
      {[@expl:clone ensures] [%#spersistent_array'1] view'6 result = view'7 self}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__new [#"persistent_array.rs" 125 8 125 37] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 31 26 31 43
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 32 23 32 28
  let%span spersistent_array = "persistent_array.rs" 126 32 126 45
  let%span spersistent_array'0 = "persistent_array.rs" 128 21 128 46
  let%span spersistent_array'1 = "persistent_array.rs" 129 25 129 55
  let%span spersistent_array'2 = "persistent_array.rs" 132 26 132 51
  let%span spersistent_array'3 = "persistent_array.rs" 141 30 141 46
  let%span spersistent_array'4 = "persistent_array.rs" 144 20 144 39
  let%span spersistent_array'5 = "persistent_array.rs" 145 20 145 39
  let%span spersistent_array'6 = "persistent_array.rs" 125 19 125 20
  let%span spersistent_array'7 = "persistent_array.rs" 125 33 125 37
  let%span spersistent_array'8 = "persistent_array.rs" 124 18 124 31
  let%span spersistent_array'9 = "persistent_array.rs" 76 16 76 41
  let%span spersistent_array'10 = "persistent_array.rs" 102 16 117 21
  let%span spersistent_array'11 = "persistent_array.rs" 59 16 61 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 195 14 195 29
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 197 22 197 26
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 197 4 199 17
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 91 8 91 22
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 63 8 63 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 99 15 99 20
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 99 4 99 54
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 97 14 97 44
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 98 14 98 35
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 30 4 30 12
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 58 20 58 46
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 41 8 41 27
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 80 4 80 31
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 79 14 79 38
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 23 96 27
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 89 15 89 34
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 4 96 78
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 90 14 90 46
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 91 14 91 39
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 92 14 92 33
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 93 14 93 38
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 286 4 286 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 284 4 284 33
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 445 29 445 33
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 445 43 445 48
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 445 4 445 65
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 443 14 443 49
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 444 14 444 40
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 120 4 120 12
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span sfmap'17 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span ssnapshot = "../../creusot-contracts/src/snapshot.rs" 125 14 125 30
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 301 8 301 13
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 296 4 296 51
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 297 14 297 40
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 298 14 298 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 50 20 50 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 76 8 79 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 686 20 686 91
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell = { t_UnsafeCell__value: t_Inner }
  
  type t_PCell = { t_PCell__0: t_UnsafeCell }
  
  type t_PCellOwn = { t_PCellOwn__0: () }
  
  type tuple = { _p0: t_PCell; _p1: t_PCellOwn }
  
  predicate inv (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed'0] inv self
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  predicate inv'1 (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 (self: t_Vec) = [%#svec'0] inv'1 (view self)
  
  predicate inv'2 (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
      = match x with
        | C_Direct a_0 -> inv'2 a_0
        | C_Link index value next -> inv value
        end
  
  predicate inv'4 (_0: t_UnsafeCell)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnsafeCell [inv'4 x]. inv'4 x
      = match x with
        | {t_UnsafeCell__value = value} -> inv'3 value
        end
  
  predicate inv'5 (_0: t_PCell)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PCell [inv'5 x]. inv'5 x
      = match x with
        | {t_PCell__0 = a_0} -> inv'4 a_0
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant'0] inv'3 self
  
  predicate inv'6 (_0: t_Inner)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Inner [inv'6 x]. inv'6 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) = [%#spcell'4] inv'6 (val' self)
  
  predicate inv'7 (_0: t_PCellOwn)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_PCellOwn [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self: t_PCellOwn) = [%#sghost'9] inv'7 self
  
  predicate inv'8 (_0: t_PCellOwn)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_PCellOwn [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate inv'9 (_0: tuple)
  
  axiom inv_axiom'8 [@rewrite]: forall x: tuple [inv'9 x]. inv'9 x
      = (let {_p0 = x0; _p1 = x1} = x in inv'5 x0 /\ inv'8 x1)
  
  type t_Id
  
  function id (self: t_PCell) : t_Id
  
  function id'0 (self: t_PCellOwn) : t_Id
  
  function view'0 (self: t_PCellOwn) : t_Inner = [%#spcell'3] val' self
  
  let rec new (value: t_Inner) (return' (x: tuple)) = {[@expl:new 'value' type invariant] [%#spcell] inv'3 value}
    any
    [ return''0 (result: tuple) -> {[%#spcell'0] inv'9 result}
      {[%#spcell'1] id result._p0 = id'0 result._p1}
      {[%#spcell'2] view'0 result._p1 = value}
      (! return' {result}) ]
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'10 (_0: t_Authority)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Authority [inv'10 x]. inv'10 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate invariant''6 (self: t_Authority) = [%#sghost'9] inv'10 self
  
  predicate inv'11 (_0: t_Authority)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Authority [inv'11 x]. inv'11 x = invariant''6 x
  
  type t_FMap
  
  function view'1 (self: t_Authority) : t_FMap
  
  function view'2 (self: t_Authority) : t_FMap = [%#sghost'8] view'1 self
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'13] len self >= 0
  
  type t_Option = C_None | C_Some (Seq.seq t_T)
  
  function view'3 (self: t_FMap) : Map.map t_Id t_Option
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'6] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'7] view'3 empty = Const.const (C_None)
  
  let rec new'0 (return' (x: t_Authority)) = any
    [ return''0 (result: t_Authority) -> {[%#sfmap_view] inv'11 result}
      {[%#sfmap_view'0] view'2 result = empty}
      (! return' {result}) ]
  
  predicate invariant''7 (self: MutBorrow.t t_Authority) = [%#sinvariant] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'12 (_0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'12 x]. inv'12 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t t_Authority) = [%#sinvariant] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'13 (_0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'13 x]. inv'13 x = invariant''8 x
  
  let rec deref_mut (self: MutBorrow.t t_Authority) (return' (x: MutBorrow.t t_Authority)) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'12 self}
    any
    [ return''0 (result: MutBorrow.t t_Authority) -> {[%#sghost'0] inv'13 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'12] Map.get (view'3 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'8] get self k <> C_None
  
  function view'4 (self: MutBorrow.t t_Authority) : t_FMap = [%#smodel] view'1 self.current
  
  predicate invariant''9 (self: t_Fragment)
  
  predicate inv'14 (_0: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
      = (invariant''9 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  function insert (self: t_FMap) (k: t_Id) (v: Seq.seq t_T) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: Seq.seq t_T. [%#sfmap'9] view'3 (insert self k v)
      = Map.set (view'3 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: Seq.seq t_T. [%#sfmap'10] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function id'1 (self: t_Authority) : t_Id
  
  type tuple'0 = { _p0'0: t_Id; _p1'0: Seq.seq t_T }
  
  function view'5 (self: t_Fragment) : tuple'0
  
  function id'2 (self: t_Fragment) : t_Id
  
  let rec insert'0 (self: MutBorrow.t t_Authority) (k: t_Id) (v: Seq.seq t_T) (return' (x: t_Fragment)) =
    {[@expl:insert 'self' type invariant] [%#sfmap_view'1] inv'13 self}
    {[@expl:insert requires] [%#sfmap_view'2] not contains (view'4 self) k}
    any
    [ return''0 (result: t_Fragment) -> {[%#sfmap_view'3] inv'14 result}
      {[%#sfmap_view'4] view'1 self.final = insert (view'4 self) k v}
      {[%#sfmap_view'5] id'1 self.final = id'1 self.current}
      {[%#sfmap_view'6] view'5 result = { _p0'0 = k; _p1'0 = v }}
      {[%#sfmap_view'7] id'2 result = id'1 self.current}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_Authority) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Authority) = resolve _0
  
  predicate invariant''10 (self: t_Fragment) = [%#sghost'9] inv'14 self
  
  predicate inv'15 (_0: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec new'1 (x: t_Fragment) (return' (x'0: t_Fragment)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'14 x}
    any
    [ return''0 (result: t_Fragment) -> {[%#sghost'3] inv'15 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PCellOwn
  
  function view'6 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = [%#sfmap'12] Map.get (view'6 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'8] get'0 self k <> C_None'0
  
  predicate inv'16 (_0: t_Id)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Id [inv'16 x]. inv'16 x = true
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option'0) : t_PCellOwn = [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_PCellOwn = [%#sfmap'18] unwrap_logic (get'0 self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : t_PCellOwn = [%#sfmap'17] lookup self key
  
  predicate invariant''11 (self: t_FMap'0) =
    [%#sfmap'16] forall k: t_Id. contains'0 self k -> inv'16 k /\ inv'7 (index_logic'0 self k)
  
  predicate inv'17 (_0: t_FMap'0)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_FMap'0 [inv'17 x]. inv'17 x = invariant''11 x
  
  predicate invariant''12 (self: t_FMap'0) = [%#sghost'9] inv'17 self
  
  predicate inv'18 (_0: t_FMap'0)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_FMap'0 [inv'18 x]. inv'18 x = invariant''12 x
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) =
    [%#sfmap'15] let _ = () in forall k: t_Id. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap'14] ext_eq self other = (self = other)
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'13] len'0 self >= 0
  
  constant empty'0 : t_FMap'0
  
  axiom empty_spec'1: [%#sfmap'6] len'0 empty'0 = 0
  
  axiom empty_spec'2: [%#sfmap'7] view'6 empty'0 = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap'0) = [%#sfmap'11] ext_eq self empty'0
  
  let rec new'2 (return' (x: t_FMap'0)) = any
    [ return''0 (result: t_FMap'0) -> {[%#sfmap] inv'18 result} {[%#sfmap'0] is_empty result} (! return' {result}) ]
  
  predicate invariant''13 (self: MutBorrow.t t_FMap'0) = [%#sinvariant] inv'18 self.current /\ inv'18 self.final
  
  predicate inv'19 (_0: MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_FMap'0 [inv'19 x]. inv'19 x = invariant''13 x
  
  predicate invariant''14 (self: MutBorrow.t t_FMap'0) = [%#sinvariant] inv'17 self.current /\ inv'17 self.final
  
  predicate inv'20 (_0: MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t t_FMap'0 [inv'20 x]. inv'20 x = invariant''14 x
  
  let rec deref_mut'0 (self: MutBorrow.t t_FMap'0) (return' (x: MutBorrow.t t_FMap'0)) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'19 self}
    any
    [ return''0 (result: MutBorrow.t t_FMap'0) -> {[%#sghost'0] inv'20 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  let rec into_ghost (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#ssnapshot] result = self} (! return' {result}) ]
  
  let rec into_inner (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'5] result = self} (! return' {result}) ]
  
  let rec into_inner'0 (self: t_PCellOwn) (return' (x: t_PCellOwn)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'6] inv'8 self}
    any
    [ return''0 (result: t_PCellOwn) -> {[%#sghost'7] inv'7 result} {[%#sghost'5] result = self} (! return' {result}) ]
  
  predicate inv'21 (_0: t_Option'0)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Option'0 [inv'21 x]. inv'21 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'7 a_0
        end
  
  function insert'1 (self: t_FMap'0) (k: t_Id) (v: t_PCellOwn) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_Id, v: t_PCellOwn. [%#sfmap'9] view'6 (insert'1 self k v)
      = Map.set (view'6 self) k (C_Some'0 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_Id, v: t_PCellOwn. [%#sfmap'10] len'0 (insert'1 self k v)
      = (if contains'0 self k then len'0 self else len'0 self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap'0) (key: t_Id) (value: t_PCellOwn) (return' (x: t_Option'0)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'1] inv'20 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'2] inv'7 value}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'3] inv'21 result}
      {[%#sfmap'4] self.final = insert'1 self.current key value}
      {[%#sfmap'5] result = get'0 self.current key}
      (! return' {result}) ]
  
  predicate resolve'1 (_0: t_Inner) = true
  
  predicate resolve'2 (self: t_PCellOwn) = [%#spcell'5] resolve'1 (val' self)
  
  predicate resolve'3 (_0: t_PCellOwn) = resolve'2 _0
  
  predicate resolve'4 (self: t_Option'0) =
    [%#sresolve'0] match self with
      | C_Some'0 x -> resolve'3 x
      | C_None'0 -> true
      end
  
  predicate resolve'5 (_0: t_Option'0) = resolve'4 _0
  
  predicate resolve'6 (self: MutBorrow.t t_FMap'0) = [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t t_FMap'0) = resolve'6 _0
  
  let rec into_inner'1 (self: t_FMap'0) (return' (x: t_FMap'0)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'6] inv'18 self}
    any
    [ return''0 (result: t_FMap'0) -> {[%#sghost'7] inv'17 result} {[%#sghost'5] result = self} (! return' {result}) ]
  
  let rec into_inner'2 (self: t_Authority) (return' (x: t_Authority)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'6] inv'11 self}
    any
    [ return''0 (result: t_Authority) -> {[%#sghost'7] inv'10 result}
      {[%#sghost'5] result = self}
      (! return' {result}) ]
  
  type t_PA = { t_PA__permissions: t_FMap'0; t_PA__auth: t_Authority; t_PA__rank: Map.map t_Id int; t_PA__length: int }
  
  predicate inv'22 (_0: t_PA)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_PA [inv'22 x]. inv'22 x
      = match x with
        | {t_PA__permissions = permissions; t_PA__auth = auth; t_PA__rank = rank; t_PA__length = length} -> inv'17 permissions
        /\ inv'10 auth
        end
  
  predicate invariant''15 (self: t_PA) = [%#sghost'9] inv'22 self
  
  predicate inv'23 (_0: t_PA)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_PA [inv'23 x]. inv'23 x = invariant''15 x
  
  let rec new'3 (x: t_PA) (return' (x'0: t_PA)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'22 x}
    any [ return''0 (result: t_PA) -> {[%#sghost'3] inv'23 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  type t_LocalInvariant
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option) : Seq.seq t_T = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap) (k: t_Id) : Seq.seq t_T = [%#sfmap'18] unwrap_logic'0 (get self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap) (key: t_Id) : Seq.seq t_T = [%#sfmap'17] lookup'0 self key
  
  function view'7 (self: t_Rc) : t_PCell
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  predicate invariant_with_data [#"persistent_array.rs" 100 8 100 61] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'10] id'1 self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains (view'1 self.t_PA__auth) id'3
      -> contains'0 self.t_PA__permissions id'3
      /\ id'0 (index_logic'0 self.t_PA__permissions id'3) = id'3
      /\ Seq.length (index_logic'2 (view'1 self.t_PA__auth) id'3) = self.t_PA__length
      /\ match val' (index_logic'0 self.t_PA__permissions id'3) with
        | C_Direct v -> index_logic'2 (view'1 self.t_PA__auth) id'3 = view v
        | C_Link index value next -> contains (view'1 self.t_PA__auth) (id (view'7 next))
        /\ index_logic'3 self.t_PA__rank id'3 > index_logic'3 self.t_PA__rank (id (view'7 next))
        /\ UInt64.t'int index < self.t_PA__length
        /\ index_logic'2 (view'1 self.t_PA__auth) id'3
        = Seq.set (index_logic'2 (view'1 self.t_PA__auth) (id (view'7 next))) (UInt64.t'int index) value
        end)
  
  function public (self: t_LocalInvariant) : t_Id
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  let rec new'4 (value: t_PA) (public'0: t_Id) (namespace'0: t_Namespace) (return' (x: t_LocalInvariant)) =
    {[@expl:new 'value' type invariant] [%#slocal_invariant] inv'23 value}
    {[@expl:new requires] [%#slocal_invariant'0] invariant_with_data value public'0}
    any
    [ return''0 (result: t_LocalInvariant) -> {[%#slocal_invariant'1] public result = public'0}
      {[%#slocal_invariant'2] namespace result = namespace'0}
      (! return' {result}) ]
  
  let rec into_inner'3 (self: t_LocalInvariant) (return' (x: t_LocalInvariant)) = any
    [ return''0 (result: t_LocalInvariant) -> {[%#sghost'5] result = self} (! return' {result}) ]
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'1; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  function view'8 (self: t_Rc'0) : t_LocalInvariant
  
  let rec new'5 (value: t_LocalInvariant) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#src] view'8 result = value} (! return' {result}) ]
  
  let rec new'6 (x: t_Rc'0) (return' (x'0: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost'4] result = x} (! return' {result}) ]
  
  let rec new'7 (value: t_PCell) (return' (x: t_Rc)) = {[@expl:new 'value' type invariant] [%#src'0] inv'5 value}
    any [ return''0 (result: t_Rc) -> {[%#src] view'7 result = value} (! return' {result}) ]
  
  let rec into_inner'4 (self: t_Fragment) (return' (x: t_Fragment)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'6] inv'15 self}
    any
    [ return''0 (result: t_Fragment) -> {[%#sghost'7] inv'14 result} {[%#sghost'5] result = self} (! return' {result}) ]
  
  type t_NonNull'2 = { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Rc'1 = { t_Rc__ptr'1: t_NonNull'2; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  function view'9 (self: t_Rc'1) : t_Fragment
  
  let rec new'8 (value: t_Fragment) (return' (x: t_Rc'1)) = {[@expl:new 'value' type invariant] [%#src'0] inv'14 value}
    any [ return''0 (result: t_Rc'1) -> {[%#src] view'9 result = value} (! return' {result}) ]
  
  let rec new'9 (x: t_Rc'1) (return' (x'0: t_Rc'1)) = any
    [ return''0 (result: t_Rc'1) -> {[%#sghost'4] result = x} (! return' {result}) ]
  
  type t_PersistentArray = {
    t_PersistentArray__program_value: t_Rc;
    t_PersistentArray__contained_in_inv: t_Rc'1;
    t_PersistentArray__map_invariant: t_Rc'0 }
  
  function view'10 (self: t_Fragment) : tuple'0 = [%#sboxed] view'5 self
  
  function view'11 (self: t_Rc'1) : t_Fragment = [%#sghost'8] view'9 self
  
  function view'12 (self: t_Rc'0) : t_LocalInvariant = [%#sghost'8] view'8 self
  
  predicate invariant''16 [#"persistent_array.rs" 56 8 56 34] (self: t_PersistentArray) =
    [%#spersistent_array'11] (view'10 (view'11 self.t_PersistentArray__contained_in_inv))._p0'0
      = id (view'7 self.t_PersistentArray__program_value)
    /\ id'2 (view'11 self.t_PersistentArray__contained_in_inv) = public (view'12 self.t_PersistentArray__map_invariant)
    /\ namespace (view'12 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv'24 (_0: t_PersistentArray)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_PersistentArray [inv'24 x]. inv'24 x
      = (invariant''16 x
      /\ match x with
        | {t_PersistentArray__program_value = program_value; t_PersistentArray__contained_in_inv = contained_in_inv; t_PersistentArray__map_invariant = map_invariant} -> true
        end)
  
  function view'13 [#"persistent_array.rs" 74 8 74 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'9] (view'10 (view'11 self.t_PersistentArray__contained_in_inv))._p1'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'10 [#"persistent_array.rs" 125 8 125 37] (v: t_Vec) (return' (x: t_PersistentArray)) =
    {[@expl:new 'v' type invariant] [%#spersistent_array'6] inv'2 v}
    (! bb0
    [ bb0 = s0 [ s0 = [ &logical_value <- [%#spersistent_array] view v'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_8 <- C_Direct v'0 ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = new {_8} (fun (_ret: tuple) -> [ &_7 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &program_value <- _7._p0 ] s1 | s1 = [ &ownership <- _7._p1 ] s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &id'3 <- [%#spersistent_array'0] id'0 ownership ] s1 | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &length <- [%#spersistent_array'1] Seq.length logical_value ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = new'0 (fun (_ret: t_Authority) -> [ &resource <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'11 resource}
        MutBorrow.borrow_mut <t_Authority> {resource}
          (fun (_ret: MutBorrow.t t_Authority) -> [ &_19 <- _ret ] -{inv'11 _ret.final}- [ &resource <- _ret.final ] s1)
      | s1 = deref_mut {_19} (fun (_ret: MutBorrow.t t_Authority) -> [ &_18 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = {inv'10 _18.current}
        MutBorrow.borrow_final <t_Authority> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret: MutBorrow.t t_Authority) ->
            [ &_17 <- _ret ] -{inv'10 _ret.final}-
            [ &_18 <- { _18 with current = _ret.final } ] s1)
      | s1 = insert'0 {_17} {id'3} {logical_value} (fun (_ret: t_Fragment) -> [ &_16 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'13 _18} s1
      | s1 = -{resolve'0 _18}- s2
      | s2 = new'1 {_16} (fun (_ret: t_Fragment) -> [ &frac_part <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0 [ s0 = [ &gset_id <- [%#spersistent_array'2] id'2 frac_part ] s1 | s1 = bb11 ]
    | bb11 = s0 [ s0 = new'2 (fun (_ret: t_FMap'0) -> [ &permissions <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = {inv'18 permissions}
        MutBorrow.borrow_mut <t_FMap'0> {permissions}
          (fun (_ret: MutBorrow.t t_FMap'0) -> [ &_30 <- _ret ] -{inv'18 _ret.final}- [ &permissions <- _ret.final ] s1)
      | s1 = deref_mut'0 {_30} (fun (_ret: MutBorrow.t t_FMap'0) -> [ &_29 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0 [ s0 = into_ghost {id'3} (fun (_ret: t_Id) -> [ &_32 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0 [ s0 = into_inner {_32} (fun (_ret: t_Id) -> [ &_31 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = into_inner'0 {ownership} (fun (_ret: t_PCellOwn) -> [ &_34 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = s0
      [ s0 = {inv'17 _29.current}
        MutBorrow.borrow_final <t_FMap'0> {_29.current} {MutBorrow.get_id _29}
          (fun (_ret: MutBorrow.t t_FMap'0) ->
            [ &_28 <- _ret ] -{inv'17 _ret.final}-
            [ &_29 <- { _29 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_28} {_31} {_34} (fun (_ret: t_Option'0) -> [ &_27 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'21 _27} s3
      | s3 = -{resolve'5 _27}- s4
      | s4 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'20 _29} s1
      | s1 = -{resolve'7 _29}- s2
      | s2 = into_inner'1 {permissions} (fun (_ret: t_FMap'0) -> [ &_39 <- _ret ] s3)
      | s3 = bb18 ]
    | bb18 = s0 [ s0 = into_inner'2 {resource} (fun (_ret: t_Authority) -> [ &_41 <- _ret ] s1) | s1 = bb19 ]
    | bb19 = s0 [ s0 = [ &_43 <- [%#spersistent_array'3] fun (__0: t_Id) -> 0 ] s1 | s1 = bb20 ]
    | bb20 = s0
      [ s0 = [ &_38 <- { t_PA__permissions = _39; t_PA__auth = _41; t_PA__rank = _43; t_PA__length = length } ] s1
      | s1 = new'3 {_38} (fun (_ret: t_PA) -> [ &_37 <- _ret ] s2)
      | s2 = bb21 ]
    | bb21 = s0 [ s0 = [ &_46 <- [%#spersistent_array'4] gset_id ] s1 | s1 = bb22 ]
    | bb22 = s0 [ s0 = [ &_48 <- [%#spersistent_array'5] Namespace_PARRAY_0'62 0 ] s1 | s1 = bb23 ]
    | bb23 = s0 [ s0 = new'4 {_37} {_46} {_48} (fun (_ret: t_LocalInvariant) -> [ &local_inv <- _ret ] s1) | s1 = bb24 ]
    | bb24 = s0 [ s0 = into_inner'3 {local_inv} (fun (_ret: t_LocalInvariant) -> [ &_50 <- _ret ] s1) | s1 = bb25 ]
    | bb25 = s0 [ s0 = new'5 {_50} (fun (_ret: t_Rc'0) -> [ &_25 <- _ret ] s1) | s1 = bb26 ]
    | bb26 = s0 [ s0 = new'6 {_25} (fun (_ret: t_Rc'0) -> [ &map_invariant <- _ret ] s1) | s1 = bb27 ]
    | bb27 = s0 [ s0 = new'7 {program_value} (fun (_ret: t_Rc) -> [ &_52 <- _ret ] s1) | s1 = bb28 ]
    | bb28 = s0 [ s0 = into_inner'4 {frac_part} (fun (_ret: t_Fragment) -> [ &_56 <- _ret ] s1) | s1 = bb29 ]
    | bb29 = s0 [ s0 = new'8 {_56} (fun (_ret: t_Rc'1) -> [ &_55 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0 [ s0 = new'9 {_55} (fun (_ret: t_Rc'1) -> [ &_54 <- _ret ] s1) | s1 = bb31 ]
    | bb31 = s0
      [ s0 = [ &_0 <- { t_PersistentArray__program_value = _52;
                        t_PersistentArray__contained_in_inv = _54;
                        t_PersistentArray__map_invariant = map_invariant } ] s1
      | s1 = bb34 ]
    | bb34 = return''0 {_0} ]
    [ & _0: t_PersistentArray = Any.any_l ()
    | & v'0: t_Vec = v
    | & logical_value: Seq.seq t_T = Any.any_l ()
    | & program_value: t_PCell = Any.any_l ()
    | & ownership: t_PCellOwn = Any.any_l ()
    | & _7: tuple = Any.any_l ()
    | & _8: t_Inner = Any.any_l ()
    | & id'3: t_Id = Any.any_l ()
    | & length: int = Any.any_l ()
    | & resource: t_Authority = Any.any_l ()
    | & frac_part: t_Fragment = Any.any_l ()
    | & _16: t_Fragment = Any.any_l ()
    | & _17: MutBorrow.t t_Authority = Any.any_l ()
    | & _18: MutBorrow.t t_Authority = Any.any_l ()
    | & _19: MutBorrow.t t_Authority = Any.any_l ()
    | & gset_id: t_Id = Any.any_l ()
    | & map_invariant: t_Rc'0 = Any.any_l ()
    | & _25: t_Rc'0 = Any.any_l ()
    | & permissions: t_FMap'0 = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _28: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _29: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _30: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _31: t_Id = Any.any_l ()
    | & _32: t_Id = Any.any_l ()
    | & _34: t_PCellOwn = Any.any_l ()
    | & local_inv: t_LocalInvariant = Any.any_l ()
    | & _37: t_PA = Any.any_l ()
    | & _38: t_PA = Any.any_l ()
    | & _39: t_FMap'0 = Any.any_l ()
    | & _41: t_Authority = Any.any_l ()
    | & _43: Map.map t_Id int = Any.any_l ()
    | & _46: t_Id = Any.any_l ()
    | & _48: t_Namespace = Any.any_l ()
    | & _50: t_LocalInvariant = Any.any_l ()
    | & _52: t_Rc = Any.any_l ()
    | & _54: t_Rc'1 = Any.any_l ()
    | & _55: t_Rc'1 = Any.any_l ()
    | & _56: t_Fragment = Any.any_l () ])
    [ return''0 (result: t_PersistentArray) -> {[@expl:new result type invariant] [%#spersistent_array'7] inv'24 result}
      {[@expl:new ensures] [%#spersistent_array'8] view'13 result = view v}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__set [#"persistent_array.rs" 161 8 161 80] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 45 18 45 37
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 32 23 32 28
  let%span src'1 = "../../creusot-contracts/src/std/rc.rs" 31 26 31 43
  let%span src'2 = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span src'3 = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span spersistent_array = "persistent_array.rs" 162 36 162 71
  let%span spersistent_array'0 = "persistent_array.rs" 161 20 161 24
  let%span spersistent_array'1 = "persistent_array.rs" 161 40 161 45
  let%span spersistent_array'2 = "persistent_array.rs" 158 19 158 39
  let%span spersistent_array'3 = "persistent_array.rs" 159 8 159 46
  let%span spersistent_array'4 = "persistent_array.rs" 161 76 161 80
  let%span spersistent_array'5 = "persistent_array.rs" 160 18 160 53
  let%span spersistent_array'6 = "persistent_array.rs" 170 38 170 73
  let%span spersistent_array'7 = "persistent_array.rs" 180 35 183 25
  let%span spersistent_array'8 = "persistent_array.rs" 184 51 184 69
  let%span spersistent_array'9 = "persistent_array.rs" 167 57 167 66
  let%span spersistent_array'10 = "persistent_array.rs" 167 62 167 65
  let%span spersistent_array'11 = "persistent_array.rs" 76 16 76 41
  let%span spersistent_array'12 = "persistent_array.rs" 102 16 117 21
  let%span spersistent_array'13 = "persistent_array.rs" 59 16 61 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 133 14 133 32
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 55 14 55 29
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 195 14 195 29
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 70 14 70 18
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 70 4 70 36
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 69 14 69 31
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 197 22 197 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 197 4 199 17
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 185 14 185 26
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 91 8 91 22
  let%span sghost'13 = "../../creusot-contracts/src/ghost.rs" 119 8 119 22
  let%span sghost'14 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'15 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 63 8 63 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 99 15 99 20
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 99 4 99 54
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 97 14 97 44
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 98 14 98 35
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 30 4 30 12
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 228 21 228 25
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 227 14 227 34
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 91 26 91 30
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 91 50 91 54
  let%span spcell'8 = "../../creusot-contracts/src/pcell.rs" 88 14 88 36
  let%span spcell'9 = "../../creusot-contracts/src/pcell.rs" 89 14 89 28
  let%span spcell'10 = "../../creusot-contracts/src/pcell.rs" 58 20 58 46
  let%span spcell'11 = "../../creusot-contracts/src/pcell.rs" 41 8 41 27
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 105 14 105 49
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 23 96 27
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 89 15 89 34
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 4 96 78
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 90 14 90 46
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 91 14 91 39
  let%span sfmap_view'8 = "../../creusot-contracts/src/resource/fmap_view.rs" 92 14 92 33
  let%span sfmap_view'9 = "../../creusot-contracts/src/resource/fmap_view.rs" 93 14 93 38
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 387 30 387 34
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 387 4 387 62
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 384 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 385 14 385 73
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 386 14 386 44
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 445 29 445 33
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 445 43 445 48
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 445 4 445 65
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 443 14 443 49
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 444 14 444 40
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 260 51 260 52
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 252 15 252 46
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 253 15 254 111
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 256 14 257 120
  let%span slocal_invariant'3 = "../../creusot-contracts/src/local_invariant.rs" 181 4 181 12
  let%span slocal_invariant'4 = "../../creusot-contracts/src/local_invariant.rs" 237 4 239 51
  let%span slocal_invariant'5 = "../../creusot-contracts/src/local_invariant.rs" 237 51 237 52
  let%span slocal_invariant'6 = "../../creusot-contracts/src/local_invariant.rs" 230 4 230 50
  let%span slocal_invariant'7 = "../../creusot-contracts/src/local_invariant.rs" 231 15 234 100
  let%span slocal_invariant'8 = "../../creusot-contracts/src/local_invariant.rs" 235 14 235 113
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 50 20 50 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 76 8 79 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 686 20 686 91
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 4 133 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 4 134 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 4 139 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 4 144 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 4 145 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 4 146 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use seq.Seq
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  use set.Set
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1 = { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray = {
    t_PersistentArray__program_value: t_Rc;
    t_PersistentArray__contained_in_inv: t_Rc'0;
    t_PersistentArray__map_invariant: t_Rc'1 }
  
  type t_T
  
  type t_Resource
  
  type t_Id
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function view'0 (self: t_Fragment) : tuple = [%#sboxed] view self
  
  function view'1 (self: t_Rc'0) : t_Fragment
  
  function view'2 (self: t_Rc'0) : t_Fragment = [%#sghost'12] view'1 self
  
  function view'3 [#"persistent_array.rs" 74 8 74 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'11] (view'0 (view'2 self.t_PersistentArray__contained_in_inv))._p1
  
  function view'4 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'3 self
  
  type t_NonNull'2 = { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell = { t_UnsafeCell__value: t_Inner }
  
  type t_PCell = { t_PCell__0: t_UnsafeCell }
  
  function view'5 (self: t_Rc) : t_PCell
  
  let rec clone' (self_: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src] view'5 result = view'5 self_} (! return' {result}) ]
  
  type t_PCellOwn = { t_PCellOwn__0: () }
  
  type tuple'0 = { _p0'0: t_PCell; _p1'0: t_PCellOwn }
  
  predicate inv (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed'0] inv self
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  predicate inv'1 (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'6 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view'6 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'0] inv'1 (view'6 self)
  
  predicate inv'2 (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
      = match x with
        | C_Direct a_0 -> inv'2 a_0
        | C_Link index value next -> inv value
        end
  
  predicate inv'4 (_0: t_UnsafeCell)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnsafeCell [inv'4 x]. inv'4 x
      = match x with
        | {t_UnsafeCell__value = value} -> inv'3 value
        end
  
  predicate inv'5 (_0: t_PCell)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PCell [inv'5 x]. inv'5 x
      = match x with
        | {t_PCell__0 = a_0} -> inv'4 a_0
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant] inv'3 self
  
  predicate inv'6 (_0: t_Inner)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Inner [inv'6 x]. inv'6 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) = [%#spcell'10] inv'6 (val' self)
  
  predicate inv'7 (_0: t_PCellOwn)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_PCellOwn [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self: t_PCellOwn) = [%#sghost'15] inv'7 self
  
  predicate inv'8 (_0: t_PCellOwn)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_PCellOwn [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate inv'9 (_0: tuple'0)
  
  axiom inv_axiom'8 [@rewrite]: forall x: tuple'0 [inv'9 x]. inv'9 x
      = (let {_p0'0 = x0; _p1'0 = x1} = x in inv'5 x0 /\ inv'8 x1)
  
  function id (self: t_PCell) : t_Id
  
  function id'0 (self: t_PCellOwn) : t_Id
  
  function view'7 (self: t_PCellOwn) : t_Inner = [%#spcell'3] val' self
  
  let rec new (value: t_Inner) (return' (x: tuple'0)) = {[@expl:new 'value' type invariant] [%#spcell] inv'3 value}
    any
    [ return''0 (result: tuple'0) -> {[%#spcell'0] inv'9 result}
      {[%#spcell'1] id result._p0'0 = id'0 result._p1'0}
      {[%#spcell'2] view'7 result._p1'0 = value}
      (! return' {result}) ]
  
  let rec borrow (self: t_Rc'1) (return' (x: t_Rc'1)) = any
    [ return''0 (result: t_Rc'1) -> {[%#sghost] result = self} (! return' {result}) ]
  
  type closure0 = { _0: t_PCell; _1: t_PersistentArray; _2: t_PCellOwn; _3: Seq.seq t_T }
  
  predicate invariant''5 (self: t_PCell) = [%#sinvariant] inv'5 self
  
  predicate inv'10 (_0'0: t_PCell)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_PCell [inv'10 x]. inv'10 x = invariant''5 x
  
  let rec id_ghost (self: t_PCell) (return' (x: t_Id)) =
    {[@expl:id_ghost 'self' type invariant] [%#spcell'4] inv'10 self}
    any [ return''0 (result: t_Id) -> {[%#spcell'5] result = id self} (! return' {result}) ]
  
  let rec into_inner (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_FMap
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__permissions: t_FMap; t_PA__auth: t_Authority; t_PA__rank: Map.map t_Id int; t_PA__length: int }
  
  type t_Option = C_None | C_Some t_PCellOwn
  
  function view'8 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'9] Map.get (view'8 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'10] get self k <> C_None
  
  predicate inv'11 (_0'0: t_Id)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Id [inv'11 x]. inv'11 x = true
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn = [%#sfmap'16] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn = [%#sfmap'11] lookup self key
  
  predicate invariant''6 (self: t_FMap) =
    [%#sfmap'15] forall k: t_Id. contains self k -> inv'11 k /\ inv'7 (index_logic'0 self k)
  
  predicate inv'12 (_0'0: t_FMap)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_FMap [inv'12 x]. inv'12 x = invariant''6 x
  
  predicate invariant''7 (self: t_Authority)
  
  predicate inv'13 (_0'0: t_Authority)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Authority [inv'13 x]. inv'13 x
      = (invariant''7 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'14 (_0'0: t_PA)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_PA [inv'14 x]. inv'14 x
      = match x with
        | {t_PA__permissions = permissions; t_PA__auth = auth; t_PA__rank = rank; t_PA__length = length} -> inv'12 permissions
        /\ inv'13 auth
        end
  
  predicate invariant''8 (self: MutBorrow.t t_PA) = [%#sinvariant'0] inv'14 self.current /\ inv'14 self.final
  
  predicate inv'15 (_0'0: MutBorrow.t t_PA)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_PA [inv'15 x]. inv'15 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_PA) = [%#sghost'15] inv'15 self
  
  predicate inv'16 (_0'0: MutBorrow.t t_PA)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_PA [inv'16 x]. inv'16 x = invariant''9 x
  
  predicate invariant''10 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'16 self
  
  predicate inv'17 (_0'0: MutBorrow.t t_PA)
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t t_PA [inv'17 x]. inv'17 x = invariant''10 x
  
  predicate invariant''11 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'15 self
  
  predicate inv'18 (_0'0: MutBorrow.t t_PA)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_PA [inv'18 x]. inv'18 x = invariant''11 x
  
  let rec deref (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:deref 'self' type invariant] [%#sghost'2] inv'17 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'3] inv'18 result}
      {[%#sghost'4] result = self}
      (! return' {result}) ]
  
  let rec deref'0 (self: t_Rc'0) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost'4] result = self} (! return' {result}) ]
  
  predicate invariant''12 (self: t_Fragment)
  
  predicate inv'19 (_0'0: t_Fragment)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_Fragment [inv'19 x]. inv'19 x
      = (invariant''12 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''13 (self: t_Fragment) = [%#sinvariant] inv'19 self
  
  predicate inv'20 (_0'0: t_Fragment)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_Fragment [inv'20 x]. inv'20 x = invariant''13 x
  
  let rec as_ref (self_: t_Rc'0) (return' (x: t_Fragment)) = any
    [ return''0 (result: t_Fragment) -> {inv'20 result} {[%#src'2] result = view'1 self_} (! return' {result}) ]
  
  predicate invariant''14 (self: t_Authority) = [%#sinvariant] inv'13 self
  
  predicate inv'21 (_0'0: t_Authority)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Authority [inv'21 x]. inv'21 x = invariant''14 x
  
  function id'1 (self: t_Authority) : t_Id
  
  function id'2 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'9 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = [%#sfmap'9] Map.get (view'9 self) k
  
  function view'10 (self: t_Authority) : t_FMap'0
  
  function view'11 (self: t_Authority) : t_FMap'0 = [%#smodel] view'10 self
  
  function view'12 (self: t_Fragment) : tuple = [%#smodel] view self
  
  let rec contains'0 (self: t_Authority) (frag: t_Fragment) (return' (x: ())) =
    {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'21 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'20 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id'1 self = id'2 frag}
    any
    [ return''0 (result: ()) -> {[%#sfmap_view'2] get'0 (view'11 self) (view'12 frag)._p0
      = C_Some'0 ((view'12 frag)._p1)}
      (! return' {result}) ]
  
  let rec into_inner'0 (self: t_PCellOwn) (return' (x: t_PCellOwn)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'5] inv'8 self}
    any
    [ return''0 (result: t_PCellOwn) -> {[%#sghost'6] inv'7 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  predicate invariant''15 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant'0] inv'16 self.current /\ inv'16 self.final
  
  predicate inv'22 (_0'0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'22 x]. inv'22 x = invariant''15 x
  
  predicate invariant''16 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant'0] inv'15 self.current /\ inv'15 self.final
  
  predicate inv'23 (_0'0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'23 x]. inv'23 x = invariant''16 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return' (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'7] inv'22 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_PA)) -> {[%#sghost'8] inv'23 result}
      {[%#sghost'9] result = self}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_PCellOwn)
  
  predicate invariant''17 (self: MutBorrow.t t_FMap) = [%#sinvariant'0] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'24 (_0'0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'24 x]. inv'24 x = invariant''17 x
  
  predicate invariant''18 (self: MutBorrow.t t_PCellOwn) = [%#sinvariant'0] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'25 (_0'0: MutBorrow.t t_PCellOwn)
  
  axiom inv_axiom'24 [@rewrite]: forall x: MutBorrow.t t_PCellOwn [inv'25 x]. inv'25 x = invariant''18 x
  
  predicate inv'26 (_0'0: t_Option'1)
  
  axiom inv_axiom'25 [@rewrite]: forall x: t_Option'1 [inv'26 x]. inv'26 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'25 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'12] len self >= 0
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return' (x: t_Option'1)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap] inv'24 self}
    any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'0] inv'26 result}
      {[%#sfmap'1] if contains self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'2] forall k: t_Id. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'3] len self.current = len self.final}
      (! return' {result}) ]
  
  let rec v_Some (input: t_Option'1) (ret (field_0: MutBorrow.t t_PCellOwn)) = any
    [ good (field_0: MutBorrow.t t_PCellOwn) -> {C_Some'1 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_PCellOwn [C_Some'1 field_0: t_Option'1]. C_Some'1 field_0 <> input}
      (! {false}
      any) ]
  
  predicate invariant''19 (self: t_PCellOwn) = [%#sinvariant] inv'7 self
  
  predicate inv'27 (_0'0: t_PCellOwn)
  
  axiom inv_axiom'26 [@rewrite]: forall x: t_PCellOwn [inv'27 x]. inv'27 x = invariant''19 x
  
  let rec disjoint_lemma (own1: MutBorrow.t t_PCellOwn) (own2: t_PCellOwn) (return' (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] [%#spcell'6] inv'25 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#spcell'7] inv'27 own2}
    any
    [ return''0 (result: ()) -> {[%#spcell'8] id'0 own1.current <> id'0 own2}
      {[%#spcell'9] own1.current = own1.final}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_PCellOwn) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0: MutBorrow.t t_PCellOwn) = resolve _0'0
  
  predicate resolve'1 (self: MutBorrow.t (MutBorrow.t t_PA)) = [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0'0: MutBorrow.t (MutBorrow.t t_PA)) = resolve'1 _0'0
  
  predicate inv'28 (_0'0: t_Option)
  
  axiom inv_axiom'27 [@rewrite]: forall x: t_Option [inv'28 x]. inv'28 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'7 a_0
        end
  
  function insert (self: t_FMap) (k: t_Id) (v: t_PCellOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: t_PCellOwn. [%#sfmap'13] view'8 (insert self k v)
      = Map.set (view'8 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: t_PCellOwn. [%#sfmap'14] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (value: t_PCellOwn) (return' (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'4] inv'24 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'5] inv'7 value}
    any
    [ return''0 (result: t_Option) -> {[%#sfmap'6] inv'28 result}
      {[%#sfmap'7] self.final = insert self.current key value}
      {[%#sfmap'8] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve'3 (_0'0: t_Inner) = true
  
  predicate resolve'4 (self: t_PCellOwn) = [%#spcell'11] resolve'3 (val' self)
  
  predicate resolve'5 (_0'0: t_PCellOwn) = resolve'4 _0'0
  
  predicate resolve'6 (self: t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve'5 x
      | C_None -> true
      end
  
  predicate resolve'7 (_0'0: t_Option) = resolve'6 _0'0
  
  function index_logic'1 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  predicate invariant''20 (self: MutBorrow.t t_Authority) = [%#sinvariant'0] inv'13 self.current /\ inv'13 self.final
  
  predicate inv'29 (_0'0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'28 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'29 x]. inv'29 x = invariant''20 x
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'10] get'0 self k <> C_None'0
  
  function view'13 (self: MutBorrow.t t_Authority) : t_FMap'0 = [%#smodel'0] view'10 self.current
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'12] len'0 self >= 0
  
  function insert'0 (self: t_FMap'0) (k: t_Id) (v: Seq.seq t_T) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_Id, v: Seq.seq t_T. [%#sfmap'13] view'9 (insert'0 self k v)
      = Map.set (view'9 self) k (C_Some'0 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_Id, v: Seq.seq t_T. [%#sfmap'14] len'0 (insert'0 self k v)
      = (if contains'1 self k then len'0 self else len'0 self + 1)
  
  let rec insert'1 (self: MutBorrow.t t_Authority) (k: t_Id) (v: Seq.seq t_T) (return' (x: t_Fragment)) =
    {[@expl:insert 'self' type invariant] [%#sfmap_view'3] inv'29 self}
    {[@expl:insert requires] [%#sfmap_view'4] not contains'1 (view'13 self) k}
    any
    [ return''0 (result: t_Fragment) -> {[%#sfmap_view'5] inv'19 result}
      {[%#sfmap_view'6] view'10 self.final = insert'0 (view'13 self) k v}
      {[%#sfmap_view'7] id'1 self.final = id'1 self.current}
      {[%#sfmap_view'8] view result = { _p0 = k; _p1 = v }}
      {[%#sfmap_view'9] id'2 result = id'1 self.current}
      (! return' {result}) ]
  
  predicate resolve'8 (self: MutBorrow.t t_PA) = [%#sresolve] self.final = self.current
  
  predicate resolve'9 (_0'0: MutBorrow.t t_PA) = resolve'8 _0'0
  
  predicate resolve'10 (self: MutBorrow.t t_PA) = [%#sghost'13] resolve'9 self
  
  predicate resolve'11 (_0'0: MutBorrow.t t_PA) = resolve'10 _0'0
  
  let rec new'0 (value: t_Fragment) (return' (x: t_Rc'0)) = {[@expl:new 'value' type invariant] [%#src'0] inv'19 value}
    any [ return''0 (result: t_Rc'0) -> {[%#src'1] view'1 result = value} (! return' {result}) ]
  
  let rec new'1 (x: t_Rc'0) (return' (x'0: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost'10] result = x} (! return' {result}) ]
  
  predicate invariant''21 (self: t_PCell) = [%#sinvariant] inv'10 self
  
  predicate inv'30 (_0'0: t_PCell)
  
  axiom inv_axiom'29 [@rewrite]: forall x: t_PCell [inv'30 x]. inv'30 x = invariant''21 x
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'14 (self: t_Rc'1) : t_LocalInvariant
  
  function view'15 (self: t_Rc'1) : t_LocalInvariant = [%#sghost'12] view'14 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''22 [#"persistent_array.rs" 56 8 56 34] (self: t_PersistentArray) =
    [%#spersistent_array'13] (view'0 (view'2 self.t_PersistentArray__contained_in_inv))._p0
      = id (view'5 self.t_PersistentArray__program_value)
    /\ id'2 (view'2 self.t_PersistentArray__contained_in_inv) = public (view'15 self.t_PersistentArray__map_invariant)
    /\ namespace (view'15 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv'31 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'30 [@rewrite]: forall x: t_PersistentArray [inv'31 x]. inv'31 x
      = (invariant''22 x
      /\ match x with
        | {t_PersistentArray__program_value = program_value; t_PersistentArray__contained_in_inv = contained_in_inv; t_PersistentArray__map_invariant = map_invariant} -> true
        end)
  
  predicate invariant''23 (self: t_PersistentArray) = [%#sinvariant] inv'31 self
  
  predicate inv'32 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'31 [@rewrite]: forall x: t_PersistentArray [inv'32 x]. inv'32 x = invariant''23 x
  
  predicate invariant''24 (self: t_PersistentArray) = [%#sinvariant] inv'32 self
  
  predicate inv'33 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'32 [@rewrite]: forall x: t_PersistentArray [inv'33 x]. inv'33 x = invariant''24 x
  
  predicate inv'34 (_0'0: closure0)
  
  axiom inv_axiom'33 [@rewrite]: forall x: closure0 [inv'34 x]. inv'34 x
      = (let {_0 = x0; _1 = x1; _2 = x2; _3 = x3} = x in inv'30 x0 /\ inv'33 x1 /\ inv'8 x2)
  
  let rec closure0 [#"persistent_array.rs" 167 57 167 66] [@coma:extspec] (self: closure0) (inv'35: MutBorrow.t t_PA)
    (return' (x: t_Rc'0)) = bb0
    [ bb0 = s0 [ s0 = id_ghost {_1'0._0} (fun (_ret: t_Id) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_inner {_5} (fun (_ret: t_Id) -> [ &cell_id <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &self_id <- [%#spersistent_array'6] id (view'5 (_1'0._1).t_PersistentArray__program_value) ] s1
      | s1 = bb3 ]
    | bb3 = s0 [ s0 = deref {inv'36} (fun (_ret: MutBorrow.t t_PA) -> [ &_11 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = deref'0 {(_1'0._1).t_PersistentArray__contained_in_inv} (fun (_ret: t_Rc'0) -> [ &_16 <- _ret ] s1)
      | s1 = bb5 ]
    | bb5 = s0 [ s0 = as_ref {_16} (fun (_ret: t_Fragment) -> [ &_14 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = contains'0 {(_11.current).t_PA__auth} {_14} (fun (_ret: ()) -> [ &_9 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = into_inner'0 {_1'0._2} (fun (_ret: t_PCellOwn) -> [ &ownership <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0
      [ s0 = {inv'16 inv'36}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {inv'36}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_24 <- _ret ] -{inv'16 _ret.final}-
            [ &inv'36 <- _ret.final ] s1)
      | s1 = deref_mut {_24} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_23 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_26 <- cell_id ] s1
      | s1 = {inv'12 ((_23.current).current).t_PA__permissions}
        MutBorrow.borrow_mut <t_FMap> {((_23.current).current).t_PA__permissions}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_22 <- _ret ] -{inv'12 _ret.final}-
            [ &_23 <- { _23 with current = { _23.current with current = { (_23.current).current with t_PA__permissions = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_22} {_26} (fun (_ret: t_Option'1) -> [ &_21 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = any [ br0 -> {_21 = C_None'1} (! bb14) | br1 (x0: MutBorrow.t t_PCellOwn) -> {_21 = C_Some'1 x0} (! bb13) ]
    | bb13 = s0
      [ s0 = v_Some {_21} (fun (r0: MutBorrow.t t_PCellOwn) -> [ &other <- r0 ] s1)
      | s1 = [ &_31 <- ownership ] s2
      | s2 = {inv'7 other.current}
        MutBorrow.borrow_final <t_PCellOwn> {other.current} {MutBorrow.get_id other}
          (fun (_ret: MutBorrow.t t_PCellOwn) ->
            [ &_29 <- _ret ] -{inv'7 _ret.final}-
            [ &other <- { other with current = _ret.final } ] s3)
      | s3 = disjoint_lemma {_29} {_31} (fun (_ret: ()) -> [ &_20 <- _ret ] s4)
      | s4 = bb15 ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'25 other} s1
      | s1 = -{resolve'0 other}- s2
      | s2 = {[@expl:type invariant] inv'23 _23} s3
      | s3 = -{resolve'2 _23}- s4
      | s4 = bb16 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'23 _23} s1 | s1 = -{resolve'2 _23}- s2 | s2 = bb16 ]
    | bb16 = s0
      [ s0 = {inv'16 inv'36}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {inv'36}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_35 <- _ret ] -{inv'16 _ret.final}-
            [ &inv'36 <- _ret.final ] s1)
      | s1 = deref_mut {_35} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_34 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = s0
      [ s0 = {inv'12 ((_34.current).current).t_PA__permissions}
        MutBorrow.borrow_mut <t_FMap> {((_34.current).current).t_PA__permissions}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_33 <- _ret ] -{inv'12 _ret.final}-
            [ &_34 <- { _34 with current = { _34.current with current = { (_34.current).current with t_PA__permissions = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_33} {cell_id} {ownership} (fun (_ret: t_Option) -> [ &_32 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'28 _32} s3
      | s3 = -{resolve'7 _32}- s4
      | s4 = bb18 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'23 _34} s1
      | s1 = -{resolve'2 _34}- s2
      | s2 = [ &_38 <- [%#spersistent_array'7] let new_distance = index_logic'1 (inv'36.current).t_PA__rank self_id
        + 1 in Map.set (inv'36.current).t_PA__rank cell_id new_distance ] s3
      | s3 = bb19 ]
    | bb19 = s0
      [ s0 = {inv'16 inv'36}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {inv'36}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_41 <- _ret ] -{inv'16 _ret.final}-
            [ &inv'36 <- _ret.final ] s1)
      | s1 = deref_mut {_41} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_40 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 =
        [ &_40 <- { _40 with current = { _40.current with current = { (_40.current).current with t_PA__rank = _38 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'23 _40} s2
      | s2 = -{resolve'2 _40}- s3
      | s3 = {inv'16 inv'36}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {inv'36}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_45 <- _ret ] -{inv'16 _ret.final}-
            [ &inv'36 <- _ret.final ] s4)
      | s4 = deref_mut {_45} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_44 <- _ret ] s5)
      | s5 = bb21 ]
    | bb21 = s0 [ s0 = [ &_46 <- [%#spersistent_array'8] cell_id ] s1 | s1 = bb22 ]
    | bb22 = s0
      [ s0 = {inv'13 ((_44.current).current).t_PA__auth}
        MutBorrow.borrow_mut <t_Authority> {((_44.current).current).t_PA__auth}
          (fun (_ret: MutBorrow.t t_Authority) ->
            [ &_43 <- _ret ] -{inv'13 _ret.final}-
            [ &_44 <- { _44 with current = { _44.current with current = { (_44.current).current with t_PA__auth = _ret.final } } } ]
            s1)
      | s1 = insert'1 {_43} {_46} {_1'0._3} (fun (_ret: t_Fragment) -> [ &frac <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'23 _44} s1
      | s1 = -{resolve'2 _44}- s2
      | s2 = {[@expl:type invariant] inv'16 inv'36} s3
      | s3 = -{resolve'11 inv'36}- s4
      | s4 = new'0 {frac} (fun (_ret: t_Rc'0) -> [ &_3'0 <- _ret ] s5)
      | s5 = bb24 ]
    | bb24 = s0 [ s0 = new'1 {_3'0} (fun (_ret: t_Rc'0) -> [ &_0'0 <- _ret ] s1) | s1 = bb25 ]
    | bb25 = return' {_0'0} ]
    [ & _0'0: t_Rc'0 = Any.any_l ()
    | & _1'0: closure0 = self
    | & inv'36: MutBorrow.t t_PA = inv'35
    | & _3'0: t_Rc'0 = Any.any_l ()
    | & cell_id: t_Id = Any.any_l ()
    | & _5: t_Id = Any.any_l ()
    | & self_id: t_Id = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & _11: MutBorrow.t t_PA = Any.any_l ()
    | & _14: t_Fragment = Any.any_l ()
    | & _16: t_Rc'0 = Any.any_l ()
    | & ownership: t_PCellOwn = Any.any_l ()
    | & _20: () = Any.any_l ()
    | & _21: t_Option'1 = Any.any_l ()
    | & _22: MutBorrow.t t_FMap = Any.any_l ()
    | & _23: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _24: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _26: t_Id = Any.any_l ()
    | & other: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & _29: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & _31: t_PCellOwn = Any.any_l ()
    | & _32: t_Option = Any.any_l ()
    | & _33: MutBorrow.t t_FMap = Any.any_l ()
    | & _34: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _35: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _38: Map.map t_Id int = Any.any_l ()
    | & _40: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _41: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & frac: t_Fragment = Any.any_l ()
    | & _43: MutBorrow.t t_Authority = Any.any_l ()
    | & _44: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _45: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _46: t_Id = Any.any_l () ]
  
  type t_Tokens
  
  predicate precondition (self: ()) (args: t_Rc'1) = let self_ = args in true
  
  let rec deref'1 (self_: t_Rc'1) (return' (x: t_LocalInvariant)) = any
    [ return''0 (result: t_LocalInvariant) -> {[%#src'3] result = view'14 self_} (! return' {result}) ]
  
  predicate postcondition_once (self: ()) (args: t_Rc'1) (result: t_LocalInvariant) =
    let self_ = args in result = view'14 self_
  
  predicate resolve'12 (_0'0: ()) = true
  
  predicate postcondition_mut (self: ()) (args: t_Rc'1) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view'14 self_
  
  function fn_mut_once (self: ()) (args: t_Rc'1) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec:
    forall self: (), args: t_Rc'1, res: t_LocalInvariant. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'12 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) = true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc'1) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Rc'1, res_state: (), res: t_LocalInvariant. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_Rc'1) (result: t_LocalInvariant) =
    let self_ = args in result = view'14 self_
  
  function fn_once (self: ()) (args: t_Rc'1) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc'1, res: t_LocalInvariant. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve'12 self)
  
  function fn_mut (self: ()) (args: t_Rc'1) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Rc'1, res_state: (), res: t_LocalInvariant. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  type tuple'1 = { _p0'1: t_LocalInvariant; _p1'1: t_Tokens; _p2: closure0 }
  
  predicate index_logic'2 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'2 p x)
      -> ([%#sutil'0] index_logic'2 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'16] unwrap_logic'0 (get'0 self k)
  
  function index_logic'3 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'11] lookup'0 self key
  
  predicate invariant_with_data [#"persistent_array.rs" 100 8 100 61] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'12] id'1 self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains'1 (view'10 self.t_PA__auth) id'3
      -> contains self.t_PA__permissions id'3
      /\ id'0 (index_logic'0 self.t_PA__permissions id'3) = id'3
      /\ Seq.length (index_logic'3 (view'10 self.t_PA__auth) id'3) = self.t_PA__length
      /\ match val' (index_logic'0 self.t_PA__permissions id'3) with
        | C_Direct v -> index_logic'3 (view'10 self.t_PA__auth) id'3 = view'6 v
        | C_Link index value next -> contains'1 (view'10 self.t_PA__auth) (id (view'5 next))
        /\ index_logic'1 self.t_PA__rank id'3 > index_logic'1 self.t_PA__rank (id (view'5 next))
        /\ UInt64.t'int index < self.t_PA__length
        /\ index_logic'3 (view'10 self.t_PA__auth) id'3
        = Seq.set (index_logic'3 (view'10 self.t_PA__auth) (id (view'5 next))) (UInt64.t'int index) value
        end)
  
  predicate precondition'0 (self: closure0) (args: MutBorrow.t t_PA) =
    [%#spersistent_array'9] let inv'35 = args in closure0'pre self inv'35
  
  predicate postcondition_once'0 (self: closure0) (args: MutBorrow.t t_PA) (result: t_Rc'0) =
    [%#spersistent_array'9] let inv'35 = args in closure0'post'return' self inv'35 result
  
  function fin (self: MutBorrow.t t_PA) : t_PA = [%#sghost'14] self.final
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = [%#sset] Set.mem e self
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'3 (self: t_Tokens) (namespace'0: t_Namespace) =
    [%#slocal_invariant'3] contains'2 (namespaces self) namespace'0
  
  predicate precondition'1 (self: ()) (args: tuple'1) =
    [%#slocal_invariant'4] let {_p0'1 = self'0; _p1'1 = tokens; _p2 = f} = args in (forall t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
          /\ inv'16 t
        -> precondition'0 f t
        /\ (forall res: t_Rc'0. postcondition_once'0 f t res -> invariant_with_data (fin t) (public self'0)))
    /\ contains'3 tokens (namespace self'0) /\ inv'34 f
  
  let rec open (self: t_LocalInvariant) (tokens: t_Tokens) (f: closure0) (return' (x: t_Rc'0)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant'5] inv'34 f}
    {[@expl:open requires #0] [%#slocal_invariant'6] contains'3 tokens (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'7] forall t: MutBorrow.t t_PA. invariant_with_data t.current (public self)
        /\ inv'16 t
      -> precondition'0 f t
      /\ (forall res: t_Rc'0. postcondition_once'0 f t res -> invariant_with_data (fin t) (public self))}
    any
    [ return''0 (result: t_Rc'0) ->
    {[%#slocal_invariant'8] exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self)
        /\ postcondition_once'0 f t result}
      (! return' {result}) ]
  
  function new_logic (x: t_LocalInvariant) : t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. [%#sghost'11] new_logic x = x
  
  predicate postcondition_once'1 (self: ()) (args: tuple'1) (result: t_Rc'0) =
    [%#slocal_invariant'4] let {_p0'1 = self'0; _p1'1 = tokens; _p2 = f} = args in exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
      /\ postcondition_once'0 f t result
  
  predicate resolve'13 (_0'0: ()) = true
  
  predicate postcondition_mut'0 (self: ()) (args: tuple'1) (result_state: ()) (result: t_Rc'0) =
    [%#slocal_invariant'4] let {_p0'1 = self'0; _p1'1 = tokens; _p2 = f} = args in exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
      /\ postcondition_once'0 f t result
  
  function fn_mut_once'0 (self: ()) (args: tuple'1) (res: t_Rc'0) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'1, res: t_Rc'0. [%#sops'8] postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'13 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) = true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
      -> ([%#sops'6] hist_inv'0 b c) -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'1) (res_state: ()) (res: t_Rc'0) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: tuple'1, res_state: (), res: t_Rc'0. ([%#sops'2] postcondition_mut'0 self args res_state res)
      -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple'1) (result: t_Rc'0) =
    [%#slocal_invariant'4] let {_p0'1 = self'0; _p1'1 = tokens; _p2 = f} = args in exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
      /\ postcondition_once'0 f t result
  
  function fn_once'0 (self: ()) (args: tuple'1) (res: t_Rc'0) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'1, res: t_Rc'0. [%#sops'0] postcondition_once'1 self args res
      = (postcondition'0 self args res /\ resolve'13 self)
  
  function fn_mut'0 (self: ()) (args: tuple'1) (res_state: ()) (res: t_Rc'0) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: tuple'1, res_state: (), res: t_Rc'0. [%#sops] postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc'1) (tokens: t_Tokens) (f: closure0) (return' (x: t_Rc'0)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant] inv'34 f}
    {[@expl:open requires #0] [%#slocal_invariant'0] precondition () self}
    {[@expl:open requires #1] [%#slocal_invariant'1] forall this: t_LocalInvariant. postcondition () self this
      -> precondition'1 () { _p0'1 = new_logic this; _p1'1 = tokens; _p2 = f }}
    any
    [ return''0 (result: t_Rc'0) -> {[%#slocal_invariant'2] exists this: t_LocalInvariant. postcondition () self this
        /\ postcondition'0 () { _p0'1 = new_logic this; _p1'1 = tokens; _p2 = f } result}
      (! return' {result}) ]
  
  let rec new'2 (value: t_PCell) (return' (x: t_Rc)) = {[@expl:new 'value' type invariant] [%#src'0] inv'5 value}
    any [ return''0 (result: t_Rc) -> {[%#src'1] view'5 result = value} (! return' {result}) ]
  
  let rec clone''0 (self: t_Rc'1) (return' (x: t_Rc'1)) = any
    [ return''0 (result: t_Rc'1) -> {[%#sghost'0] result = self} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec set [#"persistent_array.rs" 161 8 161 80] (self: t_PersistentArray) (index: UInt64.t) (value: t_T)
    (tokens: t_Tokens) (return' (x: t_PersistentArray)) =
    {[@expl:set 'self' type invariant] [%#spersistent_array'0] inv'32 self}
    {[@expl:set 'value' type invariant] [%#spersistent_array'1] inv value}
    {[@expl:set requires #0] [%#spersistent_array'2] UInt64.t'int index < Seq.length (view'4 self)}
    {[@expl:set requires #1] [%#spersistent_array'3] contains'3 tokens (Namespace_PARRAY_0'62 0)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &new_logical_value <- [%#spersistent_array] Seq.set (view'4 self'0) (UInt64.t'int index'0) value'0 ] s1
      | s1 = bb1 ]
    | bb1 = s0
      [ s0 = clone' {self'0.t_PersistentArray__program_value} (fun (_ret: t_Rc) -> [ &_16 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_13 <- C_Link index'0 value'0 _16 ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_13} (fun (_ret: tuple'0) -> [ &_12 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &program_value <- _12._p0'0 ] s1 | s1 = [ &ownership <- _12._p1'0 ] s2 | s2 = bb6 ]
    | bb6 = s0
      [ s0 = [ &program_value'0 <- program_value ] s1
      | s1 = borrow {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc'1) -> [ &_20 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_23 <- { _0 = program_value'0; _1 = self'0; _2 = ownership; _3 = new_logical_value } ] s1
      | s1 = open'0 {_20} {tokens'0} {_23} (fun (_ret: t_Rc'0) -> [ &new_frac <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0 [ s0 = new'2 {program_value} (fun (_ret: t_Rc) -> [ &_27 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = clone''0 {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc'1) -> [ &_30 <- _ret ] s1)
      | s1 = bb10 ]
    | bb10 = s0
      [ s0 = [ &_0'0 <- { t_PersistentArray__program_value = _27;
                          t_PersistentArray__contained_in_inv = new_frac;
                          t_PersistentArray__map_invariant = _30 } ] s1
      | s1 = bb13 ]
    | bb13 = return''0 {_0'0} ]
    [ & _0'0: t_PersistentArray = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & index'0: UInt64.t = index
    | & value'0: t_T = value
    | & tokens'0: t_Tokens = tokens
    | & new_logical_value: Seq.seq t_T = Any.any_l ()
    | & program_value: t_PCell = Any.any_l ()
    | & ownership: t_PCellOwn = Any.any_l ()
    | & _12: tuple'0 = Any.any_l ()
    | & _13: t_Inner = Any.any_l ()
    | & _16: t_Rc = Any.any_l ()
    | & new_frac: t_Rc'0 = Any.any_l ()
    | & program_value'0: t_PCell = Any.any_l ()
    | & _20: t_Rc'1 = Any.any_l ()
    | & _23: closure0 = Any.any_l ()
    | & _27: t_Rc = Any.any_l ()
    | & _30: t_Rc'1 = Any.any_l () ])
    [ return''0 (result: t_PersistentArray) -> {[@expl:set result type invariant] [%#spersistent_array'4] inv'31 result}
      {[@expl:set ensures] [%#spersistent_array'5] view'3 result = Seq.set (view'4 self) (UInt64.t'int index) value}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get_immut [#"persistent_array.rs" 214 8 214 95] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span spersistent_array = "persistent_array.rs" 214 40 214 44
  let%span spersistent_array'0 = "persistent_array.rs" 211 8 211 46
  let%span spersistent_array'1 = "persistent_array.rs" 212 19 212 39
  let%span spersistent_array'2 = "persistent_array.rs" 214 90 214 95
  let%span spersistent_array'3 = "persistent_array.rs" 213 18 213 42
  let%span spersistent_array'4 = "persistent_array.rs" 215 53 215 58
  let%span spersistent_array'5 = "persistent_array.rs" 215 54 215 57
  let%span spersistent_array'6 = "persistent_array.rs" 233 12 233 15
  let%span spersistent_array'7 = "persistent_array.rs" 226 19 226 55
  let%span spersistent_array'8 = "persistent_array.rs" 227 19 227 50
  let%span spersistent_array'9 = "persistent_array.rs" 228 19 228 52
  let%span spersistent_array'10 = "persistent_array.rs" 234 13 234 18
  let%span spersistent_array'11 = "persistent_array.rs" 229 18 229 55
  let%span spersistent_array'12 = "persistent_array.rs" 76 16 76 41
  let%span spersistent_array'13 = "persistent_array.rs" 102 16 117 21
  let%span spersistent_array'14 = "persistent_array.rs" 59 16 61 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 133 14 133 32
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 70 14 70 18
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 70 4 70 36
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 69 14 69 31
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 197 22 197 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 197 4 199 17
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 195 14 195 29
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 185 14 185 26
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 91 8 91 22
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 58 20 58 46
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 105 14 105 49
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 260 51 260 52
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 252 15 252 46
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 253 15 254 111
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 260 4 262 51
  let%span slocal_invariant'3 = "../../creusot-contracts/src/local_invariant.rs" 256 14 257 120
  let%span slocal_invariant'4 = "../../creusot-contracts/src/local_invariant.rs" 181 4 181 12
  let%span slocal_invariant'5 = "../../creusot-contracts/src/local_invariant.rs" 237 4 239 51
  let%span slocal_invariant'6 = "../../creusot-contracts/src/local_invariant.rs" 237 51 237 52
  let%span slocal_invariant'7 = "../../creusot-contracts/src/local_invariant.rs" 230 4 230 50
  let%span slocal_invariant'8 = "../../creusot-contracts/src/local_invariant.rs" 231 15 234 100
  let%span slocal_invariant'9 = "../../creusot-contracts/src/local_invariant.rs" 235 14 235 113
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 50 20 50 34
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 686 20 686 91
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 4 133 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 4 134 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 4 139 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 4 144 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 4 145 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 4 146 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  use set.Set
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1 = { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray = {
    t_PersistentArray__program_value: t_Rc;
    t_PersistentArray__contained_in_inv: t_Rc'0;
    t_PersistentArray__map_invariant: t_Rc'1 }
  
  let rec borrow (self: t_Rc'1) (return' (x: t_Rc'1)) = any
    [ return''0 (result: t_Rc'1) -> {[%#sghost] result = self} (! return' {result}) ]
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Id
  
  type t_PA = { t_PA__permissions: t_FMap; t_PA__auth: t_Authority; t_PA__rank: Map.map t_Id int; t_PA__length: int }
  
  type t_PCellOwn = { t_PCellOwn__0: () }
  
  type t_Option = C_None | C_Some t_PCellOwn
  
  function view (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap] Map.get (view self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'0] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'2 = { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed'0] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'0 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'0] inv'2 (view'0 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant] inv'4 self
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) = [%#spcell] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn = [%#sfmap'1] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'3] forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_0: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__permissions = permissions; t_PA__auth = auth; t_PA__rank = rank; t_PA__length = length} -> inv'7 permissions
        /\ inv'8 auth
        end
  
  predicate invariant''6 (self: MutBorrow.t t_PA) = [%#sinvariant'0] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self: MutBorrow.t t_PA) = [%#sghost'12] inv'10 self
  
  predicate inv'11 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'11 self
  
  predicate inv'12 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'10 self
  
  predicate inv'13 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:deref 'self' type invariant] [%#sghost'0] inv'12 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'1] inv'13 result}
      {[%#sghost'2] result = self}
      (! return' {result}) ]
  
  type closure0 = { _0: t_PersistentArray; _1: UInt64.t }
  
  let rec deref'0 (self: t_Rc'0) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost'2] result = self} (! return' {result}) ]
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  predicate invariant''10 (self: t_Fragment)
  
  predicate inv'14 (_0'0: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
      = (invariant''10 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''11 (self: t_Fragment) = [%#sinvariant] inv'14 self
  
  predicate inv'15 (_0'0: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''11 x
  
  function view'1 (self: t_Rc'0) : t_Fragment
  
  let rec as_ref (self_: t_Rc'0) (return' (x: t_Fragment)) = any
    [ return''0 (result: t_Fragment) -> {inv'15 result} {[%#src] result = view'1 self_} (! return' {result}) ]
  
  predicate invariant''12 (self: t_Authority) = [%#sinvariant] inv'8 self
  
  predicate inv'16 (_0'0: t_Authority)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Authority [inv'16 x]. inv'16 x = invariant''12 x
  
  function id (self: t_Authority) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'2 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = [%#sfmap] Map.get (view'2 self) k
  
  function view'3 (self: t_Authority) : t_FMap'0
  
  function view'4 (self: t_Authority) : t_FMap'0 = [%#smodel] view'3 self
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view'5 (self: t_Fragment) : tuple
  
  function view'6 (self: t_Fragment) : tuple = [%#smodel] view'5 self
  
  let rec contains'0 (self: t_Authority) (frag: t_Fragment) (return' (x: ())) =
    {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'16 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'15 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id self = id'0 frag}
    any
    [ return''0 (result: ()) -> {[%#sfmap_view'2] get'0 (view'4 self) (view'6 frag)._p0 = C_Some'0 ((view'6 frag)._p1)}
      (! return' {result}) ]
  
  let rec new (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'3] result = x} (! return' {result}) ]
  
  let rec into_inner (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'4] inv'11 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'5] inv'10 result}
      {[%#sghost'6] result = self}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_PA) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0: MutBorrow.t t_PA) = resolve _0'0
  
  predicate invariant''13 (self: t_PA) = [%#sinvariant] inv'9 self
  
  predicate inv'17 (_0'0: t_PA)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_PA [inv'17 x]. inv'17 x = invariant''13 x
  
  predicate invariant''14 (self: t_PA) = [%#sghost'12] inv'17 self
  
  predicate inv'18 (_0'0: t_PA)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_PA [inv'18 x]. inv'18 x = invariant''14 x
  
  let rec new'0 (x: t_PA) (return' (x'0: t_PA)) = {[@expl:new 'x' type invariant] [%#sghost'7] inv'17 x}
    any [ return''0 (result: t_PA) -> {[%#sghost'8] inv'18 result} {[%#sghost'3] result = x} (! return' {result}) ]
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'0] get'0 self k <> C_None'0
  
  function id'1 (self: t_PCellOwn) : t_Id
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'2] unwrap_logic'0 (get'0 self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'1] lookup'0 self key
  
  type t_UnsafeCell = { t_UnsafeCell__value: t_Inner }
  
  type t_PCell = { t_PCell__0: t_UnsafeCell }
  
  function id'2 (self: t_PCell) : t_Id
  
  function view'7 (self: t_Rc) : t_PCell
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  predicate invariant_with_data [#"persistent_array.rs" 100 8 100 61] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'13] id self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains'1 (view'3 self.t_PA__auth) id'3
      -> contains self.t_PA__permissions id'3
      /\ id'1 (index_logic'0 self.t_PA__permissions id'3) = id'3
      /\ Seq.length (index_logic'2 (view'3 self.t_PA__auth) id'3) = self.t_PA__length
      /\ match val' (index_logic'0 self.t_PA__permissions id'3) with
        | C_Direct v -> index_logic'2 (view'3 self.t_PA__auth) id'3 = view'0 v
        | C_Link index value next -> contains'1 (view'3 self.t_PA__auth) (id'2 (view'7 next))
        /\ index_logic'3 self.t_PA__rank id'3 > index_logic'3 self.t_PA__rank (id'2 (view'7 next))
        /\ UInt64.t'int index < self.t_PA__length
        /\ index_logic'2 (view'3 self.t_PA__auth) id'3
        = Seq.set (index_logic'2 (view'3 self.t_PA__auth) (id'2 (view'7 next))) (UInt64.t'int index) value
        end)
  
  function view'8 (self: t_Rc) : t_PCell = [%#smodel] view'7 self
  
  predicate invariant''15 (self: t_T) = [%#sinvariant] inv'0 self
  
  predicate inv'19 (_0'0: t_T)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_T [inv'19 x]. inv'19 x = invariant''15 x
  
  let rec get_inner_immut (inner: t_Rc) (i: UInt64.t) (inv'20: t_PA) (return' (x: t_T)) =
    {[@expl:get_inner_immut 'inv' type invariant] [%#spersistent_array'6] inv'18 inv'20}
    {[@expl:get_inner_immut requires #0] [%#spersistent_array'7] exists p: t_Id. invariant_with_data inv'20 p}
    {[@expl:get_inner_immut requires #1] [%#spersistent_array'8] contains'1 (view'3 inv'20.t_PA__auth) (id'2 (view'8 inner))}
    {[@expl:get_inner_immut requires #2] [%#spersistent_array'9] UInt64.t'int i
    < Seq.length (index_logic'2 (view'3 inv'20.t_PA__auth) (id'2 (view'8 inner)))}
    any
    [ return''0 (result: t_T) -> {[%#spersistent_array'10] inv'19 result}
      {[%#spersistent_array'11] result
      = Seq.get (index_logic'2 (view'3 inv'20.t_PA__auth) (id'2 (view'8 inner))) (UInt64.t'int i)}
      (! return' {result}) ]
  
  function view'9 (self: t_Fragment) : tuple = [%#sboxed] view'5 self
  
  function view'10 (self: t_Rc'0) : t_Fragment = [%#sghost'11] view'1 self
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'11 (self: t_Rc'1) : t_LocalInvariant
  
  function view'12 (self: t_Rc'1) : t_LocalInvariant = [%#sghost'11] view'11 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''16 [#"persistent_array.rs" 56 8 56 34] (self: t_PersistentArray) =
    [%#spersistent_array'14] (view'9 (view'10 self.t_PersistentArray__contained_in_inv))._p0
      = id'2 (view'7 self.t_PersistentArray__program_value)
    /\ id'0 (view'10 self.t_PersistentArray__contained_in_inv) = public (view'12 self.t_PersistentArray__map_invariant)
    /\ namespace (view'12 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv'20 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PersistentArray [inv'20 x]. inv'20 x
      = (invariant''16 x
      /\ match x with
        | {t_PersistentArray__program_value = program_value; t_PersistentArray__contained_in_inv = contained_in_inv; t_PersistentArray__map_invariant = map_invariant} -> true
        end)
  
  predicate invariant''17 (self: t_PersistentArray) = [%#sinvariant] inv'20 self
  
  predicate inv'21 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_PersistentArray [inv'21 x]. inv'21 x = invariant''17 x
  
  predicate invariant''18 (self: t_PersistentArray) = [%#sinvariant] inv'21 self
  
  predicate inv'22 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_PersistentArray [inv'22 x]. inv'22 x = invariant''18 x
  
  predicate inv'23 (_0'0: closure0)
  
  axiom inv_axiom'22 [@rewrite]: forall x: closure0 [inv'23 x]. inv'23 x = (let {_0 = x0; _1 = x1} = x in inv'22 x0)
  
  let rec closure0 [#"persistent_array.rs" 215 53 215 58] [@coma:extspec] (self: closure0) (inv'24: MutBorrow.t t_PA)
    (return' (x: t_T)) = bb0
    [ bb0 = s0 [ s0 = deref {inv'25} (fun (_ret: MutBorrow.t t_PA) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = deref'0 {(_1'0._0).t_PersistentArray__contained_in_inv} (fun (_ret: t_Rc'0) -> [ &_12 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0 [ s0 = as_ref {_12} (fun (_ret: t_Fragment) -> [ &_10 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = contains'0 {(_7.current).t_PA__auth} {_10} (fun (_ret: ()) -> [ &_5 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_4} (fun (_ret: ()) -> [ &_3 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_15 <- (_1'0._0).t_PersistentArray__program_value ] s1
      | s1 = into_inner {inv'25} (fun (_ret: MutBorrow.t t_PA) -> [ &_19 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'10 _19} s1
      | s1 = -{resolve'0 _19}- s2
      | s2 = new'0 {_19.current} (fun (_ret: t_PA) -> [ &_17 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = get_inner_immut {_15} {_1'0._1} {_17} (fun (_ret: t_T) -> [ &_0'0 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = return' {_0'0} ]
    [ & _0'0: t_T = Any.any_l ()
    | & _1'0: closure0 = self
    | & inv'25: MutBorrow.t t_PA = inv'24
    | & _3: () = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _5: () = Any.any_l ()
    | & _7: MutBorrow.t t_PA = Any.any_l ()
    | & _10: t_Fragment = Any.any_l ()
    | & _12: t_Rc'0 = Any.any_l ()
    | & _15: t_Rc = Any.any_l ()
    | & _17: t_PA = Any.any_l ()
    | & _19: MutBorrow.t t_PA = Any.any_l () ]
  
  type t_Tokens
  
  predicate precondition (self: ()) (args: t_Rc'1) = let self_ = args in true
  
  let rec deref'1 (self_: t_Rc'1) (return' (x: t_LocalInvariant)) = any
    [ return''0 (result: t_LocalInvariant) -> {[%#src'0] result = view'11 self_} (! return' {result}) ]
  
  predicate postcondition_once (self: ()) (args: t_Rc'1) (result: t_LocalInvariant) =
    let self_ = args in result = view'11 self_
  
  predicate resolve'1 (_0'0: ()) = true
  
  predicate postcondition_mut (self: ()) (args: t_Rc'1) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view'11 self_
  
  function fn_mut_once (self: ()) (args: t_Rc'1) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec:
    forall self: (), args: t_Rc'1, res: t_LocalInvariant. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) = true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc'1) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Rc'1, res_state: (), res: t_LocalInvariant. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_Rc'1) (result: t_LocalInvariant) =
    let self_ = args in result = view'11 self_
  
  function fn_once (self: ()) (args: t_Rc'1) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc'1, res: t_LocalInvariant. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve'1 self)
  
  function fn_mut (self: ()) (args: t_Rc'1) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Rc'1, res_state: (), res: t_LocalInvariant. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  type tuple'0 = { _p0'0: t_LocalInvariant; _p1'0: t_Tokens; _p2: closure0 }
  
  predicate precondition'0 (self: closure0) (args: MutBorrow.t t_PA) =
    [%#spersistent_array'4] let inv'24 = args in closure0'pre self inv'24
  
  predicate postcondition_once'0 (self: closure0) (args: MutBorrow.t t_PA) (result: t_T) =
    [%#spersistent_array'4] let inv'24 = args in closure0'post'return' self inv'24 result
  
  function fin (self: MutBorrow.t t_PA) : t_PA = [%#sghost'10] self.final
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = [%#sset] Set.mem e self
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'3 (self: t_Tokens) (namespace'0: t_Namespace) =
    [%#slocal_invariant'4] contains'2 (namespaces self) namespace'0
  
  predicate precondition'1 (self: ()) (args: tuple'0) =
    [%#slocal_invariant'5] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (forall t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
          /\ inv'11 t
        -> precondition'0 f t
        /\ (forall res: t_T. postcondition_once'0 f t res -> invariant_with_data (fin t) (public self'0)))
    /\ contains'3 tokens (namespace self'0) /\ inv'23 f
  
  let rec open (self: t_LocalInvariant) (tokens: t_Tokens) (f: closure0) (return' (x: t_T)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant'6] inv'23 f}
    {[@expl:open requires #0] [%#slocal_invariant'7] contains'3 tokens (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'8] forall t: MutBorrow.t t_PA. invariant_with_data t.current (public self)
        /\ inv'11 t
      -> precondition'0 f t
      /\ (forall res: t_T. postcondition_once'0 f t res -> invariant_with_data (fin t) (public self))}
    any
    [ return''0 (result: t_T) -> {[%#slocal_invariant'5] inv'19 result}
      {[%#slocal_invariant'9] exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self)
        /\ postcondition_once'0 f t result}
      (! return' {result}) ]
  
  function new_logic (x: t_LocalInvariant) : t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. [%#sghost'9] new_logic x = x
  
  predicate postcondition_once'1 (self: ()) (args: tuple'0) (result: t_T) =
    [%#slocal_invariant'5] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'19 result
  
  predicate resolve'2 (_0'0: ()) = true
  
  predicate postcondition_mut'0 (self: ()) (args: tuple'0) (result_state: ()) (result: t_T) =
    [%#slocal_invariant'5] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'19 result
  
  function fn_mut_once'0 (self: ()) (args: tuple'0) (res: t_T) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'0, res: t_T. [%#sops'8] postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'2 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) = true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
      -> ([%#sops'6] hist_inv'0 b c) -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'0) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: tuple'0, res_state: (), res: t_T. ([%#sops'2] postcondition_mut'0 self args res_state res)
      -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple'0) (result: t_T) =
    [%#slocal_invariant'5] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'19 result
  
  function fn_once'0 (self: ()) (args: tuple'0) (res: t_T) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'0, res: t_T. [%#sops'0] postcondition_once'1 self args res
      = (postcondition'0 self args res /\ resolve'2 self)
  
  function fn_mut'0 (self: ()) (args: tuple'0) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: tuple'0, res_state: (), res: t_T. [%#sops] postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc'1) (tokens: t_Tokens) (f: closure0) (return' (x: t_T)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant] inv'23 f}
    {[@expl:open requires #0] [%#slocal_invariant'0] precondition () self}
    {[@expl:open requires #1] [%#slocal_invariant'1] forall this: t_LocalInvariant. postcondition () self this
      -> precondition'1 () { _p0'0 = new_logic this; _p1'0 = tokens; _p2 = f }}
    any
    [ return''0 (result: t_T) -> {[%#slocal_invariant'2] inv'19 result}
      {[%#slocal_invariant'3] exists this: t_LocalInvariant. postcondition () self this
        /\ postcondition'0 () { _p0'0 = new_logic this; _p1'0 = tokens; _p2 = f } result}
      (! return' {result}) ]
  
  function view'13 [#"persistent_array.rs" 74 8 74 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'12] (view'9 (view'10 self.t_PersistentArray__contained_in_inv))._p1
  
  function view'14 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'13 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_immut [#"persistent_array.rs" 214 8 214 95] (self: t_PersistentArray) (index: UInt64.t) (tokens: t_Tokens)
    (return' (x: t_T)) = {[@expl:get_immut 'self' type invariant] [%#spersistent_array] inv'21 self}
    {[@expl:get_immut requires #0] [%#spersistent_array'0] contains'3 tokens (Namespace_PARRAY_0'62 0)}
    {[@expl:get_immut requires #1] [%#spersistent_array'1] UInt64.t'int index < Seq.length (view'14 self)}
    (! bb0
    [ bb0 = s0
      [ s0 = borrow {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc'1) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_11 <- { _0 = self'0; _1 = index'0 } ] s1
      | s1 = open'0 {_8} {tokens'0} {_11} (fun (_ret: t_T) -> [ &_7 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0'0 <- _7 ] s1 | s1 = return''0 {_0'0} ] ]
    [ & _0'0: t_T = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & index'0: UInt64.t = index
    | & tokens'0: t_Tokens = tokens
    | & _7: t_T = Any.any_l ()
    | & _8: t_Rc'1 = Any.any_l ()
    | & _11: closure0 = Any.any_l () ])
    [ return''0 (result: t_T) -> {[@expl:get_immut result type invariant] [%#spersistent_array'2] inv'19 result}
      {[@expl:get_immut ensures] [%#spersistent_array'3] result = Seq.get (view'14 self) (UInt64.t'int index)}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get_inner_immut [#"persistent_array.rs" 230 8 234 18] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span spersistent_array = "persistent_array.rs" 233 12 233 15
  let%span spersistent_array'0 = "persistent_array.rs" 226 19 226 55
  let%span spersistent_array'1 = "persistent_array.rs" 227 19 227 50
  let%span spersistent_array'2 = "persistent_array.rs" 228 19 228 52
  let%span spersistent_array'3 = "persistent_array.rs" 234 13 234 18
  let%span spersistent_array'4 = "persistent_array.rs" 229 18 229 55
  let%span spersistent_array'5 = "persistent_array.rs" 102 16 117 21
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 70 14 70 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 70 4 70 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 69 14 69 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 91 8 91 22
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 195 16 195 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 196 16 196 48
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 197 16 197 56
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 228 21 228 25
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 227 14 227 34
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 169 33 169 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 169 39 169 43
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 167 15 167 37
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 169 4 169 77
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 168 14 168 30
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 30 4 30 12
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 58 20 58 46
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 354 22 354 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 354 4 354 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 353 14 353 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 686 20 686 91
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 118 20 118 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 125 20 125 37
  
  use map.Map
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Id
  
  type t_PA = { t_PA__permissions: t_FMap; t_PA__auth: t_Authority; t_PA__rank: Map.map t_Id int; t_PA__length: int }
  
  type t_PCellOwn = { t_PCellOwn__0: () }
  
  type t_Option = C_None | C_Some t_PCellOwn
  
  function view (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'4] Map.get (view self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'2] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'0 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'2] Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'3] inv'2 (view'0 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant] inv'4 self
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) = [%#spcell'7] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn = [%#sfmap'5] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn = [%#sfmap'3] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'6] forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_0: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__permissions = permissions; t_PA__auth = auth; t_PA__rank = rank; t_PA__length = length} -> inv'7 permissions
        /\ inv'8 auth
        end
  
  predicate invariant''6 (self: t_PA) = [%#sinvariant] inv'9 self
  
  predicate inv'10 (_0: t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self: t_PA) = [%#sghost'6] inv'10 self
  
  predicate inv'11 (_0: t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: t_PA) = [%#sinvariant] inv'11 self
  
  predicate inv'12 (_0: t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: t_PA) = [%#sinvariant] inv'10 self
  
  predicate inv'13 (_0: t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: t_PA) (return' (x: t_PA)) = {[@expl:deref 'self' type invariant] [%#sghost] inv'12 self}
    any [ return''0 (result: t_PA) -> {[%#sghost'0] inv'13 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_UnsafeCell = { t_UnsafeCell__value: t_Inner }
  
  type t_PCell = { t_PCell__0: t_UnsafeCell }
  
  predicate inv'14 (_0: t_UnsafeCell)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_UnsafeCell [inv'14 x]. inv'14 x
      = match x with
        | {t_UnsafeCell__value = value} -> inv'4 value
        end
  
  predicate inv'15 (_0: t_PCell)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_PCell [inv'15 x]. inv'15 x
      = match x with
        | {t_PCell__0 = a_0} -> inv'14 a_0
        end
  
  predicate invariant''10 (self: t_PCell) = [%#sinvariant] inv'15 self
  
  predicate inv'16 (_0: t_PCell)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_PCell [inv'16 x]. inv'16 x = invariant''10 x
  
  function view'1 (self: t_Rc) : t_PCell
  
  let rec deref'0 (self_: t_Rc) (return' (x: t_PCell)) = any
    [ return''0 (result: t_PCell) -> {inv'16 result} {[%#src] result = view'1 self_} (! return' {result}) ]
  
  function id (self: t_PCell) : t_Id
  
  let rec id_ghost (self: t_PCell) (return' (x: t_Id)) = {[@expl:id_ghost 'self' type invariant] [%#spcell] inv'16 self}
    any [ return''0 (result: t_Id) -> {[%#spcell'0] result = id self} (! return' {result}) ]
  
  let rec deref'1 (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PCellOwn
  
  predicate invariant''11 (self: t_FMap) = [%#sinvariant] inv'7 self
  
  predicate inv'17 (_0: t_FMap)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_FMap [inv'17 x]. inv'17 x = invariant''11 x
  
  predicate invariant''12 (self: t_PCellOwn) = [%#sinvariant] inv'6 self
  
  predicate inv'18 (_0: t_PCellOwn)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_PCellOwn [inv'18 x]. inv'18 x = invariant''12 x
  
  predicate inv'19 (_0: t_Option'0)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_Option'0 [inv'19 x]. inv'19 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'18 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PCellOwn t_PCellOwn) : t_Option'0 = [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Id) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'17 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'19 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PCellOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_PCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'19 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any
    [ return''0 (result: t_PCellOwn) -> {inv'18 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  predicate invariant''13 (self: t_PCellOwn) = [%#sghost'6] inv'18 self
  
  predicate inv'20 (_0: t_PCellOwn)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PCellOwn [inv'20 x]. inv'20 x = invariant''13 x
  
  let rec new (x: t_PCellOwn) (return' (x'0: t_PCellOwn)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'18 x}
    any
    [ return''0 (result: t_PCellOwn) -> {[%#sghost'3] inv'20 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  let rec as_ref (self_: t_Rc) (return' (x: t_PCell)) = any
    [ return''0 (result: t_PCell) -> {inv'16 result} {[%#src'0] result = view'1 self_} (! return' {result}) ]
  
  function id'0 (self: t_PCellOwn) : t_Id
  
  function view'2 (self: t_PCellOwn) : t_Inner = [%#spcell'6] val' self
  
  function view'3 (self: t_PCellOwn) : t_Inner = [%#smodel] view'2 self
  
  function view'4 (self: t_PCellOwn) : t_Inner = [%#sghost'5] view'3 self
  
  let rec borrow (self: t_PCell) (perm: t_PCellOwn) (return' (x: t_Inner)) =
    {[@expl:borrow 'self' type invariant] [%#spcell'1] inv'16 self}
    {[@expl:borrow 'perm' type invariant] [%#spcell'2] inv'20 perm}
    {[@expl:borrow requires] [%#spcell'3] id self = id'0 perm}
    any
    [ return''0 (result: t_Inner) -> {[%#spcell'4] inv'5 result}
      {[%#spcell'5] result = view'4 perm}
      (! return' {result}) ]
  
  let rec v_Link (input: t_Inner) (ret (index: UInt64.t) (value: t_T) (next: t_Rc)) = any
    [ good (index: UInt64.t) (value: t_T) (next: t_Rc) -> {C_Link index value next = input}
      (! ret {index} {value} {next})
    | bad -> {forall index: UInt64.t, value: t_T, next: t_Rc [C_Link index value next: t_Inner]. C_Link index value next
        <> input}
      (! {false}
      any) ]
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate invariant''14 (self: t_Vec) = [%#sinvariant] inv'3 self
  
  predicate inv'21 (_0: t_Vec)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Vec [inv'21 x]. inv'21 x = invariant''14 x
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  function view'5 (self: t_Vec) : Seq.seq t_T = [%#smodel] view'0 self
  
  predicate invariant''15 (self: t_T) = [%#sinvariant] inv'0 self
  
  predicate inv'22 (_0: t_T)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_T [inv'22 x]. inv'22 x = invariant''15 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  let rec index (self_: t_Vec) (ix: UInt64.t) (return' (x: t_T)) =
    {[@expl:index 'self_' type invariant] [%#svec] inv'21 self_}
    {[@expl:index requires] [%#svec'0] in_bounds ix (view'5 self_)}
    any
    [ return''0 (result: t_T) -> {inv'22 result} {[%#svec'1] has_value ix (view'5 self_) result} (! return' {result}) ]
  
  function id'1 (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'1 = C_None'1 | C_Some'1 (Seq.seq t_T)
  
  function view'6 (self: t_FMap'0) : Map.map t_Id t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'1 = [%#sfmap'4] Map.get (view'6 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'2] get'0 self k <> C_None'1
  
  function view'7 (self: t_Authority) : t_FMap'0
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'1) : Seq.seq t_T = [%#soption'4] match self with
      | C_Some'1 x -> x
      | C_None'1 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'5] unwrap_logic'0 (get'0 self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'3] lookup'0 self key
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  predicate invariant_with_data [#"persistent_array.rs" 100 8 100 61] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'5] id'1 self.t_PA__auth = resource_id
    /\ (forall id'2: t_Id. contains'0 (view'7 self.t_PA__auth) id'2
      -> contains self.t_PA__permissions id'2
      /\ id'0 (index_logic'0 self.t_PA__permissions id'2) = id'2
      /\ Seq.length (index_logic'2 (view'7 self.t_PA__auth) id'2) = self.t_PA__length
      /\ match val' (index_logic'0 self.t_PA__permissions id'2) with
        | C_Direct v -> index_logic'2 (view'7 self.t_PA__auth) id'2 = view'0 v
        | C_Link index'0 value next -> contains'0 (view'7 self.t_PA__auth) (id (view'1 next))
        /\ index_logic'3 self.t_PA__rank id'2 > index_logic'3 self.t_PA__rank (id (view'1 next))
        /\ UInt64.t'int index'0 < self.t_PA__length
        /\ index_logic'2 (view'7 self.t_PA__auth) id'2
        = Seq.set (index_logic'2 (view'7 self.t_PA__auth) (id (view'1 next))) (UInt64.t'int index'0) value
        end)
  
  function view'8 (self: t_Rc) : t_PCell = [%#smodel] view'1 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_inner_immut [#"persistent_array.rs" 230 8 234 18] (inner: t_Rc) (i: UInt64.t) (inv'23: t_PA)
    (return' (x: t_T)) = {[@expl:get_inner_immut 'inv' type invariant] [%#spersistent_array] inv'11 inv'23}
    {[@expl:get_inner_immut requires #0] [%#spersistent_array'0] exists p: t_Id. invariant_with_data inv'23 p}
    {[@expl:get_inner_immut requires #1] [%#spersistent_array'1] contains'0 (view'7 inv'23.t_PA__auth) (id (view'8 inner))}
    {[@expl:get_inner_immut requires #2] [%#spersistent_array'2] UInt64.t'int i
    < Seq.length (index_logic'2 (view'7 inv'23.t_PA__auth) (id (view'8 inner)))}
    (! bb0
    [ bb0 = s0 [ s0 = deref {inv'24} (fun (_ret: t_PA) -> [ &_12 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref'0 {inner'0} (fun (_ret: t_PCell) -> [ &_20 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = id_ghost {_20} (fun (_ret: t_Id) -> [ &_18 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = deref'1 {_18} (fun (_ret: t_Id) -> [ &_16 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_15 <- _16 ] s1
      | s1 = get_ghost {_12.t_PA__permissions} {_15} (fun (_ret: t_Option'0) -> [ &_10 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = unwrap {_10} (fun (_ret: t_PCellOwn) -> [ &_9 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = new {_9} (fun (_ret: t_PCellOwn) -> [ &perm <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = as_ref {inner'0} (fun (_ret: t_PCell) -> [ &_24 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = borrow {_24} {perm} (fun (_ret: t_Inner) -> [ &inner'1 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = any
      [ br0 (x0: t_Vec) -> {inner'1 = C_Direct x0} (! bb13)
      | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {inner'1 = C_Link x0 x1 x2} (! bb12) ]
    | bb12 = s0
      [ s0 = v_Link {inner'1} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &index'0 <- rindex ] s1)
      | s1 = v_Link {inner'1} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &value <- rvalue ] s2)
      | s2 = v_Link {inner'1} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &next <- rnext ] s3)
      | s3 = [ &_36 <- i'0 = index'0 ] s4
      | s4 = any [ br0 -> {_36 = false} (! bb16) | br1 -> {_36} (! bb15) ] ]
    | bb15 = s0 [ s0 = [ &_0 <- value ] s1 | s1 = bb19 ]
    | bb16 = s0 [ s0 = get_inner_immut {next} {i'0} {inv'24} (fun (_ret: t_T) -> [ &_39 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0 [ s0 = [ &_0 <- _39 ] s1 | s1 = bb19 ]
    | bb13 = s0
      [ s0 = v_Direct {inner'1} (fun (r0: t_Vec) -> [ &v <- r0 ] s1)
      | s1 = index {v} {i'0} (fun (_ret: t_T) -> [ &_30 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0 [ s0 = [ &_29 <- _30 ] s1 | s1 = [ &_0 <- _29 ] s2 | s2 = bb19 ]
    | bb19 = return''0 {_0} ]
    [ & _0: t_T = Any.any_l ()
    | & inner'0: t_Rc = inner
    | & i'0: UInt64.t = i
    | & inv'24: t_PA = inv'23
    | & perm: t_PCellOwn = Any.any_l ()
    | & _9: t_PCellOwn = Any.any_l ()
    | & _10: t_Option'0 = Any.any_l ()
    | & _12: t_PA = Any.any_l ()
    | & _15: t_Id = Any.any_l ()
    | & _16: t_Id = Any.any_l ()
    | & _18: t_Id = Any.any_l ()
    | & _20: t_PCell = Any.any_l ()
    | & inner'1: t_Inner = Any.any_l ()
    | & _24: t_PCell = Any.any_l ()
    | & v: t_Vec = Any.any_l ()
    | & _29: t_T = Any.any_l ()
    | & _30: t_T = Any.any_l ()
    | & index'0: UInt64.t = Any.any_l ()
    | & value: t_T = Any.any_l ()
    | & next: t_Rc = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _39: t_T = Any.any_l () ])
    [ return''0 (result: t_T) -> {[@expl:get_inner_immut result type invariant] [%#spersistent_array'3] inv'22 result}
      {[@expl:get_inner_immut ensures] [%#spersistent_array'4] result
      = Seq.get (index_logic'2 (view'7 inv'23.t_PA__auth) (id (view'8 inner))) (UInt64.t'int i)}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get [#"persistent_array.rs" 259 8 259 89] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span spersistent_array = "persistent_array.rs" 260 25 260 64
  let%span spersistent_array'0 = "persistent_array.rs" 259 34 259 38
  let%span spersistent_array'1 = "persistent_array.rs" 256 8 256 46
  let%span spersistent_array'2 = "persistent_array.rs" 257 19 257 39
  let%span spersistent_array'3 = "persistent_array.rs" 259 84 259 89
  let%span spersistent_array'4 = "persistent_array.rs" 258 18 258 42
  let%span spersistent_array'5 = "persistent_array.rs" 261 53 261 62
  let%span spersistent_array'6 = "persistent_array.rs" 261 58 261 61
  let%span spersistent_array'7 = "persistent_array.rs" 301 16 301 19
  let%span spersistent_array'8 = "persistent_array.rs" 283 8 283 59
  let%span spersistent_array'9 = "persistent_array.rs" 284 19 284 50
  let%span spersistent_array'10 = "persistent_array.rs" 285 18 285 73
  let%span spersistent_array'11 = "persistent_array.rs" 286 18 286 97
  let%span spersistent_array'12 = "persistent_array.rs" 287 18 287 58
  let%span spersistent_array'13 = "persistent_array.rs" 288 18 288 62
  let%span spersistent_array'14 = "persistent_array.rs" 289 18 291 85
  let%span spersistent_array'15 = "persistent_array.rs" 293 18 296 9
  let%span spersistent_array'16 = "persistent_array.rs" 297 18 297 67
  let%span spersistent_array'17 = "persistent_array.rs" 76 16 76 41
  let%span spersistent_array'18 = "persistent_array.rs" 102 16 117 21
  let%span spersistent_array'19 = "persistent_array.rs" 59 16 61 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 91 8 91 22
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 133 14 133 32
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 70 14 70 18
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 70 4 70 36
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 69 14 69 31
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 197 22 197 26
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 197 4 199 17
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 195 14 195 29
  let%span sghost'13 = "../../creusot-contracts/src/ghost.rs" 185 14 185 26
  let%span sghost'14 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'15 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 202 16 202 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 203 26 203 42
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 228 21 228 25
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 227 14 227 34
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 169 33 169 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 169 39 169 43
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 167 15 167 37
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 169 4 169 77
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 168 14 168 30
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 30 4 30 12
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 58 20 58 46
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 105 14 105 49
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 354 22 354 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 354 4 354 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 353 14 353 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 260 51 260 52
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 252 15 252 46
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 253 15 254 111
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 260 4 262 51
  let%span slocal_invariant'3 = "../../creusot-contracts/src/local_invariant.rs" 256 14 257 120
  let%span slocal_invariant'4 = "../../creusot-contracts/src/local_invariant.rs" 181 4 181 12
  let%span slocal_invariant'5 = "../../creusot-contracts/src/local_invariant.rs" 237 4 239 51
  let%span slocal_invariant'6 = "../../creusot-contracts/src/local_invariant.rs" 237 51 237 52
  let%span slocal_invariant'7 = "../../creusot-contracts/src/local_invariant.rs" 230 4 230 50
  let%span slocal_invariant'8 = "../../creusot-contracts/src/local_invariant.rs" 231 15 234 100
  let%span slocal_invariant'9 = "../../creusot-contracts/src/local_invariant.rs" 235 14 235 113
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 50 20 50 34
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 686 20 686 91
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 4 133 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 4 134 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 4 139 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 4 144 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 4 145 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 4 146 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 367 8 367 9
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 367 8 367 40
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 368 8 368 48
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 118 20 118 37
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 125 20 125 37
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 21 20 21 30
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use set.Set
  
  type t_LocalInvariant
  
  type t_Id
  
  function public (self: t_LocalInvariant) : t_Id
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  function view (self: t_Rc) : t_LocalInvariant
  
  function view'0 (self: t_Rc) : t_LocalInvariant = [%#sghost] view self
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1 = { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray = {
    t_PersistentArray__program_value: t_Rc'0;
    t_PersistentArray__contained_in_inv: t_Rc'1;
    t_PersistentArray__map_invariant: t_Rc }
  
  let rec borrow (self: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#sghost'0] result = self} (! return' {result}) ]
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__permissions: t_FMap; t_PA__auth: t_Authority; t_PA__rank: Map.map t_Id int; t_PA__length: int }
  
  type t_PCellOwn = { t_PCellOwn__0: () }
  
  type t_Option = C_None | C_Some t_PCellOwn
  
  function view'1 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'2] Map.get (view'1 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'3] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'2 = { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc'0
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed'0] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'1] Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'2] inv'2 (view'2 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant] inv'4 self
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) = [%#spcell'7] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn = [%#sfmap'5] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn = [%#sfmap'4] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'6] forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_0: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__permissions = permissions; t_PA__auth = auth; t_PA__rank = rank; t_PA__length = length} -> inv'7 permissions
        /\ inv'8 auth
        end
  
  predicate invariant''6 (self: MutBorrow.t t_PA) = [%#sinvariant'0] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self: MutBorrow.t t_PA) = [%#sghost'15] inv'10 self
  
  predicate inv'11 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'11 self
  
  predicate inv'12 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'10 self
  
  predicate inv'13 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:deref 'self' type invariant] [%#sghost'1] inv'12 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'2] inv'13 result}
      {[%#sghost'3] result = self}
      (! return' {result}) ]
  
  type closure0 = { _0: t_PersistentArray; _1: t_Id; _2: UInt64.t }
  
  let rec deref'0 (self: t_Rc'1) (return' (x: t_Rc'1)) = any
    [ return''0 (result: t_Rc'1) -> {[%#sghost'3] result = self} (! return' {result}) ]
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  predicate invariant''10 (self: t_Fragment)
  
  predicate inv'14 (_0'0: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
      = (invariant''10 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''11 (self: t_Fragment) = [%#sinvariant] inv'14 self
  
  predicate inv'15 (_0'0: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''11 x
  
  function view'3 (self: t_Rc'1) : t_Fragment
  
  let rec as_ref (self_: t_Rc'1) (return' (x: t_Fragment)) = any
    [ return''0 (result: t_Fragment) -> {inv'15 result} {[%#src] result = view'3 self_} (! return' {result}) ]
  
  predicate invariant''12 (self: t_Authority) = [%#sinvariant] inv'8 self
  
  predicate inv'16 (_0'0: t_Authority)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Authority [inv'16 x]. inv'16 x = invariant''12 x
  
  function id (self: t_Authority) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'4 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = [%#sfmap'2] Map.get (view'4 self) k
  
  function view'5 (self: t_Authority) : t_FMap'0
  
  function view'6 (self: t_Authority) : t_FMap'0 = [%#smodel] view'5 self
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view'7 (self: t_Fragment) : tuple
  
  function view'8 (self: t_Fragment) : tuple = [%#smodel] view'7 self
  
  let rec contains'0 (self: t_Authority) (frag: t_Fragment) (return' (x: ())) =
    {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'16 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'15 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id self = id'0 frag}
    any
    [ return''0 (result: ()) -> {[%#sfmap_view'2] get'0 (view'6 self) (view'8 frag)._p0 = C_Some'0 ((view'8 frag)._p1)}
      (! return' {result}) ]
  
  let rec new (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'4] result = x} (! return' {result}) ]
  
  predicate invariant''13 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant'0] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'17 (_0'0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'17 x]. inv'17 x = invariant''13 x
  
  predicate invariant''14 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant'0] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'18 (_0'0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'18 x]. inv'18 x = invariant''14 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return' (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'17 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_PA)) -> {[%#sghost'6] inv'18 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_PA)) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0: MutBorrow.t (MutBorrow.t t_PA)) = resolve _0'0
  
  let rec new'0 (x: MutBorrow.t t_PA) (return' (x'0: MutBorrow.t t_PA)) =
    {[@expl:new 'x' type invariant] [%#sghost'8] inv'10 x}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'9] inv'11 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate resolve'1 (self: MutBorrow.t t_PA) = [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0'0: MutBorrow.t t_PA) = resolve'1 _0'0
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'3] get'0 self k <> C_None'0
  
  function id'1 (self: t_PCellOwn) : t_Id
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = [%#soption'4] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'5] unwrap_logic'0 (get'0 self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'4] lookup'0 self key
  
  type t_UnsafeCell = { t_UnsafeCell__value: t_Inner }
  
  type t_PCell = { t_PCell__0: t_UnsafeCell }
  
  function id'2 (self: t_PCell) : t_Id
  
  function view'9 (self: t_Rc'0) : t_PCell
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  predicate invariant_with_data [#"persistent_array.rs" 100 8 100 61] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'18] id self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains'1 (view'5 self.t_PA__auth) id'3
      -> contains self.t_PA__permissions id'3
      /\ id'1 (index_logic'0 self.t_PA__permissions id'3) = id'3
      /\ Seq.length (index_logic'2 (view'5 self.t_PA__auth) id'3) = self.t_PA__length
      /\ match val' (index_logic'0 self.t_PA__permissions id'3) with
        | C_Direct v -> index_logic'2 (view'5 self.t_PA__auth) id'3 = view'2 v
        | C_Link index value next -> contains'1 (view'5 self.t_PA__auth) (id'2 (view'9 next))
        /\ index_logic'3 self.t_PA__rank id'3 > index_logic'3 self.t_PA__rank (id'2 (view'9 next))
        /\ UInt64.t'int index < self.t_PA__length
        /\ index_logic'2 (view'5 self.t_PA__auth) id'3
        = Seq.set (index_logic'2 (view'5 self.t_PA__auth) (id'2 (view'9 next))) (UInt64.t'int index) value
        end)
  
  function view'10 (self: t_Rc'0) : t_PCell = [%#smodel] view'9 self
  
  let rec reroot (inner: t_Rc'0) (invariant_id: t_Id) (inv'19: MutBorrow.t t_PA) (return' (x: int)) =
    {[@expl:reroot 'inv' type invariant] [%#spersistent_array'7] inv'11 inv'19}
    {[@expl:reroot requires #0] [%#spersistent_array'8] invariant_with_data inv'19.current invariant_id}
    {[@expl:reroot requires #1] [%#spersistent_array'9] contains'1 (view'5 (inv'19.current).t_PA__auth) (id'2 (view'10 inner))}
    any
    [ return''0 (result: int) -> {[%#spersistent_array'10] invariant_with_data inv'19.final invariant_id}
      {[%#spersistent_array'11] forall id'3: t_Id. contains'1 (view'5 (inv'19.current).t_PA__auth) id'3
        = contains'1 (view'5 (inv'19.final).t_PA__auth) id'3}
      {[%#spersistent_array'12] (inv'19.current).t_PA__auth = (inv'19.final).t_PA__auth}
      {[%#spersistent_array'13] (inv'19.current).t_PA__length = (inv'19.final).t_PA__length}
      {[%#spersistent_array'14] forall id'3: t_Id. index_logic'3 (inv'19.current).t_PA__rank id'3
          > index_logic'3 (inv'19.current).t_PA__rank (id'2 (view'10 inner))
        -> index_logic'3 (inv'19.current).t_PA__rank id'3 = index_logic'3 (inv'19.final).t_PA__rank id'3
        /\ get (inv'19.current).t_PA__permissions id'3 = get (inv'19.final).t_PA__permissions id'3}
      {[%#spersistent_array'15] match val' (index_logic'0 (inv'19.final).t_PA__permissions (id'2 (view'10 inner))) with
        | C_Direct _ -> true
        | C_Link _ _ _ -> false
        end}
      {[%#spersistent_array'16] result = index_logic'3 (inv'19.final).t_PA__rank (id'2 (view'10 inner))}
      (! return' {result}) ]
  
  predicate inv'19 (_0'0: t_UnsafeCell)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_UnsafeCell [inv'19 x]. inv'19 x
      = match x with
        | {t_UnsafeCell__value = value} -> inv'4 value
        end
  
  predicate inv'20 (_0'0: t_PCell)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PCell [inv'20 x]. inv'20 x
      = match x with
        | {t_PCell__0 = a_0} -> inv'19 a_0
        end
  
  predicate invariant''15 (self: t_PCell) = [%#sinvariant] inv'20 self
  
  predicate inv'21 (_0'0: t_PCell)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_PCell [inv'21 x]. inv'21 x = invariant''15 x
  
  let rec deref'1 (self_: t_Rc'0) (return' (x: t_PCell)) = any
    [ return''0 (result: t_PCell) -> {inv'21 result} {[%#src'0] result = view'9 self_} (! return' {result}) ]
  
  let rec id_ghost (self: t_PCell) (return' (x: t_Id)) = {[@expl:id_ghost 'self' type invariant] [%#spcell] inv'21 self}
    any [ return''0 (result: t_Id) -> {[%#spcell'0] result = id'2 self} (! return' {result}) ]
  
  let rec into_inner (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'10] inv'11 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'11] inv'10 result}
      {[%#sghost'12] result = self}
      (! return' {result}) ]
  
  let rec deref'2 (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'3] result = self} (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_PCellOwn
  
  predicate invariant''16 (self: t_FMap) = [%#sinvariant] inv'7 self
  
  predicate inv'22 (_0'0: t_FMap)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_FMap [inv'22 x]. inv'22 x = invariant''16 x
  
  predicate invariant''17 (self: t_PCellOwn) = [%#sinvariant] inv'6 self
  
  predicate inv'23 (_0'0: t_PCellOwn)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_PCellOwn [inv'23 x]. inv'23 x = invariant''17 x
  
  predicate inv'24 (_0'0: t_Option'1)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_Option'1 [inv'24 x]. inv'24 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'23 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PCellOwn t_PCellOwn) : t_Option'1 = [%#soption'2] match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Id) (return' (x: t_Option'1)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'22 self}
    any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'0] inv'24 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PCellOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'1) (return' (x: t_PCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'24 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result: t_PCellOwn) -> {inv'23 result} {[%#soption'1] C_Some'1 result = self_} (! return' {result}) ]
  
  predicate invariant''18 (self: t_PCellOwn) = [%#sghost'15] inv'23 self
  
  predicate inv'25 (_0'0: t_PCellOwn)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_PCellOwn [inv'25 x]. inv'25 x = invariant''18 x
  
  let rec new'1 (x: t_PCellOwn) (return' (x'0: t_PCellOwn)) = {[@expl:new 'x' type invariant] [%#sghost'8] inv'23 x}
    any
    [ return''0 (result: t_PCellOwn) -> {[%#sghost'9] inv'25 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  let rec as_ref'0 (self_: t_Rc'0) (return' (x: t_PCell)) = any
    [ return''0 (result: t_PCell) -> {inv'21 result} {[%#src] result = view'9 self_} (! return' {result}) ]
  
  function view'11 (self: t_PCellOwn) : t_Inner = [%#spcell'6] val' self
  
  function view'12 (self: t_PCellOwn) : t_Inner = [%#smodel] view'11 self
  
  function view'13 (self: t_PCellOwn) : t_Inner = [%#sghost] view'12 self
  
  let rec borrow'0 (self: t_PCell) (perm: t_PCellOwn) (return' (x: t_Inner)) =
    {[@expl:borrow 'self' type invariant] [%#spcell'1] inv'21 self}
    {[@expl:borrow 'perm' type invariant] [%#spcell'2] inv'25 perm}
    {[@expl:borrow requires] [%#spcell'3] id'2 self = id'1 perm}
    any
    [ return''0 (result: t_Inner) -> {[%#spcell'4] inv'5 result}
      {[%#spcell'5] result = view'13 perm}
      (! return' {result}) ]
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate invariant''19 (self: t_Vec) = [%#sinvariant] inv'3 self
  
  predicate inv'26 (_0'0: t_Vec)
  
  axiom inv_axiom'25 [@rewrite]: forall x: t_Vec [inv'26 x]. inv'26 x = invariant''19 x
  
  predicate invariant''20 (self: Slice64.slice t_T) = [%#sslice'4] inv'2 (Slice64.view self)
  
  predicate inv'27 (_0'0: Slice64.slice t_T)
  
  axiom inv_axiom'26 [@rewrite]: forall x: Slice64.slice t_T [inv'27 x]. inv'27 x = invariant''20 x
  
  predicate invariant''21 (self: Slice64.slice t_T) = [%#sinvariant] inv'27 self
  
  predicate inv'28 (_0'0: Slice64.slice t_T)
  
  axiom inv_axiom'27 [@rewrite]: forall x: Slice64.slice t_T [inv'28 x]. inv'28 x = invariant''21 x
  
  function view'14 (self: Slice64.slice t_T) : Seq.seq t_T = [%#smodel] Slice64.view self
  
  function view'15 (self: t_Vec) : Seq.seq t_T = [%#smodel] view'2 self
  
  let rec deref'3 (self_: t_Vec) (return' (x: Slice64.slice t_T)) =
    {[@expl:deref 'self_' type invariant] [%#svec] inv'26 self_}
    any
    [ return''0 (result: Slice64.slice t_T) -> {inv'28 result}
      {[%#svec'0] view'14 result = view'15 self_}
      (! return' {result}) ]
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice'2] UInt64.t'int self < Seq.length seq
  
  predicate invariant''22 (self: t_T) = [%#sinvariant] inv'0 self
  
  predicate inv'29 (_0'0: t_T)
  
  axiom inv_axiom'28 [@rewrite]: forall x: t_T [inv'29 x]. inv'29 x = invariant''22 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'3] Seq.get seq (UInt64.t'int self) = out
  
  let rec get_unchecked (self_: Slice64.slice t_T) (ix: UInt64.t) (return' (x: t_T)) =
    {[@expl:get_unchecked 'self_' type invariant] [%#sslice] inv'28 self_}
    {[@expl:get_unchecked requires] [%#sslice'0] in_bounds ix (view'14 self_)}
    any
    [ return''0 (result: t_T) -> {inv'29 result}
      {[%#sslice'1] has_value ix (view'14 self_) result}
      (! return' {result}) ]
  
  function view'16 (self: t_Fragment) : tuple = [%#sboxed] view'7 self
  
  function view'17 (self: t_Rc'1) : t_Fragment = [%#sghost] view'3 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''23 [#"persistent_array.rs" 56 8 56 34] (self: t_PersistentArray) =
    [%#spersistent_array'19] (view'16 (view'17 self.t_PersistentArray__contained_in_inv))._p0
      = id'2 (view'9 self.t_PersistentArray__program_value)
    /\ id'0 (view'17 self.t_PersistentArray__contained_in_inv) = public (view'0 self.t_PersistentArray__map_invariant)
    /\ namespace (view'0 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv'30 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'29 [@rewrite]: forall x: t_PersistentArray [inv'30 x]. inv'30 x
      = (invariant''23 x
      /\ match x with
        | {t_PersistentArray__program_value = program_value; t_PersistentArray__contained_in_inv = contained_in_inv; t_PersistentArray__map_invariant = map_invariant} -> true
        end)
  
  predicate invariant''24 (self: t_PersistentArray) = [%#sinvariant] inv'30 self
  
  predicate inv'31 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'30 [@rewrite]: forall x: t_PersistentArray [inv'31 x]. inv'31 x = invariant''24 x
  
  predicate invariant''25 (self: t_PersistentArray) = [%#sinvariant] inv'31 self
  
  predicate inv'32 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'31 [@rewrite]: forall x: t_PersistentArray [inv'32 x]. inv'32 x = invariant''25 x
  
  predicate inv'33 (_0'0: closure0)
  
  axiom inv_axiom'32 [@rewrite]: forall x: closure0 [inv'33 x]. inv'33 x
      = (let {_0 = x0; _1 = x1; _2 = x2} = x in inv'32 x0)
  
  let rec closure0 [#"persistent_array.rs" 261 53 261 62] [@coma:extspec] (self: closure0) (inv'34: MutBorrow.t t_PA)
    (return' (x: t_T)) = bb0
    [ bb0 = s0 [ s0 = deref {inv'35} (fun (_ret: MutBorrow.t t_PA) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = deref'0 {(_1'0._0).t_PersistentArray__contained_in_inv} (fun (_ret: t_Rc'1) -> [ &_12 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0 [ s0 = as_ref {_12} (fun (_ret: t_Fragment) -> [ &_10 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = contains'0 {(_7.current).t_PA__auth} {_10} (fun (_ret: ()) -> [ &_5 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_4} (fun (_ret: ()) -> [ &_3 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_16 <- (_1'0._0).t_PersistentArray__program_value ] s1
      | s1 = {inv'11 inv'35}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {inv'35}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_23 <- _ret ] -{inv'11 _ret.final}-
            [ &inv'35 <- _ret.final ] s2)
      | s2 = deref_mut {_23} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_22 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = {inv'10 _22.current}
        MutBorrow.borrow_final <MutBorrow.t t_PA> {_22.current} {MutBorrow.get_id _22}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_21 <- _ret ] -{inv'10 _ret.final}-
            [ &_22 <- { _22 with current = _ret.final } ] s1)
      | s1 = {inv'9 (_21.current).current}
        MutBorrow.borrow_mut <t_PA> {(_21.current).current}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_20 <- _ret ] -{inv'9 _ret.final}-
            [ &_21 <- { _21 with current = { _21.current with current = _ret.final } } ] s2)
      | s2 = {[@expl:type invariant] inv'18 _22} s3
      | s3 = -{resolve'0 _22}- s4
      | s4 = {[@expl:type invariant] inv'18 _21} s5
      | s5 = -{resolve'0 _21}- s6
      | s6 = {inv'9 _20.current}
        MutBorrow.borrow_final <t_PA> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_19 <- _ret ] -{inv'9 _ret.final}-
            [ &_20 <- { _20 with current = _ret.final } ] s7)
      | s7 = new'0 {_19} (fun (_ret: MutBorrow.t t_PA) -> [ &_18 <- _ret ] s8)
      | s8 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'10 _20} s1
      | s1 = -{resolve'2 _20}- s2
      | s2 = reroot {_16} {_1'0._1} {_18} (fun (_ret: int) -> [ &_14 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = s0
      [ s0 = deref'1 {(_1'0._0).t_PersistentArray__program_value} (fun (_ret: t_PCell) -> [ &_26 <- _ret ] s1)
      | s1 = bb9 ]
    | bb9 = s0 [ s0 = id_ghost {_26} (fun (_ret: t_Id) -> [ &id'3 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = into_inner {inv'35} (fun (_ret: MutBorrow.t t_PA) -> [ &_32 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0 [ s0 = deref'2 {id'3} (fun (_ret: t_Id) -> [ &_36 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = [ &_35 <- _36 ] s1
      | s1 = get_ghost {(_32.current).t_PA__permissions} {_35} (fun (_ret: t_Option'1) -> [ &_30 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0 [ s0 = unwrap {_30} (fun (_ret: t_PCellOwn) -> [ &_29 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'10 _32} s1
      | s1 = -{resolve'2 _32}- s2
      | s2 = new'1 {_29} (fun (_ret: t_PCellOwn) -> [ &perm <- _ret ] s3)
      | s3 = bb15 ]
    | bb15 = s0
      [ s0 = as_ref'0 {(_1'0._0).t_PersistentArray__program_value} (fun (_ret: t_PCell) -> [ &_40 <- _ret ] s1)
      | s1 = bb16 ]
    | bb16 = s0 [ s0 = borrow'0 {_40} {perm} (fun (_ret: t_Inner) -> [ &borrow'1 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = any
      [ br0 (x0: t_Vec) -> {borrow'1 = C_Direct x0} (! bb20)
      | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc'0) -> {borrow'1 = C_Link x0 x1 x2} (! bb18) ]
    | bb18 = {false} any
    | bb20 = s0
      [ s0 = v_Direct {borrow'1} (fun (r0: t_Vec) -> [ &arr <- r0 ] s1)
      | s1 = deref'3 {arr} (fun (_ret: Slice64.slice t_T) -> [ &_46 <- _ret ] s2)
      | s2 = bb21 ]
    | bb21 = s0 [ s0 = get_unchecked {_46} {_1'0._2} (fun (_ret: t_T) -> [ &_0'0 <- _ret ] s1) | s1 = bb22 ]
    | bb22 = return' {_0'0} ]
    [ & _0'0: t_T = Any.any_l ()
    | & _1'0: closure0 = self
    | & inv'35: MutBorrow.t t_PA = inv'34
    | & _3: () = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _5: () = Any.any_l ()
    | & _7: MutBorrow.t t_PA = Any.any_l ()
    | & _10: t_Fragment = Any.any_l ()
    | & _12: t_Rc'1 = Any.any_l ()
    | & _14: int = Any.any_l ()
    | & _16: t_Rc'0 = Any.any_l ()
    | & _18: MutBorrow.t t_PA = Any.any_l ()
    | & _19: MutBorrow.t t_PA = Any.any_l ()
    | & _20: MutBorrow.t t_PA = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _22: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _23: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & id'3: t_Id = Any.any_l ()
    | & _26: t_PCell = Any.any_l ()
    | & perm: t_PCellOwn = Any.any_l ()
    | & _29: t_PCellOwn = Any.any_l ()
    | & _30: t_Option'1 = Any.any_l ()
    | & _32: MutBorrow.t t_PA = Any.any_l ()
    | & _35: t_Id = Any.any_l ()
    | & _36: t_Id = Any.any_l ()
    | & borrow'1: t_Inner = Any.any_l ()
    | & _40: t_PCell = Any.any_l ()
    | & arr: t_Vec = Any.any_l ()
    | & _46: Slice64.slice t_T = Any.any_l () ]
  
  type t_Tokens
  
  predicate precondition (self: ()) (args: t_Rc) = let self_ = args in true
  
  let rec deref'4 (self_: t_Rc) (return' (x: t_LocalInvariant)) = any
    [ return''0 (result: t_LocalInvariant) -> {[%#src'0] result = view self_} (! return' {result}) ]
  
  predicate postcondition_once (self: ()) (args: t_Rc) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  predicate resolve'3 (_0'0: ()) = true
  
  predicate postcondition_mut (self: ()) (args: t_Rc) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  function fn_mut_once (self: ()) (args: t_Rc) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec:
    forall self: (), args: t_Rc, res: t_LocalInvariant. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'3 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) = true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Rc, res_state: (), res: t_LocalInvariant. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_Rc) (result: t_LocalInvariant) = let self_ = args in result = view self_
  
  function fn_once (self: ()) (args: t_Rc) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc, res: t_LocalInvariant. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve'3 self)
  
  function fn_mut (self: ()) (args: t_Rc) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Rc, res_state: (), res: t_LocalInvariant. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  type tuple'0 = { _p0'0: t_LocalInvariant; _p1'0: t_Tokens; _p2: closure0 }
  
  predicate precondition'0 (self: closure0) (args: MutBorrow.t t_PA) =
    [%#spersistent_array'5] let inv'34 = args in closure0'pre self inv'34
  
  predicate postcondition_once'0 (self: closure0) (args: MutBorrow.t t_PA) (result: t_T) =
    [%#spersistent_array'5] let inv'34 = args in closure0'post'return' self inv'34 result
  
  function fin (self: MutBorrow.t t_PA) : t_PA = [%#sghost'14] self.final
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = [%#sset] Set.mem e self
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'3 (self: t_Tokens) (namespace'0: t_Namespace) =
    [%#slocal_invariant'4] contains'2 (namespaces self) namespace'0
  
  predicate precondition'1 (self: ()) (args: tuple'0) =
    [%#slocal_invariant'5] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (forall t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
          /\ inv'11 t
        -> precondition'0 f t
        /\ (forall res: t_T. postcondition_once'0 f t res -> invariant_with_data (fin t) (public self'0)))
    /\ contains'3 tokens (namespace self'0) /\ inv'33 f
  
  let rec open (self: t_LocalInvariant) (tokens: t_Tokens) (f: closure0) (return' (x: t_T)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant'6] inv'33 f}
    {[@expl:open requires #0] [%#slocal_invariant'7] contains'3 tokens (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'8] forall t: MutBorrow.t t_PA. invariant_with_data t.current (public self)
        /\ inv'11 t
      -> precondition'0 f t
      /\ (forall res: t_T. postcondition_once'0 f t res -> invariant_with_data (fin t) (public self))}
    any
    [ return''0 (result: t_T) -> {[%#slocal_invariant'5] inv'29 result}
      {[%#slocal_invariant'9] exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self)
        /\ postcondition_once'0 f t result}
      (! return' {result}) ]
  
  function new_logic (x: t_LocalInvariant) : t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. [%#sghost'13] new_logic x = x
  
  predicate postcondition_once'1 (self: ()) (args: tuple'0) (result: t_T) =
    [%#slocal_invariant'5] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'29 result
  
  predicate resolve'4 (_0'0: ()) = true
  
  predicate postcondition_mut'0 (self: ()) (args: tuple'0) (result_state: ()) (result: t_T) =
    [%#slocal_invariant'5] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'29 result
  
  function fn_mut_once'0 (self: ()) (args: tuple'0) (res: t_T) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'0, res: t_T. [%#sops'8] postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'4 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) = true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
      -> ([%#sops'6] hist_inv'0 b c) -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'0) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: tuple'0, res_state: (), res: t_T. ([%#sops'2] postcondition_mut'0 self args res_state res)
      -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple'0) (result: t_T) =
    [%#slocal_invariant'5] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists t: MutBorrow.t t_PA. invariant_with_data t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'29 result
  
  function fn_once'0 (self: ()) (args: tuple'0) (res: t_T) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'0, res: t_T. [%#sops'0] postcondition_once'1 self args res
      = (postcondition'0 self args res /\ resolve'4 self)
  
  function fn_mut'0 (self: ()) (args: tuple'0) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: tuple'0, res_state: (), res: t_T. [%#sops] postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc) (tokens: t_Tokens) (f: closure0) (return' (x: t_T)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant] inv'33 f}
    {[@expl:open requires #0] [%#slocal_invariant'0] precondition () self}
    {[@expl:open requires #1] [%#slocal_invariant'1] forall this: t_LocalInvariant. postcondition () self this
      -> precondition'1 () { _p0'0 = new_logic this; _p1'0 = tokens; _p2 = f }}
    any
    [ return''0 (result: t_T) -> {[%#slocal_invariant'2] inv'29 result}
      {[%#slocal_invariant'3] exists this: t_LocalInvariant. postcondition () self this
        /\ postcondition'0 () { _p0'0 = new_logic this; _p1'0 = tokens; _p2 = f } result}
      (! return' {result}) ]
  
  function view'18 [#"persistent_array.rs" 74 8 74 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'17] (view'16 (view'17 self.t_PersistentArray__contained_in_inv))._p1
  
  function view'19 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'18 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get'1 [#"persistent_array.rs" 259 8 259 89] (self: t_PersistentArray) (index: UInt64.t) (tokens: t_Tokens)
    (return' (x: t_T)) = {[@expl:get 'self' type invariant] [%#spersistent_array'0] inv'31 self}
    {[@expl:get requires #0] [%#spersistent_array'1] contains'3 tokens (Namespace_PARRAY_0'62 0)}
    {[@expl:get requires #1] [%#spersistent_array'2] UInt64.t'int index < Seq.length (view'19 self)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &public'0 <- [%#spersistent_array] public (view'0 self'0.t_PersistentArray__map_invariant) ] s1
      | s1 = bb1 ]
    | bb1 = s0
      [ s0 = borrow {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc) -> [ &_10 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_13 <- { _0 = self'0; _1 = public'0; _2 = index'0 } ] s1
      | s1 = open'0 {_10} {tokens'0} {_13} (fun (_ret: t_T) -> [ &_9 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0'0 <- _9 ] s1 | s1 = return''0 {_0'0} ] ]
    [ & _0'0: t_T = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & index'0: UInt64.t = index
    | & tokens'0: t_Tokens = tokens
    | & public'0: t_Id = Any.any_l ()
    | & _9: t_T = Any.any_l ()
    | & _10: t_Rc = Any.any_l ()
    | & _13: closure0 = Any.any_l () ])
    [ return''0 (result: t_T) -> {[@expl:get result type invariant] [%#spersistent_array'3] inv'29 result}
      {[@expl:get ensures] [%#spersistent_array'4] result = Seq.get (view'19 self) (UInt64.t'int index)}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__reroot [#"persistent_array.rs" 298 8 302 26] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 45 18 45 37
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span src'1 = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span spersistent_array = "persistent_array.rs" 305 23 305 51
  let%span spersistent_array'0 = "persistent_array.rs" 334 40 334 79
  let%span spersistent_array'1 = "persistent_array.rs" 335 48 335 84
  let%span spersistent_array'2 = "persistent_array.rs" 310 20 310 44
  let%span spersistent_array'3 = "persistent_array.rs" 301 16 301 19
  let%span spersistent_array'4 = "persistent_array.rs" 283 8 283 59
  let%span spersistent_array'5 = "persistent_array.rs" 284 19 284 50
  let%span spersistent_array'6 = "persistent_array.rs" 285 18 285 73
  let%span spersistent_array'7 = "persistent_array.rs" 286 18 286 97
  let%span spersistent_array'8 = "persistent_array.rs" 287 18 287 58
  let%span spersistent_array'9 = "persistent_array.rs" 288 18 288 62
  let%span spersistent_array'10 = "persistent_array.rs" 289 18 291 85
  let%span spersistent_array'11 = "persistent_array.rs" 293 18 296 9
  let%span spersistent_array'12 = "persistent_array.rs" 297 18 297 67
  let%span spersistent_array'13 = "persistent_array.rs" 102 16 117 21
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 70 14 70 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 70 4 70 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 69 14 69 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 175 15 175 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 175 4 177 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 81 22 81 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 81 4 81 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 224 17 224 21
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 224 4 224 46
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 222 14 222 36
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 223 14 223 36
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 91 8 91 22
  let%span sghost'13 = "../../creusot-contracts/src/ghost.rs" 101 20 101 27
  let%span sghost'14 = "../../creusot-contracts/src/ghost.rs" 119 8 119 22
  let%span sghost'15 = "../../creusot-contracts/src/ghost.rs" 111 8 111 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 63 8 63 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 185 16 185 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 186 16 186 48
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 187 16 187 56
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 188 16 188 59
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 189 16 189 64
  let%span svec'4 = "../../creusot-contracts/src/std/vec.rs" 190 26 190 55
  let%span svec'5 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'6 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 228 21 228 25
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 227 14 227 34
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 169 33 169 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 169 39 169 43
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 167 15 167 37
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 169 4 169 77
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 168 14 168 30
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 191 37 191 41
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 191 43 191 47
  let%span spcell'8 = "../../creusot-contracts/src/pcell.rs" 187 15 187 37
  let%span spcell'9 = "../../creusot-contracts/src/pcell.rs" 191 4 191 89
  let%span spcell'10 = "../../creusot-contracts/src/pcell.rs" 188 14 188 39
  let%span spcell'11 = "../../creusot-contracts/src/pcell.rs" 189 14 189 30
  let%span spcell'12 = "../../creusot-contracts/src/pcell.rs" 190 14 190 33
  let%span spcell'13 = "../../creusot-contracts/src/pcell.rs" 30 4 30 12
  let%span spcell'14 = "../../creusot-contracts/src/pcell.rs" 58 20 58 46
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 354 22 354 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 354 4 354 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 353 14 353 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 417 32 417 36
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 414 4 414 36
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 417 4 417 69
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 415 14 415 47
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 416 14 416 85
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 387 30 387 34
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 387 4 387 62
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 384 9
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 385 14 385 73
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 386 14 386 44
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 85 14 85 43
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 86 14 86 84
  let%span sfmap'17 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'19 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'20 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'21 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 50 20 50 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 37 8 37 42
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 686 20 686 91
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 118 20 118 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 125 20 125 37
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 132 20 132 88
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  use creusot.prelude.MutBorrow
  use int.MinMax
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'0; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell = { t_UnsafeCell__value: t_Inner }
  
  type t_PCell = { t_PCell__0: t_UnsafeCell }
  
  function view (self: t_Rc) : t_PCell
  
  let rec clone' (self_: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src] view result = view self_} (! return' {result}) ]
  
  predicate inv (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv self
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  predicate inv'1 (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'0 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'5] Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'6] inv'1 (view'0 self)
  
  predicate inv'2 (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
      = match x with
        | C_Direct a_0 -> inv'2 a_0
        | C_Link index value next -> inv value
        end
  
  predicate inv'4 (_0: t_UnsafeCell)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnsafeCell [inv'4 x]. inv'4 x
      = match x with
        | {t_UnsafeCell__value = value} -> inv'3 value
        end
  
  predicate inv'5 (_0: t_PCell)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PCell [inv'5 x]. inv'5 x
      = match x with
        | {t_PCell__0 = a_0} -> inv'4 a_0
        end
  
  predicate invariant''2 (self: t_PCell) = [%#sinvariant'0] inv'5 self
  
  predicate inv'6 (_0: t_PCell)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PCell [inv'6 x]. inv'6 x = invariant''2 x
  
  let rec deref (self_: t_Rc) (return' (x: t_PCell)) = any
    [ return''0 (result: t_PCell) -> {inv'6 result} {[%#src'0] result = view self_} (! return' {result}) ]
  
  type t_Id
  
  function id (self: t_PCell) : t_Id
  
  let rec id_ghost (self: t_PCell) (return' (x: t_Id)) = {[@expl:id_ghost 'self' type invariant] [%#spcell] inv'6 self}
    any [ return''0 (result: t_Id) -> {[%#spcell'0] result = id self} (! return' {result}) ]
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__permissions: t_FMap; t_PA__auth: t_Authority; t_PA__rank: Map.map t_Id int; t_PA__length: int }
  
  type t_PCellOwn = { t_PCellOwn__0: () }
  
  type t_Option = C_None | C_Some t_PCellOwn
  
  function view'1 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'13] Map.get (view'1 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'12] get self k <> C_None
  
  predicate inv'7 (_0: t_Id)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Id [inv'7 x]. inv'7 x = true
  
  predicate invariant''3 (self: t_Inner) = [%#sinvariant'0] inv'3 self
  
  predicate inv'8 (_0: t_Inner)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Inner [inv'8 x]. inv'8 x = invariant''3 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''4 (self: t_PCellOwn) = [%#spcell'14] inv'8 (val' self)
  
  predicate inv'9 (_0: t_PCellOwn)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PCellOwn [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
      -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn = [%#sfmap'20] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn = [%#sfmap'14] lookup self key
  
  predicate invariant''5 (self: t_FMap) =
    [%#sfmap'21] forall k: t_Id. contains self k -> inv'7 k /\ inv'9 (index_logic'0 self k)
  
  predicate inv'10 (_0: t_FMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_FMap [inv'10 x]. inv'10 x = invariant''5 x
  
  predicate invariant''6 (self: t_Authority)
  
  predicate inv'11 (_0: t_Authority)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Authority [inv'11 x]. inv'11 x
      = (invariant''6 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'12 (_0: t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PA [inv'12 x]. inv'12 x
      = match x with
        | {t_PA__permissions = permissions; t_PA__auth = auth; t_PA__rank = rank; t_PA__length = length} -> inv'10 permissions
        /\ inv'11 auth
        end
  
  predicate invariant''7 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'13 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_PA [inv'13 x]. inv'13 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t t_PA) = [%#sghost'15] inv'13 self
  
  predicate inv'14 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_PA [inv'14 x]. inv'14 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_PA) = [%#sinvariant'0] inv'14 self
  
  predicate inv'15 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_PA [inv'15 x]. inv'15 x = invariant''9 x
  
  predicate invariant''10 (self: MutBorrow.t t_PA) = [%#sinvariant'0] inv'13 self
  
  predicate inv'16 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_PA [inv'16 x]. inv'16 x = invariant''10 x
  
  let rec deref'0 (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:deref 'self' type invariant] [%#sghost] inv'15 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'0] inv'16 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  let rec deref'1 (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PCellOwn
  
  predicate invariant''11 (self: t_FMap) = [%#sinvariant'0] inv'10 self
  
  predicate inv'17 (_0: t_FMap)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_FMap [inv'17 x]. inv'17 x = invariant''11 x
  
  predicate invariant''12 (self: t_PCellOwn) = [%#sinvariant'0] inv'9 self
  
  predicate inv'18 (_0: t_PCellOwn)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_PCellOwn [inv'18 x]. inv'18 x = invariant''12 x
  
  predicate inv'19 (_0: t_Option'0)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_Option'0 [inv'19 x]. inv'19 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'18 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PCellOwn t_PCellOwn) : t_Option'0 = [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Id) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'17 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'19 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PCellOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_PCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'19 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any
    [ return''0 (result: t_PCellOwn) -> {inv'18 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  predicate invariant''13 (self: t_PCellOwn) = [%#sghost'15] inv'18 self
  
  predicate inv'20 (_0: t_PCellOwn)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PCellOwn [inv'20 x]. inv'20 x = invariant''13 x
  
  let rec new (x: t_PCellOwn) (return' (x'0: t_PCellOwn)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'18 x}
    any
    [ return''0 (result: t_PCellOwn) -> {[%#sghost'3] inv'20 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  let rec as_ref (self_: t_Rc) (return' (x: t_PCell)) = any
    [ return''0 (result: t_PCell) -> {inv'6 result} {[%#src'1] result = view self_} (! return' {result}) ]
  
  function id'0 (self: t_PCellOwn) : t_Id
  
  function view'2 (self: t_PCellOwn) : t_Inner = [%#spcell'13] val' self
  
  function view'3 (self: t_PCellOwn) : t_Inner = [%#smodel] view'2 self
  
  function view'4 (self: t_PCellOwn) : t_Inner = [%#sghost'12] view'3 self
  
  let rec borrow (self: t_PCell) (perm: t_PCellOwn) (return' (x: t_Inner)) =
    {[@expl:borrow 'self' type invariant] [%#spcell'1] inv'6 self}
    {[@expl:borrow 'perm' type invariant] [%#spcell'2] inv'20 perm}
    {[@expl:borrow requires] [%#spcell'3] id self = id'0 perm}
    any
    [ return''0 (result: t_Inner) -> {[%#spcell'4] inv'8 result}
      {[%#spcell'5] result = view'4 perm}
      (! return' {result}) ]
  
  let rec v_Link (input: t_Inner) (ret (index: UInt64.t) (value: t_T) (next: t_Rc)) = any
    [ good (index: UInt64.t) (value: t_T) (next: t_Rc) -> {C_Link index value next = input}
      (! ret {index} {value} {next})
    | bad -> {forall index: UInt64.t, value: t_T, next: t_Rc [C_Link index value next: t_Inner]. C_Link index value next
        <> input}
      (! {false}
      any) ]
  
  predicate invariant''14 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant] inv'14 self.current /\ inv'14 self.final
  
  predicate inv'21 (_0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'21 x]. inv'21 x = invariant''14 x
  
  predicate invariant''15 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant] inv'13 self.current /\ inv'13 self.final
  
  predicate inv'22 (_0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'22 x]. inv'22 x = invariant''15 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return' (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'21 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_PA)) -> {[%#sghost'6] inv'22 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_PA)) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t (MutBorrow.t t_PA)) = resolve _0
  
  let rec new'0 (x: MutBorrow.t t_PA) (return' (x'0: MutBorrow.t t_PA)) =
    {[@expl:new 'x' type invariant] [%#sghost'2] inv'13 x}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'3] inv'14 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  predicate resolve'1 (self: MutBorrow.t t_PA) = [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_PA) = resolve'1 _0
  
  type tuple = { _p0: MutBorrow.t t_PCellOwn; _p1: MutBorrow.t t_FMap }
  
  predicate invariant''16 (self: MutBorrow.t t_FMap) = [%#sinvariant] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'23 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'23 x]. inv'23 x = invariant''16 x
  
  predicate invariant''17 (self: MutBorrow.t t_PCellOwn) = [%#sinvariant] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'24 (_0: MutBorrow.t t_PCellOwn)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_PCellOwn [inv'24 x]. inv'24 x = invariant''17 x
  
  predicate inv'25 (_0: tuple)
  
  axiom inv_axiom'24 [@rewrite]: forall x: tuple [inv'25 x]. inv'25 x
      = (let {_p0 = x0; _p1 = x1} = x in inv'24 x0 /\ inv'23 x1)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'19] len self >= 0
  
  function remove (self: t_FMap) (k: t_Id) : t_FMap
  
  axiom remove_spec: forall self: t_FMap, k: t_Id. [%#sfmap'15] view'1 (remove self k)
      = Map.set (view'1 self) k (C_None)
  
  axiom remove_spec'0: forall self: t_FMap, k: t_Id. [%#sfmap'16] len (remove self k)
      = (if contains self k then len self - 1 else len self)
  
  function insert (self: t_FMap) (k: t_Id) (v: t_PCellOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: t_PCellOwn. [%#sfmap'17] view'1 (insert self k v)
      = Map.set (view'1 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: t_PCellOwn. [%#sfmap'18] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec split_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return' (x: tuple)) =
    {[@expl:split_mut_ghost 'self' type invariant] [%#sfmap'2] inv'23 self}
    {[@expl:split_mut_ghost requires] [%#sfmap'3] contains self.current key}
    any
    [ return''0 (result: tuple) -> {[%#sfmap'4] inv'25 result}
      {[%#sfmap'5] (result._p1).current = remove self.current key}
      {[%#sfmap'6] index_logic'0 self.current key = (result._p0).current
      /\ self.final = insert (result._p1).final key (result._p0).final}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_PCellOwn)
  
  predicate inv'26 (_0: t_Option'1)
  
  axiom inv_axiom'25 [@rewrite]: forall x: t_Option'1 [inv'26 x]. inv'26 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'24 a_0
        end
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return' (x: t_Option'1)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'7] inv'23 self}
    any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'8] inv'26 result}
      {[%#sfmap'9] if contains self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'10] forall k: t_Id. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'11] len self.current = len self.final}
      (! return' {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return' (x: MutBorrow.t t_PCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'26 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result: MutBorrow.t t_PCellOwn) -> {inv'24 result}
      {[%#soption'1] C_Some'1 result = self_}
      (! return' {result}) ]
  
  type tuple'0 = { _p0'0: MutBorrow.t t_PCellOwn; _p1'0: MutBorrow.t t_PCellOwn }
  
  predicate resolve'3 (self: MutBorrow.t t_FMap) = [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_FMap) = resolve'3 _0
  
  predicate inv'27 (_0: tuple'0)
  
  axiom inv_axiom'26 [@rewrite]: forall x: tuple'0 [inv'27 x]. inv'27 x
      = (let {_p0'0 = x0; _p1'0 = x1} = x in inv'24 x0 /\ inv'24 x1)
  
  predicate invariant''18 (self: tuple'0) = [%#sghost'15] inv'27 self
  
  predicate inv'28 (_0: tuple'0)
  
  axiom inv_axiom'27 [@rewrite]: forall x: tuple'0 [inv'28 x]. inv'28 x = invariant''18 x
  
  let rec new'1 (x: tuple'0) (return' (x'0: tuple'0)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'27 x}
    any [ return''0 (result: tuple'0) -> {[%#sghost'3] inv'28 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  type tuple'1 = { _p0'1: MutBorrow.t t_PCellOwn; _p1'1: MutBorrow.t t_PCellOwn }
  
  predicate invariant''19 (self: MutBorrow.t t_PCellOwn) = [%#sghost'15] inv'24 self
  
  predicate inv'29 (_0: MutBorrow.t t_PCellOwn)
  
  axiom inv_axiom'28 [@rewrite]: forall x: MutBorrow.t t_PCellOwn [inv'29 x]. inv'29 x = invariant''19 x
  
  predicate inv'30 (_0: tuple'1)
  
  axiom inv_axiom'29 [@rewrite]: forall x: tuple'1 [inv'30 x]. inv'30 x
      = (let {_p0'1 = x0; _p1'1 = x1} = x in inv'29 x0 /\ inv'29 x1)
  
  let rec split (self: tuple'0) (return' (x: tuple'1)) = {[@expl:split 'self' type invariant] [%#sghost'8] inv'28 self}
    any
    [ return''0 (result: tuple'1) -> {[%#sghost'9] inv'30 result}
      {[%#sghost'10] self._p0'0 = result._p0'1}
      {[%#sghost'11] self._p1'0 = result._p1'1}
      (! return' {result}) ]
  
  predicate invariant''20 (self: MutBorrow.t t_Inner) = [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'31 (_0: MutBorrow.t t_Inner)
  
  axiom inv_axiom'30 [@rewrite]: forall x: MutBorrow.t t_Inner [inv'31 x]. inv'31 x = invariant''20 x
  
  function fin (self: MutBorrow.t t_PCellOwn) : t_PCellOwn = [%#sghost'13] self.final
  
  function view'5 (self: MutBorrow.t t_PCellOwn) : t_Inner = [%#smodel'0] view'2 self.current
  
  function view'6 (self: MutBorrow.t t_PCellOwn) : t_Inner = [%#sghost'12] view'5 self
  
  let rec borrow_mut (self: t_PCell) (perm: MutBorrow.t t_PCellOwn) (return' (x: MutBorrow.t t_Inner)) =
    {[@expl:borrow_mut 'self' type invariant] [%#spcell'6] inv'6 self}
    {[@expl:borrow_mut 'perm' type invariant] [%#spcell'7] inv'29 perm}
    {[@expl:borrow_mut requires] [%#spcell'8] id self = id'0 perm.current}
    any
    [ return''0 (result: MutBorrow.t t_Inner) -> {[%#spcell'9] inv'31 result}
      {[%#spcell'10] id self = id'0 (fin perm)}
      {[%#spcell'11] result.current = view'6 perm}
      {[%#spcell'12] result.final = view'2 (fin perm)}
      (! return' {result}) ]
  
  type tuple'2 = { _p0'2: MutBorrow.t t_Inner; _p1'2: MutBorrow.t t_Inner }
  
  let rec swap (x: MutBorrow.t t_Inner) (y: MutBorrow.t t_Inner) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem] inv'31 x}
    {[@expl:swap 'y' type invariant] [%#smem'0] inv'31 y}
    any
    [ return''0 (result: ()) -> {[%#smem'1] x.final = y.current} {[%#smem'2] y.final = x.current} (! return' {result}) ]
  
  predicate inv'32 (_0: tuple'2)
  
  axiom inv_axiom'31 [@rewrite]: forall x: tuple'2 [inv'32 x]. inv'32 x
      = (let {_p0'2 = x0; _p1'2 = x1} = x in inv'31 x0 /\ inv'31 x1)
  
  predicate resolve'5 (self: MutBorrow.t t_Inner) = [%#sresolve] self.final = self.current
  
  predicate resolve'6 (_0: MutBorrow.t t_Inner) = resolve'5 _0
  
  predicate resolve'7 (self: tuple'2) = [%#sresolve'0] resolve'6 self._p0'2 /\ resolve'6 self._p1'2
  
  predicate resolve'8 (_0: tuple'2) = resolve'7 _0
  
  predicate resolve'9 (self: MutBorrow.t t_PA) = [%#sghost'14] resolve'2 self
  
  predicate resolve'10 (_0: MutBorrow.t t_PA) = resolve'9 _0
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate resolve'11 (self: MutBorrow.t t_Rc) = [%#sresolve] self.final = self.current
  
  predicate resolve'12 (_0: MutBorrow.t t_Rc) = resolve'11 _0
  
  predicate resolve'13 (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  predicate resolve'14 (_0: MutBorrow.t UInt64.t) = resolve'13 _0
  
  predicate invariant''21 (self: MutBorrow.t t_Vec) = [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'33 (_0: MutBorrow.t t_Vec)
  
  axiom inv_axiom'32 [@rewrite]: forall x: MutBorrow.t t_Vec [inv'33 x]. inv'33 x = invariant''21 x
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  function view'7 (self: MutBorrow.t t_Vec) : Seq.seq t_T = [%#smodel'0] view'0 self.current
  
  predicate invariant''22 (self: MutBorrow.t t_T) = [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'34 (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'33 [@rewrite]: forall x: MutBorrow.t t_T [inv'34 x]. inv'34 x = invariant''22 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_T) (fin'0: Seq.seq t_T) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
      -> Seq.get old' i = Seq.get fin'0 i
  
  let rec index_mut (self_: MutBorrow.t t_Vec) (ix: UInt64.t) (return' (x: MutBorrow.t t_T)) =
    {[@expl:index_mut 'self_' type invariant] [%#svec] inv'33 self_}
    {[@expl:index_mut requires] [%#svec'0] in_bounds ix (view'7 self_)}
    any
    [ return''0 (result: MutBorrow.t t_T) -> {inv'34 result}
      {[%#svec'1] has_value ix (view'7 self_) result.current}
      {[%#svec'2] has_value ix (view'0 self_.final) result.final}
      {[%#svec'3] resolve_elswhere ix (view'7 self_) (view'0 self_.final)}
      {[%#svec'4] Seq.length (view'0 self_.final) = Seq.length (view'7 self_)}
      (! return' {result}) ]
  
  let rec swap'0 (x: MutBorrow.t t_T) (y: MutBorrow.t t_T) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem] inv'34 x}
    {[@expl:swap 'y' type invariant] [%#smem'0] inv'34 y}
    any
    [ return''0 (result: ()) -> {[%#smem'1] x.final = y.current} {[%#smem'2] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'15 (self: MutBorrow.t t_T) = [%#sresolve] self.final = self.current
  
  predicate resolve'16 (_0: MutBorrow.t t_T) = resolve'15 _0
  
  predicate resolve'17 (self: MutBorrow.t t_Vec) = [%#sresolve] self.final = self.current
  
  predicate resolve'18 (_0: MutBorrow.t t_Vec) = resolve'17 _0
  
  let rec new'2 (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'4] result = x} (! return' {result}) ]
  
  function index_logic'1 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  function id'1 (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'2 = C_None'2 | C_Some'2 (Seq.seq t_T)
  
  function view'8 (self: t_FMap'0) : Map.map t_Id t_Option'2
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'2 = [%#sfmap'13] Map.get (view'8 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'12] get'0 self k <> C_None'2
  
  function view'9 (self: t_Authority) : t_FMap'0
  
  predicate index_logic'2 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'2 p x)
      -> ([%#sutil'0] index_logic'2 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'2) : Seq.seq t_T = [%#soption'4] match self with
      | C_Some'2 x -> x
      | C_None'2 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'20] unwrap_logic'0 (get'0 self k)
  
  function index_logic'3 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'14] lookup'0 self key
  
  predicate invariant_with_data [#"persistent_array.rs" 100 8 100 61] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'13] id'1 self.t_PA__auth = resource_id
    /\ (forall id'2: t_Id. contains'0 (view'9 self.t_PA__auth) id'2
      -> contains self.t_PA__permissions id'2
      /\ id'0 (index_logic'0 self.t_PA__permissions id'2) = id'2
      /\ Seq.length (index_logic'3 (view'9 self.t_PA__auth) id'2) = self.t_PA__length
      /\ match val' (index_logic'0 self.t_PA__permissions id'2) with
        | C_Direct v -> index_logic'3 (view'9 self.t_PA__auth) id'2 = view'0 v
        | C_Link index value next -> contains'0 (view'9 self.t_PA__auth) (id (view next))
        /\ index_logic'1 self.t_PA__rank id'2 > index_logic'1 self.t_PA__rank (id (view next))
        /\ UInt64.t'int index < self.t_PA__length
        /\ index_logic'3 (view'9 self.t_PA__auth) id'2
        = Seq.set (index_logic'3 (view'9 self.t_PA__auth) (id (view next))) (UInt64.t'int index) value
        end)
  
  function view'10 (self: t_Rc) : t_PCell = [%#smodel] view self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec reroot [#"persistent_array.rs" 298 8 302 26] (inner: t_Rc) (invariant_id: t_Id) (inv'35: MutBorrow.t t_PA)
    (return' (x: int)) = {[@expl:reroot 'inv' type invariant] [%#spersistent_array'3] inv'14 inv'35}
    {[@expl:reroot requires #0] [%#spersistent_array'4] invariant_with_data inv'35.current invariant_id}
    {[@expl:reroot requires #1] [%#spersistent_array'5] contains'0 (view'9 (inv'35.current).t_PA__auth) (id (view'10 inner))}
    (! bb0
    [ bb0 = s0 [ s0 = clone' {inner'0} (fun (_ret: t_Rc) -> [ &inner_clone <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref {inner'0} (fun (_ret: t_PCell) -> [ &_17 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = id_ghost {_17} (fun (_ret: t_Id) -> [ &id'2 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &rank <- [%#spersistent_array] Map.get (inv'36.current).t_PA__rank id'2 ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = deref'0 {inv'36} (fun (_ret: MutBorrow.t t_PA) -> [ &_25 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = deref'1 {id'2} (fun (_ret: t_Id) -> [ &_29 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_28 <- _29 ] s1
      | s1 = get_ghost {(_25.current).t_PA__permissions} {_28} (fun (_ret: t_Option'0) -> [ &_23 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0 [ s0 = unwrap {_23} (fun (_ret: t_PCellOwn) -> [ &_22 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = new {_22} (fun (_ret: t_PCellOwn) -> [ &perm <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0 [ s0 = as_ref {inner'0} (fun (_ret: t_PCell) -> [ &_33 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = borrow {_33} {perm} (fun (_ret: t_Inner) -> [ &borrow'0 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = any
      [ br0 (x0: t_Vec) -> {borrow'0 = C_Direct x0} (! bb15)
      | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {borrow'0 = C_Link x0 x1 x2} (! bb14) ]
    | bb14 = s0
      [ s0 = v_Link {borrow'0} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &next <- rnext ] s1)
      | s1 = clone' {next} (fun (_ret: t_Rc) -> [ &next'0 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = s0 [ s0 = deref {next'0} (fun (_ret: t_PCell) -> [ &_43 <- _ret ] s1) | s1 = bb18 ]
    | bb18 = s0 [ s0 = id_ghost {_43} (fun (_ret: t_Id) -> [ &next_id <- _ret ] s1) | s1 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_47 <- next'0 ] s1
      | s1 = {inv'14 inv'36}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {inv'36}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_54 <- _ret ] -{inv'14 _ret.final}-
            [ &inv'36 <- _ret.final ] s2)
      | s2 = deref_mut {_54} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_53 <- _ret ] s3)
      | s3 = bb20 ]
    | bb20 = s0
      [ s0 = {inv'13 _53.current}
        MutBorrow.borrow_final <MutBorrow.t t_PA> {_53.current} {MutBorrow.get_id _53}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_52 <- _ret ] -{inv'13 _ret.final}-
            [ &_53 <- { _53 with current = _ret.final } ] s1)
      | s1 = {inv'12 (_52.current).current}
        MutBorrow.borrow_mut <t_PA> {(_52.current).current}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_51 <- _ret ] -{inv'12 _ret.final}-
            [ &_52 <- { _52 with current = { _52.current with current = _ret.final } } ] s2)
      | s2 = {[@expl:type invariant] inv'22 _53} s3
      | s3 = -{resolve'0 _53}- s4
      | s4 = {[@expl:type invariant] inv'22 _52} s5
      | s5 = -{resolve'0 _52}- s6
      | s6 = {inv'12 _51.current}
        MutBorrow.borrow_final <t_PA> {_51.current} {MutBorrow.get_id _51}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_50 <- _ret ] -{inv'12 _ret.final}-
            [ &_51 <- { _51 with current = _ret.final } ] s7)
      | s7 = new'0 {_50} (fun (_ret: MutBorrow.t t_PA) -> [ &_49 <- _ret ] s8)
      | s8 = bb21 ]
    | bb21 = s0
      [ s0 = {[@expl:type invariant] inv'13 _51} s1
      | s1 = -{resolve'2 _51}- s2
      | s2 = reroot {_47} {invariant_id'0} {_49} (fun (_ret: int) -> [ &next_d <- _ret ] s3)
      | s3 = bb22 ]
    | bb22 = s0
      [ s0 = {inv'14 inv'36}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {inv'36}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_65 <- _ret ] -{inv'14 _ret.final}-
            [ &inv'36 <- _ret.final ] s1)
      | s1 = deref_mut {_65} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_64 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0 [ s0 = [ &_69 <- id'2 ] s1 | s1 = deref'1 {_69} (fun (_ret: t_Id) -> [ &_67 <- _ret ] s2) | s2 = bb24 ]
    | bb24 = s0
      [ s0 = {inv'10 ((_64.current).current).t_PA__permissions}
        MutBorrow.borrow_mut <t_FMap> {((_64.current).current).t_PA__permissions}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_63 <- _ret ] -{inv'10 _ret.final}-
            [ &_64 <- { _64 with current = { _64.current with current = { (_64.current).current with t_PA__permissions = _ret.final } } } ]
            s1)
      | s1 = split_mut_ghost {_63} {_67} (fun (_ret: tuple) -> [ &_62 <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0
      [ s0 = [ &p_inner <- _62._p0 ] s1
      | s1 = [ &rest <- _62._p1 ] s2
      | s2 = {[@expl:type invariant] inv'22 _64} s3
      | s3 = -{resolve'0 _64}- s4
      | s4 = deref'1 {next_id} (fun (_ret: t_Id) -> [ &_76 <- _ret ] s5)
      | s5 = bb26 ]
    | bb26 = s0
      [ s0 = [ &_75 <- _76 ] s1
      | s1 = {inv'10 rest.current}
        MutBorrow.borrow_final <t_FMap> {rest.current} {MutBorrow.get_id rest}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_73 <- _ret ] -{inv'10 _ret.final}-
            [ &rest <- { rest with current = _ret.final } ] s2)
      | s2 = get_mut_ghost {_73} {_75} (fun (_ret: t_Option'1) -> [ &_72 <- _ret ] s3)
      | s3 = bb27 ]
    | bb27 = s0 [ s0 = unwrap'0 {_72} (fun (_ret: MutBorrow.t t_PCellOwn) -> [ &_71 <- _ret ] s1) | s1 = bb28 ]
    | bb28 = s0
      [ s0 = [ &_59 <- { _p0'0 = p_inner; _p1'0 = _71 } ] s1
      | s1 = {[@expl:type invariant] inv'23 rest} s2
      | s2 = -{resolve'4 rest}- s3
      | s3 = new'1 {_59} (fun (_ret: tuple'0) -> [ &_58 <- _ret ] s4)
      | s4 = bb29 ]
    | bb29 = s0 [ s0 = split {_58} (fun (_ret: tuple'1) -> [ &_57 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0
      [ s0 = [ &perm_inner <- _57._p0'1 ] s1
      | s1 = [ &perm_next <- _57._p1'1 ] s2
      | s2 = as_ref {inner'0} (fun (_ret: t_PCell) -> [ &_83 <- _ret ] s3)
      | s3 = bb31 ]
    | bb31 = s0
      [ s0 = borrow_mut {_83} {perm_inner} (fun (_ret: MutBorrow.t t_Inner) -> [ &_81 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0 [ s0 = as_ref {next'0} (fun (_ret: t_PCell) -> [ &_88 <- _ret ] s1) | s1 = bb33 ]
    | bb33 = s0
      [ s0 = borrow_mut {_88} {perm_next} (fun (_ret: MutBorrow.t t_Inner) -> [ &_86 <- _ret ] s1) | s1 = bb34 ]
    | bb34 = s0
      [ s0 = [ &_80 <- { _p0'2 = _81; _p1'2 = _86 } ] s1
      | s1 = [ &bor_inner <- _80._p0'2 ] s2
      | s2 = [ &bor_next <- _80._p1'2 ] s3
      | s3 = {inv'3 bor_inner.current}
        MutBorrow.borrow_mut <t_Inner> {bor_inner.current}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &_92 <- _ret ] -{inv'3 _ret.final}-
            [ &bor_inner <- { bor_inner with current = _ret.final } ] s4)
      | s4 = {inv'3 bor_next.current}
        MutBorrow.borrow_mut <t_Inner> {bor_next.current}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &_93 <- _ret ] -{inv'3 _ret.final}-
            [ &bor_next <- { bor_next with current = _ret.final } ] s5)
      | s5 = swap {_92} {_93} (fun (_ret: ()) -> [ &_91 <- _ret ] s6)
      | s6 = bb35 ]
    | bb35 = s0
      [ s0 = [ &_94 <- { _p0'2 = bor_inner; _p1'2 = bor_next } ] s1
      | s1 = any
        [ br0 (x0: t_Vec) -> {(_94._p0'2).current = C_Direct x0} (! bb37)
        | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {(_94._p0'2).current = C_Link x0 x1 x2} (! bb36) ] ]
    | bb37 = any
      [ br0 (x0: t_Vec) -> {(_94._p1'2).current = C_Direct x0} (! bb36)
      | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {(_94._p1'2).current = C_Link x0 x1 x2} (! bb39) ]
    | bb36 = s0
      [ s0 = {[@expl:type invariant] inv'32 _94} s1
      | s1 = -{resolve'8 _94}- s2
      | s2 = {[@expl:type invariant] inv'14 inv'36} s3
      | s3 = -{resolve'10 inv'36}- s4
      | s4 = {false} any ]
    | bb39 = s0
      [ s0 = v_Direct {(_94._p0'2).current}
          (fun (r0: t_Vec) ->
            {inv'2 r0}
            MutBorrow.borrow_final <t_Vec> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _94._p0'2) 1}
              (fun (_ret: MutBorrow.t t_Vec) ->
                [ &arr <- _ret ] -{inv'2 _ret.final}-
                [ &_94 <- { _94 with _p0'2 = { _94._p0'2 with current = C_Direct _ret.final } } ] s1))
      | s1 = v_Link {(_94._p1'2).current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            MutBorrow.borrow_final <UInt64.t> {rindex} {MutBorrow.inherit_id (MutBorrow.get_id _94._p1'2) 1}
              (fun (_ret: MutBorrow.t UInt64.t) ->
                [ &index <- _ret ]
                [ &_94 <- { _94 with _p1'2 = { _94._p1'2 with current = C_Link _ret.final rvalue rnext } } ] s2))
      | s2 = v_Link {(_94._p1'2).current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            {inv rvalue}
            MutBorrow.borrow_final <t_T> {rvalue} {MutBorrow.inherit_id (MutBorrow.get_id _94._p1'2) 2}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &value_next <- _ret ] -{inv _ret.final}-
                [ &_94 <- { _94 with _p1'2 = { _94._p1'2 with current = C_Link rindex _ret.final rnext } } ] s3))
      | s3 = v_Link {(_94._p1'2).current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            MutBorrow.borrow_final <t_Rc> {rnext} {MutBorrow.inherit_id (MutBorrow.get_id _94._p1'2) 3}
              (fun (_ret: MutBorrow.t t_Rc) ->
                [ &next'1 <- _ret ]
                [ &_94 <- { _94 with _p1'2 = { _94._p1'2 with current = C_Link rindex rvalue _ret.final } } ] s4))
      | s4 = bb40 ]
    | bb40 = s0
      [ s0 = [ &next'1 <- { next'1 with current = inner_clone } ] s1 | s1 = -{resolve'12 next'1}- s2 | s2 = bb42 ]
    | bb42 = s0
      [ s0 = {inv'2 arr.current}
        MutBorrow.borrow_final <t_Vec> {arr.current} {MutBorrow.get_id arr}
          (fun (_ret: MutBorrow.t t_Vec) ->
            [ &_108 <- _ret ] -{inv'2 _ret.final}-
            [ &arr <- { arr with current = _ret.final } ] s1)
      | s1 = -{resolve'14 index}- s2
      | s2 = index_mut {_108} {index.current} (fun (_ret: MutBorrow.t t_T) -> [ &_107 <- _ret ] s3)
      | s3 = bb43 ]
    | bb43 = s0
      [ s0 = {inv _107.current}
        MutBorrow.borrow_final <t_T> {_107.current} {MutBorrow.get_id _107}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_106 <- _ret ] -{inv _ret.final}-
            [ &_107 <- { _107 with current = _ret.final } ] s1)
      | s1 = {inv _106.current}
        MutBorrow.borrow_final <t_T> {_106.current} {MutBorrow.get_id _106}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_105 <- _ret ] -{inv _ret.final}-
            [ &_106 <- { _106 with current = _ret.final } ] s2)
      | s2 = {inv value_next.current}
        MutBorrow.borrow_final <t_T> {value_next.current} {MutBorrow.get_id value_next}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_110 <- _ret ] -{inv _ret.final}-
            [ &value_next <- { value_next with current = _ret.final } ] s3)
      | s3 = swap'0 {_105} {_110} (fun (_ret: ()) -> [ &_104 <- _ret ] s4)
      | s4 = bb44 ]
    | bb44 = s0
      [ s0 = {[@expl:type invariant] inv'34 _107} s1
      | s1 = -{resolve'16 _107}- s2
      | s2 = {[@expl:type invariant] inv'34 _106} s3
      | s3 = -{resolve'16 _106}- s4
      | s4 = {[@expl:type invariant] inv'34 value_next} s5
      | s5 = -{resolve'16 value_next}- s6
      | s6 = {[@expl:type invariant] inv'33 arr} s7
      | s7 = -{resolve'18 arr}- s8
      | s8 = {[@expl:type invariant] inv'32 _94} s9
      | s9 = -{resolve'8 _94}- s10
      | s10 = [ &new_d <- [%#spersistent_array'0] MinMax.min rank (next_d - 1) ] s11
      | s11 = bb45 ]
    | bb45 = s0
      [ s0 = [ &_115 <- [%#spersistent_array'1] Map.set (inv'36.current).t_PA__rank id'2 new_d ] s1 | s1 = bb46 ]
    | bb46 = s0
      [ s0 = {inv'14 inv'36}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {inv'36}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_118 <- _ret ] -{inv'14 _ret.final}-
            [ &inv'36 <- _ret.final ] s1)
      | s1 = deref_mut {_118} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_117 <- _ret ] s2)
      | s2 = bb47 ]
    | bb47 = s0
      [ s0 =
        [ &_117 <- { _117 with current = { _117.current with current = { (_117.current).current with t_PA__rank = _115 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'22 _117} s2
      | s2 = -{resolve'0 _117}- s3
      | s3 = {[@expl:type invariant] inv'14 inv'36} s4
      | s4 = -{resolve'10 inv'36}- s5
      | s5 = new'2 {_114} (fun (_ret: ()) -> [ &_113 <- _ret ] s6)
      | s6 = bb48 ]
    | bb48 = s0 [ s0 = [ &_0 <- new_d ] s1 | s1 = bb51 ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'14 inv'36} s1
      | s1 = -{resolve'10 inv'36}- s2
      | s2 = [ &_0 <- [%#spersistent_array'2] index_logic'1 (inv'36.current).t_PA__rank id'2 ] s3
      | s3 = bb51 ]
    | bb51 = return''0 {_0} ]
    [ & _0: int = Any.any_l ()
    | & inner'0: t_Rc = inner
    | & invariant_id'0: t_Id = invariant_id
    | & inv'36: MutBorrow.t t_PA = inv'35
    | & inner_clone: t_Rc = Any.any_l ()
    | & id'2: t_Id = Any.any_l ()
    | & _17: t_PCell = Any.any_l ()
    | & rank: int = Any.any_l ()
    | & perm: t_PCellOwn = Any.any_l ()
    | & _22: t_PCellOwn = Any.any_l ()
    | & _23: t_Option'0 = Any.any_l ()
    | & _25: MutBorrow.t t_PA = Any.any_l ()
    | & _28: t_Id = Any.any_l ()
    | & _29: t_Id = Any.any_l ()
    | & borrow'0: t_Inner = Any.any_l ()
    | & _33: t_PCell = Any.any_l ()
    | & next: t_Rc = Any.any_l ()
    | & next'0: t_Rc = Any.any_l ()
    | & next_id: t_Id = Any.any_l ()
    | & _43: t_PCell = Any.any_l ()
    | & next_d: int = Any.any_l ()
    | & _47: t_Rc = Any.any_l ()
    | & _49: MutBorrow.t t_PA = Any.any_l ()
    | & _50: MutBorrow.t t_PA = Any.any_l ()
    | & _51: MutBorrow.t t_PA = Any.any_l ()
    | & _52: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _53: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _54: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & perm_inner: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & perm_next: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & _57: tuple'1 = Any.any_l ()
    | & _58: tuple'0 = Any.any_l ()
    | & _59: tuple'0 = Any.any_l ()
    | & p_inner: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & rest: MutBorrow.t t_FMap = Any.any_l ()
    | & _62: tuple = Any.any_l ()
    | & _63: MutBorrow.t t_FMap = Any.any_l ()
    | & _64: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _65: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _67: t_Id = Any.any_l ()
    | & _69: t_Id = Any.any_l ()
    | & _71: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & _72: t_Option'1 = Any.any_l ()
    | & _73: MutBorrow.t t_FMap = Any.any_l ()
    | & _75: t_Id = Any.any_l ()
    | & _76: t_Id = Any.any_l ()
    | & bor_inner: MutBorrow.t t_Inner = Any.any_l ()
    | & bor_next: MutBorrow.t t_Inner = Any.any_l ()
    | & _80: tuple'2 = Any.any_l ()
    | & _81: MutBorrow.t t_Inner = Any.any_l ()
    | & _83: t_PCell = Any.any_l ()
    | & _86: MutBorrow.t t_Inner = Any.any_l ()
    | & _88: t_PCell = Any.any_l ()
    | & _91: () = Any.any_l ()
    | & _92: MutBorrow.t t_Inner = Any.any_l ()
    | & _93: MutBorrow.t t_Inner = Any.any_l ()
    | & _94: tuple'2 = Any.any_l ()
    | & arr: MutBorrow.t t_Vec = Any.any_l ()
    | & index: MutBorrow.t UInt64.t = Any.any_l ()
    | & value_next: MutBorrow.t t_T = Any.any_l ()
    | & next'1: MutBorrow.t t_Rc = Any.any_l ()
    | & _104: () = Any.any_l ()
    | & _105: MutBorrow.t t_T = Any.any_l ()
    | & _106: MutBorrow.t t_T = Any.any_l ()
    | & _107: MutBorrow.t t_T = Any.any_l ()
    | & _108: MutBorrow.t t_Vec = Any.any_l ()
    | & _110: MutBorrow.t t_T = Any.any_l ()
    | & new_d: int = Any.any_l ()
    | & _113: () = Any.any_l ()
    | & _114: () = Any.any_l ()
    | & _115: Map.map t_Id int = Any.any_l ()
    | & _117: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _118: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l () ])
    [ return''0 (result: int) ->
    {[@expl:reroot ensures #0] [%#spersistent_array'6] invariant_with_data inv'35.final invariant_id}
      {[@expl:reroot ensures #1] [%#spersistent_array'7] forall id'2: t_Id. contains'0 (view'9 (inv'35.current).t_PA__auth) id'2
        = contains'0 (view'9 (inv'35.final).t_PA__auth) id'2}
      {[@expl:reroot ensures #2] [%#spersistent_array'8] (inv'35.current).t_PA__auth = (inv'35.final).t_PA__auth}
      {[@expl:reroot ensures #3] [%#spersistent_array'9] (inv'35.current).t_PA__length = (inv'35.final).t_PA__length}
      {[@expl:reroot ensures #4] [%#spersistent_array'10] forall id'2: t_Id. index_logic'1 (inv'35.current).t_PA__rank id'2
          > index_logic'1 (inv'35.current).t_PA__rank (id (view'10 inner))
        -> index_logic'1 (inv'35.current).t_PA__rank id'2 = index_logic'1 (inv'35.final).t_PA__rank id'2
        /\ get (inv'35.current).t_PA__permissions id'2 = get (inv'35.final).t_PA__permissions id'2}
      {[@expl:reroot ensures #5] [%#spersistent_array'11] match val' (index_logic'0 (inv'35.final).t_PA__permissions (id (view'10 inner))) with
        | C_Direct _ -> true
        | C_Link _ _ _ -> false
        end}
      {[@expl:reroot ensures #6] [%#spersistent_array'12] result
      = index_logic'1 (inv'35.final).t_PA__rank (id (view'10 inner))}
      (! return' {result}) ]
end
module M_persistent_array__testing [#"persistent_array.rs" 350 0 350 41]
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span spersistent_array = "persistent_array.rs" 351 38 351 39
  let%span spersistent_array'0 = "persistent_array.rs" 351 41 351 42
  let%span spersistent_array'1 = "persistent_array.rs" 351 44 351 45
  let%span spersistent_array'2 = "persistent_array.rs" 351 47 351 48
  let%span spersistent_array'3 = "persistent_array.rs" 353 19 353 20
  let%span spersistent_array'4 = "persistent_array.rs" 353 22 353 24
  let%span spersistent_array'5 = "persistent_array.rs" 354 19 354 20
  let%span spersistent_array'6 = "persistent_array.rs" 354 22 354 24
  let%span spersistent_array'7 = "persistent_array.rs" 358 18 358 57
  let%span spersistent_array'8 = "persistent_array.rs" 359 19 359 59
  let%span spersistent_array'9 = "persistent_array.rs" 360 19 360 59
  let%span spersistent_array'10 = "persistent_array.rs" 361 18 361 32
  let%span spersistent_array'11 = "persistent_array.rs" 362 18 362 34
  let%span spersistent_array'12 = "persistent_array.rs" 363 18 363 34
  let%span spersistent_array'13 = "persistent_array.rs" 364 18 364 33
  let%span spersistent_array'14 = "persistent_array.rs" 349 0 349 54
  let%span spersistent_array'15 = "persistent_array.rs" 125 33 125 37
  let%span spersistent_array'16 = "persistent_array.rs" 124 18 124 31
  let%span spersistent_array'17 = "persistent_array.rs" 161 20 161 24
  let%span spersistent_array'18 = "persistent_array.rs" 158 19 158 39
  let%span spersistent_array'19 = "persistent_array.rs" 159 8 159 46
  let%span spersistent_array'20 = "persistent_array.rs" 161 76 161 80
  let%span spersistent_array'21 = "persistent_array.rs" 160 18 160 53
  let%span spersistent_array'22 = "persistent_array.rs" 45 18 45 22
  let%span spersistent_array'23 = "persistent_array.rs" 45 27 45 31
  let%span spersistent_array'24 = "persistent_array.rs" 44 18 44 34
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 80 14 80 35
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 173 14 173 26
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 119 8 119 22
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 138 14 138 47
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 181 4 181 12
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 50 20 50 34
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 364 18 364 35
  
  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use set.Set
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq Int32.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 (self: Slice64.slice Int32.t) : Seq.seq Int32.t = [%#sboxed] Slice64.view self
  
  let rec into_vec (self_: Slice64.slice Int32.t) (return' (x: t_Vec)) = any
    [ return''0 (result: t_Vec) -> {[%#sslice] view result = view'0 self_} (! return' {result}) ]
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'1; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'2 = { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Rc'1 = { t_Rc__ptr'1: t_NonNull'2; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray = {
    t_PersistentArray__program_value: t_Rc;
    t_PersistentArray__contained_in_inv: t_Rc'0;
    t_PersistentArray__map_invariant: t_Rc'1 }
  
  predicate invariant' [#"persistent_array.rs" 56 8 56 34] (self: t_PersistentArray)
  
  predicate inv (_0: t_PersistentArray)
  
  axiom inv_axiom [@rewrite]: forall x: t_PersistentArray [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_PersistentArray__program_value = program_value; t_PersistentArray__contained_in_inv = contained_in_inv; t_PersistentArray__map_invariant = map_invariant} -> true
        end)
  
  function view'1 [#"persistent_array.rs" 74 8 74 31] (self: t_PersistentArray) : Seq.seq Int32.t
  
  let rec new (v: t_Vec) (return' (x: t_PersistentArray)) = any
    [ return''0 (result: t_PersistentArray) -> {[%#spersistent_array'15] inv result}
      {[%#spersistent_array'16] view'1 result = view v}
      (! return' {result}) ]
  
  type t_Tokens
  
  let rec deref_mut (self: MutBorrow.t t_Tokens) (return' (x: MutBorrow.t t_Tokens)) = any
    [ return''0 (result: MutBorrow.t t_Tokens) -> {[%#sghost] result = self} (! return' {result}) ]
  
  let rec reborrow (self: MutBorrow.t t_Tokens) (return' (x: t_Tokens)) = any
    [ return''0 (result: t_Tokens) -> {[%#slocal_invariant] result = self.current /\ self.final = self.current}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_Tokens) = [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Tokens) = resolve _0
  
  let rec new'0 (x: t_Tokens) (return' (x'0: t_Tokens)) = any
    [ return''0 (result: t_Tokens) -> {[%#sghost'0] result = x} (! return' {result}) ]
  
  predicate invariant''0 (self: t_PersistentArray) = [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_PersistentArray)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PersistentArray [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'2 (self: t_PersistentArray) : Seq.seq Int32.t = [%#smodel] view'1 self
  
  predicate contains [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = [%#sset] Set.mem e self
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'0 (self: t_Tokens) (namespace: t_Namespace) =
    [%#slocal_invariant'0] contains (namespaces self) namespace
  
  let rec set (self: t_PersistentArray) (index: UInt64.t) (value: Int32.t) (tokens: t_Tokens)
    (return' (x: t_PersistentArray)) = {[@expl:set 'self' type invariant] [%#spersistent_array'17] inv'0 self}
    {[@expl:set requires #0] [%#spersistent_array'18] UInt64.t'int index < Seq.length (view'2 self)}
    {[@expl:set requires #1] [%#spersistent_array'19] contains'0 tokens (Namespace_PARRAY_0'62 0)}
    any
    [ return''0 (result: t_PersistentArray) -> {[%#spersistent_array'20] inv result}
      {[%#spersistent_array'21] view'1 result = Seq.set (view'2 self) (UInt64.t'int index) value}
      (! return' {result}) ]
  
  predicate resolve'1 (_0: t_Tokens) = true
  
  predicate resolve'2 (self: t_Tokens) = [%#sghost'1] resolve'1 self
  
  predicate resolve'3 (_0: t_Tokens) = resolve'2 _0
  
  let rec clone' (self: t_PersistentArray) (return' (x: t_PersistentArray)) =
    {[@expl:clone 'self' type invariant] [%#spersistent_array'22] inv'0 self}
    any
    [ return''0 (result: t_PersistentArray) -> {[%#spersistent_array'23] inv result}
      {[%#spersistent_array'24] view'1 result = view'2 self}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec testing [#"persistent_array.rs" 350 0 350 41] (tokens: t_Tokens) (return' (x: ())) =
    {[@expl:testing requires] [%#spersistent_array'14] contains'0 tokens (Namespace_PARRAY_0'62 0)}
    (! bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0
            = ([%#spersistent_array] (1: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 1 = ([%#spersistent_array'0] (2: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 2 = ([%#spersistent_array'1] (3: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 3 = ([%#spersistent_array'2] (4: Int32.t))
          /\ Seq.length __arr_temp.Slice64.elts = 4}-
          [ &_7 <- __arr_temp ] s1) ]
      | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_vec {_7} (fun (_ret: t_Vec) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_4} (fun (_ret: t_PersistentArray) -> [ &a <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_mut <t_Tokens> {tokens'0}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_14 <- _ret ] [ &tokens'0 <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret: MutBorrow.t t_Tokens) -> [ &_13 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = MutBorrow.borrow_final <t_Tokens> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_12 <- _ret ] [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = reborrow {_12} (fun (_ret: t_Tokens) -> [ &_11 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = -{resolve'0 _13}- s1 | s1 = new'0 {_11} (fun (_ret: t_Tokens) -> [ &_10 <- _ret ] s2) | s2 = bb7 ]
    | bb7 = s0
      [ s0 = set {a} {[%#spersistent_array'3] (1: UInt64.t)} {[%#spersistent_array'4] (42: Int32.t)} {_10}
          (fun (_ret: t_PersistentArray) -> [ &a2 <- _ret ] s1)
      | s1 = bb8 ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Tokens> {tokens'0}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_21 <- _ret ] [ &tokens'0 <- _ret.final ] s1)
      | s1 = deref_mut {_21} (fun (_ret: MutBorrow.t t_Tokens) -> [ &_20 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = MutBorrow.borrow_final <t_Tokens> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_19 <- _ret ] [ &_20 <- { _20 with current = _ret.final } ] s1)
      | s1 = reborrow {_19} (fun (_ret: t_Tokens) -> [ &_18 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = -{resolve'0 _20}- s1 | s1 = new'0 {_18} (fun (_ret: t_Tokens) -> [ &_17 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0
      [ s0 = set {a} {[%#spersistent_array'5] (0: UInt64.t)} {[%#spersistent_array'6] (50: Int32.t)} {_17}
          (fun (_ret: t_PersistentArray) -> [ &a3 <- _ret ] s1)
      | s1 = bb12 ]
    | bb12 = s0
      [ s0 = -{resolve'3 tokens'0}- s1
      | s1 = clone' {a} (fun (_ret: t_PersistentArray) -> [ &a4 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 =
        [ &a_model <- [%#spersistent_array'7] Seq.create 4 [|(1: Int32.t);(2: Int32.t);(3: Int32.t);(4: Int32.t)|] ] s1
      | s1 = bb14 ]
    | bb14 = s0
      [ s0 =
        [ &a2_model <- [%#spersistent_array'8] Seq.create 4 [|(1: Int32.t);(42: Int32.t);(3: Int32.t);(4: Int32.t)|] ]
        s1
      | s1 = bb15 ]
    | bb15 = s0
      [ s0 =
        [ &a3_model <- [%#spersistent_array'9] Seq.create 4 [|(50: Int32.t);(2: Int32.t);(3: Int32.t);(4: Int32.t)|] ]
        s1
      | s1 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:assertion] [%#spersistent_array'10] view'1 a = a_model} s1
      | s1 = {[@expl:assertion] [%#spersistent_array'11] view'1 a2 = a2_model} s2
      | s2 = {[@expl:assertion] [%#spersistent_array'12] view'1 a3 = a3_model} s3
      | s3 = {[@expl:assertion] [%#spersistent_array'13] view'1 a4 = a_model} s4
      | s4 = bb20 ]
    | bb20 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & tokens'0: t_Tokens = tokens
    | & a: t_PersistentArray = Any.any_l ()
    | & _4: t_Vec = Any.any_l ()
    | & _7: Slice64.array Int32.t = Any.any_l ()
    | & a2: t_PersistentArray = Any.any_l ()
    | & _10: t_Tokens = Any.any_l ()
    | & _11: t_Tokens = Any.any_l ()
    | & _12: MutBorrow.t t_Tokens = Any.any_l ()
    | & _13: MutBorrow.t t_Tokens = Any.any_l ()
    | & _14: MutBorrow.t t_Tokens = Any.any_l ()
    | & a3: t_PersistentArray = Any.any_l ()
    | & _17: t_Tokens = Any.any_l ()
    | & _18: t_Tokens = Any.any_l ()
    | & _19: MutBorrow.t t_Tokens = Any.any_l ()
    | & _20: MutBorrow.t t_Tokens = Any.any_l ()
    | & _21: MutBorrow.t t_Tokens = Any.any_l ()
    | & a4: t_PersistentArray = Any.any_l ()
    | & a_model: Seq.seq Int32.t = Any.any_l ()
    | & a2_model: Seq.seq Int32.t = Any.any_l ()
    | & a3_model: Seq.seq Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_persistent_array__implementation__qyi15164097500274694161__clone__refines [#"persistent_array.rs" 45 8 45 31] (* <implementation::PersistentArray<T> as creusot_contracts::Clone> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY_0'62 int | Other namespace_other
  
  let%span spersistent_array = "persistent_array.rs" 45 8 45 31
  let%span spersistent_array'0 = "persistent_array.rs" 76 16 76 41
  let%span spersistent_array'1 = "persistent_array.rs" 59 16 61 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 91 8 91 22
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.int.UInt64
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1 = { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray = {
    t_PersistentArray__program_value: t_Rc;
    t_PersistentArray__contained_in_inv: t_Rc'0;
    t_PersistentArray__map_invariant: t_Rc'1 }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function view'0 (self: t_Fragment) : tuple = [%#sboxed] view self
  
  function view'1 (self: t_Rc'0) : t_Fragment
  
  function view'2 (self: t_Rc'0) : t_Fragment = [%#sghost] view'1 self
  
  type t_NonNull'2 = { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell = { t_UnsafeCell__value: t_Inner }
  
  type t_PCell = { t_PCell__0: t_UnsafeCell }
  
  function id (self: t_PCell) : t_Id
  
  function view'3 (self: t_Rc) : t_PCell
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'4 (self: t_Rc'1) : t_LocalInvariant
  
  function view'5 (self: t_Rc'1) : t_LocalInvariant = [%#sghost] view'4 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant' [#"persistent_array.rs" 56 8 56 34] (self: t_PersistentArray) =
    [%#spersistent_array'1] (view'0 (view'2 self.t_PersistentArray__contained_in_inv))._p0
      = id (view'3 self.t_PersistentArray__program_value)
    /\ id'0 (view'2 self.t_PersistentArray__contained_in_inv) = public (view'5 self.t_PersistentArray__map_invariant)
    /\ namespace (view'5 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv (_0: t_PersistentArray)
  
  axiom inv_axiom [@rewrite]: forall x: t_PersistentArray [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_PersistentArray__program_value = program_value; t_PersistentArray__contained_in_inv = contained_in_inv; t_PersistentArray__map_invariant = map_invariant} -> true
        end)
  
  predicate invariant''0 (self: t_PersistentArray) = [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_PersistentArray)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PersistentArray [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'6 [#"persistent_array.rs" 74 8 74 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'0] (view'0 (view'2 self.t_PersistentArray__contained_in_inv))._p1
  
  function view'7 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'6 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#spersistent_array] forall self_: t_PersistentArray. inv'0 self_
      -> inv'0 self_ /\ (forall result: t_PersistentArray. view'6 result = view'7 self_ /\ inv result -> inv result)
end
