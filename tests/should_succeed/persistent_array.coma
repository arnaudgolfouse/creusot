module M_persistent_array__implementation__qyi15164097500274694161__clone [#"persistent_array.rs" 46 8 46 31] (* <implementation::PersistentArray<T> as creusot_contracts::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 45 18 45 37
  let%span spersistent_array = "persistent_array.rs" 46 18 46 22
  let%span spersistent_array'0 = "persistent_array.rs" 46 27 46 31
  let%span spersistent_array'1 = "persistent_array.rs" 45 18 45 34
  let%span spersistent_array'2 = "persistent_array.rs" 77 16 77 43
  let%span spersistent_array'3 = "persistent_array.rs" 60 16 62 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 54 14 54 29
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 90 8 90 22
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0  =
    { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1  =
    { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray  =
    { t_PersistentArray__program_value: t_Rc;
      t_PersistentArray__contained_in_token:  t_Rc'0;
      t_PersistentArray__map_invariant:  t_Rc'1 }
  
  type t_NonNull'2  =
    { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner  =
    | C_Direct t_Vec
    | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_Inner }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  function view (self: t_Rc) : t_PCell
  
  let rec clone' (self_:t_Rc) (return'  (x:t_Rc))= any
    [ return''0 (result:t_Rc)-> {[%#src] view result = view self_} (! return' {result}) ]
  
  
  let rec clone''0 (self: t_Rc'0) (return'  (x: t_Rc'0))= any
    [ return''0 (result: t_Rc'0)-> {[%#sghost] result = self} (! return' {result}) ]
  
  
  let rec clone''1 (self: t_Rc'1) (return'  (x: t_Rc'1))= any
    [ return''0 (result: t_Rc'1)-> {[%#sghost] result = self} (! return' {result}) ]
  
  
  type t_Resource
  
  type t_Id
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type tuple  =
    { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view'0 (self: t_Fragment) : tuple
  
  function view'1 (self: t_Fragment) : tuple =
    [%#sboxed] view'0 self
  
  function view'2 (self: t_Rc'0) : t_Fragment
  
  function view'3 (self:  t_Rc'0) : t_Fragment =
    [%#sghost'0] view'2 self
  
  function id (self: t_PCell) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'4 (self: t_Rc'1) : t_LocalInvariant
  
  function view'5 (self:  t_Rc'1) : t_LocalInvariant =
    [%#sghost'0] view'4 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant' [#"persistent_array.rs" 57 8 57 34] (self: t_PersistentArray) =
    [%#spersistent_array'3] (view'1 (view'3 self.t_PersistentArray__contained_in_token))._p0
    = id (view self.t_PersistentArray__program_value)
    /\ id'0 (view'3 self.t_PersistentArray__contained_in_token) = public (view'5 self.t_PersistentArray__map_invariant)
    /\ namespace (view'5 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv (_0: t_PersistentArray)
  
  axiom inv_axiom [@rewrite]: forall x: t_PersistentArray [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_PersistentArray__program_value = program_value ; t_PersistentArray__contained_in_token = contained_in_token ; t_PersistentArray__map_invariant = map_invariant} -> true
    end)
  
  predicate invariant''0 (self: t_PersistentArray) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_PersistentArray)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PersistentArray [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'6 [#"persistent_array.rs" 75 8 75 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'2] (view'1 (view'3 self.t_PersistentArray__contained_in_token))._p1
  
  function view'7 (self: t_PersistentArray) : Seq.seq t_T =
    [%#smodel] view'6 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''2[#"persistent_array.rs" 46 8 46 31] (self:t_PersistentArray) (return'  (x:t_PersistentArray))= {[@expl:clone 'self' type invariant] [%#spersistent_array] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = clone' {self'0.t_PersistentArray__program_value} (fun (_ret:t_Rc) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = s0
      [ s0 = clone''0 {self'0.t_PersistentArray__contained_in_token} (fun (_ret: t_Rc'0) ->  [ &_5 <- _ret ] s1)
      | s1 = bb2 ]
    
    | bb2 = s0
      [ s0 = clone''1 {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc'1) ->  [ &_7 <- _ret ] s1) | s1 = bb3 ]
    
    | bb3 = s0
      [ s0 = 
        [ &_0 <- { t_PersistentArray__program_value = _3;
                   t_PersistentArray__contained_in_token = _5;
                   t_PersistentArray__map_invariant = _7 } ]
        
        s1
      | s1 = bb4 ]
    
    | bb4 = return''0 {_0} ]
    
    [ & _0: t_PersistentArray = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & _3: t_Rc = Any.any_l ()
    | & _5:  t_Rc'0 = Any.any_l ()
    | & _7:  t_Rc'1 = Any.any_l () ]
    )
    [ return''0 (result:t_PersistentArray)-> {[@expl:clone result type invariant] [%#spersistent_array'0] inv result}
      {[@expl:clone ensures] [%#spersistent_array'1] view'6 result = view'7 self}
      (! return' {result}) ]

end
module M_persistent_array__implementation__qyi7256199225841846155__new [#"persistent_array.rs" 137 8 137 37] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 31 26 31 43
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 32 23 32 28
  let%span spersistent_array = "persistent_array.rs" 138 32 138 45
  let%span spersistent_array'0 = "persistent_array.rs" 140 21 140 46
  let%span spersistent_array'1 = "persistent_array.rs" 141 25 141 55
  let%span spersistent_array'2 = "persistent_array.rs" 144 26 144 51
  let%span spersistent_array'3 = "persistent_array.rs" 153 30 153 46
  let%span spersistent_array'4 = "persistent_array.rs" 156 20 156 39
  let%span spersistent_array'5 = "persistent_array.rs" 157 20 157 39
  let%span spersistent_array'6 = "persistent_array.rs" 137 19 137 20
  let%span spersistent_array'7 = "persistent_array.rs" 137 33 137 37
  let%span spersistent_array'8 = "persistent_array.rs" 136 18 136 31
  let%span spersistent_array'9 = "persistent_array.rs" 77 16 77 43
  let%span spersistent_array'10 = "persistent_array.rs" 103 16 129 18
  let%span spersistent_array'11 = "persistent_array.rs" 60 16 62 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 80 22 80 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 80 4 80 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 79 14 79 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 183 22 183 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 183 4 183 32
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 181 14 181 29
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 90 8 90 22
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 100 8 100 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 96 15 96 20
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 96 4 96 54
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 94 14 94 44
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 95 14 95 35
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 36 8 36 19
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 61 20 61 46
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 44 8 44 27
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 80 4 80 31
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 79 14 79 38
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 23 96 27
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 89 15 89 34
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 4 96 78
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 90 14 90 46
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 91 14 91 39
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 92 14 92 33
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 93 14 93 38
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 276 4 276 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 274 14 274 31
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 442 29 442 33
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 442 43 442 48
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 442 4 442 65
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 440 14 440 49
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 441 14 441 40
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 123 8 123 34
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'17 = "../../creusot-contracts/src/logic/fmap.rs" 265 8 265 24
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 34
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 253 8 253 13
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 248 15 248 49
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 249 14 249 40
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 250 14 250 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Inner  =
    | C_Direct t_Vec
    | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_Inner }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  type tuple  =
    { _p0: t_PCell; _p1:  t_PCellOwn }
  
  predicate inv (_0: t_T)
  
  predicate invariant' (self: t_T) =
    [%#sboxed'0] inv self
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'0 (Seq.get self i)
  
  predicate inv'1 (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 (self: t_Vec) =
    [%#svec'0] inv'1 (view self)
  
  predicate inv'2 (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
  = match x with
    | C_Direct a_0 -> inv'2 a_0
    | C_Link index value next -> inv value
    end
  
  predicate inv'4 (_0: t_UnsafeCell)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnsafeCell [inv'4 x]. inv'4 x
  = match x with
    | {t_UnsafeCell__value = value} -> inv'3 value
    end
  
  predicate inv'5 (_0: t_PCell)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PCell [inv'5 x]. inv'5 x
  = match x with
    | {t_PCell__0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant''2 (self: t_Inner) =
    [%#sinvariant'0] inv'3 self
  
  predicate inv'6 (_0: t_Inner)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Inner [inv'6 x]. inv'6 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) =
    [%#spcell'4] inv'6 (val' self)
  
  predicate inv'7 (_0: t_PCellOwn)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_PCellOwn [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self:  t_PCellOwn) =
    [%#sghost'9] inv'7 self
  
  predicate inv'8 (_0:  t_PCellOwn)
  
  axiom inv_axiom'7 [@rewrite]: forall x:  t_PCellOwn [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate inv'9 (_0: tuple)
  
  axiom inv_axiom'8 [@rewrite]: forall x: tuple [inv'9 x]. inv'9 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv'5 x0 /\ inv'8 x1)
  
  type t_Id
  
  function id (self: t_PCell) : t_Id
  
  function id'0 (self: t_PCellOwn) : t_Id
  
  function view'0 (self: t_PCellOwn) : t_Inner =
    [%#spcell'3] val' self
  
  let rec new (value:t_Inner) (return'  (x:tuple))= {[@expl:new 'value' type invariant] [%#spcell] inv'3 value}
    any
    [ return''0 (result:tuple)-> {[%#spcell'0] inv'9 result}
      {[%#spcell'1] id result._p0 = id'0 result._p1}
      {[%#spcell'2] view'0 result._p1 = value}
      (! return' {result}) ]
  
  
  type t_Resource
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'10 (_0: t_Authority)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Authority [inv'10 x]. inv'10 x
  = (invariant''5 x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate invariant''6 (self:  t_Authority) =
    [%#sghost'9] inv'10 self
  
  predicate inv'11 (_0:  t_Authority)
  
  axiom inv_axiom'10 [@rewrite]: forall x:  t_Authority [inv'11 x]. inv'11 x = invariant''6 x
  
  type t_FMap
  
  function view'1 (self: t_Authority) : t_FMap
  
  function view'2 (self:  t_Authority) : t_FMap =
    [%#sghost'8] view'1 self
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'13] len self >= 0
  
  type t_Option  =
    | C_None
    | C_Some (Seq.seq t_T)
  
  function view'3 (self: t_FMap) : Map.map t_Id t_Option
  
  constant empty  : t_FMap
  
  axiom empty_spec: [%#sfmap'6] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'7] view'3 empty = Const.const (C_None)
  
  let rec new'0 (return'  (x: t_Authority))= any
    [ return''0 (result: t_Authority)-> {[%#sfmap_view] inv'11 result}
      {[%#sfmap_view'0] view'2 result = empty}
      (! return' {result}) ]
  
  
  predicate invariant''7 (self: MutBorrow.t ( t_Authority)) =
    [%#sinvariant] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'12 (_0: MutBorrow.t ( t_Authority))
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t ( t_Authority) [inv'12 x]. inv'12 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t t_Authority) =
    [%#sinvariant] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'13 (_0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'13 x]. inv'13 x = invariant''8 x
  
  let rec deref_mut (self:MutBorrow.t ( t_Authority)) (return'  (x:MutBorrow.t t_Authority))= {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'12 self}
    any
    [ return''0 (result:MutBorrow.t t_Authority)-> {[%#sghost'0] inv'13 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option =
    [%#sfmap'12] Map.get (view'3 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) =
    [%#sfmap'8] get self k <> C_None
  
  function view'4 (self: MutBorrow.t t_Authority) : t_FMap =
    [%#smodel] view'1 self.current
  
  predicate invariant''9 (self: t_Fragment)
  
  predicate inv'14 (_0: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
  = (invariant''9 x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  function insert (self: t_FMap) (k: t_Id) (v: Seq.seq t_T) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: Seq.seq t_T. [%#sfmap'9] view'3 (insert self k v)
  = Map.set (view'3 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: Seq.seq t_T. [%#sfmap'10] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  function id'1 (self: t_Authority) : t_Id
  
  type tuple'0  =
    { _p0'0: t_Id; _p1'0: Seq.seq t_T }
  
  function view'5 (self: t_Fragment) : tuple'0
  
  function id'2 (self: t_Fragment) : t_Id
  
  let rec insert'0 (self:MutBorrow.t t_Authority) (k:t_Id) (v:Seq.seq t_T) (return'  (x:t_Fragment))= {[@expl:insert 'self' type invariant] [%#sfmap_view'1] inv'13 self}
    {[@expl:insert requires] [%#sfmap_view'2] not contains (view'4 self) k}
    any
    [ return''0 (result:t_Fragment)-> {[%#sfmap_view'3] inv'14 result}
      {[%#sfmap_view'4] view'1 self.final = insert (view'4 self) k v}
      {[%#sfmap_view'5] id'1 self.final = id'1 self.current}
      {[%#sfmap_view'6] view'5 result = { _p0'0 = k; _p1'0 = v }}
      {[%#sfmap_view'7] id'2 result = id'1 self.current}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Authority) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Authority) =
    resolve _0
  
  predicate invariant''10 (self:  t_Fragment) =
    [%#sghost'9] inv'14 self
  
  predicate inv'15 (_0:  t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x:  t_Fragment [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec new'1 (x:t_Fragment) (return'  (x'0: t_Fragment))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'14 x}
    any
    [ return''0 (result: t_Fragment)-> {[%#sghost'3] inv'15 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PCellOwn
  
  function view'6 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 =
    [%#sfmap'12] Map.get (view'6 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) =
    [%#sfmap'8] get'0 self k <> C_None'0
  
  predicate inv'16 (_0: t_Id)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Id [inv'16 x]. inv'16 x = true
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option'0) : t_PCellOwn =
    [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_PCellOwn =
    [%#sfmap'18] unwrap_logic (get'0 self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : t_PCellOwn =
    [%#sfmap'17] lookup self key
  
  predicate invariant''11 (self: t_FMap'0) =
    [%#sfmap'16] forall k: t_Id. contains'0 self k  -> inv'16 k /\ inv'7 (index_logic'0 self k)
  
  predicate inv'17 (_0: t_FMap'0)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_FMap'0 [inv'17 x]. inv'17 x = invariant''11 x
  
  predicate invariant''12 (self:  t_FMap'0) =
    [%#sghost'9] inv'17 self
  
  predicate inv'18 (_0:  t_FMap'0)
  
  axiom inv_axiom'17 [@rewrite]: forall x:  t_FMap'0 [inv'18 x]. inv'18 x = invariant''12 x
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) =
    [%#sfmap'15] let _ = () in forall k: t_Id. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap'14] ext_eq self other = (self = other)
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'13] len'0 self >= 0
  
  constant empty'0  : t_FMap'0
  
  axiom empty_spec'1: [%#sfmap'6] len'0 empty'0 = 0
  
  axiom empty_spec'2: [%#sfmap'7] view'6 empty'0 = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap'0) =
    [%#sfmap'11] ext_eq self empty'0
  
  let rec new'2 (return'  (x: t_FMap'0))= any
    [ return''0 (result: t_FMap'0)-> {[%#sfmap] inv'18 result} {[%#sfmap'0] is_empty result} (! return' {result}) ]
  
  
  predicate invariant''13 (self: MutBorrow.t ( t_FMap'0)) =
    [%#sinvariant] inv'18 self.current /\ inv'18 self.final
  
  predicate inv'19 (_0: MutBorrow.t ( t_FMap'0))
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t ( t_FMap'0) [inv'19 x]. inv'19 x = invariant''13 x
  
  predicate invariant''14 (self: MutBorrow.t t_FMap'0) =
    [%#sinvariant] inv'17 self.current /\ inv'17 self.final
  
  predicate inv'20 (_0: MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t t_FMap'0 [inv'20 x]. inv'20 x = invariant''14 x
  
  let rec deref_mut'0 (self:MutBorrow.t ( t_FMap'0)) (return'  (x:MutBorrow.t t_FMap'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'19 self}
    any
    [ return''0 (result:MutBorrow.t t_FMap'0)-> {[%#sghost'0] inv'20 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  
  let rec into_inner (self: t_PCellOwn) (return'  (x:t_PCellOwn))= {[@expl:into_inner 'self' type invariant] [%#sghost'5] inv'8 self}
    any
    [ return''0 (result:t_PCellOwn)-> {[%#sghost'6] inv'7 result} {[%#sghost'7] result = self} (! return' {result}) ]
  
  
  predicate inv'21 (_0: t_Option'0)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Option'0 [inv'21 x]. inv'21 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'7 a_0
    end
  
  function insert'1 (self: t_FMap'0) (k: t_Id) (v: t_PCellOwn) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_Id, v: t_PCellOwn. [%#sfmap'9] view'6 (insert'1 self k v)
  = Map.set (view'6 self) k (C_Some'0 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_Id, v: t_PCellOwn. [%#sfmap'10] len'0 (insert'1 self k v)
  = (if contains'0 self k then len'0 self else len'0 self + 1)
  
  let rec insert_ghost (self:MutBorrow.t t_FMap'0) (key:t_Id) (value:t_PCellOwn) (return'  (x:t_Option'0))= {[@expl:insert_ghost 'self' type invariant] [%#sfmap'1] inv'20 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'2] inv'7 value}
    any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'3] inv'21 result}
      {[%#sfmap'4] self.final = insert'1 self.current key value}
      {[%#sfmap'5] result = get'0 self.current key}
      (! return' {result}) ]
  
  
  predicate resolve'1 (_0: t_Inner) =
    true
  
  predicate resolve'2 (self: t_PCellOwn) =
    [%#spcell'5] resolve'1 (val' self)
  
  predicate resolve'3 (_0: t_PCellOwn) =
    resolve'2 _0
  
  predicate resolve'4 (self: t_Option'0) =
    [%#sresolve'0] match self with
      | C_Some'0 x -> resolve'3 x
      | C_None'0 -> true
      end
  
  predicate resolve'5 (_0: t_Option'0) =
    resolve'4 _0
  
  predicate resolve'6 (self: MutBorrow.t t_FMap'0) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t t_FMap'0) =
    resolve'6 _0
  
  let rec into_inner'0 (self: t_FMap'0) (return'  (x:t_FMap'0))= {[@expl:into_inner 'self' type invariant] [%#sghost'5] inv'18 self}
    any
    [ return''0 (result:t_FMap'0)-> {[%#sghost'6] inv'17 result} {[%#sghost'7] result = self} (! return' {result}) ]
  
  
  let rec into_inner'1 (self: t_Authority) (return'  (x:t_Authority))= {[@expl:into_inner 'self' type invariant] [%#sghost'5] inv'11 self}
    any
    [ return''0 (result:t_Authority)-> {[%#sghost'6] inv'10 result} {[%#sghost'7] result = self} (! return' {result}) ]
  
  
  type t_CompleteMap  =
    { t_CompleteMap__own_map: t_FMap'0;
      t_CompleteMap__values: t_Authority;
      t_CompleteMap__rank: Map.map t_Id int;
      t_CompleteMap__length: int }
  
  predicate inv'22 (_0: t_CompleteMap)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_CompleteMap [inv'22 x]. inv'22 x
  = match x with
    | {t_CompleteMap__own_map = own_map ; t_CompleteMap__values = values ; t_CompleteMap__rank = rank ; t_CompleteMap__length = length} -> inv'17 own_map
    /\ inv'10 values
    end
  
  predicate invariant''15 (self:  t_CompleteMap) =
    [%#sghost'9] inv'22 self
  
  predicate inv'23 (_0:  t_CompleteMap)
  
  axiom inv_axiom'22 [@rewrite]: forall x:  t_CompleteMap [inv'23 x]. inv'23 x = invariant''15 x
  
  let rec new'3 (x:t_CompleteMap) (return'  (x'0: t_CompleteMap))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'22 x}
    any
    [ return''0 (result: t_CompleteMap)-> {[%#sghost'3] inv'23 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  type t_LocalInvariant
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) =
    [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option) : Seq.seq t_T =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'18] unwrap_logic'0 (get self k)
  
  function view'7 (self: t_Rc) : t_PCell
  
  function index_logic'2 (self: Map.map t_Id int) (a: t_Id) : int =
    [%#smapping] Map.get self a
  
  predicate invariant_with_data [#"persistent_array.rs" 101 8 101 52] (self: t_CompleteMap) (id'3: t_Id) =
    [%#spersistent_array'10] id'1 self.t_CompleteMap__values = id'3
    /\ (forall id'4: t_Id. contains'0 self.t_CompleteMap__own_map id'4
    = contains (view'1 self.t_CompleteMap__values) id'4)
    /\ (forall id'4: t_Id. contains'0 self.t_CompleteMap__own_map id'4
     -> id'0 (index_logic'0 self.t_CompleteMap__own_map id'4) = id'4)
    /\ (forall id'4: t_Id. contains'0 self.t_CompleteMap__own_map id'4
     -> Seq.length (lookup'0 (view'1 self.t_CompleteMap__values) id'4) = self.t_CompleteMap__length)
    /\ (forall id'4: t_Id. contains'0 self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct _ -> true
      | C_Link _ _ next -> contains'0 self.t_CompleteMap__own_map (id (view'7 next))
      end)
    /\ (forall id'4: t_Id. contains'0 self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct v -> lookup'0 (view'1 self.t_CompleteMap__values) id'4 = view v
      | C_Link index value next -> let next_id = id (view'7 next) in UInt64.t'int index < self.t_CompleteMap__length
      /\ Seq.get (lookup'0 (view'1 self.t_CompleteMap__values) id'4) (UInt64.t'int index) = value
      /\ (forall j: int. 0 <= j /\ j < self.t_CompleteMap__length /\ j <> UInt64.t'int index
       -> Seq.get (lookup'0 (view'1 self.t_CompleteMap__values) id'4) j
      = Seq.get (lookup'0 (view'1 self.t_CompleteMap__values) next_id) j)
      end)
    /\ (forall id'4: t_Id. contains'0 self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct _ -> true
      | C_Link _ _ next -> let next_id = id (view'7 next) in index_logic'2 self.t_CompleteMap__rank id'4
      > index_logic'2 self.t_CompleteMap__rank next_id
      end)
  
  function public (self: t_LocalInvariant) : t_Id
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  let rec new'4 (value: t_CompleteMap) (public'0:t_Id) (namespace'0:t_Namespace) (return'  (x: t_LocalInvariant))= {[@expl:new 'value' type invariant] [%#slocal_invariant] inv'23 value}
    {[@expl:new requires] [%#slocal_invariant'0] invariant_with_data value public'0}
    any
    [ return''0 (result: t_LocalInvariant)-> {[%#slocal_invariant'1] public result = public'0}
      {[%#slocal_invariant'2] namespace result = namespace'0}
      (! return' {result}) ]
  
  
  let rec into_inner'2 (self: t_LocalInvariant) (return'  (x:t_LocalInvariant))= any
    [ return''0 (result:t_LocalInvariant)-> {[%#sghost'7] result = self} (! return' {result}) ]
  
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'0  =
    { t_Rc__ptr'0: t_NonNull'1; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  function view'8 (self: t_Rc'0) : t_LocalInvariant
  
  let rec new'5 (value:t_LocalInvariant) (return'  (x:t_Rc'0))= any
    [ return''0 (result:t_Rc'0)-> {[%#src] view'8 result = value} (! return' {result}) ]
  
  
  let rec new'6 (x:t_Rc'0) (return'  (x'0: t_Rc'0))= any
    [ return''0 (result: t_Rc'0)-> {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  let rec new'7 (value:t_PCell) (return'  (x:t_Rc))= {[@expl:new 'value' type invariant] [%#src'0] inv'5 value}
    any [ return''0 (result:t_Rc)-> {[%#src] view'7 result = value} (! return' {result}) ] 
  
  let rec into_inner'3 (self: t_Fragment) (return'  (x:t_Fragment))= {[@expl:into_inner 'self' type invariant] [%#sghost'5] inv'15 self}
    any
    [ return''0 (result:t_Fragment)-> {[%#sghost'6] inv'14 result} {[%#sghost'7] result = self} (! return' {result}) ]
  
  
  type t_NonNull'2  =
    { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Rc'1  =
    { t_Rc__ptr'1: t_NonNull'2; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  function view'9 (self: t_Rc'1) : t_Fragment
  
  let rec new'8 (value:t_Fragment) (return'  (x:t_Rc'1))= {[@expl:new 'value' type invariant] [%#src'0] inv'14 value}
    any [ return''0 (result:t_Rc'1)-> {[%#src] view'9 result = value} (! return' {result}) ] 
  
  let rec new'9 (x:t_Rc'1) (return'  (x'0: t_Rc'1))= any
    [ return''0 (result: t_Rc'1)-> {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  type t_PersistentArray  =
    { t_PersistentArray__program_value: t_Rc;
      t_PersistentArray__contained_in_token:  t_Rc'1;
      t_PersistentArray__map_invariant:  t_Rc'0 }
  
  function view'10 (self: t_Fragment) : tuple'0 =
    [%#sboxed] view'5 self
  
  function view'11 (self:  t_Rc'1) : t_Fragment =
    [%#sghost'8] view'9 self
  
  function view'12 (self:  t_Rc'0) : t_LocalInvariant =
    [%#sghost'8] view'8 self
  
  predicate invariant''16 [#"persistent_array.rs" 57 8 57 34] (self: t_PersistentArray) =
    [%#spersistent_array'11] (view'10 (view'11 self.t_PersistentArray__contained_in_token))._p0'0
    = id (view'7 self.t_PersistentArray__program_value)
    /\ id'2 (view'11 self.t_PersistentArray__contained_in_token)
    = public (view'12 self.t_PersistentArray__map_invariant)
    /\ namespace (view'12 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv'24 (_0: t_PersistentArray)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_PersistentArray [inv'24 x]. inv'24 x
  = (invariant''16 x
  /\ match x with
    | {t_PersistentArray__program_value = program_value ; t_PersistentArray__contained_in_token = contained_in_token ; t_PersistentArray__map_invariant = map_invariant} -> true
    end)
  
  function view'13 [#"persistent_array.rs" 75 8 75 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'9] (view'10 (view'11 self.t_PersistentArray__contained_in_token))._p1'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'10[#"persistent_array.rs" 137 8 137 37] (v:t_Vec) (return'  (x:t_PersistentArray))= {[@expl:new 'v' type invariant] [%#spersistent_array'6] inv'2 v}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &logical_value <- [%#spersistent_array] view v'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_8 <- C_Direct v'0 ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = new {_8} (fun (_ret:tuple) ->  [ &_7 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &program_value <- _7._p0 ] s1 | s1 =  [ &ownership <- _7._p1 ] s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &id'3 <- [%#spersistent_array'0] id'0 ownership ] s1 | s1 = bb5 ] 
    | bb5 = s0 [ s0 =  [ &length <- [%#spersistent_array'1] Seq.length logical_value ] s1 | s1 = bb6 ] 
    | bb6 = s0 [ s0 = new'0 (fun (_ret: t_Authority) ->  [ &resource <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = {inv'11 resource}
        MutBorrow.borrow_mut < t_Authority> {resource}
          (fun (_ret:MutBorrow.t ( t_Authority)) ->
             [ &_19 <- _ret ] 
            -{inv'11 _ret.final}-
             [ &resource <- _ret.final ] 
            s1)
      | s1 = deref_mut {_19} (fun (_ret:MutBorrow.t t_Authority) ->  [ &_18 <- _ret ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 = {inv'10 _18.current}
        MutBorrow.borrow_final <t_Authority> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret:MutBorrow.t t_Authority) ->
             [ &_17 <- _ret ] 
            -{inv'10 _ret.final}-
             [ &_18 <- { _18 with current = _ret.final } ] 
            s1)
      | s1 = insert'0 {_17} {id'3} {logical_value} (fun (_ret:t_Fragment) ->  [ &_16 <- _ret ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'13 _18} s1
      | s1 = -{resolve'0 _18}- s2
      | s2 = new'1 {_16} (fun (_ret: t_Fragment) ->  [ &frac_part <- _ret ] s3)
      | s3 = bb10 ]
    
    | bb10 = s0 [ s0 =  [ &gset_id <- [%#spersistent_array'2] id'2 frac_part ] s1 | s1 = bb11 ] 
    | bb11 = s0 [ s0 = new'2 (fun (_ret: t_FMap'0) ->  [ &own_map <- _ret ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = {inv'18 own_map}
        MutBorrow.borrow_mut < t_FMap'0> {own_map}
          (fun (_ret:MutBorrow.t ( t_FMap'0)) ->  [ &_30 <- _ret ] -{inv'18 _ret.final}-  [ &own_map <- _ret.final ] s1)
      | s1 = deref_mut'0 {_30} (fun (_ret:MutBorrow.t t_FMap'0) ->  [ &_29 <- _ret ] s2)
      | s2 = bb13 ]
    
    | bb13 = s0 [ s0 = into_inner {ownership} (fun (_ret:t_PCellOwn) ->  [ &_32 <- _ret ] s1) | s1 = bb14 ] 
    | bb14 = s0
      [ s0 = {inv'17 _29.current}
        MutBorrow.borrow_final <t_FMap'0> {_29.current} {MutBorrow.get_id _29}
          (fun (_ret:MutBorrow.t t_FMap'0) ->
             [ &_28 <- _ret ] 
            -{inv'17 _ret.final}-
             [ &_29 <- { _29 with current = _ret.final } ] 
            s1)
      | s1 = insert_ghost {_28} {id'3} {_32} (fun (_ret:t_Option'0) ->  [ &_27 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'21 _27} s3
      | s3 = -{resolve'5 _27}- s4
      | s4 = bb15 ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'20 _29} s1
      | s1 = -{resolve'7 _29}- s2
      | s2 = into_inner'0 {own_map} (fun (_ret:t_FMap'0) ->  [ &_37 <- _ret ] s3)
      | s3 = bb16 ]
    
    | bb16 = s0 [ s0 = into_inner'1 {resource} (fun (_ret:t_Authority) ->  [ &_39 <- _ret ] s1) | s1 = bb17 ] 
    | bb17 = s0 [ s0 =  [ &_41 <- [%#spersistent_array'3] fun (__0: t_Id) -> 0 ] s1 | s1 = bb18 ] 
    | bb18 = s0
      [ s0 = 
        [ &_36 <- { t_CompleteMap__own_map = _37;
                    t_CompleteMap__values = _39;
                    t_CompleteMap__rank = _41;
                    t_CompleteMap__length = length } ]
        
        s1
      | s1 = new'3 {_36} (fun (_ret: t_CompleteMap) ->  [ &_35 <- _ret ] s2)
      | s2 = bb19 ]
    
    | bb19 = s0 [ s0 =  [ &_44 <- [%#spersistent_array'4] gset_id ] s1 | s1 = bb20 ] 
    | bb20 = s0 [ s0 =  [ &_46 <- [%#spersistent_array'5] Namespace_PARRAY_0'62 0 ] s1 | s1 = bb21 ] 
    | bb21 = s0
      [ s0 = new'4 {_35} {_44} {_46} (fun (_ret: t_LocalInvariant) ->  [ &local_inv <- _ret ] s1) | s1 = bb22 ]
    
    | bb22 = s0 [ s0 = into_inner'2 {local_inv} (fun (_ret:t_LocalInvariant) ->  [ &_48 <- _ret ] s1) | s1 = bb23 ] 
    | bb23 = s0 [ s0 = new'5 {_48} (fun (_ret:t_Rc'0) ->  [ &_25 <- _ret ] s1) | s1 = bb24 ] 
    | bb24 = s0 [ s0 = new'6 {_25} (fun (_ret: t_Rc'0) ->  [ &map_invariant <- _ret ] s1) | s1 = bb25 ] 
    | bb25 = s0 [ s0 = new'7 {program_value} (fun (_ret:t_Rc) ->  [ &_50 <- _ret ] s1) | s1 = bb26 ] 
    | bb26 = s0 [ s0 = into_inner'3 {frac_part} (fun (_ret:t_Fragment) ->  [ &_54 <- _ret ] s1) | s1 = bb27 ] 
    | bb27 = s0 [ s0 = new'8 {_54} (fun (_ret:t_Rc'1) ->  [ &_53 <- _ret ] s1) | s1 = bb28 ] 
    | bb28 = s0 [ s0 = new'9 {_53} (fun (_ret: t_Rc'1) ->  [ &_52 <- _ret ] s1) | s1 = bb29 ] 
    | bb29 = s0
      [ s0 = 
        [ &_0 <- { t_PersistentArray__program_value = _50;
                   t_PersistentArray__contained_in_token = _52;
                   t_PersistentArray__map_invariant = map_invariant } ]
        
        s1
      | s1 = bb32 ]
    
    | bb32 = return''0 {_0} ]
    
    [ & _0: t_PersistentArray = Any.any_l ()
    | & v'0: t_Vec = v
    | & logical_value: Seq.seq t_T = Any.any_l ()
    | & program_value: t_PCell = Any.any_l ()
    | & ownership:  t_PCellOwn = Any.any_l ()
    | & _7: tuple = Any.any_l ()
    | & _8: t_Inner = Any.any_l ()
    | & id'3: t_Id = Any.any_l ()
    | & length: int = Any.any_l ()
    | & resource:  t_Authority = Any.any_l ()
    | & frac_part:  t_Fragment = Any.any_l ()
    | & _16: t_Fragment = Any.any_l ()
    | & _17: MutBorrow.t t_Authority = Any.any_l ()
    | & _18: MutBorrow.t t_Authority = Any.any_l ()
    | & _19: MutBorrow.t ( t_Authority) = Any.any_l ()
    | & gset_id: t_Id = Any.any_l ()
    | & map_invariant:  t_Rc'0 = Any.any_l ()
    | & _25: t_Rc'0 = Any.any_l ()
    | & own_map:  t_FMap'0 = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _28: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _29: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _30: MutBorrow.t ( t_FMap'0) = Any.any_l ()
    | & _32: t_PCellOwn = Any.any_l ()
    | & local_inv:  t_LocalInvariant = Any.any_l ()
    | & _35:  t_CompleteMap = Any.any_l ()
    | & _36: t_CompleteMap = Any.any_l ()
    | & _37: t_FMap'0 = Any.any_l ()
    | & _39: t_Authority = Any.any_l ()
    | & _41: Map.map t_Id int = Any.any_l ()
    | & _44: t_Id = Any.any_l ()
    | & _46: t_Namespace = Any.any_l ()
    | & _48: t_LocalInvariant = Any.any_l ()
    | & _50: t_Rc = Any.any_l ()
    | & _52:  t_Rc'1 = Any.any_l ()
    | & _53: t_Rc'1 = Any.any_l ()
    | & _54: t_Fragment = Any.any_l () ]
    )
    [ return''0 (result:t_PersistentArray)-> {[@expl:new result type invariant] [%#spersistent_array'7] inv'24 result}
      {[@expl:new ensures] [%#spersistent_array'8] view'13 result = view v}
      (! return' {result}) ]

end
module M_persistent_array__implementation__qyi7256199225841846155__set [#"persistent_array.rs" 173 8 173 88] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 45 18 45 37
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 32 23 32 28
  let%span src'1 = "../../creusot-contracts/src/std/rc.rs" 31 26 31 43
  let%span src'2 = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span src'3 = "../../creusot-contracts/src/std/rc.rs" 50 18 50 38
  let%span spersistent_array = "persistent_array.rs" 174 36 174 71
  let%span spersistent_array'0 = "persistent_array.rs" 173 20 173 24
  let%span spersistent_array'1 = "persistent_array.rs" 173 40 173 45
  let%span spersistent_array'2 = "persistent_array.rs" 170 19 170 39
  let%span spersistent_array'3 = "persistent_array.rs" 171 19 171 48
  let%span spersistent_array'4 = "persistent_array.rs" 173 84 173 88
  let%span spersistent_array'5 = "persistent_array.rs" 172 18 172 53
  let%span spersistent_array'6 = "persistent_array.rs" 180 34 180 63
  let%span spersistent_array'7 = "persistent_array.rs" 181 34 181 69
  let%span spersistent_array'8 = "persistent_array.rs" 192 38 195 25
  let%span spersistent_array'9 = "persistent_array.rs" 179 61 179 73
  let%span spersistent_array'10 = "persistent_array.rs" 179 66 179 72
  let%span spersistent_array'11 = "persistent_array.rs" 77 16 77 43
  let%span spersistent_array'12 = "persistent_array.rs" 103 16 129 18
  let%span spersistent_array'13 = "persistent_array.rs" 60 16 62 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 122 14 122 32
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 54 14 54 29
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 68 14 68 43
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 183 22 183 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 183 4 183 32
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 181 14 181 29
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 80 22 80 26
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 80 4 80 48
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 79 14 79 35
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 171 14 171 26
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 90 8 90 22
  let%span sghost'13 = "../../creusot-contracts/src/ghost.rs" 108 8 108 22
  let%span sghost'14 = "../../creusot-contracts/src/ghost.rs" 100 8 100 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 96 15 96 20
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 96 4 96 54
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 94 14 94 44
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 95 14 95 35
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 36 8 36 19
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 88 26 88 30
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 88 50 88 54
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 85 14 85 36
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 86 14 86 28
  let%span spcell'8 = "../../creusot-contracts/src/pcell.rs" 61 20 61 46
  let%span spcell'9 = "../../creusot-contracts/src/pcell.rs" 44 8 44 27
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 105 14 105 49
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 23 96 27
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 89 15 89 34
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 4 96 78
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 90 14 90 46
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 91 14 91 39
  let%span sfmap_view'8 = "../../creusot-contracts/src/resource/fmap_view.rs" 92 14 92 33
  let%span sfmap_view'9 = "../../creusot-contracts/src/resource/fmap_view.rs" 93 14 93 38
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 377 30 377 34
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 377 4 377 62
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 366 14 374 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 375 14 375 73
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 376 44
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 442 29 442 33
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 442 43 442 48
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 442 4 442 65
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 440 14 440 49
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 441 14 441 40
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 265 8 265 24
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 34
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 212 59 212 60
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 204 15 204 46
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 205 15 206 115
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 208 14 209 124
  let%span slocal_invariant'3 = "../../creusot-contracts/src/local_invariant.rs" 136 8 136 45
  let%span slocal_invariant'4 = "../../creusot-contracts/src/local_invariant.rs" 189 4 191 51
  let%span slocal_invariant'5 = "../../creusot-contracts/src/local_invariant.rs" 189 59 189 60
  let%span slocal_invariant'6 = "../../creusot-contracts/src/local_invariant.rs" 182 15 182 53
  let%span slocal_invariant'7 = "../../creusot-contracts/src/local_invariant.rs" 183 15 186 101
  let%span slocal_invariant'8 = "../../creusot-contracts/src/local_invariant.rs" 187 14 187 117
  let%span slocal_invariant'9 = "../../creusot-contracts/src/local_invariant.rs" 145 8 145 25
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use seq.Seq
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  use set.Set
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0  =
    { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1  =
    { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray  =
    { t_PersistentArray__program_value: t_Rc;
      t_PersistentArray__contained_in_token:  t_Rc'0;
      t_PersistentArray__map_invariant:  t_Rc'1 }
  
  type t_T
  
  type t_Resource
  
  type t_Id
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type tuple  =
    { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function view'0 (self: t_Fragment) : tuple =
    [%#sboxed] view self
  
  function view'1 (self: t_Rc'0) : t_Fragment
  
  function view'2 (self:  t_Rc'0) : t_Fragment =
    [%#sghost'12] view'1 self
  
  function view'3 [#"persistent_array.rs" 75 8 75 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'11] (view'0 (view'2 self.t_PersistentArray__contained_in_token))._p1
  
  function view'4 (self: t_PersistentArray) : Seq.seq t_T =
    [%#smodel] view'3 self
  
  type t_NonNull'2  =
    { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner  =
    | C_Direct t_Vec
    | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_Inner }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  function view'5 (self: t_Rc) : t_PCell
  
  let rec clone' (self_:t_Rc) (return'  (x:t_Rc))= any
    [ return''0 (result:t_Rc)-> {[%#src] view'5 result = view'5 self_} (! return' {result}) ]
  
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  type tuple'0  =
    { _p0'0: t_PCell; _p1'0:  t_PCellOwn }
  
  predicate inv (_0: t_T)
  
  predicate invariant' (self: t_T) =
    [%#sboxed'0] inv self
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'0 (Seq.get self i)
  
  predicate inv'1 (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'6 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view'6 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) =
    [%#svec'0] inv'1 (view'6 self)
  
  predicate inv'2 (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
  = match x with
    | C_Direct a_0 -> inv'2 a_0
    | C_Link index value next -> inv value
    end
  
  predicate inv'4 (_0: t_UnsafeCell)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnsafeCell [inv'4 x]. inv'4 x
  = match x with
    | {t_UnsafeCell__value = value} -> inv'3 value
    end
  
  predicate inv'5 (_0: t_PCell)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PCell [inv'5 x]. inv'5 x
  = match x with
    | {t_PCell__0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant''2 (self: t_Inner) =
    [%#sinvariant] inv'3 self
  
  predicate inv'6 (_0: t_Inner)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Inner [inv'6 x]. inv'6 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) =
    [%#spcell'8] inv'6 (val' self)
  
  predicate inv'7 (_0: t_PCellOwn)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_PCellOwn [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self:  t_PCellOwn) =
    [%#sghost'14] inv'7 self
  
  predicate inv'8 (_0:  t_PCellOwn)
  
  axiom inv_axiom'7 [@rewrite]: forall x:  t_PCellOwn [inv'8 x]. inv'8 x = invariant''4 x
  
  predicate inv'9 (_0: tuple'0)
  
  axiom inv_axiom'8 [@rewrite]: forall x: tuple'0 [inv'9 x]. inv'9 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv'5 x0 /\ inv'8 x1)
  
  function id (self: t_PCell) : t_Id
  
  function id'0 (self: t_PCellOwn) : t_Id
  
  function view'7 (self: t_PCellOwn) : t_Inner =
    [%#spcell'3] val' self
  
  let rec new (value:t_Inner) (return'  (x:tuple'0))= {[@expl:new 'value' type invariant] [%#spcell] inv'3 value}
    any
    [ return''0 (result:tuple'0)-> {[%#spcell'0] inv'9 result}
      {[%#spcell'1] id result._p0'0 = id'0 result._p1'0}
      {[%#spcell'2] view'7 result._p1'0 = value}
      (! return' {result}) ]
  
  
  let rec borrow (self: t_Rc'1) (return'  (x: t_Rc'1))= any
    [ return''0 (result: t_Rc'1)-> {[%#sghost] result = self} (! return' {result}) ]
  
  
  type closure0  =
    { _0: t_PCell; _1: t_PersistentArray; _2:  t_PCellOwn; _3: Seq.seq t_T }
  
  type t_FMap
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_CompleteMap  =
    { t_CompleteMap__own_map: t_FMap;
      t_CompleteMap__values: t_Authority;
      t_CompleteMap__rank: Map.map t_Id int;
      t_CompleteMap__length: int }
  
  type t_Option  =
    | C_None
    | C_Some t_PCellOwn
  
  function view'8 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option =
    [%#sfmap'9] Map.get (view'8 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) =
    [%#sfmap'10] get self k <> C_None
  
  predicate inv'10 (_0'0: t_Id)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Id [inv'10 x]. inv'10 x = true
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn =
    [%#sfmap'16] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn =
    [%#sfmap'11] lookup self key
  
  predicate invariant''5 (self: t_FMap) =
    [%#sfmap'15] forall k: t_Id. contains self k  -> inv'10 k /\ inv'7 (index_logic'0 self k)
  
  predicate inv'11 (_0'0: t_FMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_FMap [inv'11 x]. inv'11 x = invariant''5 x
  
  predicate invariant''6 (self: t_Authority)
  
  predicate inv'12 (_0'0: t_Authority)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Authority [inv'12 x]. inv'12 x
  = (invariant''6 x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate inv'13 (_0'0: t_CompleteMap)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_CompleteMap [inv'13 x]. inv'13 x
  = match x with
    | {t_CompleteMap__own_map = own_map ; t_CompleteMap__values = values ; t_CompleteMap__rank = rank ; t_CompleteMap__length = length} -> inv'11 own_map
    /\ inv'12 values
    end
  
  predicate invariant''7 (self: MutBorrow.t t_CompleteMap) =
    [%#sinvariant'0] inv'13 self.current /\ inv'13 self.final
  
  predicate inv'14 (_0'0: MutBorrow.t t_CompleteMap)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_CompleteMap [inv'14 x]. inv'14 x = invariant''7 x
  
  predicate invariant''8 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sghost'14] inv'14 self
  
  predicate inv'15 (_0'0:  (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'14 [@rewrite]: forall x:  (MutBorrow.t t_CompleteMap) [inv'15 x]. inv'15 x = invariant''8 x
  
  predicate invariant''9 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sinvariant] inv'15 self
  
  predicate inv'16 (_0'0:  (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'15 [@rewrite]: forall x:  (MutBorrow.t t_CompleteMap) [inv'16 x]. inv'16 x = invariant''9 x
  
  predicate invariant''10 (self: MutBorrow.t t_CompleteMap) =
    [%#sinvariant] inv'14 self
  
  predicate inv'17 (_0'0: MutBorrow.t t_CompleteMap)
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t t_CompleteMap [inv'17 x]. inv'17 x = invariant''10 x
  
  let rec deref (self: (MutBorrow.t t_CompleteMap)) (return'  (x:MutBorrow.t t_CompleteMap))= {[@expl:deref 'self' type invariant] [%#sghost'1] inv'16 self}
    any
    [ return''0 (result:MutBorrow.t t_CompleteMap)-> {[%#sghost'2] inv'17 result}
      {[%#sghost'3] self = result}
      (! return' {result}) ]
  
  
  let rec deref'0 (self: t_Rc'0) (return'  (x:t_Rc'0))= any
    [ return''0 (result:t_Rc'0)-> {[%#sghost'3] self = result} (! return' {result}) ]
  
  
  predicate invariant''11 (self: t_Fragment)
  
  predicate inv'18 (_0'0: t_Fragment)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Fragment [inv'18 x]. inv'18 x
  = (invariant''11 x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''12 (self: t_Fragment) =
    [%#sinvariant] inv'18 self
  
  predicate inv'19 (_0'0: t_Fragment)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_Fragment [inv'19 x]. inv'19 x = invariant''12 x
  
  let rec as_ref (self_:t_Rc'0) (return'  (x:t_Fragment))= any
    [ return''0 (result:t_Fragment)-> {inv'19 result} {[%#src'2] result = view'1 self_} (! return' {result}) ]
  
  
  predicate invariant''13 (self: t_Authority) =
    [%#sinvariant] inv'12 self
  
  predicate inv'20 (_0'0: t_Authority)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_Authority [inv'20 x]. inv'20 x = invariant''13 x
  
  function id'1 (self: t_Authority) : t_Id
  
  function id'2 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (Seq.seq t_T)
  
  function view'9 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 =
    [%#sfmap'9] Map.get (view'9 self) k
  
  function view'10 (self: t_Authority) : t_FMap'0
  
  function view'11 (self: t_Authority) : t_FMap'0 =
    [%#smodel] view'10 self
  
  function view'12 (self: t_Fragment) : tuple =
    [%#smodel] view self
  
  let rec contains'0 (self:t_Authority) (frag:t_Fragment) (return'  (x:()))= {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'20 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'19 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id'1 self = id'2 frag}
    any
    [ return''0 (result:())-> {[%#sfmap_view'2] get'0 (view'11 self) (view'12 frag)._p0 = C_Some'0 ((view'12 frag)._p1)}
      (! return' {result}) ]
  
  
  let rec into_inner (self: t_PCellOwn) (return'  (x:t_PCellOwn))= {[@expl:into_inner 'self' type invariant] [%#sghost'4] inv'8 self}
    any
    [ return''0 (result:t_PCellOwn)-> {[%#sghost'5] inv'7 result} {[%#sghost'6] result = self} (! return' {result}) ]
  
  
  predicate invariant''14 (self: MutBorrow.t ( (MutBorrow.t t_CompleteMap))) =
    [%#sinvariant'0] inv'15 self.current /\ inv'15 self.final
  
  predicate inv'21 (_0'0: MutBorrow.t ( (MutBorrow.t t_CompleteMap)))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) [inv'21 x]. inv'21 x
  = invariant''14 x
  
  predicate invariant''15 (self: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    [%#sinvariant'0] inv'14 self.current /\ inv'14 self.final
  
  predicate inv'22 (_0'0: MutBorrow.t (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_CompleteMap) [inv'22 x]. inv'22 x
  = invariant''15 x
  
  let rec deref_mut (self:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) (return'  (x:MutBorrow.t (MutBorrow.t t_CompleteMap)))= {[@expl:deref_mut 'self' type invariant] [%#sghost'7] inv'21 self}
    any
    [ return''0 (result:MutBorrow.t (MutBorrow.t t_CompleteMap))-> {[%#sghost'8] inv'22 result}
      {[%#sghost'9] result = self}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PCellOwn)
  
  predicate invariant''16 (self: MutBorrow.t t_FMap) =
    [%#sinvariant'0] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'23 (_0'0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'23 x]. inv'23 x = invariant''16 x
  
  predicate invariant''17 (self: MutBorrow.t t_PCellOwn) =
    [%#sinvariant'0] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'24 (_0'0: MutBorrow.t t_PCellOwn)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_PCellOwn [inv'24 x]. inv'24 x = invariant''17 x
  
  predicate inv'25 (_0'0: t_Option'1)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_Option'1 [inv'25 x]. inv'25 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'24 a_0
    end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'12] len self >= 0
  
  let rec get_mut_ghost (self:MutBorrow.t t_FMap) (key:t_Id) (return'  (x:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap] inv'23 self}
    any
    [ return''0 (result:t_Option'1)-> {[%#sfmap'0] inv'25 result}
      {[%#sfmap'1] if contains self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'2] forall k: t_Id. k <> key  -> get self.current k = get self.final k}
      {[%#sfmap'3] len self.current = len self.final}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option'1) (ret  (field_0:MutBorrow.t t_PCellOwn))= any
    [ good (field_0:MutBorrow.t t_PCellOwn)-> {C_Some'1 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_PCellOwn [C_Some'1 field_0: t_Option'1]. C_Some'1 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate invariant''18 (self: t_PCellOwn) =
    [%#sinvariant] inv'7 self
  
  predicate inv'26 (_0'0: t_PCellOwn)
  
  axiom inv_axiom'25 [@rewrite]: forall x: t_PCellOwn [inv'26 x]. inv'26 x = invariant''18 x
  
  let rec disjoint_lemma (own1:MutBorrow.t t_PCellOwn) (own2:t_PCellOwn) (return'  (x:()))= {[@expl:disjoint_lemma 'own1' type invariant] [%#spcell'4] inv'24 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#spcell'5] inv'26 own2}
    any
    [ return''0 (result:())-> {[%#spcell'6] id'0 own1.current <> id'0 own2}
      {[%#spcell'7] own1.current = own1.final}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_PCellOwn) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0: MutBorrow.t t_PCellOwn) =
    resolve _0'0
  
  predicate resolve'1 (self: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0'0: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    resolve'1 _0'0
  
  predicate inv'27 (_0'0: t_Option)
  
  axiom inv_axiom'26 [@rewrite]: forall x: t_Option [inv'27 x]. inv'27 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'7 a_0
    end
  
  function insert (self: t_FMap) (k: t_Id) (v: t_PCellOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: t_PCellOwn. [%#sfmap'13] view'8 (insert self k v)
  = Map.set (view'8 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: t_PCellOwn. [%#sfmap'14] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  let rec insert_ghost (self:MutBorrow.t t_FMap) (key:t_Id) (value:t_PCellOwn) (return'  (x:t_Option))= {[@expl:insert_ghost 'self' type invariant] [%#sfmap'4] inv'23 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'5] inv'7 value}
    any
    [ return''0 (result:t_Option)-> {[%#sfmap'6] inv'27 result}
      {[%#sfmap'7] self.final = insert self.current key value}
      {[%#sfmap'8] result = get self.current key}
      (! return' {result}) ]
  
  
  predicate resolve'3 (_0'0: t_Inner) =
    true
  
  predicate resolve'4 (self: t_PCellOwn) =
    [%#spcell'9] resolve'3 (val' self)
  
  predicate resolve'5 (_0'0: t_PCellOwn) =
    resolve'4 _0'0
  
  predicate resolve'6 (self: t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve'5 x
      | C_None -> true
      end
  
  predicate resolve'7 (_0'0: t_Option) =
    resolve'6 _0'0
  
  function index_logic'1 (self: Map.map t_Id int) (a: t_Id) : int =
    [%#smapping] Map.get self a
  
  predicate invariant''19 (self: MutBorrow.t t_Authority) =
    [%#sinvariant'0] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'28 (_0'0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'27 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'28 x]. inv'28 x = invariant''19 x
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) =
    [%#sfmap'10] get'0 self k <> C_None'0
  
  function view'13 (self: MutBorrow.t t_Authority) : t_FMap'0 =
    [%#smodel'0] view'10 self.current
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'12] len'0 self >= 0
  
  function insert'0 (self: t_FMap'0) (k: t_Id) (v: Seq.seq t_T) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_Id, v: Seq.seq t_T. [%#sfmap'13] view'9 (insert'0 self k v)
  = Map.set (view'9 self) k (C_Some'0 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_Id, v: Seq.seq t_T. [%#sfmap'14] len'0 (insert'0 self k v)
  = (if contains'1 self k then len'0 self else len'0 self + 1)
  
  let rec insert'1 (self:MutBorrow.t t_Authority) (k:t_Id) (v:Seq.seq t_T) (return'  (x:t_Fragment))= {[@expl:insert 'self' type invariant] [%#sfmap_view'3] inv'28 self}
    {[@expl:insert requires] [%#sfmap_view'4] not contains'1 (view'13 self) k}
    any
    [ return''0 (result:t_Fragment)-> {[%#sfmap_view'5] inv'18 result}
      {[%#sfmap_view'6] view'10 self.final = insert'0 (view'13 self) k v}
      {[%#sfmap_view'7] id'1 self.final = id'1 self.current}
      {[%#sfmap_view'8] view result = { _p0 = k; _p1 = v }}
      {[%#sfmap_view'9] id'2 result = id'1 self.current}
      (! return' {result}) ]
  
  
  predicate resolve'8 (self: MutBorrow.t t_CompleteMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'9 (_0'0: MutBorrow.t t_CompleteMap) =
    resolve'8 _0'0
  
  predicate resolve'10 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sghost'13] resolve'9 self
  
  predicate resolve'11 (_0'0:  (MutBorrow.t t_CompleteMap)) =
    resolve'10 _0'0
  
  let rec new'0 (value:t_Fragment) (return'  (x:t_Rc'0))= {[@expl:new 'value' type invariant] [%#src'0] inv'18 value}
    any [ return''0 (result:t_Rc'0)-> {[%#src'1] view'1 result = value} (! return' {result}) ] 
  
  let rec new'1 (x:t_Rc'0) (return'  (x'0: t_Rc'0))= any
    [ return''0 (result: t_Rc'0)-> {[%#sghost'10] result = x} (! return' {result}) ]
  
  
  predicate invariant''20 (self: t_PCell) =
    [%#sinvariant] inv'5 self
  
  predicate inv'29 (_0'0: t_PCell)
  
  axiom inv_axiom'28 [@rewrite]: forall x: t_PCell [inv'29 x]. inv'29 x = invariant''20 x
  
  predicate invariant''21 (self: t_PCell) =
    [%#sinvariant] inv'29 self
  
  predicate inv'30 (_0'0: t_PCell)
  
  axiom inv_axiom'29 [@rewrite]: forall x: t_PCell [inv'30 x]. inv'30 x = invariant''21 x
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'14 (self: t_Rc'1) : t_LocalInvariant
  
  function view'15 (self:  t_Rc'1) : t_LocalInvariant =
    [%#sghost'12] view'14 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''22 [#"persistent_array.rs" 57 8 57 34] (self: t_PersistentArray) =
    [%#spersistent_array'13] (view'0 (view'2 self.t_PersistentArray__contained_in_token))._p0
    = id (view'5 self.t_PersistentArray__program_value)
    /\ id'2 (view'2 self.t_PersistentArray__contained_in_token) = public (view'15 self.t_PersistentArray__map_invariant)
    /\ namespace (view'15 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv'31 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'30 [@rewrite]: forall x: t_PersistentArray [inv'31 x]. inv'31 x
  = (invariant''22 x
  /\ match x with
    | {t_PersistentArray__program_value = program_value ; t_PersistentArray__contained_in_token = contained_in_token ; t_PersistentArray__map_invariant = map_invariant} -> true
    end)
  
  predicate invariant''23 (self: t_PersistentArray) =
    [%#sinvariant] inv'31 self
  
  predicate inv'32 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'31 [@rewrite]: forall x: t_PersistentArray [inv'32 x]. inv'32 x = invariant''23 x
  
  predicate invariant''24 (self: t_PersistentArray) =
    [%#sinvariant] inv'32 self
  
  predicate inv'33 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'32 [@rewrite]: forall x: t_PersistentArray [inv'33 x]. inv'33 x = invariant''24 x
  
  predicate inv'34 (_0'0: closure0)
  
  axiom inv_axiom'33 [@rewrite]: forall x: closure0 [inv'34 x]. inv'34 x
  = (let {_0 = x0 ; _1 = x1 ; _2 = x2 ; _3 = x3} = x in inv'30 x0 /\ inv'33 x1 /\ inv'8 x2)
  
  let rec closure0[#"persistent_array.rs" 179 61 179 73] [@coma:extspec] (self:closure0) (tokens: (MutBorrow.t t_CompleteMap)) (return'  (x: t_Rc'0))= bb0
    [ bb0 = s0 [ s0 =  [ &cell_id <- [%#spersistent_array'6] id _1'0._0 ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 =  [ &self_id <- [%#spersistent_array'7] id (view'5 (_1'0._1).t_PersistentArray__program_value) ] s1
      | s1 = bb2 ]
    
    | bb2 = s0 [ s0 = deref {tokens'0} (fun (_ret:MutBorrow.t t_CompleteMap) ->  [ &_10 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = deref'0 {(_1'0._1).t_PersistentArray__contained_in_token} (fun (_ret:t_Rc'0) ->  [ &_15 <- _ret ] s1)
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 = as_ref {_15} (fun (_ret:t_Fragment) ->  [ &_13 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = contains'0 {(_10.current).t_CompleteMap__values} {_13} (fun (_ret:()) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ]
    
    | bb6 = s0 [ s0 = into_inner {_1'0._2} (fun (_ret:t_PCellOwn) ->  [ &ownership <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = {inv'15 tokens'0}
        MutBorrow.borrow_mut < (MutBorrow.t t_CompleteMap)> {tokens'0}
          (fun (_ret:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) ->
             [ &_23 <- _ret ] 
            -{inv'15 _ret.final}-
             [ &tokens'0 <- _ret.final ] 
            s1)
      | s1 = deref_mut {_23} (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->  [ &_22 <- _ret ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_25 <- cell_id ] s1
      | s1 = {inv'11 ((_22.current).current).t_CompleteMap__own_map}
        MutBorrow.borrow_mut <t_FMap> {((_22.current).current).t_CompleteMap__own_map}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_21 <- _ret ] 
            -{inv'11 _ret.final}-
            
            [ &_22 <- { _22 with current = { _22.current with current = { (_22.current).current with t_CompleteMap__own_map = _ret.final } } } ]
            
            s2)
      | s2 = get_mut_ghost {_21} {_25} (fun (_ret:t_Option'1) ->  [ &_20 <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = any [ br0 -> {_20 = C_None'1} (! bb13) | br1 (x0:MutBorrow.t t_PCellOwn)-> {_20 = C_Some'1 x0} (! bb12) ] 
    | bb12 = s0
      [ s0 = v_Some {_20} (fun (r0:MutBorrow.t t_PCellOwn) ->  [ &other <- r0 ] s1)
      | s1 =  [ &_30 <- ownership ] s2
      | s2 = {inv'7 other.current}
        MutBorrow.borrow_final <t_PCellOwn> {other.current} {MutBorrow.get_id other}
          (fun (_ret:MutBorrow.t t_PCellOwn) ->
             [ &_28 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &other <- { other with current = _ret.final } ] 
            s3)
      | s3 = disjoint_lemma {_28} {_30} (fun (_ret:()) ->  [ &_19 <- _ret ] s4)
      | s4 = bb14 ]
    
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'24 other} s1
      | s1 = -{resolve'0 other}- s2
      | s2 = {[@expl:type invariant] inv'22 _22} s3
      | s3 = -{resolve'2 _22}- s4
      | s4 = bb15 ]
    
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'22 _22} s1 | s1 = -{resolve'2 _22}- s2 | s2 = bb15 ] 
    | bb15 = s0
      [ s0 = {inv'15 tokens'0}
        MutBorrow.borrow_mut < (MutBorrow.t t_CompleteMap)> {tokens'0}
          (fun (_ret:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) ->
             [ &_34 <- _ret ] 
            -{inv'15 _ret.final}-
             [ &tokens'0 <- _ret.final ] 
            s1)
      | s1 = deref_mut {_34} (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->  [ &_33 <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0
      [ s0 = {inv'11 ((_33.current).current).t_CompleteMap__own_map}
        MutBorrow.borrow_mut <t_FMap> {((_33.current).current).t_CompleteMap__own_map}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_32 <- _ret ] 
            -{inv'11 _ret.final}-
            
            [ &_33 <- { _33 with current = { _33.current with current = { (_33.current).current with t_CompleteMap__own_map = _ret.final } } } ]
            
            s1)
      | s1 = insert_ghost {_32} {cell_id} {ownership} (fun (_ret:t_Option) ->  [ &_31 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'27 _31} s3
      | s3 = -{resolve'7 _31}- s4
      | s4 = bb17 ]
    
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'22 _33} s1
      | s1 = -{resolve'2 _33}- s2
      | s2 = 
        [ &_37 <- [%#spersistent_array'8] let new_distance = index_logic'1 (tokens'0.current).t_CompleteMap__rank self_id
        + 1 in Map.set (tokens'0.current).t_CompleteMap__rank cell_id new_distance ]
        
        s3
      | s3 = bb18 ]
    
    | bb18 = s0
      [ s0 = {inv'15 tokens'0}
        MutBorrow.borrow_mut < (MutBorrow.t t_CompleteMap)> {tokens'0}
          (fun (_ret:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) ->
             [ &_40 <- _ret ] 
            -{inv'15 _ret.final}-
             [ &tokens'0 <- _ret.final ] 
            s1)
      | s1 = deref_mut {_40} (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->  [ &_39 <- _ret ] s2)
      | s2 = bb19 ]
    
    | bb19 = s0
      [ s0 = 
        [ &_39 <- { _39 with current = { _39.current with current = { (_39.current).current with t_CompleteMap__rank = _37 } } } ]
        
        s1
      | s1 = {[@expl:type invariant] inv'22 _39} s2
      | s2 = -{resolve'2 _39}- s3
      | s3 = {inv'15 tokens'0}
        MutBorrow.borrow_mut < (MutBorrow.t t_CompleteMap)> {tokens'0}
          (fun (_ret:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) ->
             [ &_44 <- _ret ] 
            -{inv'15 _ret.final}-
             [ &tokens'0 <- _ret.final ] 
            s4)
      | s4 = deref_mut {_44} (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->  [ &_43 <- _ret ] s5)
      | s5 = bb20 ]
    
    | bb20 = s0
      [ s0 = {inv'12 ((_43.current).current).t_CompleteMap__values}
        MutBorrow.borrow_mut <t_Authority> {((_43.current).current).t_CompleteMap__values}
          (fun (_ret:MutBorrow.t t_Authority) ->
             [ &_42 <- _ret ] 
            -{inv'12 _ret.final}-
            
            [ &_43 <- { _43 with current = { _43.current with current = { (_43.current).current with t_CompleteMap__values = _ret.final } } } ]
            
            s1)
      | s1 = insert'1 {_42} {cell_id} {_1'0._3} (fun (_ret:t_Fragment) ->  [ &frac <- _ret ] s2)
      | s2 = bb21 ]
    
    | bb21 = s0
      [ s0 = {[@expl:type invariant] inv'22 _43} s1
      | s1 = -{resolve'2 _43}- s2
      | s2 = {[@expl:type invariant] inv'15 tokens'0} s3
      | s3 = -{resolve'11 tokens'0}- s4
      | s4 = new'0 {frac} (fun (_ret:t_Rc'0) ->  [ &_7 <- _ret ] s5)
      | s5 = bb22 ]
    
    | bb22 = s0 [ s0 = new'1 {_7} (fun (_ret: t_Rc'0) ->  [ &_0'0 <- _ret ] s1) | s1 = bb23 ] 
    | bb23 = return' {_0'0} ]
    
    [ & _0'0:  t_Rc'0 = Any.any_l ()
    | & _1'0: closure0 = self
    | & tokens'0:  (MutBorrow.t t_CompleteMap) = tokens
    | & cell_id: t_Id = Any.any_l ()
    | & self_id: t_Id = Any.any_l ()
    | & _7: t_Rc'0 = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _10: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _13: t_Fragment = Any.any_l ()
    | & _15: t_Rc'0 = Any.any_l ()
    | & ownership: t_PCellOwn = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _20: t_Option'1 = Any.any_l ()
    | & _21: MutBorrow.t t_FMap = Any.any_l ()
    | & _22: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _23: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) = Any.any_l ()
    | & _25: t_Id = Any.any_l ()
    | & other: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & _28: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & _30: t_PCellOwn = Any.any_l ()
    | & _31: t_Option = Any.any_l ()
    | & _32: MutBorrow.t t_FMap = Any.any_l ()
    | & _33: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _34: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) = Any.any_l ()
    | & _37: Map.map t_Id int = Any.any_l ()
    | & _39: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _40: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) = Any.any_l ()
    | & frac: t_Fragment = Any.any_l ()
    | & _42: MutBorrow.t t_Authority = Any.any_l ()
    | & _43: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _44: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) = Any.any_l () ]
  
  
  type t_Namespaces
  
  predicate precondition (self: ()) (args: t_Rc'1) =
    let self_ = args in true
  
  let rec deref'1 (self_:t_Rc'1) (return'  (x:t_LocalInvariant))= any
    [ return''0 (result:t_LocalInvariant)-> {[%#src'3] result = view'14 self_} (! return' {result}) ]
  
  
  predicate postcondition_once (self: ()) (args: t_Rc'1) (result: t_LocalInvariant) =
    let self_ = args in result = view'14 self_
  
  predicate resolve'12 (_0'0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: t_Rc'1) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view'14 self_
  
  function fn_mut_once (self: ()) (args: t_Rc'1) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_Rc'1, res: t_LocalInvariant. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'12 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc'1) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_Rc'1, res_state: (), res: t_LocalInvariant. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_Rc'1) (result: t_LocalInvariant) =
    let self_ = args in result = view'14 self_
  
  function fn_once (self: ()) (args: t_Rc'1) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc'1, res: t_LocalInvariant. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'12 self)
  
  function fn_mut (self: ()) (args: t_Rc'1) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_Rc'1, res_state: (), res: t_LocalInvariant. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  type tuple'1  =
    { _p0'1:  t_LocalInvariant; _p1'1:  t_Namespaces; _p2: closure0 }
  
  predicate index_logic'2 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) =
    [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'2 p x)
   -> ([%#sutil'0] index_logic'2 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T =
    [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'16] unwrap_logic'0 (get'0 self k)
  
  predicate invariant_with_data [#"persistent_array.rs" 101 8 101 52] (self: t_CompleteMap) (id'3: t_Id) =
    [%#spersistent_array'12] id'1 self.t_CompleteMap__values = id'3
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
    = contains'1 (view'10 self.t_CompleteMap__values) id'4)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> id'0 (index_logic'0 self.t_CompleteMap__own_map id'4) = id'4)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> Seq.length (lookup'0 (view'10 self.t_CompleteMap__values) id'4) = self.t_CompleteMap__length)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct _ -> true
      | C_Link _ _ next -> contains self.t_CompleteMap__own_map (id (view'5 next))
      end)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct v -> lookup'0 (view'10 self.t_CompleteMap__values) id'4 = view'6 v
      | C_Link index value next -> let next_id = id (view'5 next) in UInt64.t'int index < self.t_CompleteMap__length
      /\ Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) id'4) (UInt64.t'int index) = value
      /\ (forall j: int. 0 <= j /\ j < self.t_CompleteMap__length /\ j <> UInt64.t'int index
       -> Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) id'4) j
      = Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) next_id) j)
      end)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct _ -> true
      | C_Link _ _ next -> let next_id = id (view'5 next) in index_logic'1 self.t_CompleteMap__rank id'4
      > index_logic'1 self.t_CompleteMap__rank next_id
      end)
  
  predicate precondition'0 (self: closure0) (args:  (MutBorrow.t t_CompleteMap)) =
    [%#spersistent_array'9] let tokens = args in closure0'pre self tokens
  
  predicate postcondition_once'0 (self: closure0) (args:  (MutBorrow.t t_CompleteMap)) (result:  t_Rc'0) =
    [%#spersistent_array'9] let tokens = args in closure0'post'return' self tokens result
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) =
    [%#sset] Set.mem e self
  
  function namespaces (self: t_Namespaces) : Set.set t_Namespace
  
  function view'16 (self: t_Namespaces) : Set.set t_Namespace =
    [%#slocal_invariant'9] namespaces self
  
  function view'17 (self:  t_Namespaces) : Set.set t_Namespace =
    [%#sghost'12] view'16 self
  
  predicate precondition'1 (self: ()) (args: tuple'1) =
    [%#slocal_invariant'4] let {_p0'1 = self'0 ; _p1'1 = namespaces'0 ; _p2 = f} = args in (forall t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ inv'15 t
     -> precondition'0 f t
    /\ (forall res:  t_Rc'0. postcondition_once'0 f t res  -> invariant_with_data t.final (public self'0)))
    /\ contains'2 (view'17 namespaces'0) (namespace self'0) /\ inv'34 f
  
  let rec open (self: t_LocalInvariant) (namespaces'0: t_Namespaces) (f:closure0) (return'  (x: t_Rc'0))= {[@expl:open 'f' type invariant] [%#slocal_invariant'5] inv'34 f}
    {[@expl:open requires #0] [%#slocal_invariant'6] contains'2 (view'17 namespaces'0) (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'7] forall t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self)
    /\ inv'15 t
     -> precondition'0 f t
    /\ (forall res:  t_Rc'0. postcondition_once'0 f t res  -> invariant_with_data t.final (public self))}
    any
    [ return''0 (result: t_Rc'0)-> {[%#slocal_invariant'8] exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self)
      /\ postcondition_once'0 f t result}
      (! return' {result}) ]
  
  
  function new_logic (x: t_LocalInvariant) :  t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. [%#sghost'11] new_logic x = x
  
  predicate postcondition_once'1 (self: ()) (args: tuple'1) (result:  t_Rc'0) =
    [%#slocal_invariant'4] let {_p0'1 = self'0 ; _p1'1 = namespaces'0 ; _p2 = f} = args in exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result
  
  predicate resolve'13 (_0'0: ()) =
    true
  
  predicate postcondition_mut'0 (self: ()) (args: tuple'1) (result_state: ()) (result:  t_Rc'0) =
    [%#slocal_invariant'4] let {_p0'1 = self'0 ; _p1'1 = namespaces'0 ; _p2 = f} = args in exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result
  
  function fn_mut_once'0 (self: ()) (args: tuple'1) (res:  t_Rc'0) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'1, res:  t_Rc'0. [%#sops'8] postcondition_once'1 self args res
  = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'13 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'1) (res_state: ()) (res:  t_Rc'0) : ()
  
  axiom postcondition_mut_hist_inv_spec'0: forall self: (), args: tuple'1, res_state: (), res:  t_Rc'0. ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple'1) (result:  t_Rc'0) =
    [%#slocal_invariant'4] let {_p0'1 = self'0 ; _p1'1 = namespaces'0 ; _p2 = f} = args in exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result
  
  function fn_once'0 (self: ()) (args: tuple'1) (res:  t_Rc'0) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'1, res:  t_Rc'0. [%#sops'0] postcondition_once'1 self args res
  = (postcondition'0 self args res /\ resolve'13 self)
  
  function fn_mut'0 (self: ()) (args: tuple'1) (res_state: ()) (res:  t_Rc'0) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: tuple'1, res_state: (), res:  t_Rc'0. [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc'1) (namespaces'0: t_Namespaces) (f:closure0) (return'  (x: t_Rc'0))= {[@expl:open 'f' type invariant] [%#slocal_invariant] inv'34 f}
    {[@expl:open requires #0] [%#slocal_invariant'0] precondition () self}
    {[@expl:open requires #1] [%#slocal_invariant'1] forall this: t_LocalInvariant. postcondition () self this
     -> precondition'1 () { _p0'1 = new_logic this; _p1'1 = namespaces'0; _p2 = f }}
    any
    [ return''0 (result: t_Rc'0)-> {[%#slocal_invariant'2] exists this: t_LocalInvariant. postcondition () self this
      /\ postcondition'0 () { _p0'1 = new_logic this; _p1'1 = namespaces'0; _p2 = f } result}
      (! return' {result}) ]
  
  
  let rec new'2 (value:t_PCell) (return'  (x:t_Rc))= {[@expl:new 'value' type invariant] [%#src'0] inv'5 value}
    any [ return''0 (result:t_Rc)-> {[%#src'1] view'5 result = value} (! return' {result}) ] 
  
  let rec clone''0 (self: t_Rc'1) (return'  (x: t_Rc'1))= any
    [ return''0 (result: t_Rc'1)-> {[%#sghost'0] result = self} (! return' {result}) ]
  
  
  predicate contains'3 (self: t_Namespaces) (namespace'0: t_Namespace) =
    [%#slocal_invariant'3] contains'2 (namespaces self) namespace'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec set[#"persistent_array.rs" 173 8 173 88] (self:t_PersistentArray) (index:UInt64.t) (value:t_T) (namespaces'0: t_Namespaces) (return'  (x:t_PersistentArray))= {[@expl:set 'self' type invariant] [%#spersistent_array'0] inv'32 self}
    {[@expl:set 'value' type invariant] [%#spersistent_array'1] inv value}
    {[@expl:set requires #0] [%#spersistent_array'2] UInt64.t'int index < Seq.length (view'4 self)}
    {[@expl:set requires #1] [%#spersistent_array'3] contains'3 namespaces'0 (Namespace_PARRAY_0'62 0)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &new_logical_value <- [%#spersistent_array] Seq.set (view'4 self'0) (UInt64.t'int index'0) value'0 ] s1
      | s1 = bb1 ]
    
    | bb1 = s0
      [ s0 = clone' {self'0.t_PersistentArray__program_value} (fun (_ret:t_Rc) ->  [ &_16 <- _ret ] s1) | s1 = bb2 ]
    
    | bb2 = s0 [ s0 =  [ &_13 <- C_Link index'0 value'0 _16 ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new {_13} (fun (_ret:tuple'0) ->  [ &_12 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 =  [ &program_value <- _12._p0'0 ] s1 | s1 =  [ &ownership <- _12._p1'0 ] s2 | s2 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &program_value'0 <- program_value ] s1
      | s1 = borrow {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc'1) ->  [ &_20 <- _ret ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &_23 <- { _0 = program_value'0; _1 = self'0; _2 = ownership; _3 = new_logical_value } ] s1
      | s1 = open'0 {_20} {namespaces'1} {_23} (fun (_ret: t_Rc'0) ->  [ &new_frac <- _ret ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0 [ s0 = new'2 {program_value} (fun (_ret:t_Rc) ->  [ &_27 <- _ret ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = clone''0 {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc'1) ->  [ &_30 <- _ret ] s1)
      | s1 = bb10 ]
    
    | bb10 = s0
      [ s0 = 
        [ &_0'0 <- { t_PersistentArray__program_value = _27;
                     t_PersistentArray__contained_in_token = new_frac;
                     t_PersistentArray__map_invariant = _30 } ]
        
        s1
      | s1 = bb13 ]
    
    | bb13 = return''0 {_0'0} ]
    
    [ & _0'0: t_PersistentArray = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & index'0: UInt64.t = index
    | & value'0: t_T = value
    | & namespaces'1:  t_Namespaces = namespaces'0
    | & new_logical_value: Seq.seq t_T = Any.any_l ()
    | & program_value: t_PCell = Any.any_l ()
    | & ownership:  t_PCellOwn = Any.any_l ()
    | & _12: tuple'0 = Any.any_l ()
    | & _13: t_Inner = Any.any_l ()
    | & _16: t_Rc = Any.any_l ()
    | & new_frac:  t_Rc'0 = Any.any_l ()
    | & program_value'0: t_PCell = Any.any_l ()
    | & _20:  t_Rc'1 = Any.any_l ()
    | & _23: closure0 = Any.any_l ()
    | & _27: t_Rc = Any.any_l ()
    | & _30:  t_Rc'1 = Any.any_l () ]
    )
    [ return''0 (result:t_PersistentArray)-> {[@expl:set result type invariant] [%#spersistent_array'4] inv'31 result}
      {[@expl:set ensures] [%#spersistent_array'5] view'3 result = Seq.set (view'4 self) (UInt64.t'int index) value}
      (! return' {result}) ]

end
module M_persistent_array__implementation__qyi7256199225841846155__get_immut [#"persistent_array.rs" 229 8 233 26] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 50 18 50 38
  let%span spersistent_array = "persistent_array.rs" 230 16 230 20
  let%span spersistent_array'0 = "persistent_array.rs" 223 19 223 48
  let%span spersistent_array'1 = "persistent_array.rs" 233 13 233 26
  let%span spersistent_array'2 = "persistent_array.rs" 224 18 228 9
  let%span spersistent_array'3 = "persistent_array.rs" 234 57 234 65
  let%span spersistent_array'4 = "persistent_array.rs" 234 58 234 64
  let%span spersistent_array'5 = "persistent_array.rs" 255 12 255 18
  let%span spersistent_array'6 = "persistent_array.rs" 245 19 245 58
  let%span spersistent_array'7 = "persistent_array.rs" 246 8 246 78
  let%span spersistent_array'8 = "persistent_array.rs" 256 13 256 26
  let%span spersistent_array'9 = "persistent_array.rs" 247 18 251 9
  let%span spersistent_array'10 = "persistent_array.rs" 77 16 77 43
  let%span spersistent_array'11 = "persistent_array.rs" 103 16 129 18
  let%span spersistent_array'12 = "persistent_array.rs" 60 16 62 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 122 14 122 32
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 68 14 68 43
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 183 22 183 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 183 4 183 32
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 181 14 181 29
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 171 14 171 26
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 90 8 90 22
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 100 8 100 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 61 20 61 46
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 105 14 105 49
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 265 8 265 24
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 34
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 212 59 212 60
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 204 15 204 46
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 205 15 206 115
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 212 4 214 51
  let%span slocal_invariant'3 = "../../creusot-contracts/src/local_invariant.rs" 208 14 209 124
  let%span slocal_invariant'4 = "../../creusot-contracts/src/local_invariant.rs" 136 8 136 45
  let%span slocal_invariant'5 = "../../creusot-contracts/src/local_invariant.rs" 189 4 191 51
  let%span slocal_invariant'6 = "../../creusot-contracts/src/local_invariant.rs" 189 59 189 60
  let%span slocal_invariant'7 = "../../creusot-contracts/src/local_invariant.rs" 182 15 182 53
  let%span slocal_invariant'8 = "../../creusot-contracts/src/local_invariant.rs" 183 15 186 101
  let%span slocal_invariant'9 = "../../creusot-contracts/src/local_invariant.rs" 187 14 187 117
  let%span slocal_invariant'10 = "../../creusot-contracts/src/local_invariant.rs" 145 8 145 25
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  use set.Set
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0  =
    { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1  =
    { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray  =
    { t_PersistentArray__program_value: t_Rc;
      t_PersistentArray__contained_in_token:  t_Rc'0;
      t_PersistentArray__map_invariant:  t_Rc'1 }
  
  let rec borrow (self: t_Rc'1) (return'  (x: t_Rc'1))= any
    [ return''0 (result: t_Rc'1)-> {[%#sghost] result = self} (! return' {result}) ]
  
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_Id
  
  type t_CompleteMap  =
    { t_CompleteMap__own_map: t_FMap;
      t_CompleteMap__values: t_Authority;
      t_CompleteMap__rank: Map.map t_Id int;
      t_CompleteMap__length: int }
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  type t_Option  =
    | C_None
    | C_Some t_PCellOwn
  
  function view (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option =
    [%#sfmap] Map.get (view self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) =
    [%#sfmap'0] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'2  =
    { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner  =
    | C_Direct t_Vec
    | C_Link UInt64.t t_T t_Rc
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) =
    [%#sboxed'0] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'0 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) =
    [%#svec'0] inv'2 (view'0 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
  = match x with
    | C_Direct a_0 -> inv'3 a_0
    | C_Link index value next -> inv'0 value
    end
  
  predicate invariant''2 (self: t_Inner) =
    [%#sinvariant] inv'4 self
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) =
    [%#spcell] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn =
    [%#sfmap'2] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn =
    [%#sfmap'1] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'3] forall k: t_Id. contains self k  -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
  = (invariant''5 x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate inv'9 (_0: t_CompleteMap)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_CompleteMap [inv'9 x]. inv'9 x
  = match x with
    | {t_CompleteMap__own_map = own_map ; t_CompleteMap__values = values ; t_CompleteMap__rank = rank ; t_CompleteMap__length = length} -> inv'7 own_map
    /\ inv'8 values
    end
  
  predicate invariant''6 (self: MutBorrow.t t_CompleteMap) =
    [%#sinvariant'0] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_CompleteMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_CompleteMap [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sghost'11] inv'10 self
  
  predicate inv'11 (_0:  (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'10 [@rewrite]: forall x:  (MutBorrow.t t_CompleteMap) [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sinvariant] inv'11 self
  
  predicate inv'12 (_0:  (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'11 [@rewrite]: forall x:  (MutBorrow.t t_CompleteMap) [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_CompleteMap) =
    [%#sinvariant] inv'10 self
  
  predicate inv'13 (_0: MutBorrow.t t_CompleteMap)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_CompleteMap [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: (MutBorrow.t t_CompleteMap)) (return'  (x:MutBorrow.t t_CompleteMap))= {[@expl:deref 'self' type invariant] [%#sghost'0] inv'12 self}
    any
    [ return''0 (result:MutBorrow.t t_CompleteMap)-> {[%#sghost'1] inv'13 result}
      {[%#sghost'2] self = result}
      (! return' {result}) ]
  
  
  type closure0  =
    { _0: t_PersistentArray; _1: UInt64.t }
  
  let rec deref'0 (self: t_Rc'0) (return'  (x:t_Rc'0))= any
    [ return''0 (result:t_Rc'0)-> {[%#sghost'2] self = result} (! return' {result}) ]
  
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  predicate invariant''10 (self: t_Fragment)
  
  predicate inv'14 (_0'0: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
  = (invariant''10 x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''11 (self: t_Fragment) =
    [%#sinvariant] inv'14 self
  
  predicate inv'15 (_0'0: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''11 x
  
  function view'1 (self: t_Rc'0) : t_Fragment
  
  let rec as_ref (self_:t_Rc'0) (return'  (x:t_Fragment))= any
    [ return''0 (result:t_Fragment)-> {inv'15 result} {[%#src] result = view'1 self_} (! return' {result}) ]
  
  
  predicate invariant''12 (self: t_Authority) =
    [%#sinvariant] inv'8 self
  
  predicate inv'16 (_0'0: t_Authority)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Authority [inv'16 x]. inv'16 x = invariant''12 x
  
  function id (self: t_Authority) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (Seq.seq t_T)
  
  function view'2 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 =
    [%#sfmap] Map.get (view'2 self) k
  
  function view'3 (self: t_Authority) : t_FMap'0
  
  function view'4 (self: t_Authority) : t_FMap'0 =
    [%#smodel] view'3 self
  
  type tuple  =
    { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view'5 (self: t_Fragment) : tuple
  
  function view'6 (self: t_Fragment) : tuple =
    [%#smodel] view'5 self
  
  let rec contains'0 (self:t_Authority) (frag:t_Fragment) (return'  (x:()))= {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'16 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'15 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id self = id'0 frag}
    any
    [ return''0 (result:())-> {[%#sfmap_view'2] get'0 (view'4 self) (view'6 frag)._p0 = C_Some'0 ((view'6 frag)._p1)}
      (! return' {result}) ]
  
  
  let rec new (x:()) (return'  (x'0: ()))= any
    [ return''0 (result: ())-> {[%#sghost'3] result = x} (! return' {result}) ]
  
  
  let rec into_inner (self: (MutBorrow.t t_CompleteMap)) (return'  (x:MutBorrow.t t_CompleteMap))= {[@expl:into_inner 'self' type invariant] [%#sghost'4] inv'11 self}
    any
    [ return''0 (result:MutBorrow.t t_CompleteMap)-> {[%#sghost'5] inv'10 result}
      {[%#sghost'6] result = self}
      (! return' {result}) ]
  
  
  predicate invariant''13 (self: t_CompleteMap) =
    [%#sinvariant] inv'9 self
  
  predicate inv'17 (_0'0: t_CompleteMap)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_CompleteMap [inv'17 x]. inv'17 x = invariant''13 x
  
  predicate invariant''14 (self:  t_CompleteMap) =
    [%#sghost'11] inv'17 self
  
  predicate inv'18 (_0'0:  t_CompleteMap)
  
  axiom inv_axiom'17 [@rewrite]: forall x:  t_CompleteMap [inv'18 x]. inv'18 x = invariant''14 x
  
  let rec new'0 (x:t_CompleteMap) (return'  (x'0: t_CompleteMap))= {[@expl:new 'x' type invariant] [%#sghost'7] inv'17 x}
    any
    [ return''0 (result: t_CompleteMap)-> {[%#sghost'8] inv'18 result} {[%#sghost'3] result = x} (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_T
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) =
    [%#sfmap'0] get'0 self k <> C_None'0
  
  function id'1 (self: t_PCellOwn) : t_Id
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) =
    [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T =
    [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'2] unwrap_logic'0 (get'0 self k)
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_Inner }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  function id'2 (self: t_PCell) : t_Id
  
  function view'7 (self: t_Rc) : t_PCell
  
  function index_logic'2 (self: Map.map t_Id int) (a: t_Id) : int =
    [%#smapping] Map.get self a
  
  predicate invariant_with_data [#"persistent_array.rs" 101 8 101 52] (self: t_CompleteMap) (id'3: t_Id) =
    [%#spersistent_array'11] id self.t_CompleteMap__values = id'3
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
    = contains'1 (view'3 self.t_CompleteMap__values) id'4)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> id'1 (index_logic'0 self.t_CompleteMap__own_map id'4) = id'4)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> Seq.length (lookup'0 (view'3 self.t_CompleteMap__values) id'4) = self.t_CompleteMap__length)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct _ -> true
      | C_Link _ _ next -> contains self.t_CompleteMap__own_map (id'2 (view'7 next))
      end)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct v -> lookup'0 (view'3 self.t_CompleteMap__values) id'4 = view'0 v
      | C_Link index value next -> let next_id = id'2 (view'7 next) in UInt64.t'int index < self.t_CompleteMap__length
      /\ Seq.get (lookup'0 (view'3 self.t_CompleteMap__values) id'4) (UInt64.t'int index) = value
      /\ (forall j: int. 0 <= j /\ j < self.t_CompleteMap__length /\ j <> UInt64.t'int index
       -> Seq.get (lookup'0 (view'3 self.t_CompleteMap__values) id'4) j
      = Seq.get (lookup'0 (view'3 self.t_CompleteMap__values) next_id) j)
      end)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct _ -> true
      | C_Link _ _ next -> let next_id = id'2 (view'7 next) in index_logic'2 self.t_CompleteMap__rank id'4
      > index_logic'2 self.t_CompleteMap__rank next_id
      end)
  
  function view'8 (self: t_Rc) : t_PCell =
    [%#smodel] view'7 self
  
  predicate invariant''15 (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'19 (_0'0: t_T)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_T [inv'19 x]. inv'19 x = invariant''15 x
  
  predicate inv'20 (_0'0: t_Option'1)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_Option'1 [inv'20 x]. inv'20 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'19 a_0
    end
  
  function index_logic'3 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T =
    [%#sfmap'1] lookup'0 self key
  
  let rec get_inner_immut (inner:t_Rc) (i:UInt64.t) (tokens: t_CompleteMap) (return'  (x:t_Option'1))= {[@expl:get_inner_immut 'tokens' type invariant] [%#spersistent_array'5] inv'18 tokens}
    {[@expl:get_inner_immut requires #0] [%#spersistent_array'6] exists p: t_Id. invariant_with_data tokens p}
    {[@expl:get_inner_immut requires #1] [%#spersistent_array'7] contains tokens.t_CompleteMap__own_map (id'2 (view'8 inner))}
    any
    [ return''0 (result:t_Option'1)-> {[%#spersistent_array'8] inv'20 result}
      {[%#spersistent_array'9] if UInt64.t'int i < tokens.t_CompleteMap__length then
        result
        = C_Some'1 (Seq.get (index_logic'3 (view'3 tokens.t_CompleteMap__values) (id'2 (view'8 inner))) (UInt64.t'int i))
      else
        result = C_None'1
      }
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_CompleteMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0: MutBorrow.t t_CompleteMap) =
    resolve _0'0
  
  function view'9 (self: t_Fragment) : tuple =
    [%#sboxed] view'5 self
  
  function view'10 (self:  t_Rc'0) : t_Fragment =
    [%#sghost'10] view'1 self
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'11 (self: t_Rc'1) : t_LocalInvariant
  
  function view'12 (self:  t_Rc'1) : t_LocalInvariant =
    [%#sghost'10] view'11 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''16 [#"persistent_array.rs" 57 8 57 34] (self: t_PersistentArray) =
    [%#spersistent_array'12] (view'9 (view'10 self.t_PersistentArray__contained_in_token))._p0
    = id'2 (view'7 self.t_PersistentArray__program_value)
    /\ id'0 (view'10 self.t_PersistentArray__contained_in_token)
    = public (view'12 self.t_PersistentArray__map_invariant)
    /\ namespace (view'12 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv'21 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_PersistentArray [inv'21 x]. inv'21 x
  = (invariant''16 x
  /\ match x with
    | {t_PersistentArray__program_value = program_value ; t_PersistentArray__contained_in_token = contained_in_token ; t_PersistentArray__map_invariant = map_invariant} -> true
    end)
  
  predicate invariant''17 (self: t_PersistentArray) =
    [%#sinvariant] inv'21 self
  
  predicate inv'22 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_PersistentArray [inv'22 x]. inv'22 x = invariant''17 x
  
  predicate invariant''18 (self: t_PersistentArray) =
    [%#sinvariant] inv'22 self
  
  predicate inv'23 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_PersistentArray [inv'23 x]. inv'23 x = invariant''18 x
  
  predicate inv'24 (_0'0: closure0)
  
  axiom inv_axiom'23 [@rewrite]: forall x: closure0 [inv'24 x]. inv'24 x = (let {_0 = x0 ; _1 = x1} = x in inv'23 x0)
  
  let rec closure0[#"persistent_array.rs" 234 57 234 65] [@coma:extspec] (self:closure0) (tokens: (MutBorrow.t t_CompleteMap)) (return'  (x:t_Option'1))= bb0
    [ bb0 = s0 [ s0 = deref {tokens'0} (fun (_ret:MutBorrow.t t_CompleteMap) ->  [ &_7 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = deref'0 {(_1'0._0).t_PersistentArray__contained_in_token} (fun (_ret:t_Rc'0) ->  [ &_12 <- _ret ] s1)
      | s1 = bb2 ]
    
    | bb2 = s0 [ s0 = as_ref {_12} (fun (_ret:t_Fragment) ->  [ &_10 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = contains'0 {(_7.current).t_CompleteMap__values} {_10} (fun (_ret:()) ->  [ &_5 <- _ret ] s1) | s1 = bb4 ]
    
    | bb4 = s0 [ s0 = new {_4} (fun (_ret: ()) ->  [ &_3 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_15 <- (_1'0._0).t_PersistentArray__program_value ] s1
      | s1 = into_inner {tokens'0} (fun (_ret:MutBorrow.t t_CompleteMap) ->  [ &_19 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0 [ s0 = new'0 {_19.current} (fun (_ret: t_CompleteMap) ->  [ &_17 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = get_inner_immut {_15} {_1'0._1} {_17} (fun (_ret:t_Option'1) ->  [ &_0'0 <- _ret ] s1) | s1 = bb8 ]
    
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'10 _19} s1 | s1 = -{resolve'0 _19}- s2 | s2 = return' {_0'0} ]  ]
    
    [ & _0'0: t_Option'1 = Any.any_l ()
    | & _1'0: closure0 = self
    | & tokens'0:  (MutBorrow.t t_CompleteMap) = tokens
    | & _3:  () = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _5: () = Any.any_l ()
    | & _7: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _10: t_Fragment = Any.any_l ()
    | & _12: t_Rc'0 = Any.any_l ()
    | & _15: t_Rc = Any.any_l ()
    | & _17:  t_CompleteMap = Any.any_l ()
    | & _19: MutBorrow.t t_CompleteMap = Any.any_l () ]
  
  
  type t_Namespaces
  
  predicate precondition (self: ()) (args: t_Rc'1) =
    let self_ = args in true
  
  let rec deref'1 (self_:t_Rc'1) (return'  (x:t_LocalInvariant))= any
    [ return''0 (result:t_LocalInvariant)-> {[%#src'0] result = view'11 self_} (! return' {result}) ]
  
  
  predicate postcondition_once (self: ()) (args: t_Rc'1) (result: t_LocalInvariant) =
    let self_ = args in result = view'11 self_
  
  predicate resolve'1 (_0'0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: t_Rc'1) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view'11 self_
  
  function fn_mut_once (self: ()) (args: t_Rc'1) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_Rc'1, res: t_LocalInvariant. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc'1) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_Rc'1, res_state: (), res: t_LocalInvariant. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_Rc'1) (result: t_LocalInvariant) =
    let self_ = args in result = view'11 self_
  
  function fn_once (self: ()) (args: t_Rc'1) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc'1, res: t_LocalInvariant. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'1 self)
  
  function fn_mut (self: ()) (args: t_Rc'1) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_Rc'1, res_state: (), res: t_LocalInvariant. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  type tuple'0  =
    { _p0'0:  t_LocalInvariant; _p1'0:  t_Namespaces; _p2: closure0 }
  
  predicate precondition'0 (self: closure0) (args:  (MutBorrow.t t_CompleteMap)) =
    [%#spersistent_array'3] let tokens = args in closure0'pre self tokens
  
  predicate postcondition_once'0 (self: closure0) (args:  (MutBorrow.t t_CompleteMap)) (result: t_Option'1) =
    [%#spersistent_array'3] let tokens = args in closure0'post'return' self tokens result
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) =
    [%#sset] Set.mem e self
  
  function namespaces (self: t_Namespaces) : Set.set t_Namespace
  
  function view'13 (self: t_Namespaces) : Set.set t_Namespace =
    [%#slocal_invariant'10] namespaces self
  
  function view'14 (self:  t_Namespaces) : Set.set t_Namespace =
    [%#sghost'10] view'13 self
  
  predicate precondition'1 (self: ()) (args: tuple'0) =
    [%#slocal_invariant'5] let {_p0'0 = self'0 ; _p1'0 = namespaces'0 ; _p2 = f} = args in (forall t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ inv'11 t
     -> precondition'0 f t
    /\ (forall res: t_Option'1. postcondition_once'0 f t res  -> invariant_with_data t.final (public self'0)))
    /\ contains'2 (view'14 namespaces'0) (namespace self'0) /\ inv'24 f
  
  let rec open (self: t_LocalInvariant) (namespaces'0: t_Namespaces) (f:closure0) (return'  (x:t_Option'1))= {[@expl:open 'f' type invariant] [%#slocal_invariant'6] inv'24 f}
    {[@expl:open requires #0] [%#slocal_invariant'7] contains'2 (view'14 namespaces'0) (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'8] forall t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self)
    /\ inv'11 t
     -> precondition'0 f t
    /\ (forall res: t_Option'1. postcondition_once'0 f t res  -> invariant_with_data t.final (public self))}
    any
    [ return''0 (result:t_Option'1)-> {[%#slocal_invariant'5] inv'20 result}
      {[%#slocal_invariant'9] exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self)
      /\ postcondition_once'0 f t result}
      (! return' {result}) ]
  
  
  function new_logic (x: t_LocalInvariant) :  t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. [%#sghost'9] new_logic x = x
  
  predicate postcondition_once'1 (self: ()) (args: tuple'0) (result: t_Option'1) =
    [%#slocal_invariant'5] let {_p0'0 = self'0 ; _p1'0 = namespaces'0 ; _p2 = f} = args in (exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result)
    /\ inv'20 result
  
  predicate resolve'2 (_0'0: ()) =
    true
  
  predicate postcondition_mut'0 (self: ()) (args: tuple'0) (result_state: ()) (result: t_Option'1) =
    [%#slocal_invariant'5] let {_p0'0 = self'0 ; _p1'0 = namespaces'0 ; _p2 = f} = args in (exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result)
    /\ inv'20 result
  
  function fn_mut_once'0 (self: ()) (args: tuple'0) (res: t_Option'1) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'0, res: t_Option'1. [%#sops'8] postcondition_once'1 self args res
  = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'2 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'0) (res_state: ()) (res: t_Option'1) : ()
  
  axiom postcondition_mut_hist_inv_spec'0: forall self: (), args: tuple'0, res_state: (), res: t_Option'1. ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple'0) (result: t_Option'1) =
    [%#slocal_invariant'5] let {_p0'0 = self'0 ; _p1'0 = namespaces'0 ; _p2 = f} = args in (exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result)
    /\ inv'20 result
  
  function fn_once'0 (self: ()) (args: tuple'0) (res: t_Option'1) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'0, res: t_Option'1. [%#sops'0] postcondition_once'1 self args res
  = (postcondition'0 self args res /\ resolve'2 self)
  
  function fn_mut'0 (self: ()) (args: tuple'0) (res_state: ()) (res: t_Option'1) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: tuple'0, res_state: (), res: t_Option'1. [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc'1) (namespaces'0: t_Namespaces) (f:closure0) (return'  (x:t_Option'1))= {[@expl:open 'f' type invariant] [%#slocal_invariant] inv'24 f}
    {[@expl:open requires #0] [%#slocal_invariant'0] precondition () self}
    {[@expl:open requires #1] [%#slocal_invariant'1] forall this: t_LocalInvariant. postcondition () self this
     -> precondition'1 () { _p0'0 = new_logic this; _p1'0 = namespaces'0; _p2 = f }}
    any
    [ return''0 (result:t_Option'1)-> {[%#slocal_invariant'2] inv'20 result}
      {[%#slocal_invariant'3] exists this: t_LocalInvariant. postcondition () self this
      /\ postcondition'0 () { _p0'0 = new_logic this; _p1'0 = namespaces'0; _p2 = f } result}
      (! return' {result}) ]
  
  
  predicate contains'3 (self: t_Namespaces) (namespace'0: t_Namespace) =
    [%#slocal_invariant'4] contains'2 (namespaces self) namespace'0
  
  function view'15 [#"persistent_array.rs" 75 8 75 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'10] (view'9 (view'10 self.t_PersistentArray__contained_in_token))._p1
  
  function view'16 (self: t_PersistentArray) : Seq.seq t_T =
    [%#smodel] view'15 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_immut[#"persistent_array.rs" 229 8 233 26] (self:t_PersistentArray) (i:UInt64.t) (namespaces'0: t_Namespaces) (return'  (x:t_Option'1))= {[@expl:get_immut 'self' type invariant] [%#spersistent_array] inv'22 self}
    {[@expl:get_immut requires] [%#spersistent_array'0] contains'3 namespaces'0 (Namespace_PARRAY_0'62 0)}
    (! bb0
    [ bb0 = s0
      [ s0 = borrow {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc'1) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- { _0 = self'0; _1 = i'0 } ] s1
      | s1 = open'0 {_6} {namespaces'1} {_9} (fun (_ret:t_Option'1) ->  [ &_0'0 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = return''0 {_0'0} ]
    
    [ & _0'0: t_Option'1 = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & i'0: UInt64.t = i
    | & namespaces'1:  t_Namespaces = namespaces'0
    | & _6:  t_Rc'1 = Any.any_l ()
    | & _9: closure0 = Any.any_l () ]
    )
    [ return''0 (result:t_Option'1)-> {[@expl:get_immut result type invariant] [%#spersistent_array'1] inv'20 result}
      {[@expl:get_immut ensures] [%#spersistent_array'2] result
      = (if UInt64.t'int i < Seq.length (view'16 self) then
        C_Some'1 (Seq.get (view'16 self) (UInt64.t'int i))
      else
        C_None'1
      )}
      (! return' {result}) ]

end
module M_persistent_array__implementation__qyi7256199225841846155__get_inner_immut [#"persistent_array.rs" 252 8 256 26] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span spersistent_array = "persistent_array.rs" 257 21 257 49
  let%span spersistent_array'0 = "persistent_array.rs" 255 12 255 18
  let%span spersistent_array'1 = "persistent_array.rs" 245 19 245 58
  let%span spersistent_array'2 = "persistent_array.rs" 246 8 246 78
  let%span spersistent_array'3 = "persistent_array.rs" 256 13 256 26
  let%span spersistent_array'4 = "persistent_array.rs" 247 18 251 9
  let%span spersistent_array'5 = "persistent_array.rs" 103 16 129 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 68 14 68 43
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 90 8 90 22
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 100 8 100 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 166 16 166 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 167 26 167 42
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 166 33 166 37
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 166 39 166 43
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 164 15 164 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 166 4 166 77
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 165 14 165 30
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 36 8 36 19
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 61 20 61 46
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 344 22 344 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 344 4 344 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 343 14 343 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 265 8 265 24
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 34
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 280 8 280 9
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 280 18 280 96
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 281 18 281 55
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 110 20 110 37
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 117 20 117 37
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 20 20 20 30
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use map.Map
  use seq.Seq
  use mach.int.Int
  use creusot.slice.Slice64
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Inner  =
    | C_Direct t_Vec
    | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_Inner }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  type t_Id
  
  function id (self: t_PCell) : t_Id
  
  function view (self: t_Rc) : t_PCell
  
  function view'0 (self: t_Rc) : t_PCell =
    [%#smodel] view self
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_CompleteMap  =
    { t_CompleteMap__own_map: t_FMap;
      t_CompleteMap__values: t_Authority;
      t_CompleteMap__rank: Map.map t_Id int;
      t_CompleteMap__length: int }
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  type t_Option  =
    | C_None
    | C_Some t_PCellOwn
  
  function view'1 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option =
    [%#sfmap'4] Map.get (view'1 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) =
    [%#sfmap'2] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'1] Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) =
    [%#svec'2] inv'2 (view'2 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
  = match x with
    | C_Direct a_0 -> inv'3 a_0
    | C_Link index value next -> inv'0 value
    end
  
  predicate invariant''2 (self: t_Inner) =
    [%#sinvariant] inv'4 self
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) =
    [%#spcell'5] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn =
    [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn =
    [%#sfmap'5] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn =
    [%#sfmap'3] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'6] forall k: t_Id. contains self k  -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
  = (invariant''5 x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate inv'9 (_0: t_CompleteMap)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_CompleteMap [inv'9 x]. inv'9 x
  = match x with
    | {t_CompleteMap__own_map = own_map ; t_CompleteMap__values = values ; t_CompleteMap__rank = rank ; t_CompleteMap__length = length} -> inv'7 own_map
    /\ inv'8 values
    end
  
  predicate invariant''6 (self: t_CompleteMap) =
    [%#sinvariant] inv'9 self
  
  predicate inv'10 (_0: t_CompleteMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_CompleteMap [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self:  t_CompleteMap) =
    [%#sghost'6] inv'10 self
  
  predicate inv'11 (_0:  t_CompleteMap)
  
  axiom inv_axiom'10 [@rewrite]: forall x:  t_CompleteMap [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self:  t_CompleteMap) =
    [%#sinvariant] inv'11 self
  
  predicate inv'12 (_0:  t_CompleteMap)
  
  axiom inv_axiom'11 [@rewrite]: forall x:  t_CompleteMap [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: t_CompleteMap) =
    [%#sinvariant] inv'10 self
  
  predicate inv'13 (_0: t_CompleteMap)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_CompleteMap [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: t_CompleteMap) (return'  (x:t_CompleteMap))= {[@expl:deref 'self' type invariant] [%#sghost] inv'12 self}
    any
    [ return''0 (result:t_CompleteMap)-> {[%#sghost'0] inv'13 result}
      {[%#sghost'1] self = result}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PCellOwn
  
  predicate invariant''10 (self: t_FMap) =
    [%#sinvariant] inv'7 self
  
  predicate inv'14 (_0: t_FMap)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_FMap [inv'14 x]. inv'14 x = invariant''10 x
  
  predicate invariant''11 (self: t_PCellOwn) =
    [%#sinvariant] inv'6 self
  
  predicate inv'15 (_0: t_PCellOwn)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_PCellOwn [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate inv'16 (_0: t_Option'0)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Option'0 [inv'16 x]. inv'16 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'15 a_0
    end
  
  function map_logic (self: t_Option) (f: Map.map t_PCellOwn t_PCellOwn) : t_Option'0 =
    [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self:t_FMap) (key:t_Id) (return'  (x:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'14 self}
    any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'0] inv'16 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PCellOwn) -> v)}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:t_PCellOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'16 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any
    [ return''0 (result:t_PCellOwn)-> {inv'15 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  
  predicate invariant''12 (self:  t_PCellOwn) =
    [%#sghost'6] inv'15 self
  
  predicate inv'17 (_0:  t_PCellOwn)
  
  axiom inv_axiom'16 [@rewrite]: forall x:  t_PCellOwn [inv'17 x]. inv'17 x = invariant''12 x
  
  let rec new (x:t_PCellOwn) (return'  (x'0: t_PCellOwn))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'15 x}
    any
    [ return''0 (result: t_PCellOwn)-> {[%#sghost'3] inv'17 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  predicate inv'18 (_0: t_UnsafeCell)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_UnsafeCell [inv'18 x]. inv'18 x
  = match x with
    | {t_UnsafeCell__value = value} -> inv'4 value
    end
  
  predicate inv'19 (_0: t_PCell)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_PCell [inv'19 x]. inv'19 x
  = match x with
    | {t_PCell__0 = a_0} -> inv'18 a_0
    end
  
  predicate invariant''13 (self: t_PCell) =
    [%#sinvariant] inv'19 self
  
  predicate inv'20 (_0: t_PCell)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PCell [inv'20 x]. inv'20 x = invariant''13 x
  
  let rec as_ref (self_:t_Rc) (return'  (x:t_PCell))= any
    [ return''0 (result:t_PCell)-> {inv'20 result} {[%#src] result = view self_} (! return' {result}) ]
  
  
  function id'0 (self: t_PCellOwn) : t_Id
  
  function view'3 (self: t_PCellOwn) : t_Inner =
    [%#spcell'4] val' self
  
  function view'4 (self: t_PCellOwn) : t_Inner =
    [%#smodel] view'3 self
  
  function view'5 (self:  t_PCellOwn) : t_Inner =
    [%#sghost'5] view'4 self
  
  let rec borrow (self:t_PCell) (perm: t_PCellOwn) (return'  (x:t_Inner))= {[@expl:borrow 'self' type invariant] [%#spcell] inv'20 self}
    {[@expl:borrow 'perm' type invariant] [%#spcell'0] inv'17 perm}
    {[@expl:borrow requires] [%#spcell'1] id self = id'0 perm}
    any
    [ return''0 (result:t_Inner)-> {[%#spcell'2] inv'5 result}
      {[%#spcell'3] result = view'5 perm}
      (! return' {result}) ]
  
  
  let rec v_Link (input:t_Inner) (ret  (index:UInt64.t) (value:t_T) (next:t_Rc))= any
    [ good (index:UInt64.t) (value:t_T) (next:t_Rc)-> {C_Link index value next = input} (! ret {index} {value} {next})
    | bad -> {forall index: UInt64.t, value: t_T, next: t_Rc [C_Link index value next: t_Inner]. C_Link index value next
      <> input}
      (! {false}
      any) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_T
  
  let rec v_Direct (input:t_Inner) (ret  (field_0:t_Vec))= any
    [ good (field_0:t_Vec)-> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  
  predicate invariant''14 (self: t_Vec) =
    [%#sinvariant] inv'3 self
  
  predicate inv'21 (_0: t_Vec)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Vec [inv'21 x]. inv'21 x = invariant''14 x
  
  function view'6 (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'4] Seq.length (view'6 self) <= UInt64.t'int const_MAX
  
  axiom view_spec'1: forall self: Slice64.slice t_T. [%#sslice'5] view'6 self = Slice64.id self
  
  predicate invariant''15 (self: Slice64.slice t_T) =
    [%#sslice'6] inv'2 (view'6 self)
  
  predicate inv'22 (_0: Slice64.slice t_T)
  
  axiom inv_axiom'21 [@rewrite]: forall x: Slice64.slice t_T [inv'22 x]. inv'22 x = invariant''15 x
  
  predicate invariant''16 (self: Slice64.slice t_T) =
    [%#sinvariant] inv'22 self
  
  predicate inv'23 (_0: Slice64.slice t_T)
  
  axiom inv_axiom'22 [@rewrite]: forall x: Slice64.slice t_T [inv'23 x]. inv'23 x = invariant''16 x
  
  function view'7 (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view'6 self
  
  function view'8 (self: t_Vec) : Seq.seq t_T =
    [%#smodel] view'2 self
  
  let rec deref'0 (self_:t_Vec) (return'  (x:Slice64.slice t_T))= {[@expl:deref 'self_' type invariant] [%#svec] inv'21 self_}
    any
    [ return''0 (result:Slice64.slice t_T)-> {inv'23 result}
      {[%#svec'0] view'7 result = view'8 self_}
      (! return' {result}) ]
  
  
  predicate invariant''17 (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'24 (_0: t_T)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_T [inv'24 x]. inv'24 x = invariant''17 x
  
  predicate inv'25 (_0: t_Option'1)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_Option'1 [inv'25 x]. inv'25 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'24 a_0
    end
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice'2] UInt64.t'int self < Seq.length seq
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'3] Seq.get seq (UInt64.t'int self) = out
  
  let rec get'0 (self_:Slice64.slice t_T) (ix:UInt64.t) (return'  (x:t_Option'1))= {[@expl:get 'self_' type invariant] [%#sslice] inv'23 self_}
    any
    [ return''0 (result:t_Option'1)-> {inv'25 result}
      {[%#sslice'0] in_bounds ix (view'7 self_)
       -> (exists r: t_T. result = C_Some'1 r /\ has_value ix (view'7 self_) r)}
      {[%#sslice'1] in_bounds ix (view'7 self_) \/ result = C_None'1}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option'1) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some'1 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some'1 field_0: t_Option'1]. C_Some'1 field_0 <> input} (! {false} any) ]
  
  
  function id'1 (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (Seq.seq t_T)
  
  function view'9 (self: t_FMap'0) : Map.map t_Id t_Option'2
  
  function get'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'2 =
    [%#sfmap'4] Map.get (view'9 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) =
    [%#sfmap'2] get'1 self k <> C_None'2
  
  function view'10 (self: t_Authority) : t_FMap'0
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) =
    [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'2) : Seq.seq t_T =
    [%#soption'4] match self with
      | C_Some'2 x -> x
      | C_None'2 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'5] unwrap_logic'0 (get'1 self k)
  
  function index_logic'2 (self: Map.map t_Id int) (a: t_Id) : int =
    [%#smapping] Map.get self a
  
  predicate invariant_with_data [#"persistent_array.rs" 101 8 101 52] (self: t_CompleteMap) (id'2: t_Id) =
    [%#spersistent_array'5] id'1 self.t_CompleteMap__values = id'2
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
    = contains'0 (view'10 self.t_CompleteMap__values) id'3)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> id'0 (index_logic'0 self.t_CompleteMap__own_map id'3) = id'3)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> Seq.length (lookup'0 (view'10 self.t_CompleteMap__values) id'3) = self.t_CompleteMap__length)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'3) with
      | C_Direct _ -> true
      | C_Link _ _ next -> contains self.t_CompleteMap__own_map (id (view next))
      end)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'3) with
      | C_Direct v -> lookup'0 (view'10 self.t_CompleteMap__values) id'3 = view'2 v
      | C_Link index value next -> let next_id = id (view next) in UInt64.t'int index < self.t_CompleteMap__length
      /\ Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) id'3) (UInt64.t'int index) = value
      /\ (forall j: int. 0 <= j /\ j < self.t_CompleteMap__length /\ j <> UInt64.t'int index
       -> Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) id'3) j
      = Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) next_id) j)
      end)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'3) with
      | C_Direct _ -> true
      | C_Link _ _ next -> let next_id = id (view next) in index_logic'2 self.t_CompleteMap__rank id'3
      > index_logic'2 self.t_CompleteMap__rank next_id
      end)
  
  function index_logic'3 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T =
    [%#sfmap'3] lookup'0 self key
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_inner_immut[#"persistent_array.rs" 252 8 256 26] (inner:t_Rc) (i:UInt64.t) (tokens: t_CompleteMap) (return'  (x:t_Option'1))= {[@expl:get_inner_immut 'tokens' type invariant] [%#spersistent_array'0] inv'11 tokens}
    {[@expl:get_inner_immut requires #0] [%#spersistent_array'1] exists p: t_Id. invariant_with_data tokens p}
    {[@expl:get_inner_immut requires #1] [%#spersistent_array'2] contains tokens.t_CompleteMap__own_map (id (view'0 inner))}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &id'2 <- [%#spersistent_array] id (view'0 inner'0) ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = deref {tokens'0} (fun (_ret:t_CompleteMap) ->  [ &_13 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_16 <- id'2 ] s1
      | s1 = get_ghost {_13.t_CompleteMap__own_map} {_16} (fun (_ret:t_Option'0) ->  [ &_11 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap {_11} (fun (_ret:t_PCellOwn) ->  [ &_10 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new {_10} (fun (_ret: t_PCellOwn) ->  [ &perm <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = as_ref {inner'0} (fun (_ret:t_PCell) ->  [ &_19 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = borrow {_19} {perm} (fun (_ret:t_Inner) ->  [ &inner'1 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = any
      [ br0 (x0:t_Vec)-> {inner'1 = C_Direct x0} (! bb11)
      | br1 (x0:UInt64.t) (x1:t_T) (x2:t_Rc)-> {inner'1 = C_Link x0 x1 x2} (! bb10) ]
    
    | bb10 = s0
      [ s0 = v_Link {inner'1} (fun (rindex:UInt64.t) (rvalue:t_T) (rnext:t_Rc) ->  [ &index <- rindex ] s1)
      | s1 = v_Link {inner'1} (fun (rindex:UInt64.t) (rvalue:t_T) (rnext:t_Rc) ->  [ &value <- rvalue ] s2)
      | s2 = v_Link {inner'1} (fun (rindex:UInt64.t) (rvalue:t_T) (rnext:t_Rc) ->  [ &next <- rnext ] s3)
      | s3 =  [ &_35 <- i'0 = index ] s4
      | s4 = any [ br0 -> {_35 = false} (! bb20) | br1 -> {_35} (! bb19) ]  ]
    
    | bb19 = s0 [ s0 =  [ &_0 <- C_Some'1 value ] s1 | s1 = bb23 ] 
    | bb20 = s0
      [ s0 = get_inner_immut {next} {i'0} {tokens'0} (fun (_ret:t_Option'1) ->  [ &_0 <- _ret ] s1) | s1 = bb23 ]
    
    | bb11 = s0
      [ s0 = v_Direct {inner'1} (fun (r0:t_Vec) ->  [ &v <- r0 ] s1)
      | s1 = deref'0 {v} (fun (_ret:Slice64.slice t_T) ->  [ &_26 <- _ret ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0 [ s0 = get'0 {_26} {i'0} (fun (_ret:t_Option'1) ->  [ &_24 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_24 = C_None'1} (! bb17) | br1 (x0:t_T)-> {_24 = C_Some'1 x0} (! bb16) ] 
    | bb16 = s0 [ s0 = v_Some {_24} (fun (r0:t_T) ->  [ &x <- r0 ] s1) | s1 =  [ &_0 <- C_Some'1 x ] s2 | s2 = bb23 ] 
    | bb17 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb23 ] 
    | bb23 = return''0 {_0} ]
    
    [ & _0: t_Option'1 = Any.any_l ()
    | & inner'0: t_Rc = inner
    | & i'0: UInt64.t = i
    | & tokens'0:  t_CompleteMap = tokens
    | & id'2: t_Id = Any.any_l ()
    | & perm:  t_PCellOwn = Any.any_l ()
    | & _10: t_PCellOwn = Any.any_l ()
    | & _11: t_Option'0 = Any.any_l ()
    | & _13: t_CompleteMap = Any.any_l ()
    | & _16: t_Id = Any.any_l ()
    | & inner'1: t_Inner = Any.any_l ()
    | & _19: t_PCell = Any.any_l ()
    | & v: t_Vec = Any.any_l ()
    | & _24: t_Option'1 = Any.any_l ()
    | & _26: Slice64.slice t_T = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & index: UInt64.t = Any.any_l ()
    | & value: t_T = Any.any_l ()
    | & next: t_Rc = Any.any_l ()
    | & _35: bool = Any.any_l () ]
    )
    [ return''0 (result:t_Option'1)-> {[@expl:get_inner_immut result type invariant] [%#spersistent_array'3] inv'25 result}
      {[@expl:get_inner_immut ensures] [%#spersistent_array'4] if UInt64.t'int i < tokens.t_CompleteMap__length then
        result
        = C_Some'1 (Seq.get (index_logic'3 (view'10 tokens.t_CompleteMap__values) (id (view'0 inner))) (UInt64.t'int i))
      else
        result = C_None'1
      }
      (! return' {result}) ]

end
module M_persistent_array__implementation__qyi7256199225841846155__get [#"persistent_array.rs" 288 8 292 26] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 50 18 50 38
  let%span spersistent_array = "persistent_array.rs" 293 25 293 64
  let%span spersistent_array'0 = "persistent_array.rs" 289 16 289 20
  let%span spersistent_array'1 = "persistent_array.rs" 282 19 282 48
  let%span spersistent_array'2 = "persistent_array.rs" 292 13 292 26
  let%span spersistent_array'3 = "persistent_array.rs" 283 18 287 9
  let%span spersistent_array'4 = "persistent_array.rs" 300 25 300 66
  let%span spersistent_array'5 = "persistent_array.rs" 294 57 294 69
  let%span spersistent_array'6 = "persistent_array.rs" 294 62 294 68
  let%span spersistent_array'7 = "persistent_array.rs" 334 16 334 22
  let%span spersistent_array'8 = "persistent_array.rs" 316 19 316 60
  let%span spersistent_array'9 = "persistent_array.rs" 317 8 317 78
  let%span spersistent_array'10 = "persistent_array.rs" 318 18 318 76
  let%span spersistent_array'11 = "persistent_array.rs" 319 18 319 107
  let%span spersistent_array'12 = "persistent_array.rs" 320 18 320 68
  let%span spersistent_array'13 = "persistent_array.rs" 321 18 321 68
  let%span spersistent_array'14 = "persistent_array.rs" 322 18 324 83
  let%span spersistent_array'15 = "persistent_array.rs" 326 18 329 9
  let%span spersistent_array'16 = "persistent_array.rs" 330 18 330 76
  let%span spersistent_array'17 = "persistent_array.rs" 77 16 77 43
  let%span spersistent_array'18 = "persistent_array.rs" 103 16 129 18
  let%span spersistent_array'19 = "persistent_array.rs" 60 16 62 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 90 8 90 22
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 122 14 122 32
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 68 14 68 43
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 80 22 80 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 80 4 80 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 79 14 79 35
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 183 22 183 26
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 183 4 183 32
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 181 14 181 29
  let%span sghost'13 = "../../creusot-contracts/src/ghost.rs" 171 14 171 26
  let%span sghost'14 = "../../creusot-contracts/src/ghost.rs" 100 8 100 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 166 16 166 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 167 26 167 42
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 166 33 166 37
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 166 39 166 43
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 164 15 164 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 166 4 166 77
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 165 14 165 30
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 36 8 36 19
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 61 20 61 46
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 105 14 105 49
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 344 22 344 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 344 4 344 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 343 14 343 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 265 8 265 24
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 34
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 212 59 212 60
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 204 15 204 46
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 205 15 206 115
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 212 4 214 51
  let%span slocal_invariant'3 = "../../creusot-contracts/src/local_invariant.rs" 208 14 209 124
  let%span slocal_invariant'4 = "../../creusot-contracts/src/local_invariant.rs" 136 8 136 45
  let%span slocal_invariant'5 = "../../creusot-contracts/src/local_invariant.rs" 189 4 191 51
  let%span slocal_invariant'6 = "../../creusot-contracts/src/local_invariant.rs" 189 59 189 60
  let%span slocal_invariant'7 = "../../creusot-contracts/src/local_invariant.rs" 182 15 182 53
  let%span slocal_invariant'8 = "../../creusot-contracts/src/local_invariant.rs" 183 15 186 101
  let%span slocal_invariant'9 = "../../creusot-contracts/src/local_invariant.rs" 187 14 187 117
  let%span slocal_invariant'10 = "../../creusot-contracts/src/local_invariant.rs" 145 8 145 25
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 280 8 280 9
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 280 18 280 96
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 281 18 281 55
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 110 20 110 37
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 117 20 117 37
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 20 20 20 30
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use set.Set
  
  type t_LocalInvariant
  
  type t_Id
  
  function public (self: t_LocalInvariant) : t_Id
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  function view (self: t_Rc) : t_LocalInvariant
  
  function view'0 (self:  t_Rc) : t_LocalInvariant =
    [%#sghost] view self
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0  =
    { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1  =
    { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray  =
    { t_PersistentArray__program_value: t_Rc'0;
      t_PersistentArray__contained_in_token:  t_Rc'1;
      t_PersistentArray__map_invariant:  t_Rc }
  
  let rec borrow (self: t_Rc) (return'  (x: t_Rc))= any
    [ return''0 (result: t_Rc)-> {[%#sghost'0] result = self} (! return' {result}) ]
  
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_CompleteMap  =
    { t_CompleteMap__own_map: t_FMap;
      t_CompleteMap__values: t_Authority;
      t_CompleteMap__rank: Map.map t_Id int;
      t_CompleteMap__length: int }
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  type t_Option  =
    | C_None
    | C_Some t_PCellOwn
  
  function view'1 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option =
    [%#sfmap'2] Map.get (view'1 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) =
    [%#sfmap'3] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'2  =
    { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner  =
    | C_Direct t_Vec
    | C_Link UInt64.t t_T t_Rc'0
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) =
    [%#sboxed'0] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'1] Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) =
    [%#svec'2] inv'2 (view'2 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
  = match x with
    | C_Direct a_0 -> inv'3 a_0
    | C_Link index value next -> inv'0 value
    end
  
  predicate invariant''2 (self: t_Inner) =
    [%#sinvariant] inv'4 self
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) =
    [%#spcell'5] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn =
    [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn =
    [%#sfmap'5] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn =
    [%#sfmap'4] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'6] forall k: t_Id. contains self k  -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
  = (invariant''5 x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate inv'9 (_0: t_CompleteMap)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_CompleteMap [inv'9 x]. inv'9 x
  = match x with
    | {t_CompleteMap__own_map = own_map ; t_CompleteMap__values = values ; t_CompleteMap__rank = rank ; t_CompleteMap__length = length} -> inv'7 own_map
    /\ inv'8 values
    end
  
  predicate invariant''6 (self: MutBorrow.t t_CompleteMap) =
    [%#sinvariant'0] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_CompleteMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_CompleteMap [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sghost'14] inv'10 self
  
  predicate inv'11 (_0:  (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'10 [@rewrite]: forall x:  (MutBorrow.t t_CompleteMap) [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sinvariant] inv'11 self
  
  predicate inv'12 (_0:  (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'11 [@rewrite]: forall x:  (MutBorrow.t t_CompleteMap) [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_CompleteMap) =
    [%#sinvariant] inv'10 self
  
  predicate inv'13 (_0: MutBorrow.t t_CompleteMap)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_CompleteMap [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: (MutBorrow.t t_CompleteMap)) (return'  (x:MutBorrow.t t_CompleteMap))= {[@expl:deref 'self' type invariant] [%#sghost'1] inv'12 self}
    any
    [ return''0 (result:MutBorrow.t t_CompleteMap)-> {[%#sghost'2] inv'13 result}
      {[%#sghost'3] self = result}
      (! return' {result}) ]
  
  
  type closure0  =
    { _0: t_PersistentArray; _1: t_Id; _2: UInt64.t }
  
  let rec deref'0 (self: t_Rc'1) (return'  (x:t_Rc'1))= any
    [ return''0 (result:t_Rc'1)-> {[%#sghost'3] self = result} (! return' {result}) ]
  
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  predicate invariant''10 (self: t_Fragment)
  
  predicate inv'14 (_0'0: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
  = (invariant''10 x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''11 (self: t_Fragment) =
    [%#sinvariant] inv'14 self
  
  predicate inv'15 (_0'0: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''11 x
  
  function view'3 (self: t_Rc'1) : t_Fragment
  
  let rec as_ref (self_:t_Rc'1) (return'  (x:t_Fragment))= any
    [ return''0 (result:t_Fragment)-> {inv'15 result} {[%#src] result = view'3 self_} (! return' {result}) ]
  
  
  predicate invariant''12 (self: t_Authority) =
    [%#sinvariant] inv'8 self
  
  predicate inv'16 (_0'0: t_Authority)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Authority [inv'16 x]. inv'16 x = invariant''12 x
  
  function id (self: t_Authority) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (Seq.seq t_T)
  
  function view'4 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 =
    [%#sfmap'2] Map.get (view'4 self) k
  
  function view'5 (self: t_Authority) : t_FMap'0
  
  function view'6 (self: t_Authority) : t_FMap'0 =
    [%#smodel] view'5 self
  
  type tuple  =
    { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view'7 (self: t_Fragment) : tuple
  
  function view'8 (self: t_Fragment) : tuple =
    [%#smodel] view'7 self
  
  let rec contains'0 (self:t_Authority) (frag:t_Fragment) (return'  (x:()))= {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'16 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'15 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id self = id'0 frag}
    any
    [ return''0 (result:())-> {[%#sfmap_view'2] get'0 (view'6 self) (view'8 frag)._p0 = C_Some'0 ((view'8 frag)._p1)}
      (! return' {result}) ]
  
  
  let rec new (x:()) (return'  (x'0: ()))= any
    [ return''0 (result: ())-> {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  predicate invariant''13 (self: MutBorrow.t ( (MutBorrow.t t_CompleteMap))) =
    [%#sinvariant'0] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'17 (_0'0: MutBorrow.t ( (MutBorrow.t t_CompleteMap)))
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) [inv'17 x]. inv'17 x
  = invariant''13 x
  
  predicate invariant''14 (self: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    [%#sinvariant'0] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'18 (_0'0: MutBorrow.t (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_CompleteMap) [inv'18 x]. inv'18 x
  = invariant''14 x
  
  let rec deref_mut (self:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) (return'  (x:MutBorrow.t (MutBorrow.t t_CompleteMap)))= {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'17 self}
    any
    [ return''0 (result:MutBorrow.t (MutBorrow.t t_CompleteMap))-> {[%#sghost'6] inv'18 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  
  let rec new'0 (x:MutBorrow.t t_CompleteMap) (return'  (x'0: (MutBorrow.t t_CompleteMap)))= {[@expl:new 'x' type invariant] [%#sghost'8] inv'10 x}
    any
    [ return''0 (result: (MutBorrow.t t_CompleteMap))-> {[%#sghost'9] inv'11 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) =
    [%#sfmap'3] get'0 self k <> C_None'0
  
  function id'1 (self: t_PCellOwn) : t_Id
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) =
    [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T =
    [%#soption'4] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'5] unwrap_logic'0 (get'0 self k)
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_Inner }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  function id'2 (self: t_PCell) : t_Id
  
  function view'9 (self: t_Rc'0) : t_PCell
  
  function index_logic'2 (self: Map.map t_Id int) (a: t_Id) : int =
    [%#smapping] Map.get self a
  
  predicate invariant_with_data [#"persistent_array.rs" 101 8 101 52] (self: t_CompleteMap) (id'3: t_Id) =
    [%#spersistent_array'18] id self.t_CompleteMap__values = id'3
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
    = contains'1 (view'5 self.t_CompleteMap__values) id'4)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> id'1 (index_logic'0 self.t_CompleteMap__own_map id'4) = id'4)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> Seq.length (lookup'0 (view'5 self.t_CompleteMap__values) id'4) = self.t_CompleteMap__length)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct _ -> true
      | C_Link _ _ next -> contains self.t_CompleteMap__own_map (id'2 (view'9 next))
      end)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct v -> lookup'0 (view'5 self.t_CompleteMap__values) id'4 = view'2 v
      | C_Link index value next -> let next_id = id'2 (view'9 next) in UInt64.t'int index < self.t_CompleteMap__length
      /\ Seq.get (lookup'0 (view'5 self.t_CompleteMap__values) id'4) (UInt64.t'int index) = value
      /\ (forall j: int. 0 <= j /\ j < self.t_CompleteMap__length /\ j <> UInt64.t'int index
       -> Seq.get (lookup'0 (view'5 self.t_CompleteMap__values) id'4) j
      = Seq.get (lookup'0 (view'5 self.t_CompleteMap__values) next_id) j)
      end)
    /\ (forall id'4: t_Id. contains self.t_CompleteMap__own_map id'4
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'4) with
      | C_Direct _ -> true
      | C_Link _ _ next -> let next_id = id'2 (view'9 next) in index_logic'2 self.t_CompleteMap__rank id'4
      > index_logic'2 self.t_CompleteMap__rank next_id
      end)
  
  function view'10 (self: t_Rc'0) : t_PCell =
    [%#smodel] view'9 self
  
  let rec reroot (inner:t_Rc'0) (invariant_id:t_Id) (tokens: (MutBorrow.t t_CompleteMap)) (return'  (x:int))= {[@expl:reroot 'tokens' type invariant] [%#spersistent_array'7] inv'11 tokens}
    {[@expl:reroot requires #0] [%#spersistent_array'8] invariant_with_data tokens.current invariant_id}
    {[@expl:reroot requires #1] [%#spersistent_array'9] contains (tokens.current).t_CompleteMap__own_map (id'2 (view'10 inner))}
    any
    [ return''0 (result:int)-> {[%#spersistent_array'10] invariant_with_data tokens.final invariant_id}
      {[%#spersistent_array'11] forall id'3: t_Id. contains (tokens.current).t_CompleteMap__own_map id'3
      = contains (tokens.final).t_CompleteMap__own_map id'3}
      {[%#spersistent_array'12] (tokens.current).t_CompleteMap__values = (tokens.final).t_CompleteMap__values}
      {[%#spersistent_array'13] (tokens.current).t_CompleteMap__length = (tokens.final).t_CompleteMap__length}
      {[%#spersistent_array'14] forall id'3: t_Id. index_logic'2 (tokens.current).t_CompleteMap__rank id'3
      > index_logic'2 (tokens.current).t_CompleteMap__rank (id'2 (view'10 inner))
       -> index_logic'2 (tokens.current).t_CompleteMap__rank id'3
      = index_logic'2 (tokens.final).t_CompleteMap__rank id'3
      /\ get (tokens.current).t_CompleteMap__own_map id'3 = get (tokens.final).t_CompleteMap__own_map id'3}
      {[%#spersistent_array'15] match val' (index_logic'0 (tokens.final).t_CompleteMap__own_map (id'2 (view'10 inner))) with
        | C_Direct _ -> true
        | C_Link _ _ _ -> false
        end}
      {[%#spersistent_array'16] result = index_logic'2 (tokens.final).t_CompleteMap__rank (id'2 (view'10 inner))}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    resolve _0'0
  
  predicate resolve'1 (self: MutBorrow.t t_CompleteMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0'0: MutBorrow.t t_CompleteMap) =
    resolve'1 _0'0
  
  let rec into_inner (self: (MutBorrow.t t_CompleteMap)) (return'  (x:MutBorrow.t t_CompleteMap))= {[@expl:into_inner 'self' type invariant] [%#sghost'10] inv'11 self}
    any
    [ return''0 (result:MutBorrow.t t_CompleteMap)-> {[%#sghost'11] inv'10 result}
      {[%#sghost'12] result = self}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_PCellOwn
  
  predicate invariant''15 (self: t_FMap) =
    [%#sinvariant] inv'7 self
  
  predicate inv'19 (_0'0: t_FMap)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_FMap [inv'19 x]. inv'19 x = invariant''15 x
  
  predicate invariant''16 (self: t_PCellOwn) =
    [%#sinvariant] inv'6 self
  
  predicate inv'20 (_0'0: t_PCellOwn)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PCellOwn [inv'20 x]. inv'20 x = invariant''16 x
  
  predicate inv'21 (_0'0: t_Option'1)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Option'1 [inv'21 x]. inv'21 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'20 a_0
    end
  
  function map_logic (self: t_Option) (f: Map.map t_PCellOwn t_PCellOwn) : t_Option'1 =
    [%#soption'2] match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  let rec get_ghost (self:t_FMap) (key:t_Id) (return'  (x:t_Option'1))= {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'19 self}
    any
    [ return''0 (result:t_Option'1)-> {[%#sfmap'0] inv'21 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PCellOwn) -> v)}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'1) (return'  (x:t_PCellOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'21 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result:t_PCellOwn)-> {inv'20 result} {[%#soption'1] C_Some'1 result = self_} (! return' {result}) ]
  
  
  predicate invariant''17 (self:  t_PCellOwn) =
    [%#sghost'14] inv'20 self
  
  predicate inv'22 (_0'0:  t_PCellOwn)
  
  axiom inv_axiom'21 [@rewrite]: forall x:  t_PCellOwn [inv'22 x]. inv'22 x = invariant''17 x
  
  let rec new'1 (x:t_PCellOwn) (return'  (x'0: t_PCellOwn))= {[@expl:new 'x' type invariant] [%#sghost'8] inv'20 x}
    any
    [ return''0 (result: t_PCellOwn)-> {[%#sghost'9] inv'22 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  predicate inv'23 (_0'0: t_UnsafeCell)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_UnsafeCell [inv'23 x]. inv'23 x
  = match x with
    | {t_UnsafeCell__value = value} -> inv'4 value
    end
  
  predicate inv'24 (_0'0: t_PCell)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_PCell [inv'24 x]. inv'24 x
  = match x with
    | {t_PCell__0 = a_0} -> inv'23 a_0
    end
  
  predicate invariant''18 (self: t_PCell) =
    [%#sinvariant] inv'24 self
  
  predicate inv'25 (_0'0: t_PCell)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_PCell [inv'25 x]. inv'25 x = invariant''18 x
  
  let rec as_ref'0 (self_:t_Rc'0) (return'  (x:t_PCell))= any
    [ return''0 (result:t_PCell)-> {inv'25 result} {[%#src] result = view'9 self_} (! return' {result}) ]
  
  
  function view'11 (self: t_PCellOwn) : t_Inner =
    [%#spcell'4] val' self
  
  function view'12 (self: t_PCellOwn) : t_Inner =
    [%#smodel] view'11 self
  
  function view'13 (self:  t_PCellOwn) : t_Inner =
    [%#sghost] view'12 self
  
  let rec borrow'0 (self:t_PCell) (perm: t_PCellOwn) (return'  (x:t_Inner))= {[@expl:borrow 'self' type invariant] [%#spcell] inv'25 self}
    {[@expl:borrow 'perm' type invariant] [%#spcell'0] inv'22 perm}
    {[@expl:borrow requires] [%#spcell'1] id'2 self = id'1 perm}
    any
    [ return''0 (result:t_Inner)-> {[%#spcell'2] inv'5 result}
      {[%#spcell'3] result = view'13 perm}
      (! return' {result}) ]
  
  
  let rec v_Direct (input:t_Inner) (ret  (field_0:t_Vec))= any
    [ good (field_0:t_Vec)-> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  
  predicate invariant''19 (self: t_Vec) =
    [%#sinvariant] inv'3 self
  
  predicate inv'26 (_0'0: t_Vec)
  
  axiom inv_axiom'25 [@rewrite]: forall x: t_Vec [inv'26 x]. inv'26 x = invariant''19 x
  
  function view'14 (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'4] Seq.length (view'14 self) <= UInt64.t'int const_MAX
  
  axiom view_spec'1: forall self: Slice64.slice t_T. [%#sslice'5] view'14 self = Slice64.id self
  
  predicate invariant''20 (self: Slice64.slice t_T) =
    [%#sslice'6] inv'2 (view'14 self)
  
  predicate inv'27 (_0'0: Slice64.slice t_T)
  
  axiom inv_axiom'26 [@rewrite]: forall x: Slice64.slice t_T [inv'27 x]. inv'27 x = invariant''20 x
  
  predicate invariant''21 (self: Slice64.slice t_T) =
    [%#sinvariant] inv'27 self
  
  predicate inv'28 (_0'0: Slice64.slice t_T)
  
  axiom inv_axiom'27 [@rewrite]: forall x: Slice64.slice t_T [inv'28 x]. inv'28 x = invariant''21 x
  
  function view'15 (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view'14 self
  
  function view'16 (self: t_Vec) : Seq.seq t_T =
    [%#smodel] view'2 self
  
  let rec deref'1 (self_:t_Vec) (return'  (x:Slice64.slice t_T))= {[@expl:deref 'self_' type invariant] [%#svec] inv'26 self_}
    any
    [ return''0 (result:Slice64.slice t_T)-> {inv'28 result}
      {[%#svec'0] view'15 result = view'16 self_}
      (! return' {result}) ]
  
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_T
  
  predicate invariant''22 (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'29 (_0'0: t_T)
  
  axiom inv_axiom'28 [@rewrite]: forall x: t_T [inv'29 x]. inv'29 x = invariant''22 x
  
  predicate inv'30 (_0'0: t_Option'2)
  
  axiom inv_axiom'29 [@rewrite]: forall x: t_Option'2 [inv'30 x]. inv'30 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'29 a_0
    end
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice'2] UInt64.t'int self < Seq.length seq
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'3] Seq.get seq (UInt64.t'int self) = out
  
  let rec get'1 (self_:Slice64.slice t_T) (ix:UInt64.t) (return'  (x:t_Option'2))= {[@expl:get 'self_' type invariant] [%#sslice] inv'28 self_}
    any
    [ return''0 (result:t_Option'2)-> {inv'30 result}
      {[%#sslice'0] in_bounds ix (view'15 self_)
       -> (exists r: t_T. result = C_Some'2 r /\ has_value ix (view'15 self_) r)}
      {[%#sslice'1] in_bounds ix (view'15 self_) \/ result = C_None'2}
      (! return' {result}) ]
  
  
  function view'17 (self: t_Fragment) : tuple =
    [%#sboxed] view'7 self
  
  function view'18 (self:  t_Rc'1) : t_Fragment =
    [%#sghost] view'3 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''23 [#"persistent_array.rs" 57 8 57 34] (self: t_PersistentArray) =
    [%#spersistent_array'19] (view'17 (view'18 self.t_PersistentArray__contained_in_token))._p0
    = id'2 (view'9 self.t_PersistentArray__program_value)
    /\ id'0 (view'18 self.t_PersistentArray__contained_in_token) = public (view'0 self.t_PersistentArray__map_invariant)
    /\ namespace (view'0 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv'31 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'30 [@rewrite]: forall x: t_PersistentArray [inv'31 x]. inv'31 x
  = (invariant''23 x
  /\ match x with
    | {t_PersistentArray__program_value = program_value ; t_PersistentArray__contained_in_token = contained_in_token ; t_PersistentArray__map_invariant = map_invariant} -> true
    end)
  
  predicate invariant''24 (self: t_PersistentArray) =
    [%#sinvariant] inv'31 self
  
  predicate inv'32 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'31 [@rewrite]: forall x: t_PersistentArray [inv'32 x]. inv'32 x = invariant''24 x
  
  predicate invariant''25 (self: t_PersistentArray) =
    [%#sinvariant] inv'32 self
  
  predicate inv'33 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'32 [@rewrite]: forall x: t_PersistentArray [inv'33 x]. inv'33 x = invariant''25 x
  
  predicate inv'34 (_0'0: closure0)
  
  axiom inv_axiom'33 [@rewrite]: forall x: closure0 [inv'34 x]. inv'34 x
  = (let {_0 = x0 ; _1 = x1 ; _2 = x2} = x in inv'33 x0)
  
  let rec closure0[#"persistent_array.rs" 294 57 294 69] [@coma:extspec] (self:closure0) (tokens: (MutBorrow.t t_CompleteMap)) (return'  (x:t_Option'2))= bb0
    [ bb0 = s0 [ s0 = deref {tokens'0} (fun (_ret:MutBorrow.t t_CompleteMap) ->  [ &_7 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = deref'0 {(_1'0._0).t_PersistentArray__contained_in_token} (fun (_ret:t_Rc'1) ->  [ &_12 <- _ret ] s1)
      | s1 = bb2 ]
    
    | bb2 = s0 [ s0 = as_ref {_12} (fun (_ret:t_Fragment) ->  [ &_10 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = contains'0 {(_7.current).t_CompleteMap__values} {_10} (fun (_ret:()) ->  [ &_5 <- _ret ] s1) | s1 = bb4 ]
    
    | bb4 = s0 [ s0 = new {_4} (fun (_ret: ()) ->  [ &_3 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_16 <- (_1'0._0).t_PersistentArray__program_value ] s1
      | s1 = {inv'11 tokens'0}
        MutBorrow.borrow_mut < (MutBorrow.t t_CompleteMap)> {tokens'0}
          (fun (_ret:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) ->
             [ &_23 <- _ret ] 
            -{inv'11 _ret.final}-
             [ &tokens'0 <- _ret.final ] 
            s2)
      | s2 = deref_mut {_23} (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->  [ &_22 <- _ret ] s3)
      | s3 = bb6 ]
    
    | bb6 = s0
      [ s0 = {inv'10 _22.current}
        MutBorrow.borrow_final <MutBorrow.t t_CompleteMap> {_22.current} {MutBorrow.get_id _22}
          (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->
             [ &_21 <- _ret ] 
            -{inv'10 _ret.final}-
             [ &_22 <- { _22 with current = _ret.final } ] 
            s1)
      | s1 = {inv'9 (_21.current).current}
        MutBorrow.borrow_mut <t_CompleteMap> {(_21.current).current}
          (fun (_ret:MutBorrow.t t_CompleteMap) ->
             [ &_20 <- _ret ] 
            -{inv'9 _ret.final}-
             [ &_21 <- { _21 with current = { _21.current with current = _ret.final } } ] 
            s2)
      | s2 = {inv'9 _20.current}
        MutBorrow.borrow_final <t_CompleteMap> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret:MutBorrow.t t_CompleteMap) ->
             [ &_19 <- _ret ] 
            -{inv'9 _ret.final}-
             [ &_20 <- { _20 with current = _ret.final } ] 
            s3)
      | s3 = new'0 {_19} (fun (_ret: (MutBorrow.t t_CompleteMap)) ->  [ &_18 <- _ret ] s4)
      | s4 = bb7 ]
    
    | bb7 = s0 [ s0 = reroot {_16} {_1'0._1} {_18} (fun (_ret:int) ->  [ &_14 <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'18 _22} s1
      | s1 = -{resolve'0 _22}- s2
      | s2 = {[@expl:type invariant] inv'18 _21} s3
      | s3 = -{resolve'0 _21}- s4
      | s4 = {[@expl:type invariant] inv'10 _20} s5
      | s5 = -{resolve'2 _20}- s6
      | s6 =  [ &id'3 <- [%#spersistent_array'4] id'2 (view'9 (_1'0._0).t_PersistentArray__program_value) ] s7
      | s7 = bb9 ]
    
    | bb9 = s0
      [ s0 = into_inner {tokens'0} (fun (_ret:MutBorrow.t t_CompleteMap) ->  [ &_30 <- _ret ] s1) | s1 = bb10 ]
    
    | bb10 = s0
      [ s0 =  [ &_33 <- id'3 ] s1
      | s1 = get_ghost {(_30.current).t_CompleteMap__own_map} {_33} (fun (_ret:t_Option'1) ->  [ &_28 <- _ret ] s2)
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = unwrap {_28} (fun (_ret:t_PCellOwn) ->  [ &_27 <- _ret ] s1) | s1 = bb12 ] 
    | bb12 = s0 [ s0 = new'1 {_27} (fun (_ret: t_PCellOwn) ->  [ &perm <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'10 _30} s1
      | s1 = -{resolve'2 _30}- s2
      | s2 = as_ref'0 {(_1'0._0).t_PersistentArray__program_value} (fun (_ret:t_PCell) ->  [ &_36 <- _ret ] s3)
      | s3 = bb14 ]
    
    | bb14 = s0 [ s0 = borrow'0 {_36} {perm} (fun (_ret:t_Inner) ->  [ &borrow'1 <- _ret ] s1) | s1 = bb15 ] 
    | bb15 = any
      [ br0 (x0:t_Vec)-> {borrow'1 = C_Direct x0} (! bb18)
      | br1 (x0:UInt64.t) (x1:t_T) (x2:t_Rc'0)-> {borrow'1 = C_Link x0 x1 x2} (! bb16) ]
    
    | bb16 = {false} any
    | bb18 = s0
      [ s0 = v_Direct {borrow'1} (fun (r0:t_Vec) ->  [ &arr <- r0 ] s1)
      | s1 = deref'1 {arr} (fun (_ret:Slice64.slice t_T) ->  [ &_42 <- _ret ] s2)
      | s2 = bb19 ]
    
    | bb19 = s0 [ s0 = get'1 {_42} {_1'0._2} (fun (_ret:t_Option'2) ->  [ &_0'0 <- _ret ] s1) | s1 = bb20 ] 
    | bb20 = return' {_0'0} ]
    
    [ & _0'0: t_Option'2 = Any.any_l ()
    | & _1'0: closure0 = self
    | & tokens'0:  (MutBorrow.t t_CompleteMap) = tokens
    | & _3:  () = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _5: () = Any.any_l ()
    | & _7: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _10: t_Fragment = Any.any_l ()
    | & _12: t_Rc'1 = Any.any_l ()
    | & _14: int = Any.any_l ()
    | & _16: t_Rc'0 = Any.any_l ()
    | & _18:  (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _19: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _20: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _22: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _23: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) = Any.any_l ()
    | & id'3: t_Id = Any.any_l ()
    | & perm:  t_PCellOwn = Any.any_l ()
    | & _27: t_PCellOwn = Any.any_l ()
    | & _28: t_Option'1 = Any.any_l ()
    | & _30: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _33: t_Id = Any.any_l ()
    | & borrow'1: t_Inner = Any.any_l ()
    | & _36: t_PCell = Any.any_l ()
    | & arr: t_Vec = Any.any_l ()
    | & _42: Slice64.slice t_T = Any.any_l () ]
  
  
  type t_Namespaces
  
  predicate precondition (self: ()) (args: t_Rc) =
    let self_ = args in true
  
  let rec deref'2 (self_:t_Rc) (return'  (x:t_LocalInvariant))= any
    [ return''0 (result:t_LocalInvariant)-> {[%#src'0] result = view self_} (! return' {result}) ]
  
  
  predicate postcondition_once (self: ()) (args: t_Rc) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  predicate resolve'3 (_0'0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: t_Rc) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  function fn_mut_once (self: ()) (args: t_Rc) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_Rc, res: t_LocalInvariant. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'3 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_Rc, res_state: (), res: t_LocalInvariant. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_Rc) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  function fn_once (self: ()) (args: t_Rc) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc, res: t_LocalInvariant. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'3 self)
  
  function fn_mut (self: ()) (args: t_Rc) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_Rc, res_state: (), res: t_LocalInvariant. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  type tuple'0  =
    { _p0'0:  t_LocalInvariant; _p1'0:  t_Namespaces; _p2: closure0 }
  
  predicate precondition'0 (self: closure0) (args:  (MutBorrow.t t_CompleteMap)) =
    [%#spersistent_array'5] let tokens = args in closure0'pre self tokens
  
  predicate postcondition_once'0 (self: closure0) (args:  (MutBorrow.t t_CompleteMap)) (result: t_Option'2) =
    [%#spersistent_array'5] let tokens = args in closure0'post'return' self tokens result
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) =
    [%#sset] Set.mem e self
  
  function namespaces (self: t_Namespaces) : Set.set t_Namespace
  
  function view'19 (self: t_Namespaces) : Set.set t_Namespace =
    [%#slocal_invariant'10] namespaces self
  
  function view'20 (self:  t_Namespaces) : Set.set t_Namespace =
    [%#sghost] view'19 self
  
  predicate precondition'1 (self: ()) (args: tuple'0) =
    [%#slocal_invariant'5] let {_p0'0 = self'0 ; _p1'0 = namespaces'0 ; _p2 = f} = args in (forall t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ inv'11 t
     -> precondition'0 f t
    /\ (forall res: t_Option'2. postcondition_once'0 f t res  -> invariant_with_data t.final (public self'0)))
    /\ contains'2 (view'20 namespaces'0) (namespace self'0) /\ inv'34 f
  
  let rec open (self: t_LocalInvariant) (namespaces'0: t_Namespaces) (f:closure0) (return'  (x:t_Option'2))= {[@expl:open 'f' type invariant] [%#slocal_invariant'6] inv'34 f}
    {[@expl:open requires #0] [%#slocal_invariant'7] contains'2 (view'20 namespaces'0) (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'8] forall t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self)
    /\ inv'11 t
     -> precondition'0 f t
    /\ (forall res: t_Option'2. postcondition_once'0 f t res  -> invariant_with_data t.final (public self))}
    any
    [ return''0 (result:t_Option'2)-> {[%#slocal_invariant'5] inv'30 result}
      {[%#slocal_invariant'9] exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self)
      /\ postcondition_once'0 f t result}
      (! return' {result}) ]
  
  
  function new_logic (x: t_LocalInvariant) :  t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. [%#sghost'13] new_logic x = x
  
  predicate postcondition_once'1 (self: ()) (args: tuple'0) (result: t_Option'2) =
    [%#slocal_invariant'5] let {_p0'0 = self'0 ; _p1'0 = namespaces'0 ; _p2 = f} = args in (exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result)
    /\ inv'30 result
  
  predicate resolve'4 (_0'0: ()) =
    true
  
  predicate postcondition_mut'0 (self: ()) (args: tuple'0) (result_state: ()) (result: t_Option'2) =
    [%#slocal_invariant'5] let {_p0'0 = self'0 ; _p1'0 = namespaces'0 ; _p2 = f} = args in (exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result)
    /\ inv'30 result
  
  function fn_mut_once'0 (self: ()) (args: tuple'0) (res: t_Option'2) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'0, res: t_Option'2. [%#sops'8] postcondition_once'1 self args res
  = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'4 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'0) (res_state: ()) (res: t_Option'2) : ()
  
  axiom postcondition_mut_hist_inv_spec'0: forall self: (), args: tuple'0, res_state: (), res: t_Option'2. ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple'0) (result: t_Option'2) =
    [%#slocal_invariant'5] let {_p0'0 = self'0 ; _p1'0 = namespaces'0 ; _p2 = f} = args in (exists t:  (MutBorrow.t t_CompleteMap). invariant_with_data t.current (public self'0)
    /\ postcondition_once'0 f t result)
    /\ inv'30 result
  
  function fn_once'0 (self: ()) (args: tuple'0) (res: t_Option'2) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'0, res: t_Option'2. [%#sops'0] postcondition_once'1 self args res
  = (postcondition'0 self args res /\ resolve'4 self)
  
  function fn_mut'0 (self: ()) (args: tuple'0) (res_state: ()) (res: t_Option'2) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: tuple'0, res_state: (), res: t_Option'2. [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc) (namespaces'0: t_Namespaces) (f:closure0) (return'  (x:t_Option'2))= {[@expl:open 'f' type invariant] [%#slocal_invariant] inv'34 f}
    {[@expl:open requires #0] [%#slocal_invariant'0] precondition () self}
    {[@expl:open requires #1] [%#slocal_invariant'1] forall this: t_LocalInvariant. postcondition () self this
     -> precondition'1 () { _p0'0 = new_logic this; _p1'0 = namespaces'0; _p2 = f }}
    any
    [ return''0 (result:t_Option'2)-> {[%#slocal_invariant'2] inv'30 result}
      {[%#slocal_invariant'3] exists this: t_LocalInvariant. postcondition () self this
      /\ postcondition'0 () { _p0'0 = new_logic this; _p1'0 = namespaces'0; _p2 = f } result}
      (! return' {result}) ]
  
  
  predicate contains'3 (self: t_Namespaces) (namespace'0: t_Namespace) =
    [%#slocal_invariant'4] contains'2 (namespaces self) namespace'0
  
  function view'21 [#"persistent_array.rs" 75 8 75 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'17] (view'17 (view'18 self.t_PersistentArray__contained_in_token))._p1
  
  function view'22 (self: t_PersistentArray) : Seq.seq t_T =
    [%#smodel] view'21 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get'2[#"persistent_array.rs" 288 8 292 26] (self:t_PersistentArray) (index:UInt64.t) (namespaces'0: t_Namespaces) (return'  (x:t_Option'2))= {[@expl:get 'self' type invariant] [%#spersistent_array'0] inv'32 self}
    {[@expl:get requires] [%#spersistent_array'1] contains'3 namespaces'0 (Namespace_PARRAY_0'62 0)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &public'0 <- [%#spersistent_array] public (view'0 self'0.t_PersistentArray__map_invariant) ] s1
      | s1 = bb1 ]
    
    | bb1 = s0
      [ s0 = borrow {self'0.t_PersistentArray__map_invariant} (fun (_ret: t_Rc) ->  [ &_8 <- _ret ] s1) | s1 = bb2 ]
    
    | bb2 = s0
      [ s0 =  [ &_11 <- { _0 = self'0; _1 = public'0; _2 = index'0 } ] s1
      | s1 = open'0 {_8} {namespaces'1} {_11} (fun (_ret:t_Option'2) ->  [ &_0'0 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = return''0 {_0'0} ]
    
    [ & _0'0: t_Option'2 = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & index'0: UInt64.t = index
    | & namespaces'1:  t_Namespaces = namespaces'0
    | & public'0: t_Id = Any.any_l ()
    | & _8:  t_Rc = Any.any_l ()
    | & _11: closure0 = Any.any_l () ]
    )
    [ return''0 (result:t_Option'2)-> {[@expl:get result type invariant] [%#spersistent_array'2] inv'30 result}
      {[@expl:get ensures] [%#spersistent_array'3] if UInt64.t'int index < Seq.length (view'22 self) then
        result = C_Some'2 (Seq.get (view'22 self) (UInt64.t'int index))
      else
        result = C_None'2
      }
      (! return' {result}) ]

end
module M_persistent_array__implementation__qyi7256199225841846155__reroot [#"persistent_array.rs" 331 8 335 26] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 45 18 45 37
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span spersistent_array = "persistent_array.rs" 337 21 337 49
  let%span spersistent_array'0 = "persistent_array.rs" 338 23 338 54
  let%span spersistent_array'1 = "persistent_array.rs" 347 34 347 61
  let%span spersistent_array'2 = "persistent_array.rs" 367 40 367 79
  let%span spersistent_array'3 = "persistent_array.rs" 368 51 368 90
  let%span spersistent_array'4 = "persistent_array.rs" 343 20 343 47
  let%span spersistent_array'5 = "persistent_array.rs" 334 16 334 22
  let%span spersistent_array'6 = "persistent_array.rs" 316 19 316 60
  let%span spersistent_array'7 = "persistent_array.rs" 317 8 317 78
  let%span spersistent_array'8 = "persistent_array.rs" 318 18 318 76
  let%span spersistent_array'9 = "persistent_array.rs" 319 18 319 107
  let%span spersistent_array'10 = "persistent_array.rs" 320 18 320 68
  let%span spersistent_array'11 = "persistent_array.rs" 321 18 321 68
  let%span spersistent_array'12 = "persistent_array.rs" 322 18 324 83
  let%span spersistent_array'13 = "persistent_array.rs" 326 18 329 9
  let%span spersistent_array'14 = "persistent_array.rs" 330 18 330 76
  let%span spersistent_array'15 = "persistent_array.rs" 103 16 129 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 68 14 68 43
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 80 22 80 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 80 4 80 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 79 14 79 35
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 203 17 203 21
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 203 4 203 46
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 202 14 202 45
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 90 8 90 22
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 108 8 108 22
  let%span sghost'13 = "../../creusot-contracts/src/ghost.rs" 100 8 100 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 149 16 149 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 150 27 150 46
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 151 26 151 54
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 152 26 152 57
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 153 26 153 62
  let%span svec'4 = "../../creusot-contracts/src/std/vec.rs" 154 26 154 55
  let%span svec'5 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'6 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 166 33 166 37
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 166 39 166 43
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 164 15 164 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 166 4 166 77
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 165 14 165 30
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 188 37 188 41
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 188 43 188 47
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 184 15 184 37
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 188 4 188 89
  let%span spcell'8 = "../../creusot-contracts/src/pcell.rs" 185 14 185 40
  let%span spcell'9 = "../../creusot-contracts/src/pcell.rs" 186 14 186 30
  let%span spcell'10 = "../../creusot-contracts/src/pcell.rs" 187 14 187 34
  let%span spcell'11 = "../../creusot-contracts/src/pcell.rs" 36 8 36 19
  let%span spcell'12 = "../../creusot-contracts/src/pcell.rs" 61 20 61 46
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 344 22 344 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 344 4 344 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 343 14 343 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 414 32 414 36
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 414 4 414 77
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 405 14 413 5
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 377 30 377 34
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 377 4 377 62
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 366 14 374 9
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 375 14 375 73
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 376 44
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 265 8 265 24
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 85 14 85 43
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 86 14 86 84
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'17 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 34
  let%span sfmap'19 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 36 8 36 42
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 110 20 110 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 117 20 117 37
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 124 20 124 88
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull'0; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner  =
    | C_Direct t_Vec
    | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_Inner }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  function view (self: t_Rc) : t_PCell
  
  let rec clone' (self_:t_Rc) (return'  (x:t_Rc))= any
    [ return''0 (result:t_Rc)-> {[%#src] view result = view self_} (! return' {result}) ]
  
  
  type t_Id
  
  function id (self: t_PCell) : t_Id
  
  function view'0 (self: t_Rc) : t_PCell =
    [%#smodel] view self
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_CompleteMap  =
    { t_CompleteMap__own_map: t_FMap;
      t_CompleteMap__values: t_Authority;
      t_CompleteMap__rank: Map.map t_Id int;
      t_CompleteMap__length: int }
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  type t_Option  =
    | C_None
    | C_Some t_PCellOwn
  
  function view'1 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option =
    [%#sfmap'11] Map.get (view'1 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) =
    [%#sfmap'10] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'5] Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) =
    [%#svec'6] inv'2 (view'2 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
  = match x with
    | C_Direct a_0 -> inv'3 a_0
    | C_Link index value next -> inv'0 value
    end
  
  predicate invariant''2 (self: t_Inner) =
    [%#sinvariant'0] inv'4 self
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PCellOwn) =
    [%#spcell'12] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PCellOwn bool) (a: t_PCellOwn) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PCellOwn bool) : t_PCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PCellOwn bool. ([%#sutil] exists x: t_PCellOwn. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PCellOwn =
    [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PCellOwn =
    [%#sfmap'18] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PCellOwn =
    [%#sfmap'12] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'19] forall k: t_Id. contains self k  -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
  = (invariant''5 x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate inv'9 (_0: t_CompleteMap)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_CompleteMap [inv'9 x]. inv'9 x
  = match x with
    | {t_CompleteMap__own_map = own_map ; t_CompleteMap__values = values ; t_CompleteMap__rank = rank ; t_CompleteMap__length = length} -> inv'7 own_map
    /\ inv'8 values
    end
  
  predicate invariant''6 (self: MutBorrow.t t_CompleteMap) =
    [%#sinvariant] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_CompleteMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_CompleteMap [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sghost'13] inv'10 self
  
  predicate inv'11 (_0:  (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'10 [@rewrite]: forall x:  (MutBorrow.t t_CompleteMap) [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sinvariant'0] inv'11 self
  
  predicate inv'12 (_0:  (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'11 [@rewrite]: forall x:  (MutBorrow.t t_CompleteMap) [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_CompleteMap) =
    [%#sinvariant'0] inv'10 self
  
  predicate inv'13 (_0: MutBorrow.t t_CompleteMap)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_CompleteMap [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: (MutBorrow.t t_CompleteMap)) (return'  (x:MutBorrow.t t_CompleteMap))= {[@expl:deref 'self' type invariant] [%#sghost] inv'12 self}
    any
    [ return''0 (result:MutBorrow.t t_CompleteMap)-> {[%#sghost'0] inv'13 result}
      {[%#sghost'1] self = result}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PCellOwn
  
  predicate invariant''10 (self: t_FMap) =
    [%#sinvariant'0] inv'7 self
  
  predicate inv'14 (_0: t_FMap)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_FMap [inv'14 x]. inv'14 x = invariant''10 x
  
  predicate invariant''11 (self: t_PCellOwn) =
    [%#sinvariant'0] inv'6 self
  
  predicate inv'15 (_0: t_PCellOwn)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_PCellOwn [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate inv'16 (_0: t_Option'0)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Option'0 [inv'16 x]. inv'16 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'15 a_0
    end
  
  function map_logic (self: t_Option) (f: Map.map t_PCellOwn t_PCellOwn) : t_Option'0 =
    [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self:t_FMap) (key:t_Id) (return'  (x:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'14 self}
    any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'0] inv'16 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PCellOwn) -> v)}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:t_PCellOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'16 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any
    [ return''0 (result:t_PCellOwn)-> {inv'15 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ]
  
  
  predicate invariant''12 (self:  t_PCellOwn) =
    [%#sghost'13] inv'15 self
  
  predicate inv'17 (_0:  t_PCellOwn)
  
  axiom inv_axiom'16 [@rewrite]: forall x:  t_PCellOwn [inv'17 x]. inv'17 x = invariant''12 x
  
  let rec new (x:t_PCellOwn) (return'  (x'0: t_PCellOwn))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'15 x}
    any
    [ return''0 (result: t_PCellOwn)-> {[%#sghost'3] inv'17 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  predicate inv'18 (_0: t_UnsafeCell)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_UnsafeCell [inv'18 x]. inv'18 x
  = match x with
    | {t_UnsafeCell__value = value} -> inv'4 value
    end
  
  predicate inv'19 (_0: t_PCell)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_PCell [inv'19 x]. inv'19 x
  = match x with
    | {t_PCell__0 = a_0} -> inv'18 a_0
    end
  
  predicate invariant''13 (self: t_PCell) =
    [%#sinvariant'0] inv'19 self
  
  predicate inv'20 (_0: t_PCell)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PCell [inv'20 x]. inv'20 x = invariant''13 x
  
  let rec as_ref (self_:t_Rc) (return'  (x:t_PCell))= any
    [ return''0 (result:t_PCell)-> {inv'20 result} {[%#src'0] result = view self_} (! return' {result}) ]
  
  
  function id'0 (self: t_PCellOwn) : t_Id
  
  function view'3 (self: t_PCellOwn) : t_Inner =
    [%#spcell'11] val' self
  
  function view'4 (self: t_PCellOwn) : t_Inner =
    [%#smodel] view'3 self
  
  function view'5 (self:  t_PCellOwn) : t_Inner =
    [%#sghost'11] view'4 self
  
  let rec borrow (self:t_PCell) (perm: t_PCellOwn) (return'  (x:t_Inner))= {[@expl:borrow 'self' type invariant] [%#spcell] inv'20 self}
    {[@expl:borrow 'perm' type invariant] [%#spcell'0] inv'17 perm}
    {[@expl:borrow requires] [%#spcell'1] id self = id'0 perm}
    any
    [ return''0 (result:t_Inner)-> {[%#spcell'2] inv'5 result}
      {[%#spcell'3] result = view'5 perm}
      (! return' {result}) ]
  
  
  let rec v_Link (input:t_Inner) (ret  (index:UInt64.t) (value:t_T) (next:t_Rc))= any
    [ good (index:UInt64.t) (value:t_T) (next:t_Rc)-> {C_Link index value next = input} (! ret {index} {value} {next})
    | bad -> {forall index: UInt64.t, value: t_T, next: t_Rc [C_Link index value next: t_Inner]. C_Link index value next
      <> input}
      (! {false}
      any) ]
  
  
  predicate invariant''14 (self: MutBorrow.t ( (MutBorrow.t t_CompleteMap))) =
    [%#sinvariant] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'21 (_0: MutBorrow.t ( (MutBorrow.t t_CompleteMap)))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) [inv'21 x]. inv'21 x
  = invariant''14 x
  
  predicate invariant''15 (self: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    [%#sinvariant] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'22 (_0: MutBorrow.t (MutBorrow.t t_CompleteMap))
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_CompleteMap) [inv'22 x]. inv'22 x
  = invariant''15 x
  
  let rec deref_mut (self:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) (return'  (x:MutBorrow.t (MutBorrow.t t_CompleteMap)))= {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'21 self}
    any
    [ return''0 (result:MutBorrow.t (MutBorrow.t t_CompleteMap))-> {[%#sghost'6] inv'22 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  
  let rec new'0 (x:MutBorrow.t t_CompleteMap) (return'  (x'0: (MutBorrow.t t_CompleteMap)))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'10 x}
    any
    [ return''0 (result: (MutBorrow.t t_CompleteMap))-> {[%#sghost'3] inv'11 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t (MutBorrow.t t_CompleteMap)) =
    resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_CompleteMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_CompleteMap) =
    resolve'1 _0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PCellOwn)
  
  type tuple  =
    { _p0: t_Option'1; _p1: MutBorrow.t t_FMap }
  
  predicate invariant''16 (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'23 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'23 x]. inv'23 x = invariant''16 x
  
  predicate invariant''17 (self: MutBorrow.t t_PCellOwn) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'24 (_0: MutBorrow.t t_PCellOwn)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_PCellOwn [inv'24 x]. inv'24 x = invariant''17 x
  
  predicate inv'25 (_0: t_Option'1)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_Option'1 [inv'25 x]. inv'25 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'24 a_0
    end
  
  predicate inv'26 (_0: tuple)
  
  axiom inv_axiom'25 [@rewrite]: forall x: tuple [inv'26 x]. inv'26 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv'25 x0 /\ inv'23 x1)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'17] len self >= 0
  
  function remove (self: t_FMap) (k: t_Id) : t_FMap
  
  axiom remove_spec: forall self: t_FMap, k: t_Id. [%#sfmap'13] view'1 (remove self k)
  = Map.set (view'1 self) k (C_None)
  
  axiom remove_spec'0: forall self: t_FMap, k: t_Id. [%#sfmap'14] len (remove self k)
  = (if contains self k then len self - 1 else len self)
  
  function insert (self: t_FMap) (k: t_Id) (v: t_PCellOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: t_PCellOwn. [%#sfmap'15] view'1 (insert self k v)
  = Map.set (view'1 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: t_PCellOwn. [%#sfmap'16] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  let rec split_mut_ghost (self:MutBorrow.t t_FMap) (key:t_Id) (return'  (x:tuple))= {[@expl:split_mut_ghost 'self' type invariant] [%#sfmap'2] inv'23 self}
    any
    [ return''0 (result:tuple)-> {[%#sfmap'3] inv'26 result}
      {[%#sfmap'4] if contains self.current key then
        (result._p1).current = remove self.current key
        /\ match result._p0 with
          | C_None'1 -> false
          | C_Some'1 r -> index_logic'0 self.current key = r.current
          /\ self.final = insert (result._p1).final key r.final
          end
      else
        result._p0 = C_None'1 /\ result._p1 = self
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self_:t_Option'1) (return'  (x:MutBorrow.t t_PCellOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'25 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result:MutBorrow.t t_PCellOwn)-> {inv'24 result}
      {[%#soption'1] C_Some'1 result = self_}
      (! return' {result}) ]
  
  
  let rec get_mut_ghost (self:MutBorrow.t t_FMap) (key:t_Id) (return'  (x:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'5] inv'23 self}
    any
    [ return''0 (result:t_Option'1)-> {[%#sfmap'6] inv'25 result}
      {[%#sfmap'7] if contains self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'8] forall k: t_Id. k <> key  -> get self.current k = get self.final k}
      {[%#sfmap'9] len self.current = len self.final}
      (! return' {result}) ]
  
  
  type tuple'0  =
    { _p0'0: MutBorrow.t t_PCellOwn; _p1'0: MutBorrow.t t_PCellOwn }
  
  predicate resolve'3 (self: MutBorrow.t t_FMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_FMap) =
    resolve'3 _0
  
  predicate inv'27 (_0: tuple'0)
  
  axiom inv_axiom'26 [@rewrite]: forall x: tuple'0 [inv'27 x]. inv'27 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv'24 x0 /\ inv'24 x1)
  
  predicate invariant''18 (self:  tuple'0) =
    [%#sghost'13] inv'27 self
  
  predicate inv'28 (_0:  tuple'0)
  
  axiom inv_axiom'27 [@rewrite]: forall x:  tuple'0 [inv'28 x]. inv'28 x = invariant''18 x
  
  let rec new'1 (x:tuple'0) (return'  (x'0: tuple'0))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'27 x}
    any [ return''0 (result: tuple'0)-> {[%#sghost'3] inv'28 result} {[%#sghost'4] result = x} (! return' {result}) ] 
  
  type tuple'1  =
    { _p0'1:  (MutBorrow.t t_PCellOwn); _p1'1:  (MutBorrow.t t_PCellOwn) }
  
  predicate invariant''19 (self:  (MutBorrow.t t_PCellOwn)) =
    [%#sghost'13] inv'24 self
  
  predicate inv'29 (_0:  (MutBorrow.t t_PCellOwn))
  
  axiom inv_axiom'28 [@rewrite]: forall x:  (MutBorrow.t t_PCellOwn) [inv'29 x]. inv'29 x = invariant''19 x
  
  predicate inv'30 (_0: tuple'1)
  
  axiom inv_axiom'29 [@rewrite]: forall x: tuple'1 [inv'30 x]. inv'30 x
  = (let {_p0'1 = x0 ; _p1'1 = x1} = x in inv'29 x0 /\ inv'29 x1)
  
  let rec split (self: tuple'0) (return'  (x:tuple'1))= {[@expl:split 'self' type invariant] [%#sghost'8] inv'28 self}
    any
    [ return''0 (result:tuple'1)-> {[%#sghost'9] inv'30 result}
      {[%#sghost'10] self = { _p0'0 = result._p0'1; _p1'0 = result._p1'1 }}
      (! return' {result}) ]
  
  
  predicate invariant''20 (self: MutBorrow.t t_Inner) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'31 (_0: MutBorrow.t t_Inner)
  
  axiom inv_axiom'30 [@rewrite]: forall x: MutBorrow.t t_Inner [inv'31 x]. inv'31 x = invariant''20 x
  
  function view'6 (self: MutBorrow.t t_PCellOwn) : t_Inner =
    [%#smodel'0] view'3 self.current
  
  function view'7 (self:  (MutBorrow.t t_PCellOwn)) : t_Inner =
    [%#sghost'11] view'6 self
  
  let rec borrow_mut (self:t_PCell) (perm: (MutBorrow.t t_PCellOwn)) (return'  (x:MutBorrow.t t_Inner))= {[@expl:borrow_mut 'self' type invariant] [%#spcell'4] inv'20 self}
    {[@expl:borrow_mut 'perm' type invariant] [%#spcell'5] inv'29 perm}
    {[@expl:borrow_mut requires] [%#spcell'6] id self = id'0 perm.current}
    any
    [ return''0 (result:MutBorrow.t t_Inner)-> {[%#spcell'7] inv'31 result}
      {[%#spcell'8] id self = id'0 perm.final}
      {[%#spcell'9] result.current = view'7 perm}
      {[%#spcell'10] result.final = view'3 perm.final}
      (! return' {result}) ]
  
  
  type tuple'2  =
    { _p0'2: MutBorrow.t t_Inner; _p1'2: MutBorrow.t t_Inner }
  
  let rec swap (x:MutBorrow.t t_Inner) (y:MutBorrow.t t_Inner) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem] inv'31 x}
    {[@expl:swap 'y' type invariant] [%#smem'0] inv'31 y}
    any
    [ return''0 (result:())-> {[%#smem'1] x.final = y.current} {[%#smem'2] y.final = x.current} (! return' {result}) ]
  
  
  predicate inv'32 (_0: tuple'2)
  
  axiom inv_axiom'31 [@rewrite]: forall x: tuple'2 [inv'32 x]. inv'32 x
  = (let {_p0'2 = x0 ; _p1'2 = x1} = x in inv'31 x0 /\ inv'31 x1)
  
  predicate resolve'5 (self: MutBorrow.t t_Inner) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 (_0: MutBorrow.t t_Inner) =
    resolve'5 _0
  
  predicate resolve'7 (self: tuple'2) =
    [%#sresolve'0] resolve'6 self._p0'2 /\ resolve'6 self._p1'2
  
  predicate resolve'8 (_0: tuple'2) =
    resolve'7 _0
  
  predicate resolve'9 (self:  (MutBorrow.t t_CompleteMap)) =
    [%#sghost'12] resolve'2 self
  
  predicate resolve'10 (_0:  (MutBorrow.t t_CompleteMap)) =
    resolve'9 _0
  
  let rec v_Direct (input:t_Inner) (ret  (field_0:t_Vec))= any
    [ good (field_0:t_Vec)-> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  
  predicate resolve'11 (self: MutBorrow.t t_Rc) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'12 (_0: MutBorrow.t t_Rc) =
    resolve'11 _0
  
  predicate resolve'13 (self: MutBorrow.t UInt64.t) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'14 (_0: MutBorrow.t UInt64.t) =
    resolve'13 _0
  
  predicate invariant''21 (self: MutBorrow.t t_Vec) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'33 (_0: MutBorrow.t t_Vec)
  
  axiom inv_axiom'32 [@rewrite]: forall x: MutBorrow.t t_Vec [inv'33 x]. inv'33 x = invariant''21 x
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  function view'8 (self: MutBorrow.t t_Vec) : Seq.seq t_T =
    [%#smodel'0] view'2 self.current
  
  predicate invariant''22 (self: MutBorrow.t t_T) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'34 (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'33 [@rewrite]: forall x: MutBorrow.t t_T [inv'34 x]. inv'34 x = invariant''22 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_T) (fin: Seq.seq t_T) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  let rec index_mut (self_:MutBorrow.t t_Vec) (ix:UInt64.t) (return'  (x:MutBorrow.t t_T))= {[@expl:index_mut 'self_' type invariant] [%#svec] inv'33 self_}
    {[@expl:index_mut requires] [%#svec'0] in_bounds ix (view'8 self_)}
    any
    [ return''0 (result:MutBorrow.t t_T)-> {inv'34 result}
      {[%#svec'1] has_value ix (view'8 self_) result.current}
      {[%#svec'2] has_value ix (view'2 self_.final) result.final}
      {[%#svec'3] resolve_elswhere ix (view'8 self_) (view'2 self_.final)}
      {[%#svec'4] Seq.length (view'2 self_.final) = Seq.length (view'8 self_)}
      (! return' {result}) ]
  
  
  let rec swap'0 (x:MutBorrow.t t_T) (y:MutBorrow.t t_T) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem] inv'34 x}
    {[@expl:swap 'y' type invariant] [%#smem'0] inv'34 y}
    any
    [ return''0 (result:())-> {[%#smem'1] x.final = y.current} {[%#smem'2] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'15 (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'16 (_0: MutBorrow.t t_T) =
    resolve'15 _0
  
  predicate resolve'17 (self: MutBorrow.t t_Vec) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'18 (_0: MutBorrow.t t_Vec) =
    resolve'17 _0
  
  let rec new'2 (x:()) (return'  (x'0: ()))= any
    [ return''0 (result: ())-> {[%#sghost'4] result = x} (! return' {result}) ]
  
  
  function index_logic'1 (self: Map.map t_Id int) (a: t_Id) : int =
    [%#smapping] Map.get self a
  
  function id'1 (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (Seq.seq t_T)
  
  function view'9 (self: t_FMap'0) : Map.map t_Id t_Option'2
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'2 =
    [%#sfmap'11] Map.get (view'9 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) =
    [%#sfmap'10] get'0 self k <> C_None'2
  
  function view'10 (self: t_Authority) : t_FMap'0
  
  predicate index_logic'2 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) =
    [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#sutil] exists x: Seq.seq t_T. index_logic'2 p x)
   -> ([%#sutil'0] index_logic'2 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'2) : Seq.seq t_T =
    [%#soption'4] match self with
      | C_Some'2 x -> x
      | C_None'2 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'18] unwrap_logic'0 (get'0 self k)
  
  predicate invariant_with_data [#"persistent_array.rs" 101 8 101 52] (self: t_CompleteMap) (id'2: t_Id) =
    [%#spersistent_array'15] id'1 self.t_CompleteMap__values = id'2
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
    = contains'0 (view'10 self.t_CompleteMap__values) id'3)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> id'0 (index_logic'0 self.t_CompleteMap__own_map id'3) = id'3)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> Seq.length (lookup'0 (view'10 self.t_CompleteMap__values) id'3) = self.t_CompleteMap__length)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'3) with
      | C_Direct _ -> true
      | C_Link _ _ next -> contains self.t_CompleteMap__own_map (id (view next))
      end)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'3) with
      | C_Direct v -> lookup'0 (view'10 self.t_CompleteMap__values) id'3 = view'2 v
      | C_Link index value next -> let next_id = id (view next) in UInt64.t'int index < self.t_CompleteMap__length
      /\ Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) id'3) (UInt64.t'int index) = value
      /\ (forall j: int. 0 <= j /\ j < self.t_CompleteMap__length /\ j <> UInt64.t'int index
       -> Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) id'3) j
      = Seq.get (lookup'0 (view'10 self.t_CompleteMap__values) next_id) j)
      end)
    /\ (forall id'3: t_Id. contains self.t_CompleteMap__own_map id'3
     -> match val' (index_logic'0 self.t_CompleteMap__own_map id'3) with
      | C_Direct _ -> true
      | C_Link _ _ next -> let next_id = id (view next) in index_logic'1 self.t_CompleteMap__rank id'3
      > index_logic'1 self.t_CompleteMap__rank next_id
      end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec reroot[#"persistent_array.rs" 331 8 335 26] (inner:t_Rc) (invariant_id:t_Id) (tokens: (MutBorrow.t t_CompleteMap)) (return'  (x:int))= {[@expl:reroot 'tokens' type invariant] [%#spersistent_array'5] inv'11 tokens}
    {[@expl:reroot requires #0] [%#spersistent_array'6] invariant_with_data tokens.current invariant_id}
    {[@expl:reroot requires #1] [%#spersistent_array'7] contains (tokens.current).t_CompleteMap__own_map (id (view'0 inner))}
    (! bb0
    [ bb0 = s0 [ s0 = clone' {inner'0} (fun (_ret:t_Rc) ->  [ &inner_clone <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &id'2 <- [%#spersistent_array] id (view'0 inner'0) ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &rank <- [%#spersistent_array'0] Map.get (tokens'0.current).t_CompleteMap__rank id'2 ] s1 | s1 = bb3 ]
    
    | bb3 = s0 [ s0 = deref {tokens'0} (fun (_ret:MutBorrow.t t_CompleteMap) ->  [ &_23 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 =  [ &_26 <- id'2 ] s1
      | s1 = get_ghost {(_23.current).t_CompleteMap__own_map} {_26} (fun (_ret:t_Option'0) ->  [ &_21 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 = unwrap {_21} (fun (_ret:t_PCellOwn) ->  [ &_20 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = new {_20} (fun (_ret: t_PCellOwn) ->  [ &perm <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 = as_ref {inner'0} (fun (_ret:t_PCell) ->  [ &_29 <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = s0 [ s0 = borrow {_29} {perm} (fun (_ret:t_Inner) ->  [ &borrow'0 <- _ret ] s1) | s1 = bb9 ] 
    | bb9 = any
      [ br0 (x0:t_Vec)-> {borrow'0 = C_Direct x0} (! bb13)
      | br1 (x0:UInt64.t) (x1:t_T) (x2:t_Rc)-> {borrow'0 = C_Link x0 x1 x2} (! bb12) ]
    
    | bb12 = s0
      [ s0 = v_Link {borrow'0} (fun (rindex:UInt64.t) (rvalue:t_T) (rnext:t_Rc) ->  [ &next <- rnext ] s1)
      | s1 = clone' {next} (fun (_ret:t_Rc) ->  [ &next'0 <- _ret ] s2)
      | s2 = bb15 ]
    
    | bb15 = s0 [ s0 =  [ &next_id <- [%#spersistent_array'1] id (view next'0) ] s1 | s1 = bb16 ] 
    | bb16 = s0
      [ s0 =  [ &_41 <- next'0 ] s1
      | s1 = {inv'11 tokens'0}
        MutBorrow.borrow_mut < (MutBorrow.t t_CompleteMap)> {tokens'0}
          (fun (_ret:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) ->
             [ &_48 <- _ret ] 
            -{inv'11 _ret.final}-
             [ &tokens'0 <- _ret.final ] 
            s2)
      | s2 = deref_mut {_48} (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->  [ &_47 <- _ret ] s3)
      | s3 = bb17 ]
    
    | bb17 = s0
      [ s0 = {inv'10 _47.current}
        MutBorrow.borrow_final <MutBorrow.t t_CompleteMap> {_47.current} {MutBorrow.get_id _47}
          (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->
             [ &_46 <- _ret ] 
            -{inv'10 _ret.final}-
             [ &_47 <- { _47 with current = _ret.final } ] 
            s1)
      | s1 = {inv'9 (_46.current).current}
        MutBorrow.borrow_mut <t_CompleteMap> {(_46.current).current}
          (fun (_ret:MutBorrow.t t_CompleteMap) ->
             [ &_45 <- _ret ] 
            -{inv'9 _ret.final}-
             [ &_46 <- { _46 with current = { _46.current with current = _ret.final } } ] 
            s2)
      | s2 = {inv'9 _45.current}
        MutBorrow.borrow_final <t_CompleteMap> {_45.current} {MutBorrow.get_id _45}
          (fun (_ret:MutBorrow.t t_CompleteMap) ->
             [ &_44 <- _ret ] 
            -{inv'9 _ret.final}-
             [ &_45 <- { _45 with current = _ret.final } ] 
            s3)
      | s3 = new'0 {_44} (fun (_ret: (MutBorrow.t t_CompleteMap)) ->  [ &_43 <- _ret ] s4)
      | s4 = bb18 ]
    
    | bb18 = s0 [ s0 = reroot {_41} {invariant_id'0} {_43} (fun (_ret:int) ->  [ &next_d <- _ret ] s1) | s1 = bb19 ] 
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'22 _47} s1
      | s1 = -{resolve'0 _47}- s2
      | s2 = {[@expl:type invariant] inv'22 _46} s3
      | s3 = -{resolve'0 _46}- s4
      | s4 = {[@expl:type invariant] inv'10 _45} s5
      | s5 = -{resolve'2 _45}- s6
      | s6 = {inv'11 tokens'0}
        MutBorrow.borrow_mut < (MutBorrow.t t_CompleteMap)> {tokens'0}
          (fun (_ret:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) ->
             [ &_59 <- _ret ] 
            -{inv'11 _ret.final}-
             [ &tokens'0 <- _ret.final ] 
            s7)
      | s7 = deref_mut {_59} (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->  [ &_58 <- _ret ] s8)
      | s8 = bb20 ]
    
    | bb20 = s0
      [ s0 =  [ &_61 <- id'2 ] s1
      | s1 = {inv'7 ((_58.current).current).t_CompleteMap__own_map}
        MutBorrow.borrow_mut <t_FMap> {((_58.current).current).t_CompleteMap__own_map}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_57 <- _ret ] 
            -{inv'7 _ret.final}-
            
            [ &_58 <- { _58 with current = { _58.current with current = { (_58.current).current with t_CompleteMap__own_map = _ret.final } } } ]
            
            s2)
      | s2 = split_mut_ghost {_57} {_61} (fun (_ret:tuple) ->  [ &_56 <- _ret ] s3)
      | s3 = bb21 ]
    
    | bb21 = s0
      [ s0 =  [ &p_inner <- _56._p0 ] s1
      | s1 =  [ &rest <- _56._p1 ] s2
      | s2 = {[@expl:type invariant] inv'22 _58} s3
      | s3 = -{resolve'0 _58}- s4
      | s4 = unwrap'0 {p_inner} (fun (_ret:MutBorrow.t t_PCellOwn) ->  [ &_62 <- _ret ] s5)
      | s5 = bb22 ]
    
    | bb22 = s0
      [ s0 =  [ &_68 <- next_id ] s1
      | s1 = {inv'7 rest.current}
        MutBorrow.borrow_final <t_FMap> {rest.current} {MutBorrow.get_id rest}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_66 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &rest <- { rest with current = _ret.final } ] 
            s2)
      | s2 = get_mut_ghost {_66} {_68} (fun (_ret:t_Option'1) ->  [ &_65 <- _ret ] s3)
      | s3 = bb23 ]
    
    | bb23 = s0 [ s0 = unwrap'0 {_65} (fun (_ret:MutBorrow.t t_PCellOwn) ->  [ &_64 <- _ret ] s1) | s1 = bb24 ] 
    | bb24 = s0
      [ s0 =  [ &_53 <- { _p0'0 = _62; _p1'0 = _64 } ] s1
      | s1 = {[@expl:type invariant] inv'23 rest} s2
      | s2 = -{resolve'4 rest}- s3
      | s3 = new'1 {_53} (fun (_ret: tuple'0) ->  [ &_52 <- _ret ] s4)
      | s4 = bb25 ]
    
    | bb25 = s0 [ s0 = split {_52} (fun (_ret:tuple'1) ->  [ &_51 <- _ret ] s1) | s1 = bb26 ] 
    | bb26 = s0
      [ s0 =  [ &perm_inner <- _51._p0'1 ] s1
      | s1 =  [ &perm_next <- _51._p1'1 ] s2
      | s2 = as_ref {inner'0} (fun (_ret:t_PCell) ->  [ &_74 <- _ret ] s3)
      | s3 = bb27 ]
    
    | bb27 = s0
      [ s0 = borrow_mut {_74} {perm_inner} (fun (_ret:MutBorrow.t t_Inner) ->  [ &_72 <- _ret ] s1) | s1 = bb28 ]
    
    | bb28 = s0 [ s0 = as_ref {next'0} (fun (_ret:t_PCell) ->  [ &_79 <- _ret ] s1) | s1 = bb29 ] 
    | bb29 = s0
      [ s0 = borrow_mut {_79} {perm_next} (fun (_ret:MutBorrow.t t_Inner) ->  [ &_77 <- _ret ] s1) | s1 = bb30 ]
    
    | bb30 = s0
      [ s0 =  [ &_71 <- { _p0'2 = _72; _p1'2 = _77 } ] s1
      | s1 =  [ &bor_inner <- _71._p0'2 ] s2
      | s2 =  [ &bor_next <- _71._p1'2 ] s3
      | s3 = {inv'4 bor_inner.current}
        MutBorrow.borrow_mut <t_Inner> {bor_inner.current}
          (fun (_ret:MutBorrow.t t_Inner) ->
             [ &_83 <- _ret ] 
            -{inv'4 _ret.final}-
             [ &bor_inner <- { bor_inner with current = _ret.final } ] 
            s4)
      | s4 = {inv'4 bor_next.current}
        MutBorrow.borrow_mut <t_Inner> {bor_next.current}
          (fun (_ret:MutBorrow.t t_Inner) ->
             [ &_84 <- _ret ] 
            -{inv'4 _ret.final}-
             [ &bor_next <- { bor_next with current = _ret.final } ] 
            s5)
      | s5 = swap {_83} {_84} (fun (_ret:()) ->  [ &_82 <- _ret ] s6)
      | s6 = bb31 ]
    
    | bb31 = s0
      [ s0 =  [ &_85 <- { _p0'2 = bor_inner; _p1'2 = bor_next } ] s1
      | s1 = any
        [ br0 (x0:t_Vec)-> {(_85._p0'2).current = C_Direct x0} (! bb33)
        | br1 (x0:UInt64.t) (x1:t_T) (x2:t_Rc)-> {(_85._p0'2).current = C_Link x0 x1 x2} (! bb32) ]
       ]
    
    | bb33 = any
      [ br0 (x0:t_Vec)-> {(_85._p1'2).current = C_Direct x0} (! bb32)
      | br1 (x0:UInt64.t) (x1:t_T) (x2:t_Rc)-> {(_85._p1'2).current = C_Link x0 x1 x2} (! bb35) ]
    
    | bb32 = s0
      [ s0 = {[@expl:type invariant] inv'32 _85} s1
      | s1 = -{resolve'8 _85}- s2
      | s2 = {[@expl:type invariant] inv'11 tokens'0} s3
      | s3 = -{resolve'10 tokens'0}- s4
      | s4 = {false} any ]
    
    | bb35 = s0
      [ s0 = v_Direct {(_85._p0'2).current}
          (fun (r0:t_Vec) ->
            {inv'3 r0}
            MutBorrow.borrow_final <t_Vec> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _85._p0'2) 1}
              (fun (_ret:MutBorrow.t t_Vec) ->
                 [ &arr <- _ret ] 
                -{inv'3 _ret.final}-
                 [ &_85 <- { _85 with _p0'2 = { _85._p0'2 with current = C_Direct _ret.final } } ] 
                s1))
      | s1 = v_Link {(_85._p1'2).current}
          (fun (rindex:UInt64.t) (rvalue:t_T) (rnext:t_Rc) ->
            MutBorrow.borrow_final <UInt64.t> {rindex} {MutBorrow.inherit_id (MutBorrow.get_id _85._p1'2) 1}
              (fun (_ret:MutBorrow.t UInt64.t) ->
                 [ &index <- _ret ] 
                 [ &_85 <- { _85 with _p1'2 = { _85._p1'2 with current = C_Link _ret.final rvalue rnext } } ] 
                s2))
      | s2 = v_Link {(_85._p1'2).current}
          (fun (rindex:UInt64.t) (rvalue:t_T) (rnext:t_Rc) ->
            {inv'0 rvalue}
            MutBorrow.borrow_final <t_T> {rvalue} {MutBorrow.inherit_id (MutBorrow.get_id _85._p1'2) 2}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &value_next <- _ret ] 
                -{inv'0 _ret.final}-
                 [ &_85 <- { _85 with _p1'2 = { _85._p1'2 with current = C_Link rindex _ret.final rnext } } ] 
                s3))
      | s3 = v_Link {(_85._p1'2).current}
          (fun (rindex:UInt64.t) (rvalue:t_T) (rnext:t_Rc) ->
            MutBorrow.borrow_final <t_Rc> {rnext} {MutBorrow.inherit_id (MutBorrow.get_id _85._p1'2) 3}
              (fun (_ret:MutBorrow.t t_Rc) ->
                 [ &next'1 <- _ret ] 
                 [ &_85 <- { _85 with _p1'2 = { _85._p1'2 with current = C_Link rindex rvalue _ret.final } } ] 
                s4))
      | s4 = bb36 ]
    
    | bb36 = s0
      [ s0 =  [ &next'1 <- { next'1 with current = inner_clone } ] s1 | s1 = -{resolve'12 next'1}- s2 | s2 = bb38 ]
    
    | bb38 = s0
      [ s0 = {inv'3 arr.current}
        MutBorrow.borrow_final <t_Vec> {arr.current} {MutBorrow.get_id arr}
          (fun (_ret:MutBorrow.t t_Vec) ->
             [ &_99 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &arr <- { arr with current = _ret.final } ] 
            s1)
      | s1 = -{resolve'14 index}- s2
      | s2 = index_mut {_99} {index.current} (fun (_ret:MutBorrow.t t_T) ->  [ &_98 <- _ret ] s3)
      | s3 = bb39 ]
    
    | bb39 = s0
      [ s0 = {inv'0 _98.current}
        MutBorrow.borrow_final <t_T> {_98.current} {MutBorrow.get_id _98}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_97 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_98 <- { _98 with current = _ret.final } ] 
            s1)
      | s1 = {inv'0 _97.current}
        MutBorrow.borrow_final <t_T> {_97.current} {MutBorrow.get_id _97}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_96 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_97 <- { _97 with current = _ret.final } ] 
            s2)
      | s2 = {inv'0 value_next.current}
        MutBorrow.borrow_final <t_T> {value_next.current} {MutBorrow.get_id value_next}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_101 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &value_next <- { value_next with current = _ret.final } ] 
            s3)
      | s3 = swap'0 {_96} {_101} (fun (_ret:()) ->  [ &_95 <- _ret ] s4)
      | s4 = bb40 ]
    
    | bb40 = s0
      [ s0 = {[@expl:type invariant] inv'34 _98} s1
      | s1 = -{resolve'16 _98}- s2
      | s2 = {[@expl:type invariant] inv'34 _97} s3
      | s3 = -{resolve'16 _97}- s4
      | s4 = {[@expl:type invariant] inv'34 value_next} s5
      | s5 = -{resolve'16 value_next}- s6
      | s6 = {[@expl:type invariant] inv'33 arr} s7
      | s7 = -{resolve'18 arr}- s8
      | s8 = {[@expl:type invariant] inv'32 _85} s9
      | s9 = -{resolve'8 _85}- s10
      | s10 =  [ &new_d <- [%#spersistent_array'2] MinMax.min rank (next_d - 1) ] s11
      | s11 = bb41 ]
    
    | bb41 = s0
      [ s0 =  [ &_106 <- [%#spersistent_array'3] Map.set (tokens'0.current).t_CompleteMap__rank id'2 new_d ] s1
      | s1 = bb42 ]
    
    | bb42 = s0
      [ s0 = {inv'11 tokens'0}
        MutBorrow.borrow_mut < (MutBorrow.t t_CompleteMap)> {tokens'0}
          (fun (_ret:MutBorrow.t ( (MutBorrow.t t_CompleteMap))) ->
             [ &_109 <- _ret ] 
            -{inv'11 _ret.final}-
             [ &tokens'0 <- _ret.final ] 
            s1)
      | s1 = deref_mut {_109} (fun (_ret:MutBorrow.t (MutBorrow.t t_CompleteMap)) ->  [ &_108 <- _ret ] s2)
      | s2 = bb43 ]
    
    | bb43 = s0
      [ s0 = 
        [ &_108 <- { _108 with current = { _108.current with current = { (_108.current).current with t_CompleteMap__rank = _106 } } } ]
        
        s1
      | s1 = {[@expl:type invariant] inv'22 _108} s2
      | s2 = -{resolve'0 _108}- s3
      | s3 = {[@expl:type invariant] inv'11 tokens'0} s4
      | s4 = -{resolve'10 tokens'0}- s5
      | s5 = new'2 {_105} (fun (_ret: ()) ->  [ &_104 <- _ret ] s6)
      | s6 = bb44 ]
    
    | bb44 = s0 [ s0 =  [ &_0 <- new_d ] s1 | s1 = bb47 ] 
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'11 tokens'0} s1
      | s1 = -{resolve'10 tokens'0}- s2
      | s2 =  [ &_0 <- [%#spersistent_array'4] index_logic'1 (tokens'0.current).t_CompleteMap__rank id'2 ] s3
      | s3 = bb47 ]
    
    | bb47 = return''0 {_0} ]
    
    [ & _0: int = Any.any_l ()
    | & inner'0: t_Rc = inner
    | & invariant_id'0: t_Id = invariant_id
    | & tokens'0:  (MutBorrow.t t_CompleteMap) = tokens
    | & inner_clone: t_Rc = Any.any_l ()
    | & id'2: t_Id = Any.any_l ()
    | & rank: int = Any.any_l ()
    | & perm:  t_PCellOwn = Any.any_l ()
    | & _20: t_PCellOwn = Any.any_l ()
    | & _21: t_Option'0 = Any.any_l ()
    | & _23: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _26: t_Id = Any.any_l ()
    | & borrow'0: t_Inner = Any.any_l ()
    | & _29: t_PCell = Any.any_l ()
    | & next: t_Rc = Any.any_l ()
    | & next'0: t_Rc = Any.any_l ()
    | & next_id: t_Id = Any.any_l ()
    | & next_d: int = Any.any_l ()
    | & _41: t_Rc = Any.any_l ()
    | & _43:  (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _44: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _45: MutBorrow.t t_CompleteMap = Any.any_l ()
    | & _46: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _47: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _48: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) = Any.any_l ()
    | & perm_inner:  (MutBorrow.t t_PCellOwn) = Any.any_l ()
    | & perm_next:  (MutBorrow.t t_PCellOwn) = Any.any_l ()
    | & _51: tuple'1 = Any.any_l ()
    | & _52:  tuple'0 = Any.any_l ()
    | & _53: tuple'0 = Any.any_l ()
    | & p_inner: t_Option'1 = Any.any_l ()
    | & rest: MutBorrow.t t_FMap = Any.any_l ()
    | & _56: tuple = Any.any_l ()
    | & _57: MutBorrow.t t_FMap = Any.any_l ()
    | & _58: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _59: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) = Any.any_l ()
    | & _61: t_Id = Any.any_l ()
    | & _62: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & _64: MutBorrow.t t_PCellOwn = Any.any_l ()
    | & _65: t_Option'1 = Any.any_l ()
    | & _66: MutBorrow.t t_FMap = Any.any_l ()
    | & _68: t_Id = Any.any_l ()
    | & bor_inner: MutBorrow.t t_Inner = Any.any_l ()
    | & bor_next: MutBorrow.t t_Inner = Any.any_l ()
    | & _71: tuple'2 = Any.any_l ()
    | & _72: MutBorrow.t t_Inner = Any.any_l ()
    | & _74: t_PCell = Any.any_l ()
    | & _77: MutBorrow.t t_Inner = Any.any_l ()
    | & _79: t_PCell = Any.any_l ()
    | & _82: () = Any.any_l ()
    | & _83: MutBorrow.t t_Inner = Any.any_l ()
    | & _84: MutBorrow.t t_Inner = Any.any_l ()
    | & _85: tuple'2 = Any.any_l ()
    | & arr: MutBorrow.t t_Vec = Any.any_l ()
    | & index: MutBorrow.t UInt64.t = Any.any_l ()
    | & value_next: MutBorrow.t t_T = Any.any_l ()
    | & next'1: MutBorrow.t t_Rc = Any.any_l ()
    | & _95: () = Any.any_l ()
    | & _96: MutBorrow.t t_T = Any.any_l ()
    | & _97: MutBorrow.t t_T = Any.any_l ()
    | & _98: MutBorrow.t t_T = Any.any_l ()
    | & _99: MutBorrow.t t_Vec = Any.any_l ()
    | & _101: MutBorrow.t t_T = Any.any_l ()
    | & new_d: int = Any.any_l ()
    | & _104:  () = Any.any_l ()
    | & _105: () = Any.any_l ()
    | & _106: Map.map t_Id int = Any.any_l ()
    | & _108: MutBorrow.t (MutBorrow.t t_CompleteMap) = Any.any_l ()
    | & _109: MutBorrow.t ( (MutBorrow.t t_CompleteMap)) = Any.any_l () ]
    )
    [ return''0 (result:int)-> {[@expl:reroot ensures #0] [%#spersistent_array'8] invariant_with_data tokens.final invariant_id}
      {[@expl:reroot ensures #1] [%#spersistent_array'9] forall id'2: t_Id. contains (tokens.current).t_CompleteMap__own_map id'2
      = contains (tokens.final).t_CompleteMap__own_map id'2}
      {[@expl:reroot ensures #2] [%#spersistent_array'10] (tokens.current).t_CompleteMap__values
      = (tokens.final).t_CompleteMap__values}
      {[@expl:reroot ensures #3] [%#spersistent_array'11] (tokens.current).t_CompleteMap__length
      = (tokens.final).t_CompleteMap__length}
      {[@expl:reroot ensures #4] [%#spersistent_array'12] forall id'2: t_Id. index_logic'1 (tokens.current).t_CompleteMap__rank id'2
      > index_logic'1 (tokens.current).t_CompleteMap__rank (id (view'0 inner))
       -> index_logic'1 (tokens.current).t_CompleteMap__rank id'2
      = index_logic'1 (tokens.final).t_CompleteMap__rank id'2
      /\ get (tokens.current).t_CompleteMap__own_map id'2 = get (tokens.final).t_CompleteMap__own_map id'2}
      {[@expl:reroot ensures #5] [%#spersistent_array'13] match val' (index_logic'0 (tokens.final).t_CompleteMap__own_map (id (view'0 inner))) with
        | C_Direct _ -> true
        | C_Link _ _ _ -> false
        end}
      {[@expl:reroot ensures #6] [%#spersistent_array'14] result
      = index_logic'1 (tokens.final).t_CompleteMap__rank (id (view'0 inner))}
      (! return' {result}) ]

end
module M_persistent_array__testing [#"persistent_array.rs" 383 0 383 49]
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span spersistent_array = "persistent_array.rs" 384 38 384 39
  let%span spersistent_array'0 = "persistent_array.rs" 384 41 384 42
  let%span spersistent_array'1 = "persistent_array.rs" 384 44 384 45
  let%span spersistent_array'2 = "persistent_array.rs" 384 47 384 48
  let%span spersistent_array'3 = "persistent_array.rs" 386 19 386 20
  let%span spersistent_array'4 = "persistent_array.rs" 386 22 386 24
  let%span spersistent_array'5 = "persistent_array.rs" 387 19 387 20
  let%span spersistent_array'6 = "persistent_array.rs" 387 22 387 24
  let%span spersistent_array'7 = "persistent_array.rs" 391 18 391 57
  let%span spersistent_array'8 = "persistent_array.rs" 392 19 392 59
  let%span spersistent_array'9 = "persistent_array.rs" 393 19 393 59
  let%span spersistent_array'10 = "persistent_array.rs" 394 18 394 32
  let%span spersistent_array'11 = "persistent_array.rs" 395 18 395 34
  let%span spersistent_array'12 = "persistent_array.rs" 396 18 396 34
  let%span spersistent_array'13 = "persistent_array.rs" 397 18 397 33
  let%span spersistent_array'14 = "persistent_array.rs" 382 11 382 56
  let%span spersistent_array'15 = "persistent_array.rs" 137 33 137 37
  let%span spersistent_array'16 = "persistent_array.rs" 136 18 136 31
  let%span spersistent_array'17 = "persistent_array.rs" 173 20 173 24
  let%span spersistent_array'18 = "persistent_array.rs" 170 19 170 39
  let%span spersistent_array'19 = "persistent_array.rs" 171 19 171 48
  let%span spersistent_array'20 = "persistent_array.rs" 173 84 173 88
  let%span spersistent_array'21 = "persistent_array.rs" 172 18 172 53
  let%span spersistent_array'22 = "persistent_array.rs" 46 18 46 22
  let%span spersistent_array'23 = "persistent_array.rs" 46 27 46 31
  let%span spersistent_array'24 = "persistent_array.rs" 45 18 45 34
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 79 14 79 35
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 108 8 108 22
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 126 14 126 57
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 127 14 127 57
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 136 8 136 45
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 356 18 356 35
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  
  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use set.Set
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq Int32.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 (self: Slice64.slice Int32.t) : Seq.seq Int32.t
  
  axiom view_spec'0: forall self: Slice64.slice Int32.t. [%#sslice'0] Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  axiom view_spec'1: forall self: Slice64.slice Int32.t. [%#sslice'1] view'0 self = Slice64.id self
  
  function view'1 (self: Slice64.slice Int32.t) : Seq.seq Int32.t =
    [%#sboxed] view'0 self
  
  let rec into_vec (self_:Slice64.slice Int32.t) (return'  (x:t_Vec))= any
    [ return''0 (result:t_Vec)-> {[%#sslice] view result = view'1 self_} (! return' {result}) ]
  
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'0  =
    { t_Rc__ptr'0: t_NonNull'1; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'2  =
    { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Rc'1  =
    { t_Rc__ptr'1: t_NonNull'2; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray  =
    { t_PersistentArray__program_value: t_Rc;
      t_PersistentArray__contained_in_token:  t_Rc'0;
      t_PersistentArray__map_invariant:  t_Rc'1 }
  
  predicate invariant' [#"persistent_array.rs" 57 8 57 34] (self: t_PersistentArray)
  
  predicate inv (_0: t_PersistentArray)
  
  axiom inv_axiom [@rewrite]: forall x: t_PersistentArray [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_PersistentArray__program_value = program_value ; t_PersistentArray__contained_in_token = contained_in_token ; t_PersistentArray__map_invariant = map_invariant} -> true
    end)
  
  function view'2 [#"persistent_array.rs" 75 8 75 31] (self: t_PersistentArray) : Seq.seq Int32.t
  
  let rec new (v:t_Vec) (return'  (x:t_PersistentArray))= any
    [ return''0 (result:t_PersistentArray)-> {[%#spersistent_array'15] inv result}
      {[%#spersistent_array'16] view'2 result = view v}
      (! return' {result}) ]
  
  
  type t_Namespaces
  
  let rec deref_mut (self:MutBorrow.t ( t_Namespaces)) (return'  (x:MutBorrow.t t_Namespaces))= any
    [ return''0 (result:MutBorrow.t t_Namespaces)-> {[%#sghost] result = self} (! return' {result}) ]
  
  
  function namespaces (self: t_Namespaces) : Set.set t_Namespace
  
  let rec reborrow (self:MutBorrow.t t_Namespaces) (return'  (x:t_Namespaces))= any
    [ return''0 (result:t_Namespaces)-> {[%#slocal_invariant] namespaces self.current = namespaces result}
      {[%#slocal_invariant'0] namespaces self.final = namespaces result}
      (! return' {result}) ]
  
  
  let rec new'0 (x:t_Namespaces) (return'  (x'0: t_Namespaces))= any
    [ return''0 (result: t_Namespaces)-> {[%#sghost'0] result = x} (! return' {result}) ]
  
  
  predicate invariant''0 (self: t_PersistentArray) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_PersistentArray)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PersistentArray [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'3 (self: t_PersistentArray) : Seq.seq Int32.t =
    [%#smodel] view'2 self
  
  predicate contains [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) =
    [%#sset] Set.mem e self
  
  predicate contains'0 (self: t_Namespaces) (namespace: t_Namespace) =
    [%#slocal_invariant'1] contains (namespaces self) namespace
  
  let rec set (self:t_PersistentArray) (index:UInt64.t) (value:Int32.t) (namespaces'0: t_Namespaces) (return'  (x:t_PersistentArray))= {[@expl:set 'self' type invariant] [%#spersistent_array'17] inv'0 self}
    {[@expl:set requires #0] [%#spersistent_array'18] UInt64.t'int index < Seq.length (view'3 self)}
    {[@expl:set requires #1] [%#spersistent_array'19] contains'0 namespaces'0 (Namespace_PARRAY_0'62 0)}
    any
    [ return''0 (result:t_PersistentArray)-> {[%#spersistent_array'20] inv result}
      {[%#spersistent_array'21] view'2 result = Seq.set (view'3 self) (UInt64.t'int index) value}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Namespaces) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Namespaces) =
    resolve _0
  
  predicate resolve'1 (_0: t_Namespaces) =
    true
  
  predicate resolve'2 (self:  t_Namespaces) =
    [%#sghost'1] resolve'1 self
  
  predicate resolve'3 (_0:  t_Namespaces) =
    resolve'2 _0
  
  let rec clone' (self:t_PersistentArray) (return'  (x:t_PersistentArray))= {[@expl:clone 'self' type invariant] [%#spersistent_array'22] inv'0 self}
    any
    [ return''0 (result:t_PersistentArray)-> {[%#spersistent_array'23] inv result}
      {[%#spersistent_array'24] view'2 result = view'3 self}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec testing[#"persistent_array.rs" 383 0 383 49] (namespaces'0: t_Namespaces) (return'  (x:()))= {[@expl:testing requires] [%#spersistent_array'14] contains'0 namespaces'0 (Namespace_PARRAY_0'62 0)}
    (! bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array Int32.t)-> (! -{Seq.get __arr_temp.Slice64.elts 0
          = ([%#spersistent_array] (1: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 1 = ([%#spersistent_array'0] (2: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 2 = ([%#spersistent_array'1] (3: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 3 = ([%#spersistent_array'2] (4: Int32.t))
          /\ Seq.length __arr_temp.Slice64.elts = 4}-
           [ &_7 <- __arr_temp ] 
          s1) ]
      
      | s1 = bb2 ]
    
    | bb2 = s0 [ s0 = into_vec {_7} (fun (_ret:t_Vec) ->  [ &_4 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = new {_4} (fun (_ret:t_PersistentArray) ->  [ &a <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = MutBorrow.borrow_mut < t_Namespaces> {namespaces'1}
          (fun (_ret:MutBorrow.t ( t_Namespaces)) ->  [ &_14 <- _ret ]  [ &namespaces'1 <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret:MutBorrow.t t_Namespaces) ->  [ &_13 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = MutBorrow.borrow_final <t_Namespaces> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret:MutBorrow.t t_Namespaces) ->  [ &_12 <- _ret ]  [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = reborrow {_12} (fun (_ret:t_Namespaces) ->  [ &_11 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0 [ s0 = new'0 {_11} (fun (_ret: t_Namespaces) ->  [ &_10 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = set {a} {[%#spersistent_array'3] (1: UInt64.t)} {[%#spersistent_array'4] (42: Int32.t)} {_10}
          (fun (_ret:t_PersistentArray) ->  [ &a2 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 = -{resolve'0 _13}- s1
      | s1 = MutBorrow.borrow_mut < t_Namespaces> {namespaces'1}
          (fun (_ret:MutBorrow.t ( t_Namespaces)) ->  [ &_21 <- _ret ]  [ &namespaces'1 <- _ret.final ] s2)
      | s2 = deref_mut {_21} (fun (_ret:MutBorrow.t t_Namespaces) ->  [ &_20 <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = s0
      [ s0 = MutBorrow.borrow_final <t_Namespaces> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret:MutBorrow.t t_Namespaces) ->  [ &_19 <- _ret ]  [ &_20 <- { _20 with current = _ret.final } ] s1)
      | s1 = reborrow {_19} (fun (_ret:t_Namespaces) ->  [ &_18 <- _ret ] s2)
      | s2 = bb10 ]
    
    | bb10 = s0 [ s0 = new'0 {_18} (fun (_ret: t_Namespaces) ->  [ &_17 <- _ret ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 = set {a} {[%#spersistent_array'5] (0: UInt64.t)} {[%#spersistent_array'6] (50: Int32.t)} {_17}
          (fun (_ret:t_PersistentArray) ->  [ &a3 <- _ret ] s1)
      | s1 = bb12 ]
    
    | bb12 = s0
      [ s0 = -{resolve'0 _20}- s1
      | s1 = -{resolve'3 namespaces'1}- s2
      | s2 = clone' {a} (fun (_ret:t_PersistentArray) ->  [ &a4 <- _ret ] s3)
      | s3 = bb13 ]
    
    | bb13 = s0
      [ s0 = 
        [ &a_model <- [%#spersistent_array'7] Seq.create 4 [|(1: Int32.t);(2: Int32.t);(3: Int32.t);(4: Int32.t)|] ]
        
        s1
      | s1 = bb14 ]
    
    | bb14 = s0
      [ s0 = 
        [ &a2_model <- [%#spersistent_array'8] Seq.create 4 [|(1: Int32.t);(42: Int32.t);(3: Int32.t);(4: Int32.t)|] ]
        
        s1
      | s1 = bb15 ]
    
    | bb15 = s0
      [ s0 = 
        [ &a3_model <- [%#spersistent_array'9] Seq.create 4 [|(50: Int32.t);(2: Int32.t);(3: Int32.t);(4: Int32.t)|] ]
        
        s1
      | s1 = bb16 ]
    
    | bb16 = s0
      [ s0 = {[@expl:assertion] [%#spersistent_array'10] view'2 a = a_model} s1
      | s1 = {[@expl:assertion] [%#spersistent_array'11] view'2 a2 = a2_model} s2
      | s2 = {[@expl:assertion] [%#spersistent_array'12] view'2 a3 = a3_model} s3
      | s3 = {[@expl:assertion] [%#spersistent_array'13] view'2 a4 = a_model} s4
      | s4 = bb20 ]
    
    | bb20 = return''0 {_0} ]
    
    [ & _0: () = Any.any_l ()
    | & namespaces'1:  t_Namespaces = namespaces'0
    | & a: t_PersistentArray = Any.any_l ()
    | & _4: t_Vec = Any.any_l ()
    | & _7: Slice64.array Int32.t = Any.any_l ()
    | & a2: t_PersistentArray = Any.any_l ()
    | & _10:  t_Namespaces = Any.any_l ()
    | & _11: t_Namespaces = Any.any_l ()
    | & _12: MutBorrow.t t_Namespaces = Any.any_l ()
    | & _13: MutBorrow.t t_Namespaces = Any.any_l ()
    | & _14: MutBorrow.t ( t_Namespaces) = Any.any_l ()
    | & a3: t_PersistentArray = Any.any_l ()
    | & _17:  t_Namespaces = Any.any_l ()
    | & _18: t_Namespaces = Any.any_l ()
    | & _19: MutBorrow.t t_Namespaces = Any.any_l ()
    | & _20: MutBorrow.t t_Namespaces = Any.any_l ()
    | & _21: MutBorrow.t ( t_Namespaces) = Any.any_l ()
    | & a4: t_PersistentArray = Any.any_l ()
    | & a_model: Seq.seq Int32.t = Any.any_l ()
    | & a2_model: Seq.seq Int32.t = Any.any_l ()
    | & a3_model: Seq.seq Int32.t = Any.any_l () ]
    ) [ return''0 (result:())-> (! return' {result}) ] 
end
module M_persistent_array__implementation__qyi15164097500274694161__clone__refines [#"persistent_array.rs" 46 8 46 31] (* <implementation::PersistentArray<T> as creusot_contracts::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Namespace_PARRAY_0'62 int
    | Other namespace_other
  
  let%span spersistent_array = "persistent_array.rs" 46 8 46 31
  let%span spersistent_array'0 = "persistent_array.rs" 77 16 77 43
  let%span spersistent_array'1 = "persistent_array.rs" 60 16 62 62
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 90 8 90 22
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.int.UInt64
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc  =
    { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0  =
    { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'1  =
    { t_Rc__ptr'1: t_NonNull'1; t_Rc__phantom'1: (); t_Rc__alloc'1: () }
  
  type t_PersistentArray  =
    { t_PersistentArray__program_value: t_Rc;
      t_PersistentArray__contained_in_token:  t_Rc'0;
      t_PersistentArray__map_invariant:  t_Rc'1 }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type tuple  =
    { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function view'0 (self: t_Fragment) : tuple =
    [%#sboxed] view self
  
  function view'1 (self: t_Rc'0) : t_Fragment
  
  function view'2 (self:  t_Rc'0) : t_Fragment =
    [%#sghost] view'1 self
  
  type t_NonNull'2  =
    { t_NonNull__pointer'2: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull'2; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner  =
    | C_Direct t_Vec
    | C_Link UInt64.t t_T t_Rc
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_Inner }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  function id (self: t_PCell) : t_Id
  
  function view'3 (self: t_Rc) : t_PCell
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'4 (self: t_Rc'1) : t_LocalInvariant
  
  function view'5 (self:  t_Rc'1) : t_LocalInvariant =
    [%#sghost] view'4 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant' [#"persistent_array.rs" 57 8 57 34] (self: t_PersistentArray) =
    [%#spersistent_array'1] (view'0 (view'2 self.t_PersistentArray__contained_in_token))._p0
    = id (view'3 self.t_PersistentArray__program_value)
    /\ id'0 (view'2 self.t_PersistentArray__contained_in_token) = public (view'5 self.t_PersistentArray__map_invariant)
    /\ namespace (view'5 self.t_PersistentArray__map_invariant) = Namespace_PARRAY_0'62 0
  
  predicate inv (_0: t_PersistentArray)
  
  axiom inv_axiom [@rewrite]: forall x: t_PersistentArray [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_PersistentArray__program_value = program_value ; t_PersistentArray__contained_in_token = contained_in_token ; t_PersistentArray__map_invariant = map_invariant} -> true
    end)
  
  predicate invariant''0 (self: t_PersistentArray) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_PersistentArray)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PersistentArray [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'6 [#"persistent_array.rs" 75 8 75 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'0] (view'0 (view'2 self.t_PersistentArray__contained_in_token))._p1
  
  function view'7 (self: t_PersistentArray) : Seq.seq t_T =
    [%#smodel] view'6 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#spersistent_array] forall self_: t_PersistentArray. inv'0 self_
   -> inv'0 self_ /\ (forall result: t_PersistentArray. view'6 result = view'7 self_ /\ inv result  -> inv result)
end
