module M_persistent_array__implementation__qyi15164097500274694161__clone [#"persistent_array.rs" 48 8 48 31] (* <implementation::PersistentArray<T> as creusot_contracts::Clone> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 45 18 45 33
  let%span spersistent_array = "persistent_array.rs" 48 18 48 22
  let%span spersistent_array'0 = "persistent_array.rs" 48 27 48 31
  let%span spersistent_array'1 = "persistent_array.rs" 47 18 47 34
  let%span spersistent_array'2 = "persistent_array.rs" 78 24 78 36
  let%span spersistent_array'3 = "persistent_array.rs" 62 16 64 52
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 78 14 78 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 78 4 78 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 183 15 183 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 183 4 185 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span sfmap_view = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 125 14 125 18
  let%span sfmap_view'0 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 125 4 125 27
  let%span sfmap_view'1 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 123 14 123 30
  let%span sfmap_view'2 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 124 14 124 38
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  let rec clone' (self_: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src] result = self_} (! return' {result}) ]
  
  predicate invariant' (self: t_Fragment)
  
  predicate inv (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''0 (self: t_Fragment) = [%#sghost'6] inv self
  
  predicate inv'0 (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate invariant''1 (self: t_Fragment) = [%#sinvariant] inv'0 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'1 (_0: t_Fragment)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x = invariant''1 x
  
  predicate invariant''2 (self: t_Fragment) = [%#sinvariant] inv self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 (_0: t_Fragment)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Fragment [inv'2 x]. inv'2 x = invariant''2 x
  
  let rec deref (self: t_Fragment) (return' (x: t_Fragment)) =
    {[@expl:deref 'self' type invariant] [%#sghost] inv'1 self}
    any
    [ return''0 (result: t_Fragment) -> {[%#sghost'0] inv'2 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function view'0 (self: t_Fragment) : tuple = [%#smodel] view self
  
  function id (self: t_Fragment) : t_Id
  
  let rec clone''0 (self: t_Fragment) (return' (x: t_Fragment)) =
    {[@expl:clone 'self' type invariant] [%#sfmap_view] inv'2 self}
    any
    [ return''0 (result: t_Fragment) -> {[%#sfmap_view'0] inv result}
      {[%#sfmap_view'1] view result = view'0 self}
      {[%#sfmap_view'2] id result = id self}
      (! return' {result}) ]
  
  let rec new (x: t_Fragment) (return' (x'0: t_Fragment)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv x}
    any [ return''0 (result: t_Fragment) -> {[%#sghost'3] inv'0 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  let rec deref'0 (self: t_Rc'0) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost'1] result = self} (! return' {result}) ]
  
  let rec clone''1 (self_: t_Rc'0) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#src] result = self_} (! return' {result}) ]
  
  let rec new'0 (x: t_Rc'0) (return' (x'0: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost'4] result = x} (! return' {result}) ]
  
  function view'1 (self: t_Fragment) : tuple = [%#sghost'5] view self
  
  type t_PermCell
  
  function id'0 (self: t_PermCell) : t_Id
  
  function view'2 (self: t_Rc) : t_PermCell
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'3 (self: t_Rc'0) : t_LocalInvariant
  
  function view'4 (self: t_Rc'0) : t_LocalInvariant = [%#sghost'5] view'3 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''3 [#"persistent_array.rs" 59 8 59 34] (self: t_PersistentArray) =
    [%#spersistent_array'3] (view'1 self.t_PersistentArray__frag)._p0 = id'0 (view'2 self.t_PersistentArray__permcell)
    /\ id self.t_PersistentArray__frag = public (view'4 self.t_PersistentArray__inv)
    /\ namespace (view'4 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'3 (_0: t_PersistentArray)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PersistentArray [inv'3 x]. inv'3 x
      = (invariant''3 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'4} -> inv'0 frag
        end)
  
  predicate invariant''4 (self: t_PersistentArray) = [%#sinvariant] inv'3 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'4 (_0: t_PersistentArray)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PersistentArray [inv'4 x]. inv'4 x = invariant''4 x
  
  function view'5 [#"persistent_array.rs" 77 8 77 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'2] (view'1 self.t_PersistentArray__frag)._p1
  
  function view'6 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'5 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''2 [#"persistent_array.rs" 48 8 48 31] (self: t_PersistentArray) (return' (x: t_PersistentArray)) =
    {[@expl:clone 'self' type invariant] [%#spersistent_array] inv'4 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone' {self'0.t_PersistentArray__permcell} (fun (_ret: t_Rc) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref {self'0.t_PersistentArray__frag} (fun (_ret: t_Fragment) -> [ &_8 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = clone''0 {_8} (fun (_ret: t_Fragment) -> [ &_6 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_6} (fun (_ret: t_Fragment) -> [ &_5 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = deref'0 {self'0.t_PersistentArray__inv} (fun (_ret: t_Rc'0) -> [ &_13 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = clone''1 {_13} (fun (_ret: t_Rc'0) -> [ &_11 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = new'0 {_11} (fun (_ret: t_Rc'0) -> [ &_10 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_0 <- { t_PersistentArray__permcell = _3; t_PersistentArray__frag = _5; t_PersistentArray__inv = _10 } ]
        s1
      | s1 = bb8 ]
    | bb8 = return''0 {_0} ]
    [ & _0: t_PersistentArray = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & _3: t_Rc = Any.any_l ()
    | & _5: t_Fragment = Any.any_l ()
    | & _6: t_Fragment = Any.any_l ()
    | & _8: t_Fragment = Any.any_l ()
    | & _10: t_Rc'0 = Any.any_l ()
    | & _11: t_Rc'0 = Any.any_l ()
    | & _13: t_Rc'0 = Any.any_l () ])
    [ return''0 (result: t_PersistentArray) ->
    {[@expl:clone result type invariant] [%#spersistent_array'0] inv'3 result}
      {[@expl:clone ensures] [%#spersistent_array'1] view'5 result = view'6 self}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__new [#"persistent_array.rs" 131 8 131 37] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 31 26 31 43
  let%span spersistent_array = "persistent_array.rs" 132 22 132 35
  let%span spersistent_array'0 = "persistent_array.rs" 135 42 135 69
  let%span spersistent_array'1 = "persistent_array.rs" 144 31 144 47
  let%span spersistent_array'2 = "persistent_array.rs" 146 20 146 40
  let%span spersistent_array'3 = "persistent_array.rs" 147 20 147 39
  let%span spersistent_array'4 = "persistent_array.rs" 131 19 131 20
  let%span spersistent_array'5 = "persistent_array.rs" 131 33 131 37
  let%span spersistent_array'6 = "persistent_array.rs" 130 18 130 31
  let%span spersistent_array'7 = "persistent_array.rs" 78 24 78 36
  let%span spersistent_array'8 = "persistent_array.rs" 100 12 103 13
  let%span spersistent_array'9 = "persistent_array.rs" 111 16 123 21
  let%span spersistent_array'10 = "persistent_array.rs" 62 16 64 52
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 89 22 89 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 89 4 89 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 88 14 88 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 183 15 183 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 183 4 185 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 78 14 78 18
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 78 4 78 36
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 205 22 205 26
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 205 4 207 17
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 203 14 203 29
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span sfmap_view = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 80 4 80 31
  let%span sfmap_view'0 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 79 14 79 38
  let%span sfmap_view'1 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 96 23 96 27
  let%span sfmap_view'2 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 89 15 89 34
  let%span sfmap_view'3 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 96 4 96 78
  let%span sfmap_view'4 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 90 14 90 46
  let%span sfmap_view'5 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 91 14 91 39
  let%span sfmap_view'6 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 92 14 92 33
  let%span sfmap_view'7 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 93 14 93 38
  let%span smodel = "../../creusot-contracts/src/model.rs" 63 8 63 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 106 20 106 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spermcell = "../../creusot-contracts/src/cell/permcell.rs" 103 15 103 20
  let%span spermcell'0 = "../../creusot-contracts/src/cell/permcell.rs" 103 4 103 57
  let%span spermcell'1 = "../../creusot-contracts/src/cell/permcell.rs" 101 14 101 44
  let%span spermcell'2 = "../../creusot-contracts/src/cell/permcell.rs" 102 14 102 35
  let%span spermcell'3 = "../../creusot-contracts/src/cell/permcell.rs" 85 21 85 25
  let%span spermcell'4 = "../../creusot-contracts/src/cell/permcell.rs" 84 14 84 34
  let%span spermcell'5 = "../../creusot-contracts/src/cell/permcell.rs" 34 4 34 12
  let%span spermcell'6 = "../../creusot-contracts/src/cell/permcell.rs" 62 20 62 46
  let%span spermcell'7 = "../../creusot-contracts/src/cell/permcell.rs" 45 8 45 27
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 286 4 286 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 284 4 284 33
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 445 29 445 33
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 445 43 445 48
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 445 4 445 65
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 443 14 443 49
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 444 14 444 40
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 120 4 120 12
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span sfmap'17 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span slocal_invariant = "../../creusot-contracts/src/ghost/local_invariant.rs" 301 8 301 13
  let%span slocal_invariant'0 = "../../creusot-contracts/src/ghost/local_invariant.rs" 296 4 296 40
  let%span slocal_invariant'1 = "../../creusot-contracts/src/ghost/local_invariant.rs" 297 14 297 40
  let%span slocal_invariant'2 = "../../creusot-contracts/src/ghost/local_invariant.rs" 298 14 298 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 775 8 778 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 685 20 685 91
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_PermCell
  
  type t_PermCellOwn
  
  type tuple = { _p0: t_PermCell; _p1: t_PermCellOwn }
  
  predicate inv (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv self
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  predicate inv'1 (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 (self: t_Vec) = [%#svec'0] inv'1 (view self)
  
  predicate inv'2 (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
      = match x with
        | C_Direct a_0 -> inv'2 a_0
        | C_Link index value next -> inv value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant'0] inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PermCellOwn) = [%#spermcell'6] inv'4 (val' self)
  
  predicate inv'5 (_0: t_PermCellOwn)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PermCellOwn [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self: t_PermCellOwn) = [%#sghost'12] inv'5 self
  
  predicate inv'6 (_0: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: tuple)
  
  axiom inv_axiom'6 [@rewrite]: forall x: tuple [inv'7 x]. inv'7 x = (let {_p0 = x0; _p1 = x1} = x in inv'6 x1)
  
  type t_Id
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function view'0 (self: t_PermCellOwn) : t_Inner = [%#spermcell'5] val' self
  
  let rec new (value: t_Inner) (return' (x: tuple)) = {[@expl:new 'value' type invariant] [%#spermcell] inv'3 value}
    any
    [ return''0 (result: tuple) -> {[%#spermcell'0] inv'7 result}
      {[%#spermcell'1] id result._p0 = id'0 result._p1}
      {[%#spermcell'2] view'0 result._p1 = value}
      (! return' {result}) ]
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate invariant''6 (self: t_Authority) = [%#sghost'12] inv'8 self
  
  predicate inv'9 (_0: t_Authority)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Authority [inv'9 x]. inv'9 x = invariant''6 x
  
  type t_FMap
  
  function view'1 (self: t_Authority) : t_FMap
  
  function view'2 (self: t_Authority) : t_FMap = [%#sghost'11] view'1 self
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'13] len self >= 0
  
  type t_Option = C_None | C_Some (Seq.seq t_T)
  
  function view'3 (self: t_FMap) : Map.map t_Id t_Option
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'6] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'7] view'3 empty = Const.const (C_None)
  
  let rec new'0 (return' (x: t_Authority)) = any
    [ return''0 (result: t_Authority) -> {[%#sfmap_view] inv'9 result}
      {[%#sfmap_view'0] view'2 result = empty}
      (! return' {result}) ]
  
  predicate invariant''7 (self: MutBorrow.t t_Authority) = [%#sinvariant] inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'10 (_0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'10 x]. inv'10 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t t_Authority) = [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'11 (_0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'11 x]. inv'11 x = invariant''8 x
  
  let rec deref_mut (self: MutBorrow.t t_Authority) (return' (x: MutBorrow.t t_Authority)) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'10 self}
    any
    [ return''0 (result: MutBorrow.t t_Authority) -> {[%#sghost'0] inv'11 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'12] Map.get (view'3 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'8] get self k <> C_None
  
  function view'4 (self: MutBorrow.t t_Authority) : t_FMap = [%#smodel] view'1 self.current
  
  predicate invariant''9 (self: t_Fragment)
  
  predicate inv'12 (_0: t_Fragment)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Fragment [inv'12 x]. inv'12 x
      = (invariant''9 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  function insert (self: t_FMap) (k: t_Id) (v: Seq.seq t_T) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: Seq.seq t_T. [%#sfmap'9] view'3 (insert self k v)
      = Map.set (view'3 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: Seq.seq t_T. [%#sfmap'10] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function id'1 (self: t_Authority) : t_Id
  
  type tuple'0 = { _p0'0: t_Id; _p1'0: Seq.seq t_T }
  
  function view'5 (self: t_Fragment) : tuple'0
  
  function id'2 (self: t_Fragment) : t_Id
  
  let rec insert'0 (self: MutBorrow.t t_Authority) (k: t_Id) (v: Seq.seq t_T) (return' (x: t_Fragment)) =
    {[@expl:insert 'self' type invariant] [%#sfmap_view'1] inv'11 self}
    {[@expl:insert requires] [%#sfmap_view'2] not contains (view'4 self) k}
    any
    [ return''0 (result: t_Fragment) -> {[%#sfmap_view'3] inv'12 result}
      {[%#sfmap_view'4] view'1 self.final = insert (view'4 self) k v}
      {[%#sfmap_view'5] id'1 self.final = id'1 self.current}
      {[%#sfmap_view'6] view'5 result = { _p0'0 = k; _p1'0 = v }}
      {[%#sfmap_view'7] id'2 result = id'1 self.current}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_Authority) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0: MutBorrow.t t_Authority) = resolve _0
  
  predicate invariant''10 (self: t_Fragment) = [%#sghost'12] inv'12 self
  
  predicate inv'13 (_0: t_Fragment)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Fragment [inv'13 x]. inv'13 x = invariant''10 x
  
  let rec new'1 (x: t_Fragment) (return' (x'0: t_Fragment)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'12 x}
    any
    [ return''0 (result: t_Fragment) -> {[%#sghost'3] inv'13 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PermCellOwn
  
  function view'6 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = [%#sfmap'12] Map.get (view'6 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'8] get'0 self k <> C_None'0
  
  predicate inv'14 (_0: t_Id)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Id [inv'14 x]. inv'14 x = true
  
  predicate index_logic (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. ([%#slogic] exists x: t_PermCellOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option'0) : t_PermCellOwn = [%#soption'1] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_PermCellOwn =
    [%#sfmap'18] unwrap_logic (get'0 self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : t_PermCellOwn = [%#sfmap'17] lookup self key
  
  predicate invariant''11 (self: t_FMap'0) =
    [%#sfmap'16] forall k: t_Id. contains'0 self k -> inv'14 k /\ inv'5 (index_logic'0 self k)
  
  predicate inv'15 (_0: t_FMap'0)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_FMap'0 [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate invariant''12 (self: t_FMap'0) = [%#sghost'12] inv'15 self
  
  predicate inv'16 (_0: t_FMap'0)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_FMap'0 [inv'16 x]. inv'16 x = invariant''12 x
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) = [%#sfmap'15] forall k: t_Id. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap'14] ext_eq self other = (self = other)
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'13] len'0 self >= 0
  
  constant empty'0 : t_FMap'0
  
  axiom empty_spec'1: [%#sfmap'6] len'0 empty'0 = 0
  
  axiom empty_spec'2: [%#sfmap'7] view'6 empty'0 = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap'0) = [%#sfmap'11] ext_eq self empty'0
  
  let rec new'2 (return' (x: t_FMap'0)) = any
    [ return''0 (result: t_FMap'0) -> {[%#sfmap] inv'16 result} {[%#sfmap'0] is_empty result} (! return' {result}) ]
  
  predicate invariant''13 (self: MutBorrow.t t_FMap'0) = [%#sinvariant] inv'16 self.current /\ inv'16 self.final
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'17 (_0: MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t t_FMap'0 [inv'17 x]. inv'17 x = invariant''13 x
  
  predicate invariant''14 (self: MutBorrow.t t_FMap'0) = [%#sinvariant] inv'15 self.current /\ inv'15 self.final
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'18 (_0: MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_FMap'0 [inv'18 x]. inv'18 x = invariant''14 x
  
  let rec deref_mut'0 (self: MutBorrow.t t_FMap'0) (return' (x: MutBorrow.t t_FMap'0)) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'17 self}
    any
    [ return''0 (result: MutBorrow.t t_FMap'0) -> {[%#sghost'0] inv'18 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate invariant''15 (self: t_PermCellOwn) = [%#sinvariant'0] inv'6 self
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'19 (_0: t_PermCellOwn)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_PermCellOwn [inv'19 x]. inv'19 x = invariant''15 x
  
  predicate invariant''16 (self: t_PermCellOwn) = [%#sinvariant'0] inv'5 self
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'20 (_0: t_PermCellOwn)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PermCellOwn [inv'20 x]. inv'20 x = invariant''16 x
  
  let rec deref (self: t_PermCellOwn) (return' (x: t_PermCellOwn)) =
    {[@expl:deref 'self' type invariant] [%#sghost'5] inv'19 self}
    any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost'6] inv'20 result}
      {[%#sghost'7] result = self}
      (! return' {result}) ]
  
  let rec id_ghost (self: t_PermCellOwn) (return' (x: t_Id)) =
    {[@expl:id_ghost 'self' type invariant] [%#spermcell'3] inv'20 self}
    any [ return''0 (result: t_Id) -> {[%#spermcell'4] result = id'0 self} (! return' {result}) ]
  
  let rec deref'0 (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'7] result = self} (! return' {result}) ]
  
  let rec into_inner (self: t_PermCellOwn) (return' (x: t_PermCellOwn)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'8] inv'6 self}
    any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost'9] inv'5 result}
      {[%#sghost'10] result = self}
      (! return' {result}) ]
  
  predicate inv'21 (_0: t_Option'0)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Option'0 [inv'21 x]. inv'21 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'5 a_0
        end
  
  function insert'1 (self: t_FMap'0) (k: t_Id) (v: t_PermCellOwn) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_Id, v: t_PermCellOwn. [%#sfmap'9] view'6 (insert'1 self k v)
      = Map.set (view'6 self) k (C_Some'0 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_Id, v: t_PermCellOwn. [%#sfmap'10] len'0 (insert'1 self k v)
      = (if contains'0 self k then len'0 self else len'0 self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap'0) (key: t_Id) (value: t_PermCellOwn) (return' (x: t_Option'0)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'1] inv'18 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'2] inv'5 value}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'3] inv'21 result}
      {[%#sfmap'4] self.final = insert'1 self.current key value}
      {[%#sfmap'5] result = get'0 self.current key}
      (! return' {result}) ]
  
  predicate resolve'1 (_0: t_Inner) = true
  
  predicate resolve'2 (self: t_PermCellOwn) = [%#spermcell'7] resolve'1 (val' self)
  
  predicate resolve'3 (_0: t_PermCellOwn) = resolve'2 _0
  
  predicate resolve'4 (self: t_Option'0) =
    [%#soption] match self with
      | C_Some'0 x -> resolve'3 x
      | C_None'0 -> true
      end
  
  predicate resolve'5 (_0: t_Option'0) = resolve'4 _0
  
  predicate resolve'6 (self: MutBorrow.t t_FMap'0) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 (_0: MutBorrow.t t_FMap'0) = resolve'6 _0
  
  let rec into_inner'0 (self: t_FMap'0) (return' (x: t_FMap'0)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'8] inv'16 self}
    any
    [ return''0 (result: t_FMap'0) -> {[%#sghost'9] inv'15 result} {[%#sghost'10] result = self} (! return' {result}) ]
  
  let rec into_inner'1 (self: t_Authority) (return' (x: t_Authority)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'8] inv'9 self}
    any
    [ return''0 (result: t_Authority) -> {[%#sghost'9] inv'8 result}
      {[%#sghost'10] result = self}
      (! return' {result}) ]
  
  type t_PA = { t_PA__perms: t_FMap'0; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  predicate inv'22 (_0: t_PA)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_PA [inv'22 x]. inv'22 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'15 perms /\ inv'8 auth
        end
  
  predicate invariant''17 (self: t_PA) = [%#sghost'12] inv'22 self
  
  predicate inv'23 (_0: t_PA)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_PA [inv'23 x]. inv'23 x = invariant''17 x
  
  let rec new'3 (x: t_PA) (return' (x'0: t_PA)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'22 x}
    any [ return''0 (result: t_PA) -> {[%#sghost'3] inv'23 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  type t_LocalInvariant
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#slogic] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#slogic'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option) : Seq.seq t_T = [%#soption'1] match self with
      | C_Some x -> x
      | C_None -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap) (k: t_Id) : Seq.seq t_T = [%#sfmap'18] unwrap_logic'0 (get self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap) (key: t_Id) : Seq.seq t_T = [%#sfmap'17] lookup'0 self key
  
  function view'7 (self: t_Vec) : Seq.seq t_T = [%#smodel'0] view self
  
  function view'8 (self: t_Rc) : t_PermCell
  
  function view'9 (self: t_Rc) : t_PermCell = [%#smodel'0] view'8 self
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  function view'10 (self: UInt64.t) : int = [%#smodel'0] UInt64.t'int self
  
  predicate partial_invariant [#"persistent_array.rs" 109 8 109 59] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'9] id'1 self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains (view'1 self.t_PA__auth) id'3 /\ contains'0 self.t_PA__perms id'3
      -> id'0 (index_logic'0 self.t_PA__perms id'3) = id'3
      /\ match val' (index_logic'0 self.t_PA__perms id'3) with
        | C_Direct v -> index_logic'2 (view'1 self.t_PA__auth) id'3 = view'7 v
        | C_Link index value next -> contains (view'1 self.t_PA__auth) (id (view'9 next))
        /\ index_logic'3 self.t_PA__depth id'3 > index_logic'3 self.t_PA__depth (id (view'9 next))
        /\ view'10 index < Seq.length (index_logic'2 (view'1 self.t_PA__auth) (id (view'9 next)))
        /\ index_logic'2 (view'1 self.t_PA__auth) id'3
        = Seq.set (index_logic'2 (view'1 self.t_PA__auth) (id (view'9 next))) (view'10 index) value
        end)
  
  predicate protocol [#"persistent_array.rs" 99 8 99 50] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'8] partial_invariant self resource_id
    /\ (forall id'3: t_Id. contains (view'1 self.t_PA__auth) id'3 -> contains'0 self.t_PA__perms id'3)
  
  function public (self: t_LocalInvariant) : t_Id
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  let rec new'4 (value: t_PA) (public'0: t_Id) (namespace'0: t_Namespace) (return' (x: t_LocalInvariant)) =
    {[@expl:new 'value' type invariant] [%#slocal_invariant] inv'23 value}
    {[@expl:new requires] [%#slocal_invariant'0] protocol value public'0}
    any
    [ return''0 (result: t_LocalInvariant) -> {[%#slocal_invariant'1] public result = public'0}
      {[%#slocal_invariant'2] namespace result = namespace'0}
      (! return' {result}) ]
  
  let rec into_inner'2 (self: t_LocalInvariant) (return' (x: t_LocalInvariant)) = any
    [ return''0 (result: t_LocalInvariant) -> {[%#sghost'10] result = self} (! return' {result}) ]
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'1; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  function view'11 (self: t_Rc'0) : t_LocalInvariant
  
  let rec new'5 (value: t_LocalInvariant) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#src] view'11 result = value} (! return' {result}) ]
  
  let rec new'6 (x: t_Rc'0) (return' (x'0: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost'4] result = x} (! return' {result}) ]
  
  let rec new'7 (value: t_PermCell) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src] view'8 result = value} (! return' {result}) ]
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  function view'12 (self: t_Fragment) : tuple'0 = [%#sghost'11] view'5 self
  
  function view'13 (self: t_Rc'0) : t_LocalInvariant = [%#sghost'11] view'11 self
  
  predicate invariant''18 [#"persistent_array.rs" 59 8 59 34] (self: t_PersistentArray) =
    [%#spersistent_array'10] (view'12 self.t_PersistentArray__frag)._p0'0 = id (view'8 self.t_PersistentArray__permcell)
    /\ id'2 self.t_PersistentArray__frag = public (view'13 self.t_PersistentArray__inv)
    /\ namespace (view'13 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'24 (_0: t_PersistentArray)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_PersistentArray [inv'24 x]. inv'24 x
      = (invariant''18 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'25} -> inv'13 frag
        end)
  
  function view'14 [#"persistent_array.rs" 77 8 77 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'7] (view'12 self.t_PersistentArray__frag)._p1'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'8 [#"persistent_array.rs" 131 8 131 37] (v: t_Vec) (return' (x: t_PersistentArray)) =
    {[@expl:new 'v' type invariant] [%#spersistent_array'4] inv'2 v}
    (! bb0
    [ bb0 = s0 [ s0 = [ &seq <- [%#spersistent_array] view v'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_8 <- C_Direct v'0 ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = new {_8} (fun (_ret: tuple) -> [ &_7 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &permcell <- _7._p0 ] s1 | s1 = [ &permcellown <- _7._p1 ] s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = new'0 (fun (_ret: t_Authority) -> [ &auth <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'9 auth}
        MutBorrow.borrow_mut <t_Authority> {auth}
          (fun (_ret: MutBorrow.t t_Authority) -> [ &_15 <- _ret ] -{inv'9 _ret.final}- [ &auth <- _ret.final ] s1)
      | s1 = deref_mut {_15} (fun (_ret: MutBorrow.t t_Authority) -> [ &_14 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = [ &_16 <- [%#spersistent_array'0] id'0 permcellown ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'8 _14.current}
        MutBorrow.borrow_final <t_Authority> {_14.current} {MutBorrow.get_id _14}
          (fun (_ret: MutBorrow.t t_Authority) ->
            [ &_13 <- _ret ] -{inv'8 _ret.final}-
            [ &_14 <- { _14 with current = _ret.final } ] s1)
      | s1 = insert'0 {_13} {_16} {seq} (fun (_ret: t_Fragment) -> [ &_12 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'11 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 = new'1 {_12} (fun (_ret: t_Fragment) -> [ &frag <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0 [ s0 = new'2 (fun (_ret: t_FMap'0) -> [ &perms <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'16 perms}
        MutBorrow.borrow_mut <t_FMap'0> {perms}
          (fun (_ret: MutBorrow.t t_FMap'0) -> [ &_25 <- _ret ] -{inv'16 _ret.final}- [ &perms <- _ret.final ] s1)
      | s1 = deref_mut'0 {_25} (fun (_ret: MutBorrow.t t_FMap'0) -> [ &_24 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0 [ s0 = deref {permcellown} (fun (_ret: t_PermCellOwn) -> [ &_31 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = id_ghost {_31} (fun (_ret: t_Id) -> [ &_29 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = deref'0 {_29} (fun (_ret: t_Id) -> [ &_27 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0 [ s0 = into_inner {permcellown} (fun (_ret: t_PermCellOwn) -> [ &_33 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'15 _24.current}
        MutBorrow.borrow_final <t_FMap'0> {_24.current} {MutBorrow.get_id _24}
          (fun (_ret: MutBorrow.t t_FMap'0) ->
            [ &_23 <- _ret ] -{inv'15 _ret.final}-
            [ &_24 <- { _24 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_23} {_27} {_33} (fun (_ret: t_Option'0) -> [ &_22 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'21 _22} s3
      | s3 = -{resolve'5 _22}- s4
      | s4 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'18 _24} s1
      | s1 = -{resolve'7 _24}- s2
      | s2 = into_inner'0 {perms} (fun (_ret: t_FMap'0) -> [ &_38 <- _ret ] s3)
      | s3 = bb17 ]
    | bb17 = s0 [ s0 = into_inner'1 {auth} (fun (_ret: t_Authority) -> [ &_40 <- _ret ] s1) | s1 = bb18 ]
    | bb18 = s0 [ s0 = [ &_42 <- [%#spersistent_array'1] fun (__0: t_Id) -> 0 ] s1 | s1 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_37 <- { t_PA__perms = _38; t_PA__auth = _40; t_PA__depth = _42 } ] s1
      | s1 = new'3 {_37} (fun (_ret: t_PA) -> [ &_36 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = [ &_44 <- [%#spersistent_array'2] id'2 frag ] s1 | s1 = bb21 ]
    | bb21 = s0 [ s0 = [ &_46 <- [%#spersistent_array'3] Namespace_PARRAY 0 ] s1 | s1 = bb22 ]
    | bb22 = s0 [ s0 = new'4 {_36} {_44} {_46} (fun (_ret: t_LocalInvariant) -> [ &local_inv <- _ret ] s1) | s1 = bb23 ]
    | bb23 = s0 [ s0 = into_inner'2 {local_inv} (fun (_ret: t_LocalInvariant) -> [ &_48 <- _ret ] s1) | s1 = bb24 ]
    | bb24 = s0 [ s0 = new'5 {_48} (fun (_ret: t_Rc'0) -> [ &_20 <- _ret ] s1) | s1 = bb25 ]
    | bb25 = s0 [ s0 = new'6 {_20} (fun (_ret: t_Rc'0) -> [ &inv'25 <- _ret ] s1) | s1 = bb26 ]
    | bb26 = s0 [ s0 = new'7 {permcell} (fun (_ret: t_Rc) -> [ &_50 <- _ret ] s1) | s1 = bb27 ]
    | bb27 = s0
      [ s0 = [ &_0 <- { t_PersistentArray__permcell = _50;
                        t_PersistentArray__frag = frag;
                        t_PersistentArray__inv = inv'25 } ] s1
      | s1 = bb30 ]
    | bb30 = return''0 {_0} ]
    [ & _0: t_PersistentArray = Any.any_l ()
    | & v'0: t_Vec = v
    | & seq: Seq.seq t_T = Any.any_l ()
    | & permcell: t_PermCell = Any.any_l ()
    | & permcellown: t_PermCellOwn = Any.any_l ()
    | & _7: tuple = Any.any_l ()
    | & _8: t_Inner = Any.any_l ()
    | & auth: t_Authority = Any.any_l ()
    | & frag: t_Fragment = Any.any_l ()
    | & _12: t_Fragment = Any.any_l ()
    | & _13: MutBorrow.t t_Authority = Any.any_l ()
    | & _14: MutBorrow.t t_Authority = Any.any_l ()
    | & _15: MutBorrow.t t_Authority = Any.any_l ()
    | & _16: t_Id = Any.any_l ()
    | & inv'25: t_Rc'0 = Any.any_l ()
    | & _20: t_Rc'0 = Any.any_l ()
    | & perms: t_FMap'0 = Any.any_l ()
    | & _22: t_Option'0 = Any.any_l ()
    | & _23: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _24: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _25: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _27: t_Id = Any.any_l ()
    | & _29: t_Id = Any.any_l ()
    | & _31: t_PermCellOwn = Any.any_l ()
    | & _33: t_PermCellOwn = Any.any_l ()
    | & local_inv: t_LocalInvariant = Any.any_l ()
    | & _36: t_PA = Any.any_l ()
    | & _37: t_PA = Any.any_l ()
    | & _38: t_FMap'0 = Any.any_l ()
    | & _40: t_Authority = Any.any_l ()
    | & _42: Map.map t_Id int = Any.any_l ()
    | & _44: t_Id = Any.any_l ()
    | & _46: t_Namespace = Any.any_l ()
    | & _48: t_LocalInvariant = Any.any_l ()
    | & _50: t_Rc = Any.any_l () ])
    [ return''0 (result: t_PersistentArray) -> {[@expl:new result type invariant] [%#spersistent_array'5] inv'24 result}
      {[@expl:new ensures] [%#spersistent_array'6] view'14 result = view v}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__set [#"persistent_array.rs" 159 8 159 80] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 45 18 45 33
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 31 26 31 43
  let%span src'1 = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span spersistent_array = "persistent_array.rs" 160 26 160 61
  let%span spersistent_array'0 = "persistent_array.rs" 159 20 159 24
  let%span spersistent_array'1 = "persistent_array.rs" 159 40 159 45
  let%span spersistent_array'2 = "persistent_array.rs" 156 19 156 39
  let%span spersistent_array'3 = "persistent_array.rs" 157 8 157 46
  let%span spersistent_array'4 = "persistent_array.rs" 159 76 159 80
  let%span spersistent_array'5 = "persistent_array.rs" 158 18 158 53
  let%span spersistent_array'6 = "persistent_array.rs" 173 31 173 98
  let%span spersistent_array'7 = "persistent_array.rs" 174 35 174 53
  let%span spersistent_array'8 = "persistent_array.rs" 163 45 163 53
  let%span spersistent_array'9 = "persistent_array.rs" 163 50 163 52
  let%span spersistent_array'10 = "persistent_array.rs" 78 24 78 36
  let%span spersistent_array'11 = "persistent_array.rs" 62 16 64 52
  let%span spersistent_array'12 = "persistent_array.rs" 100 12 103 13
  let%span spersistent_array'13 = "persistent_array.rs" 111 16 123 21
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 78 14 78 18
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 78 4 78 36
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 203 14 203 29
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 89 22 89 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 89 4 89 48
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 88 14 88 35
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 205 22 205 26
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 205 4 207 17
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 183 15 183 16
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 183 4 185 17
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 193 14 193 26
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'13 = "../../creusot-contracts/src/ghost.rs" 127 8 127 22
  let%span sghost'14 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span sghost'15 = "../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sfmap_view = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 105 14 105 49
  let%span sfmap_view'3 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 96 23 96 27
  let%span sfmap_view'4 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 89 15 89 34
  let%span sfmap_view'5 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 96 4 96 78
  let%span sfmap_view'6 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 90 14 90 46
  let%span sfmap_view'7 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 91 14 91 39
  let%span sfmap_view'8 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 92 14 92 33
  let%span sfmap_view'9 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 93 14 93 38
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 63 8 63 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 106 20 106 44
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span spermcell = "../../creusot-contracts/src/cell/permcell.rs" 103 15 103 20
  let%span spermcell'0 = "../../creusot-contracts/src/cell/permcell.rs" 103 4 103 57
  let%span spermcell'1 = "../../creusot-contracts/src/cell/permcell.rs" 101 14 101 44
  let%span spermcell'2 = "../../creusot-contracts/src/cell/permcell.rs" 102 14 102 35
  let%span spermcell'3 = "../../creusot-contracts/src/cell/permcell.rs" 34 4 34 12
  let%span spermcell'4 = "../../creusot-contracts/src/cell/permcell.rs" 231 14 231 34
  let%span spermcell'5 = "../../creusot-contracts/src/cell/permcell.rs" 95 26 95 30
  let%span spermcell'6 = "../../creusot-contracts/src/cell/permcell.rs" 95 53 95 57
  let%span spermcell'7 = "../../creusot-contracts/src/cell/permcell.rs" 92 14 92 36
  let%span spermcell'8 = "../../creusot-contracts/src/cell/permcell.rs" 93 14 93 28
  let%span spermcell'9 = "../../creusot-contracts/src/cell/permcell.rs" 62 20 62 46
  let%span spermcell'10 = "../../creusot-contracts/src/cell/permcell.rs" 45 8 45 27
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 387 30 387 34
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 387 4 387 62
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 384 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 385 14 385 73
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 386 14 386 44
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 445 29 445 33
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 445 43 445 48
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 445 4 445 65
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 443 14 443 49
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 444 14 444 40
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span slocal_invariant = "../../creusot-contracts/src/ghost/local_invariant.rs" 278 51 278 52
  let%span slocal_invariant'0 = "../../creusot-contracts/src/ghost/local_invariant.rs" 275 15 275 113
  let%span slocal_invariant'1 = "../../creusot-contracts/src/ghost/local_invariant.rs" 278 4 280 51
  let%span slocal_invariant'2 = "../../creusot-contracts/src/ghost/local_invariant.rs" 276 14 276 121
  let%span slocal_invariant'3 = "../../creusot-contracts/src/ghost/local_invariant.rs" 181 4 181 12
  let%span slocal_invariant'4 = "../../creusot-contracts/src/ghost/local_invariant.rs" 260 4 262 51
  let%span slocal_invariant'5 = "../../creusot-contracts/src/ghost/local_invariant.rs" 260 51 260 52
  let%span slocal_invariant'6 = "../../creusot-contracts/src/ghost/local_invariant.rs" 252 15 252 46
  let%span slocal_invariant'7 = "../../creusot-contracts/src/ghost/local_invariant.rs" 253 15 254 111
  let%span slocal_invariant'8 = "../../creusot-contracts/src/ghost/local_invariant.rs" 256 14 257 120
  let%span slocal_invariant'9 = "../../creusot-contracts/src/ghost/local_invariant.rs" 237 4 239 51
  let%span slocal_invariant'10 = "../../creusot-contracts/src/ghost/local_invariant.rs" 237 51 237 52
  let%span slocal_invariant'11 = "../../creusot-contracts/src/ghost/local_invariant.rs" 230 4 230 50
  let%span slocal_invariant'12 = "../../creusot-contracts/src/ghost/local_invariant.rs" 231 15 234 89
  let%span slocal_invariant'13 = "../../creusot-contracts/src/ghost/local_invariant.rs" 235 14 235 102
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 775 8 778 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 685 20 685 91
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 4 133 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 4 134 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 4 139 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 4 144 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 4 145 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 4 146 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use seq.Seq
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  use set.Set
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function view'0 (self: t_Fragment) : tuple = [%#sghost'12] view self
  
  function view'1 [#"persistent_array.rs" 77 8 77 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'10] (view'0 self.t_PersistentArray__frag)._p1
  
  function view'2 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'1 self
  
  let rec clone' (self_: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src] result = self_} (! return' {result}) ]
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'1; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_PermCell
  
  type t_PermCellOwn
  
  type tuple'0 = { _p0'0: t_PermCell; _p1'0: t_PermCellOwn }
  
  predicate inv (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv self
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  predicate inv'1 (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'3 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'0] Seq.length (view'3 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec] inv'1 (view'3 self)
  
  predicate inv'2 (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
      = match x with
        | C_Direct a_0 -> inv'2 a_0
        | C_Link index value next -> inv value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant] inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PermCellOwn) = [%#spermcell'9] inv'4 (val' self)
  
  predicate inv'5 (_0: t_PermCellOwn)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PermCellOwn [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self: t_PermCellOwn) = [%#sghost'14] inv'5 self
  
  predicate inv'6 (_0: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: tuple'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: tuple'0 [inv'7 x]. inv'7 x = (let {_p0'0 = x0; _p1'0 = x1} = x in inv'6 x1)
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function view'4 (self: t_PermCellOwn) : t_Inner = [%#spermcell'3] val' self
  
  let rec new (value: t_Inner) (return' (x: tuple'0)) = {[@expl:new 'value' type invariant] [%#spermcell] inv'3 value}
    any
    [ return''0 (result: tuple'0) -> {[%#spermcell'0] inv'7 result}
      {[%#spermcell'1] id result._p0'0 = id'0 result._p1'0}
      {[%#spermcell'2] view'4 result._p1'0 = value}
      (! return' {result}) ]
  
  type t_FMap
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view'5 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'9] Map.get (view'5 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'10] get self k <> C_None
  
  predicate inv'8 (_0: t_Id)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Id [inv'8 x]. inv'8 x = true
  
  predicate index_logic (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. ([%#slogic] exists x: t_PermCellOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = [%#soption'1] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = [%#sfmap'16] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = [%#sfmap'11] lookup self key
  
  predicate invariant''5 (self: t_FMap) =
    [%#sfmap'15] forall k: t_Id. contains self k -> inv'8 k /\ inv'5 (index_logic'0 self k)
  
  predicate inv'9 (_0: t_FMap)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_FMap [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 (self: t_Authority)
  
  predicate inv'10 (_0: t_Authority)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Authority [inv'10 x]. inv'10 x
      = (invariant''6 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'11 (_0: t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PA [inv'11 x]. inv'11 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'9 perms /\ inv'10 auth
        end
  
  predicate invariant''7 (self: MutBorrow.t t_PA) = [%#sinvariant'0] inv'11 self.current /\ inv'11 self.final
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'12 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_PA [inv'12 x]. inv'12 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t t_PA) = [%#sghost'14] inv'12 self
  
  predicate inv'13 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_PA [inv'13 x]. inv'13 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'13 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'14 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_PA [inv'14 x]. inv'14 x = invariant''9 x
  
  predicate invariant''10 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'12 self
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'15 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_PA [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec deref (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:deref 'self' type invariant] [%#sghost'1] inv'14 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'2] inv'15 result}
      {[%#sghost] result = self}
      (! return' {result}) ]
  
  type closure0 = { _0: t_PersistentArray; _1: t_PermCell; _2: t_PermCellOwn; _3: Seq.seq t_T }
  
  predicate invariant''11 (self: t_Fragment)
  
  predicate inv'16 (_0'0: t_Fragment)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Fragment [inv'16 x]. inv'16 x
      = (invariant''11 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''12 (self: t_Fragment) = [%#sghost'14] inv'16 self
  
  predicate inv'17 (_0'0: t_Fragment)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Fragment [inv'17 x]. inv'17 x = invariant''12 x
  
  predicate invariant''13 (self: t_Fragment) = [%#sinvariant] inv'17 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'18 (_0'0: t_Fragment)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Fragment [inv'18 x]. inv'18 x = invariant''13 x
  
  predicate invariant''14 (self: t_Fragment) = [%#sinvariant] inv'16 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'19 (_0'0: t_Fragment)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_Fragment [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec deref'0 (self: t_Fragment) (return' (x: t_Fragment)) =
    {[@expl:deref 'self' type invariant] [%#sghost'1] inv'18 self}
    any
    [ return''0 (result: t_Fragment) -> {[%#sghost'2] inv'19 result} {[%#sghost] result = self} (! return' {result}) ]
  
  predicate invariant''15 (self: t_Authority) = [%#sinvariant] inv'10 self
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'20 (_0'0: t_Authority)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_Authority [inv'20 x]. inv'20 x = invariant''15 x
  
  function id'1 (self: t_Authority) : t_Id
  
  function id'2 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'6 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = [%#sfmap'9] Map.get (view'6 self) k
  
  function view'7 (self: t_Authority) : t_FMap'0
  
  function view'8 (self: t_Authority) : t_FMap'0 = [%#smodel] view'7 self
  
  function view'9 (self: t_Fragment) : tuple = [%#smodel] view self
  
  let rec contains'0 (self: t_Authority) (frag: t_Fragment) (return' (x: ())) =
    {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'20 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'19 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id'1 self = id'2 frag}
    any
    [ return''0 (result: ()) -> {[%#sfmap_view'2] get'0 (view'8 self) (view'9 frag)._p0 = C_Some'0 ((view'9 frag)._p1)}
      (! return' {result}) ]
  
  let rec id_ghost (self: t_PermCell) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#spermcell'4] result = id self} (! return' {result}) ]
  
  let rec into_inner (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'3] result = self} (! return' {result}) ]
  
  predicate invariant''16 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant'0] inv'13 self.current /\ inv'13 self.final
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'21 (_0'0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'21 x]. inv'21 x = invariant''16 x
  
  predicate invariant''17 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant'0] inv'12 self.current /\ inv'12 self.final
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'22 (_0'0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'22 x]. inv'22 x = invariant''17 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return' (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'4] inv'21 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_PA)) -> {[%#sghost'5] inv'22 result}
      {[%#sghost'6] result = self}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_PermCellOwn)
  
  predicate invariant''18 (self: MutBorrow.t t_FMap) = [%#sinvariant'0] inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'23 (_0'0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'23 x]. inv'23 x = invariant''18 x
  
  predicate invariant''19 (self: MutBorrow.t t_PermCellOwn) = [%#sinvariant'0] inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''19
  
  predicate inv'24 (_0'0: MutBorrow.t t_PermCellOwn)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_PermCellOwn [inv'24 x]. inv'24 x = invariant''19 x
  
  predicate inv'25 (_0'0: t_Option'1)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_Option'1 [inv'25 x]. inv'25 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'24 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'12] len self >= 0
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return' (x: t_Option'1)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap] inv'23 self}
    any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'0] inv'25 result}
      {[%#sfmap'1] if contains self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'2] forall k: t_Id. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'3] len self.current = len self.final}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_PermCellOwn) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0'0: MutBorrow.t t_PermCellOwn) = resolve _0'0
  
  predicate resolve'1 (self: MutBorrow.t (MutBorrow.t t_PA)) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (_0'0: MutBorrow.t (MutBorrow.t t_PA)) = resolve'1 _0'0
  
  let rec v_Some (input: t_Option'1) (ret (field_0: MutBorrow.t t_PermCellOwn)) = any
    [ good (field_0: MutBorrow.t t_PermCellOwn) -> {C_Some'1 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_PermCellOwn [C_Some'1 field_0: t_Option'1]. C_Some'1 field_0 <> input}
      (! {false}
      any) ]
  
  predicate invariant''20 (self: t_PermCellOwn) = [%#sinvariant] inv'6 self
  
  meta "rewrite_def" predicate invariant''20
  
  predicate inv'26 (_0'0: t_PermCellOwn)
  
  axiom inv_axiom'25 [@rewrite]: forall x: t_PermCellOwn [inv'26 x]. inv'26 x = invariant''20 x
  
  predicate invariant''21 (self: t_PermCellOwn) = [%#sinvariant] inv'5 self
  
  meta "rewrite_def" predicate invariant''21
  
  predicate inv'27 (_0'0: t_PermCellOwn)
  
  axiom inv_axiom'26 [@rewrite]: forall x: t_PermCellOwn [inv'27 x]. inv'27 x = invariant''21 x
  
  let rec deref'1 (self: t_PermCellOwn) (return' (x: t_PermCellOwn)) =
    {[@expl:deref 'self' type invariant] [%#sghost'1] inv'26 self}
    any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost'2] inv'27 result}
      {[%#sghost] result = self}
      (! return' {result}) ]
  
  let rec disjoint_lemma (own1: MutBorrow.t t_PermCellOwn) (own2: t_PermCellOwn) (return' (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] [%#spermcell'5] inv'24 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#spermcell'6] inv'27 own2}
    any
    [ return''0 (result: ()) -> {[%#spermcell'7] id'0 own1.current <> id'0 own2}
      {[%#spermcell'8] own1.current = own1.final}
      (! return' {result}) ]
  
  let rec into_inner'0 (self: t_PermCellOwn) (return' (x: t_PermCellOwn)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'7] inv'6 self}
    any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost'8] inv'5 result}
      {[%#sghost'3] result = self}
      (! return' {result}) ]
  
  predicate inv'28 (_0'0: t_Option)
  
  axiom inv_axiom'27 [@rewrite]: forall x: t_Option [inv'28 x]. inv'28 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'5 a_0
        end
  
  function insert (self: t_FMap) (k: t_Id) (v: t_PermCellOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: t_PermCellOwn. [%#sfmap'13] view'5 (insert self k v)
      = Map.set (view'5 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: t_PermCellOwn. [%#sfmap'14] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (value: t_PermCellOwn) (return' (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'4] inv'23 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'5] inv'5 value}
    any
    [ return''0 (result: t_Option) -> {[%#sfmap'6] inv'28 result}
      {[%#sfmap'7] self.final = insert self.current key value}
      {[%#sfmap'8] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve'3 (_0'0: t_Inner) = true
  
  predicate resolve'4 (self: t_PermCellOwn) = [%#spermcell'10] resolve'3 (val' self)
  
  predicate resolve'5 (_0'0: t_PermCellOwn) = resolve'4 _0'0
  
  predicate resolve'6 (self: t_Option) =
    [%#soption] match self with
      | C_Some x -> resolve'5 x
      | C_None -> true
      end
  
  predicate resolve'7 (_0'0: t_Option) = resolve'6 _0'0
  
  function index_logic'1 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  function view'10 (self: t_Rc) : t_PermCell
  
  predicate invariant''22 (self: MutBorrow.t t_Authority) = [%#sinvariant'0] inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''22
  
  predicate inv'29 (_0'0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'28 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'29 x]. inv'29 x = invariant''22 x
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'10] get'0 self k <> C_None'0
  
  function view'11 (self: MutBorrow.t t_Authority) : t_FMap'0 = [%#smodel'0] view'7 self.current
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'12] len'0 self >= 0
  
  function insert'0 (self: t_FMap'0) (k: t_Id) (v: Seq.seq t_T) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_Id, v: Seq.seq t_T. [%#sfmap'13] view'6 (insert'0 self k v)
      = Map.set (view'6 self) k (C_Some'0 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_Id, v: Seq.seq t_T. [%#sfmap'14] len'0 (insert'0 self k v)
      = (if contains'1 self k then len'0 self else len'0 self + 1)
  
  let rec insert'1 (self: MutBorrow.t t_Authority) (k: t_Id) (v: Seq.seq t_T) (return' (x: t_Fragment)) =
    {[@expl:insert 'self' type invariant] [%#sfmap_view'3] inv'29 self}
    {[@expl:insert requires] [%#sfmap_view'4] not contains'1 (view'11 self) k}
    any
    [ return''0 (result: t_Fragment) -> {[%#sfmap_view'5] inv'16 result}
      {[%#sfmap_view'6] view'7 self.final = insert'0 (view'11 self) k v}
      {[%#sfmap_view'7] id'1 self.final = id'1 self.current}
      {[%#sfmap_view'8] view result = { _p0 = k; _p1 = v }}
      {[%#sfmap_view'9] id'2 result = id'1 self.current}
      (! return' {result}) ]
  
  predicate resolve'8 (self: MutBorrow.t t_PA) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 (_0'0: MutBorrow.t t_PA) = resolve'8 _0'0
  
  predicate resolve'10 (self: MutBorrow.t t_PA) = [%#sghost'13] resolve'9 self
  
  predicate resolve'11 (_0'0: MutBorrow.t t_PA) = resolve'10 _0'0
  
  let rec new'0 (x: t_Fragment) (return' (x'0: t_Fragment)) = {[@expl:new 'x' type invariant] [%#sghost'9] inv'16 x}
    any
    [ return''0 (result: t_Fragment) -> {[%#sghost'10] inv'17 result} {[%#sghost'0] result = x} (! return' {result}) ]
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'12 (self: t_Rc'0) : t_LocalInvariant
  
  function view'13 (self: t_Rc'0) : t_LocalInvariant = [%#sghost'12] view'12 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''23 [#"persistent_array.rs" 59 8 59 34] (self: t_PersistentArray) =
    [%#spersistent_array'11] (view'0 self.t_PersistentArray__frag)._p0 = id (view'10 self.t_PersistentArray__permcell)
    /\ id'2 self.t_PersistentArray__frag = public (view'13 self.t_PersistentArray__inv)
    /\ namespace (view'13 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'30 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'29 [@rewrite]: forall x: t_PersistentArray [inv'30 x]. inv'30 x
      = (invariant''23 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'31} -> inv'17 frag
        end)
  
  predicate invariant''24 (self: t_PersistentArray) = [%#sinvariant] inv'30 self
  
  meta "rewrite_def" predicate invariant''24
  
  predicate inv'31 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'30 [@rewrite]: forall x: t_PersistentArray [inv'31 x]. inv'31 x = invariant''24 x
  
  predicate invariant''25 (self: t_PersistentArray) = [%#sinvariant] inv'31 self
  
  meta "rewrite_def" predicate invariant''25
  
  predicate inv'32 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'31 [@rewrite]: forall x: t_PersistentArray [inv'32 x]. inv'32 x = invariant''25 x
  
  predicate inv'33 (_0'0: closure0)
  
  axiom inv_axiom'32 [@rewrite]: forall x: closure0 [inv'33 x]. inv'33 x
      = (let {_0 = x0; _1 = x1; _2 = x2; _3 = x3} = x in inv'32 x0 /\ inv'6 x2)
  
  let rec closure0 [#"persistent_array.rs" 163 45 163 53] [@coma:extspec] (self: closure0) (pa: MutBorrow.t t_PA)
    (return' (x: t_Fragment)) = bb0
    [ bb0 = s0 [ s0 = deref {pa'0} (fun (_ret: MutBorrow.t t_PA) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_11 <- (_1'0._0).t_PersistentArray__frag ] s1
      | s1 = deref'0 {_11} (fun (_ret: t_Fragment) -> [ &_9 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = contains'0 {(_6.current).t_PA__auth} {_9} (fun (_ret: ()) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = id_ghost {_1'0._1} (fun (_ret: t_Id) -> [ &_13 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_inner {_13} (fun (_ret: t_Id) -> [ &cell_id <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'13 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_19 <- _ret ] -{inv'13 _ret.final}-
            [ &pa'0 <- _ret.final ] s1)
      | s1 = deref_mut {_19} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_18 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_21 <- cell_id ] s1
      | s1 = {inv'9 ((_18.current).current).t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {((_18.current).current).t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_17 <- _ret ] -{inv'9 _ret.final}-
            [ &_18 <- { _18 with current = { _18.current with current = { (_18.current).current with t_PA__perms = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_17} {_21} (fun (_ret: t_Option'1) -> [ &_16 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = any
      [ br0 -> {_16 = C_None'1} (! bb12) | br1 (x0: MutBorrow.t t_PermCellOwn) -> {_16 = C_Some'1 x0} (! bb9) ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] match _16 with
          | C_Some'1 x -> inv'24 x
          | _ -> true
          end}
        s1
      | s1 = -{match _16 with
          | C_Some'1 x -> resolve'0 x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] inv'22 _18} s3
      | s3 = -{resolve'2 _18}- s4
      | s4 = bb13 ]
    | bb9 = s0
      [ s0 = v_Some {_16} (fun (r0: MutBorrow.t t_PermCellOwn) -> [ &other <- r0 ] s1)
      | s1 = [ &_29 <- _1'0._2 ] s2
      | s2 = deref'1 {_29} (fun (_ret: t_PermCellOwn) -> [ &_27 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'5 other.current}
        MutBorrow.borrow_final <t_PermCellOwn> {other.current} {MutBorrow.get_id other}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_25 <- _ret ] -{inv'5 _ret.final}-
            [ &other <- { other with current = _ret.final } ] s1)
      | s1 = disjoint_lemma {_25} {_27} (fun (_ret: ()) -> [ &_24 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'24 other} s1
      | s1 = -{resolve'0 other}- s2
      | s2 = {[@expl:type invariant] inv'22 _18} s3
      | s3 = -{resolve'2 _18}- s4
      | s4 = bb13 ]
    | bb13 = s0
      [ s0 = {inv'13 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_33 <- _ret ] -{inv'13 _ret.final}-
            [ &pa'0 <- _ret.final ] s1)
      | s1 = deref_mut {_33} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_32 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0 [ s0 = into_inner'0 {_1'0._2} (fun (_ret: t_PermCellOwn) -> [ &_35 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'9 ((_32.current).current).t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {((_32.current).current).t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_31 <- _ret ] -{inv'9 _ret.final}-
            [ &_32 <- { _32 with current = { _32.current with current = { (_32.current).current with t_PA__perms = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_31} {cell_id} {_35} (fun (_ret: t_Option) -> [ &_30 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'28 _30} s3
      | s3 = -{resolve'7 _30}- s4
      | s4 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'22 _32} s1
      | s1 = -{resolve'2 _32}- s2
      | s2 =
        [ &_37 <- [%#spersistent_array'6] Map.set (pa'0.current).t_PA__depth cell_id (index_logic'1 (pa'0.current).t_PA__depth (id (view'10 (_1'0._0).t_PersistentArray__permcell))
        + 1) ] s3
      | s3 = bb17 ]
    | bb17 = s0
      [ s0 = {inv'13 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_40 <- _ret ] -{inv'13 _ret.final}-
            [ &pa'0 <- _ret.final ] s1)
      | s1 = deref_mut {_40} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_39 <- _ret ] s2)
      | s2 = bb18 ]
    | bb18 = s0
      [ s0 =
        [ &_39 <- { _39 with current = { _39.current with current = { (_39.current).current with t_PA__depth = _37 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'22 _39} s2
      | s2 = -{resolve'2 _39}- s3
      | s3 = {inv'13 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_43 <- _ret ] -{inv'13 _ret.final}-
            [ &pa'0 <- _ret.final ] s4)
      | s4 = deref_mut {_43} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_42 <- _ret ] s5)
      | s5 = bb19 ]
    | bb19 = s0 [ s0 = [ &_44 <- [%#spersistent_array'7] cell_id ] s1 | s1 = bb20 ]
    | bb20 = s0
      [ s0 = {inv'10 ((_42.current).current).t_PA__auth}
        MutBorrow.borrow_mut <t_Authority> {((_42.current).current).t_PA__auth}
          (fun (_ret: MutBorrow.t t_Authority) ->
            [ &_41 <- _ret ] -{inv'10 _ret.final}-
            [ &_42 <- { _42 with current = { _42.current with current = { (_42.current).current with t_PA__auth = _ret.final } } } ]
            s1)
      | s1 = insert'1 {_41} {_44} {_1'0._3} (fun (_ret: t_Fragment) -> [ &_3'0 <- _ret ] s2)
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = {[@expl:type invariant] inv'22 _42} s1
      | s1 = -{resolve'2 _42}- s2
      | s2 = {[@expl:type invariant] inv'13 pa'0} s3
      | s3 = -{resolve'11 pa'0}- s4
      | s4 = new'0 {_3'0} (fun (_ret: t_Fragment) -> [ &_0'0 <- _ret ] s5)
      | s5 = bb22 ]
    | bb22 = return' {_0'0} ]
    [ & _0'0: t_Fragment = Any.any_l ()
    | & _1'0: closure0 = self
    | & pa'0: MutBorrow.t t_PA = pa
    | & _3'0: t_Fragment = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _6: MutBorrow.t t_PA = Any.any_l ()
    | & _9: t_Fragment = Any.any_l ()
    | & _11: t_Fragment = Any.any_l ()
    | & cell_id: t_Id = Any.any_l ()
    | & _13: t_Id = Any.any_l ()
    | & _16: t_Option'1 = Any.any_l ()
    | & _17: MutBorrow.t t_FMap = Any.any_l ()
    | & _18: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _19: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _21: t_Id = Any.any_l ()
    | & other: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _27: t_PermCellOwn = Any.any_l ()
    | & _29: t_PermCellOwn = Any.any_l ()
    | & _30: t_Option = Any.any_l ()
    | & _31: MutBorrow.t t_FMap = Any.any_l ()
    | & _32: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _33: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _35: t_PermCellOwn = Any.any_l ()
    | & _37: Map.map t_Id int = Any.any_l ()
    | & _39: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _40: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _41: MutBorrow.t t_Authority = Any.any_l ()
    | & _42: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _43: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _44: t_Id = Any.any_l () ]
  
  type t_Tokens
  
  type tuple'1 = { _p0'1: t_Rc'0; _p1'1: t_Tokens; _p2: closure0 }
  
  predicate postcondition_once (self: ()) (args: t_Rc'0) (result: t_LocalInvariant) =
    let self_ = args in result = view'12 self_
  
  predicate resolve'12 (_0'0: ()) = true
  
  predicate postcondition_mut (self: ()) (args: t_Rc'0) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view'12 self_
  
  function fn_mut_once (self: ()) (args: t_Rc'0) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec:
    forall self: (), args: t_Rc'0, res: t_LocalInvariant. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'12 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) = true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc'0) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Rc'0, res_state: (), res: t_LocalInvariant. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_Rc'0) (result: t_LocalInvariant) =
    let self_ = args in result = view'12 self_
  
  function fn_once (self: ()) (args: t_Rc'0) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc'0, res: t_LocalInvariant. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve'12 self)
  
  function fn_mut (self: ()) (args: t_Rc'0) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Rc'0, res_state: (), res: t_LocalInvariant. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  type tuple'2 = { _p0'2: t_LocalInvariant; _p1'2: t_Tokens; _p2'0: closure0 }
  
  predicate index_logic'2 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#slogic] exists x: Seq.seq t_T. index_logic'2 p x)
      -> ([%#slogic'0] index_logic'2 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = [%#soption'1] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'16] unwrap_logic'0 (get'0 self k)
  
  function index_logic'3 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'11] lookup'0 self key
  
  function view'14 (self: t_Vec) : Seq.seq t_T = [%#smodel] view'3 self
  
  function view'15 (self: t_Rc) : t_PermCell = [%#smodel] view'10 self
  
  function view'16 (self: UInt64.t) : int = [%#smodel] UInt64.t'int self
  
  predicate partial_invariant [#"persistent_array.rs" 109 8 109 59] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'13] id'1 self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains'1 (view'7 self.t_PA__auth) id'3 /\ contains self.t_PA__perms id'3
      -> id'0 (index_logic'0 self.t_PA__perms id'3) = id'3
      /\ match val' (index_logic'0 self.t_PA__perms id'3) with
        | C_Direct v -> index_logic'3 (view'7 self.t_PA__auth) id'3 = view'14 v
        | C_Link index value next -> contains'1 (view'7 self.t_PA__auth) (id (view'15 next))
        /\ index_logic'1 self.t_PA__depth id'3 > index_logic'1 self.t_PA__depth (id (view'15 next))
        /\ view'16 index < Seq.length (index_logic'3 (view'7 self.t_PA__auth) (id (view'15 next)))
        /\ index_logic'3 (view'7 self.t_PA__auth) id'3
        = Seq.set (index_logic'3 (view'7 self.t_PA__auth) (id (view'15 next))) (view'16 index) value
        end)
  
  predicate protocol [#"persistent_array.rs" 99 8 99 50] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'12] partial_invariant self resource_id
    /\ (forall id'3: t_Id. contains'1 (view'7 self.t_PA__auth) id'3 -> contains self.t_PA__perms id'3)
  
  predicate precondition (self: closure0) (args: MutBorrow.t t_PA) =
    [%#spersistent_array'8] let pa = args in closure0'pre self pa
  
  predicate postcondition_once'0 (self: closure0) (args: MutBorrow.t t_PA) (result: t_Fragment) =
    [%#spersistent_array'8] let pa = args in closure0'post'return' self pa result
  
  function fin (self: MutBorrow.t t_PA) : t_PA = [%#sghost'15] self.final
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = [%#sset] Set.mem e self
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'3 (self: t_Tokens) (namespace'0: t_Namespace) =
    [%#slocal_invariant'3] contains'2 (namespaces self) namespace'0
  
  predicate precondition'0 (self: ()) (args: tuple'2) =
    [%#slocal_invariant'9] let {_p0'2 = self'0; _p1'2 = tokens; _p2'0 = f} = args in (forall t: MutBorrow.t t_PA. protocol t.current (public self'0)
          /\ inv'13 t
        -> precondition f t
        /\ (forall res: t_Fragment. postcondition_once'0 f t res -> protocol (fin t) (public self'0)))
    /\ contains'3 tokens (namespace self'0) /\ inv'33 f
  
  function new_logic (x: t_LocalInvariant) : t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. [%#sghost'11] new_logic x = x
  
  predicate precondition'1 (self: ()) (args: t_Rc'0) = let self_ = args in true
  
  predicate precondition'2 (self: ()) (args: tuple'1) =
    [%#slocal_invariant'4] let {_p0'1 = self'0; _p1'1 = tokens; _p2 = f} = args in (forall this: t_LocalInvariant. postcondition () self'0 this
        -> precondition'0 () { _p0'2 = new_logic this; _p1'2 = tokens; _p2'0 = f })
    /\ precondition'1 () self'0 /\ inv'33 f
  
  let rec deref'2 (self_: t_Rc'0) (return' (x: t_LocalInvariant)) = any
    [ return''0 (result: t_LocalInvariant) -> {[%#src'1] result = view'12 self_} (! return' {result}) ]
  
  let rec open (self: t_LocalInvariant) (tokens: t_Tokens) (f: closure0) (return' (x: t_Fragment)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant'10] inv'33 f}
    {[@expl:open requires #0] [%#slocal_invariant'11] contains'3 tokens (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'12] forall t: MutBorrow.t t_PA. protocol t.current (public self)
        /\ inv'13 t
      -> precondition f t /\ (forall res: t_Fragment. postcondition_once'0 f t res -> protocol (fin t) (public self))}
    any
    [ return''0 (result: t_Fragment) -> {[%#slocal_invariant'9] inv'17 result}
      {[%#slocal_invariant'13] exists t: MutBorrow.t t_PA. protocol t.current (public self)
        /\ postcondition_once'0 f t result}
      (! return' {result}) ]
  
  predicate postcondition_once'1 (self: ()) (args: tuple'2) (result: t_Fragment) =
    [%#slocal_invariant'9] let {_p0'2 = self'0; _p1'2 = tokens; _p2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'17 result
  
  predicate resolve'13 (_0'0: ()) = true
  
  predicate postcondition_mut'0 (self: ()) (args: tuple'2) (result_state: ()) (result: t_Fragment) =
    [%#slocal_invariant'9] let {_p0'2 = self'0; _p1'2 = tokens; _p2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'17 result
  
  function fn_mut_once'0 (self: ()) (args: tuple'2) (res: t_Fragment) : ()
  
  axiom fn_mut_once_spec'0:
    forall self: (), args: tuple'2, res: t_Fragment. [%#sops'8] postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'13 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) = true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
      -> ([%#sops'6] hist_inv'0 b c) -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'2) (res_state: ()) (res: t_Fragment) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: tuple'2, res_state: (), res: t_Fragment. ([%#sops'2] postcondition_mut'0 self args res_state res)
      -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple'2) (result: t_Fragment) =
    [%#slocal_invariant'9] let {_p0'2 = self'0; _p1'2 = tokens; _p2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'17 result
  
  function fn_once'0 (self: ()) (args: tuple'2) (res: t_Fragment) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'2, res: t_Fragment. [%#sops'0] postcondition_once'1 self args res
      = (postcondition'0 self args res /\ resolve'13 self)
  
  function fn_mut'0 (self: ()) (args: tuple'2) (res_state: ()) (res: t_Fragment) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: tuple'2, res_state: (), res: t_Fragment. [%#sops] postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc'0) (tokens: t_Tokens) (f: closure0) (return' (x: t_Fragment)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant'5] inv'33 f}
    {[@expl:open requires #0] [%#slocal_invariant'6] precondition'1 () self}
    {[@expl:open requires #1] [%#slocal_invariant'7] forall this: t_LocalInvariant. postcondition () self this
      -> precondition'0 () { _p0'2 = new_logic this; _p1'2 = tokens; _p2'0 = f }}
    any
    [ return''0 (result: t_Fragment) -> {[%#slocal_invariant'4] inv'17 result}
      {[%#slocal_invariant'8] exists this: t_LocalInvariant. postcondition () self this
        /\ postcondition'0 () { _p0'2 = new_logic this; _p1'2 = tokens; _p2'0 = f } result}
      (! return' {result}) ]
  
  function new_logic'0 (x: t_Rc'0) : t_Rc'0
  
  axiom new_logic_spec'0: forall x: t_Rc'0. [%#sghost'11] new_logic'0 x = x
  
  predicate postcondition_once'2 (self: ()) (args: tuple'1) (result: t_Fragment) =
    [%#slocal_invariant'4] let {_p0'1 = self'0; _p1'1 = tokens; _p2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { _p0'2 = new_logic this; _p1'2 = tokens; _p2'0 = f } result)
    /\ inv'17 result
  
  predicate resolve'14 (_0'0: ()) = true
  
  predicate postcondition_mut'1 (self: ()) (args: tuple'1) (result_state: ()) (result: t_Fragment) =
    [%#slocal_invariant'4] let {_p0'1 = self'0; _p1'1 = tokens; _p2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { _p0'2 = new_logic this; _p1'2 = tokens; _p2'0 = f } result)
    /\ inv'17 result
  
  function fn_mut_once'1 (self: ()) (args: tuple'1) (res: t_Fragment) : ()
  
  axiom fn_mut_once_spec'1:
    forall self: (), args: tuple'1, res: t_Fragment. [%#sops'8] postcondition_once'2 self args res
      = (exists res_state: (). postcondition_mut'1 self args res_state res /\ resolve'14 res_state)
  
  predicate hist_inv'1 (self: ()) (result_state: ()) = true
  
  function hist_inv_trans'1 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'1: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'1 self b)
      -> ([%#sops'6] hist_inv'1 b c) -> ([%#sops'7] hist_inv'1 self c)
  
  function hist_inv_refl'1 (self: ()) : ()
  
  axiom hist_inv_refl_spec'1: forall self: (). [%#sops'4] hist_inv'1 self self
  
  function postcondition_mut_hist_inv'1 (self: ()) (args: tuple'1) (res_state: ()) (res: t_Fragment) : ()
  
  axiom postcondition_mut_hist_inv_spec'1:
    forall self: (), args: tuple'1, res_state: (), res: t_Fragment. ([%#sops'2] postcondition_mut'1 self args res_state res)
      -> ([%#sops'3] hist_inv'1 self res_state)
  
  function fn_hist_inv'1 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'1: forall self: (), res_state: (). [%#sops'1] hist_inv'1 self res_state = (self = res_state)
  
  predicate postcondition'1 (self: ()) (args: tuple'1) (result: t_Fragment) =
    [%#slocal_invariant'4] let {_p0'1 = self'0; _p1'1 = tokens; _p2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { _p0'2 = new_logic this; _p1'2 = tokens; _p2'0 = f } result)
    /\ inv'17 result
  
  function fn_once'1 (self: ()) (args: tuple'1) (res: t_Fragment) : ()
  
  axiom fn_once_spec'1: forall self: (), args: tuple'1, res: t_Fragment. [%#sops'0] postcondition_once'2 self args res
      = (postcondition'1 self args res /\ resolve'14 self)
  
  function fn_mut'1 (self: ()) (args: tuple'1) (res_state: ()) (res: t_Fragment) : ()
  
  axiom fn_mut_spec'1:
    forall self: (), args: tuple'1, res_state: (), res: t_Fragment. [%#sops] postcondition_mut'1 self args res_state res
      = (postcondition'1 self args res /\ self = res_state)
  
  let rec open'1 (self: t_Rc'0) (tokens: t_Tokens) (f: closure0) (return' (x: t_Fragment)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant] inv'33 f}
    {[@expl:open requires] [%#slocal_invariant'0] precondition'2 () { _p0'1 = new_logic'0 self;
                                                                      _p1'1 = tokens;
                                                                      _p2 = f }}
    any
    [ return''0 (result: t_Fragment) -> {[%#slocal_invariant'1] inv'17 result}
      {[%#slocal_invariant'2] postcondition'1 () { _p0'1 = new_logic'0 self; _p1'1 = tokens; _p2 = f } result}
      (! return' {result}) ]
  
  let rec new'1 (value: t_PermCell) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src'0] view'10 result = value} (! return' {result}) ]
  
  let rec deref'3 (self: t_Rc'0) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost] result = self} (! return' {result}) ]
  
  let rec clone''0 (self_: t_Rc'0) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#src] result = self_} (! return' {result}) ]
  
  let rec new'2 (x: t_Rc'0) (return' (x'0: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost'0] result = x} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec set [#"persistent_array.rs" 159 8 159 80] (self: t_PersistentArray) (index: UInt64.t) (value: t_T)
    (tokens: t_Tokens) (return' (x: t_PersistentArray)) =
    {[@expl:set 'self' type invariant] [%#spersistent_array'0] inv'31 self}
    {[@expl:set 'value' type invariant] [%#spersistent_array'1] inv value}
    {[@expl:set requires #0] [%#spersistent_array'2] UInt64.t'int index < Seq.length (view'2 self)}
    {[@expl:set requires #1] [%#spersistent_array'3] contains'3 tokens (Namespace_PARRAY 0)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &new_seq <- [%#spersistent_array] Seq.set (view'2 self'0) (UInt64.t'int index'0) value'0 ] s1
      | s1 = bb1 ]
    | bb1 = s0 [ s0 = clone' {self'0.t_PersistentArray__permcell} (fun (_ret: t_Rc) -> [ &_16 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_13 <- C_Link index'0 value'0 _16 ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_13} (fun (_ret: tuple'0) -> [ &_12 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &permcell <- _12._p0'0 ] s1 | s1 = [ &permcellown <- _12._p1'0 ] s2 | s2 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_21 <- { _0 = self'0; _1 = permcell; _2 = permcellown; _3 = new_seq } ] s1
      | s1 = open'1 {self'0.t_PersistentArray__inv} {tokens'0} {_21} (fun (_ret: t_Fragment) -> [ &frag <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0 [ s0 = new'1 {permcell} (fun (_ret: t_Rc) -> [ &_25 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = deref'3 {self'0.t_PersistentArray__inv} (fun (_ret: t_Rc'0) -> [ &_31 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0 [ s0 = clone''0 {_31} (fun (_ret: t_Rc'0) -> [ &_29 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = new'2 {_29} (fun (_ret: t_Rc'0) -> [ &_28 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = [ &_0'0 <- { t_PersistentArray__permcell = _25;
                          t_PersistentArray__frag = frag;
                          t_PersistentArray__inv = _28 } ] s1
      | s1 = bb14 ]
    | bb14 = return''0 {_0'0} ]
    [ & _0'0: t_PersistentArray = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & index'0: UInt64.t = index
    | & value'0: t_T = value
    | & tokens'0: t_Tokens = tokens
    | & new_seq: Seq.seq t_T = Any.any_l ()
    | & permcell: t_PermCell = Any.any_l ()
    | & permcellown: t_PermCellOwn = Any.any_l ()
    | & _12: tuple'0 = Any.any_l ()
    | & _13: t_Inner = Any.any_l ()
    | & _16: t_Rc = Any.any_l ()
    | & frag: t_Fragment = Any.any_l ()
    | & _21: closure0 = Any.any_l ()
    | & _25: t_Rc = Any.any_l ()
    | & _28: t_Rc'0 = Any.any_l ()
    | & _29: t_Rc'0 = Any.any_l ()
    | & _31: t_Rc'0 = Any.any_l () ])
    [ return''0 (result: t_PersistentArray) -> {[@expl:set result type invariant] [%#spersistent_array'4] inv'30 result}
      {[@expl:set ensures] [%#spersistent_array'5] view'1 result = Seq.set (view'2 self) (UInt64.t'int index) value}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get_immut [#"persistent_array.rs" 198 8 198 95] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span spersistent_array = "persistent_array.rs" 198 40 198 44
  let%span spersistent_array'0 = "persistent_array.rs" 195 8 195 46
  let%span spersistent_array'1 = "persistent_array.rs" 196 19 196 39
  let%span spersistent_array'2 = "persistent_array.rs" 198 90 198 95
  let%span spersistent_array'3 = "persistent_array.rs" 197 18 197 42
  let%span spersistent_array'4 = "persistent_array.rs" 212 12 212 14
  let%span spersistent_array'5 = "persistent_array.rs" 205 19 205 43
  let%span spersistent_array'6 = "persistent_array.rs" 206 19 206 49
  let%span spersistent_array'7 = "persistent_array.rs" 207 19 207 51
  let%span spersistent_array'8 = "persistent_array.rs" 213 13 213 18
  let%span spersistent_array'9 = "persistent_array.rs" 208 18 208 54
  let%span spersistent_array'10 = "persistent_array.rs" 100 12 103 13
  let%span spersistent_array'11 = "persistent_array.rs" 78 24 78 36
  let%span spersistent_array'12 = "persistent_array.rs" 111 16 123 21
  let%span spersistent_array'13 = "persistent_array.rs" 62 16 64 52
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 183 15 183 16
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 183 4 185 17
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 78 14 78 18
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 78 4 78 36
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span sfmap_view = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 105 14 105 49
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spermcell = "../../creusot-contracts/src/cell/permcell.rs" 62 20 62 46
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span slocal_invariant = "../../creusot-contracts/src/ghost/local_invariant.rs" 350 4 350 50
  let%span slocal_invariant'0 = "../../creusot-contracts/src/ghost/local_invariant.rs" 353 4 353 64
  let%span slocal_invariant'1 = "../../creusot-contracts/src/ghost/local_invariant.rs" 351 4 351 46
  let%span slocal_invariant'2 = "../../creusot-contracts/src/ghost/local_invariant.rs" 181 4 181 12
  let%span soption = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 685 20 685 91
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  
  use creusot.prelude.Opaque
  use seq.Seq
  use map.Map
  use set.Set
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  let rec deref (self: t_Rc'0) (return' (x: t_Rc'0)) = any
    [ return''0 (result: t_Rc'0) -> {[%#sghost] result = self} (! return' {result}) ]
  
  type t_LocalInvariant
  
  function view (self: t_Rc'0) : t_LocalInvariant
  
  let rec deref'0 (self_: t_Rc'0) (return' (x: t_LocalInvariant)) = any
    [ return''0 (result: t_LocalInvariant) -> {[%#src] result = view self_} (! return' {result}) ]
  
  type t_Tokens
  
  let rec deref'1 (self: t_Tokens) (return' (x: t_Tokens)) = any
    [ return''0 (result: t_Tokens) -> {[%#sghost] result = self} (! return' {result}) ]
  
  type t_FMap
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  predicate contains [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = [%#sset] Set.mem e self
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'0 (self: t_Tokens) (namespace: t_Namespace) =
    [%#slocal_invariant'2] contains (namespaces self) namespace
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  type t_PermCellOwn
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view'0 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap] Map.get (view'0 self) k
  
  predicate contains'1 [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'0] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'1; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'1 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'0] inv'2 (view'1 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant] inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PermCellOwn) = [%#spermcell] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. ([%#slogic] exists x: t_PermCellOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = [%#sfmap'2] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = [%#sfmap'1] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'3] forall k: t_Id. contains'1 self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_0: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'7 perms /\ inv'8 auth
        end
  
  predicate invariant''6 (self: t_PA) = [%#sinvariant] inv'9 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_0: t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  function id (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'2 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = [%#sfmap] Map.get (view'2 self) k
  
  predicate contains'2 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'0] get'0 self k <> C_None'0
  
  function view'3 (self: t_Authority) : t_FMap'0
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#slogic] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#slogic'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'2] unwrap_logic'0 (get'0 self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'1] lookup'0 self key
  
  function view'4 (self: t_Vec) : Seq.seq t_T = [%#smodel] view'1 self
  
  type t_PermCell
  
  function id'1 (self: t_PermCell) : t_Id
  
  function view'5 (self: t_Rc) : t_PermCell
  
  function view'6 (self: t_Rc) : t_PermCell = [%#smodel] view'5 self
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  function view'7 (self: UInt64.t) : int = [%#smodel] UInt64.t'int self
  
  predicate partial_invariant [#"persistent_array.rs" 109 8 109 59] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'12] id self.t_PA__auth = resource_id
    /\ (forall id'2: t_Id. contains'2 (view'3 self.t_PA__auth) id'2 /\ contains'1 self.t_PA__perms id'2
      -> id'0 (index_logic'0 self.t_PA__perms id'2) = id'2
      /\ match val' (index_logic'0 self.t_PA__perms id'2) with
        | C_Direct v -> index_logic'2 (view'3 self.t_PA__auth) id'2 = view'4 v
        | C_Link index value next -> contains'2 (view'3 self.t_PA__auth) (id'1 (view'6 next))
        /\ index_logic'3 self.t_PA__depth id'2 > index_logic'3 self.t_PA__depth (id'1 (view'6 next))
        /\ view'7 index < Seq.length (index_logic'2 (view'3 self.t_PA__auth) (id'1 (view'6 next)))
        /\ index_logic'2 (view'3 self.t_PA__auth) id'2
        = Seq.set (index_logic'2 (view'3 self.t_PA__auth) (id'1 (view'6 next))) (view'7 index) value
        end)
  
  predicate protocol [#"persistent_array.rs" 99 8 99 50] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'10] partial_invariant self resource_id
    /\ (forall id'2: t_Id. contains'2 (view'3 self.t_PA__auth) id'2 -> contains'1 self.t_PA__perms id'2)
  
  function public (self: t_LocalInvariant) : t_Id
  
  let rec open_const (self: t_LocalInvariant) (tokens: t_Tokens) (return' (x: t_PA)) =
    {[@expl:open_const requires] [%#slocal_invariant] contains'0 tokens (namespace self)}
    any
    [ return''0 (result: t_PA) -> {[%#slocal_invariant'0] inv'10 result}
      {[%#slocal_invariant'1] protocol result (public self)}
      (! return' {result}) ]
  
  predicate invariant''7 (self: t_PA) = [%#sghost'6] inv'10 self
  
  predicate inv'11 (_0: t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  let rec new (x: t_PA) (return' (x'0: t_PA)) = {[@expl:new 'x' type invariant] [%#sghost'0] inv'10 x}
    any [ return''0 (result: t_PA) -> {[%#sghost'1] inv'11 result} {[%#sghost'2] result = x} (! return' {result}) ]
  
  predicate invariant''8 (self: t_PA) = [%#sinvariant] inv'11 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_0: t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: t_PA) = [%#sinvariant] inv'10 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_0: t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref'2 (self: t_PA) (return' (x: t_PA)) = {[@expl:deref 'self' type invariant] [%#sghost'3] inv'12 self}
    any [ return''0 (result: t_PA) -> {[%#sghost'4] inv'13 result} {[%#sghost] result = self} (! return' {result}) ]
  
  predicate invariant''10 (self: t_Fragment)
  
  predicate inv'14 (_0: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
      = (invariant''10 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''11 (self: t_Fragment) = [%#sghost'6] inv'14 self
  
  predicate inv'15 (_0: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate invariant''12 (self: t_Fragment) = [%#sinvariant] inv'15 self
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'16 (_0: t_Fragment)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Fragment [inv'16 x]. inv'16 x = invariant''12 x
  
  predicate invariant''13 (self: t_Fragment) = [%#sinvariant] inv'14 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'17 (_0: t_Fragment)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Fragment [inv'17 x]. inv'17 x = invariant''13 x
  
  let rec deref'3 (self: t_Fragment) (return' (x: t_Fragment)) =
    {[@expl:deref 'self' type invariant] [%#sghost'3] inv'16 self}
    any
    [ return''0 (result: t_Fragment) -> {[%#sghost'4] inv'17 result} {[%#sghost] result = self} (! return' {result}) ]
  
  predicate invariant''14 (self: t_Authority) = [%#sinvariant] inv'8 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'18 (_0: t_Authority)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Authority [inv'18 x]. inv'18 x = invariant''14 x
  
  function id'2 (self: t_Fragment) : t_Id
  
  function view'8 (self: t_Authority) : t_FMap'0 = [%#smodel] view'3 self
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view'9 (self: t_Fragment) : tuple
  
  function view'10 (self: t_Fragment) : tuple = [%#smodel] view'9 self
  
  let rec contains'3 (self: t_Authority) (frag: t_Fragment) (return' (x: ())) =
    {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'18 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'17 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id self = id'2 frag}
    any
    [ return''0 (result: ()) -> {[%#sfmap_view'2] get'0 (view'8 self) (view'10 frag)._p0
      = C_Some'0 ((view'10 frag)._p1)}
      (! return' {result}) ]
  
  let rec new'0 (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'2] result = x} (! return' {result}) ]
  
  predicate invariant''15 (self: t_T) = [%#sinvariant] inv'0 self
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'19 (_0: t_T)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_T [inv'19 x]. inv'19 x = invariant''15 x
  
  let rec get_inner_immut (inner: t_Rc) (i: UInt64.t) (pa: t_PA) (return' (x: t_T)) =
    {[@expl:get_inner_immut 'pa' type invariant] [%#spersistent_array'4] inv'11 pa}
    {[@expl:get_inner_immut requires #0] [%#spersistent_array'5] exists p: t_Id. protocol pa p}
    {[@expl:get_inner_immut requires #1] [%#spersistent_array'6] contains'2 (view'3 pa.t_PA__auth) (id'1 (view'6 inner))}
    {[@expl:get_inner_immut requires #2] [%#spersistent_array'7] UInt64.t'int i
    < Seq.length (index_logic'2 (view'3 pa.t_PA__auth) (id'1 (view'6 inner)))}
    any
    [ return''0 (result: t_T) -> {[%#spersistent_array'8] inv'19 result}
      {[%#spersistent_array'9] result
      = Seq.get (index_logic'2 (view'3 pa.t_PA__auth) (id'1 (view'6 inner))) (UInt64.t'int i)}
      (! return' {result}) ]
  
  function view'11 (self: t_Fragment) : tuple = [%#sghost'5] view'9 self
  
  function view'12 (self: t_Rc'0) : t_LocalInvariant = [%#sghost'5] view self
  
  predicate invariant''16 [#"persistent_array.rs" 59 8 59 34] (self: t_PersistentArray) =
    [%#spersistent_array'13] (view'11 self.t_PersistentArray__frag)._p0 = id'1 (view'5 self.t_PersistentArray__permcell)
    /\ id'2 self.t_PersistentArray__frag = public (view'12 self.t_PersistentArray__inv)
    /\ namespace (view'12 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'20 (_0: t_PersistentArray)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PersistentArray [inv'20 x]. inv'20 x
      = (invariant''16 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'21} -> inv'15 frag
        end)
  
  predicate invariant''17 (self: t_PersistentArray) = [%#sinvariant] inv'20 self
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'21 (_0: t_PersistentArray)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_PersistentArray [inv'21 x]. inv'21 x = invariant''17 x
  
  function view'13 [#"persistent_array.rs" 77 8 77 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'11] (view'11 self.t_PersistentArray__frag)._p1
  
  function view'14 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'13 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_immut [#"persistent_array.rs" 198 8 198 95] (self: t_PersistentArray) (index: UInt64.t) (tokens: t_Tokens)
    (return' (x: t_T)) = {[@expl:get_immut 'self' type invariant] [%#spersistent_array] inv'21 self}
    {[@expl:get_immut requires #0] [%#spersistent_array'0] contains'0 tokens (Namespace_PARRAY 0)}
    {[@expl:get_immut requires #1] [%#spersistent_array'1] UInt64.t'int index < Seq.length (view'14 self)}
    (! bb0
    [ bb0 = s0 [ s0 = deref {self'0.t_PersistentArray__inv} (fun (_ret: t_Rc'0) -> [ &_12 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref'0 {_12} (fun (_ret: t_LocalInvariant) -> [ &_10 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = deref'1 {tokens'0} (fun (_ret: t_Tokens) -> [ &_15 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = open_const {_10} {_15} (fun (_ret: t_PA) -> [ &_8 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_8} (fun (_ret: t_PA) -> [ &pa <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = deref'2 {pa} (fun (_ret: t_PA) -> [ &_20 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_25 <- self'0.t_PersistentArray__frag ] s1
      | s1 = deref'3 {_25} (fun (_ret: t_Fragment) -> [ &_23 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0 [ s0 = contains'3 {_20.t_PA__auth} {_23} (fun (_ret: ()) -> [ &_18 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = new'0 {_18} (fun (_ret: ()) -> [ &_17 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_28 <- self'0.t_PersistentArray__permcell ] s1
      | s1 = get_inner_immut {_28} {index'0} {pa} (fun (_ret: t_T) -> [ &_26 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0 [ s0 = [ &_0 <- _26 ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & index'0: UInt64.t = index
    | & tokens'0: t_Tokens = tokens
    | & pa: t_PA = Any.any_l ()
    | & _8: t_PA = Any.any_l ()
    | & _10: t_LocalInvariant = Any.any_l ()
    | & _12: t_Rc'0 = Any.any_l ()
    | & _15: t_Tokens = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: () = Any.any_l ()
    | & _20: t_PA = Any.any_l ()
    | & _23: t_Fragment = Any.any_l ()
    | & _25: t_Fragment = Any.any_l ()
    | & _26: t_T = Any.any_l ()
    | & _28: t_Rc = Any.any_l () ])
    [ return''0 (result: t_T) -> {[@expl:get_immut result type invariant] [%#spersistent_array'2] inv'19 result}
      {[@expl:get_immut ensures] [%#spersistent_array'3] result = Seq.get (view'14 self) (UInt64.t'int index)}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get_inner_immut [#"persistent_array.rs" 209 8 213 18] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span spersistent_array = "persistent_array.rs" 212 12 212 14
  let%span spersistent_array'0 = "persistent_array.rs" 205 19 205 43
  let%span spersistent_array'1 = "persistent_array.rs" 206 19 206 49
  let%span spersistent_array'2 = "persistent_array.rs" 207 19 207 51
  let%span spersistent_array'3 = "persistent_array.rs" 213 13 213 18
  let%span spersistent_array'4 = "persistent_array.rs" 208 18 208 54
  let%span spersistent_array'5 = "persistent_array.rs" 100 12 103 13
  let%span spersistent_array'6 = "persistent_array.rs" 111 16 123 21
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 78 14 78 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 78 4 78 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 183 15 183 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 183 4 185 17
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 195 16 195 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 196 16 196 48
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 197 16 197 56
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spermcell = "../../creusot-contracts/src/cell/permcell.rs" 231 14 231 34
  let%span spermcell'0 = "../../creusot-contracts/src/cell/permcell.rs" 173 39 173 43
  let%span spermcell'1 = "../../creusot-contracts/src/cell/permcell.rs" 171 15 171 37
  let%span spermcell'2 = "../../creusot-contracts/src/cell/permcell.rs" 173 4 173 80
  let%span spermcell'3 = "../../creusot-contracts/src/cell/permcell.rs" 172 14 172 30
  let%span spermcell'4 = "../../creusot-contracts/src/cell/permcell.rs" 34 4 34 12
  let%span spermcell'5 = "../../creusot-contracts/src/cell/permcell.rs" 62 20 62 46
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 354 22 354 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 354 4 354 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 353 14 353 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span soption = "../../creusot-contracts/src/std/option.rs" 145 16 145 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 146 27 146 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 147 26 147 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 764 8 767 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 685 20 685 91
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 118 20 118 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 125 20 125 37
  
  use creusot.prelude.Opaque
  use map.Map
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PermCell
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  function view (self: t_Rc) : t_PermCell
  
  let rec deref (self_: t_Rc) (return' (x: t_PermCell)) = any
    [ return''0 (result: t_PermCell) -> {[%#src] result = view self_} (! return' {result}) ]
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Id
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  type t_PermCellOwn
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view'0 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'4] Map.get (view'0 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'2] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'0; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'1 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'2] Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'3] inv'2 (view'1 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant] inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PermCellOwn) = [%#spermcell'5] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. ([%#slogic] exists x: t_PermCellOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = [%#sfmap'5] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = [%#sfmap'3] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'6] forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_0: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'7 perms /\ inv'8 auth
        end
  
  predicate invariant''6 (self: t_PA) = [%#sinvariant] inv'9 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_0: t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self: t_PA) = [%#sghost'6] inv'10 self
  
  predicate inv'11 (_0: t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: t_PA) = [%#sinvariant] inv'11 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_0: t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: t_PA) = [%#sinvariant] inv'10 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_0: t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref'0 (self: t_PA) (return' (x: t_PA)) = {[@expl:deref 'self' type invariant] [%#sghost] inv'12 self}
    any [ return''0 (result: t_PA) -> {[%#sghost'0] inv'13 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  function id (self: t_PermCell) : t_Id
  
  let rec id_ghost (self: t_PermCell) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#spermcell] result = id self} (! return' {result}) ]
  
  let rec deref'1 (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PermCellOwn
  
  predicate invariant''10 (self: t_FMap) = [%#sinvariant] inv'7 self
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'14 (_0: t_FMap)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_FMap [inv'14 x]. inv'14 x = invariant''10 x
  
  predicate invariant''11 (self: t_PermCellOwn) = [%#sinvariant] inv'6 self
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'15 (_0: t_PermCellOwn)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_PermCellOwn [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate inv'16 (_0: t_Option'0)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Option'0 [inv'16 x]. inv'16 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'15 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PermCellOwn t_PermCellOwn) : t_Option'0 =
    [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Id) (return' (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'14 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'0] inv'16 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PermCellOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_PermCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'16 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any
    [ return''0 (result: t_PermCellOwn) -> {inv'15 result}
      {[%#soption'1] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate invariant''12 (self: t_PermCellOwn) = [%#sghost'6] inv'15 self
  
  predicate inv'17 (_0: t_PermCellOwn)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_PermCellOwn [inv'17 x]. inv'17 x = invariant''12 x
  
  let rec new (x: t_PermCellOwn) (return' (x'0: t_PermCellOwn)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'15 x}
    any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost'3] inv'17 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function view'2 (self: t_PermCellOwn) : t_Inner = [%#spermcell'4] val' self
  
  function view'3 (self: t_PermCellOwn) : t_Inner = [%#smodel] view'2 self
  
  function view'4 (self: t_PermCellOwn) : t_Inner = [%#sghost'5] view'3 self
  
  let rec borrow (self: t_PermCell) (perm: t_PermCellOwn) (return' (x: t_Inner)) =
    {[@expl:borrow 'perm' type invariant] [%#spermcell'0] inv'17 perm}
    {[@expl:borrow requires] [%#spermcell'1] id self = id'0 perm}
    any
    [ return''0 (result: t_Inner) -> {[%#spermcell'2] inv'5 result}
      {[%#spermcell'3] result = view'4 perm}
      (! return' {result}) ]
  
  let rec v_Link (input: t_Inner) (ret (index: UInt64.t) (value: t_T) (next: t_Rc)) = any
    [ good (index: UInt64.t) (value: t_T) (next: t_Rc) -> {C_Link index value next = input}
      (! ret {index} {value} {next})
    | bad -> {forall index: UInt64.t, value: t_T, next: t_Rc [C_Link index value next: t_Inner]. C_Link index value next
        <> input}
      (! {false}
      any) ]
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate invariant''13 (self: t_Vec) = [%#sinvariant] inv'3 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'18 (_0: t_Vec)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Vec [inv'18 x]. inv'18 x = invariant''13 x
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  function view'5 (self: t_Vec) : Seq.seq t_T = [%#smodel] view'1 self
  
  predicate invariant''14 (self: t_T) = [%#sinvariant] inv'0 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'19 (_0: t_T)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_T [inv'19 x]. inv'19 x = invariant''14 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  let rec index (self_: t_Vec) (ix: UInt64.t) (return' (x: t_T)) =
    {[@expl:index 'self_' type invariant] [%#svec] inv'18 self_}
    {[@expl:index requires] [%#svec'0] in_bounds ix (view'5 self_)}
    any
    [ return''0 (result: t_T) -> {inv'19 result} {[%#svec'1] has_value ix (view'5 self_) result} (! return' {result}) ]
  
  function id'1 (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'1 = C_None'1 | C_Some'1 (Seq.seq t_T)
  
  function view'6 (self: t_FMap'0) : Map.map t_Id t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'1 = [%#sfmap'4] Map.get (view'6 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'2] get'0 self k <> C_None'1
  
  function view'7 (self: t_Authority) : t_FMap'0
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#slogic] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#slogic'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'1) : Seq.seq t_T = [%#soption'4] match self with
      | C_Some'1 x -> x
      | C_None'1 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'5] unwrap_logic'0 (get'0 self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'3] lookup'0 self key
  
  function view'8 (self: t_Rc) : t_PermCell = [%#smodel] view self
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  function view'9 (self: UInt64.t) : int = [%#smodel] UInt64.t'int self
  
  predicate partial_invariant [#"persistent_array.rs" 109 8 109 59] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'6] id'1 self.t_PA__auth = resource_id
    /\ (forall id'2: t_Id. contains'0 (view'7 self.t_PA__auth) id'2 /\ contains self.t_PA__perms id'2
      -> id'0 (index_logic'0 self.t_PA__perms id'2) = id'2
      /\ match val' (index_logic'0 self.t_PA__perms id'2) with
        | C_Direct v -> index_logic'2 (view'7 self.t_PA__auth) id'2 = view'5 v
        | C_Link index'0 value next -> contains'0 (view'7 self.t_PA__auth) (id (view'8 next))
        /\ index_logic'3 self.t_PA__depth id'2 > index_logic'3 self.t_PA__depth (id (view'8 next))
        /\ view'9 index'0 < Seq.length (index_logic'2 (view'7 self.t_PA__auth) (id (view'8 next)))
        /\ index_logic'2 (view'7 self.t_PA__auth) id'2
        = Seq.set (index_logic'2 (view'7 self.t_PA__auth) (id (view'8 next))) (view'9 index'0) value
        end)
  
  predicate protocol [#"persistent_array.rs" 99 8 99 50] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'5] partial_invariant self resource_id
    /\ (forall id'2: t_Id. contains'0 (view'7 self.t_PA__auth) id'2 -> contains self.t_PA__perms id'2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_inner_immut [#"persistent_array.rs" 209 8 213 18] (inner: t_Rc) (i: UInt64.t) (pa: t_PA)
    (return' (x: t_T)) = {[@expl:get_inner_immut 'pa' type invariant] [%#spersistent_array] inv'11 pa}
    {[@expl:get_inner_immut requires #0] [%#spersistent_array'0] exists p: t_Id. protocol pa p}
    {[@expl:get_inner_immut requires #1] [%#spersistent_array'1] contains'0 (view'7 pa.t_PA__auth) (id (view'8 inner))}
    {[@expl:get_inner_immut requires #2] [%#spersistent_array'2] UInt64.t'int i
    < Seq.length (index_logic'2 (view'7 pa.t_PA__auth) (id (view'8 inner)))}
    (! bb0
    [ bb0 = s0 [ s0 = deref {inner'0} (fun (_ret: t_PermCell) -> [ &_11 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref'0 {pa'0} (fun (_ret: t_PA) -> [ &_18 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = deref {inner'0} (fun (_ret: t_PermCell) -> [ &_26 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = id_ghost {_26} (fun (_ret: t_Id) -> [ &_24 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = deref'1 {_24} (fun (_ret: t_Id) -> [ &_22 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_21 <- _22 ] s1
      | s1 = get_ghost {_18.t_PA__perms} {_21} (fun (_ret: t_Option'0) -> [ &_16 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = unwrap {_16} (fun (_ret: t_PermCellOwn) -> [ &_15 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = new {_15} (fun (_ret: t_PermCellOwn) -> [ &_13 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = borrow {_11} {_13} (fun (_ret: t_Inner) -> [ &_9 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = any
      [ br0 (x0: t_Vec) -> {_9 = C_Direct x0} (! bb15)
      | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {_9 = C_Link x0 x1 x2} (! bb14) ]
    | bb14 = s0
      [ s0 = v_Link {_9} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &index'0 <- rindex ] s1)
      | s1 = [ &index'1 <- index'0 ] s2
      | s2 = v_Link {_9} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &value <- rvalue ] s3)
      | s3 = [ &value'0 <- value ] s4
      | s4 = [ &_40 <- i'0 = index'1 ] s5
      | s5 = any [ br0 -> {_40 = false} (! bb13) | br1 -> {_40} (! bb17) ] ]
    | bb17 = s0 [ s0 = [ &_8 <- value ] s1 | s1 = bb20 ]
    | bb13 = s0
      [ s0 = v_Link {_9} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &next <- rnext ] s1)
      | s1 = get_inner_immut {next} {i'0} {pa'0} (fun (_ret: t_T) -> [ &_44 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0 [ s0 = [ &_8 <- _44 ] s1 | s1 = bb20 ]
    | bb15 = s0
      [ s0 = v_Direct {_9} (fun (r0: t_Vec) -> [ &v <- r0 ] s1)
      | s1 = index {v} {i'0} (fun (_ret: t_T) -> [ &_33 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0 [ s0 = [ &_32 <- _33 ] s1 | s1 = [ &_8 <- _32 ] s2 | s2 = bb20 ]
    | bb20 = s0 [ s0 = [ &_0 <- _8 ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & inner'0: t_Rc = inner
    | & i'0: UInt64.t = i
    | & pa'0: t_PA = pa
    | & _8: t_T = Any.any_l ()
    | & _9: t_Inner = Any.any_l ()
    | & _11: t_PermCell = Any.any_l ()
    | & _13: t_PermCellOwn = Any.any_l ()
    | & _15: t_PermCellOwn = Any.any_l ()
    | & _16: t_Option'0 = Any.any_l ()
    | & _18: t_PA = Any.any_l ()
    | & _21: t_Id = Any.any_l ()
    | & _22: t_Id = Any.any_l ()
    | & _24: t_Id = Any.any_l ()
    | & _26: t_PermCell = Any.any_l ()
    | & v: t_Vec = Any.any_l ()
    | & _32: t_T = Any.any_l ()
    | & _33: t_T = Any.any_l ()
    | & index'0: UInt64.t = Any.any_l ()
    | & index'1: UInt64.t = Any.any_l ()
    | & value: t_T = Any.any_l ()
    | & value'0: t_T = Any.any_l ()
    | & _40: bool = Any.any_l ()
    | & next: t_Rc = Any.any_l ()
    | & _44: t_T = Any.any_l () ])
    [ return''0 (result: t_T) -> {[@expl:get_inner_immut result type invariant] [%#spersistent_array'3] inv'19 result}
      {[@expl:get_inner_immut ensures] [%#spersistent_array'4] result
      = Seq.get (index_logic'2 (view'7 pa.t_PA__auth) (id (view'8 inner))) (UInt64.t'int i)}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get [#"persistent_array.rs" 231 8 231 89] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span spersistent_array = "persistent_array.rs" 232 26 232 55
  let%span spersistent_array'0 = "persistent_array.rs" 231 34 231 38
  let%span spersistent_array'1 = "persistent_array.rs" 228 8 228 46
  let%span spersistent_array'2 = "persistent_array.rs" 229 19 229 39
  let%span spersistent_array'3 = "persistent_array.rs" 231 84 231 89
  let%span spersistent_array'4 = "persistent_array.rs" 230 18 230 42
  let%span spersistent_array'5 = "persistent_array.rs" 233 34 233 42
  let%span spersistent_array'6 = "persistent_array.rs" 233 39 233 41
  let%span spersistent_array'7 = "persistent_array.rs" 262 75 262 77
  let%span spersistent_array'8 = "persistent_array.rs" 248 8 248 51
  let%span spersistent_array'9 = "persistent_array.rs" 249 19 249 47
  let%span spersistent_array'10 = "persistent_array.rs" 250 19 251 37
  let%span spersistent_array'11 = "persistent_array.rs" 253 18 253 51
  let%span spersistent_array'12 = "persistent_array.rs" 254 18 254 39
  let%span spersistent_array'13 = "persistent_array.rs" 255 18 256 86
  let%span spersistent_array'14 = "persistent_array.rs" 257 18 257 78
  let%span spersistent_array'15 = "persistent_array.rs" 258 18 261 9
  let%span spersistent_array'16 = "persistent_array.rs" 78 24 78 36
  let%span spersistent_array'17 = "persistent_array.rs" 111 16 123 21
  let%span spersistent_array'18 = "persistent_array.rs" 100 12 103 13
  let%span spersistent_array'19 = "persistent_array.rs" 62 16 64 52
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 78 14 78 18
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 78 4 78 36
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 89 22 89 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 89 4 89 48
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 88 14 88 35
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 183 15 183 16
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 183 4 185 17
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 205 22 205 26
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 205 4 207 17
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 203 14 203 29
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 193 14 193 26
  let%span sghost'13 = "../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sghost'14 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span sfmap_view = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'0 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'2 = "../../creusot-contracts/src/ghost/resource/fmap_view.rs" 105 14 105 49
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 106 20 106 44
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 202 16 202 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 203 26 203 42
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spermcell = "../../creusot-contracts/src/cell/permcell.rs" 231 14 231 34
  let%span spermcell'0 = "../../creusot-contracts/src/cell/permcell.rs" 173 39 173 43
  let%span spermcell'1 = "../../creusot-contracts/src/cell/permcell.rs" 171 15 171 37
  let%span spermcell'2 = "../../creusot-contracts/src/cell/permcell.rs" 173 4 173 80
  let%span spermcell'3 = "../../creusot-contracts/src/cell/permcell.rs" 172 14 172 30
  let%span spermcell'4 = "../../creusot-contracts/src/cell/permcell.rs" 34 4 34 12
  let%span spermcell'5 = "../../creusot-contracts/src/cell/permcell.rs" 62 20 62 46
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 354 22 354 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 354 4 354 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 353 14 353 55
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span slocal_invariant = "../../creusot-contracts/src/ghost/local_invariant.rs" 278 51 278 52
  let%span slocal_invariant'0 = "../../creusot-contracts/src/ghost/local_invariant.rs" 275 15 275 113
  let%span slocal_invariant'1 = "../../creusot-contracts/src/ghost/local_invariant.rs" 278 4 280 51
  let%span slocal_invariant'2 = "../../creusot-contracts/src/ghost/local_invariant.rs" 276 14 276 121
  let%span slocal_invariant'3 = "../../creusot-contracts/src/ghost/local_invariant.rs" 181 4 181 12
  let%span slocal_invariant'4 = "../../creusot-contracts/src/ghost/local_invariant.rs" 260 4 262 51
  let%span slocal_invariant'5 = "../../creusot-contracts/src/ghost/local_invariant.rs" 260 51 260 52
  let%span slocal_invariant'6 = "../../creusot-contracts/src/ghost/local_invariant.rs" 252 15 252 46
  let%span slocal_invariant'7 = "../../creusot-contracts/src/ghost/local_invariant.rs" 253 15 254 111
  let%span slocal_invariant'8 = "../../creusot-contracts/src/ghost/local_invariant.rs" 256 14 257 120
  let%span slocal_invariant'9 = "../../creusot-contracts/src/ghost/local_invariant.rs" 237 4 239 51
  let%span slocal_invariant'10 = "../../creusot-contracts/src/ghost/local_invariant.rs" 237 51 237 52
  let%span slocal_invariant'11 = "../../creusot-contracts/src/ghost/local_invariant.rs" 230 4 230 50
  let%span slocal_invariant'12 = "../../creusot-contracts/src/ghost/local_invariant.rs" 231 15 234 89
  let%span slocal_invariant'13 = "../../creusot-contracts/src/ghost/local_invariant.rs" 235 14 235 102
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 145 16 145 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 146 27 146 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 147 26 147 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 764 8 767 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 685 20 685 91
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 4 133 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 4 134 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 4 139 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 4 144 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 4 145 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 4 146 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 367 8 367 9
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 367 8 367 40
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 368 8 368 48
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 118 20 118 37
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 125 20 125 37
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 21 20 21 30
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use set.Set
  
  type t_LocalInvariant
  
  type t_Id
  
  function public (self: t_LocalInvariant) : t_Id
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  function view (self: t_Rc) : t_LocalInvariant
  
  function view'0 (self: t_Rc) : t_LocalInvariant = [%#sghost] view self
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_Resource
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc'0;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc }
  
  type t_FMap
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  type t_PermCellOwn
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view'1 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'2] Map.get (view'1 self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'3] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'1; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc'0
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'1] Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'2] inv'2 (view'2 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant] inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PermCellOwn) = [%#spermcell'5] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. ([%#slogic] exists x: t_PermCellOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = [%#sfmap'5] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = [%#sfmap'4] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'6] forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_0: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'7 perms /\ inv'8 auth
        end
  
  predicate invariant''6 (self: MutBorrow.t t_PA) = [%#sinvariant'0] inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self: MutBorrow.t t_PA) = [%#sghost'14] inv'10 self
  
  predicate inv'11 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'11 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'10 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:deref 'self' type invariant] [%#sghost'0] inv'12 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'1] inv'13 result}
      {[%#sghost'2] result = self}
      (! return' {result}) ]
  
  type closure0 = { _0: t_PersistentArray; _1: t_Id; _2: UInt64.t }
  
  predicate invariant''10 (self: t_Fragment)
  
  predicate inv'14 (_0'0: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
      = (invariant''10 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''11 (self: t_Fragment) = [%#sghost'14] inv'14 self
  
  predicate inv'15 (_0'0: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate invariant''12 (self: t_Fragment) = [%#sinvariant] inv'15 self
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'16 (_0'0: t_Fragment)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Fragment [inv'16 x]. inv'16 x = invariant''12 x
  
  predicate invariant''13 (self: t_Fragment) = [%#sinvariant] inv'14 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'17 (_0'0: t_Fragment)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Fragment [inv'17 x]. inv'17 x = invariant''13 x
  
  let rec deref'0 (self: t_Fragment) (return' (x: t_Fragment)) =
    {[@expl:deref 'self' type invariant] [%#sghost'0] inv'16 self}
    any
    [ return''0 (result: t_Fragment) -> {[%#sghost'1] inv'17 result} {[%#sghost'2] result = self} (! return' {result}) ]
  
  predicate invariant''14 (self: t_Authority) = [%#sinvariant] inv'8 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'18 (_0'0: t_Authority)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Authority [inv'18 x]. inv'18 x = invariant''14 x
  
  function id (self: t_Authority) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'3 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = [%#sfmap'2] Map.get (view'3 self) k
  
  function view'4 (self: t_Authority) : t_FMap'0
  
  function view'5 (self: t_Authority) : t_FMap'0 = [%#smodel] view'4 self
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view'6 (self: t_Fragment) : tuple
  
  function view'7 (self: t_Fragment) : tuple = [%#smodel] view'6 self
  
  let rec contains'0 (self: t_Authority) (frag: t_Fragment) (return' (x: ())) =
    {[@expl:contains 'self' type invariant] [%#sfmap_view] inv'18 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'0] inv'17 frag}
    {[@expl:contains requires] [%#sfmap_view'1] id self = id'0 frag}
    any
    [ return''0 (result: ()) -> {[%#sfmap_view'2] get'0 (view'5 self) (view'7 frag)._p0 = C_Some'0 ((view'7 frag)._p1)}
      (! return' {result}) ]
  
  let rec new (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'3] result = x} (! return' {result}) ]
  
  predicate invariant''15 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant'0] inv'11 self.current /\ inv'11 self.final
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'19 (_0'0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'19 x]. inv'19 x = invariant''15 x
  
  predicate invariant''16 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant'0] inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'20 (_0'0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'20 x]. inv'20 x = invariant''16 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return' (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost'4] inv'19 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_PA)) -> {[%#sghost'5] inv'20 result}
      {[%#sghost'6] result = self}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_PA)) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0'0: MutBorrow.t (MutBorrow.t t_PA)) = resolve _0'0
  
  let rec new'0 (x: MutBorrow.t t_PA) (return' (x'0: MutBorrow.t t_PA)) =
    {[@expl:new 'x' type invariant] [%#sghost'7] inv'10 x}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'8] inv'11 result}
      {[%#sghost'3] result = x}
      (! return' {result}) ]
  
  predicate resolve'1 (self: MutBorrow.t t_PA) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (_0'0: MutBorrow.t t_PA) = resolve'1 _0'0
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'3] get'0 self k <> C_None'0
  
  function id'1 (self: t_PermCellOwn) : t_Id
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#slogic] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#slogic'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = [%#soption'4] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'5] unwrap_logic'0 (get'0 self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'4] lookup'0 self key
  
  function view'8 (self: t_Vec) : Seq.seq t_T = [%#smodel] view'2 self
  
  type t_PermCell
  
  function id'2 (self: t_PermCell) : t_Id
  
  function view'9 (self: t_Rc'0) : t_PermCell
  
  function view'10 (self: t_Rc'0) : t_PermCell = [%#smodel] view'9 self
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  function view'11 (self: UInt64.t) : int = [%#smodel] UInt64.t'int self
  
  predicate partial_invariant [#"persistent_array.rs" 109 8 109 59] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'17] id self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains'1 (view'4 self.t_PA__auth) id'3 /\ contains self.t_PA__perms id'3
      -> id'1 (index_logic'0 self.t_PA__perms id'3) = id'3
      /\ match val' (index_logic'0 self.t_PA__perms id'3) with
        | C_Direct v -> index_logic'2 (view'4 self.t_PA__auth) id'3 = view'8 v
        | C_Link index value next -> contains'1 (view'4 self.t_PA__auth) (id'2 (view'10 next))
        /\ index_logic'3 self.t_PA__depth id'3 > index_logic'3 self.t_PA__depth (id'2 (view'10 next))
        /\ view'11 index < Seq.length (index_logic'2 (view'4 self.t_PA__auth) (id'2 (view'10 next)))
        /\ index_logic'2 (view'4 self.t_PA__auth) id'3
        = Seq.set (index_logic'2 (view'4 self.t_PA__auth) (id'2 (view'10 next))) (view'11 index) value
        end)
  
  function fin (self: MutBorrow.t t_PA) : t_PA = [%#sghost'13] self.final
  
  let rec reroot (cur: t_Rc'0) (auth_id: t_Id) (pa: MutBorrow.t t_PA) (return' (x: ())) =
    {[@expl:reroot 'pa' type invariant] [%#spersistent_array'7] inv'11 pa}
    {[@expl:reroot requires #0] [%#spersistent_array'8] partial_invariant pa.current auth_id}
    {[@expl:reroot requires #1] [%#spersistent_array'9] contains'1 (view'4 (pa.current).t_PA__auth) (id'2 (view'10 cur))}
    {[@expl:reroot requires #2] [%#spersistent_array'10] forall id'3: t_Id. contains'1 (view'4 (pa.current).t_PA__auth) id'3
        /\ index_logic'3 (pa.current).t_PA__depth id'3 <= index_logic'3 (pa.current).t_PA__depth (id'2 (view'10 cur))
      -> contains (pa.current).t_PA__perms id'3}
    any
    [ return''0 (result: ()) -> {[%#spersistent_array'11] partial_invariant (fin pa) auth_id}
      {[%#spersistent_array'12] (fin pa).t_PA__auth = (pa.current).t_PA__auth}
      {[%#spersistent_array'13] forall id'3: t_Id. index_logic'3 (pa.current).t_PA__depth id'3
          > index_logic'3 (pa.current).t_PA__depth (id'2 (view'10 cur))
        -> get (pa.current).t_PA__perms id'3 = get (fin pa).t_PA__perms id'3
        /\ index_logic'3 (pa.current).t_PA__depth id'3 = index_logic'3 (fin pa).t_PA__depth id'3}
      {[%#spersistent_array'14] forall id'3: t_Id. contains (fin pa).t_PA__perms id'3
        = contains (pa.current).t_PA__perms id'3}
      {[%#spersistent_array'15] match val' (index_logic'0 (fin pa).t_PA__perms (id'2 (view'10 cur))) with
        | C_Direct _ -> true
        | C_Link _ _ _ -> false
        end}
      (! return' {result}) ]
  
  let rec into_inner (self: MutBorrow.t t_PA) (return' (x: MutBorrow.t t_PA)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'9] inv'11 self}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'10] inv'10 result}
      {[%#sghost'11] result = self}
      (! return' {result}) ]
  
  let rec deref'1 (self_: t_Rc'0) (return' (x: t_PermCell)) = any
    [ return''0 (result: t_PermCell) -> {[%#src] result = view'9 self_} (! return' {result}) ]
  
  let rec id_ghost (self: t_PermCell) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#spermcell] result = id'2 self} (! return' {result}) ]
  
  let rec deref'2 (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'2] result = self} (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_PermCellOwn
  
  predicate invariant''17 (self: t_FMap) = [%#sinvariant] inv'7 self
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'21 (_0'0: t_FMap)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_FMap [inv'21 x]. inv'21 x = invariant''17 x
  
  predicate invariant''18 (self: t_PermCellOwn) = [%#sinvariant] inv'6 self
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'22 (_0'0: t_PermCellOwn)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_PermCellOwn [inv'22 x]. inv'22 x = invariant''18 x
  
  predicate inv'23 (_0'0: t_Option'1)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_Option'1 [inv'23 x]. inv'23 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'22 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PermCellOwn t_PermCellOwn) : t_Option'1 =
    [%#soption'2] match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Id) (return' (x: t_Option'1)) =
    {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'21 self}
    any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'0] inv'23 result}
      {[%#sfmap'1] result = map_logic (get self key) (fun (v: t_PermCellOwn) -> v)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'1) (return' (x: t_PermCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'23 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result: t_PermCellOwn) -> {inv'22 result}
      {[%#soption'1] C_Some'1 result = self_}
      (! return' {result}) ]
  
  predicate invariant''19 (self: t_PermCellOwn) = [%#sghost'14] inv'22 self
  
  predicate inv'24 (_0'0: t_PermCellOwn)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_PermCellOwn [inv'24 x]. inv'24 x = invariant''19 x
  
  let rec new'1 (x: t_PermCellOwn) (return' (x'0: t_PermCellOwn)) =
    {[@expl:new 'x' type invariant] [%#sghost'7] inv'22 x}
    any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost'8] inv'24 result} {[%#sghost'3] result = x} (! return' {result}) ]
  
  function view'12 (self: t_PermCellOwn) : t_Inner = [%#spermcell'4] val' self
  
  function view'13 (self: t_PermCellOwn) : t_Inner = [%#smodel] view'12 self
  
  function view'14 (self: t_PermCellOwn) : t_Inner = [%#sghost] view'13 self
  
  let rec borrow (self: t_PermCell) (perm: t_PermCellOwn) (return' (x: t_Inner)) =
    {[@expl:borrow 'perm' type invariant] [%#spermcell'0] inv'24 perm}
    {[@expl:borrow requires] [%#spermcell'1] id'2 self = id'1 perm}
    any
    [ return''0 (result: t_Inner) -> {[%#spermcell'2] inv'5 result}
      {[%#spermcell'3] result = view'14 perm}
      (! return' {result}) ]
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate invariant''20 (self: t_Vec) = [%#sinvariant] inv'3 self
  
  meta "rewrite_def" predicate invariant''20
  
  predicate inv'25 (_0'0: t_Vec)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_Vec [inv'25 x]. inv'25 x = invariant''20 x
  
  predicate invariant''21 (self: Slice64.slice t_T) = [%#sslice'4] inv'2 (Slice64.view self)
  
  predicate inv'26 (_0'0: Slice64.slice t_T)
  
  axiom inv_axiom'25 [@rewrite]: forall x: Slice64.slice t_T [inv'26 x]. inv'26 x = invariant''21 x
  
  predicate invariant''22 (self: Slice64.slice t_T) = [%#sinvariant] inv'26 self
  
  meta "rewrite_def" predicate invariant''22
  
  predicate inv'27 (_0'0: Slice64.slice t_T)
  
  axiom inv_axiom'26 [@rewrite]: forall x: Slice64.slice t_T [inv'27 x]. inv'27 x = invariant''22 x
  
  function view'15 (self: Slice64.slice t_T) : Seq.seq t_T = [%#smodel] Slice64.view self
  
  let rec deref'3 (self_: t_Vec) (return' (x: Slice64.slice t_T)) =
    {[@expl:deref 'self_' type invariant] [%#svec] inv'25 self_}
    any
    [ return''0 (result: Slice64.slice t_T) -> {inv'27 result}
      {[%#svec'0] view'15 result = view'8 self_}
      (! return' {result}) ]
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice'2] UInt64.t'int self < Seq.length seq
  
  predicate invariant''23 (self: t_T) = [%#sinvariant] inv'0 self
  
  meta "rewrite_def" predicate invariant''23
  
  predicate inv'28 (_0'0: t_T)
  
  axiom inv_axiom'27 [@rewrite]: forall x: t_T [inv'28 x]. inv'28 x = invariant''23 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'3] Seq.get seq (UInt64.t'int self) = out
  
  let rec get_unchecked (self_: Slice64.slice t_T) (ix: UInt64.t) (return' (x: t_T)) =
    {[@expl:get_unchecked 'self_' type invariant] [%#sslice] inv'27 self_}
    {[@expl:get_unchecked requires] [%#sslice'0] in_bounds ix (view'15 self_)}
    any
    [ return''0 (result: t_T) -> {inv'28 result}
      {[%#sslice'1] has_value ix (view'15 self_) result}
      (! return' {result}) ]
  
  function view'16 (self: t_Fragment) : tuple = [%#sghost] view'6 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''24 [#"persistent_array.rs" 59 8 59 34] (self: t_PersistentArray) =
    [%#spersistent_array'19] (view'16 self.t_PersistentArray__frag)._p0 = id'2 (view'9 self.t_PersistentArray__permcell)
    /\ id'0 self.t_PersistentArray__frag = public (view'0 self.t_PersistentArray__inv)
    /\ namespace (view'0 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'29 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'28 [@rewrite]: forall x: t_PersistentArray [inv'29 x]. inv'29 x
      = (invariant''24 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'30} -> inv'15 frag
        end)
  
  predicate invariant''25 (self: t_PersistentArray) = [%#sinvariant] inv'29 self
  
  meta "rewrite_def" predicate invariant''25
  
  predicate inv'30 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'29 [@rewrite]: forall x: t_PersistentArray [inv'30 x]. inv'30 x = invariant''25 x
  
  predicate invariant''26 (self: t_PersistentArray) = [%#sinvariant] inv'30 self
  
  meta "rewrite_def" predicate invariant''26
  
  predicate inv'31 (_0'0: t_PersistentArray)
  
  axiom inv_axiom'30 [@rewrite]: forall x: t_PersistentArray [inv'31 x]. inv'31 x = invariant''26 x
  
  predicate inv'32 (_0'0: closure0)
  
  axiom inv_axiom'31 [@rewrite]: forall x: closure0 [inv'32 x]. inv'32 x
      = (let {_0 = x0; _1 = x1; _2 = x2} = x in inv'31 x0)
  
  let rec closure0 [#"persistent_array.rs" 233 34 233 42] [@coma:extspec] (self: closure0) (pa: MutBorrow.t t_PA)
    (return' (x: t_T)) = bb0
    [ bb0 = s0 [ s0 = deref {pa'0} (fun (_ret: MutBorrow.t t_PA) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_11 <- (_1'0._0).t_PersistentArray__frag ] s1
      | s1 = deref'0 {_11} (fun (_ret: t_Fragment) -> [ &_9 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = contains'0 {(_6.current).t_PA__auth} {_9} (fun (_ret: ()) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_4} (fun (_ret: ()) -> [ &_3 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_14 <- (_1'0._0).t_PersistentArray__permcell ] s1
      | s1 = {inv'11 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_21 <- _ret ] -{inv'11 _ret.final}-
            [ &pa'0 <- _ret.final ] s2)
      | s2 = deref_mut {_21} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_20 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'10 _20.current}
        MutBorrow.borrow_final <MutBorrow.t t_PA> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_19 <- _ret ] -{inv'10 _ret.final}-
            [ &_20 <- { _20 with current = _ret.final } ] s1)
      | s1 = {inv'9 (_19.current).current}
        MutBorrow.borrow_mut <t_PA> {(_19.current).current}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_18 <- _ret ] -{inv'9 _ret.final}-
            [ &_19 <- { _19 with current = { _19.current with current = _ret.final } } ] s2)
      | s2 = {[@expl:type invariant] inv'20 _20} s3
      | s3 = -{resolve'0 _20}- s4
      | s4 = {[@expl:type invariant] inv'20 _19} s5
      | s5 = -{resolve'0 _19}- s6
      | s6 = {inv'9 _18.current}
        MutBorrow.borrow_final <t_PA> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_17 <- _ret ] -{inv'9 _ret.final}-
            [ &_18 <- { _18 with current = _ret.final } ] s7)
      | s7 = new'0 {_17} (fun (_ret: MutBorrow.t t_PA) -> [ &_16 <- _ret ] s8)
      | s8 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'10 _18} s1
      | s1 = -{resolve'2 _18}- s2
      | s2 = reroot {_14} {_1'0._1} {_16} (fun (_ret: ()) -> [ &_12 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = into_inner {pa'0} (fun (_ret: MutBorrow.t t_PA) -> [ &_26 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0
      [ s0 = deref'1 {(_1'0._0).t_PersistentArray__permcell} (fun (_ret: t_PermCell) -> [ &_34 <- _ret ] s1)
      | s1 = bb9 ]
    | bb9 = s0 [ s0 = id_ghost {_34} (fun (_ret: t_Id) -> [ &_32 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = [ &_31 <- _32 ] s1 | s1 = deref'2 {_31} (fun (_ret: t_Id) -> [ &_29 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0
      [ s0 = get_ghost {(_26.current).t_PA__perms} {_29} (fun (_ret: t_Option'1) -> [ &_24 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_24} (fun (_ret: t_PermCellOwn) -> [ &_23 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'10 _26} s1
      | s1 = -{resolve'2 _26}- s2
      | s2 = new'1 {_23} (fun (_ret: t_PermCellOwn) -> [ &perm <- _ret ] s3)
      | s3 = bb14 ]
    | bb14 = s0
      [ s0 = deref'1 {(_1'0._0).t_PersistentArray__permcell} (fun (_ret: t_PermCell) -> [ &_40 <- _ret ] s1)
      | s1 = bb15 ]
    | bb15 = s0 [ s0 = borrow {_40} {perm} (fun (_ret: t_Inner) -> [ &_38 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = any
      [ br0 (x0: t_Vec) -> {_38 = C_Direct x0} (! bb18)
      | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc'0) -> {_38 = C_Link x0 x1 x2} (! bb19) ]
    | bb19 = {false} any
    | bb18 = s0
      [ s0 = v_Direct {_38} (fun (r0: t_Vec) -> [ &arr <- r0 ] s1)
      | s1 = deref'3 {arr} (fun (_ret: Slice64.slice t_T) -> [ &_45 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = get_unchecked {_45} {_1'0._2} (fun (_ret: t_T) -> [ &_0'0 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = return' {_0'0} ]
    [ & _0'0: t_T = Any.any_l ()
    | & _1'0: closure0 = self
    | & pa'0: MutBorrow.t t_PA = pa
    | & _3: () = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _6: MutBorrow.t t_PA = Any.any_l ()
    | & _9: t_Fragment = Any.any_l ()
    | & _11: t_Fragment = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & _14: t_Rc'0 = Any.any_l ()
    | & _16: MutBorrow.t t_PA = Any.any_l ()
    | & _17: MutBorrow.t t_PA = Any.any_l ()
    | & _18: MutBorrow.t t_PA = Any.any_l ()
    | & _19: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _20: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & perm: t_PermCellOwn = Any.any_l ()
    | & _23: t_PermCellOwn = Any.any_l ()
    | & _24: t_Option'1 = Any.any_l ()
    | & _26: MutBorrow.t t_PA = Any.any_l ()
    | & _29: t_Id = Any.any_l ()
    | & _31: t_Id = Any.any_l ()
    | & _32: t_Id = Any.any_l ()
    | & _34: t_PermCell = Any.any_l ()
    | & arr: t_Vec = Any.any_l ()
    | & _38: t_Inner = Any.any_l ()
    | & _40: t_PermCell = Any.any_l ()
    | & _45: Slice64.slice t_T = Any.any_l () ]
  
  type t_Tokens
  
  type tuple'0 = { _p0'0: t_Rc; _p1'0: t_Tokens; _p2: closure0 }
  
  predicate postcondition_once (self: ()) (args: t_Rc) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  predicate resolve'3 (_0'0: ()) = true
  
  predicate postcondition_mut (self: ()) (args: t_Rc) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  function fn_mut_once (self: ()) (args: t_Rc) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec:
    forall self: (), args: t_Rc, res: t_LocalInvariant. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'3 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) = true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Rc, res_state: (), res: t_LocalInvariant. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_Rc) (result: t_LocalInvariant) = let self_ = args in result = view self_
  
  function fn_once (self: ()) (args: t_Rc) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc, res: t_LocalInvariant. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve'3 self)
  
  function fn_mut (self: ()) (args: t_Rc) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Rc, res_state: (), res: t_LocalInvariant. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  type tuple'1 = { _p0'1: t_LocalInvariant; _p1'1: t_Tokens; _p2'0: closure0 }
  
  predicate protocol [#"persistent_array.rs" 99 8 99 50] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'18] partial_invariant self resource_id
    /\ (forall id'3: t_Id. contains'1 (view'4 self.t_PA__auth) id'3 -> contains self.t_PA__perms id'3)
  
  predicate precondition (self: closure0) (args: MutBorrow.t t_PA) =
    [%#spersistent_array'5] let pa = args in closure0'pre self pa
  
  predicate postcondition_once'0 (self: closure0) (args: MutBorrow.t t_PA) (result: t_T) =
    [%#spersistent_array'5] let pa = args in closure0'post'return' self pa result
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = [%#sset] Set.mem e self
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'3 (self: t_Tokens) (namespace'0: t_Namespace) =
    [%#slocal_invariant'3] contains'2 (namespaces self) namespace'0
  
  predicate precondition'0 (self: ()) (args: tuple'1) =
    [%#slocal_invariant'9] let {_p0'1 = self'0; _p1'1 = tokens; _p2'0 = f} = args in (forall t: MutBorrow.t t_PA. protocol t.current (public self'0)
          /\ inv'11 t
        -> precondition f t /\ (forall res: t_T. postcondition_once'0 f t res -> protocol (fin t) (public self'0)))
    /\ contains'3 tokens (namespace self'0) /\ inv'32 f
  
  function new_logic (x: t_LocalInvariant) : t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. [%#sghost'12] new_logic x = x
  
  predicate precondition'1 (self: ()) (args: t_Rc) = let self_ = args in true
  
  predicate precondition'2 (self: ()) (args: tuple'0) =
    [%#slocal_invariant'4] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (forall this: t_LocalInvariant. postcondition () self'0 this
        -> precondition'0 () { _p0'1 = new_logic this; _p1'1 = tokens; _p2'0 = f })
    /\ precondition'1 () self'0 /\ inv'32 f
  
  let rec deref'4 (self_: t_Rc) (return' (x: t_LocalInvariant)) = any
    [ return''0 (result: t_LocalInvariant) -> {[%#src] result = view self_} (! return' {result}) ]
  
  let rec open (self: t_LocalInvariant) (tokens: t_Tokens) (f: closure0) (return' (x: t_T)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant'10] inv'32 f}
    {[@expl:open requires #0] [%#slocal_invariant'11] contains'3 tokens (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'12] forall t: MutBorrow.t t_PA. protocol t.current (public self)
        /\ inv'11 t
      -> precondition f t /\ (forall res: t_T. postcondition_once'0 f t res -> protocol (fin t) (public self))}
    any
    [ return''0 (result: t_T) -> {[%#slocal_invariant'9] inv'28 result}
      {[%#slocal_invariant'13] exists t: MutBorrow.t t_PA. protocol t.current (public self)
        /\ postcondition_once'0 f t result}
      (! return' {result}) ]
  
  predicate postcondition_once'1 (self: ()) (args: tuple'1) (result: t_T) =
    [%#slocal_invariant'9] let {_p0'1 = self'0; _p1'1 = tokens; _p2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'28 result
  
  predicate resolve'4 (_0'0: ()) = true
  
  predicate postcondition_mut'0 (self: ()) (args: tuple'1) (result_state: ()) (result: t_T) =
    [%#slocal_invariant'9] let {_p0'1 = self'0; _p1'1 = tokens; _p2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'28 result
  
  function fn_mut_once'0 (self: ()) (args: tuple'1) (res: t_T) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'1, res: t_T. [%#sops'8] postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'4 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) = true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
      -> ([%#sops'6] hist_inv'0 b c) -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'1) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: tuple'1, res_state: (), res: t_T. ([%#sops'2] postcondition_mut'0 self args res_state res)
      -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple'1) (result: t_T) =
    [%#slocal_invariant'9] let {_p0'1 = self'0; _p1'1 = tokens; _p2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'28 result
  
  function fn_once'0 (self: ()) (args: tuple'1) (res: t_T) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'1, res: t_T. [%#sops'0] postcondition_once'1 self args res
      = (postcondition'0 self args res /\ resolve'4 self)
  
  function fn_mut'0 (self: ()) (args: tuple'1) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: tuple'1, res_state: (), res: t_T. [%#sops] postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc) (tokens: t_Tokens) (f: closure0) (return' (x: t_T)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant'5] inv'32 f}
    {[@expl:open requires #0] [%#slocal_invariant'6] precondition'1 () self}
    {[@expl:open requires #1] [%#slocal_invariant'7] forall this: t_LocalInvariant. postcondition () self this
      -> precondition'0 () { _p0'1 = new_logic this; _p1'1 = tokens; _p2'0 = f }}
    any
    [ return''0 (result: t_T) -> {[%#slocal_invariant'4] inv'28 result}
      {[%#slocal_invariant'8] exists this: t_LocalInvariant. postcondition () self this
        /\ postcondition'0 () { _p0'1 = new_logic this; _p1'1 = tokens; _p2'0 = f } result}
      (! return' {result}) ]
  
  function new_logic'0 (x: t_Rc) : t_Rc
  
  axiom new_logic_spec'0: forall x: t_Rc. [%#sghost'12] new_logic'0 x = x
  
  predicate postcondition_once'2 (self: ()) (args: tuple'0) (result: t_T) =
    [%#slocal_invariant'4] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { _p0'1 = new_logic this; _p1'1 = tokens; _p2'0 = f } result)
    /\ inv'28 result
  
  predicate resolve'5 (_0'0: ()) = true
  
  predicate postcondition_mut'1 (self: ()) (args: tuple'0) (result_state: ()) (result: t_T) =
    [%#slocal_invariant'4] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { _p0'1 = new_logic this; _p1'1 = tokens; _p2'0 = f } result)
    /\ inv'28 result
  
  function fn_mut_once'1 (self: ()) (args: tuple'0) (res: t_T) : ()
  
  axiom fn_mut_once_spec'1: forall self: (), args: tuple'0, res: t_T. [%#sops'8] postcondition_once'2 self args res
      = (exists res_state: (). postcondition_mut'1 self args res_state res /\ resolve'5 res_state)
  
  predicate hist_inv'1 (self: ()) (result_state: ()) = true
  
  function hist_inv_trans'1 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'1: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'1 self b)
      -> ([%#sops'6] hist_inv'1 b c) -> ([%#sops'7] hist_inv'1 self c)
  
  function hist_inv_refl'1 (self: ()) : ()
  
  axiom hist_inv_refl_spec'1: forall self: (). [%#sops'4] hist_inv'1 self self
  
  function postcondition_mut_hist_inv'1 (self: ()) (args: tuple'0) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'1:
    forall self: (), args: tuple'0, res_state: (), res: t_T. ([%#sops'2] postcondition_mut'1 self args res_state res)
      -> ([%#sops'3] hist_inv'1 self res_state)
  
  function fn_hist_inv'1 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'1: forall self: (), res_state: (). [%#sops'1] hist_inv'1 self res_state = (self = res_state)
  
  predicate postcondition'1 (self: ()) (args: tuple'0) (result: t_T) =
    [%#slocal_invariant'4] let {_p0'0 = self'0; _p1'0 = tokens; _p2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { _p0'1 = new_logic this; _p1'1 = tokens; _p2'0 = f } result)
    /\ inv'28 result
  
  function fn_once'1 (self: ()) (args: tuple'0) (res: t_T) : ()
  
  axiom fn_once_spec'1: forall self: (), args: tuple'0, res: t_T. [%#sops'0] postcondition_once'2 self args res
      = (postcondition'1 self args res /\ resolve'5 self)
  
  function fn_mut'1 (self: ()) (args: tuple'0) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec'1:
    forall self: (), args: tuple'0, res_state: (), res: t_T. [%#sops] postcondition_mut'1 self args res_state res
      = (postcondition'1 self args res /\ self = res_state)
  
  let rec open'1 (self: t_Rc) (tokens: t_Tokens) (f: closure0) (return' (x: t_T)) =
    {[@expl:open 'f' type invariant] [%#slocal_invariant] inv'32 f}
    {[@expl:open requires] [%#slocal_invariant'0] precondition'2 () { _p0'0 = new_logic'0 self;
                                                                      _p1'0 = tokens;
                                                                      _p2 = f }}
    any
    [ return''0 (result: t_T) -> {[%#slocal_invariant'1] inv'28 result}
      {[%#slocal_invariant'2] postcondition'1 () { _p0'0 = new_logic'0 self; _p1'0 = tokens; _p2 = f } result}
      (! return' {result}) ]
  
  function view'17 [#"persistent_array.rs" 77 8 77 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'16] (view'16 self.t_PersistentArray__frag)._p1
  
  function view'18 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'17 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get'1 [#"persistent_array.rs" 231 8 231 89] (self: t_PersistentArray) (index: UInt64.t) (tokens: t_Tokens)
    (return' (x: t_T)) = {[@expl:get 'self' type invariant] [%#spersistent_array'0] inv'30 self}
    {[@expl:get requires #0] [%#spersistent_array'1] contains'3 tokens (Namespace_PARRAY 0)}
    {[@expl:get requires #1] [%#spersistent_array'2] UInt64.t'int index < Seq.length (view'18 self)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &auth_id <- [%#spersistent_array] public (view'0 self'0.t_PersistentArray__inv) ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_12 <- { _0 = self'0; _1 = auth_id; _2 = index'0 } ] s1
      | s1 = open'1 {self'0.t_PersistentArray__inv} {tokens'0} {_12} (fun (_ret: t_T) -> [ &_9 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0'0 <- _9 ] s1 | s1 = return''0 {_0'0} ] ]
    [ & _0'0: t_T = Any.any_l ()
    | & self'0: t_PersistentArray = self
    | & index'0: UInt64.t = index
    | & tokens'0: t_Tokens = tokens
    | & auth_id: t_Id = Any.any_l ()
    | & _9: t_T = Any.any_l ()
    | & _12: closure0 = Any.any_l () ])
    [ return''0 (result: t_T) -> {[@expl:get result type invariant] [%#spersistent_array'3] inv'28 result}
      {[@expl:get ensures] [%#spersistent_array'4] result = Seq.get (view'18 self) (UInt64.t'int index)}
      (! return' {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__reroot [#"persistent_array.rs" 262 8 262 97] (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span src = "../../creusot-contracts/src/std/rc.rs" 51 18 51 38
  let%span src'0 = "../../creusot-contracts/src/std/rc.rs" 45 18 45 33
  let%span spersistent_array = "persistent_array.rs" 293 28 293 102
  let%span spersistent_array'0 = "persistent_array.rs" 294 27 294 69
  let%span spersistent_array'1 = "persistent_array.rs" 262 75 262 77
  let%span spersistent_array'2 = "persistent_array.rs" 248 8 248 51
  let%span spersistent_array'3 = "persistent_array.rs" 249 19 249 47
  let%span spersistent_array'4 = "persistent_array.rs" 250 19 251 37
  let%span spersistent_array'5 = "persistent_array.rs" 253 18 253 51
  let%span spersistent_array'6 = "persistent_array.rs" 254 18 254 39
  let%span spersistent_array'7 = "persistent_array.rs" 255 18 256 86
  let%span spersistent_array'8 = "persistent_array.rs" 257 18 257 78
  let%span spersistent_array'9 = "persistent_array.rs" 258 18 261 9
  let%span spersistent_array'10 = "persistent_array.rs" 111 16 123 21
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 89 22 89 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 89 4 89 48
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 88 14 88 35
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 183 15 183 16
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 183 4 185 17
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 205 22 205 26
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 205 4 207 17
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 203 14 203 29
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sghost'10 = "../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'11 = "../../creusot-contracts/src/ghost.rs" 127 8 127 22
  let%span sghost'12 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 63 8 63 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 106 20 106 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 185 16 185 17
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 186 16 186 48
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 187 16 187 56
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 188 16 188 59
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 189 16 189 64
  let%span svec'4 = "../../creusot-contracts/src/std/vec.rs" 190 26 190 55
  let%span svec'5 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'6 = "../../creusot-contracts/src/std/vec.rs" 99 20 99 41
  let%span spermcell = "../../creusot-contracts/src/cell/permcell.rs" 231 14 231 34
  let%span spermcell'0 = "../../creusot-contracts/src/cell/permcell.rs" 195 43 195 47
  let%span spermcell'1 = "../../creusot-contracts/src/cell/permcell.rs" 191 15 191 37
  let%span spermcell'2 = "../../creusot-contracts/src/cell/permcell.rs" 195 4 195 92
  let%span spermcell'3 = "../../creusot-contracts/src/cell/permcell.rs" 192 14 192 39
  let%span spermcell'4 = "../../creusot-contracts/src/cell/permcell.rs" 193 14 193 30
  let%span spermcell'5 = "../../creusot-contracts/src/cell/permcell.rs" 194 14 194 33
  let%span spermcell'6 = "../../creusot-contracts/src/cell/permcell.rs" 34 4 34 12
  let%span spermcell'7 = "../../creusot-contracts/src/cell/permcell.rs" 62 20 62 46
  let%span spermcell'8 = "../../creusot-contracts/src/cell/permcell.rs" 45 8 45 27
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 470 29 470 33
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 470 4 470 56
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 468 14 468 43
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 469 14 469 41
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 445 29 445 33
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 445 43 445 48
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 445 4 445 65
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 443 14 443 49
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 444 14 444 40
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 387 30 387 34
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 387 4 387 62
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 376 14 384 9
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 385 14 385 73
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 386 14 386 44
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 85 14 85 43
  let%span sfmap'17 = "../../creusot-contracts/src/logic/fmap.rs" 86 14 86 84
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'19 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'20 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'21 = "../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'22 = "../../creusot-contracts/src/logic/fmap.rs" 514 20 514 76
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 145 16 145 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 146 27 146 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 147 26 147 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 775 8 778 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 685 20 685 91
  let%span slogic = "../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 118 20 118 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 125 20 125 37
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 132 20 132 88
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Id
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  type t_PermCellOwn
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = [%#sfmap'14] Map.get (view self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = [%#sfmap'13] get self k <> C_None
  
  predicate inv (_0: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  predicate inv'0 (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'0 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'5] Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = [%#svec'6] inv'2 (view'0 self)
  
  predicate inv'3 (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 (self: t_Inner) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_0: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 (self: t_PermCellOwn) = [%#spermcell'7] inv'5 (val' self)
  
  predicate inv'6 (_0: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. ([%#slogic] exists x: t_PermCellOwn. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = [%#soption'4] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = [%#sfmap'21] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = [%#sfmap'15] lookup self key
  
  predicate invariant''4 (self: t_FMap) =
    [%#sfmap'22] forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_0: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_0: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'7 perms /\ inv'8 auth
        end
  
  predicate invariant''6 (self: MutBorrow.t t_PA) = [%#sinvariant] inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 (self: MutBorrow.t t_PA) = [%#sghost'12] inv'10 self
  
  predicate inv'11 (_0: MutBorrow.t t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant] inv'11 self.current /\ inv'11 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 (self: MutBorrow.t (MutBorrow.t t_PA)) =
    [%#sinvariant] inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_0: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return' (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'12 self}
    any
    [ return''0 (result: MutBorrow.t (MutBorrow.t t_PA)) -> {[%#sghost'0] inv'13 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  type t_PermCell
  
  function view'1 (self: t_Rc) : t_PermCell
  
  let rec deref (self_: t_Rc) (return' (x: t_PermCell)) = any
    [ return''0 (result: t_PermCell) -> {[%#src] result = view'1 self_} (! return' {result}) ]
  
  function id (self: t_PermCell) : t_Id
  
  let rec id_ghost (self: t_PermCell) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#spermcell] result = id self} (! return' {result}) ]
  
  let rec deref'0 (self: t_Id) (return' (x: t_Id)) = any
    [ return''0 (result: t_Id) -> {[%#sghost'2] result = self} (! return' {result}) ]
  
  predicate invariant''10 (self: MutBorrow.t t_FMap) = [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'14 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'14 x]. inv'14 x = invariant''10 x
  
  predicate inv'15 (_0: t_Option)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Option [inv'15 x]. inv'15 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'6 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'20] len self >= 0
  
  function remove (self: t_FMap) (k: t_Id) : t_FMap
  
  axiom remove_spec: forall self: t_FMap, k: t_Id. [%#sfmap'16] view (remove self k) = Map.set (view self) k (C_None)
  
  axiom remove_spec'0: forall self: t_FMap, k: t_Id. [%#sfmap'17] len (remove self k)
      = (if contains self k then len self - 1 else len self)
  
  let rec remove_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return' (x: t_Option)) =
    {[@expl:remove_ghost 'self' type invariant] [%#sfmap] inv'14 self}
    any
    [ return''0 (result: t_Option) -> {[%#sfmap'0] inv'15 result}
      {[%#sfmap'1] self.final = remove self.current key}
      {[%#sfmap'2] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t (MutBorrow.t t_PA)) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0: MutBorrow.t (MutBorrow.t t_PA)) = resolve _0
  
  let rec unwrap (self_: t_Option) (return' (x: t_PermCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'15 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None}
    any
    [ return''0 (result: t_PermCellOwn) -> {inv'6 result} {[%#soption'1] C_Some result = self_} (! return' {result}) ]
  
  predicate invariant''11 (self: t_PermCellOwn) = [%#sghost'12] inv'6 self
  
  predicate inv'16 (_0: t_PermCellOwn)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_PermCellOwn [inv'16 x]. inv'16 x = invariant''11 x
  
  let rec new (x: t_PermCellOwn) (return' (x'0: t_PermCellOwn)) = {[@expl:new 'x' type invariant] [%#sghost'3] inv'6 x}
    any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost'4] inv'16 result} {[%#sghost'5] result = x} (! return' {result}) ]
  
  predicate invariant''12 (self: MutBorrow.t t_PermCellOwn) = [%#sinvariant] inv'16 self.current /\ inv'16 self.final
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'17 (_0: MutBorrow.t t_PermCellOwn)
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t t_PermCellOwn [inv'17 x]. inv'17 x = invariant''12 x
  
  predicate invariant''13 (self: MutBorrow.t t_PermCellOwn) = [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'18 (_0: MutBorrow.t t_PermCellOwn)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_PermCellOwn [inv'18 x]. inv'18 x = invariant''13 x
  
  let rec deref_mut'0 (self: MutBorrow.t t_PermCellOwn) (return' (x: MutBorrow.t t_PermCellOwn)) =
    {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'17 self}
    any
    [ return''0 (result: MutBorrow.t t_PermCellOwn) -> {[%#sghost'0] inv'18 result}
      {[%#sghost'1] result = self}
      (! return' {result}) ]
  
  predicate resolve'1 (self: MutBorrow.t t_PermCellOwn) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (_0: MutBorrow.t t_PermCellOwn) = resolve'1 _0
  
  predicate resolve'3 (self: MutBorrow.t t_PermCellOwn) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 (_0: MutBorrow.t t_PermCellOwn) = resolve'3 _0
  
  predicate invariant''14 (self: MutBorrow.t t_PermCellOwn) = [%#sghost'12] inv'18 self
  
  predicate inv'19 (_0: MutBorrow.t t_PermCellOwn)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_PermCellOwn [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec new'0 (x: MutBorrow.t t_PermCellOwn) (return' (x'0: MutBorrow.t t_PermCellOwn)) =
    {[@expl:new 'x' type invariant] [%#sghost'3] inv'18 x}
    any
    [ return''0 (result: MutBorrow.t t_PermCellOwn) -> {[%#sghost'4] inv'19 result}
      {[%#sghost'5] result = x}
      (! return' {result}) ]
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  predicate invariant''15 (self: MutBorrow.t t_Inner) = [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'20 (_0: MutBorrow.t t_Inner)
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t t_Inner [inv'20 x]. inv'20 x = invariant''15 x
  
  function fin (self: MutBorrow.t t_PermCellOwn) : t_PermCellOwn = [%#sghost'9] self.final
  
  function view'2 (self: t_PermCellOwn) : t_Inner = [%#spermcell'6] val' self
  
  function view'3 (self: MutBorrow.t t_PermCellOwn) : t_Inner = [%#smodel'0] view'2 self.current
  
  function view'4 (self: MutBorrow.t t_PermCellOwn) : t_Inner = [%#sghost'10] view'3 self
  
  let rec borrow_mut (self: t_PermCell) (perm: MutBorrow.t t_PermCellOwn) (return' (x: MutBorrow.t t_Inner)) =
    {[@expl:borrow_mut 'perm' type invariant] [%#spermcell'0] inv'19 perm}
    {[@expl:borrow_mut requires] [%#spermcell'1] id self = id'0 perm.current}
    any
    [ return''0 (result: MutBorrow.t t_Inner) -> {[%#spermcell'2] inv'20 result}
      {[%#spermcell'3] id self = id'0 (fin perm)}
      {[%#spermcell'4] result.current = view'4 perm}
      {[%#spermcell'5] result.final = view'2 (fin perm)}
      (! return' {result}) ]
  
  predicate resolve'5 (self: MutBorrow.t t_Inner) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 (_0: MutBorrow.t t_Inner) = resolve'5 _0
  
  let rec into_inner (self: t_PermCellOwn) (return' (x: t_PermCellOwn)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost'6] inv'16 self}
    any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost'7] inv'6 result}
      {[%#sghost'8] result = self}
      (! return' {result}) ]
  
  function insert (self: t_FMap) (k: t_Id) (v: t_PermCellOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: t_PermCellOwn. [%#sfmap'18] view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: t_PermCellOwn. [%#sfmap'19] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (value: t_PermCellOwn) (return' (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'3] inv'14 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'4] inv'6 value}
    any
    [ return''0 (result: t_Option) -> {[%#sfmap'5] inv'15 result}
      {[%#sfmap'6] self.final = insert self.current key value}
      {[%#sfmap'7] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve'7 (self: MutBorrow.t t_PA) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 (_0: MutBorrow.t t_PA) = resolve'7 _0
  
  predicate resolve'9 (self: MutBorrow.t t_PA) = [%#sghost'11] resolve'8 self
  
  predicate resolve'10 (_0: MutBorrow.t t_PA) = resolve'9 _0
  
  predicate invariant''16 (self: t_Option) = [%#sghost'12] inv'15 self
  
  predicate inv'21 (_0: t_Option)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Option [inv'21 x]. inv'21 x = invariant''16 x
  
  let rec new'1 (x: t_Option) (return' (x'0: t_Option)) = {[@expl:new 'x' type invariant] [%#sghost'3] inv'15 x}
    any [ return''0 (result: t_Option) -> {[%#sghost'4] inv'21 result} {[%#sghost'5] result = x} (! return' {result}) ]
  
  predicate resolve'11 (_0: t_Inner) = true
  
  predicate resolve'12 (self: t_PermCellOwn) = [%#spermcell'8] resolve'11 (val' self)
  
  predicate resolve'13 (_0: t_PermCellOwn) = resolve'12 _0
  
  predicate resolve'14 (self: t_Option) =
    [%#soption'2] match self with
      | C_Some x -> resolve'13 x
      | C_None -> true
      end
  
  predicate resolve'15 (_0: t_Option) = resolve'14 _0
  
  predicate resolve'16 (self: t_Option) = [%#sghost'11] resolve'15 self
  
  predicate resolve'17 (_0: t_Option) = resolve'16 _0
  
  let rec v_Link (input: t_Inner) (ret (index: UInt64.t) (value: t_T) (next: t_Rc)) = any
    [ good (index: UInt64.t) (value: t_T) (next: t_Rc) -> {C_Link index value next = input}
      (! ret {index} {value} {next})
    | bad -> {forall index: UInt64.t, value: t_T, next: t_Rc [C_Link index value next: t_Inner]. C_Link index value next
        <> input}
      (! {false}
      any) ]
  
  let rec new'2 (x: MutBorrow.t t_PA) (return' (x'0: MutBorrow.t t_PA)) =
    {[@expl:new 'x' type invariant] [%#sghost'3] inv'10 x}
    any
    [ return''0 (result: MutBorrow.t t_PA) -> {[%#sghost'4] inv'11 result}
      {[%#sghost'5] result = x}
      (! return' {result}) ]
  
  let rec clone' (self_: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src'0] result = self_} (! return' {result}) ]
  
  let rec replace (dest: MutBorrow.t t_Rc) (src: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#smem] dest.final = src} {[%#smem'0] result = dest.current} (! return' {result}) ]
  
  predicate resolve'18 (self: MutBorrow.t t_Rc) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'18
  
  predicate resolve'19 (_0: MutBorrow.t t_Rc) = resolve'18 _0
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_PermCellOwn)
  
  predicate inv'22 (_0: t_Option'0)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_Option'0 [inv'22 x]. inv'22 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'18 a_0
        end
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return' (x: t_Option'0)) =
    {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'8] inv'14 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'9] inv'22 result}
      {[%#sfmap'10] if contains self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap'11] forall k: t_Id. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'12] len self.current = len self.final}
      (! return' {result}) ]
  
  let rec unwrap'0 (self_: t_Option'0) (return' (x: MutBorrow.t t_PermCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'22 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_PermCellOwn) -> {inv'18 result}
      {[%#soption'1] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate resolve'20 (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'20
  
  predicate resolve'21 (_0: MutBorrow.t UInt64.t) = resolve'20 _0
  
  predicate invariant''17 (self: MutBorrow.t t_T) = [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'23 (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_T [inv'23 x]. inv'23 x = invariant''17 x
  
  predicate resolve'22 (self: MutBorrow.t t_T) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'22
  
  predicate resolve'23 (_0: MutBorrow.t t_T) = resolve'22 _0
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate invariant''18 (self: MutBorrow.t t_Vec) = [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'24 (_0: MutBorrow.t t_Vec)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_Vec [inv'24 x]. inv'24 x = invariant''18 x
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  function view'5 (self: MutBorrow.t t_Vec) : Seq.seq t_T = [%#smodel'0] view'0 self.current
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_T) (fin'0: Seq.seq t_T) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
      -> Seq.get old' i = Seq.get fin'0 i
  
  let rec index_mut (self_: MutBorrow.t t_Vec) (ix: UInt64.t) (return' (x: MutBorrow.t t_T)) =
    {[@expl:index_mut 'self_' type invariant] [%#svec] inv'24 self_}
    {[@expl:index_mut requires] [%#svec'0] in_bounds ix (view'5 self_)}
    any
    [ return''0 (result: MutBorrow.t t_T) -> {inv'23 result}
      {[%#svec'1] has_value ix (view'5 self_) result.current}
      {[%#svec'2] has_value ix (view'0 self_.final) result.final}
      {[%#svec'3] resolve_elswhere ix (view'5 self_) (view'0 self_.final)}
      {[%#svec'4] Seq.length (view'0 self_.final) = Seq.length (view'5 self_)}
      (! return' {result}) ]
  
  let rec swap (x: MutBorrow.t t_T) (y: MutBorrow.t t_T) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem'1] inv'23 x}
    {[@expl:swap 'y' type invariant] [%#smem'2] inv'23 y}
    any
    [ return''0 (result: ()) -> {[%#smem'3] x.final = y.current} {[%#smem'4] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'24 (self: MutBorrow.t t_Vec) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'24
  
  predicate resolve'25 (_0: MutBorrow.t t_Vec) = resolve'24 _0
  
  let rec swap'0 (x: MutBorrow.t t_Inner) (y: MutBorrow.t t_Inner) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem'1] inv'20 x}
    {[@expl:swap 'y' type invariant] [%#smem'2] inv'20 y}
    any
    [ return''0 (result: ()) -> {[%#smem'3] x.final = y.current} {[%#smem'4] y.final = x.current} (! return' {result}) ]
  
  function view'6 (self: t_Rc) : t_PermCell = [%#smodel] view'1 self
  
  let rec new'3 (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'5] result = x} (! return' {result}) ]
  
  function id'1 (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'1 = C_None'1 | C_Some'1 (Seq.seq t_T)
  
  function view'7 (self: t_FMap'0) : Map.map t_Id t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'1 = [%#sfmap'14] Map.get (view'7 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = [%#sfmap'13] get'0 self k <> C_None'1
  
  function view'8 (self: t_Authority) : t_FMap'0
  
  predicate index_logic'1 (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. ([%#slogic] exists x: Seq.seq t_T. index_logic'1 p x)
      -> ([%#slogic'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'1) : Seq.seq t_T = [%#soption'4] match self with
      | C_Some'1 x -> x
      | C_None'1 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T =
    [%#sfmap'21] unwrap_logic'0 (get'0 self k)
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = [%#sfmap'15] lookup'0 self key
  
  function view'9 (self: t_Vec) : Seq.seq t_T = [%#smodel] view'0 self
  
  function index_logic'3 (self: Map.map t_Id int) (a: t_Id) : int = [%#smapping] Map.get self a
  
  function view'10 (self: UInt64.t) : int = [%#smodel] UInt64.t'int self
  
  predicate partial_invariant [#"persistent_array.rs" 109 8 109 59] (self: t_PA) (resource_id: t_Id) =
    [%#spersistent_array'10] id'1 self.t_PA__auth = resource_id
    /\ (forall id'2: t_Id. contains'0 (view'8 self.t_PA__auth) id'2 /\ contains self.t_PA__perms id'2
      -> id'0 (index_logic'0 self.t_PA__perms id'2) = id'2
      /\ match val' (index_logic'0 self.t_PA__perms id'2) with
        | C_Direct v -> index_logic'2 (view'8 self.t_PA__auth) id'2 = view'9 v
        | C_Link index value next -> contains'0 (view'8 self.t_PA__auth) (id (view'6 next))
        /\ index_logic'3 self.t_PA__depth id'2 > index_logic'3 self.t_PA__depth (id (view'6 next))
        /\ view'10 index < Seq.length (index_logic'2 (view'8 self.t_PA__auth) (id (view'6 next)))
        /\ index_logic'2 (view'8 self.t_PA__auth) id'2
        = Seq.set (index_logic'2 (view'8 self.t_PA__auth) (id (view'6 next))) (view'10 index) value
        end)
  
  function fin'0 (self: MutBorrow.t t_PA) : t_PA = [%#sghost'9] self.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec reroot [#"persistent_array.rs" 262 8 262 97] (cur: t_Rc) (auth_id: t_Id) (pa: MutBorrow.t t_PA)
    (return' (x: ())) = {[@expl:reroot 'pa' type invariant] [%#spersistent_array'1] inv'11 pa}
    {[@expl:reroot requires #0] [%#spersistent_array'2] partial_invariant pa.current auth_id}
    {[@expl:reroot requires #1] [%#spersistent_array'3] contains'0 (view'8 (pa.current).t_PA__auth) (id (view'6 cur))}
    {[@expl:reroot requires #2] [%#spersistent_array'4] forall id'2: t_Id. contains'0 (view'8 (pa.current).t_PA__auth) id'2
        /\ index_logic'3 (pa.current).t_PA__depth id'2 <= index_logic'3 (pa.current).t_PA__depth (id (view'6 cur))
      -> contains (pa.current).t_PA__perms id'2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'11 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_17 <- _ret ] -{inv'11 _ret.final}-
            [ &pa'0 <- _ret.final ] s1)
      | s1 = deref_mut {_17} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_16 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = deref {cur'0} (fun (_ret: t_PermCell) -> [ &_24 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = id_ghost {_24} (fun (_ret: t_Id) -> [ &_22 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_21 <- _22 ] s1 | s1 = deref'0 {_21} (fun (_ret: t_Id) -> [ &_19 <- _ret ] s2) | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv'7 ((_16.current).current).t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {((_16.current).current).t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_15 <- _ret ] -{inv'7 _ret.final}-
            [ &_16 <- { _16 with current = { _16.current with current = { (_16.current).current with t_PA__perms = _ret.final } } } ]
            s1)
      | s1 = remove_ghost {_15} {_19} (fun (_ret: t_Option) -> [ &_14 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'13 _16} s1
      | s1 = -{resolve'0 _16}- s2
      | s2 = unwrap {_14} (fun (_ret: t_PermCellOwn) -> [ &_13 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = new {_13} (fun (_ret: t_PermCellOwn) -> [ &perm_cur <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = deref {cur'0} (fun (_ret: t_PermCell) -> [ &_29 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0
      [ s0 = {inv'16 perm_cur}
        MutBorrow.borrow_mut <t_PermCellOwn> {perm_cur}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_36 <- _ret ] -{inv'16 _ret.final}-
            [ &perm_cur <- _ret.final ] s1)
      | s1 = {inv'16 _36.current}
        MutBorrow.borrow_final <t_PermCellOwn> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_35 <- _ret ] -{inv'16 _ret.final}-
            [ &_36 <- { _36 with current = _ret.final } ] s2)
      | s2 = deref_mut'0 {_35} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_34 <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0
      [ s0 = {inv'6 _34.current}
        MutBorrow.borrow_final <t_PermCellOwn> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_33 <- _ret ] -{inv'6 _ret.final}-
            [ &_34 <- { _34 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'17 _36} s2
      | s2 = -{resolve'2 _36}- s3
      | s3 = {[@expl:type invariant] inv'18 _34} s4
      | s4 = -{resolve'4 _34}- s5
      | s5 = {inv'6 _33.current}
        MutBorrow.borrow_final <t_PermCellOwn> {_33.current} {MutBorrow.get_id _33}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_32 <- _ret ] -{inv'6 _ret.final}-
            [ &_33 <- { _33 with current = _ret.final } ] s6)
      | s6 = new'0 {_32} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_31 <- _ret ] s7)
      | s7 = bb10 ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'18 _33} s1
      | s1 = -{resolve'4 _33}- s2
      | s2 = borrow_mut {_29} {_31} (fun (_ret: MutBorrow.t t_Inner) -> [ &_27 <- _ret ] s3)
      | s3 = bb11 ]
    | bb11 = s0
      [ s0 = {inv'4 _27.current}
        MutBorrow.borrow_final <t_Inner> {_27.current} {MutBorrow.get_id _27}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &bor_cur <- _ret ] -{inv'4 _ret.final}-
            [ &_27 <- { _27 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'20 _27} s2
      | s2 = -{resolve'6 _27}- s3
      | s3 = any
        [ br0 (x0: t_Vec) -> {bor_cur.current = C_Direct x0} (! bb12)
        | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {bor_cur.current = C_Link x0 x1 x2} (! bb21) ] ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'20 bor_cur} s1
      | s1 = -{resolve'6 bor_cur}- s2
      | s2 = {inv'11 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_42 <- _ret ] -{inv'11 _ret.final}-
            [ &pa'0 <- _ret.final ] s3)
      | s3 = deref_mut {_42} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_41 <- _ret ] s4)
      | s4 = bb13 ]
    | bb13 = s0 [ s0 = deref {cur'0} (fun (_ret: t_PermCell) -> [ &_48 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0 [ s0 = id_ghost {_48} (fun (_ret: t_Id) -> [ &_46 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = deref'0 {_46} (fun (_ret: t_Id) -> [ &_44 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = s0 [ s0 = into_inner {perm_cur} (fun (_ret: t_PermCellOwn) -> [ &_50 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = {inv'7 ((_41.current).current).t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {((_41.current).current).t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_40 <- _ret ] -{inv'7 _ret.final}-
            [ &_41 <- { _41 with current = { _41.current with current = { (_41.current).current with t_PA__perms = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_40} {_44} {_50} (fun (_ret: t_Option) -> [ &_39 <- _ret ] s2)
      | s2 = bb18 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'13 _41} s1
      | s1 = -{resolve'0 _41}- s2
      | s2 = {[@expl:type invariant] inv'11 pa'0} s3
      | s3 = -{resolve'10 pa'0}- s4
      | s4 = new'1 {_39} (fun (_ret: t_Option) -> [ &_38 <- _ret ] s5)
      | s5 = {[@expl:type invariant] inv'21 _38} s6
      | s6 = -{resolve'17 _38}- s7
      | s7 = bb53 ]
    | bb21 = s0
      [ s0 = v_Link {bor_cur.current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            MutBorrow.borrow_mut <t_Rc> {rnext}
              (fun (_ret: MutBorrow.t t_Rc) ->
                [ &next <- _ret ] [ &bor_cur <- { bor_cur with current = C_Link rindex rvalue _ret.final } ] s1))
      | s1 = v_Link {bor_cur.current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            {inv'0 rvalue}
            MutBorrow.borrow_mut <t_T> {rvalue}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &value <- _ret ] -{inv'0 _ret.final}-
                [ &bor_cur <- { bor_cur with current = C_Link rindex _ret.final rnext } ] s2))
      | s2 = v_Link {bor_cur.current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            MutBorrow.borrow_mut <UInt64.t> {rindex}
              (fun (_ret: MutBorrow.t UInt64.t) ->
                [ &index <- _ret ] [ &bor_cur <- { bor_cur with current = C_Link _ret.final rvalue rnext } ] s3))
      | s3 = [ &_58 <- next ] s4
      | s4 = {inv'11 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_65 <- _ret ] -{inv'11 _ret.final}-
            [ &pa'0 <- _ret.final ] s5)
      | s5 = deref_mut {_65} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_64 <- _ret ] s6)
      | s6 = bb22 ]
    | bb22 = s0
      [ s0 = {inv'10 _64.current}
        MutBorrow.borrow_final <MutBorrow.t t_PA> {_64.current} {MutBorrow.get_id _64}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_63 <- _ret ] -{inv'10 _ret.final}-
            [ &_64 <- { _64 with current = _ret.final } ] s1)
      | s1 = {inv'9 (_63.current).current}
        MutBorrow.borrow_mut <t_PA> {(_63.current).current}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_62 <- _ret ] -{inv'9 _ret.final}-
            [ &_63 <- { _63 with current = { _63.current with current = _ret.final } } ] s2)
      | s2 = {[@expl:type invariant] inv'13 _64} s3
      | s3 = -{resolve'0 _64}- s4
      | s4 = {[@expl:type invariant] inv'13 _63} s5
      | s5 = -{resolve'0 _63}- s6
      | s6 = {inv'9 _62.current}
        MutBorrow.borrow_final <t_PA> {_62.current} {MutBorrow.get_id _62}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_61 <- _ret ] -{inv'9 _ret.final}-
            [ &_62 <- { _62 with current = _ret.final } ] s7)
      | s7 = new'2 {_61} (fun (_ret: MutBorrow.t t_PA) -> [ &_60 <- _ret ] s8)
      | s8 = bb23 ]
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'10 _62} s1
      | s1 = -{resolve'8 _62}- s2
      | s2 = reroot {_58.current} {auth_id'0} {_60} (fun (_ret: ()) -> [ &_56 <- _ret ] s3)
      | s3 = bb24 ]
    | bb24 = s0 [ s0 = clone' {cur'0} (fun (_ret: t_Rc) -> [ &_68 <- _ret ] s1) | s1 = bb25 ]
    | bb25 = s0
      [ s0 = MutBorrow.borrow_final <t_Rc> {next.current} {MutBorrow.get_id next}
          (fun (_ret: MutBorrow.t t_Rc) -> [ &_67 <- _ret ] [ &next <- { next with current = _ret.final } ] s1)
      | s1 = replace {_67} {_68} (fun (_ret: t_Rc) -> [ &next'0 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = s0
      [ s0 = -{resolve'19 next}- s1
      | s1 = {inv'11 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_76 <- _ret ] -{inv'11 _ret.final}-
            [ &pa'0 <- _ret.final ] s2)
      | s2 = deref_mut {_76} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_75 <- _ret ] s3)
      | s3 = bb27 ]
    | bb27 = s0 [ s0 = deref {next'0} (fun (_ret: t_PermCell) -> [ &_83 <- _ret ] s1) | s1 = bb28 ]
    | bb28 = s0 [ s0 = id_ghost {_83} (fun (_ret: t_Id) -> [ &_81 <- _ret ] s1) | s1 = bb29 ]
    | bb29 = s0 [ s0 = deref'0 {_81} (fun (_ret: t_Id) -> [ &_79 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0
      [ s0 = [ &_78 <- _79 ] s1
      | s1 = {inv'7 ((_75.current).current).t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {((_75.current).current).t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_74 <- _ret ] -{inv'7 _ret.final}-
            [ &_75 <- { _75 with current = { _75.current with current = { (_75.current).current with t_PA__perms = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_74} {_78} (fun (_ret: t_Option'0) -> [ &_73 <- _ret ] s3)
      | s3 = bb31 ]
    | bb31 = s0 [ s0 = unwrap'0 {_73} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_72 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0
      [ s0 = {[@expl:type invariant] inv'13 _75} s1
      | s1 = -{resolve'0 _75}- s2
      | s2 = {inv'6 _72.current}
        MutBorrow.borrow_final <t_PermCellOwn> {_72.current} {MutBorrow.get_id _72}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_71 <- _ret ] -{inv'6 _ret.final}-
            [ &_72 <- { _72 with current = _ret.final } ] s3)
      | s3 = new'0 {_71} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &perm_next <- _ret ] s4)
      | s4 = bb33 ]
    | bb33 = s0
      [ s0 = {[@expl:type invariant] inv'18 _72} s1
      | s1 = -{resolve'4 _72}- s2
      | s2 = deref {next'0} (fun (_ret: t_PermCell) -> [ &_88 <- _ret ] s3)
      | s3 = bb34 ]
    | bb34 = s0
      [ s0 = borrow_mut {_88} {perm_next} (fun (_ret: MutBorrow.t t_Inner) -> [ &_86 <- _ret ] s1) | s1 = bb35 ]
    | bb35 = s0
      [ s0 = {inv'4 _86.current}
        MutBorrow.borrow_final <t_Inner> {_86.current} {MutBorrow.get_id _86}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &bor_next <- _ret ] -{inv'4 _ret.final}-
            [ &_86 <- { _86 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'20 _86} s2
      | s2 = -{resolve'6 _86}- s3
      | s3 = any
        [ br0 (x0: t_Vec) -> {bor_next.current = C_Direct x0} (! bb38)
        | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {bor_next.current = C_Link x0 x1 x2} (! bb36) ] ]
    | bb36 = s0
      [ s0 = {[@expl:type invariant] inv'20 bor_next} s1
      | s1 = -{resolve'6 bor_next}- s2
      | s2 = -{resolve'21 index}- s3
      | s3 = {[@expl:type invariant] inv'23 value} s4
      | s4 = -{resolve'23 value}- s5
      | s5 = {false} any ]
    | bb38 = s0
      [ s0 = v_Direct {bor_next.current}
          (fun (r0: t_Vec) ->
            {inv'3 r0}
            MutBorrow.borrow_mut <t_Vec> {r0}
              (fun (_ret: MutBorrow.t t_Vec) ->
                [ &arr <- _ret ] -{inv'3 _ret.final}-
                [ &bor_next <- { bor_next with current = C_Direct _ret.final } ] s1))
      | s1 = {inv'3 arr.current}
        MutBorrow.borrow_final <t_Vec> {arr.current} {MutBorrow.get_id arr}
          (fun (_ret: MutBorrow.t t_Vec) ->
            [ &_98 <- _ret ] -{inv'3 _ret.final}-
            [ &arr <- { arr with current = _ret.final } ] s2)
      | s2 = -{resolve'21 index}- s3
      | s3 = index_mut {_98} {index.current} (fun (_ret: MutBorrow.t t_T) -> [ &_97 <- _ret ] s4)
      | s4 = bb39 ]
    | bb39 = s0
      [ s0 = {inv'0 _97.current}
        MutBorrow.borrow_final <t_T> {_97.current} {MutBorrow.get_id _97}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_96 <- _ret ] -{inv'0 _ret.final}-
            [ &_97 <- { _97 with current = _ret.final } ] s1)
      | s1 = {inv'0 _96.current}
        MutBorrow.borrow_final <t_T> {_96.current} {MutBorrow.get_id _96}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_95 <- _ret ] -{inv'0 _ret.final}-
            [ &_96 <- { _96 with current = _ret.final } ] s2)
      | s2 = {inv'0 value.current}
        MutBorrow.borrow_final <t_T> {value.current} {MutBorrow.get_id value}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_100 <- _ret ] -{inv'0 _ret.final}-
            [ &value <- { value with current = _ret.final } ] s3)
      | s3 = swap {_95} {_100} (fun (_ret: ()) -> [ &_94 <- _ret ] s4)
      | s4 = bb40 ]
    | bb40 = s0
      [ s0 = {[@expl:type invariant] inv'23 _97} s1
      | s1 = -{resolve'23 _97}- s2
      | s2 = {[@expl:type invariant] inv'23 _96} s3
      | s3 = -{resolve'23 _96}- s4
      | s4 = {[@expl:type invariant] inv'24 arr} s5
      | s5 = -{resolve'25 arr}- s6
      | s6 = {[@expl:type invariant] inv'23 value} s7
      | s7 = -{resolve'23 value}- s8
      | s8 = {inv'4 bor_next.current}
        MutBorrow.borrow_final <t_Inner> {bor_next.current} {MutBorrow.get_id bor_next}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &_102 <- _ret ] -{inv'4 _ret.final}-
            [ &bor_next <- { bor_next with current = _ret.final } ] s9)
      | s9 = {inv'4 bor_cur.current}
        MutBorrow.borrow_final <t_Inner> {bor_cur.current} {MutBorrow.get_id bor_cur}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &_103 <- _ret ] -{inv'4 _ret.final}-
            [ &bor_cur <- { bor_cur with current = _ret.final } ] s10)
      | s10 = swap'0 {_102} {_103} (fun (_ret: ()) -> [ &_101 <- _ret ] s11)
      | s11 = bb41 ]
    | bb41 = s0
      [ s0 = {[@expl:type invariant] inv'20 bor_next} s1
      | s1 = -{resolve'6 bor_next}- s2
      | s2 = {[@expl:type invariant] inv'20 bor_cur} s3
      | s3 = -{resolve'6 bor_cur}- s4
      | s4 = {inv'11 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_109 <- _ret ] -{inv'11 _ret.final}-
            [ &pa'0 <- _ret.final ] s5)
      | s5 = deref_mut {_109} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_108 <- _ret ] s6)
      | s6 = bb42 ]
    | bb42 = s0 [ s0 = deref {cur'0} (fun (_ret: t_PermCell) -> [ &_115 <- _ret ] s1) | s1 = bb43 ]
    | bb43 = s0 [ s0 = id_ghost {_115} (fun (_ret: t_Id) -> [ &_113 <- _ret ] s1) | s1 = bb44 ]
    | bb44 = s0 [ s0 = deref'0 {_113} (fun (_ret: t_Id) -> [ &_111 <- _ret ] s1) | s1 = bb45 ]
    | bb45 = s0 [ s0 = into_inner {perm_cur} (fun (_ret: t_PermCellOwn) -> [ &_117 <- _ret ] s1) | s1 = bb46 ]
    | bb46 = s0
      [ s0 = {inv'7 ((_108.current).current).t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {((_108.current).current).t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_107 <- _ret ] -{inv'7 _ret.final}-
            [ &_108 <- { _108 with current = { _108.current with current = { (_108.current).current with t_PA__perms = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_107} {_111} {_117} (fun (_ret: t_Option) -> [ &_106 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'15 _106} s3
      | s3 = -{resolve'15 _106}- s4
      | s4 = bb47 ]
    | bb47 = s0
      [ s0 = {[@expl:type invariant] inv'13 _108} s1
      | s1 = -{resolve'0 _108}- s2
      | s2 =
        [ &new_d <- [%#spersistent_array] MinMax.min (Map.get (pa'0.current).t_PA__depth (id (view'6 cur'0))) (Map.get (pa'0.current).t_PA__depth (id (view'1 next'0))
        - 1) ] s3
      | s3 = bb48 ]
    | bb48 = s0
      [ s0 = [ &_121 <- [%#spersistent_array'0] Map.set (pa'0.current).t_PA__depth (id (view'6 cur'0)) new_d ] s1
      | s1 = bb49 ]
    | bb49 = s0
      [ s0 = {inv'11 pa'0}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_124 <- _ret ] -{inv'11 _ret.final}-
            [ &pa'0 <- _ret.final ] s1)
      | s1 = deref_mut {_124} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_123 <- _ret ] s2)
      | s2 = bb50 ]
    | bb50 = s0
      [ s0 =
        [ &_123 <- { _123 with current = { _123.current with current = { (_123.current).current with t_PA__depth = _121 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'13 _123} s2
      | s2 = -{resolve'0 _123}- s3
      | s3 = {[@expl:type invariant] inv'11 pa'0} s4
      | s4 = -{resolve'10 pa'0}- s5
      | s5 = new'3 {_105} (fun (_ret: ()) -> [ &_104 <- _ret ] s6)
      | s6 = bb53 ]
    | bb53 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & cur'0: t_Rc = cur
    | & auth_id'0: t_Id = auth_id
    | & pa'0: MutBorrow.t t_PA = pa
    | & perm_cur: t_PermCellOwn = Any.any_l ()
    | & _13: t_PermCellOwn = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_FMap = Any.any_l ()
    | & _16: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _17: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _19: t_Id = Any.any_l ()
    | & _21: t_Id = Any.any_l ()
    | & _22: t_Id = Any.any_l ()
    | & _24: t_PermCell = Any.any_l ()
    | & bor_cur: MutBorrow.t t_Inner = Any.any_l ()
    | & _27: MutBorrow.t t_Inner = Any.any_l ()
    | & _29: t_PermCell = Any.any_l ()
    | & _31: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _32: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _33: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _34: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _35: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _36: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _38: t_Option = Any.any_l ()
    | & _39: t_Option = Any.any_l ()
    | & _40: MutBorrow.t t_FMap = Any.any_l ()
    | & _41: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _42: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _44: t_Id = Any.any_l ()
    | & _46: t_Id = Any.any_l ()
    | & _48: t_PermCell = Any.any_l ()
    | & _50: t_PermCellOwn = Any.any_l ()
    | & next: MutBorrow.t t_Rc = Any.any_l ()
    | & value: MutBorrow.t t_T = Any.any_l ()
    | & index: MutBorrow.t UInt64.t = Any.any_l ()
    | & _56: () = Any.any_l ()
    | & _58: MutBorrow.t t_Rc = Any.any_l ()
    | & _60: MutBorrow.t t_PA = Any.any_l ()
    | & _61: MutBorrow.t t_PA = Any.any_l ()
    | & _62: MutBorrow.t t_PA = Any.any_l ()
    | & _63: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _64: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _65: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & next'0: t_Rc = Any.any_l ()
    | & _67: MutBorrow.t t_Rc = Any.any_l ()
    | & _68: t_Rc = Any.any_l ()
    | & perm_next: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _71: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _72: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _73: t_Option'0 = Any.any_l ()
    | & _74: MutBorrow.t t_FMap = Any.any_l ()
    | & _75: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _76: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _78: t_Id = Any.any_l ()
    | & _79: t_Id = Any.any_l ()
    | & _81: t_Id = Any.any_l ()
    | & _83: t_PermCell = Any.any_l ()
    | & bor_next: MutBorrow.t t_Inner = Any.any_l ()
    | & _86: MutBorrow.t t_Inner = Any.any_l ()
    | & _88: t_PermCell = Any.any_l ()
    | & arr: MutBorrow.t t_Vec = Any.any_l ()
    | & _94: () = Any.any_l ()
    | & _95: MutBorrow.t t_T = Any.any_l ()
    | & _96: MutBorrow.t t_T = Any.any_l ()
    | & _97: MutBorrow.t t_T = Any.any_l ()
    | & _98: MutBorrow.t t_Vec = Any.any_l ()
    | & _100: MutBorrow.t t_T = Any.any_l ()
    | & _101: () = Any.any_l ()
    | & _102: MutBorrow.t t_Inner = Any.any_l ()
    | & _103: MutBorrow.t t_Inner = Any.any_l ()
    | & _104: () = Any.any_l ()
    | & _105: () = Any.any_l ()
    | & _106: t_Option = Any.any_l ()
    | & _107: MutBorrow.t t_FMap = Any.any_l ()
    | & _108: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _109: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _111: t_Id = Any.any_l ()
    | & _113: t_Id = Any.any_l ()
    | & _115: t_PermCell = Any.any_l ()
    | & _117: t_PermCellOwn = Any.any_l ()
    | & new_d: int = Any.any_l ()
    | & _121: Map.map t_Id int = Any.any_l ()
    | & _123: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _124: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:reroot ensures #0] [%#spersistent_array'5] partial_invariant (fin'0 pa) auth_id}
      {[@expl:reroot ensures #1] [%#spersistent_array'6] (fin'0 pa).t_PA__auth = (pa.current).t_PA__auth}
      {[@expl:reroot ensures #2] [%#spersistent_array'7] forall id'2: t_Id. index_logic'3 (pa.current).t_PA__depth id'2
          > index_logic'3 (pa.current).t_PA__depth (id (view'6 cur))
        -> get (pa.current).t_PA__perms id'2 = get (fin'0 pa).t_PA__perms id'2
        /\ index_logic'3 (pa.current).t_PA__depth id'2 = index_logic'3 (fin'0 pa).t_PA__depth id'2}
      {[@expl:reroot ensures #3] [%#spersistent_array'8] forall id'2: t_Id. contains (fin'0 pa).t_PA__perms id'2
        = contains (pa.current).t_PA__perms id'2}
      {[@expl:reroot ensures #4] [%#spersistent_array'9] match val' (index_logic'0 (fin'0 pa).t_PA__perms (id (view'6 cur))) with
        | C_Direct _ -> true
        | C_Link _ _ _ -> false
        end}
      (! return' {result}) ]
end
module M_persistent_array__testing [#"persistent_array.rs" 304 0 304 41]
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span spersistent_array = "persistent_array.rs" 305 38 305 39
  let%span spersistent_array'0 = "persistent_array.rs" 305 41 305 42
  let%span spersistent_array'1 = "persistent_array.rs" 305 44 305 45
  let%span spersistent_array'2 = "persistent_array.rs" 305 47 305 48
  let%span spersistent_array'3 = "persistent_array.rs" 307 19 307 20
  let%span spersistent_array'4 = "persistent_array.rs" 307 22 307 24
  let%span spersistent_array'5 = "persistent_array.rs" 308 19 308 20
  let%span spersistent_array'6 = "persistent_array.rs" 308 22 308 24
  let%span spersistent_array'7 = "persistent_array.rs" 312 18 312 57
  let%span spersistent_array'8 = "persistent_array.rs" 313 19 313 59
  let%span spersistent_array'9 = "persistent_array.rs" 314 19 314 59
  let%span spersistent_array'10 = "persistent_array.rs" 315 18 315 32
  let%span spersistent_array'11 = "persistent_array.rs" 316 18 316 34
  let%span spersistent_array'12 = "persistent_array.rs" 317 18 317 34
  let%span spersistent_array'13 = "persistent_array.rs" 318 18 318 33
  let%span spersistent_array'14 = "persistent_array.rs" 303 0 303 54
  let%span spersistent_array'15 = "persistent_array.rs" 131 33 131 37
  let%span spersistent_array'16 = "persistent_array.rs" 130 18 130 31
  let%span spersistent_array'17 = "persistent_array.rs" 159 20 159 24
  let%span spersistent_array'18 = "persistent_array.rs" 156 19 156 39
  let%span spersistent_array'19 = "persistent_array.rs" 157 8 157 46
  let%span spersistent_array'20 = "persistent_array.rs" 159 76 159 80
  let%span spersistent_array'21 = "persistent_array.rs" 158 18 158 53
  let%span spersistent_array'22 = "persistent_array.rs" 48 18 48 22
  let%span spersistent_array'23 = "persistent_array.rs" 48 27 48 31
  let%span spersistent_array'24 = "persistent_array.rs" 47 18 47 34
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 88 14 88 35
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 127 8 127 22
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span slocal_invariant = "../../creusot-contracts/src/ghost/local_invariant.rs" 138 14 138 47
  let%span slocal_invariant'0 = "../../creusot-contracts/src/ghost/local_invariant.rs" 181 4 181 12
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 22 8 22 22
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 364 18 364 35
  
  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use set.Set
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq Int32.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 (self: Slice64.slice Int32.t) : Seq.seq Int32.t = [%#sboxed] Slice64.view self
  
  let rec into_vec (self_: Slice64.slice Int32.t) (return' (x: t_Vec)) = any
    [ return''0 (result: t_Vec) -> {[%#sslice] view result = view'0 self_} (! return' {result}) ]
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq Int32.t }
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'1; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  predicate invariant' [#"persistent_array.rs" 59 8 59 34] (self: t_PersistentArray)
  
  predicate invariant''0 (self: t_Fragment)
  
  predicate inv (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
      = (invariant''0 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''1 (self: t_Fragment) = [%#sghost'2] inv self
  
  predicate inv'0 (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''1 x
  
  predicate inv'1 (_0: t_PersistentArray)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PersistentArray [inv'1 x]. inv'1 x
      = (invariant' x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'2} -> inv'0 frag
        end)
  
  function view'1 [#"persistent_array.rs" 77 8 77 31] (self: t_PersistentArray) : Seq.seq Int32.t
  
  let rec new (v: t_Vec) (return' (x: t_PersistentArray)) = any
    [ return''0 (result: t_PersistentArray) -> {[%#spersistent_array'15] inv'1 result}
      {[%#spersistent_array'16] view'1 result = view v}
      (! return' {result}) ]
  
  type t_Tokens
  
  let rec deref_mut (self: MutBorrow.t t_Tokens) (return' (x: MutBorrow.t t_Tokens)) = any
    [ return''0 (result: MutBorrow.t t_Tokens) -> {[%#sghost] result = self} (! return' {result}) ]
  
  let rec reborrow (self: MutBorrow.t t_Tokens) (return' (x: t_Tokens)) = any
    [ return''0 (result: t_Tokens) -> {[%#slocal_invariant] result = self.current /\ self.final = self.current}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_Tokens) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0: MutBorrow.t t_Tokens) = resolve _0
  
  let rec new'0 (x: t_Tokens) (return' (x'0: t_Tokens)) = any
    [ return''0 (result: t_Tokens) -> {[%#sghost'0] result = x} (! return' {result}) ]
  
  predicate invariant''2 (self: t_PersistentArray) = [%#sinvariant] inv'1 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 (_0: t_PersistentArray)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PersistentArray [inv'2 x]. inv'2 x = invariant''2 x
  
  function view'2 (self: t_PersistentArray) : Seq.seq Int32.t = [%#smodel] view'1 self
  
  predicate contains [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = [%#sset] Set.mem e self
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'0 (self: t_Tokens) (namespace: t_Namespace) =
    [%#slocal_invariant'0] contains (namespaces self) namespace
  
  let rec set (self: t_PersistentArray) (index: UInt64.t) (value: Int32.t) (tokens: t_Tokens)
    (return' (x: t_PersistentArray)) = {[@expl:set 'self' type invariant] [%#spersistent_array'17] inv'2 self}
    {[@expl:set requires #0] [%#spersistent_array'18] UInt64.t'int index < Seq.length (view'2 self)}
    {[@expl:set requires #1] [%#spersistent_array'19] contains'0 tokens (Namespace_PARRAY 0)}
    any
    [ return''0 (result: t_PersistentArray) -> {[%#spersistent_array'20] inv'1 result}
      {[%#spersistent_array'21] view'1 result = Seq.set (view'2 self) (UInt64.t'int index) value}
      (! return' {result}) ]
  
  predicate resolve'1 (_0: t_Tokens) = true
  
  predicate resolve'2 (self: t_Tokens) = [%#sghost'1] resolve'1 self
  
  predicate resolve'3 (_0: t_Tokens) = resolve'2 _0
  
  let rec clone' (self: t_PersistentArray) (return' (x: t_PersistentArray)) =
    {[@expl:clone 'self' type invariant] [%#spersistent_array'22] inv'2 self}
    any
    [ return''0 (result: t_PersistentArray) -> {[%#spersistent_array'23] inv'1 result}
      {[%#spersistent_array'24] view'1 result = view'2 self}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec testing [#"persistent_array.rs" 304 0 304 41] (tokens: t_Tokens) (return' (x: ())) =
    {[@expl:testing requires] [%#spersistent_array'14] contains'0 tokens (Namespace_PARRAY 0)}
    (! bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0
            = ([%#spersistent_array] (1: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 1 = ([%#spersistent_array'0] (2: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 2 = ([%#spersistent_array'1] (3: Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 3 = ([%#spersistent_array'2] (4: Int32.t))
          /\ Seq.length __arr_temp.Slice64.elts = 4}-
          [ &_7 <- __arr_temp ] s1) ]
      | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_vec {_7} (fun (_ret: t_Vec) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_4} (fun (_ret: t_PersistentArray) -> [ &a <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_mut <t_Tokens> {tokens'0}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_14 <- _ret ] [ &tokens'0 <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret: MutBorrow.t t_Tokens) -> [ &_13 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = MutBorrow.borrow_final <t_Tokens> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_12 <- _ret ] [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = reborrow {_12} (fun (_ret: t_Tokens) -> [ &_11 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = -{resolve'0 _13}- s1 | s1 = new'0 {_11} (fun (_ret: t_Tokens) -> [ &_10 <- _ret ] s2) | s2 = bb7 ]
    | bb7 = s0
      [ s0 = set {a} {[%#spersistent_array'3] (1: UInt64.t)} {[%#spersistent_array'4] (42: Int32.t)} {_10}
          (fun (_ret: t_PersistentArray) -> [ &a2 <- _ret ] s1)
      | s1 = bb8 ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Tokens> {tokens'0}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_21 <- _ret ] [ &tokens'0 <- _ret.final ] s1)
      | s1 = deref_mut {_21} (fun (_ret: MutBorrow.t t_Tokens) -> [ &_20 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = MutBorrow.borrow_final <t_Tokens> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_19 <- _ret ] [ &_20 <- { _20 with current = _ret.final } ] s1)
      | s1 = reborrow {_19} (fun (_ret: t_Tokens) -> [ &_18 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = -{resolve'0 _20}- s1 | s1 = new'0 {_18} (fun (_ret: t_Tokens) -> [ &_17 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0
      [ s0 = set {a} {[%#spersistent_array'5] (0: UInt64.t)} {[%#spersistent_array'6] (50: Int32.t)} {_17}
          (fun (_ret: t_PersistentArray) -> [ &a3 <- _ret ] s1)
      | s1 = bb12 ]
    | bb12 = s0
      [ s0 = -{resolve'3 tokens'0}- s1
      | s1 = clone' {a} (fun (_ret: t_PersistentArray) -> [ &a4 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 =
        [ &a_model <- [%#spersistent_array'7] Seq.create 4 [|(1: Int32.t);(2: Int32.t);(3: Int32.t);(4: Int32.t)|] ] s1
      | s1 = bb14 ]
    | bb14 = s0
      [ s0 =
        [ &a2_model <- [%#spersistent_array'8] Seq.create 4 [|(1: Int32.t);(42: Int32.t);(3: Int32.t);(4: Int32.t)|] ]
        s1
      | s1 = bb15 ]
    | bb15 = s0
      [ s0 =
        [ &a3_model <- [%#spersistent_array'9] Seq.create 4 [|(50: Int32.t);(2: Int32.t);(3: Int32.t);(4: Int32.t)|] ]
        s1
      | s1 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:assertion] [%#spersistent_array'10] view'1 a = a_model} s1
      | s1 = {[@expl:assertion] [%#spersistent_array'11] view'1 a2 = a2_model} s2
      | s2 = {[@expl:assertion] [%#spersistent_array'12] view'1 a3 = a3_model} s3
      | s3 = {[@expl:assertion] [%#spersistent_array'13] view'1 a4 = a_model} s4
      | s4 = bb20 ]
    | bb20 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & tokens'0: t_Tokens = tokens
    | & a: t_PersistentArray = Any.any_l ()
    | & _4: t_Vec = Any.any_l ()
    | & _7: Slice64.array Int32.t = Any.any_l ()
    | & a2: t_PersistentArray = Any.any_l ()
    | & _10: t_Tokens = Any.any_l ()
    | & _11: t_Tokens = Any.any_l ()
    | & _12: MutBorrow.t t_Tokens = Any.any_l ()
    | & _13: MutBorrow.t t_Tokens = Any.any_l ()
    | & _14: MutBorrow.t t_Tokens = Any.any_l ()
    | & a3: t_PersistentArray = Any.any_l ()
    | & _17: t_Tokens = Any.any_l ()
    | & _18: t_Tokens = Any.any_l ()
    | & _19: MutBorrow.t t_Tokens = Any.any_l ()
    | & _20: MutBorrow.t t_Tokens = Any.any_l ()
    | & _21: MutBorrow.t t_Tokens = Any.any_l ()
    | & a4: t_PersistentArray = Any.any_l ()
    | & a_model: Seq.seq Int32.t = Any.any_l ()
    | & a2_model: Seq.seq Int32.t = Any.any_l ()
    | & a3_model: Seq.seq Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_persistent_array__implementation__qyi15164097500274694161__clone__refines [#"persistent_array.rs" 48 8 48 31] (* <implementation::PersistentArray<T> as creusot_contracts::Clone> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  let%span spersistent_array = "persistent_array.rs" 48 8 48 31
  let%span spersistent_array'0 = "persistent_array.rs" 78 24 78 36
  let%span spersistent_array'1 = "persistent_array.rs" 62 16 64 52
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 119 8 119 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 95 8 95 18
  
  use creusot.prelude.Opaque
  use seq.Seq
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  type tuple = { _p0: t_Id; _p1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function view'0 (self: t_Fragment) : tuple = [%#sghost] view self
  
  type t_PermCell
  
  function id (self: t_PermCell) : t_Id
  
  function view'1 (self: t_Rc) : t_PermCell
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'2 (self: t_Rc'0) : t_LocalInvariant
  
  function view'3 (self: t_Rc'0) : t_LocalInvariant = [%#sghost] view'2 self
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant' [#"persistent_array.rs" 59 8 59 34] (self: t_PersistentArray) =
    [%#spersistent_array'1] (view'0 self.t_PersistentArray__frag)._p0 = id (view'1 self.t_PersistentArray__permcell)
    /\ id'0 self.t_PersistentArray__frag = public (view'3 self.t_PersistentArray__inv)
    /\ namespace (view'3 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate invariant''0 (self: t_Fragment)
  
  predicate inv (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
      = (invariant''0 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''1 (self: t_Fragment) = [%#sghost'0] inv self
  
  predicate inv'0 (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''1 x
  
  predicate inv'1 (_0: t_PersistentArray)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PersistentArray [inv'1 x]. inv'1 x
      = (invariant' x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'2} -> inv'0 frag
        end)
  
  predicate invariant''2 (self: t_PersistentArray) = [%#sinvariant] inv'1 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 (_0: t_PersistentArray)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PersistentArray [inv'2 x]. inv'2 x = invariant''2 x
  
  function view'4 [#"persistent_array.rs" 77 8 77 31] (self: t_PersistentArray) : Seq.seq t_T =
    [%#spersistent_array'0] (view'0 self.t_PersistentArray__frag)._p1
  
  function view'5 (self: t_PersistentArray) : Seq.seq t_T = [%#smodel] view'4 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#spersistent_array] forall self_: t_PersistentArray. inv'2 self_
      -> inv'2 self_ /\ (forall result: t_PersistentArray. view'4 result = view'5 self_ /\ inv'1 result -> inv'1 result)
end
