module M_persistent_array__implementation__qyi15164097500274694161__clone (* <implementation::PersistentArray<T> as creusot_contracts::Clone> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  let rec clone' (self_: t_Rc) (return (x: t_Rc)) = any
    [ return' (result: t_Rc) -> {result = self_} (! return {result}) ]
  
  predicate invariant' (self: t_Fragment)
  
  predicate inv (_1: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: t_Fragment) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_1: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_Fragment) = inv'0 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'1 (_1: t_Fragment)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_Fragment) = inv self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 (_1: t_Fragment)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Fragment [inv'2 x]. inv'2 x = invariant''2 x
  
  let rec deref (self: t_Fragment) (return (x: t_Fragment)) = {[@expl:deref 'self' type invariant] inv'1 self}
    any [ return' (result: t_Fragment) -> {inv'2 result} {result = self} (! return {result}) ]
  
  type tuple = { f0: t_Id; f1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function id (self: t_Fragment) : t_Id
  
  let rec clone''0 (self: t_Fragment) (return (x: t_Fragment)) = {[@expl:clone 'self' type invariant] inv'2 self}
    any
    [ return' (result: t_Fragment) -> {inv result} {view result = view self} {id result = id self} (! return {result}) ]
  
  let rec new (x: t_Fragment) (return (x'0: t_Fragment)) = {[@expl:new 'x' type invariant] inv x}
    any [ return' (result: t_Fragment) -> {inv'0 result} {result = x} (! return {result}) ]
  
  let rec deref'0 (self: t_Rc'0) (return (x: t_Rc'0)) = any
    [ return' (result: t_Rc'0) -> {result = self} (! return {result}) ]
  
  let rec clone''1 (self_: t_Rc'0) (return (x: t_Rc'0)) = any
    [ return' (result: t_Rc'0) -> {result = self_} (! return {result}) ]
  
  let rec new'0 (x: t_Rc'0) (return (x'0: t_Rc'0)) = any
    [ return' (result: t_Rc'0) -> {result = x} (! return {result}) ]
  
  type t_PermCell
  
  function id'0 (self: t_PermCell) : t_Id
  
  function view'0 (self: t_Rc) : t_PermCell
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'1 (self: t_Rc'0) : t_LocalInvariant
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''3 (self: t_PersistentArray) =
    (view self.t_PersistentArray__frag).f0 = id'0 (view'0 self.t_PersistentArray__permcell)
    /\ id self.t_PersistentArray__frag = public (view'1 self.t_PersistentArray__inv)
    /\ namespace (view'1 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'3 (_1: t_PersistentArray)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PersistentArray [inv'3 x]. inv'3 x
      = (invariant''3 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'4} -> inv'0 frag
        end)
  
  predicate invariant''4 [@inline:trivial] (self: t_PersistentArray) = inv'3 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'4 (_1: t_PersistentArray)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PersistentArray [inv'4 x]. inv'4 x = invariant''4 x
  
  function view'2 [@inline:trivial] (self: t_PersistentArray) : Seq.seq t_T = (view self.t_PersistentArray__frag).f1
  
  meta "rewrite_def" function view'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''2 (self: t_PersistentArray) (return (x: t_PersistentArray)) =
    {[@expl:clone 'self' type invariant] inv'4 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone' {self.t_PersistentArray__permcell} (fun (_ret: t_Rc) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref {self.t_PersistentArray__frag} (fun (_ret: t_Fragment) -> [ &_8 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = clone''0 {_8} (fun (_ret: t_Fragment) -> [ &_6 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_6} (fun (_ret: t_Fragment) -> [ &_5 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = deref'0 {self.t_PersistentArray__inv} (fun (_ret: t_Rc'0) -> [ &_13 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = clone''1 {_13} (fun (_ret: t_Rc'0) -> [ &_11 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = new'0 {_11} (fun (_ret: t_Rc'0) -> [ &_10 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_0 <- { t_PersistentArray__permcell = _3; t_PersistentArray__frag = _5; t_PersistentArray__inv = _10 } ]
        s1
      | s1 = bb8 ]
    | bb8 = return {_0} ]
    [ & _0: t_PersistentArray = Any.any_l ()
    | & self: t_PersistentArray = self
    | & _3: t_Rc = Any.any_l ()
    | & _5: t_Fragment = Any.any_l ()
    | & _6: t_Fragment = Any.any_l ()
    | & _8: t_Fragment = Any.any_l ()
    | & _10: t_Rc'0 = Any.any_l ()
    | & _11: t_Rc'0 = Any.any_l ()
    | & _13: t_Rc'0 = Any.any_l () ])
    [ return (result: t_PersistentArray) -> {[@expl:clone result type invariant] inv'3 result}
      {[@expl:clone ensures] view'2 result = view'2 self}
      (! return {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__new (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_PermCell
  
  type t_PermCellOwn
  
  type tuple = { f0: t_PermCell; f1: t_PermCellOwn }
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 (_1: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_1: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 (self: t_Vec) = inv'1 (view self)
  
  predicate inv'2 (_1: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
      = match x with
        | C_Direct a_0 -> inv'2 a_0
        | C_Link index value next -> inv value
        end
  
  predicate invariant''2 [@inline:trivial] (self: t_Inner) = inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_1: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 [@inline:trivial] (self: t_PermCellOwn) = inv'4 (val' self)
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 (_1: t_PermCellOwn)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PermCellOwn [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_PermCellOwn) = inv'5 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'6 (_1: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_1: tuple)
  
  axiom inv_axiom'6 [@rewrite]: forall x: tuple [inv'7 x]. inv'7 x = (let {f0 = x0; f1 = x1} = x in inv'6 x1)
  
  type t_Id
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function view'0 [@inline:trivial] (self: t_PermCellOwn) : t_Inner = val' self
  
  meta "rewrite_def" function view'0
  
  let rec new (value: t_Inner) (return (x: tuple)) = {[@expl:new 'value' type invariant] inv'3 value}
    any
    [ return' (result: tuple) -> {inv'7 result}
      {id result.f0 = id'0 result.f1}
      {view'0 result.f1 = value}
      (! return {result}) ]
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_1: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate invariant''6 [@inline:trivial] (self: t_Authority) = inv'8 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'9 (_1: t_Authority)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Authority [inv'9 x]. inv'9 x = invariant''6 x
  
  type t_FMap
  
  function view'1 (self: t_Authority) : t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  type t_Option = C_None | C_Some (Seq.seq t_T)
  
  function view'2 (self: t_FMap) : Map.map t_Id t_Option
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view'2 empty = Const.const (C_None)
  
  let rec new'0 (return (x: t_Authority)) = any
    [ return' (result: t_Authority) -> {inv'9 result} {view'1 result = empty} (! return {result}) ]
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_Authority) = inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'10 (_1: MutBorrow.t t_Authority)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'10 x]. inv'10 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_Authority) = inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'11 (_1: MutBorrow.t t_Authority)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'11 x]. inv'11 x = invariant''8 x
  
  let rec deref_mut (self: MutBorrow.t t_Authority) (return (x: MutBorrow.t t_Authority)) =
    {[@expl:deref_mut 'self' type invariant] inv'10 self}
    any [ return' (result: MutBorrow.t t_Authority) -> {inv'11 result} {result = self} (! return {result}) ]
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = Map.get (view'2 self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate invariant''9 (self: t_Fragment)
  
  predicate inv'12 (_1: t_Fragment)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Fragment [inv'12 x]. inv'12 x
      = (invariant''9 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  function insert (self: t_FMap) (k: t_Id) (v: Seq.seq t_T) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: Seq.seq t_T. view'2 (insert self k v)
      = Map.set (view'2 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: Seq.seq t_T. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function id'1 (self: t_Authority) : t_Id
  
  type tuple'0 = { f0'0: t_Id; f1'0: Seq.seq t_T }
  
  function view'3 (self: t_Fragment) : tuple'0
  
  function id'2 (self: t_Fragment) : t_Id
  
  let rec insert'0 (self: MutBorrow.t t_Authority) (k: t_Id) (v: Seq.seq t_T) (return (x: t_Fragment)) =
    {[@expl:insert 'self' type invariant] inv'11 self}
    {[@expl:insert requires] not contains (view'1 self.current) k}
    any
    [ return' (result: t_Fragment) -> {inv'12 result}
      {view'1 self.final = insert (view'1 self.current) k v}
      {id'1 self.final = id'1 self.current}
      {view'3 result = { f0'0 = k; f1'0 = v }}
      {id'2 result = id'1 self.current}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Authority) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Authority) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''10 [@inline:trivial] (self: t_Fragment) = inv'12 self
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'13 (_1: t_Fragment)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Fragment [inv'13 x]. inv'13 x = invariant''10 x
  
  let rec new'1 (x: t_Fragment) (return (x'0: t_Fragment)) = {[@expl:new 'x' type invariant] inv'12 x}
    any [ return' (result: t_Fragment) -> {inv'13 result} {result = x} (! return {result}) ]
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PermCellOwn
  
  function view'4 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = Map.get (view'4 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains'0
  
  predicate inv'14 (_1: t_Id)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Id [inv'14 x]. inv'14 x = true
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. (exists x: t_PermCellOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option'0) : t_PermCellOwn = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_PermCellOwn = unwrap_logic (get'0 self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : t_PermCellOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''11 [@inline:trivial] (self: t_FMap'0) =
    forall k: t_Id. contains'0 self k -> inv'14 k /\ inv'5 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'15 (_1: t_FMap'0)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_FMap'0 [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate invariant''12 [@inline:trivial] (self: t_FMap'0) = inv'15 self
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'16 (_1: t_FMap'0)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_FMap'0 [inv'16 x]. inv'16 x = invariant''12 x
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) = forall k: t_Id. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. ext_eq self other = (self = other)
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. len'0 self >= 0
  
  constant empty'0 : t_FMap'0
  
  axiom empty_spec'1: len'0 empty'0 = 0
  
  axiom empty_spec'2: view'4 empty'0 = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap'0) = ext_eq self empty'0
  
  let rec new'2 (return (x: t_FMap'0)) = any
    [ return' (result: t_FMap'0) -> {inv'16 result} {is_empty result} (! return {result}) ]
  
  predicate invariant''13 [@inline:trivial] (self: MutBorrow.t t_FMap'0) = inv'16 self.current /\ inv'16 self.final
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'17 (_1: MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t t_FMap'0 [inv'17 x]. inv'17 x = invariant''13 x
  
  predicate invariant''14 [@inline:trivial] (self: MutBorrow.t t_FMap'0) = inv'15 self.current /\ inv'15 self.final
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'18 (_1: MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_FMap'0 [inv'18 x]. inv'18 x = invariant''14 x
  
  let rec deref_mut'0 (self: MutBorrow.t t_FMap'0) (return (x: MutBorrow.t t_FMap'0)) =
    {[@expl:deref_mut 'self' type invariant] inv'17 self}
    any [ return' (result: MutBorrow.t t_FMap'0) -> {inv'18 result} {result = self} (! return {result}) ]
  
  predicate invariant''15 [@inline:trivial] (self: t_PermCellOwn) = inv'6 self
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'19 (_1: t_PermCellOwn)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_PermCellOwn [inv'19 x]. inv'19 x = invariant''15 x
  
  predicate invariant''16 [@inline:trivial] (self: t_PermCellOwn) = inv'5 self
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'20 (_1: t_PermCellOwn)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PermCellOwn [inv'20 x]. inv'20 x = invariant''16 x
  
  let rec deref (self: t_PermCellOwn) (return (x: t_PermCellOwn)) = {[@expl:deref 'self' type invariant] inv'19 self}
    any [ return' (result: t_PermCellOwn) -> {inv'20 result} {result = self} (! return {result}) ]
  
  let rec id_ghost (self: t_PermCellOwn) (return (x: t_Id)) = {[@expl:id_ghost 'self' type invariant] inv'20 self}
    any [ return' (result: t_Id) -> {result = id'0 self} (! return {result}) ]
  
  let rec deref'0 (self: t_Id) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = self} (! return {result}) ]
  
  let rec into_inner (self: t_PermCellOwn) (return (x: t_PermCellOwn)) =
    {[@expl:into_inner 'self' type invariant] inv'6 self}
    any [ return' (result: t_PermCellOwn) -> {inv'5 result} {result = self} (! return {result}) ]
  
  predicate inv'21 (_1: t_Option'0)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Option'0 [inv'21 x]. inv'21 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'5 a_0
        end
  
  function insert'1 (self: t_FMap'0) (k: t_Id) (v: t_PermCellOwn) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_Id, v: t_PermCellOwn. view'4 (insert'1 self k v)
      = Map.set (view'4 self) k (C_Some'0 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_Id, v: t_PermCellOwn. len'0 (insert'1 self k v)
      = (if contains'0 self k then len'0 self else len'0 self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap'0) (key: t_Id) (value: t_PermCellOwn) (return (x: t_Option'0)) =
    {[@expl:insert_ghost 'self' type invariant] inv'18 self}
    {[@expl:insert_ghost 'value' type invariant] inv'5 value}
    any
    [ return' (result: t_Option'0) -> {inv'21 result}
      {self.final = insert'1 self.current key value}
      {result = get'0 self.current key}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (_1: t_Inner) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (self: t_PermCellOwn) = resolve'1 (val' self)
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_PermCellOwn) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_Option'0) =
    match self with
      | C_Some'0 x -> resolve'3 x
      | C_None'0 -> true
      end
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: t_Option'0) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_FMap'0) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: MutBorrow.t t_FMap'0) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  let rec into_inner'0 (self: t_FMap'0) (return (x: t_FMap'0)) = {[@expl:into_inner 'self' type invariant] inv'16 self}
    any [ return' (result: t_FMap'0) -> {inv'15 result} {result = self} (! return {result}) ]
  
  let rec into_inner'1 (self: t_Authority) (return (x: t_Authority)) =
    {[@expl:into_inner 'self' type invariant] inv'9 self}
    any [ return' (result: t_Authority) -> {inv'8 result} {result = self} (! return {result}) ]
  
  type t_PA = { t_PA__perms: t_FMap'0; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  predicate inv'22 (_1: t_PA)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_PA [inv'22 x]. inv'22 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'15 perms /\ inv'8 auth
        end
  
  predicate invariant''17 [@inline:trivial] (self: t_PA) = inv'22 self
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'23 (_1: t_PA)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_PA [inv'23 x]. inv'23 x = invariant''17 x
  
  let rec new'3 (x: t_PA) (return (x'0: t_PA)) = {[@expl:new 'x' type invariant] inv'22 x}
    any [ return' (result: t_PA) -> {inv'23 result} {result = x} (! return {result}) ]
  
  type t_LocalInvariant
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. (exists x: Seq.seq t_T. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option) : Seq.seq t_T = match self with
      | C_Some x -> x
      | C_None -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap) (k: t_Id) : Seq.seq t_T = unwrap_logic'0 (get self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap) (key: t_Id) : Seq.seq t_T = lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  function view'5 (self: t_Rc) : t_PermCell
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Id int) (a: t_Id) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate partial_invariant [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    id'1 self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains (view'1 self.t_PA__auth) id'3 /\ contains'0 self.t_PA__perms id'3
      -> id'0 (index_logic'0 self.t_PA__perms id'3) = id'3
      /\ match val' (index_logic'0 self.t_PA__perms id'3) with
        | C_Direct v -> index_logic'2 (view'1 self.t_PA__auth) id'3 = view v
        | C_Link index value next -> contains (view'1 self.t_PA__auth) (id (view'5 next))
        /\ index_logic'3 self.t_PA__depth id'3 > index_logic'3 self.t_PA__depth (id (view'5 next))
        /\ UInt64.t'int index < Seq.length (index_logic'2 (view'1 self.t_PA__auth) (id (view'5 next)))
        /\ index_logic'2 (view'1 self.t_PA__auth) id'3
        = Seq.set (index_logic'2 (view'1 self.t_PA__auth) (id (view'5 next))) (UInt64.t'int index) value
        end)
  
  meta "rewrite_def" predicate partial_invariant
  
  predicate protocol [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    partial_invariant self resource_id
    /\ (forall id'3: t_Id. contains (view'1 self.t_PA__auth) id'3 -> contains'0 self.t_PA__perms id'3)
  
  meta "rewrite_def" predicate protocol
  
  function public (self: t_LocalInvariant) : t_Id
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  let rec new'4 (value: t_PA) (public'0: t_Id) (namespace'0: t_Namespace) (return (x: t_LocalInvariant)) =
    {[@expl:new 'value' type invariant] inv'23 value}
    {[@expl:new requires] protocol value public'0}
    any
    [ return' (result: t_LocalInvariant) -> {public result = public'0}
      {namespace result = namespace'0}
      (! return {result}) ]
  
  let rec into_inner'2 (self: t_LocalInvariant) (return (x: t_LocalInvariant)) = any
    [ return' (result: t_LocalInvariant) -> {result = self} (! return {result}) ]
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'1; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  function view'6 (self: t_Rc'0) : t_LocalInvariant
  
  let rec new'5 (value: t_LocalInvariant) (return (x: t_Rc'0)) = any
    [ return' (result: t_Rc'0) -> {view'6 result = value} (! return {result}) ]
  
  let rec new'6 (x: t_Rc'0) (return (x'0: t_Rc'0)) = any
    [ return' (result: t_Rc'0) -> {result = x} (! return {result}) ]
  
  let rec new'7 (value: t_PermCell) (return (x: t_Rc)) = any
    [ return' (result: t_Rc) -> {view'5 result = value} (! return {result}) ]
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  predicate invariant''18 (self: t_PersistentArray) =
    (view'3 self.t_PersistentArray__frag).f0'0 = id (view'5 self.t_PersistentArray__permcell)
    /\ id'2 self.t_PersistentArray__frag = public (view'6 self.t_PersistentArray__inv)
    /\ namespace (view'6 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'24 (_1: t_PersistentArray)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_PersistentArray [inv'24 x]. inv'24 x
      = (invariant''18 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'25} -> inv'13 frag
        end)
  
  function view'7 [@inline:trivial] (self: t_PersistentArray) : Seq.seq t_T = (view'3 self.t_PersistentArray__frag).f1'0
  
  meta "rewrite_def" function view'7
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'8 (v: t_Vec) (return (x: t_PersistentArray)) = {[@expl:new 'v' type invariant] inv'2 v}
    (! bb0
    [ bb0 = s0 [ s0 = [ &seq <- view v ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_8 <- C_Direct v ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = new {_8} (fun (_ret: tuple) -> [ &_7 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &permcell <- _7.f0 ] s1 | s1 = [ &permcellown <- _7.f1 ] s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = new'0 (fun (_ret: t_Authority) -> [ &auth <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'9 auth}
        MutBorrow.borrow_mut <t_Authority> {auth}
          (fun (_ret: MutBorrow.t t_Authority) -> [ &_15 <- _ret ] -{inv'9 _ret.final}- [ &auth <- _ret.final ] s1)
      | s1 = deref_mut {_15} (fun (_ret: MutBorrow.t t_Authority) -> [ &_14 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = [ &_16 <- id'0 permcellown ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'8 _14.current}
        MutBorrow.borrow_final <t_Authority> {_14.current} {MutBorrow.get_id _14}
          (fun (_ret: MutBorrow.t t_Authority) ->
            [ &_13 <- _ret ] -{inv'8 _ret.final}-
            [ &_14 <- { _14 with current = _ret.final } ] s1)
      | s1 = insert'0 {_13} {_16} {seq} (fun (_ret: t_Fragment) -> [ &_12 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'11 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 = new'1 {_12} (fun (_ret: t_Fragment) -> [ &frag <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0 [ s0 = new'2 (fun (_ret: t_FMap'0) -> [ &perms <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'16 perms}
        MutBorrow.borrow_mut <t_FMap'0> {perms}
          (fun (_ret: MutBorrow.t t_FMap'0) -> [ &_25 <- _ret ] -{inv'16 _ret.final}- [ &perms <- _ret.final ] s1)
      | s1 = deref_mut'0 {_25} (fun (_ret: MutBorrow.t t_FMap'0) -> [ &_24 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0 [ s0 = deref {permcellown} (fun (_ret: t_PermCellOwn) -> [ &_31 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = id_ghost {_31} (fun (_ret: t_Id) -> [ &_29 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = deref'0 {_29} (fun (_ret: t_Id) -> [ &_27 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0 [ s0 = into_inner {permcellown} (fun (_ret: t_PermCellOwn) -> [ &_33 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'15 _24.current}
        MutBorrow.borrow_final <t_FMap'0> {_24.current} {MutBorrow.get_id _24}
          (fun (_ret: MutBorrow.t t_FMap'0) ->
            [ &_23 <- _ret ] -{inv'15 _ret.final}-
            [ &_24 <- { _24 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_23} {_27} {_33} (fun (_ret: t_Option'0) -> [ &_22 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'21 _22} s3
      | s3 = -{resolve'5 _22}- s4
      | s4 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'18 _24} s1
      | s1 = -{resolve'7 _24}- s2
      | s2 = into_inner'0 {perms} (fun (_ret: t_FMap'0) -> [ &_38 <- _ret ] s3)
      | s3 = bb17 ]
    | bb17 = s0 [ s0 = into_inner'1 {auth} (fun (_ret: t_Authority) -> [ &_40 <- _ret ] s1) | s1 = bb18 ]
    | bb18 = s0 [ s0 = [ &_42 <- fun (__0: t_Id) -> 0 ] s1 | s1 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_37 <- { t_PA__perms = _38; t_PA__auth = _40; t_PA__depth = _42 } ] s1
      | s1 = new'3 {_37} (fun (_ret: t_PA) -> [ &_36 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = [ &_44 <- id'2 frag ] s1 | s1 = bb21 ]
    | bb21 = s0 [ s0 = [ &_46 <- Namespace_PARRAY 0 ] s1 | s1 = bb22 ]
    | bb22 = s0 [ s0 = new'4 {_36} {_44} {_46} (fun (_ret: t_LocalInvariant) -> [ &local_inv <- _ret ] s1) | s1 = bb23 ]
    | bb23 = s0 [ s0 = into_inner'2 {local_inv} (fun (_ret: t_LocalInvariant) -> [ &_48 <- _ret ] s1) | s1 = bb24 ]
    | bb24 = s0 [ s0 = new'5 {_48} (fun (_ret: t_Rc'0) -> [ &_20 <- _ret ] s1) | s1 = bb25 ]
    | bb25 = s0 [ s0 = new'6 {_20} (fun (_ret: t_Rc'0) -> [ &inv'25 <- _ret ] s1) | s1 = bb26 ]
    | bb26 = s0 [ s0 = new'7 {permcell} (fun (_ret: t_Rc) -> [ &_50 <- _ret ] s1) | s1 = bb27 ]
    | bb27 = s0
      [ s0 = [ &_0 <- { t_PersistentArray__permcell = _50;
                        t_PersistentArray__frag = frag;
                        t_PersistentArray__inv = inv'25 } ] s1
      | s1 = bb30 ]
    | bb30 = return {_0} ]
    [ & _0: t_PersistentArray = Any.any_l ()
    | & v: t_Vec = v
    | & seq: Seq.seq t_T = Any.any_l ()
    | & permcell: t_PermCell = Any.any_l ()
    | & permcellown: t_PermCellOwn = Any.any_l ()
    | & _7: tuple = Any.any_l ()
    | & _8: t_Inner = Any.any_l ()
    | & auth: t_Authority = Any.any_l ()
    | & frag: t_Fragment = Any.any_l ()
    | & _12: t_Fragment = Any.any_l ()
    | & _13: MutBorrow.t t_Authority = Any.any_l ()
    | & _14: MutBorrow.t t_Authority = Any.any_l ()
    | & _15: MutBorrow.t t_Authority = Any.any_l ()
    | & _16: t_Id = Any.any_l ()
    | & inv'25: t_Rc'0 = Any.any_l ()
    | & _20: t_Rc'0 = Any.any_l ()
    | & perms: t_FMap'0 = Any.any_l ()
    | & _22: t_Option'0 = Any.any_l ()
    | & _23: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _24: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _25: MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _27: t_Id = Any.any_l ()
    | & _29: t_Id = Any.any_l ()
    | & _31: t_PermCellOwn = Any.any_l ()
    | & _33: t_PermCellOwn = Any.any_l ()
    | & local_inv: t_LocalInvariant = Any.any_l ()
    | & _36: t_PA = Any.any_l ()
    | & _37: t_PA = Any.any_l ()
    | & _38: t_FMap'0 = Any.any_l ()
    | & _40: t_Authority = Any.any_l ()
    | & _42: Map.map t_Id int = Any.any_l ()
    | & _44: t_Id = Any.any_l ()
    | & _46: t_Namespace = Any.any_l ()
    | & _48: t_LocalInvariant = Any.any_l ()
    | & _50: t_Rc = Any.any_l () ])
    [ return (result: t_PersistentArray) -> {[@expl:new result type invariant] inv'24 result}
      {[@expl:new ensures] view'7 result = view v}
      (! return {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__set (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  use set.Set
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  type tuple = { f0: t_Id; f1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  function view'0 [@inline:trivial] (self: t_PersistentArray) : Seq.seq t_T = (view self.t_PersistentArray__frag).f1
  
  meta "rewrite_def" function view'0
  
  let rec clone' (self_: t_Rc) (return (x: t_Rc)) = any
    [ return' (result: t_Rc) -> {result = self_} (! return {result}) ]
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'1; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  type t_PermCell
  
  type t_PermCellOwn
  
  type tuple'0 = { f0'0: t_PermCell; f1'0: t_PermCellOwn }
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 (_1: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_1: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'1 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = inv'1 (view'1 self)
  
  predicate inv'2 (_1: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_1: t_Inner)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Inner [inv'3 x]. inv'3 x
      = match x with
        | C_Direct a_0 -> inv'2 a_0
        | C_Link index value next -> inv value
        end
  
  predicate invariant''2 [@inline:trivial] (self: t_Inner) = inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_1: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 [@inline:trivial] (self: t_PermCellOwn) = inv'4 (val' self)
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 (_1: t_PermCellOwn)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PermCellOwn [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_PermCellOwn) = inv'5 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'6 (_1: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_1: tuple'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: tuple'0 [inv'7 x]. inv'7 x = (let {f0'0 = x0; f1'0 = x1} = x in inv'6 x1)
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function view'2 [@inline:trivial] (self: t_PermCellOwn) : t_Inner = val' self
  
  meta "rewrite_def" function view'2
  
  let rec new (value: t_Inner) (return (x: tuple'0)) = {[@expl:new 'value' type invariant] inv'3 value}
    any
    [ return' (result: tuple'0) -> {inv'7 result}
      {id result.f0'0 = id'0 result.f1'0}
      {view'2 result.f1'0 = value}
      (! return {result}) ]
  
  type t_FMap
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view'3 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = Map.get (view'3 self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv'8 (_1: t_Id)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Id [inv'8 x]. inv'8 x = true
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. (exists x: t_PermCellOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''5 [@inline:trivial] (self: t_FMap) =
    forall k: t_Id. contains self k -> inv'8 k /\ inv'5 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'9 (_1: t_FMap)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_FMap [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 (self: t_Authority)
  
  predicate inv'10 (_1: t_Authority)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Authority [inv'10 x]. inv'10 x
      = (invariant''6 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'11 (_1: t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PA [inv'11 x]. inv'11 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'9 perms /\ inv'10 auth
        end
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'11 self.current /\ inv'11 self.final
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'12 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_PA [inv'12 x]. inv'12 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'12 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'13 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_PA [inv'13 x]. inv'13 x = invariant''8 x
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'13 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'14 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_PA [inv'14 x]. inv'14 x = invariant''9 x
  
  predicate invariant''10 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'12 self
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'15 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_PA [inv'15 x]. inv'15 x = invariant''10 x
  
  let rec deref (self: MutBorrow.t t_PA) (return (x: MutBorrow.t t_PA)) =
    {[@expl:deref 'self' type invariant] inv'14 self}
    any [ return' (result: MutBorrow.t t_PA) -> {inv'15 result} {result = self} (! return {result}) ]
  
  type closure0 = { c0: t_PersistentArray; c1: t_PermCell; c2: t_PermCellOwn; c3: Seq.seq t_T }
  
  predicate invariant''11 (self: t_Fragment)
  
  predicate inv'16 (_1: t_Fragment)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Fragment [inv'16 x]. inv'16 x
      = (invariant''11 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''12 [@inline:trivial] (self: t_Fragment) = inv'16 self
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'17 (_1: t_Fragment)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Fragment [inv'17 x]. inv'17 x = invariant''12 x
  
  predicate invariant''13 [@inline:trivial] (self: t_Fragment) = inv'17 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'18 (_1: t_Fragment)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Fragment [inv'18 x]. inv'18 x = invariant''13 x
  
  predicate invariant''14 [@inline:trivial] (self: t_Fragment) = inv'16 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'19 (_1: t_Fragment)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_Fragment [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec deref'0 (self: t_Fragment) (return (x: t_Fragment)) = {[@expl:deref 'self' type invariant] inv'18 self}
    any [ return' (result: t_Fragment) -> {inv'19 result} {result = self} (! return {result}) ]
  
  predicate invariant''15 [@inline:trivial] (self: t_Authority) = inv'10 self
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'20 (_1: t_Authority)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_Authority [inv'20 x]. inv'20 x = invariant''15 x
  
  function id'1 (self: t_Authority) : t_Id
  
  function id'2 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'4 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = Map.get (view'4 self) k
  
  meta "rewrite_def" function get'0
  
  function view'5 (self: t_Authority) : t_FMap'0
  
  let rec contains'0 (self: t_Authority) (frag: t_Fragment) (return (x: ())) =
    {[@expl:contains 'self' type invariant] inv'20 self}
    {[@expl:contains 'frag' type invariant] inv'19 frag}
    {[@expl:contains requires] id'1 self = id'2 frag}
    any [ return' (result: ()) -> {get'0 (view'5 self) (view frag).f0 = C_Some'0 ((view frag).f1)} (! return {result}) ]
  
  let rec id_ghost (self: t_PermCell) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = id self} (! return {result}) ]
  
  let rec into_inner (self: t_Id) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = self} (! return {result}) ]
  
  predicate invariant''16 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) =
    inv'13 self.current /\ inv'13 self.final
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'21 (_1: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'20 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'21 x]. inv'21 x = invariant''16 x
  
  predicate invariant''17 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) =
    inv'12 self.current /\ inv'12 self.final
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'22 (_1: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'21 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'22 x]. inv'22 x = invariant''17 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] inv'21 self}
    any [ return' (result: MutBorrow.t (MutBorrow.t t_PA)) -> {inv'22 result} {result = self} (! return {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_PermCellOwn)
  
  predicate invariant''18 [@inline:trivial] (self: MutBorrow.t t_FMap) = inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'23 (_1: MutBorrow.t t_FMap)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'23 x]. inv'23 x = invariant''18 x
  
  predicate invariant''19 [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''19
  
  predicate inv'24 (_1: MutBorrow.t t_PermCellOwn)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_PermCellOwn [inv'24 x]. inv'24 x = invariant''19 x
  
  predicate inv'25 (_1: t_Option'1)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_Option'1 [inv'25 x]. inv'25 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'24 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return (x: t_Option'1)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv'23 self}
    any
    [ return' (result: t_Option'1) -> {inv'25 result}
      {if contains self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {forall k: t_Id. k <> key -> get self.current k = get self.final k}
      {len self.current = len self.final}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_PermCellOwn) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_PA)) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  let rec v_Some (input: t_Option'1) (ret (field_0: MutBorrow.t t_PermCellOwn)) = any
    [ good (field_0: MutBorrow.t t_PermCellOwn) -> {C_Some'1 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_PermCellOwn [C_Some'1 field_0: t_Option'1]. C_Some'1 field_0 <> input}
      (! {false}
      any) ]
  
  predicate invariant''20 [@inline:trivial] (self: t_PermCellOwn) = inv'6 self
  
  meta "rewrite_def" predicate invariant''20
  
  predicate inv'26 (_1: t_PermCellOwn)
  
  axiom inv_axiom'25 [@rewrite]: forall x: t_PermCellOwn [inv'26 x]. inv'26 x = invariant''20 x
  
  predicate invariant''21 [@inline:trivial] (self: t_PermCellOwn) = inv'5 self
  
  meta "rewrite_def" predicate invariant''21
  
  predicate inv'27 (_1: t_PermCellOwn)
  
  axiom inv_axiom'26 [@rewrite]: forall x: t_PermCellOwn [inv'27 x]. inv'27 x = invariant''21 x
  
  let rec deref'1 (self: t_PermCellOwn) (return (x: t_PermCellOwn)) = {[@expl:deref 'self' type invariant] inv'26 self}
    any [ return' (result: t_PermCellOwn) -> {inv'27 result} {result = self} (! return {result}) ]
  
  let rec disjoint_lemma (own1: MutBorrow.t t_PermCellOwn) (own2: t_PermCellOwn) (return (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] inv'24 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] inv'27 own2}
    any [ return' (result: ()) -> {id'0 own1.current <> id'0 own2} {own1.current = own1.final} (! return {result}) ]
  
  let rec into_inner'0 (self: t_PermCellOwn) (return (x: t_PermCellOwn)) =
    {[@expl:into_inner 'self' type invariant] inv'6 self}
    any [ return' (result: t_PermCellOwn) -> {inv'5 result} {result = self} (! return {result}) ]
  
  predicate inv'28 (_1: t_Option)
  
  axiom inv_axiom'27 [@rewrite]: forall x: t_Option [inv'28 x]. inv'28 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'5 a_0
        end
  
  function insert (self: t_FMap) (k: t_Id) (v: t_PermCellOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: t_PermCellOwn. view'3 (insert self k v)
      = Map.set (view'3 self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: t_PermCellOwn. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (value: t_PermCellOwn) (return (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] inv'23 self}
    {[@expl:insert_ghost 'value' type invariant] inv'5 value}
    any
    [ return' (result: t_Option) -> {inv'28 result}
      {self.final = insert self.current key value}
      {result = get self.current key}
      (! return {result}) ]
  
  predicate resolve'3 [@inline:trivial] (_1: t_Inner) = true
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_PermCellOwn) = resolve'3 (val' self)
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: t_PermCellOwn) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (self: t_Option) =
    match self with
      | C_Some x -> resolve'5 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: t_Option) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  function index_logic'1 [@inline:trivial] (self: Map.map t_Id int) (a: t_Id) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function view'6 (self: t_Rc) : t_PermCell
  
  predicate invariant''22 [@inline:trivial] (self: MutBorrow.t t_Authority) = inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''22
  
  predicate inv'29 (_1: MutBorrow.t t_Authority)
  
  axiom inv_axiom'28 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'29 x]. inv'29 x = invariant''22 x
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains'1
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. len'0 self >= 0
  
  function insert'0 (self: t_FMap'0) (k: t_Id) (v: Seq.seq t_T) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_Id, v: Seq.seq t_T. view'4 (insert'0 self k v)
      = Map.set (view'4 self) k (C_Some'0 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_Id, v: Seq.seq t_T. len'0 (insert'0 self k v)
      = (if contains'1 self k then len'0 self else len'0 self + 1)
  
  let rec insert'1 (self: MutBorrow.t t_Authority) (k: t_Id) (v: Seq.seq t_T) (return (x: t_Fragment)) =
    {[@expl:insert 'self' type invariant] inv'29 self}
    {[@expl:insert requires] not contains'1 (view'5 self.current) k}
    any
    [ return' (result: t_Fragment) -> {inv'16 result}
      {view'5 self.final = insert'0 (view'5 self.current) k v}
      {id'1 self.final = id'1 self.current}
      {view result = { f0 = k; f1 = v }}
      {id'2 result = id'1 self.current}
      (! return {result}) ]
  
  predicate resolve'8 [@inline:trivial] (self: MutBorrow.t t_PA) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 [@inline:trivial] (_1: MutBorrow.t t_PA) = resolve'8 _1
  
  meta "rewrite_def" predicate resolve'9
  
  predicate resolve'10 [@inline:trivial] (self: MutBorrow.t t_PA) = resolve'9 self
  
  meta "rewrite_def" predicate resolve'10
  
  predicate resolve'11 [@inline:trivial] (_1: MutBorrow.t t_PA) = resolve'10 _1
  
  meta "rewrite_def" predicate resolve'11
  
  let rec new'0 (x: t_Fragment) (return (x'0: t_Fragment)) = {[@expl:new 'x' type invariant] inv'16 x}
    any [ return' (result: t_Fragment) -> {inv'17 result} {result = x} (! return {result}) ]
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'7 (self: t_Rc'0) : t_LocalInvariant
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''23 (self: t_PersistentArray) =
    (view self.t_PersistentArray__frag).f0 = id (view'6 self.t_PersistentArray__permcell)
    /\ id'2 self.t_PersistentArray__frag = public (view'7 self.t_PersistentArray__inv)
    /\ namespace (view'7 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'30 (_1: t_PersistentArray)
  
  axiom inv_axiom'29 [@rewrite]: forall x: t_PersistentArray [inv'30 x]. inv'30 x
      = (invariant''23 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'31} -> inv'17 frag
        end)
  
  predicate invariant''24 [@inline:trivial] (self: t_PersistentArray) = inv'30 self
  
  meta "rewrite_def" predicate invariant''24
  
  predicate inv'31 (_1: t_PersistentArray)
  
  axiom inv_axiom'30 [@rewrite]: forall x: t_PersistentArray [inv'31 x]. inv'31 x = invariant''24 x
  
  predicate invariant''25 [@inline:trivial] (self: t_PersistentArray) = inv'31 self
  
  meta "rewrite_def" predicate invariant''25
  
  predicate inv'32 (_1: t_PersistentArray)
  
  axiom inv_axiom'31 [@rewrite]: forall x: t_PersistentArray [inv'32 x]. inv'32 x = invariant''25 x
  
  predicate inv'33 (_1: closure0)
  
  axiom inv_axiom'32 [@rewrite]: forall x: closure0 [inv'33 x]. inv'33 x
      = (let {c0 = x0; c1 = x1; c2 = x2; c3 = x3} = x in inv'32 x0 /\ inv'6 x2)
  
  let rec closure0 [@coma:extspec] (self: closure0) (pa: MutBorrow.t t_PA) (return (x: t_Fragment)) = bb0
    [ bb0 = s0 [ s0 = deref {pa} (fun (_ret: MutBorrow.t t_PA) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_11 <- self.c0.t_PersistentArray__frag ] s1
      | s1 = deref'0 {_11} (fun (_ret: t_Fragment) -> [ &_9 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = contains'0 {_6.current.t_PA__auth} {_9} (fun (_ret: ()) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = id_ghost {self.c1} (fun (_ret: t_Id) -> [ &_13 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_inner {_13} (fun (_ret: t_Id) -> [ &cell_id <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'13 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_19 <- _ret ] -{inv'13 _ret.final}-
            [ &pa <- _ret.final ] s1)
      | s1 = deref_mut {_19} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_18 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_21 <- cell_id ] s1
      | s1 = {inv'9 _18.current.current.t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {_18.current.current.t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_17 <- _ret ] -{inv'9 _ret.final}-
            [ &_18 <- { _18 with current = { _18.current with current = { _18.current.current with t_PA__perms = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_17} {_21} (fun (_ret: t_Option'1) -> [ &_16 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = any
      [ br0 -> {_16 = C_None'1} (! bb12) | br1 (x0: MutBorrow.t t_PermCellOwn) -> {_16 = C_Some'1 x0} (! bb9) ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] match _16 with
          | C_Some'1 x -> inv'24 x
          | _ -> true
          end}
        s1
      | s1 = -{match _16 with
          | C_Some'1 x -> resolve'0 x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] inv'22 _18} s3
      | s3 = -{resolve'2 _18}- s4
      | s4 = bb13 ]
    | bb9 = s0
      [ s0 = v_Some {_16} (fun (r0: MutBorrow.t t_PermCellOwn) -> [ &other <- r0 ] s1)
      | s1 = [ &_29 <- self.c2 ] s2
      | s2 = deref'1 {_29} (fun (_ret: t_PermCellOwn) -> [ &_27 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'5 other.current}
        MutBorrow.borrow_final <t_PermCellOwn> {other.current} {MutBorrow.get_id other}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_25 <- _ret ] -{inv'5 _ret.final}-
            [ &other <- { other with current = _ret.final } ] s1)
      | s1 = disjoint_lemma {_25} {_27} (fun (_ret: ()) -> [ &_24 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'24 other} s1
      | s1 = -{resolve'0 other}- s2
      | s2 = {[@expl:type invariant] inv'22 _18} s3
      | s3 = -{resolve'2 _18}- s4
      | s4 = bb13 ]
    | bb13 = s0
      [ s0 = {inv'13 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_33 <- _ret ] -{inv'13 _ret.final}-
            [ &pa <- _ret.final ] s1)
      | s1 = deref_mut {_33} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_32 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0 [ s0 = into_inner'0 {self.c2} (fun (_ret: t_PermCellOwn) -> [ &_35 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'9 _32.current.current.t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {_32.current.current.t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_31 <- _ret ] -{inv'9 _ret.final}-
            [ &_32 <- { _32 with current = { _32.current with current = { _32.current.current with t_PA__perms = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_31} {cell_id} {_35} (fun (_ret: t_Option) -> [ &_30 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'28 _30} s3
      | s3 = -{resolve'7 _30}- s4
      | s4 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'22 _32} s1
      | s1 = -{resolve'2 _32}- s2
      | s2 =
        [ &_37 <- Map.set pa.current.t_PA__depth cell_id (index_logic'1 pa.current.t_PA__depth (id (view'6 self.c0.t_PersistentArray__permcell))
        + 1) ] s3
      | s3 = bb17 ]
    | bb17 = s0
      [ s0 = {inv'13 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_40 <- _ret ] -{inv'13 _ret.final}-
            [ &pa <- _ret.final ] s1)
      | s1 = deref_mut {_40} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_39 <- _ret ] s2)
      | s2 = bb18 ]
    | bb18 = s0
      [ s0 =
        [ &_39 <- { _39 with current = { _39.current with current = { _39.current.current with t_PA__depth = _37 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'22 _39} s2
      | s2 = -{resolve'2 _39}- s3
      | s3 = {inv'13 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_43 <- _ret ] -{inv'13 _ret.final}-
            [ &pa <- _ret.final ] s4)
      | s4 = deref_mut {_43} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_42 <- _ret ] s5)
      | s5 = bb19 ]
    | bb19 = s0 [ s0 = [ &_44 <- cell_id ] s1 | s1 = bb20 ]
    | bb20 = s0
      [ s0 = {inv'10 _42.current.current.t_PA__auth}
        MutBorrow.borrow_mut <t_Authority> {_42.current.current.t_PA__auth}
          (fun (_ret: MutBorrow.t t_Authority) ->
            [ &_41 <- _ret ] -{inv'10 _ret.final}-
            [ &_42 <- { _42 with current = { _42.current with current = { _42.current.current with t_PA__auth = _ret.final } } } ]
            s1)
      | s1 = insert'1 {_41} {_44} {self.c3} (fun (_ret: t_Fragment) -> [ &_3 <- _ret ] s2)
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = {[@expl:type invariant] inv'22 _42} s1
      | s1 = -{resolve'2 _42}- s2
      | s2 = {[@expl:type invariant] inv'13 pa} s3
      | s3 = -{resolve'11 pa}- s4
      | s4 = new'0 {_3} (fun (_ret: t_Fragment) -> [ &_0 <- _ret ] s5)
      | s5 = bb22 ]
    | bb22 = return {_0} ]
    [ & _0: t_Fragment = Any.any_l ()
    | & self: closure0 = self
    | & pa: MutBorrow.t t_PA = pa
    | & _3: t_Fragment = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _6: MutBorrow.t t_PA = Any.any_l ()
    | & _9: t_Fragment = Any.any_l ()
    | & _11: t_Fragment = Any.any_l ()
    | & cell_id: t_Id = Any.any_l ()
    | & _13: t_Id = Any.any_l ()
    | & _16: t_Option'1 = Any.any_l ()
    | & _17: MutBorrow.t t_FMap = Any.any_l ()
    | & _18: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _19: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _21: t_Id = Any.any_l ()
    | & other: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _27: t_PermCellOwn = Any.any_l ()
    | & _29: t_PermCellOwn = Any.any_l ()
    | & _30: t_Option = Any.any_l ()
    | & _31: MutBorrow.t t_FMap = Any.any_l ()
    | & _32: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _33: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _35: t_PermCellOwn = Any.any_l ()
    | & _37: Map.map t_Id int = Any.any_l ()
    | & _39: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _40: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _41: MutBorrow.t t_Authority = Any.any_l ()
    | & _42: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _43: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _44: t_Id = Any.any_l () ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  type t_Tokens
  
  type tuple'1 = { f0'1: t_Rc'0; f1'1: t_Tokens; f2: closure0 }
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: t_Rc'0) (result: t_LocalInvariant) =
    let self_ = args in result = view'7 self_
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve'12 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'12
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: t_Rc'0) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view'7 self_
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: t_Rc'0) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_Rc'0, res: t_LocalInvariant. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'12 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc'0) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Rc'0, res_state: (), res: t_LocalInvariant. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: t_Rc'0) (result: t_LocalInvariant) =
    let self_ = args in result = view'7 self_
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: t_Rc'0) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc'0, res: t_LocalInvariant. postcondition_once self args res
      = (postcondition self args res /\ resolve'12 self)
  
  function fn_mut (self: ()) (args: t_Rc'0) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Rc'0, res_state: (), res: t_LocalInvariant. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  type tuple'2 = { f0'2: t_LocalInvariant; f1'2: t_Tokens; f2'0: closure0 }
  
  predicate index_logic'2 [@inline:trivial] (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'2
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. (exists x: Seq.seq t_T. index_logic'2 p x)
      -> index_logic'2 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T = unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'3 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = lookup'0 self key
  
  meta "rewrite_def" function index_logic'3
  
  predicate partial_invariant [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    id'1 self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains'1 (view'5 self.t_PA__auth) id'3 /\ contains self.t_PA__perms id'3
      -> id'0 (index_logic'0 self.t_PA__perms id'3) = id'3
      /\ match val' (index_logic'0 self.t_PA__perms id'3) with
        | C_Direct v -> index_logic'3 (view'5 self.t_PA__auth) id'3 = view'1 v
        | C_Link index value next -> contains'1 (view'5 self.t_PA__auth) (id (view'6 next))
        /\ index_logic'1 self.t_PA__depth id'3 > index_logic'1 self.t_PA__depth (id (view'6 next))
        /\ UInt64.t'int index < Seq.length (index_logic'3 (view'5 self.t_PA__auth) (id (view'6 next)))
        /\ index_logic'3 (view'5 self.t_PA__auth) id'3
        = Seq.set (index_logic'3 (view'5 self.t_PA__auth) (id (view'6 next))) (UInt64.t'int index) value
        end)
  
  meta "rewrite_def" predicate partial_invariant
  
  predicate protocol [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    partial_invariant self resource_id
    /\ (forall id'3: t_Id. contains'1 (view'5 self.t_PA__auth) id'3 -> contains self.t_PA__perms id'3)
  
  meta "rewrite_def" predicate protocol
  
  predicate precondition [@inline:trivial] (self: closure0) (args: MutBorrow.t t_PA) =
    let pa = args in closure0'pre self pa
  
  meta "rewrite_def" predicate precondition
  
  predicate postcondition_once'0 [@inline:trivial] (self: closure0) (args: MutBorrow.t t_PA) (result: t_Fragment) =
    let pa = args in closure0'post'return self pa result
  
  meta "rewrite_def" predicate postcondition_once'0
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PA) : t_PA = self.final
  
  meta "rewrite_def" function fin
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = Set.mem e self
  
  meta "rewrite_def" predicate contains'2
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'3 (self: t_Tokens) (namespace'0: t_Namespace) = contains'2 (namespaces self) namespace'0
  
  predicate precondition'0 [@inline:trivial] (self: ()) (args: tuple'2) =
    let {f0'2 = self'0; f1'2 = tokens; f2'0 = f} = args in (forall t: MutBorrow.t t_PA. protocol t.current (public self'0)
          /\ inv'13 t
        -> precondition f t
        /\ (forall res: t_Fragment. postcondition_once'0 f t res -> protocol (fin t) (public self'0)))
    /\ contains'3 tokens (namespace self'0) /\ inv'33 f
  
  meta "rewrite_def" predicate precondition'0
  
  function new_logic (x: t_LocalInvariant) : t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. new_logic x = x
  
  predicate precondition'1 [@inline:trivial] (self: ()) (args: t_Rc'0) = let self_ = args in true
  
  meta "rewrite_def" predicate precondition'1
  
  predicate precondition'2 [@inline:trivial] (self: ()) (args: tuple'1) =
    let {f0'1 = self'0; f1'1 = tokens; f2 = f} = args in (forall this: t_LocalInvariant. postcondition () self'0 this
        -> precondition'0 () { f0'2 = new_logic this; f1'2 = tokens; f2'0 = f })
    /\ precondition'1 () self'0 /\ inv'33 f
  
  meta "rewrite_def" predicate precondition'2
  
  let rec deref'2 (self_: t_Rc'0) (return (x: t_LocalInvariant)) = any
    [ return' (result: t_LocalInvariant) -> {result = view'7 self_} (! return {result}) ]
  
  let rec open (self: t_LocalInvariant) (tokens: t_Tokens) (f: closure0) (return (x: t_Fragment)) =
    {[@expl:open 'f' type invariant] inv'33 f}
    {[@expl:open requires #0] contains'3 tokens (namespace self)}
    {[@expl:open requires #1] forall t: MutBorrow.t t_PA. protocol t.current (public self) /\ inv'13 t
      -> precondition f t /\ (forall res: t_Fragment. postcondition_once'0 f t res -> protocol (fin t) (public self))}
    any
    [ return' (result: t_Fragment) -> {inv'17 result}
      {exists t: MutBorrow.t t_PA. protocol t.current (public self) /\ postcondition_once'0 f t result}
      (! return {result}) ]
  
  predicate postcondition_once'1 [@inline:trivial] (self: ()) (args: tuple'2) (result: t_Fragment) =
    let {f0'2 = self'0; f1'2 = tokens; f2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'17 result
  
  meta "rewrite_def" predicate postcondition_once'1
  
  predicate resolve'13 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'13
  
  predicate postcondition_mut'0 [@inline:trivial] (self: ()) (args: tuple'2) (result_state: ()) (result: t_Fragment) =
    let {f0'2 = self'0; f1'2 = tokens; f2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'17 result
  
  meta "rewrite_def" predicate postcondition_mut'0
  
  function fn_mut_once'0 (self: ()) (args: tuple'2) (res: t_Fragment) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'2, res: t_Fragment. postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'13 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'2) (res_state: ()) (res: t_Fragment) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: tuple'2, res_state: (), res: t_Fragment. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 [@inline:trivial] (self: ()) (args: tuple'2) (result: t_Fragment) =
    let {f0'2 = self'0; f1'2 = tokens; f2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'17 result
  
  meta "rewrite_def" predicate postcondition'0
  
  function fn_once'0 (self: ()) (args: tuple'2) (res: t_Fragment) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'2, res: t_Fragment. postcondition_once'1 self args res
      = (postcondition'0 self args res /\ resolve'13 self)
  
  function fn_mut'0 (self: ()) (args: tuple'2) (res_state: ()) (res: t_Fragment) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: tuple'2, res_state: (), res: t_Fragment. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc'0) (tokens: t_Tokens) (f: closure0) (return (x: t_Fragment)) =
    {[@expl:open 'f' type invariant] inv'33 f}
    {[@expl:open requires #0] precondition'1 () self}
    {[@expl:open requires #1] forall this: t_LocalInvariant. postcondition () self this
      -> precondition'0 () { f0'2 = new_logic this; f1'2 = tokens; f2'0 = f }}
    any
    [ return' (result: t_Fragment) -> {inv'17 result}
      {exists this: t_LocalInvariant. postcondition () self this
        /\ postcondition'0 () { f0'2 = new_logic this; f1'2 = tokens; f2'0 = f } result}
      (! return {result}) ]
  
  function new_logic'0 (x: t_Rc'0) : t_Rc'0
  
  axiom new_logic_spec'0: forall x: t_Rc'0. new_logic'0 x = x
  
  predicate postcondition_once'2 [@inline:trivial] (self: ()) (args: tuple'1) (result: t_Fragment) =
    let {f0'1 = self'0; f1'1 = tokens; f2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { f0'2 = new_logic this; f1'2 = tokens; f2'0 = f } result)
    /\ inv'17 result
  
  meta "rewrite_def" predicate postcondition_once'2
  
  predicate resolve'14 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'14
  
  predicate postcondition_mut'1 [@inline:trivial] (self: ()) (args: tuple'1) (result_state: ()) (result: t_Fragment) =
    let {f0'1 = self'0; f1'1 = tokens; f2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { f0'2 = new_logic this; f1'2 = tokens; f2'0 = f } result)
    /\ inv'17 result
  
  meta "rewrite_def" predicate postcondition_mut'1
  
  function fn_mut_once'1 (self: ()) (args: tuple'1) (res: t_Fragment) : ()
  
  axiom fn_mut_once_spec'1: forall self: (), args: tuple'1, res: t_Fragment. postcondition_once'2 self args res
      = (exists res_state: (). postcondition_mut'1 self args res_state res /\ resolve'14 res_state)
  
  predicate hist_inv'1 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'1
  
  function hist_inv_trans'1 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'1: forall self: (), b: (), c: (). hist_inv'1 self b -> hist_inv'1 b c -> hist_inv'1 self c
  
  function hist_inv_refl'1 (self: ()) : ()
  
  axiom hist_inv_refl_spec'1: forall self: (). hist_inv'1 self self
  
  function postcondition_mut_hist_inv'1 (self: ()) (args: tuple'1) (res_state: ()) (res: t_Fragment) : ()
  
  axiom postcondition_mut_hist_inv_spec'1:
    forall self: (), args: tuple'1, res_state: (), res: t_Fragment. postcondition_mut'1 self args res_state res
      -> hist_inv'1 self res_state
  
  function fn_hist_inv'1 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'1: forall self: (), res_state: (). hist_inv'1 self res_state = (self = res_state)
  
  predicate postcondition'1 [@inline:trivial] (self: ()) (args: tuple'1) (result: t_Fragment) =
    let {f0'1 = self'0; f1'1 = tokens; f2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { f0'2 = new_logic this; f1'2 = tokens; f2'0 = f } result)
    /\ inv'17 result
  
  meta "rewrite_def" predicate postcondition'1
  
  function fn_once'1 (self: ()) (args: tuple'1) (res: t_Fragment) : ()
  
  axiom fn_once_spec'1: forall self: (), args: tuple'1, res: t_Fragment. postcondition_once'2 self args res
      = (postcondition'1 self args res /\ resolve'14 self)
  
  function fn_mut'1 (self: ()) (args: tuple'1) (res_state: ()) (res: t_Fragment) : ()
  
  axiom fn_mut_spec'1:
    forall self: (), args: tuple'1, res_state: (), res: t_Fragment. postcondition_mut'1 self args res_state res
      = (postcondition'1 self args res /\ self = res_state)
  
  let rec open'1 (self: t_Rc'0) (tokens: t_Tokens) (f: closure0) (return (x: t_Fragment)) =
    {[@expl:open 'f' type invariant] inv'33 f}
    {[@expl:open requires] precondition'2 () { f0'1 = new_logic'0 self; f1'1 = tokens; f2 = f }}
    any
    [ return' (result: t_Fragment) -> {inv'17 result}
      {postcondition'1 () { f0'1 = new_logic'0 self; f1'1 = tokens; f2 = f } result}
      (! return {result}) ]
  
  let rec new'1 (value: t_PermCell) (return (x: t_Rc)) = any
    [ return' (result: t_Rc) -> {view'6 result = value} (! return {result}) ]
  
  let rec deref'3 (self: t_Rc'0) (return (x: t_Rc'0)) = any
    [ return' (result: t_Rc'0) -> {result = self} (! return {result}) ]
  
  let rec clone''0 (self_: t_Rc'0) (return (x: t_Rc'0)) = any
    [ return' (result: t_Rc'0) -> {result = self_} (! return {result}) ]
  
  let rec new'2 (x: t_Rc'0) (return (x'0: t_Rc'0)) = any
    [ return' (result: t_Rc'0) -> {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec set (self: t_PersistentArray) (index: UInt64.t) (value: t_T) (tokens: t_Tokens)
    (return (x: t_PersistentArray)) = {[@expl:set 'self' type invariant] inv'31 self}
    {[@expl:set 'value' type invariant] inv value}
    {[@expl:set requires #0] UInt64.t'int index < Seq.length (view'0 self)}
    {[@expl:set requires #1] contains'3 tokens (Namespace_PARRAY 0)}
    (! bb0
    [ bb0 = s0 [ s0 = [ &new_seq <- Seq.set (view'0 self) (UInt64.t'int index) value ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = clone' {self.t_PersistentArray__permcell} (fun (_ret: t_Rc) -> [ &_16 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_13 <- C_Link index value _16 ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_13} (fun (_ret: tuple'0) -> [ &_12 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &permcell <- _12.f0'0 ] s1 | s1 = [ &permcellown <- _12.f1'0 ] s2 | s2 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_21 <- { c0 = self; c1 = permcell; c2 = permcellown; c3 = new_seq } ] s1
      | s1 = open'1 {self.t_PersistentArray__inv} {tokens} {_21} (fun (_ret: t_Fragment) -> [ &frag <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0 [ s0 = new'1 {permcell} (fun (_ret: t_Rc) -> [ &_25 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = deref'3 {self.t_PersistentArray__inv} (fun (_ret: t_Rc'0) -> [ &_31 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0 [ s0 = clone''0 {_31} (fun (_ret: t_Rc'0) -> [ &_29 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = new'2 {_29} (fun (_ret: t_Rc'0) -> [ &_28 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = [ &_0 <- { t_PersistentArray__permcell = _25;
                        t_PersistentArray__frag = frag;
                        t_PersistentArray__inv = _28 } ] s1
      | s1 = bb14 ]
    | bb14 = return {_0} ]
    [ & _0: t_PersistentArray = Any.any_l ()
    | & self: t_PersistentArray = self
    | & index: UInt64.t = index
    | & value: t_T = value
    | & tokens: t_Tokens = tokens
    | & new_seq: Seq.seq t_T = Any.any_l ()
    | & permcell: t_PermCell = Any.any_l ()
    | & permcellown: t_PermCellOwn = Any.any_l ()
    | & _12: tuple'0 = Any.any_l ()
    | & _13: t_Inner = Any.any_l ()
    | & _16: t_Rc = Any.any_l ()
    | & frag: t_Fragment = Any.any_l ()
    | & _21: closure0 = Any.any_l ()
    | & _25: t_Rc = Any.any_l ()
    | & _28: t_Rc'0 = Any.any_l ()
    | & _29: t_Rc'0 = Any.any_l ()
    | & _31: t_Rc'0 = Any.any_l () ])
    [ return (result: t_PersistentArray) -> {[@expl:set result type invariant] inv'30 result}
      {[@expl:set ensures] view'0 result = Seq.set (view'0 self) (UInt64.t'int index) value}
      (! return {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get_immut (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use creusot.prelude.Opaque
  use seq.Seq
  use map.Map
  use set.Set
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc'0;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc }
  
  let rec deref (self: t_Rc) (return (x: t_Rc)) = any [ return' (result: t_Rc) -> {result = self} (! return {result}) ]
  
  type t_LocalInvariant
  
  function view (self: t_Rc) : t_LocalInvariant
  
  let rec deref'0 (self_: t_Rc) (return (x: t_LocalInvariant)) = any
    [ return' (result: t_LocalInvariant) -> {result = view self_} (! return {result}) ]
  
  type t_Tokens
  
  let rec deref'1 (self: t_Tokens) (return (x: t_Tokens)) = any
    [ return' (result: t_Tokens) -> {result = self} (! return {result}) ]
  
  type t_FMap
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  predicate contains [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = Set.mem e self
  
  meta "rewrite_def" predicate contains
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'0 (self: t_Tokens) (namespace: t_Namespace) = contains (namespaces self) namespace
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  type t_PermCellOwn
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view'0 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  predicate contains'1 [@inline:trivial] (self: t_FMap) (k: t_Id) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'1
  
  predicate inv (_1: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'1; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc'0
  
  predicate inv'0 (_1: t_T)
  
  predicate invariant' (self: t_T) = inv'0 self
  
  predicate inv'1 (_1: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'1 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = inv'2 (view'1 self)
  
  predicate inv'3 (_1: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_1: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 [@inline:trivial] (self: t_Inner) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 [@inline:trivial] (self: t_PermCellOwn) = inv'5 (val' self)
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. (exists x: t_PermCellOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''4 [@inline:trivial] (self: t_FMap) =
    forall k: t_Id. contains'1 self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_1: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_1: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'7 perms /\ inv'8 auth
        end
  
  predicate invariant''6 [@inline:trivial] (self: t_PA) = inv'9 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_1: t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  function id (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'2 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = Map.get (view'2 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'2 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains'2
  
  function view'3 (self: t_Authority) : t_FMap'0
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. (exists x: Seq.seq t_T. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T = unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  type t_PermCell
  
  function id'1 (self: t_PermCell) : t_Id
  
  function view'4 (self: t_Rc'0) : t_PermCell
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Id int) (a: t_Id) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate partial_invariant [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    id self.t_PA__auth = resource_id
    /\ (forall id'2: t_Id. contains'2 (view'3 self.t_PA__auth) id'2 /\ contains'1 self.t_PA__perms id'2
      -> id'0 (index_logic'0 self.t_PA__perms id'2) = id'2
      /\ match val' (index_logic'0 self.t_PA__perms id'2) with
        | C_Direct v -> index_logic'2 (view'3 self.t_PA__auth) id'2 = view'1 v
        | C_Link index value next -> contains'2 (view'3 self.t_PA__auth) (id'1 (view'4 next))
        /\ index_logic'3 self.t_PA__depth id'2 > index_logic'3 self.t_PA__depth (id'1 (view'4 next))
        /\ UInt64.t'int index < Seq.length (index_logic'2 (view'3 self.t_PA__auth) (id'1 (view'4 next)))
        /\ index_logic'2 (view'3 self.t_PA__auth) id'2
        = Seq.set (index_logic'2 (view'3 self.t_PA__auth) (id'1 (view'4 next))) (UInt64.t'int index) value
        end)
  
  meta "rewrite_def" predicate partial_invariant
  
  predicate protocol [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    partial_invariant self resource_id
    /\ (forall id'2: t_Id. contains'2 (view'3 self.t_PA__auth) id'2 -> contains'1 self.t_PA__perms id'2)
  
  meta "rewrite_def" predicate protocol
  
  function public (self: t_LocalInvariant) : t_Id
  
  let rec open_const (self: t_LocalInvariant) (tokens: t_Tokens) (return (x: t_PA)) =
    {[@expl:open_const requires] contains'0 tokens (namespace self)}
    any [ return' (result: t_PA) -> {inv'10 result} {protocol result (public self)} (! return {result}) ]
  
  predicate invariant''7 [@inline:trivial] (self: t_PA) = inv'10 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'11 (_1: t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  let rec new (x: t_PA) (return (x'0: t_PA)) = {[@expl:new 'x' type invariant] inv'10 x}
    any [ return' (result: t_PA) -> {inv'11 result} {result = x} (! return {result}) ]
  
  predicate invariant''8 [@inline:trivial] (self: t_PA) = inv'11 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_1: t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 [@inline:trivial] (self: t_PA) = inv'10 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_1: t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref'2 (self: t_PA) (return (x: t_PA)) = {[@expl:deref 'self' type invariant] inv'12 self}
    any [ return' (result: t_PA) -> {inv'13 result} {result = self} (! return {result}) ]
  
  predicate invariant''10 (self: t_Fragment)
  
  predicate inv'14 (_1: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
      = (invariant''10 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''11 [@inline:trivial] (self: t_Fragment) = inv'14 self
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'15 (_1: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate invariant''12 [@inline:trivial] (self: t_Fragment) = inv'15 self
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'16 (_1: t_Fragment)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Fragment [inv'16 x]. inv'16 x = invariant''12 x
  
  predicate invariant''13 [@inline:trivial] (self: t_Fragment) = inv'14 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'17 (_1: t_Fragment)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Fragment [inv'17 x]. inv'17 x = invariant''13 x
  
  let rec deref'3 (self: t_Fragment) (return (x: t_Fragment)) = {[@expl:deref 'self' type invariant] inv'16 self}
    any [ return' (result: t_Fragment) -> {inv'17 result} {result = self} (! return {result}) ]
  
  predicate invariant''14 [@inline:trivial] (self: t_Authority) = inv'8 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'18 (_1: t_Authority)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Authority [inv'18 x]. inv'18 x = invariant''14 x
  
  function id'2 (self: t_Fragment) : t_Id
  
  type tuple = { f0: t_Id; f1: Seq.seq t_T }
  
  function view'5 (self: t_Fragment) : tuple
  
  let rec contains'3 (self: t_Authority) (frag: t_Fragment) (return (x: ())) =
    {[@expl:contains 'self' type invariant] inv'18 self}
    {[@expl:contains 'frag' type invariant] inv'17 frag}
    {[@expl:contains requires] id self = id'2 frag}
    any
    [ return' (result: ()) -> {get'0 (view'3 self) (view'5 frag).f0 = C_Some'0 ((view'5 frag).f1)} (! return {result}) ]
  
  let rec new'0 (x: ()) (return (x'0: ())) = any [ return' (result: ()) -> {result = x} (! return {result}) ]
  
  predicate invariant''15 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'19 (_1: t_T)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_T [inv'19 x]. inv'19 x = invariant''15 x
  
  let rec get_inner_immut (inner: t_Rc'0) (i: UInt64.t) (pa: t_PA) (return (x: t_T)) =
    {[@expl:get_inner_immut 'pa' type invariant] inv'11 pa}
    {[@expl:get_inner_immut requires #0] exists p: t_Id. protocol pa p}
    {[@expl:get_inner_immut requires #1] contains'2 (view'3 pa.t_PA__auth) (id'1 (view'4 inner))}
    {[@expl:get_inner_immut requires #2] UInt64.t'int i
    < Seq.length (index_logic'2 (view'3 pa.t_PA__auth) (id'1 (view'4 inner)))}
    any
    [ return' (result: t_T) -> {inv'19 result}
      {result = Seq.get (index_logic'2 (view'3 pa.t_PA__auth) (id'1 (view'4 inner))) (UInt64.t'int i)}
      (! return {result}) ]
  
  predicate invariant''16 (self: t_PersistentArray) =
    (view'5 self.t_PersistentArray__frag).f0 = id'1 (view'4 self.t_PersistentArray__permcell)
    /\ id'2 self.t_PersistentArray__frag = public (view self.t_PersistentArray__inv)
    /\ namespace (view self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'20 (_1: t_PersistentArray)
  
  axiom inv_axiom'19 [@rewrite]: forall x: t_PersistentArray [inv'20 x]. inv'20 x
      = (invariant''16 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'21} -> inv'15 frag
        end)
  
  predicate invariant''17 [@inline:trivial] (self: t_PersistentArray) = inv'20 self
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'21 (_1: t_PersistentArray)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_PersistentArray [inv'21 x]. inv'21 x = invariant''17 x
  
  function view'6 [@inline:trivial] (self: t_PersistentArray) : Seq.seq t_T = (view'5 self.t_PersistentArray__frag).f1
  
  meta "rewrite_def" function view'6
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_immut (self: t_PersistentArray) (index: UInt64.t) (tokens: t_Tokens) (return (x: t_T)) =
    {[@expl:get_immut 'self' type invariant] inv'21 self}
    {[@expl:get_immut requires #0] contains'0 tokens (Namespace_PARRAY 0)}
    {[@expl:get_immut requires #1] UInt64.t'int index < Seq.length (view'6 self)}
    (! bb0
    [ bb0 = s0 [ s0 = deref {self.t_PersistentArray__inv} (fun (_ret: t_Rc) -> [ &_12 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref'0 {_12} (fun (_ret: t_LocalInvariant) -> [ &_10 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = deref'1 {tokens} (fun (_ret: t_Tokens) -> [ &_15 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = open_const {_10} {_15} (fun (_ret: t_PA) -> [ &_8 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = new {_8} (fun (_ret: t_PA) -> [ &pa <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = deref'2 {pa} (fun (_ret: t_PA) -> [ &_20 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_25 <- self.t_PersistentArray__frag ] s1
      | s1 = deref'3 {_25} (fun (_ret: t_Fragment) -> [ &_23 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0 [ s0 = contains'3 {_20.t_PA__auth} {_23} (fun (_ret: ()) -> [ &_18 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = new'0 {_18} (fun (_ret: ()) -> [ &_17 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_28 <- self.t_PersistentArray__permcell ] s1
      | s1 = get_inner_immut {_28} {index} {pa} (fun (_ret: t_T) -> [ &_26 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0 [ s0 = [ &_0 <- _26 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & self: t_PersistentArray = self
    | & index: UInt64.t = index
    | & tokens: t_Tokens = tokens
    | & pa: t_PA = Any.any_l ()
    | & _8: t_PA = Any.any_l ()
    | & _10: t_LocalInvariant = Any.any_l ()
    | & _12: t_Rc = Any.any_l ()
    | & _15: t_Tokens = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: () = Any.any_l ()
    | & _20: t_PA = Any.any_l ()
    | & _23: t_Fragment = Any.any_l ()
    | & _25: t_Fragment = Any.any_l ()
    | & _26: t_T = Any.any_l ()
    | & _28: t_Rc'0 = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:get_immut result type invariant] inv'19 result}
      {[@expl:get_immut ensures] result = Seq.get (view'6 self) (UInt64.t'int index)}
      (! return {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get_inner_immut (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use creusot.prelude.Opaque
  use map.Map
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_PermCell
  
  function view (self: t_Rc) : t_PermCell
  
  let rec deref (self_: t_Rc) (return (x: t_PermCell)) = any
    [ return' (result: t_PermCell) -> {result = view self_} (! return {result}) ]
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Id
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  type t_PermCellOwn
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view'0 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'0; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  predicate inv'0 (_1: t_T)
  
  predicate invariant' (self: t_T) = inv'0 self
  
  predicate inv'1 (_1: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'1 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = inv'2 (view'1 self)
  
  predicate inv'3 (_1: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_1: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 [@inline:trivial] (self: t_Inner) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 [@inline:trivial] (self: t_PermCellOwn) = inv'5 (val' self)
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. (exists x: t_PermCellOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''4 [@inline:trivial] (self: t_FMap) =
    forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_1: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_1: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'7 perms /\ inv'8 auth
        end
  
  predicate invariant''6 [@inline:trivial] (self: t_PA) = inv'9 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_1: t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: t_PA) = inv'10 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'11 (_1: t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: t_PA) = inv'11 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_1: t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 [@inline:trivial] (self: t_PA) = inv'10 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_1: t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref'0 (self: t_PA) (return (x: t_PA)) = {[@expl:deref 'self' type invariant] inv'12 self}
    any [ return' (result: t_PA) -> {inv'13 result} {result = self} (! return {result}) ]
  
  function id (self: t_PermCell) : t_Id
  
  let rec id_ghost (self: t_PermCell) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = id self} (! return {result}) ]
  
  let rec deref'1 (self: t_Id) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = self} (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_PermCellOwn
  
  predicate invariant''10 [@inline:trivial] (self: t_FMap) = inv'7 self
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'14 (_1: t_FMap)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_FMap [inv'14 x]. inv'14 x = invariant''10 x
  
  predicate invariant''11 [@inline:trivial] (self: t_PermCellOwn) = inv'6 self
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'15 (_1: t_PermCellOwn)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_PermCellOwn [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate inv'16 (_1: t_Option'0)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Option'0 [inv'16 x]. inv'16 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'15 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PermCellOwn t_PermCellOwn) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Id) (return (x: t_Option'0)) =
    {[@expl:get_ghost 'self' type invariant] inv'14 self}
    any
    [ return' (result: t_Option'0) -> {inv'16 result}
      {result = map_logic (get self key) (fun (v: t_PermCellOwn) -> v)}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: t_PermCellOwn)) = {[@expl:unwrap 'self_' type invariant] inv'16 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: t_PermCellOwn) -> {inv'15 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate invariant''12 [@inline:trivial] (self: t_PermCellOwn) = inv'15 self
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'17 (_1: t_PermCellOwn)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_PermCellOwn [inv'17 x]. inv'17 x = invariant''12 x
  
  let rec new (x: t_PermCellOwn) (return (x'0: t_PermCellOwn)) = {[@expl:new 'x' type invariant] inv'15 x}
    any [ return' (result: t_PermCellOwn) -> {inv'17 result} {result = x} (! return {result}) ]
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function view'2 [@inline:trivial] (self: t_PermCellOwn) : t_Inner = val' self
  
  meta "rewrite_def" function view'2
  
  let rec borrow (self: t_PermCell) (perm: t_PermCellOwn) (return (x: t_Inner)) =
    {[@expl:borrow 'perm' type invariant] inv'17 perm}
    {[@expl:borrow requires] id self = id'0 perm}
    any [ return' (result: t_Inner) -> {inv'5 result} {result = view'2 perm} (! return {result}) ]
  
  let rec v_Link (input: t_Inner) (ret (index: UInt64.t) (value: t_T) (next: t_Rc)) = any
    [ good (index: UInt64.t) (value: t_T) (next: t_Rc) -> {C_Link index value next = input}
      (! ret {index} {value} {next})
    | bad -> {forall index: UInt64.t, value: t_T, next: t_Rc [C_Link index value next: t_Inner]. C_Link index value next
        <> input}
      (! {false}
      any) ]
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate invariant''13 [@inline:trivial] (self: t_Vec) = inv'3 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'18 (_1: t_Vec)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Vec [inv'18 x]. inv'18 x = invariant''13 x
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  predicate invariant''14 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'19 (_1: t_T)
  
  axiom inv_axiom'18 [@rewrite]: forall x: t_T [inv'19 x]. inv'19 x = invariant''14 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec index (self_: t_Vec) (ix: UInt64.t) (return (x: t_T)) = {[@expl:index 'self_' type invariant] inv'18 self_}
    {[@expl:index requires] in_bounds ix (view'1 self_)}
    any [ return' (result: t_T) -> {inv'19 result} {has_value ix (view'1 self_) result} (! return {result}) ]
  
  function id'1 (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'1 = C_None'1 | C_Some'1 (Seq.seq t_T)
  
  function view'3 (self: t_FMap'0) : Map.map t_Id t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'1 = Map.get (view'3 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = get'0 self k <> C_None'1
  
  meta "rewrite_def" predicate contains'0
  
  function view'4 (self: t_Authority) : t_FMap'0
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. (exists x: Seq.seq t_T. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'1) : Seq.seq t_T = match self with
      | C_Some'1 x -> x
      | C_None'1 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T = unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Id int) (a: t_Id) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate partial_invariant [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    id'1 self.t_PA__auth = resource_id
    /\ (forall id'2: t_Id. contains'0 (view'4 self.t_PA__auth) id'2 /\ contains self.t_PA__perms id'2
      -> id'0 (index_logic'0 self.t_PA__perms id'2) = id'2
      /\ match val' (index_logic'0 self.t_PA__perms id'2) with
        | C_Direct v -> index_logic'2 (view'4 self.t_PA__auth) id'2 = view'1 v
        | C_Link index'0 value next -> contains'0 (view'4 self.t_PA__auth) (id (view next))
        /\ index_logic'3 self.t_PA__depth id'2 > index_logic'3 self.t_PA__depth (id (view next))
        /\ UInt64.t'int index'0 < Seq.length (index_logic'2 (view'4 self.t_PA__auth) (id (view next)))
        /\ index_logic'2 (view'4 self.t_PA__auth) id'2
        = Seq.set (index_logic'2 (view'4 self.t_PA__auth) (id (view next))) (UInt64.t'int index'0) value
        end)
  
  meta "rewrite_def" predicate partial_invariant
  
  predicate protocol [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    partial_invariant self resource_id
    /\ (forall id'2: t_Id. contains'0 (view'4 self.t_PA__auth) id'2 -> contains self.t_PA__perms id'2)
  
  meta "rewrite_def" predicate protocol
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_inner_immut (inner: t_Rc) (i: UInt64.t) (pa: t_PA) (return (x: t_T)) =
    {[@expl:get_inner_immut 'pa' type invariant] inv'11 pa}
    {[@expl:get_inner_immut requires #0] exists p: t_Id. protocol pa p}
    {[@expl:get_inner_immut requires #1] contains'0 (view'4 pa.t_PA__auth) (id (view inner))}
    {[@expl:get_inner_immut requires #2] UInt64.t'int i
    < Seq.length (index_logic'2 (view'4 pa.t_PA__auth) (id (view inner)))}
    (! bb0
    [ bb0 = s0 [ s0 = deref {inner} (fun (_ret: t_PermCell) -> [ &_11 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref'0 {pa} (fun (_ret: t_PA) -> [ &_18 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = deref {inner} (fun (_ret: t_PermCell) -> [ &_26 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = id_ghost {_26} (fun (_ret: t_Id) -> [ &_24 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = deref'1 {_24} (fun (_ret: t_Id) -> [ &_22 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_21 <- _22 ] s1
      | s1 = get_ghost {_18.t_PA__perms} {_21} (fun (_ret: t_Option'0) -> [ &_16 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = unwrap {_16} (fun (_ret: t_PermCellOwn) -> [ &_15 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = new {_15} (fun (_ret: t_PermCellOwn) -> [ &_13 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = borrow {_11} {_13} (fun (_ret: t_Inner) -> [ &_9 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = any
      [ br0 (x0: t_Vec) -> {_9 = C_Direct x0} (! bb15)
      | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {_9 = C_Link x0 x1 x2} (! bb14) ]
    | bb14 = s0
      [ s0 = v_Link {_9} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &index'0 <- rindex ] s1)
      | s1 = [ &index'1 <- index'0 ] s2
      | s2 = v_Link {_9} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &value <- rvalue ] s3)
      | s3 = [ &value'0 <- value ] s4
      | s4 = [ &_40 <- i = index'1 ] s5
      | s5 = any [ br0 -> {_40 = false} (! bb13) | br1 -> {_40} (! bb17) ] ]
    | bb17 = s0 [ s0 = [ &_8 <- value ] s1 | s1 = bb20 ]
    | bb13 = s0
      [ s0 = v_Link {_9} (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) -> [ &next <- rnext ] s1)
      | s1 = get_inner_immut {next} {i} {pa} (fun (_ret: t_T) -> [ &_44 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0 [ s0 = [ &_8 <- _44 ] s1 | s1 = bb20 ]
    | bb15 = s0
      [ s0 = v_Direct {_9} (fun (r0: t_Vec) -> [ &v <- r0 ] s1)
      | s1 = index {v} {i} (fun (_ret: t_T) -> [ &_33 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0 [ s0 = [ &_32 <- _33 ] s1 | s1 = [ &_8 <- _32 ] s2 | s2 = bb20 ]
    | bb20 = s0 [ s0 = [ &_0 <- _8 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & inner: t_Rc = inner
    | & i: UInt64.t = i
    | & pa: t_PA = pa
    | & _8: t_T = Any.any_l ()
    | & _9: t_Inner = Any.any_l ()
    | & _11: t_PermCell = Any.any_l ()
    | & _13: t_PermCellOwn = Any.any_l ()
    | & _15: t_PermCellOwn = Any.any_l ()
    | & _16: t_Option'0 = Any.any_l ()
    | & _18: t_PA = Any.any_l ()
    | & _21: t_Id = Any.any_l ()
    | & _22: t_Id = Any.any_l ()
    | & _24: t_Id = Any.any_l ()
    | & _26: t_PermCell = Any.any_l ()
    | & v: t_Vec = Any.any_l ()
    | & _32: t_T = Any.any_l ()
    | & _33: t_T = Any.any_l ()
    | & index'0: UInt64.t = Any.any_l ()
    | & index'1: UInt64.t = Any.any_l ()
    | & value: t_T = Any.any_l ()
    | & value'0: t_T = Any.any_l ()
    | & _40: bool = Any.any_l ()
    | & next: t_Rc = Any.any_l ()
    | & _44: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:get_inner_immut result type invariant] inv'19 result}
      {[@expl:get_inner_immut ensures] result
      = Seq.get (index_logic'2 (view'4 pa.t_PA__auth) (id (view inner))) (UInt64.t'int i)}
      (! return {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__get (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use set.Set
  
  type t_LocalInvariant
  
  type t_Id
  
  function public (self: t_LocalInvariant) : t_Id
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  function view (self: t_Rc) : t_LocalInvariant
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_Resource
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc'0;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc }
  
  type t_FMap
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  type t_PermCellOwn
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view'0 (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull'1; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc'0
  
  predicate inv'0 (_1: t_T)
  
  predicate invariant' (self: t_T) = inv'0 self
  
  predicate inv'1 (_1: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'1 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = inv'2 (view'1 self)
  
  predicate inv'3 (_1: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_1: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 [@inline:trivial] (self: t_Inner) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 [@inline:trivial] (self: t_PermCellOwn) = inv'5 (val' self)
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. (exists x: t_PermCellOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''4 [@inline:trivial] (self: t_FMap) =
    forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_1: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_1: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'7 perms /\ inv'8 auth
        end
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'10 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'11 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'11 self
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_PA [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'10 self
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t t_PA [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref (self: MutBorrow.t t_PA) (return (x: MutBorrow.t t_PA)) =
    {[@expl:deref 'self' type invariant] inv'12 self}
    any [ return' (result: MutBorrow.t t_PA) -> {inv'13 result} {result = self} (! return {result}) ]
  
  type closure0 = { c0: t_PersistentArray; c1: t_Id; c2: UInt64.t }
  
  predicate invariant''10 (self: t_Fragment)
  
  predicate inv'14 (_1: t_Fragment)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Fragment [inv'14 x]. inv'14 x
      = (invariant''10 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''11 [@inline:trivial] (self: t_Fragment) = inv'14 self
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'15 (_1: t_Fragment)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Fragment [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate invariant''12 [@inline:trivial] (self: t_Fragment) = inv'15 self
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'16 (_1: t_Fragment)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_Fragment [inv'16 x]. inv'16 x = invariant''12 x
  
  predicate invariant''13 [@inline:trivial] (self: t_Fragment) = inv'14 self
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'17 (_1: t_Fragment)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Fragment [inv'17 x]. inv'17 x = invariant''13 x
  
  let rec deref'0 (self: t_Fragment) (return (x: t_Fragment)) = {[@expl:deref 'self' type invariant] inv'16 self}
    any [ return' (result: t_Fragment) -> {inv'17 result} {result = self} (! return {result}) ]
  
  predicate invariant''14 [@inline:trivial] (self: t_Authority) = inv'8 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'18 (_1: t_Authority)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Authority [inv'18 x]. inv'18 x = invariant''14 x
  
  function id (self: t_Authority) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (Seq.seq t_T)
  
  function view'2 (self: t_FMap'0) : Map.map t_Id t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'0 = Map.get (view'2 self) k
  
  meta "rewrite_def" function get'0
  
  function view'3 (self: t_Authority) : t_FMap'0
  
  type tuple = { f0: t_Id; f1: Seq.seq t_T }
  
  function view'4 (self: t_Fragment) : tuple
  
  let rec contains'0 (self: t_Authority) (frag: t_Fragment) (return (x: ())) =
    {[@expl:contains 'self' type invariant] inv'18 self}
    {[@expl:contains 'frag' type invariant] inv'17 frag}
    {[@expl:contains requires] id self = id'0 frag}
    any
    [ return' (result: ()) -> {get'0 (view'3 self) (view'4 frag).f0 = C_Some'0 ((view'4 frag).f1)} (! return {result}) ]
  
  let rec new (x: ()) (return (x'0: ())) = any [ return' (result: ()) -> {result = x} (! return {result}) ]
  
  predicate invariant''15 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) =
    inv'11 self.current /\ inv'11 self.final
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'19 (_1: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'19 x]. inv'19 x = invariant''15 x
  
  predicate invariant''16 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) =
    inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'20 (_1: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'20 x]. inv'20 x = invariant''16 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] inv'19 self}
    any [ return' (result: MutBorrow.t (MutBorrow.t t_PA)) -> {inv'20 result} {result = self} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_PA)) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec new'0 (x: MutBorrow.t t_PA) (return (x'0: MutBorrow.t t_PA)) = {[@expl:new 'x' type invariant] inv'10 x}
    any [ return' (result: MutBorrow.t t_PA) -> {inv'11 result} {result = x} (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_PA) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_PA) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate contains'1 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains'1
  
  function id'1 (self: t_PermCellOwn) : t_Id
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. (exists x: Seq.seq t_T. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'0) : Seq.seq t_T = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T = unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  type t_PermCell
  
  function id'2 (self: t_PermCell) : t_Id
  
  function view'5 (self: t_Rc'0) : t_PermCell
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Id int) (a: t_Id) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate partial_invariant [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    id self.t_PA__auth = resource_id
    /\ (forall id'3: t_Id. contains'1 (view'3 self.t_PA__auth) id'3 /\ contains self.t_PA__perms id'3
      -> id'1 (index_logic'0 self.t_PA__perms id'3) = id'3
      /\ match val' (index_logic'0 self.t_PA__perms id'3) with
        | C_Direct v -> index_logic'2 (view'3 self.t_PA__auth) id'3 = view'1 v
        | C_Link index value next -> contains'1 (view'3 self.t_PA__auth) (id'2 (view'5 next))
        /\ index_logic'3 self.t_PA__depth id'3 > index_logic'3 self.t_PA__depth (id'2 (view'5 next))
        /\ UInt64.t'int index < Seq.length (index_logic'2 (view'3 self.t_PA__auth) (id'2 (view'5 next)))
        /\ index_logic'2 (view'3 self.t_PA__auth) id'3
        = Seq.set (index_logic'2 (view'3 self.t_PA__auth) (id'2 (view'5 next))) (UInt64.t'int index) value
        end)
  
  meta "rewrite_def" predicate partial_invariant
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PA) : t_PA = self.final
  
  meta "rewrite_def" function fin
  
  let rec reroot (cur: t_Rc'0) (auth_id: t_Id) (pa: MutBorrow.t t_PA) (return (x: ())) =
    {[@expl:reroot 'pa' type invariant] inv'11 pa}
    {[@expl:reroot requires #0] partial_invariant pa.current auth_id}
    {[@expl:reroot requires #1] contains'1 (view'3 pa.current.t_PA__auth) (id'2 (view'5 cur))}
    {[@expl:reroot requires #2] forall id'3: t_Id. contains'1 (view'3 pa.current.t_PA__auth) id'3
        /\ index_logic'3 pa.current.t_PA__depth id'3 <= index_logic'3 pa.current.t_PA__depth (id'2 (view'5 cur))
      -> contains pa.current.t_PA__perms id'3}
    any
    [ return' (result: ()) -> {partial_invariant (fin pa) auth_id}
      {(fin pa).t_PA__auth = pa.current.t_PA__auth}
      {forall id'3: t_Id. index_logic'3 pa.current.t_PA__depth id'3
          > index_logic'3 pa.current.t_PA__depth (id'2 (view'5 cur))
        -> get pa.current.t_PA__perms id'3 = get (fin pa).t_PA__perms id'3
        /\ index_logic'3 pa.current.t_PA__depth id'3 = index_logic'3 (fin pa).t_PA__depth id'3}
      {forall id'3: t_Id. contains (fin pa).t_PA__perms id'3 = contains pa.current.t_PA__perms id'3}
      {match val' (index_logic'0 (fin pa).t_PA__perms (id'2 (view'5 cur))) with
        | C_Direct _ -> true
        | C_Link _ _ _ -> false
        end}
      (! return {result}) ]
  
  let rec into_inner (self: MutBorrow.t t_PA) (return (x: MutBorrow.t t_PA)) =
    {[@expl:into_inner 'self' type invariant] inv'11 self}
    any [ return' (result: MutBorrow.t t_PA) -> {inv'10 result} {result = self} (! return {result}) ]
  
  let rec deref'1 (self_: t_Rc'0) (return (x: t_PermCell)) = any
    [ return' (result: t_PermCell) -> {result = view'5 self_} (! return {result}) ]
  
  let rec id_ghost (self: t_PermCell) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = id'2 self} (! return {result}) ]
  
  let rec deref'2 (self: t_Id) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = self} (! return {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_PermCellOwn
  
  predicate invariant''17 [@inline:trivial] (self: t_FMap) = inv'7 self
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'21 (_1: t_FMap)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_FMap [inv'21 x]. inv'21 x = invariant''17 x
  
  predicate invariant''18 [@inline:trivial] (self: t_PermCellOwn) = inv'6 self
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'22 (_1: t_PermCellOwn)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_PermCellOwn [inv'22 x]. inv'22 x = invariant''18 x
  
  predicate inv'23 (_1: t_Option'1)
  
  axiom inv_axiom'22 [@rewrite]: forall x: t_Option'1 [inv'23 x]. inv'23 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'22 a_0
        end
  
  function map_logic (self: t_Option) (f: Map.map t_PermCellOwn t_PermCellOwn) : t_Option'1 = match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_Id) (return (x: t_Option'1)) =
    {[@expl:get_ghost 'self' type invariant] inv'21 self}
    any
    [ return' (result: t_Option'1) -> {inv'23 result}
      {result = map_logic (get self key) (fun (v: t_PermCellOwn) -> v)}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'1) (return (x: t_PermCellOwn)) = {[@expl:unwrap 'self_' type invariant] inv'23 self_}
    {[@expl:unwrap requires] self_ <> C_None'1}
    any [ return' (result: t_PermCellOwn) -> {inv'22 result} {C_Some'1 result = self_} (! return {result}) ]
  
  predicate invariant''19 [@inline:trivial] (self: t_PermCellOwn) = inv'22 self
  
  meta "rewrite_def" predicate invariant''19
  
  predicate inv'24 (_1: t_PermCellOwn)
  
  axiom inv_axiom'23 [@rewrite]: forall x: t_PermCellOwn [inv'24 x]. inv'24 x = invariant''19 x
  
  let rec new'1 (x: t_PermCellOwn) (return (x'0: t_PermCellOwn)) = {[@expl:new 'x' type invariant] inv'22 x}
    any [ return' (result: t_PermCellOwn) -> {inv'24 result} {result = x} (! return {result}) ]
  
  function view'6 [@inline:trivial] (self: t_PermCellOwn) : t_Inner = val' self
  
  meta "rewrite_def" function view'6
  
  let rec borrow (self: t_PermCell) (perm: t_PermCellOwn) (return (x: t_Inner)) =
    {[@expl:borrow 'perm' type invariant] inv'24 perm}
    {[@expl:borrow requires] id'2 self = id'1 perm}
    any [ return' (result: t_Inner) -> {inv'5 result} {result = view'6 perm} (! return {result}) ]
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate invariant''20 [@inline:trivial] (self: t_Vec) = inv'3 self
  
  meta "rewrite_def" predicate invariant''20
  
  predicate inv'25 (_1: t_Vec)
  
  axiom inv_axiom'24 [@rewrite]: forall x: t_Vec [inv'25 x]. inv'25 x = invariant''20 x
  
  predicate invariant''21 (self: Slice64.slice t_T) = inv'2 (Slice64.view self)
  
  predicate inv'26 (_1: Slice64.slice t_T)
  
  axiom inv_axiom'25 [@rewrite]: forall x: Slice64.slice t_T [inv'26 x]. inv'26 x = invariant''21 x
  
  predicate invariant''22 [@inline:trivial] (self: Slice64.slice t_T) = inv'26 self
  
  meta "rewrite_def" predicate invariant''22
  
  predicate inv'27 (_1: Slice64.slice t_T)
  
  axiom inv_axiom'26 [@rewrite]: forall x: Slice64.slice t_T [inv'27 x]. inv'27 x = invariant''22 x
  
  let rec deref'3 (self_: t_Vec) (return (x: Slice64.slice t_T)) = {[@expl:deref 'self_' type invariant] inv'25 self_}
    any
    [ return' (result: Slice64.slice t_T) -> {inv'27 result} {Slice64.view result = view'1 self_} (! return {result}) ]
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  predicate invariant''23 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''23
  
  predicate inv'28 (_1: t_T)
  
  axiom inv_axiom'27 [@rewrite]: forall x: t_T [inv'28 x]. inv'28 x = invariant''23 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec get_unchecked (self_: Slice64.slice t_T) (ix: UInt64.t) (return (x: t_T)) =
    {[@expl:get_unchecked 'self_' type invariant] inv'27 self_}
    {[@expl:get_unchecked requires] in_bounds ix (Slice64.view self_)}
    any [ return' (result: t_T) -> {inv'28 result} {has_value ix (Slice64.view self_) result} (! return {result}) ]
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant''24 (self: t_PersistentArray) =
    (view'4 self.t_PersistentArray__frag).f0 = id'2 (view'5 self.t_PersistentArray__permcell)
    /\ id'0 self.t_PersistentArray__frag = public (view self.t_PersistentArray__inv)
    /\ namespace (view self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate inv'29 (_1: t_PersistentArray)
  
  axiom inv_axiom'28 [@rewrite]: forall x: t_PersistentArray [inv'29 x]. inv'29 x
      = (invariant''24 x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'30} -> inv'15 frag
        end)
  
  predicate invariant''25 [@inline:trivial] (self: t_PersistentArray) = inv'29 self
  
  meta "rewrite_def" predicate invariant''25
  
  predicate inv'30 (_1: t_PersistentArray)
  
  axiom inv_axiom'29 [@rewrite]: forall x: t_PersistentArray [inv'30 x]. inv'30 x = invariant''25 x
  
  predicate invariant''26 [@inline:trivial] (self: t_PersistentArray) = inv'30 self
  
  meta "rewrite_def" predicate invariant''26
  
  predicate inv'31 (_1: t_PersistentArray)
  
  axiom inv_axiom'30 [@rewrite]: forall x: t_PersistentArray [inv'31 x]. inv'31 x = invariant''26 x
  
  predicate inv'32 (_1: closure0)
  
  axiom inv_axiom'31 [@rewrite]: forall x: closure0 [inv'32 x]. inv'32 x
      = (let {c0 = x0; c1 = x1; c2 = x2} = x in inv'31 x0)
  
  let rec closure0 [@coma:extspec] (self: closure0) (pa: MutBorrow.t t_PA) (return (x: t_T)) = bb0
    [ bb0 = s0 [ s0 = deref {pa} (fun (_ret: MutBorrow.t t_PA) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_11 <- self.c0.t_PersistentArray__frag ] s1
      | s1 = deref'0 {_11} (fun (_ret: t_Fragment) -> [ &_9 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = contains'0 {_6.current.t_PA__auth} {_9} (fun (_ret: ()) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_4} (fun (_ret: ()) -> [ &_3 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_14 <- self.c0.t_PersistentArray__permcell ] s1
      | s1 = {inv'11 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_21 <- _ret ] -{inv'11 _ret.final}-
            [ &pa <- _ret.final ] s2)
      | s2 = deref_mut {_21} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_20 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'10 _20.current}
        MutBorrow.borrow_final <MutBorrow.t t_PA> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_19 <- _ret ] -{inv'10 _ret.final}-
            [ &_20 <- { _20 with current = _ret.final } ] s1)
      | s1 = {inv'9 _19.current.current}
        MutBorrow.borrow_mut <t_PA> {_19.current.current}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_18 <- _ret ] -{inv'9 _ret.final}-
            [ &_19 <- { _19 with current = { _19.current with current = _ret.final } } ] s2)
      | s2 = {[@expl:type invariant] inv'20 _20} s3
      | s3 = -{resolve'0 _20}- s4
      | s4 = {[@expl:type invariant] inv'20 _19} s5
      | s5 = -{resolve'0 _19}- s6
      | s6 = {inv'9 _18.current}
        MutBorrow.borrow_final <t_PA> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_17 <- _ret ] -{inv'9 _ret.final}-
            [ &_18 <- { _18 with current = _ret.final } ] s7)
      | s7 = new'0 {_17} (fun (_ret: MutBorrow.t t_PA) -> [ &_16 <- _ret ] s8)
      | s8 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'10 _18} s1
      | s1 = -{resolve'2 _18}- s2
      | s2 = reroot {_14} {self.c1} {_16} (fun (_ret: ()) -> [ &_12 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = into_inner {pa} (fun (_ret: MutBorrow.t t_PA) -> [ &_26 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'10 _26} s1
      | s1 = -{resolve'2 _26}- s2
      | s2 = deref'1 {self.c0.t_PersistentArray__permcell} (fun (_ret: t_PermCell) -> [ &_34 <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0 [ s0 = id_ghost {_34} (fun (_ret: t_Id) -> [ &_32 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = [ &_31 <- _32 ] s1 | s1 = deref'2 {_31} (fun (_ret: t_Id) -> [ &_29 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0
      [ s0 = get_ghost {_26.current.t_PA__perms} {_29} (fun (_ret: t_Option'1) -> [ &_24 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_24} (fun (_ret: t_PermCellOwn) -> [ &_23 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = new'1 {_23} (fun (_ret: t_PermCellOwn) -> [ &perm <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0
      [ s0 = deref'1 {self.c0.t_PersistentArray__permcell} (fun (_ret: t_PermCell) -> [ &_40 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = borrow {_40} {perm} (fun (_ret: t_Inner) -> [ &_38 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = any
      [ br0 (x0: t_Vec) -> {_38 = C_Direct x0} (! bb18)
      | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc'0) -> {_38 = C_Link x0 x1 x2} (! bb19) ]
    | bb19 = {false} any
    | bb18 = s0
      [ s0 = v_Direct {_38} (fun (r0: t_Vec) -> [ &arr <- r0 ] s1)
      | s1 = deref'3 {arr} (fun (_ret: Slice64.slice t_T) -> [ &_45 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = get_unchecked {_45} {self.c2} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = return {_0} ]
    [ & _0: t_T = Any.any_l ()
    | & self: closure0 = self
    | & pa: MutBorrow.t t_PA = pa
    | & _3: () = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _6: MutBorrow.t t_PA = Any.any_l ()
    | & _9: t_Fragment = Any.any_l ()
    | & _11: t_Fragment = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & _14: t_Rc'0 = Any.any_l ()
    | & _16: MutBorrow.t t_PA = Any.any_l ()
    | & _17: MutBorrow.t t_PA = Any.any_l ()
    | & _18: MutBorrow.t t_PA = Any.any_l ()
    | & _19: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _20: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & perm: t_PermCellOwn = Any.any_l ()
    | & _23: t_PermCellOwn = Any.any_l ()
    | & _24: t_Option'1 = Any.any_l ()
    | & _26: MutBorrow.t t_PA = Any.any_l ()
    | & _29: t_Id = Any.any_l ()
    | & _31: t_Id = Any.any_l ()
    | & _32: t_Id = Any.any_l ()
    | & _34: t_PermCell = Any.any_l ()
    | & arr: t_Vec = Any.any_l ()
    | & _38: t_Inner = Any.any_l ()
    | & _40: t_PermCell = Any.any_l ()
    | & _45: Slice64.slice t_T = Any.any_l () ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  type t_Tokens
  
  type tuple'0 = { f0'0: t_Rc; f1'0: t_Tokens; f2: closure0 }
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: t_Rc) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve'3 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'3
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: t_Rc) (result_state: ()) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: t_Rc) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_Rc, res: t_LocalInvariant. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'3 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Rc) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Rc, res_state: (), res: t_LocalInvariant. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: t_Rc) (result: t_LocalInvariant) =
    let self_ = args in result = view self_
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: t_Rc) (res: t_LocalInvariant) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Rc, res: t_LocalInvariant. postcondition_once self args res
      = (postcondition self args res /\ resolve'3 self)
  
  function fn_mut (self: ()) (args: t_Rc) (res_state: ()) (res: t_LocalInvariant) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Rc, res_state: (), res: t_LocalInvariant. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  type tuple'1 = { f0'1: t_LocalInvariant; f1'1: t_Tokens; f2'0: closure0 }
  
  predicate protocol [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    partial_invariant self resource_id
    /\ (forall id'3: t_Id. contains'1 (view'3 self.t_PA__auth) id'3 -> contains self.t_PA__perms id'3)
  
  meta "rewrite_def" predicate protocol
  
  predicate precondition [@inline:trivial] (self: closure0) (args: MutBorrow.t t_PA) =
    let pa = args in closure0'pre self pa
  
  meta "rewrite_def" predicate precondition
  
  predicate postcondition_once'0 [@inline:trivial] (self: closure0) (args: MutBorrow.t t_PA) (result: t_T) =
    let pa = args in closure0'post'return self pa result
  
  meta "rewrite_def" predicate postcondition_once'0
  
  predicate contains'2 [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = Set.mem e self
  
  meta "rewrite_def" predicate contains'2
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'3 (self: t_Tokens) (namespace'0: t_Namespace) = contains'2 (namespaces self) namespace'0
  
  predicate precondition'0 [@inline:trivial] (self: ()) (args: tuple'1) =
    let {f0'1 = self'0; f1'1 = tokens; f2'0 = f} = args in (forall t: MutBorrow.t t_PA. protocol t.current (public self'0)
          /\ inv'11 t
        -> precondition f t /\ (forall res: t_T. postcondition_once'0 f t res -> protocol (fin t) (public self'0)))
    /\ contains'3 tokens (namespace self'0) /\ inv'32 f
  
  meta "rewrite_def" predicate precondition'0
  
  function new_logic (x: t_LocalInvariant) : t_LocalInvariant
  
  axiom new_logic_spec: forall x: t_LocalInvariant. new_logic x = x
  
  predicate precondition'1 [@inline:trivial] (self: ()) (args: t_Rc) = let self_ = args in true
  
  meta "rewrite_def" predicate precondition'1
  
  predicate precondition'2 [@inline:trivial] (self: ()) (args: tuple'0) =
    let {f0'0 = self'0; f1'0 = tokens; f2 = f} = args in (forall this: t_LocalInvariant. postcondition () self'0 this
        -> precondition'0 () { f0'1 = new_logic this; f1'1 = tokens; f2'0 = f })
    /\ precondition'1 () self'0 /\ inv'32 f
  
  meta "rewrite_def" predicate precondition'2
  
  let rec deref'4 (self_: t_Rc) (return (x: t_LocalInvariant)) = any
    [ return' (result: t_LocalInvariant) -> {result = view self_} (! return {result}) ]
  
  let rec open (self: t_LocalInvariant) (tokens: t_Tokens) (f: closure0) (return (x: t_T)) =
    {[@expl:open 'f' type invariant] inv'32 f}
    {[@expl:open requires #0] contains'3 tokens (namespace self)}
    {[@expl:open requires #1] forall t: MutBorrow.t t_PA. protocol t.current (public self) /\ inv'11 t
      -> precondition f t /\ (forall res: t_T. postcondition_once'0 f t res -> protocol (fin t) (public self))}
    any
    [ return' (result: t_T) -> {inv'28 result}
      {exists t: MutBorrow.t t_PA. protocol t.current (public self) /\ postcondition_once'0 f t result}
      (! return {result}) ]
  
  predicate postcondition_once'1 [@inline:trivial] (self: ()) (args: tuple'1) (result: t_T) =
    let {f0'1 = self'0; f1'1 = tokens; f2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'28 result
  
  meta "rewrite_def" predicate postcondition_once'1
  
  predicate resolve'4 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'4
  
  predicate postcondition_mut'0 [@inline:trivial] (self: ()) (args: tuple'1) (result_state: ()) (result: t_T) =
    let {f0'1 = self'0; f1'1 = tokens; f2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'28 result
  
  meta "rewrite_def" predicate postcondition_mut'0
  
  function fn_mut_once'0 (self: ()) (args: tuple'1) (res: t_T) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple'1, res: t_T. postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'4 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple'1) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: tuple'1, res_state: (), res: t_T. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 [@inline:trivial] (self: ()) (args: tuple'1) (result: t_T) =
    let {f0'1 = self'0; f1'1 = tokens; f2'0 = f} = args in (exists t: MutBorrow.t t_PA. protocol t.current (public self'0)
        /\ postcondition_once'0 f t result)
    /\ inv'28 result
  
  meta "rewrite_def" predicate postcondition'0
  
  function fn_once'0 (self: ()) (args: tuple'1) (res: t_T) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple'1, res: t_T. postcondition_once'1 self args res
      = (postcondition'0 self args res /\ resolve'4 self)
  
  function fn_mut'0 (self: ()) (args: tuple'1) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: tuple'1, res_state: (), res: t_T. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  let rec open'0 (self: t_Rc) (tokens: t_Tokens) (f: closure0) (return (x: t_T)) =
    {[@expl:open 'f' type invariant] inv'32 f}
    {[@expl:open requires #0] precondition'1 () self}
    {[@expl:open requires #1] forall this: t_LocalInvariant. postcondition () self this
      -> precondition'0 () { f0'1 = new_logic this; f1'1 = tokens; f2'0 = f }}
    any
    [ return' (result: t_T) -> {inv'28 result}
      {exists this: t_LocalInvariant. postcondition () self this
        /\ postcondition'0 () { f0'1 = new_logic this; f1'1 = tokens; f2'0 = f } result}
      (! return {result}) ]
  
  function new_logic'0 (x: t_Rc) : t_Rc
  
  axiom new_logic_spec'0: forall x: t_Rc. new_logic'0 x = x
  
  predicate postcondition_once'2 [@inline:trivial] (self: ()) (args: tuple'0) (result: t_T) =
    let {f0'0 = self'0; f1'0 = tokens; f2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { f0'1 = new_logic this; f1'1 = tokens; f2'0 = f } result)
    /\ inv'28 result
  
  meta "rewrite_def" predicate postcondition_once'2
  
  predicate resolve'5 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'5
  
  predicate postcondition_mut'1 [@inline:trivial] (self: ()) (args: tuple'0) (result_state: ()) (result: t_T) =
    let {f0'0 = self'0; f1'0 = tokens; f2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { f0'1 = new_logic this; f1'1 = tokens; f2'0 = f } result)
    /\ inv'28 result
  
  meta "rewrite_def" predicate postcondition_mut'1
  
  function fn_mut_once'1 (self: ()) (args: tuple'0) (res: t_T) : ()
  
  axiom fn_mut_once_spec'1: forall self: (), args: tuple'0, res: t_T. postcondition_once'2 self args res
      = (exists res_state: (). postcondition_mut'1 self args res_state res /\ resolve'5 res_state)
  
  predicate hist_inv'1 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'1
  
  function hist_inv_trans'1 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'1: forall self: (), b: (), c: (). hist_inv'1 self b -> hist_inv'1 b c -> hist_inv'1 self c
  
  function hist_inv_refl'1 (self: ()) : ()
  
  axiom hist_inv_refl_spec'1: forall self: (). hist_inv'1 self self
  
  function postcondition_mut_hist_inv'1 (self: ()) (args: tuple'0) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'1:
    forall self: (), args: tuple'0, res_state: (), res: t_T. postcondition_mut'1 self args res_state res
      -> hist_inv'1 self res_state
  
  function fn_hist_inv'1 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'1: forall self: (), res_state: (). hist_inv'1 self res_state = (self = res_state)
  
  predicate postcondition'1 [@inline:trivial] (self: ()) (args: tuple'0) (result: t_T) =
    let {f0'0 = self'0; f1'0 = tokens; f2 = f} = args in (exists this: t_LocalInvariant. postcondition () self'0 this
        /\ postcondition'0 () { f0'1 = new_logic this; f1'1 = tokens; f2'0 = f } result)
    /\ inv'28 result
  
  meta "rewrite_def" predicate postcondition'1
  
  function fn_once'1 (self: ()) (args: tuple'0) (res: t_T) : ()
  
  axiom fn_once_spec'1: forall self: (), args: tuple'0, res: t_T. postcondition_once'2 self args res
      = (postcondition'1 self args res /\ resolve'5 self)
  
  function fn_mut'1 (self: ()) (args: tuple'0) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec'1:
    forall self: (), args: tuple'0, res_state: (), res: t_T. postcondition_mut'1 self args res_state res
      = (postcondition'1 self args res /\ self = res_state)
  
  let rec open'1 (self: t_Rc) (tokens: t_Tokens) (f: closure0) (return (x: t_T)) =
    {[@expl:open 'f' type invariant] inv'32 f}
    {[@expl:open requires] precondition'2 () { f0'0 = new_logic'0 self; f1'0 = tokens; f2 = f }}
    any
    [ return' (result: t_T) -> {inv'28 result}
      {postcondition'1 () { f0'0 = new_logic'0 self; f1'0 = tokens; f2 = f } result}
      (! return {result}) ]
  
  function view'7 [@inline:trivial] (self: t_PersistentArray) : Seq.seq t_T = (view'4 self.t_PersistentArray__frag).f1
  
  meta "rewrite_def" function view'7
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get'1 (self: t_PersistentArray) (index: UInt64.t) (tokens: t_Tokens) (return (x: t_T)) =
    {[@expl:get 'self' type invariant] inv'30 self}
    {[@expl:get requires #0] contains'3 tokens (Namespace_PARRAY 0)}
    {[@expl:get requires #1] UInt64.t'int index < Seq.length (view'7 self)}
    (! bb0
    [ bb0 = s0 [ s0 = [ &auth_id <- public (view self.t_PersistentArray__inv) ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_12 <- { c0 = self; c1 = auth_id; c2 = index } ] s1
      | s1 = open'1 {self.t_PersistentArray__inv} {tokens} {_12} (fun (_ret: t_T) -> [ &_9 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- _9 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & self: t_PersistentArray = self
    | & index: UInt64.t = index
    | & tokens: t_Tokens = tokens
    | & auth_id: t_Id = Any.any_l ()
    | & _9: t_T = Any.any_l ()
    | & _12: closure0 = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:get result type invariant] inv'28 result}
      {[@expl:get ensures] result = Seq.get (view'7 self) (UInt64.t'int index)}
      (! return {result}) ]
end
module M_persistent_array__implementation__qyi7256199225841846155__reroot (* implementation::PersistentArray<T> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Id
  
  type t_PA = { t_PA__perms: t_FMap; t_PA__auth: t_Authority; t_PA__depth: Map.map t_Id int }
  
  type t_PermCellOwn
  
  type t_Option = C_None | C_Some t_PermCellOwn
  
  function view (self: t_FMap) : Map.map t_Id t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_Id) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_Id) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_Id)
  
  axiom inv_axiom [@rewrite]: forall x: t_Id [inv x]. inv x = true
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_T
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Inner = C_Direct t_Vec | C_Link UInt64.t t_T t_Rc
  
  predicate inv'0 (_1: t_T)
  
  predicate invariant' (self: t_T) = inv'0 self
  
  predicate inv'1 (_1: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'0 (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = inv'2 (view'0 self)
  
  predicate inv'3 (_1: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_1: t_Inner)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Inner [inv'4 x]. inv'4 x
      = match x with
        | C_Direct a_0 -> inv'3 a_0
        | C_Link index value next -> inv'0 value
        end
  
  predicate invariant''2 [@inline:trivial] (self: t_Inner) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: t_Inner)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Inner [inv'5 x]. inv'5 x = invariant''2 x
  
  function val' (self: t_PermCellOwn) : t_Inner
  
  predicate invariant''3 [@inline:trivial] (self: t_PermCellOwn) = inv'5 (val' self)
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_1: t_PermCellOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PermCellOwn [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate index_logic [@inline:trivial] (self: Map.map t_PermCellOwn bool) (a: t_PermCellOwn) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_PermCellOwn bool) : t_PermCellOwn
  
  axiom such_that_spec: forall p: Map.map t_PermCellOwn bool. (exists x: t_PermCellOwn. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_PermCellOwn = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_PermCellOwn) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_Id) : t_PermCellOwn = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_Id) : t_PermCellOwn = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''4 [@inline:trivial] (self: t_FMap) =
    forall k: t_Id. contains self k -> inv k /\ inv'6 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'7 (_1: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_Authority)
  
  predicate inv'8 (_1: t_Authority)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Authority [inv'8 x]. inv'8 x
      = (invariant''5 x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate inv'9 (_1: t_PA)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PA [inv'9 x]. inv'9 x
      = match x with
        | {t_PA__perms = perms; t_PA__auth = auth; t_PA__depth = depth} -> inv'7 perms /\ inv'8 auth
        end
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'10 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_PA [inv'10 x]. inv'10 x = invariant''6 x
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_PA) = inv'10 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'11 (_1: MutBorrow.t t_PA)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_PA [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) =
    inv'11 self.current /\ inv'11 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'12 (_1: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'12 x]. inv'12 x = invariant''8 x
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) =
    inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'13 (_1: MutBorrow.t (MutBorrow.t t_PA))
  
  axiom inv_axiom'12 [@rewrite]: forall x: MutBorrow.t (MutBorrow.t t_PA) [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec deref_mut (self: MutBorrow.t (MutBorrow.t t_PA)) (return (x: MutBorrow.t (MutBorrow.t t_PA))) =
    {[@expl:deref_mut 'self' type invariant] inv'12 self}
    any [ return' (result: MutBorrow.t (MutBorrow.t t_PA)) -> {inv'13 result} {result = self} (! return {result}) ]
  
  type t_PermCell
  
  function view'1 (self: t_Rc) : t_PermCell
  
  let rec deref (self_: t_Rc) (return (x: t_PermCell)) = any
    [ return' (result: t_PermCell) -> {result = view'1 self_} (! return {result}) ]
  
  function id (self: t_PermCell) : t_Id
  
  let rec id_ghost (self: t_PermCell) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = id self} (! return {result}) ]
  
  let rec deref'0 (self: t_Id) (return (x: t_Id)) = any
    [ return' (result: t_Id) -> {result = self} (! return {result}) ]
  
  predicate invariant''10 [@inline:trivial] (self: MutBorrow.t t_FMap) = inv'7 self.current /\ inv'7 self.final
  
  meta "rewrite_def" predicate invariant''10
  
  predicate inv'14 (_1: MutBorrow.t t_FMap)
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'14 x]. inv'14 x = invariant''10 x
  
  predicate inv'15 (_1: t_Option)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_Option [inv'15 x]. inv'15 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'6 a_0
        end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function remove (self: t_FMap) (k: t_Id) : t_FMap
  
  axiom remove_spec: forall self: t_FMap, k: t_Id. view (remove self k) = Map.set (view self) k (C_None)
  
  axiom remove_spec'0: forall self: t_FMap, k: t_Id. len (remove self k)
      = (if contains self k then len self - 1 else len self)
  
  let rec remove_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return (x: t_Option)) =
    {[@expl:remove_ghost 'self' type invariant] inv'14 self}
    any
    [ return' (result: t_Option) -> {inv'15 result}
      {self.final = remove self.current key}
      {result = get self.current key}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_PA)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_PA)) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec unwrap (self_: t_Option) (return (x: t_PermCellOwn)) = {[@expl:unwrap 'self_' type invariant] inv'15 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return' (result: t_PermCellOwn) -> {inv'6 result} {C_Some result = self_} (! return {result}) ]
  
  predicate invariant''11 [@inline:trivial] (self: t_PermCellOwn) = inv'6 self
  
  meta "rewrite_def" predicate invariant''11
  
  predicate inv'16 (_1: t_PermCellOwn)
  
  axiom inv_axiom'15 [@rewrite]: forall x: t_PermCellOwn [inv'16 x]. inv'16 x = invariant''11 x
  
  let rec new (x: t_PermCellOwn) (return (x'0: t_PermCellOwn)) = {[@expl:new 'x' type invariant] inv'6 x}
    any [ return' (result: t_PermCellOwn) -> {inv'16 result} {result = x} (! return {result}) ]
  
  predicate invariant''12 [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = inv'16 self.current /\ inv'16 self.final
  
  meta "rewrite_def" predicate invariant''12
  
  predicate inv'17 (_1: MutBorrow.t t_PermCellOwn)
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t t_PermCellOwn [inv'17 x]. inv'17 x = invariant''12 x
  
  predicate invariant''13 [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''13
  
  predicate inv'18 (_1: MutBorrow.t t_PermCellOwn)
  
  axiom inv_axiom'17 [@rewrite]: forall x: MutBorrow.t t_PermCellOwn [inv'18 x]. inv'18 x = invariant''13 x
  
  let rec deref_mut'0 (self: MutBorrow.t t_PermCellOwn) (return (x: MutBorrow.t t_PermCellOwn)) =
    {[@expl:deref_mut 'self' type invariant] inv'17 self}
    any [ return' (result: MutBorrow.t t_PermCellOwn) -> {inv'18 result} {result = self} (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_PermCellOwn) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_PermCellOwn) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate invariant''14 [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = inv'18 self
  
  meta "rewrite_def" predicate invariant''14
  
  predicate inv'19 (_1: MutBorrow.t t_PermCellOwn)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_PermCellOwn [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec new'0 (x: MutBorrow.t t_PermCellOwn) (return (x'0: MutBorrow.t t_PermCellOwn)) =
    {[@expl:new 'x' type invariant] inv'18 x}
    any [ return' (result: MutBorrow.t t_PermCellOwn) -> {inv'19 result} {result = x} (! return {result}) ]
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  predicate invariant''15 [@inline:trivial] (self: MutBorrow.t t_Inner) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''15
  
  predicate inv'20 (_1: MutBorrow.t t_Inner)
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t t_Inner [inv'20 x]. inv'20 x = invariant''15 x
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) : t_PermCellOwn = self.final
  
  meta "rewrite_def" function fin
  
  function view'2 [@inline:trivial] (self: t_PermCellOwn) : t_Inner = val' self
  
  meta "rewrite_def" function view'2
  
  let rec borrow_mut (self: t_PermCell) (perm: MutBorrow.t t_PermCellOwn) (return (x: MutBorrow.t t_Inner)) =
    {[@expl:borrow_mut 'perm' type invariant] inv'19 perm}
    {[@expl:borrow_mut requires] id self = id'0 perm.current}
    any
    [ return' (result: MutBorrow.t t_Inner) -> {inv'20 result}
      {id self = id'0 (fin perm)}
      {result.current = view'2 perm.current}
      {result.final = view'2 (fin perm)}
      (! return {result}) ]
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_Inner) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_1: MutBorrow.t t_Inner) = resolve'5 _1
  
  meta "rewrite_def" predicate resolve'6
  
  let rec into_inner (self: t_PermCellOwn) (return (x: t_PermCellOwn)) =
    {[@expl:into_inner 'self' type invariant] inv'16 self}
    any [ return' (result: t_PermCellOwn) -> {inv'6 result} {result = self} (! return {result}) ]
  
  function insert (self: t_FMap) (k: t_Id) (v: t_PermCellOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_Id, v: t_PermCellOwn. view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_Id, v: t_PermCellOwn. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (value: t_PermCellOwn) (return (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] inv'14 self}
    {[@expl:insert_ghost 'value' type invariant] inv'6 value}
    any
    [ return' (result: t_Option) -> {inv'15 result}
      {self.final = insert self.current key value}
      {result = get self.current key}
      (! return {result}) ]
  
  predicate resolve'7 [@inline:trivial] (self: MutBorrow.t t_PA) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_1: MutBorrow.t t_PA) = resolve'7 _1
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 [@inline:trivial] (self: MutBorrow.t t_PA) = resolve'8 self
  
  meta "rewrite_def" predicate resolve'9
  
  predicate resolve'10 [@inline:trivial] (_1: MutBorrow.t t_PA) = resolve'9 _1
  
  meta "rewrite_def" predicate resolve'10
  
  predicate invariant''16 [@inline:trivial] (self: t_Option) = inv'15 self
  
  meta "rewrite_def" predicate invariant''16
  
  predicate inv'21 (_1: t_Option)
  
  axiom inv_axiom'20 [@rewrite]: forall x: t_Option [inv'21 x]. inv'21 x = invariant''16 x
  
  let rec new'1 (x: t_Option) (return (x'0: t_Option)) = {[@expl:new 'x' type invariant] inv'15 x}
    any [ return' (result: t_Option) -> {inv'21 result} {result = x} (! return {result}) ]
  
  predicate resolve'11 [@inline:trivial] (_1: t_Inner) = true
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (self: t_PermCellOwn) = resolve'11 (val' self)
  
  meta "rewrite_def" predicate resolve'12
  
  predicate resolve'13 [@inline:trivial] (_1: t_PermCellOwn) = resolve'12 _1
  
  meta "rewrite_def" predicate resolve'13
  
  predicate resolve'14 [@inline:trivial] (self: t_Option) =
    match self with
      | C_Some x -> resolve'13 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'14
  
  predicate resolve'15 [@inline:trivial] (_1: t_Option) = resolve'14 _1
  
  meta "rewrite_def" predicate resolve'15
  
  predicate resolve'16 [@inline:trivial] (self: t_Option) = resolve'15 self
  
  meta "rewrite_def" predicate resolve'16
  
  predicate resolve'17 [@inline:trivial] (_1: t_Option) = resolve'16 _1
  
  meta "rewrite_def" predicate resolve'17
  
  let rec v_Link (input: t_Inner) (ret (index: UInt64.t) (value: t_T) (next: t_Rc)) = any
    [ good (index: UInt64.t) (value: t_T) (next: t_Rc) -> {C_Link index value next = input}
      (! ret {index} {value} {next})
    | bad -> {forall index: UInt64.t, value: t_T, next: t_Rc [C_Link index value next: t_Inner]. C_Link index value next
        <> input}
      (! {false}
      any) ]
  
  let rec new'2 (x: MutBorrow.t t_PA) (return (x'0: MutBorrow.t t_PA)) = {[@expl:new 'x' type invariant] inv'10 x}
    any [ return' (result: MutBorrow.t t_PA) -> {inv'11 result} {result = x} (! return {result}) ]
  
  let rec clone' (self_: t_Rc) (return (x: t_Rc)) = any
    [ return' (result: t_Rc) -> {result = self_} (! return {result}) ]
  
  let rec replace (dest: MutBorrow.t t_Rc) (src: t_Rc) (return (x: t_Rc)) = any
    [ return' (result: t_Rc) -> {dest.final = src} {result = dest.current} (! return {result}) ]
  
  predicate resolve'18 [@inline:trivial] (self: MutBorrow.t t_Rc) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'18
  
  predicate resolve'19 [@inline:trivial] (_1: MutBorrow.t t_Rc) = resolve'18 _1
  
  meta "rewrite_def" predicate resolve'19
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_PermCellOwn)
  
  predicate inv'22 (_1: t_Option'0)
  
  axiom inv_axiom'21 [@rewrite]: forall x: t_Option'0 [inv'22 x]. inv'22 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'18 a_0
        end
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: t_Id) (return (x: t_Option'0)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv'14 self}
    any
    [ return' (result: t_Option'0) -> {inv'22 result}
      {if contains self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {forall k: t_Id. k <> key -> get self.current k = get self.final k}
      {len self.current = len self.final}
      (! return {result}) ]
  
  let rec unwrap'0 (self_: t_Option'0) (return (x: MutBorrow.t t_PermCellOwn)) =
    {[@expl:unwrap 'self_' type invariant] inv'22 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_PermCellOwn) -> {inv'18 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate resolve'20 [@inline:trivial] (self: MutBorrow.t UInt64.t) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'20
  
  predicate resolve'21 [@inline:trivial] (_1: MutBorrow.t UInt64.t) = resolve'20 _1
  
  meta "rewrite_def" predicate resolve'21
  
  predicate invariant''17 [@inline:trivial] (self: MutBorrow.t t_T) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''17
  
  predicate inv'23 (_1: MutBorrow.t t_T)
  
  axiom inv_axiom'22 [@rewrite]: forall x: MutBorrow.t t_T [inv'23 x]. inv'23 x = invariant''17 x
  
  predicate resolve'22 [@inline:trivial] (self: MutBorrow.t t_T) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'22
  
  predicate resolve'23 [@inline:trivial] (_1: MutBorrow.t t_T) = resolve'22 _1
  
  meta "rewrite_def" predicate resolve'23
  
  let rec v_Direct (input: t_Inner) (ret (field_0: t_Vec)) = any
    [ good (field_0: t_Vec) -> {C_Direct field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Vec [C_Direct field_0: t_Inner]. C_Direct field_0 <> input} (! {false} any) ]
  
  predicate invariant''18 [@inline:trivial] (self: MutBorrow.t t_Vec) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''18
  
  predicate inv'24 (_1: MutBorrow.t t_Vec)
  
  axiom inv_axiom'23 [@rewrite]: forall x: MutBorrow.t t_Vec [inv'24 x]. inv'24 x = invariant''18 x
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_T) (out: t_T) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_T) (fin'0: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin'0 i
  
  meta "rewrite_def" predicate resolve_elswhere
  
  let rec index_mut (self_: MutBorrow.t t_Vec) (ix: UInt64.t) (return (x: MutBorrow.t t_T)) =
    {[@expl:index_mut 'self_' type invariant] inv'24 self_}
    {[@expl:index_mut requires] in_bounds ix (view'0 self_.current)}
    any
    [ return' (result: MutBorrow.t t_T) -> {inv'23 result}
      {has_value ix (view'0 self_.current) result.current}
      {has_value ix (view'0 self_.final) result.final}
      {resolve_elswhere ix (view'0 self_.current) (view'0 self_.final)}
      {Seq.length (view'0 self_.final) = Seq.length (view'0 self_.current)}
      (! return {result}) ]
  
  let rec swap (x: MutBorrow.t t_T) (y: MutBorrow.t t_T) (return (x'0: ())) = {[@expl:swap 'x' type invariant] inv'23 x}
    {[@expl:swap 'y' type invariant] inv'23 y}
    any [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve'24 [@inline:trivial] (self: MutBorrow.t t_Vec) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'24
  
  predicate resolve'25 [@inline:trivial] (_1: MutBorrow.t t_Vec) = resolve'24 _1
  
  meta "rewrite_def" predicate resolve'25
  
  let rec swap'0 (x: MutBorrow.t t_Inner) (y: MutBorrow.t t_Inner) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv'20 x}
    {[@expl:swap 'y' type invariant] inv'20 y}
    any [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  let rec new'3 (x: ()) (return (x'0: ())) = any [ return' (result: ()) -> {result = x} (! return {result}) ]
  
  function id'1 (self: t_Authority) : t_Id
  
  type t_FMap'0
  
  type t_Option'1 = C_None'1 | C_Some'1 (Seq.seq t_T)
  
  function view'3 (self: t_FMap'0) : Map.map t_Id t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : t_Option'1 = Map.get (view'3 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) = get'0 self k <> C_None'1
  
  meta "rewrite_def" predicate contains'0
  
  function view'4 (self: t_Authority) : t_FMap'0
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (Seq.seq t_T) bool) (a: Seq.seq t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (Seq.seq t_T) bool) : Seq.seq t_T
  
  axiom such_that_spec'0: forall p: Map.map (Seq.seq t_T) bool. (exists x: Seq.seq t_T. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'1) : Seq.seq t_T = match self with
      | C_Some'1 x -> x
      | C_None'1 -> such_that'0 (fun (__0: Seq.seq t_T) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_Id) : Seq.seq t_T = unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_Id) : Seq.seq t_T = lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  function index_logic'3 [@inline:trivial] (self: Map.map t_Id int) (a: t_Id) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'3
  
  predicate partial_invariant [@inline:trivial] (self: t_PA) (resource_id: t_Id) =
    id'1 self.t_PA__auth = resource_id
    /\ (forall id'2: t_Id. contains'0 (view'4 self.t_PA__auth) id'2 /\ contains self.t_PA__perms id'2
      -> id'0 (index_logic'0 self.t_PA__perms id'2) = id'2
      /\ match val' (index_logic'0 self.t_PA__perms id'2) with
        | C_Direct v -> index_logic'2 (view'4 self.t_PA__auth) id'2 = view'0 v
        | C_Link index value next -> contains'0 (view'4 self.t_PA__auth) (id (view'1 next))
        /\ index_logic'3 self.t_PA__depth id'2 > index_logic'3 self.t_PA__depth (id (view'1 next))
        /\ UInt64.t'int index < Seq.length (index_logic'2 (view'4 self.t_PA__auth) (id (view'1 next)))
        /\ index_logic'2 (view'4 self.t_PA__auth) id'2
        = Seq.set (index_logic'2 (view'4 self.t_PA__auth) (id (view'1 next))) (UInt64.t'int index) value
        end)
  
  meta "rewrite_def" predicate partial_invariant
  
  function fin'0 [@inline:trivial] (self: MutBorrow.t t_PA) : t_PA = self.final
  
  meta "rewrite_def" function fin'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec reroot (cur: t_Rc) (auth_id: t_Id) (pa: MutBorrow.t t_PA) (return (x: ())) =
    {[@expl:reroot 'pa' type invariant] inv'11 pa}
    {[@expl:reroot requires #0] partial_invariant pa.current auth_id}
    {[@expl:reroot requires #1] contains'0 (view'4 pa.current.t_PA__auth) (id (view'1 cur))}
    {[@expl:reroot requires #2] forall id'2: t_Id. contains'0 (view'4 pa.current.t_PA__auth) id'2
        /\ index_logic'3 pa.current.t_PA__depth id'2 <= index_logic'3 pa.current.t_PA__depth (id (view'1 cur))
      -> contains pa.current.t_PA__perms id'2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'11 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_17 <- _ret ] -{inv'11 _ret.final}-
            [ &pa <- _ret.final ] s1)
      | s1 = deref_mut {_17} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_16 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = deref {cur} (fun (_ret: t_PermCell) -> [ &_24 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = id_ghost {_24} (fun (_ret: t_Id) -> [ &_22 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_21 <- _22 ] s1 | s1 = deref'0 {_21} (fun (_ret: t_Id) -> [ &_19 <- _ret ] s2) | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv'7 _16.current.current.t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {_16.current.current.t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_15 <- _ret ] -{inv'7 _ret.final}-
            [ &_16 <- { _16 with current = { _16.current with current = { _16.current.current with t_PA__perms = _ret.final } } } ]
            s1)
      | s1 = remove_ghost {_15} {_19} (fun (_ret: t_Option) -> [ &_14 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'13 _16} s1
      | s1 = -{resolve'0 _16}- s2
      | s2 = unwrap {_14} (fun (_ret: t_PermCellOwn) -> [ &_13 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = new {_13} (fun (_ret: t_PermCellOwn) -> [ &perm_cur <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = deref {cur} (fun (_ret: t_PermCell) -> [ &_29 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0
      [ s0 = {inv'16 perm_cur}
        MutBorrow.borrow_mut <t_PermCellOwn> {perm_cur}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_36 <- _ret ] -{inv'16 _ret.final}-
            [ &perm_cur <- _ret.final ] s1)
      | s1 = {inv'16 _36.current}
        MutBorrow.borrow_final <t_PermCellOwn> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_35 <- _ret ] -{inv'16 _ret.final}-
            [ &_36 <- { _36 with current = _ret.final } ] s2)
      | s2 = deref_mut'0 {_35} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_34 <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0
      [ s0 = {inv'6 _34.current}
        MutBorrow.borrow_final <t_PermCellOwn> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_33 <- _ret ] -{inv'6 _ret.final}-
            [ &_34 <- { _34 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'17 _36} s2
      | s2 = -{resolve'2 _36}- s3
      | s3 = {[@expl:type invariant] inv'18 _34} s4
      | s4 = -{resolve'4 _34}- s5
      | s5 = {inv'6 _33.current}
        MutBorrow.borrow_final <t_PermCellOwn> {_33.current} {MutBorrow.get_id _33}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_32 <- _ret ] -{inv'6 _ret.final}-
            [ &_33 <- { _33 with current = _ret.final } ] s6)
      | s6 = new'0 {_32} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_31 <- _ret ] s7)
      | s7 = bb10 ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'18 _33} s1
      | s1 = -{resolve'4 _33}- s2
      | s2 = borrow_mut {_29} {_31} (fun (_ret: MutBorrow.t t_Inner) -> [ &_27 <- _ret ] s3)
      | s3 = bb11 ]
    | bb11 = s0
      [ s0 = {inv'4 _27.current}
        MutBorrow.borrow_final <t_Inner> {_27.current} {MutBorrow.get_id _27}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &bor_cur <- _ret ] -{inv'4 _ret.final}-
            [ &_27 <- { _27 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'20 _27} s2
      | s2 = -{resolve'6 _27}- s3
      | s3 = any
        [ br0 (x0: t_Vec) -> {bor_cur.current = C_Direct x0} (! bb12)
        | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {bor_cur.current = C_Link x0 x1 x2} (! bb21) ] ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'20 bor_cur} s1
      | s1 = -{resolve'6 bor_cur}- s2
      | s2 = {inv'11 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_42 <- _ret ] -{inv'11 _ret.final}-
            [ &pa <- _ret.final ] s3)
      | s3 = deref_mut {_42} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_41 <- _ret ] s4)
      | s4 = bb13 ]
    | bb13 = s0 [ s0 = deref {cur} (fun (_ret: t_PermCell) -> [ &_48 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0 [ s0 = id_ghost {_48} (fun (_ret: t_Id) -> [ &_46 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = deref'0 {_46} (fun (_ret: t_Id) -> [ &_44 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = s0 [ s0 = into_inner {perm_cur} (fun (_ret: t_PermCellOwn) -> [ &_50 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = {inv'7 _41.current.current.t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {_41.current.current.t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_40 <- _ret ] -{inv'7 _ret.final}-
            [ &_41 <- { _41 with current = { _41.current with current = { _41.current.current with t_PA__perms = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_40} {_44} {_50} (fun (_ret: t_Option) -> [ &_39 <- _ret ] s2)
      | s2 = bb18 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'13 _41} s1
      | s1 = -{resolve'0 _41}- s2
      | s2 = {[@expl:type invariant] inv'11 pa} s3
      | s3 = -{resolve'10 pa}- s4
      | s4 = new'1 {_39} (fun (_ret: t_Option) -> [ &_38 <- _ret ] s5)
      | s5 = {[@expl:type invariant] inv'21 _38} s6
      | s6 = -{resolve'17 _38}- s7
      | s7 = bb53 ]
    | bb21 = s0
      [ s0 = v_Link {bor_cur.current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            MutBorrow.borrow_mut <t_Rc> {rnext}
              (fun (_ret: MutBorrow.t t_Rc) ->
                [ &next <- _ret ] [ &bor_cur <- { bor_cur with current = C_Link rindex rvalue _ret.final } ] s1))
      | s1 = v_Link {bor_cur.current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            {inv'0 rvalue}
            MutBorrow.borrow_mut <t_T> {rvalue}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &value <- _ret ] -{inv'0 _ret.final}-
                [ &bor_cur <- { bor_cur with current = C_Link rindex _ret.final rnext } ] s2))
      | s2 = v_Link {bor_cur.current}
          (fun (rindex: UInt64.t) (rvalue: t_T) (rnext: t_Rc) ->
            MutBorrow.borrow_mut <UInt64.t> {rindex}
              (fun (_ret: MutBorrow.t UInt64.t) ->
                [ &index <- _ret ] [ &bor_cur <- { bor_cur with current = C_Link _ret.final rvalue rnext } ] s3))
      | s3 = [ &_58 <- next ] s4
      | s4 = {inv'11 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_65 <- _ret ] -{inv'11 _ret.final}-
            [ &pa <- _ret.final ] s5)
      | s5 = deref_mut {_65} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_64 <- _ret ] s6)
      | s6 = bb22 ]
    | bb22 = s0
      [ s0 = {inv'10 _64.current}
        MutBorrow.borrow_final <MutBorrow.t t_PA> {_64.current} {MutBorrow.get_id _64}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_63 <- _ret ] -{inv'10 _ret.final}-
            [ &_64 <- { _64 with current = _ret.final } ] s1)
      | s1 = {inv'9 _63.current.current}
        MutBorrow.borrow_mut <t_PA> {_63.current.current}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_62 <- _ret ] -{inv'9 _ret.final}-
            [ &_63 <- { _63 with current = { _63.current with current = _ret.final } } ] s2)
      | s2 = {[@expl:type invariant] inv'13 _64} s3
      | s3 = -{resolve'0 _64}- s4
      | s4 = {[@expl:type invariant] inv'13 _63} s5
      | s5 = -{resolve'0 _63}- s6
      | s6 = {inv'9 _62.current}
        MutBorrow.borrow_final <t_PA> {_62.current} {MutBorrow.get_id _62}
          (fun (_ret: MutBorrow.t t_PA) ->
            [ &_61 <- _ret ] -{inv'9 _ret.final}-
            [ &_62 <- { _62 with current = _ret.final } ] s7)
      | s7 = new'2 {_61} (fun (_ret: MutBorrow.t t_PA) -> [ &_60 <- _ret ] s8)
      | s8 = bb23 ]
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'10 _62} s1
      | s1 = -{resolve'8 _62}- s2
      | s2 = reroot {_58.current} {auth_id} {_60} (fun (_ret: ()) -> [ &_56 <- _ret ] s3)
      | s3 = bb24 ]
    | bb24 = s0 [ s0 = clone' {cur} (fun (_ret: t_Rc) -> [ &_68 <- _ret ] s1) | s1 = bb25 ]
    | bb25 = s0
      [ s0 = MutBorrow.borrow_final <t_Rc> {next.current} {MutBorrow.get_id next}
          (fun (_ret: MutBorrow.t t_Rc) -> [ &_67 <- _ret ] [ &next <- { next with current = _ret.final } ] s1)
      | s1 = replace {_67} {_68} (fun (_ret: t_Rc) -> [ &next'0 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = s0
      [ s0 = -{resolve'19 next}- s1
      | s1 = {inv'11 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_76 <- _ret ] -{inv'11 _ret.final}-
            [ &pa <- _ret.final ] s2)
      | s2 = deref_mut {_76} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_75 <- _ret ] s3)
      | s3 = bb27 ]
    | bb27 = s0 [ s0 = deref {next'0} (fun (_ret: t_PermCell) -> [ &_83 <- _ret ] s1) | s1 = bb28 ]
    | bb28 = s0 [ s0 = id_ghost {_83} (fun (_ret: t_Id) -> [ &_81 <- _ret ] s1) | s1 = bb29 ]
    | bb29 = s0 [ s0 = deref'0 {_81} (fun (_ret: t_Id) -> [ &_79 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0
      [ s0 = [ &_78 <- _79 ] s1
      | s1 = {inv'7 _75.current.current.t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {_75.current.current.t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_74 <- _ret ] -{inv'7 _ret.final}-
            [ &_75 <- { _75 with current = { _75.current with current = { _75.current.current with t_PA__perms = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost {_74} {_78} (fun (_ret: t_Option'0) -> [ &_73 <- _ret ] s3)
      | s3 = bb31 ]
    | bb31 = s0 [ s0 = unwrap'0 {_73} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_72 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0
      [ s0 = {[@expl:type invariant] inv'13 _75} s1
      | s1 = -{resolve'0 _75}- s2
      | s2 = {inv'6 _72.current}
        MutBorrow.borrow_final <t_PermCellOwn> {_72.current} {MutBorrow.get_id _72}
          (fun (_ret: MutBorrow.t t_PermCellOwn) ->
            [ &_71 <- _ret ] -{inv'6 _ret.final}-
            [ &_72 <- { _72 with current = _ret.final } ] s3)
      | s3 = new'0 {_71} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &perm_next <- _ret ] s4)
      | s4 = bb33 ]
    | bb33 = s0
      [ s0 = {[@expl:type invariant] inv'18 _72} s1
      | s1 = -{resolve'4 _72}- s2
      | s2 = deref {next'0} (fun (_ret: t_PermCell) -> [ &_88 <- _ret ] s3)
      | s3 = bb34 ]
    | bb34 = s0
      [ s0 = borrow_mut {_88} {perm_next} (fun (_ret: MutBorrow.t t_Inner) -> [ &_86 <- _ret ] s1) | s1 = bb35 ]
    | bb35 = s0
      [ s0 = {inv'4 _86.current}
        MutBorrow.borrow_final <t_Inner> {_86.current} {MutBorrow.get_id _86}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &bor_next <- _ret ] -{inv'4 _ret.final}-
            [ &_86 <- { _86 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'20 _86} s2
      | s2 = -{resolve'6 _86}- s3
      | s3 = any
        [ br0 (x0: t_Vec) -> {bor_next.current = C_Direct x0} (! bb38)
        | br1 (x0: UInt64.t) (x1: t_T) (x2: t_Rc) -> {bor_next.current = C_Link x0 x1 x2} (! bb36) ] ]
    | bb36 = s0
      [ s0 = {[@expl:type invariant] inv'20 bor_next} s1
      | s1 = -{resolve'6 bor_next}- s2
      | s2 = -{resolve'21 index}- s3
      | s3 = {[@expl:type invariant] inv'23 value} s4
      | s4 = -{resolve'23 value}- s5
      | s5 = {false} any ]
    | bb38 = s0
      [ s0 = v_Direct {bor_next.current}
          (fun (r0: t_Vec) ->
            {inv'3 r0}
            MutBorrow.borrow_mut <t_Vec> {r0}
              (fun (_ret: MutBorrow.t t_Vec) ->
                [ &arr <- _ret ] -{inv'3 _ret.final}-
                [ &bor_next <- { bor_next with current = C_Direct _ret.final } ] s1))
      | s1 = {inv'3 arr.current}
        MutBorrow.borrow_final <t_Vec> {arr.current} {MutBorrow.get_id arr}
          (fun (_ret: MutBorrow.t t_Vec) ->
            [ &_98 <- _ret ] -{inv'3 _ret.final}-
            [ &arr <- { arr with current = _ret.final } ] s2)
      | s2 = -{resolve'21 index}- s3
      | s3 = index_mut {_98} {index.current} (fun (_ret: MutBorrow.t t_T) -> [ &_97 <- _ret ] s4)
      | s4 = bb39 ]
    | bb39 = s0
      [ s0 = {inv'0 _97.current}
        MutBorrow.borrow_final <t_T> {_97.current} {MutBorrow.get_id _97}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_96 <- _ret ] -{inv'0 _ret.final}-
            [ &_97 <- { _97 with current = _ret.final } ] s1)
      | s1 = {inv'0 _96.current}
        MutBorrow.borrow_final <t_T> {_96.current} {MutBorrow.get_id _96}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_95 <- _ret ] -{inv'0 _ret.final}-
            [ &_96 <- { _96 with current = _ret.final } ] s2)
      | s2 = {inv'0 value.current}
        MutBorrow.borrow_final <t_T> {value.current} {MutBorrow.get_id value}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_100 <- _ret ] -{inv'0 _ret.final}-
            [ &value <- { value with current = _ret.final } ] s3)
      | s3 = swap {_95} {_100} (fun (_ret: ()) -> [ &_94 <- _ret ] s4)
      | s4 = bb40 ]
    | bb40 = s0
      [ s0 = {[@expl:type invariant] inv'23 _97} s1
      | s1 = -{resolve'23 _97}- s2
      | s2 = {[@expl:type invariant] inv'23 _96} s3
      | s3 = -{resolve'23 _96}- s4
      | s4 = {[@expl:type invariant] inv'24 arr} s5
      | s5 = -{resolve'25 arr}- s6
      | s6 = {[@expl:type invariant] inv'23 value} s7
      | s7 = -{resolve'23 value}- s8
      | s8 = {inv'4 bor_next.current}
        MutBorrow.borrow_final <t_Inner> {bor_next.current} {MutBorrow.get_id bor_next}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &_102 <- _ret ] -{inv'4 _ret.final}-
            [ &bor_next <- { bor_next with current = _ret.final } ] s9)
      | s9 = {inv'4 bor_cur.current}
        MutBorrow.borrow_final <t_Inner> {bor_cur.current} {MutBorrow.get_id bor_cur}
          (fun (_ret: MutBorrow.t t_Inner) ->
            [ &_103 <- _ret ] -{inv'4 _ret.final}-
            [ &bor_cur <- { bor_cur with current = _ret.final } ] s10)
      | s10 = swap'0 {_102} {_103} (fun (_ret: ()) -> [ &_101 <- _ret ] s11)
      | s11 = bb41 ]
    | bb41 = s0
      [ s0 = {[@expl:type invariant] inv'20 bor_next} s1
      | s1 = -{resolve'6 bor_next}- s2
      | s2 = {[@expl:type invariant] inv'20 bor_cur} s3
      | s3 = -{resolve'6 bor_cur}- s4
      | s4 = {inv'11 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_109 <- _ret ] -{inv'11 _ret.final}-
            [ &pa <- _ret.final ] s5)
      | s5 = deref_mut {_109} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_108 <- _ret ] s6)
      | s6 = bb42 ]
    | bb42 = s0 [ s0 = deref {cur} (fun (_ret: t_PermCell) -> [ &_115 <- _ret ] s1) | s1 = bb43 ]
    | bb43 = s0 [ s0 = id_ghost {_115} (fun (_ret: t_Id) -> [ &_113 <- _ret ] s1) | s1 = bb44 ]
    | bb44 = s0 [ s0 = deref'0 {_113} (fun (_ret: t_Id) -> [ &_111 <- _ret ] s1) | s1 = bb45 ]
    | bb45 = s0 [ s0 = into_inner {perm_cur} (fun (_ret: t_PermCellOwn) -> [ &_117 <- _ret ] s1) | s1 = bb46 ]
    | bb46 = s0
      [ s0 = {inv'7 _108.current.current.t_PA__perms}
        MutBorrow.borrow_mut <t_FMap> {_108.current.current.t_PA__perms}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_107 <- _ret ] -{inv'7 _ret.final}-
            [ &_108 <- { _108 with current = { _108.current with current = { _108.current.current with t_PA__perms = _ret.final } } } ]
            s1)
      | s1 = insert_ghost {_107} {_111} {_117} (fun (_ret: t_Option) -> [ &_106 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'15 _106} s3
      | s3 = -{resolve'15 _106}- s4
      | s4 = bb47 ]
    | bb47 = s0
      [ s0 = {[@expl:type invariant] inv'13 _108} s1
      | s1 = -{resolve'0 _108}- s2
      | s2 =
        [ &new_d <- MinMax.min (Map.get pa.current.t_PA__depth (id (view'1 cur))) (Map.get pa.current.t_PA__depth (id (view'1 next'0))
        - 1) ] s3
      | s3 = bb48 ]
    | bb48 = s0 [ s0 = [ &_121 <- Map.set pa.current.t_PA__depth (id (view'1 cur)) new_d ] s1 | s1 = bb49 ]
    | bb49 = s0
      [ s0 = {inv'11 pa}
        MutBorrow.borrow_mut <MutBorrow.t t_PA> {pa}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) ->
            [ &_124 <- _ret ] -{inv'11 _ret.final}-
            [ &pa <- _ret.final ] s1)
      | s1 = deref_mut {_124} (fun (_ret: MutBorrow.t (MutBorrow.t t_PA)) -> [ &_123 <- _ret ] s2)
      | s2 = bb50 ]
    | bb50 = s0
      [ s0 =
        [ &_123 <- { _123 with current = { _123.current with current = { _123.current.current with t_PA__depth = _121 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv'13 _123} s2
      | s2 = -{resolve'0 _123}- s3
      | s3 = {[@expl:type invariant] inv'11 pa} s4
      | s4 = -{resolve'10 pa}- s5
      | s5 = new'3 {_105} (fun (_ret: ()) -> [ &_104 <- _ret ] s6)
      | s6 = bb53 ]
    | bb53 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & cur: t_Rc = cur
    | & auth_id: t_Id = auth_id
    | & pa: MutBorrow.t t_PA = pa
    | & perm_cur: t_PermCellOwn = Any.any_l ()
    | & _13: t_PermCellOwn = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_FMap = Any.any_l ()
    | & _16: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _17: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _19: t_Id = Any.any_l ()
    | & _21: t_Id = Any.any_l ()
    | & _22: t_Id = Any.any_l ()
    | & _24: t_PermCell = Any.any_l ()
    | & bor_cur: MutBorrow.t t_Inner = Any.any_l ()
    | & _27: MutBorrow.t t_Inner = Any.any_l ()
    | & _29: t_PermCell = Any.any_l ()
    | & _31: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _32: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _33: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _34: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _35: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _36: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _38: t_Option = Any.any_l ()
    | & _39: t_Option = Any.any_l ()
    | & _40: MutBorrow.t t_FMap = Any.any_l ()
    | & _41: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _42: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _44: t_Id = Any.any_l ()
    | & _46: t_Id = Any.any_l ()
    | & _48: t_PermCell = Any.any_l ()
    | & _50: t_PermCellOwn = Any.any_l ()
    | & next: MutBorrow.t t_Rc = Any.any_l ()
    | & value: MutBorrow.t t_T = Any.any_l ()
    | & index: MutBorrow.t UInt64.t = Any.any_l ()
    | & _56: () = Any.any_l ()
    | & _58: MutBorrow.t t_Rc = Any.any_l ()
    | & _60: MutBorrow.t t_PA = Any.any_l ()
    | & _61: MutBorrow.t t_PA = Any.any_l ()
    | & _62: MutBorrow.t t_PA = Any.any_l ()
    | & _63: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _64: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _65: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & next'0: t_Rc = Any.any_l ()
    | & _67: MutBorrow.t t_Rc = Any.any_l ()
    | & _68: t_Rc = Any.any_l ()
    | & perm_next: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _71: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _72: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _73: t_Option'0 = Any.any_l ()
    | & _74: MutBorrow.t t_FMap = Any.any_l ()
    | & _75: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _76: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _78: t_Id = Any.any_l ()
    | & _79: t_Id = Any.any_l ()
    | & _81: t_Id = Any.any_l ()
    | & _83: t_PermCell = Any.any_l ()
    | & bor_next: MutBorrow.t t_Inner = Any.any_l ()
    | & _86: MutBorrow.t t_Inner = Any.any_l ()
    | & _88: t_PermCell = Any.any_l ()
    | & arr: MutBorrow.t t_Vec = Any.any_l ()
    | & _94: () = Any.any_l ()
    | & _95: MutBorrow.t t_T = Any.any_l ()
    | & _96: MutBorrow.t t_T = Any.any_l ()
    | & _97: MutBorrow.t t_T = Any.any_l ()
    | & _98: MutBorrow.t t_Vec = Any.any_l ()
    | & _100: MutBorrow.t t_T = Any.any_l ()
    | & _101: () = Any.any_l ()
    | & _102: MutBorrow.t t_Inner = Any.any_l ()
    | & _103: MutBorrow.t t_Inner = Any.any_l ()
    | & _104: () = Any.any_l ()
    | & _105: () = Any.any_l ()
    | & _106: t_Option = Any.any_l ()
    | & _107: MutBorrow.t t_FMap = Any.any_l ()
    | & _108: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _109: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _111: t_Id = Any.any_l ()
    | & _113: t_Id = Any.any_l ()
    | & _115: t_PermCell = Any.any_l ()
    | & _117: t_PermCellOwn = Any.any_l ()
    | & new_d: int = Any.any_l ()
    | & _121: Map.map t_Id int = Any.any_l ()
    | & _123: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l ()
    | & _124: MutBorrow.t (MutBorrow.t t_PA) = Any.any_l () ])
    [ return (result: ()) -> {[@expl:reroot ensures #0] partial_invariant (fin'0 pa) auth_id}
      {[@expl:reroot ensures #1] (fin'0 pa).t_PA__auth = pa.current.t_PA__auth}
      {[@expl:reroot ensures #2] forall id'2: t_Id. index_logic'3 pa.current.t_PA__depth id'2
          > index_logic'3 pa.current.t_PA__depth (id (view'1 cur))
        -> get pa.current.t_PA__perms id'2 = get (fin'0 pa).t_PA__perms id'2
        /\ index_logic'3 pa.current.t_PA__depth id'2 = index_logic'3 (fin'0 pa).t_PA__depth id'2}
      {[@expl:reroot ensures #3] forall id'2: t_Id. contains (fin'0 pa).t_PA__perms id'2
        = contains pa.current.t_PA__perms id'2}
      {[@expl:reroot ensures #4] match val' (index_logic'0 (fin'0 pa).t_PA__perms (id (view'1 cur))) with
        | C_Direct _ -> true
        | C_Link _ _ _ -> false
        end}
      (! return {result}) ]
end
module M_persistent_array__testing
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use set.Set
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq Int32.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 [@inline:trivial] (self: Slice64.slice Int32.t) : Seq.seq Int32.t = Slice64.view self
  
  meta "rewrite_def" function view'0
  
  let rec into_vec (self_: Slice64.slice Int32.t) (return (x: t_Vec)) = any
    [ return' (result: t_Vec) -> {view result = view'0 self_} (! return {result}) ]
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull'0; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq Int32.t }
  
  type t_NonNull'1 = { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'1; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  predicate invariant' (self: t_PersistentArray)
  
  predicate invariant''0 (self: t_Fragment)
  
  predicate inv (_1: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
      = (invariant''0 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''1 [@inline:trivial] (self: t_Fragment) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'0 (_1: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''1 x
  
  predicate inv'1 (_1: t_PersistentArray)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PersistentArray [inv'1 x]. inv'1 x
      = (invariant' x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'2} -> inv'0 frag
        end)
  
  function view'1 (self: t_PersistentArray) : Seq.seq Int32.t
  
  let rec new (v: t_Vec) (return (x: t_PersistentArray)) = any
    [ return' (result: t_PersistentArray) -> {inv'1 result} {view'1 result = view v} (! return {result}) ]
  
  type t_Tokens
  
  let rec deref_mut (self: MutBorrow.t t_Tokens) (return (x: MutBorrow.t t_Tokens)) = any
    [ return' (result: MutBorrow.t t_Tokens) -> {result = self} (! return {result}) ]
  
  let rec reborrow (self: MutBorrow.t t_Tokens) (return (x: t_Tokens)) = any
    [ return' (result: t_Tokens) -> {result = self.current /\ self.final = self.current} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Tokens) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Tokens) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec new'0 (x: t_Tokens) (return (x'0: t_Tokens)) = any
    [ return' (result: t_Tokens) -> {result = x} (! return {result}) ]
  
  predicate invariant''2 [@inline:trivial] (self: t_PersistentArray) = inv'1 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 (_1: t_PersistentArray)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PersistentArray [inv'2 x]. inv'2 x = invariant''2 x
  
  predicate contains [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = Set.mem e self
  
  meta "rewrite_def" predicate contains
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'0 (self: t_Tokens) (namespace: t_Namespace) = contains (namespaces self) namespace
  
  let rec set (self: t_PersistentArray) (index: UInt64.t) (value: Int32.t) (tokens: t_Tokens)
    (return (x: t_PersistentArray)) = {[@expl:set 'self' type invariant] inv'2 self}
    {[@expl:set requires #0] UInt64.t'int index < Seq.length (view'1 self)}
    {[@expl:set requires #1] contains'0 tokens (Namespace_PARRAY 0)}
    any
    [ return' (result: t_PersistentArray) -> {inv'1 result}
      {view'1 result = Seq.set (view'1 self) (UInt64.t'int index) value}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (_1: t_Tokens) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (self: t_Tokens) = resolve'1 self
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_Tokens) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  let rec clone' (self: t_PersistentArray) (return (x: t_PersistentArray)) =
    {[@expl:clone 'self' type invariant] inv'2 self}
    any [ return' (result: t_PersistentArray) -> {inv'1 result} {view'1 result = view'1 self} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec testing (tokens: t_Tokens) (return (x: ())) =
    {[@expl:testing requires] contains'0 tokens (Namespace_PARRAY 0)}
    (! bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0 = (1: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 1 = (2: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 2 = (3: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 3 = (4: Int32.t) /\ Seq.length __arr_temp.Slice64.elts = 4}-
          [ &_7 <- __arr_temp ] s1) ]
      | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_vec {_7} (fun (_ret: t_Vec) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_4} (fun (_ret: t_PersistentArray) -> [ &a <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_mut <t_Tokens> {tokens}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_14 <- _ret ] [ &tokens <- _ret.final ] s1)
      | s1 = deref_mut {_14} (fun (_ret: MutBorrow.t t_Tokens) -> [ &_13 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = MutBorrow.borrow_final <t_Tokens> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_12 <- _ret ] [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = reborrow {_12} (fun (_ret: t_Tokens) -> [ &_11 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = -{resolve'0 _13}- s1 | s1 = new'0 {_11} (fun (_ret: t_Tokens) -> [ &_10 <- _ret ] s2) | s2 = bb7 ]
    | bb7 = s0
      [ s0 = set {a} {(1: UInt64.t)} {(42: Int32.t)} {_10} (fun (_ret: t_PersistentArray) -> [ &a2 <- _ret ] s1)
      | s1 = bb8 ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Tokens> {tokens}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_21 <- _ret ] [ &tokens <- _ret.final ] s1)
      | s1 = deref_mut {_21} (fun (_ret: MutBorrow.t t_Tokens) -> [ &_20 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = MutBorrow.borrow_final <t_Tokens> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_Tokens) -> [ &_19 <- _ret ] [ &_20 <- { _20 with current = _ret.final } ] s1)
      | s1 = reborrow {_19} (fun (_ret: t_Tokens) -> [ &_18 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = -{resolve'0 _20}- s1 | s1 = new'0 {_18} (fun (_ret: t_Tokens) -> [ &_17 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0
      [ s0 = set {a} {(0: UInt64.t)} {(50: Int32.t)} {_17} (fun (_ret: t_PersistentArray) -> [ &a3 <- _ret ] s1)
      | s1 = bb12 ]
    | bb12 = s0
      [ s0 = -{resolve'3 tokens}- s1
      | s1 = clone' {a} (fun (_ret: t_PersistentArray) -> [ &a4 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = [ &a_model <- Seq.create 4 [|(1: Int32.t);(2: Int32.t);(3: Int32.t);(4: Int32.t)|] ] s1 | s1 = bb14 ]
    | bb14 = s0
      [ s0 = [ &a2_model <- Seq.create 4 [|(1: Int32.t);(42: Int32.t);(3: Int32.t);(4: Int32.t)|] ] s1 | s1 = bb15 ]
    | bb15 = s0
      [ s0 = [ &a3_model <- Seq.create 4 [|(50: Int32.t);(2: Int32.t);(3: Int32.t);(4: Int32.t)|] ] s1 | s1 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:assertion] view'1 a = a_model} s1
      | s1 = {[@expl:assertion] view'1 a2 = a2_model} s2
      | s2 = {[@expl:assertion] view'1 a3 = a3_model} s3
      | s3 = {[@expl:assertion] view'1 a4 = a_model} s4
      | s4 = bb20 ]
    | bb20 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & tokens: t_Tokens = tokens
    | & a: t_PersistentArray = Any.any_l ()
    | & _4: t_Vec = Any.any_l ()
    | & _7: Slice64.array Int32.t = Any.any_l ()
    | & a2: t_PersistentArray = Any.any_l ()
    | & _10: t_Tokens = Any.any_l ()
    | & _11: t_Tokens = Any.any_l ()
    | & _12: MutBorrow.t t_Tokens = Any.any_l ()
    | & _13: MutBorrow.t t_Tokens = Any.any_l ()
    | & _14: MutBorrow.t t_Tokens = Any.any_l ()
    | & a3: t_PersistentArray = Any.any_l ()
    | & _17: t_Tokens = Any.any_l ()
    | & _18: t_Tokens = Any.any_l ()
    | & _19: MutBorrow.t t_Tokens = Any.any_l ()
    | & _20: MutBorrow.t t_Tokens = Any.any_l ()
    | & _21: MutBorrow.t t_Tokens = Any.any_l ()
    | & a4: t_PersistentArray = Any.any_l ()
    | & a_model: Seq.seq Int32.t = Any.any_l ()
    | & a2_model: Seq.seq Int32.t = Any.any_l ()
    | & a3_model: Seq.seq Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_persistent_array__implementation__qyi15164097500274694161__clone__refines (* <implementation::PersistentArray<T> as creusot_contracts::Clone> *)
  type namespace_other
  
  type t_Namespace = Namespace_PARRAY int | Other namespace_other
  
  use creusot.prelude.Opaque
  use seq.Seq
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Resource
  
  type t_Id
  
  type t_T
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_Id; t_Fragment__2: Seq.seq t_T }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Rc'0 = { t_Rc__ptr'0: t_NonNull'0; t_Rc__phantom'0: (); t_Rc__alloc'0: () }
  
  type t_PersistentArray = {
    t_PersistentArray__permcell: t_Rc;
    t_PersistentArray__frag: t_Fragment;
    t_PersistentArray__inv: t_Rc'0 }
  
  type tuple = { f0: t_Id; f1: Seq.seq t_T }
  
  function view (self: t_Fragment) : tuple
  
  type t_PermCell
  
  function id (self: t_PermCell) : t_Id
  
  function view'0 (self: t_Rc) : t_PermCell
  
  function id'0 (self: t_Fragment) : t_Id
  
  type t_LocalInvariant
  
  function public (self: t_LocalInvariant) : t_Id
  
  function view'1 (self: t_Rc'0) : t_LocalInvariant
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  predicate invariant' (self: t_PersistentArray) =
    (view self.t_PersistentArray__frag).f0 = id (view'0 self.t_PersistentArray__permcell)
    /\ id'0 self.t_PersistentArray__frag = public (view'1 self.t_PersistentArray__inv)
    /\ namespace (view'1 self.t_PersistentArray__inv) = Namespace_PARRAY 0
  
  predicate invariant''0 (self: t_Fragment)
  
  predicate inv (_1: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
      = (invariant''0 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''1 [@inline:trivial] (self: t_Fragment) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'0 (_1: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''1 x
  
  predicate inv'1 (_1: t_PersistentArray)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PersistentArray [inv'1 x]. inv'1 x
      = (invariant' x
      /\ match x with
        | {t_PersistentArray__permcell = permcell; t_PersistentArray__frag = frag; t_PersistentArray__inv = inv'2} -> inv'0 frag
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_PersistentArray) = inv'1 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 (_1: t_PersistentArray)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PersistentArray [inv'2 x]. inv'2 x = invariant''2 x
  
  function view'2 [@inline:trivial] (self: t_PersistentArray) : Seq.seq t_T = (view self.t_PersistentArray__frag).f1
  
  meta "rewrite_def" function view'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PersistentArray. inv'2 self_
      -> inv'2 self_ /\ (forall result: t_PersistentArray. view'2 result = view'2 self_ /\ inv'1 result -> inv'1 result)
end
