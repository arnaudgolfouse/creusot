module M_knapsack_full__max
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.MinMax
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec max (a: UInt64.t) (b: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- UInt64.lt a b ] s1 | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- b ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_0 <- a ] s1 | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & a: UInt64.t = a | & b: UInt64.t = b | & _4: bool = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:max ensures] UInt64.t'int result
      = MinMax.max (UInt64.t'int a) (UInt64.t'int b)}
      (! return {result}) ]
end
module M_knapsack_full__sum_weights
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Seq.seq t_Item
  
  constant i : int
  
  function sum_weights (s: Seq.seq t_Item) (i: int) : int
  
  goal vc_sum_weights: 0 <= i /\ i <= Seq.length s
    -> (if i = Seq.length s then
      [@expl:sum_weights ensures] 0 >= 0
    else
      (([@expl:sum_weights requires] 0 <= i + 1 /\ i + 1 <= Seq.length s)
        /\ well_founded_relation (Seq.length s - i) (Seq.length s - (i + 1)))
      /\ (sum_weights s (i + 1) >= 0
      -> ([@expl:sum_weights ensures] UInt64.t'int (Seq.get s i).t_Item__weight + sum_weights s (i + 1) >= 0))
    )
end
module M_knapsack_full__sum_values
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Seq.seq t_Item
  
  constant i : int
  
  function sum_values (s: Seq.seq t_Item) (i: int) : int
  
  goal vc_sum_values: i >= 0 /\ i <= Seq.length s
    -> (if i = Seq.length s then
      true
    else
      ([@expl:sum_values requires] i + 1 >= 0 /\ i + 1 <= Seq.length s)
      /\ well_founded_relation (Seq.length s - i) (Seq.length s - (i + 1))
    )
end
module M_knapsack_full__subseq_rev
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s1 : Seq.seq t_T
  
  constant i1 : int
  
  constant s2 : Seq.seq t_T
  
  constant i2 : int
  
  predicate subseq_rev (s1: Seq.seq t_T) (i1: int) (s2: Seq.seq t_T) (i2: int)
  
  goal vc_subseq_rev: 0 <= i1 /\ i1 <= Seq.length s1
    -> 0 <= i2 /\ i2 <= Seq.length s2
    -> (if i2 = 0 then
      true
    else
      if i1 < Seq.length s1 then
        if Seq.get s1 i1 = Seq.get s2 (i2 - 1) then
          ((([@expl:subseq_rev requires #0] 0 <= i1 + 1 /\ i1 + 1 <= Seq.length s1)
              && ([@expl:subseq_rev requires #1] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
            /\ well_founded_relation i2 (i2 - 1))
          /\ (if subseq_rev s1 (i1 + 1) s2 (i2 - 1) then
            true
          else
            (([@expl:subseq_rev requires #0] 0 <= i1 /\ i1 <= Seq.length s1)
              && ([@expl:subseq_rev requires #1] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
            /\ well_founded_relation i2 (i2 - 1)
          )
        else
          (([@expl:subseq_rev requires #0] 0 <= i1 /\ i1 <= Seq.length s1)
            && ([@expl:subseq_rev requires #1] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
          /\ well_founded_relation i2 (i2 - 1)
      
      else
        (([@expl:subseq_rev requires #0] 0 <= i1 /\ i1 <= Seq.length s1)
          && ([@expl:subseq_rev requires #1] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
        /\ well_founded_relation i2 (i2 - 1)
    
    )
end
module M_knapsack_full__m
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate subseq_rev (s1: Seq.seq t_Item) (i1: int) (s2: Seq.seq t_Item) (i2: int)
  
  axiom subseq_rev_def: forall s1: Seq.seq t_Item, i1: int, s2: Seq.seq t_Item, i2: int. 0 <= i1 /\ i1 <= Seq.length s1
      -> 0 <= i2 /\ i2 <= Seq.length s2
      -> subseq_rev s1 i1 s2 i2
      = (if i2 = 0 then
        i1 = Seq.length s1
      else
        i1 < Seq.length s1 /\ Seq.get s1 i1 = Seq.get s2 (i2 - 1) /\ subseq_rev s1 (i1 + 1) s2 (i2 - 1)
        \/ subseq_rev s1 i1 s2 (i2 - 1)
      )
  
  function sum_weights (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_weights_def: forall s: Seq.seq t_Item, i: int. 0 <= i /\ i <= Seq.length s
      -> sum_weights s i
      = (if i = Seq.length s then 0 else UInt64.t'int (Seq.get s i).t_Item__weight + sum_weights s (i + 1))
  
  axiom sum_weights_spec: forall s: Seq.seq t_Item, i: int. 0 <= i /\ i <= Seq.length s -> sum_weights s i >= 0
  
  function sum_values (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_values_def: forall s: Seq.seq t_Item, i: int. i >= 0 /\ i <= Seq.length s
      -> sum_values s i
      = (if i = Seq.length s then 0 else UInt64.t'int (Seq.get s i).t_Item__value + sum_values s (i + 1))
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant items : Seq.seq t_Item
  
  constant i : int
  
  constant w : int
  
  function m (items: Seq.seq t_Item) (i: int) (w: int) : int
  
  goal vc_m: 0 <= i /\ i <= Seq.length items
    -> 0 <= w
    -> (if i = 0 then
      let result = 0 in ([@expl:m ensures #0] result >= 0)
      && ([@expl:m ensures #1] forall s: Seq.seq t_Item, j: int. 0 <= j
          /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w -> sum_values s j <= result)
    else
      if UInt64.t'int (Seq.get items (i - 1)).t_Item__weight > w then
        ((([@expl:m requires #0] 0 <= i - 1 /\ i - 1 <= Seq.length items) && ([@expl:m requires #1] 0 <= w))
          /\ well_founded_relation i (i - 1))
        /\ (m items (i - 1) w >= 0
          && (forall s: Seq.seq t_Item, j: int. 0 <= j
              /\ j <= Seq.length s /\ subseq_rev s j items (i - 1) /\ sum_weights s j <= w
            -> sum_values s j <= m items (i - 1) w)
        -> (let result = m items (i - 1) w in ([@expl:m ensures #0] result >= 0)
        && ([@expl:m ensures #1] forall s: Seq.seq t_Item, j: int. 0 <= j
            /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w -> sum_values s j <= result)))
      else
        ((([@expl:m requires #0] 0 <= i - 1 /\ i - 1 <= Seq.length items) && ([@expl:m requires #1] 0 <= w))
          /\ well_founded_relation i (i - 1))
        /\ (m items (i - 1) w >= 0
          && (forall s: Seq.seq t_Item, j: int. 0 <= j
              /\ j <= Seq.length s /\ subseq_rev s j items (i - 1) /\ sum_weights s j <= w
            -> sum_values s j <= m items (i - 1) w)
        -> ((([@expl:m requires #0] 0 <= i - 1 /\ i - 1 <= Seq.length items)
            && ([@expl:m requires #1] 0 <= w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight))
          /\ well_founded_relation i (i - 1))
        /\ (m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight) >= 0
          && (forall s: Seq.seq t_Item, j: int. 0 <= j
              /\ j <= Seq.length s
              /\ subseq_rev s j items (i - 1)
              /\ sum_weights s j <= w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight
            -> sum_values s j <= m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight))
        -> (let result = MinMax.max (m items (i - 1) w) (m items (i - 1) (w
          - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight)
        + UInt64.t'int (Seq.get items (i - 1)).t_Item__value) in ([@expl:m ensures #0] result >= 0)
        && ([@expl:m ensures #1] forall s: Seq.seq t_Item, j: int. 0 <= j
            /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w -> sum_values s j <= result))))
    
    )
end
module M_knapsack_full__knapsack01_dyn
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Vec
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : UInt64.t = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  let rec from_elem (elem: UInt64.t) (n: UInt64.t) (return (x: t_Vec)) = any
    [ return (result: t_Vec) -> {Seq.length (view result) = UInt64.t'int n}
      {forall i: int. 0 <= i /\ i < UInt64.t'int n -> index_logic result i = elem}
      (! return {result}) ]
  
  type t_Vec'0
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate inv (_1: t_Name)
  
  predicate inv'0 (_1: t_Item)
  
  axiom inv_axiom [@rewrite]: forall x: t_Item [inv'0 x]. inv'0 x = inv x.t_Item__name
  
  predicate invariant' (self: t_Item) = inv'0 self
  
  predicate inv'1 (_1: t_Item)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Item [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: Seq.seq t_Item)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_Item [inv'2 x]. inv'2 x = invariant''0 x
  
  function view'0 (self: t_Vec'0) : Seq.seq t_Item
  
  axiom view_spec'0: forall self: t_Vec'0. Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec'0) = inv'2 (view'0 self)
  
  predicate inv'3 (_1: t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec'0 [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_Vec'0) = inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_1: t_Vec'0)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Vec'0 [inv'4 x]. inv'4 x = invariant''2 x
  
  let rec len (self_: t_Vec'0) (return (x: UInt64.t)) = {[@expl:len 'self_' type invariant] inv'4 self_}
    any [ return (result: UInt64.t) -> {UInt64.t'int result = Seq.length (view'0 self_)} (! return {result}) ]
  
  type t_Vec'1
  
  function view'1 (self: t_Vec'1) : Seq.seq t_Vec
  
  axiom view_spec'1: forall self: t_Vec'1. Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  function index_logic'0 [@inline:trivial] (self: t_Vec'1) (ix: int) : t_Vec = Seq.get (view'1 self) ix
  
  meta "rewrite_def" function index_logic'0
  
  let rec from_elem'0 (elem: t_Vec) (n: UInt64.t) (return (x: t_Vec'1)) = any
    [ return (result: t_Vec'1) -> {Seq.length (view'1 result) = UInt64.t'int n}
      {forall i: int. 0 <= i /\ i < UInt64.t'int n -> index_logic'0 result i = elem}
      (! return {result}) ]
  
  type t_Range = { t_Range__start: UInt64.t; t_Range__end: UInt64.t }
  
  let rec into_iter (self_: t_Range) (return (x: t_Range)) = any
    [ return (result: t_Range) -> {result = self_} (! return {result}) ]
  
  predicate subseq_rev (s1: Seq.seq t_Item) (i1: int) (s2: Seq.seq t_Item) (i2: int)
  
  axiom subseq_rev_def: forall s1: Seq.seq t_Item, i1: int, s2: Seq.seq t_Item, i2: int. 0 <= i1 /\ i1 <= Seq.length s1
      -> 0 <= i2 /\ i2 <= Seq.length s2
      -> subseq_rev s1 i1 s2 i2
      = (if i2 = 0 then
        i1 = Seq.length s1
      else
        i1 < Seq.length s1 /\ Seq.get s1 i1 = Seq.get s2 (i2 - 1) /\ subseq_rev s1 (i1 + 1) s2 (i2 - 1)
        \/ subseq_rev s1 i1 s2 (i2 - 1)
      )
  
  function sum_weights (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_weights_def: forall s: Seq.seq t_Item, i: int. 0 <= i /\ i <= Seq.length s
      -> sum_weights s i
      = (if i = Seq.length s then 0 else UInt64.t'int (Seq.get s i).t_Item__weight + sum_weights s (i + 1))
  
  axiom sum_weights_spec: forall s: Seq.seq t_Item, i: int. 0 <= i /\ i <= Seq.length s -> sum_weights s i >= 0
  
  function sum_values (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_values_def: forall s: Seq.seq t_Item, i: int. i >= 0 /\ i <= Seq.length s
      -> sum_values s i
      = (if i = Seq.length s then 0 else UInt64.t'int (Seq.get s i).t_Item__value + sum_values s (i + 1))
  
  function m (items: Seq.seq t_Item) (i: int) (w: int) : int
  
  axiom m_def: forall items: Seq.seq t_Item, i: int, w: int. 0 <= i /\ i <= Seq.length items
      -> 0 <= w
      -> m items i w
      = (if i = 0 then
        0
      else
        if UInt64.t'int (Seq.get items (i - 1)).t_Item__weight > w then
          m items (i - 1) w
        else
          MinMax.max (m items (i - 1) w) (m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight)
          + UInt64.t'int (Seq.get items (i - 1)).t_Item__value)
      
      )
  
  axiom m_spec: forall items: Seq.seq t_Item, i: int, w: int. 0 <= i /\ i <= Seq.length items
      -> 0 <= w -> m items i w >= 0
  
  axiom m_spec'0: forall items: Seq.seq t_Item, i: int, w: int. 0 <= i /\ i <= Seq.length items
      -> 0 <= w
      -> (forall s: Seq.seq t_Item, j: int. 0 <= j
          /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w -> sum_values s j <= m items i w)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  predicate produces (self: t_Range) (visited: Seq.seq UInt64.t) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  function produces_trans (a: t_Range) (ab: Seq.seq UInt64.t) (b: t_Range) (bc: Seq.seq UInt64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec:
    forall a: t_Range, ab: Seq.seq UInt64.t, b: t_Range, bc: Seq.seq UInt64.t, c: t_Range. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Range) : ()
  
  axiom produces_refl_spec: forall self: t_Range. produces self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate inv'5 (_1: t_Range)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Range [inv'5 x]. inv'5 x = true
  
  predicate inv'6 (_1: Seq.seq UInt64.t)
  
  axiom inv_axiom'5 [@rewrite]: forall x: Seq.seq UInt64.t [inv'6 x]. inv'6 x = true
  
  type t_Option = C_None | C_Some UInt64.t
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Range) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_Range) =
    resolve self /\ deep_model self.current.t_Range__start >= deep_model self.current.t_Range__end
  
  let rec next (self_: MutBorrow.t t_Range) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Range) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: UInt64.t)) = any
    [ good (field_0: UInt64.t) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: UInt64.t [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Item) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  predicate invariant''3 [@inline:trivial] (self: t_Item) = inv'0 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'7 (_1: t_Item)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Item [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Item) (out: t_Item) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec index (self_: t_Vec'0) (ix: UInt64.t) (return (x: t_Item)) =
    {[@expl:index 'self_' type invariant] inv'4 self_}
    {[@expl:index requires] in_bounds ix (view'0 self_)}
    any [ return (result: t_Item) -> {inv'7 result} {has_value ix (view'0 self_) result} (! return {result}) ]
  
  type t_RangeInclusive
  
  predicate inv'8 (_1: t_RangeInclusive)
  
  function start_log (self: t_RangeInclusive) : UInt64.t
  
  function end_log (self: t_RangeInclusive) : UInt64.t
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  let rec new (start: UInt64.t) (end': UInt64.t) (return (x: t_RangeInclusive)) = any
    [ return (result: t_RangeInclusive) -> {inv'8 result}
      {start_log result = start}
      {end_log result = end'}
      {deep_model start <= deep_model end' -> not is_empty_log result}
      (! return {result}) ]
  
  let rec into_iter'0 (self_: t_RangeInclusive) (return (x: t_RangeInclusive)) =
    {[@expl:into_iter 'self_' type invariant] inv'8 self_}
    any [ return (result: t_RangeInclusive) -> {inv'8 result} {result = self_} (! return {result}) ]
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces'0 (self: t_RangeInclusive) (visited: Seq.seq UInt64.t) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  function produces_trans'0 (a: t_RangeInclusive) (ab: Seq.seq UInt64.t) (b: t_RangeInclusive) (bc: Seq.seq UInt64.t) (c: t_RangeInclusive) : ()
   = ()
  
  axiom produces_trans_spec'0:
    forall a: t_RangeInclusive, ab: Seq.seq UInt64.t, b: t_RangeInclusive, bc: Seq.seq UInt64.t, c: t_RangeInclusive. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_RangeInclusive) : () = ()
  
  axiom produces_refl_spec'0: forall self: t_RangeInclusive. produces'0 self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_RangeInclusive) = inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_1: MutBorrow.t t_RangeInclusive)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_RangeInclusive [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate completed'0 (self: MutBorrow.t t_RangeInclusive) = is_empty_log self.current /\ is_empty_log self.final
  
  let rec next'0 (self_: MutBorrow.t t_RangeInclusive) (return (x: t_Option)) =
    {[@expl:next 'self_' type invariant] inv'9 self_}
    any
    [ return (result: t_Option) -> {match result with
        | C_None -> completed'0 self_
        | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_RangeInclusive) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_RangeInclusive) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate in_bounds'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds'0
  
  predicate has_value'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec) (out: t_Vec) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value'0
  
  let rec index'0 (self_: t_Vec'1) (ix: UInt64.t) (return (x: t_Vec)) =
    {[@expl:index requires] in_bounds'0 ix (view'1 self_)}
    any [ return (result: t_Vec) -> {has_value'0 ix (view'1 self_) result} (! return {result}) ]
  
  predicate in_bounds'1 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds'1
  
  predicate has_value'1 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value'1
  
  let rec index'1 (self_: t_Vec) (ix: UInt64.t) (return (x: UInt64.t)) =
    {[@expl:index requires] in_bounds'1 ix (view self_)}
    any [ return (result: UInt64.t) -> {has_value'1 ix (view self_) result} (! return {result}) ]
  
  let rec max (a: UInt64.t) (b: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {UInt64.t'int result = MinMax.max (UInt64.t'int a) (UInt64.t'int b)}
      (! return {result}) ]
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_Vec) (fin: Seq.seq t_Vec) =
    forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere
  
  let rec index_mut (self_: MutBorrow.t t_Vec'1) (ix: UInt64.t) (return (x: MutBorrow.t t_Vec)) =
    {[@expl:index_mut requires] in_bounds'0 ix (view'1 self_.current)}
    any
    [ return (result: MutBorrow.t t_Vec) -> {has_value'0 ix (view'1 self_.current) result.current}
      {has_value'0 ix (view'1 self_.final) result.final}
      {resolve_elswhere ix (view'1 self_.current) (view'1 self_.final)}
      {Seq.length (view'1 self_.final) = Seq.length (view'1 self_.current)}
      (! return {result}) ]
  
  predicate resolve_elswhere'0 [@inline:trivial] (self: UInt64.t) (old': Seq.seq UInt64.t) (fin: Seq.seq UInt64.t) =
    forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere'0
  
  let rec index_mut'0 (self_: MutBorrow.t t_Vec) (ix: UInt64.t) (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] in_bounds'1 ix (view self_.current)}
    any
    [ return (result: MutBorrow.t UInt64.t) -> {has_value'1 ix (view self_.current) result.current}
      {has_value'1 ix (view self_.final) result.final}
      {resolve_elswhere'0 ix (view self_.current) (view self_.final)}
      {Seq.length (view self_.final) = Seq.length (view self_.current)}
      (! return {result}) ]
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t UInt64.t) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t UInt64.t) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_Vec) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_1: MutBorrow.t t_Vec) = resolve'5 _1
  
  meta "rewrite_def" predicate resolve'6
  
  type t_Vec'2
  
  predicate invariant''5 (self: t_Item) = inv'7 self
  
  predicate inv'10 (_1: t_Item)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Item [inv'10 x]. inv'10 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'10 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'11 (_1: Seq.seq t_Item)
  
  axiom inv_axiom'9 [@rewrite]: forall x: Seq.seq t_Item [inv'11 x]. inv'11 x = invariant''6 x
  
  function view'2 (self: t_Vec'2) : Seq.seq t_Item
  
  axiom view_spec'2: forall self: t_Vec'2. Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  predicate invariant''7 (self: t_Vec'2) = inv'11 (view'2 self)
  
  predicate inv'12 (_1: t_Vec'2)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Vec'2 [inv'12 x]. inv'12 x = invariant''7 x
  
  let rec with_capacity (capacity: UInt64.t) (return (x: t_Vec'2)) = any
    [ return (result: t_Vec'2) -> {inv'12 result} {Seq.length (view'2 result) = 0} (! return {result}) ]
  
  function index_logic'1 [@inline:trivial] (self: t_Vec'2) (ix: int) : t_Item = Seq.get (view'2 self) ix
  
  meta "rewrite_def" function index_logic'1
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_Vec'2) = inv'12 self.current /\ inv'12 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'13 (_1: MutBorrow.t t_Vec'2)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Vec'2 [inv'13 x]. inv'13 x = invariant''8 x
  
  let rec push (self_: MutBorrow.t t_Vec'2) (v: t_Item) (return (x: ())) =
    {[@expl:push 'self_' type invariant] inv'13 self_}
    {[@expl:push 'v' type invariant] inv'7 v}
    any [ return (result: ()) -> {view'2 self_.final = Seq.snoc (view'2 self_.current) v} (! return {result}) ]
  
  function index_logic'2 [@inline:trivial] (self: t_Vec'0) (ix: int) : t_Item = Seq.get (view'0 self) ix
  
  meta "rewrite_def" function index_logic'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec knapsack01_dyn (items: t_Vec'0) (max_weight: UInt64.t) (return (x: t_Vec'2)) =
    {[@expl:knapsack01_dyn 'items' type invariant] inv'4 items}
    {[@expl:knapsack01_dyn requires #0] Seq.length (view'0 items) < 10000000}
    {[@expl:knapsack01_dyn requires #1] UInt64.t'int max_weight < 10000000}
    {[@expl:knapsack01_dyn requires #2] forall i: int. 0 <= i /\ i < Seq.length (view'0 items)
      -> UInt64.t'int (index_logic'2 items i).t_Item__value <= 10000000}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.add {max_weight} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_11 <- _ret ] s1)
      | s1 = from_elem {(0: UInt64.t)} {_11} (fun (_ret: t_Vec) -> [ &_10 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = len {items} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.add {_14} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_13 <- _ret ] s1)
      | s1 = from_elem'0 {_10} {_13} (fun (_ret: t_Vec'1) -> [ &best_value <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = len {items} (fun (_ret: UInt64.t) -> [ &_19 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_18 <- { t_Range__start = (0: UInt64.t); t_Range__end = _19 } ] s1
      | s1 = into_iter {_18} (fun (_ret: t_Range) -> [ &iter <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq UInt64.t ] s1 | s1 = bb8 ]
    | bb8 = bb8
      [ bb8 = {[@expl:for invariant] inv'6 produced}
        {[@expl:for invariant] inv'5 iter}
        {[@expl:for invariant] produces iter_old produced iter}
        {[@expl:loop invariant #0] Seq.length (view'0 items) + 1 = Seq.length (view'1 best_value)}
        {[@expl:loop invariant #1] forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'1 best_value)
          -> UInt64.t'int max_weight + 1 = Seq.length (view (index_logic'0 best_value i'0))}
        {[@expl:loop invariant #2] forall ii: int, ww: int. 0 <= ii
            /\ ii <= Seq.length produced /\ 0 <= ww /\ ww <= UInt64.t'int max_weight
          -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) = m (view'0 items) ii ww}
        {[@expl:loop invariant #3] forall ii: int, ww: int. 0 <= ii
            /\ ii <= Seq.length (view'0 items) /\ 0 <= ww /\ ww <= UInt64.t'int max_weight
          -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) <= 10000000 * ii}
        (! s0)
        [ s0 = bb9 ]
        [ bb9 = s0
          [ s0 = MutBorrow.borrow_mut <t_Range> {iter}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_36 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Range> {_36.current} {MutBorrow.get_id _36}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_35 <- _ret ] [ &_36 <- { _36 with current = _ret.final } ] s2)
          | s2 = next {_35} (fun (_ret: t_Option) -> [ &_34 <- _ret ] s3)
          | s3 = bb10 ]
        | bb10 = s0
          [ s0 = -{resolve'0 _36}- s1
          | s1 = any [ br0 -> {_34 = C_None} (! bb13) | br1 (x0: UInt64.t) -> {_34 = C_Some x0} (! bb14) ] ]
        | bb14 = s0
          [ s0 = v_Some {_34} (fun (r0: UInt64.t) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_39 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb15 ]
        | bb15 = s0
          [ s0 = [ &produced <- _39 ] s1
          | s1 = [ &i <- __creusot_proc_iter_elem ] s2
          | s2 = index {items} {i} (fun (_ret: t_Item) -> [ &_43 <- _ret ] s3)
          | s3 = bb16 ]
        | bb16 = s0
          [ s0 = [ &it <- _43 ] s1
          | s1 = new {(0: UInt64.t)} {max_weight} (fun (_ret: t_RangeInclusive) -> [ &_47 <- _ret ] s2)
          | s2 = bb17 ]
        | bb17 = s0 [ s0 = into_iter'0 {_47} (fun (_ret: t_RangeInclusive) -> [ &iter'0 <- _ret ] s1) | s1 = bb18 ]
        | bb18 = s0 [ s0 = [ &iter_old'0 <- iter'0 ] s1 | s1 = bb19 ]
        | bb19 = s0 [ s0 = [ &produced'0 <- Seq.empty: Seq.seq UInt64.t ] s1 | s1 = bb21 ]
        | bb21 = bb21
          [ bb21 = {[@expl:for invariant] inv'6 produced'0}
            {[@expl:for invariant] inv'8 iter'0}
            {[@expl:for invariant] produces'0 iter_old'0 produced'0 iter'0}
            {[@expl:loop invariant #0] Seq.length (view'0 items) + 1 = Seq.length (view'1 best_value)}
            {[@expl:loop invariant #1] forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'1 best_value)
              -> UInt64.t'int max_weight + 1 = Seq.length (view (index_logic'0 best_value i'0))}
            {[@expl:loop invariant #2] forall ii: int, ww: int. 0 <= ii
                /\ ii <= UInt64.t'int i /\ 0 <= ww /\ ww <= UInt64.t'int max_weight
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) = m (view'0 items) ii ww}
            {[@expl:loop invariant #3] forall ww: int. 0 <= ww /\ ww <= Seq.length produced'0 - 1
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value (UInt64.t'int i + 1))) ww)
              = m (view'0 items) (UInt64.t'int i + 1) ww}
            {[@expl:loop invariant #4] forall ii: int, ww: int. 0 <= ii
                /\ ii <= Seq.length (view'0 items) /\ 0 <= ww /\ ww <= UInt64.t'int max_weight
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) <= 10000000 * ii}
            (! s0)
            [ s0 = bb22 ]
            [ bb22 = s0
              [ s0 = {inv'8 iter'0}
                MutBorrow.borrow_mut <t_RangeInclusive> {iter'0}
                  (fun (_ret: MutBorrow.t t_RangeInclusive) ->
                    [ &_64 <- _ret ] -{inv'8 _ret.final}-
                    [ &iter'0 <- _ret.final ] s1)
              | s1 = {inv'8 _64.current}
                MutBorrow.borrow_final <t_RangeInclusive> {_64.current} {MutBorrow.get_id _64}
                  (fun (_ret: MutBorrow.t t_RangeInclusive) ->
                    [ &_63 <- _ret ] -{inv'8 _ret.final}-
                    [ &_64 <- { _64 with current = _ret.final } ] s2)
              | s2 = next'0 {_63} (fun (_ret: t_Option) -> [ &_62 <- _ret ] s3)
              | s3 = bb23 ]
            | bb23 = s0
              [ s0 = {[@expl:type invariant] inv'9 _64} s1
              | s1 = -{resolve'2 _64}- s2
              | s2 = any [ br0 -> {_62 = C_None} (! bb8) | br1 (x0: UInt64.t) -> {_62 = C_Some x0} (! bb27) ] ]
            | bb27 = s0
              [ s0 = v_Some {_62} (fun (r0: UInt64.t) -> [ &__creusot_proc_iter_elem'0 <- r0 ] s1)
              | s1 = [ &_67 <- Seq.(++) produced'0 (Seq.singleton __creusot_proc_iter_elem'0) ] s2
              | s2 = bb28 ]
            | bb28 = s0
              [ s0 = [ &produced'0 <- _67 ] s1
              | s1 = [ &w <- __creusot_proc_iter_elem'0 ] s2
              | s2 = [ &_71 <- UInt64.gt it.t_Item__weight w ] s3
              | s3 = any [ br0 -> {_71 = false} (! bb32) | br1 -> {_71} (! bb29) ] ]
            | bb29 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_76 <- _ret ] s1) | s1 = bb30 ]
            | bb30 = s0 [ s0 = index'1 {_76} {w} (fun (_ret: UInt64.t) -> [ &_74 <- _ret ] s1) | s1 = bb31 ]
            | bb31 = s0 [ s0 = [ &_70 <- _74 ] s1 | s1 = bb38 ]
            | bb32 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_83 <- _ret ] s1) | s1 = bb33 ]
            | bb33 = s0 [ s0 = index'1 {_83} {w} (fun (_ret: UInt64.t) -> [ &_81 <- _ret ] s1) | s1 = bb34 ]
            | bb34 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_91 <- _ret ] s1) | s1 = bb35 ]
            | bb35 = s0
              [ s0 = UInt64.sub {w} {it.t_Item__weight} (fun (_ret: UInt64.t) -> [ &_94 <- _ret ] s1)
              | s1 = index'1 {_91} {_94} (fun (_ret: UInt64.t) -> [ &_89 <- _ret ] s2)
              | s2 = bb36 ]
            | bb36 = s0
              [ s0 = UInt64.add {_89} {it.t_Item__value} (fun (_ret: UInt64.t) -> [ &_87 <- _ret ] s1)
              | s1 = max {_81} {_87} (fun (_ret: UInt64.t) -> [ &_70 <- _ret ] s2)
              | s2 = bb38 ]
            | bb38 = s0
              [ s0 = MutBorrow.borrow_mut <t_Vec'1> {best_value}
                  (fun (_ret: MutBorrow.t t_Vec'1) -> [ &_101 <- _ret ] [ &best_value <- _ret.final ] s1)
              | s1 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_102 <- _ret ] s2)
              | s2 = index_mut {_101} {_102} (fun (_ret: MutBorrow.t t_Vec) -> [ &_100 <- _ret ] s3)
              | s3 = bb39 ]
            | bb39 = s0
              [ s0 = MutBorrow.borrow_final <t_Vec> {_100.current} {MutBorrow.get_id _100}
                  (fun (_ret: MutBorrow.t t_Vec) -> [ &_99 <- _ret ] [ &_100 <- { _100 with current = _ret.final } ] s1)
              | s1 = index_mut'0 {_99} {w} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_98 <- _ret ] s2)
              | s2 = bb40 ]
            | bb40 = s0
              [ s0 = [ &_98 <- { _98 with current = _70 } ] s1
              | s1 = -{resolve'4 _98}- s2
              | s2 = -{resolve'6 _100}- s3
              | s3 = bb21 ] ] ] ] ]
    | bb13 = s0 [ s0 = len {items} (fun (_ret: UInt64.t) -> [ &_108 <- _ret ] s1) | s1 = bb41 ]
    | bb41 = s0 [ s0 = with_capacity {_108} (fun (_ret: t_Vec'2) -> [ &result <- _ret ] s1) | s1 = bb42 ]
    | bb42 = s0
      [ s0 = [ &left_weight <- max_weight ] s1
      | s1 = len {items} (fun (_ret: UInt64.t) -> [ &j <- _ret ] s2)
      | s2 = bb44 ]
    | bb44 = bb44
      [ bb44 = {[@expl:loop invariant #0] inv'12 result}
        {[@expl:loop invariant #1] UInt64.t'int j <= Seq.length (view'0 items)}
        {[@expl:loop invariant #2] UInt64.t'int left_weight <= UInt64.t'int max_weight}
        {[@expl:loop invariant #3] forall r: Seq.seq t_Item. Seq.length (view'2 result) <= Seq.length r
            /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'2 result)
                -> index_logic'1 result i'0 = Seq.get r i'0)
            /\ sum_values r (Seq.length (view'2 result)) = m (view'0 items) (UInt64.t'int j) (UInt64.t'int left_weight)
          -> sum_values r 0 = m (view'0 items) (Seq.length (view'0 items)) (UInt64.t'int max_weight)}
        {[@expl:loop invariant #4] forall r: Seq.seq t_Item. Seq.length (view'2 result) <= Seq.length r
            /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'2 result)
                -> index_logic'1 result i'0 = Seq.get r i'0)
            /\ sum_weights r (Seq.length (view'2 result)) <= UInt64.t'int left_weight
          -> sum_weights r 0 <= UInt64.t'int max_weight}
        {[@expl:loop invariant #5] forall r: Seq.seq t_Item. Seq.length (view'2 result) <= Seq.length r
            /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'2 result)
                -> index_logic'1 result i'0 = Seq.get r i'0)
            /\ subseq_rev r (Seq.length (view'2 result)) (view'0 items) (UInt64.t'int j)
          -> subseq_rev r 0 (view'0 items) (Seq.length (view'0 items))}
        (! s0)
        [ s0 = bb45 ]
        [ bb45 = s0
          [ s0 = [ &_121 <- UInt64.lt (0: UInt64.t) j ] s1
          | s1 = any [ br0 -> {_121 = false} (! bb56) | br1 -> {_121} (! bb46) ] ]
        | bb46 = s0
          [ s0 = UInt64.sub {j} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &j <- _ret ] s1)
          | s1 = index {items} {j} (fun (_ret: t_Item) -> [ &_124 <- _ret ] s2)
          | s2 = bb47 ]
        | bb47 = s0
          [ s0 = [ &it'0 <- _124 ] s1
          | s1 = UInt64.add {j} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_133 <- _ret ] s2)
          | s2 = index'0 {best_value} {_133} (fun (_ret: t_Vec) -> [ &_131 <- _ret ] s3)
          | s3 = bb48 ]
        | bb48 = s0 [ s0 = index'1 {_131} {left_weight} (fun (_ret: UInt64.t) -> [ &_129 <- _ret ] s1) | s1 = bb49 ]
        | bb49 = s0 [ s0 = index'0 {best_value} {j} (fun (_ret: t_Vec) -> [ &_139 <- _ret ] s1) | s1 = bb50 ]
        | bb50 = s0 [ s0 = index'1 {_139} {left_weight} (fun (_ret: UInt64.t) -> [ &_137 <- _ret ] s1) | s1 = bb51 ]
        | bb51 = s0
          [ s0 = [ &_127 <- _129 <> _137 ] s1 | s1 = any [ br0 -> {_127 = false} (! bb44) | br1 -> {_127} (! bb52) ] ]
        | bb52 = s0
          [ s0 = {inv'12 result}
            MutBorrow.borrow_mut <t_Vec'2> {result}
              (fun (_ret: MutBorrow.t t_Vec'2) -> [ &_144 <- _ret ] -{inv'12 _ret.final}- [ &result <- _ret.final ] s1)
          | s1 = push {_144} {it'0} (fun (_ret: ()) -> [ &_143 <- _ret ] s2)
          | s2 = bb53 ]
        | bb53 = s0
          [ s0 = UInt64.sub {left_weight} {it'0.t_Item__weight} (fun (_ret: UInt64.t) -> [ &left_weight <- _ret ] s1)
          | s1 = bb44 ] ] ]
    | bb56 = s0 [ s0 = [ &_0 <- result ] s1 | s1 = bb58 ]
    | bb58 = return {_0} ]
    [ & _0: t_Vec'2 = Any.any_l ()
    | & items: t_Vec'0 = items
    | & max_weight: UInt64.t = max_weight
    | & best_value: t_Vec'1 = Any.any_l ()
    | & _10: t_Vec = Any.any_l ()
    | & _11: UInt64.t = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & iter: t_Range = Any.any_l ()
    | & _18: t_Range = Any.any_l ()
    | & _19: UInt64.t = Any.any_l ()
    | & iter_old: t_Range = Any.any_l ()
    | & produced: Seq.seq UInt64.t = Any.any_l ()
    | & _34: t_Option = Any.any_l ()
    | & _35: MutBorrow.t t_Range = Any.any_l ()
    | & _36: MutBorrow.t t_Range = Any.any_l ()
    | & __creusot_proc_iter_elem: UInt64.t = Any.any_l ()
    | & _39: Seq.seq UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & it: t_Item = Any.any_l ()
    | & _43: t_Item = Any.any_l ()
    | & iter'0: t_RangeInclusive = Any.any_l ()
    | & _47: t_RangeInclusive = Any.any_l ()
    | & iter_old'0: t_RangeInclusive = Any.any_l ()
    | & produced'0: Seq.seq UInt64.t = Any.any_l ()
    | & _62: t_Option = Any.any_l ()
    | & _63: MutBorrow.t t_RangeInclusive = Any.any_l ()
    | & _64: MutBorrow.t t_RangeInclusive = Any.any_l ()
    | & __creusot_proc_iter_elem'0: UInt64.t = Any.any_l ()
    | & _67: Seq.seq UInt64.t = Any.any_l ()
    | & w: UInt64.t = Any.any_l ()
    | & _70: UInt64.t = Any.any_l ()
    | & _71: bool = Any.any_l ()
    | & _74: UInt64.t = Any.any_l ()
    | & _76: t_Vec = Any.any_l ()
    | & _81: UInt64.t = Any.any_l ()
    | & _83: t_Vec = Any.any_l ()
    | & _87: UInt64.t = Any.any_l ()
    | & _89: UInt64.t = Any.any_l ()
    | & _91: t_Vec = Any.any_l ()
    | & _94: UInt64.t = Any.any_l ()
    | & _98: MutBorrow.t UInt64.t = Any.any_l ()
    | & _99: MutBorrow.t t_Vec = Any.any_l ()
    | & _100: MutBorrow.t t_Vec = Any.any_l ()
    | & _101: MutBorrow.t t_Vec'1 = Any.any_l ()
    | & _102: UInt64.t = Any.any_l ()
    | & result: t_Vec'2 = Any.any_l ()
    | & _108: UInt64.t = Any.any_l ()
    | & left_weight: UInt64.t = Any.any_l ()
    | & j: UInt64.t = Any.any_l ()
    | & _121: bool = Any.any_l ()
    | & it'0: t_Item = Any.any_l ()
    | & _124: t_Item = Any.any_l ()
    | & _127: bool = Any.any_l ()
    | & _129: UInt64.t = Any.any_l ()
    | & _131: t_Vec = Any.any_l ()
    | & _133: UInt64.t = Any.any_l ()
    | & _137: UInt64.t = Any.any_l ()
    | & _139: t_Vec = Any.any_l ()
    | & _143: () = Any.any_l ()
    | & _144: MutBorrow.t t_Vec'2 = Any.any_l () ])
    [ return (result: t_Vec'2) -> {[@expl:knapsack01_dyn result type invariant] inv'12 result}
      {[@expl:knapsack01_dyn ensures #0] sum_weights (view'2 result) (Seq.length (view'2 result))
      <= UInt64.t'int max_weight}
      {[@expl:knapsack01_dyn ensures #1] subseq_rev (view'2 result) 0 (view'0 items) (Seq.length (view'0 items))}
      {[@expl:knapsack01_dyn ensures #2] forall s: Seq.seq t_Item. subseq_rev s 0 (view'0 items) (Seq.length (view'0 items))
          /\ sum_weights s (Seq.length s) <= UInt64.t'int max_weight
        -> sum_values s (Seq.length s) <= sum_values (view'2 result) (Seq.length (view'2 result))}
      (! return {result}) ]
end
