module M_knapsack_full__max [#"knapsack_full.rs" 11 0 11 35]
  let%span sknapsack_full = "knapsack_full.rs" 10 10 10 31
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.MinMax
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec max [#"knapsack_full.rs" 11 0 11 35] (a: UInt64.t) (b: UInt64.t) (return' (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- UInt64.lt a'0 b'0 ] s1 | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- b'0 ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_0 <- a'0 ] s1 | s1 = bb3 ]
    | bb3 = return''0 {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & a'0: UInt64.t = a | & b'0: UInt64.t = b | & _4: bool = Any.any_l () ])
    [ return''0 (result: UInt64.t) -> {[@expl:max ensures] [%#sknapsack_full] UInt64.t'int result
      = MinMax.max (UInt64.t'int a) (UInt64.t'int b)}
      (! return' {result}) ]
end
module M_knapsack_full__sum_weights [#"knapsack_full.rs" 19 0 19 60]
  let%span sknapsack_full = "knapsack_full.rs" 16 10 16 19
  let%span sknapsack_full'0 = "knapsack_full.rs" 17 11 17 33
  let%span sknapsack_full'1 = "knapsack_full.rs" 18 10 18 21
  let%span sknapsack_full'2 = "knapsack_full.rs" 21 8 22 51
  let%span swell_founded = "../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Seq.seq t_Item
  
  constant i : int
  
  function sum_weights [#"knapsack_full.rs" 19 0 19 60] (s'0: Seq.seq t_Item) (i'0: int) : int
  
  goal vc_sum_weights: ([%#sknapsack_full'0] 0 <= i /\ i <= Seq.length s)
    -> (if i = Seq.length s then
      [@expl:sum_weights ensures] [%#sknapsack_full'1] 0 >= 0
    else
      (([@expl:sum_weights requires] [%#sknapsack_full'0] 0 <= i + 1 /\ i + 1 <= Seq.length s)
        /\ well_founded_relation ([%#sknapsack_full] Seq.length s - i) ([%#sknapsack_full] Seq.length s - (i + 1)))
      /\ (([%#sknapsack_full'1] sum_weights s (i + 1) >= 0)
      -> ([@expl:sum_weights ensures] [%#sknapsack_full'1] UInt64.t'int (Seq.get s i).t_Item__weight
        + sum_weights s (i + 1)
      >= 0))
    )
end
module M_knapsack_full__sum_values [#"knapsack_full.rs" 29 0 29 59]
  let%span sknapsack_full = "knapsack_full.rs" 27 10 27 19
  let%span sknapsack_full'0 = "knapsack_full.rs" 28 11 28 33
  let%span sknapsack_full'1 = "knapsack_full.rs" 31 8 32 49
  let%span swell_founded = "../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Seq.seq t_Item
  
  constant i : int
  
  function sum_values [#"knapsack_full.rs" 29 0 29 59] (s'0: Seq.seq t_Item) (i'0: int) : int
  
  goal vc_sum_values: ([%#sknapsack_full'0] i >= 0 /\ i <= Seq.length s)
    -> (if i = Seq.length s then
      true
    else
      ([@expl:sum_values requires] [%#sknapsack_full'0] i + 1 >= 0 /\ i + 1 <= Seq.length s)
      /\ well_founded_relation ([%#sknapsack_full] Seq.length s - i) ([%#sknapsack_full] Seq.length s - (i + 1))
    )
end
module M_knapsack_full__subseq_rev [#"knapsack_full.rs" 40 0 40 71]
  let%span sknapsack_full = "knapsack_full.rs" 37 10 37 12
  let%span sknapsack_full'0 = "knapsack_full.rs" 38 11 38 36
  let%span sknapsack_full'1 = "knapsack_full.rs" 39 11 39 36
  let%span sknapsack_full'2 = "knapsack_full.rs" 42 8 46 9
  let%span swell_founded = "../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s1 : Seq.seq t_T
  
  constant i1 : int
  
  constant s2 : Seq.seq t_T
  
  constant i2 : int
  
  predicate subseq_rev [#"knapsack_full.rs" 40 0 40 71] (s1'0: Seq.seq t_T) (i1'0: int) (s2'0: Seq.seq t_T) (i2'0: int)
  
  goal vc_subseq_rev: ([%#sknapsack_full'0] 0 <= i1 /\ i1 <= Seq.length s1)
    -> ([%#sknapsack_full'1] 0 <= i2 /\ i2 <= Seq.length s2)
    -> (if i2 = 0 then
      true
    else
      if i1 < Seq.length s1 then
        if Seq.get s1 i1 = Seq.get s2 (i2 - 1) then
          ((([@expl:subseq_rev requires #0] [%#sknapsack_full'0] 0 <= i1 + 1 /\ i1 + 1 <= Seq.length s1)
              && ([@expl:subseq_rev requires #1] [%#sknapsack_full'1] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
            /\ well_founded_relation ([%#sknapsack_full] i2) ([%#sknapsack_full] i2 - 1))
          /\ (if subseq_rev s1 (i1 + 1) s2 (i2 - 1) then
            true
          else
            (([@expl:subseq_rev requires #0] [%#sknapsack_full'0] 0 <= i1 /\ i1 <= Seq.length s1)
              && ([@expl:subseq_rev requires #1] [%#sknapsack_full'1] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
            /\ well_founded_relation ([%#sknapsack_full] i2) ([%#sknapsack_full] i2 - 1)
          )
        else
          (([@expl:subseq_rev requires #0] [%#sknapsack_full'0] 0 <= i1 /\ i1 <= Seq.length s1)
            && ([@expl:subseq_rev requires #1] [%#sknapsack_full'1] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
          /\ well_founded_relation ([%#sknapsack_full] i2) ([%#sknapsack_full] i2 - 1)
      
      else
        (([@expl:subseq_rev requires #0] [%#sknapsack_full'0] 0 <= i1 /\ i1 <= Seq.length s1)
          && ([@expl:subseq_rev requires #1] [%#sknapsack_full'1] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
        /\ well_founded_relation ([%#sknapsack_full] i2) ([%#sknapsack_full] i2 - 1)
    
    )
end
module M_knapsack_full__m [#"knapsack_full.rs" 58 0 58 57]
  let%span sknapsack_full = "knapsack_full.rs" 51 10 51 11
  let%span sknapsack_full'0 = "knapsack_full.rs" 52 11 52 37
  let%span sknapsack_full'1 = "knapsack_full.rs" 53 11 53 17
  let%span sknapsack_full'2 = "knapsack_full.rs" 54 10 54 21
  let%span sknapsack_full'3 = "knapsack_full.rs" 55 10 56 30
  let%span sknapsack_full'4 = "knapsack_full.rs" 60 8 65 9
  let%span sknapsack_full'5 = "knapsack_full.rs" 37 10 37 12
  let%span sknapsack_full'6 = "knapsack_full.rs" 38 11 38 36
  let%span sknapsack_full'7 = "knapsack_full.rs" 39 11 39 36
  let%span sknapsack_full'8 = "knapsack_full.rs" 42 8 46 9
  let%span sknapsack_full'9 = "knapsack_full.rs" 16 10 16 19
  let%span sknapsack_full'10 = "knapsack_full.rs" 17 11 17 33
  let%span sknapsack_full'11 = "knapsack_full.rs" 18 10 18 21
  let%span sknapsack_full'12 = "knapsack_full.rs" 21 8 22 51
  let%span sknapsack_full'13 = "knapsack_full.rs" 27 10 27 19
  let%span sknapsack_full'14 = "knapsack_full.rs" 28 11 28 33
  let%span sknapsack_full'15 = "knapsack_full.rs" 31 8 32 49
  let%span swell_founded = "../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate subseq_rev [#"knapsack_full.rs" 40 0 40 71] (s1: Seq.seq t_Item) (i1: int) (s2: Seq.seq t_Item) (i2: int)
  
  axiom subseq_rev_def: forall s1: Seq.seq t_Item, i1: int, s2: Seq.seq t_Item, i2: int. ([%#sknapsack_full'6] 0 <= i1
        /\ i1 <= Seq.length s1)
      -> ([%#sknapsack_full'7] 0 <= i2 /\ i2 <= Seq.length s2)
      -> subseq_rev s1 i1 s2 i2
      = ([%#sknapsack_full'8] if i2 = 0 then
        i1 = Seq.length s1
      else
        i1 < Seq.length s1 /\ Seq.get s1 i1 = Seq.get s2 (i2 - 1) /\ subseq_rev s1 (i1 + 1) s2 (i2 - 1)
        \/ subseq_rev s1 i1 s2 (i2 - 1)
      )
  
  function sum_weights [#"knapsack_full.rs" 19 0 19 60] (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_weights_def: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'10] 0 <= i /\ i <= Seq.length s)
      -> sum_weights s i
      = ([%#sknapsack_full'12] if i = Seq.length s then
        0
      else
        UInt64.t'int (Seq.get s i).t_Item__weight + sum_weights s (i + 1)
      )
  
  axiom sum_weights_spec: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'10] 0 <= i /\ i <= Seq.length s)
      -> ([%#sknapsack_full'11] sum_weights s i >= 0)
  
  function sum_values [#"knapsack_full.rs" 29 0 29 59] (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_values_def: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'14] i >= 0 /\ i <= Seq.length s)
      -> sum_values s i
      = ([%#sknapsack_full'15] if i = Seq.length s then
        0
      else
        UInt64.t'int (Seq.get s i).t_Item__value + sum_values s (i + 1)
      )
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant items : Seq.seq t_Item
  
  constant i : int
  
  constant w : int
  
  function m [#"knapsack_full.rs" 58 0 58 57] (items'0: Seq.seq t_Item) (i'0: int) (w'0: int) : int
  
  goal vc_m: ([%#sknapsack_full'0] 0 <= i /\ i <= Seq.length items)
    -> ([%#sknapsack_full'1] 0 <= w)
    -> (if i = 0 then
      let result = 0 in ([@expl:m ensures #0] [%#sknapsack_full'2] result >= 0)
      && ([@expl:m ensures #1] [%#sknapsack_full'3] forall s: Seq.seq t_Item, j: int. 0 <= j
          /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w -> sum_values s j <= result)
    else
      if UInt64.t'int (Seq.get items (i - 1)).t_Item__weight > w then
        ((([@expl:m requires #0] [%#sknapsack_full'0] 0 <= i - 1 /\ i - 1 <= Seq.length items)
            && ([@expl:m requires #1] [%#sknapsack_full'1] 0 <= w))
          /\ well_founded_relation ([%#sknapsack_full] i) ([%#sknapsack_full] i - 1))
        /\ (([%#sknapsack_full'2] m items (i - 1) w >= 0)
          && ([%#sknapsack_full'3] forall s: Seq.seq t_Item, j: int. 0 <= j
              /\ j <= Seq.length s /\ subseq_rev s j items (i - 1) /\ sum_weights s j <= w
            -> sum_values s j <= m items (i - 1) w)
        -> (let result = m items (i - 1) w in ([@expl:m ensures #0] [%#sknapsack_full'2] result >= 0)
        && ([@expl:m ensures #1] [%#sknapsack_full'3] forall s: Seq.seq t_Item, j: int. 0 <= j
            /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w -> sum_values s j <= result)))
      else
        ((([@expl:m requires #0] [%#sknapsack_full'0] 0 <= i - 1 /\ i - 1 <= Seq.length items)
            && ([@expl:m requires #1] [%#sknapsack_full'1] 0 <= w))
          /\ well_founded_relation ([%#sknapsack_full] i) ([%#sknapsack_full] i - 1))
        /\ (([%#sknapsack_full'2] m items (i - 1) w >= 0)
          && ([%#sknapsack_full'3] forall s: Seq.seq t_Item, j: int. 0 <= j
              /\ j <= Seq.length s /\ subseq_rev s j items (i - 1) /\ sum_weights s j <= w
            -> sum_values s j <= m items (i - 1) w)
        -> ((([@expl:m requires #0] [%#sknapsack_full'0] 0 <= i - 1 /\ i - 1 <= Seq.length items)
            && ([@expl:m requires #1] [%#sknapsack_full'1] 0
            <= w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight))
          /\ well_founded_relation ([%#sknapsack_full] i) ([%#sknapsack_full] i - 1))
        /\ (([%#sknapsack_full'2] m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight) >= 0)
          && ([%#sknapsack_full'3] forall s: Seq.seq t_Item, j: int. 0 <= j
              /\ j <= Seq.length s
              /\ subseq_rev s j items (i - 1)
              /\ sum_weights s j <= w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight
            -> sum_values s j <= m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight))
        -> (let result = MinMax.max (m items (i - 1) w) (m items (i - 1) (w
          - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight)
        + UInt64.t'int (Seq.get items (i - 1)).t_Item__value) in ([@expl:m ensures #0] [%#sknapsack_full'2] result >= 0)
        && ([@expl:m ensures #1] [%#sknapsack_full'3] forall s: Seq.seq t_Item, j: int. 0 <= j
            /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w -> sum_values s j <= result))))
    
    )
end
module M_knapsack_full__knapsack01_dyn [#"knapsack_full.rs" 77 0 77 91]
  let%span sknapsack_full = "knapsack_full.rs" 78 51 78 52
  let%span sknapsack_full'0 = "knapsack_full.rs" 78 35 78 36
  let%span sknapsack_full'1 = "knapsack_full.rs" 78 69 78 70
  let%span sknapsack_full'2 = "knapsack_full.rs" 87 13 87 14
  let%span sknapsack_full'3 = "knapsack_full.rs" 87 4 87 7
  let%span sknapsack_full'4 = "knapsack_full.rs" 85 16 86 57
  let%span sknapsack_full'5 = "knapsack_full.rs" 83 16 84 61
  let%span sknapsack_full'6 = "knapsack_full.rs" 81 16 82 59
  let%span sknapsack_full'7 = "knapsack_full.rs" 80 16 80 53
  let%span sknapsack_full'8 = "knapsack_full.rs" 87 4 87 7
  let%span sknapsack_full'9 = "knapsack_full.rs" 102 17 102 18
  let%span sknapsack_full'10 = "knapsack_full.rs" 102 8 102 11
  let%span sknapsack_full'11 = "knapsack_full.rs" 98 20 99 57
  let%span sknapsack_full'12 = "knapsack_full.rs" 96 20 97 69
  let%span sknapsack_full'13 = "knapsack_full.rs" 93 20 95 65
  let%span sknapsack_full'14 = "knapsack_full.rs" 91 20 92 63
  let%span sknapsack_full'15 = "knapsack_full.rs" 90 20 90 57
  let%span sknapsack_full'16 = "knapsack_full.rs" 102 8 102 11
  let%span sknapsack_full'17 = "knapsack_full.rs" 103 27 103 28
  let%span sknapsack_full'18 = "knapsack_full.rs" 128 16 132 58
  let%span sknapsack_full'19 = "knapsack_full.rs" 123 16 127 52
  let%span sknapsack_full'20 = "knapsack_full.rs" 118 16 122 76
  let%span sknapsack_full'21 = "knapsack_full.rs" 117 16 117 43
  let%span sknapsack_full'22 = "knapsack_full.rs" 116 16 116 34
  let%span sknapsack_full'23 = "knapsack_full.rs" 115 16 115 27
  let%span sknapsack_full'24 = "knapsack_full.rs" 133 10 133 11
  let%span sknapsack_full'25 = "knapsack_full.rs" 134 13 134 14
  let%span sknapsack_full'26 = "knapsack_full.rs" 136 26 136 27
  let%span sknapsack_full'27 = "knapsack_full.rs" 77 28 77 33
  let%span sknapsack_full'28 = "knapsack_full.rs" 69 11 69 34
  let%span sknapsack_full'29 = "knapsack_full.rs" 70 11 70 33
  let%span sknapsack_full'30 = "knapsack_full.rs" 71 11 71 79
  let%span sknapsack_full'31 = "knapsack_full.rs" 77 75 77 91
  let%span sknapsack_full'32 = "knapsack_full.rs" 72 10 72 60
  let%span sknapsack_full'33 = "knapsack_full.rs" 73 10 73 54
  let%span sknapsack_full'34 = "knapsack_full.rs" 74 10 75 64
  let%span sknapsack_full'35 = "knapsack_full.rs" 51 10 51 11
  let%span sknapsack_full'36 = "knapsack_full.rs" 52 11 52 37
  let%span sknapsack_full'37 = "knapsack_full.rs" 53 11 53 17
  let%span sknapsack_full'38 = "knapsack_full.rs" 54 10 54 21
  let%span sknapsack_full'39 = "knapsack_full.rs" 55 10 56 30
  let%span sknapsack_full'40 = "knapsack_full.rs" 60 8 65 9
  let%span sknapsack_full'41 = "knapsack_full.rs" 10 10 10 31
  let%span sknapsack_full'42 = "knapsack_full.rs" 37 10 37 12
  let%span sknapsack_full'43 = "knapsack_full.rs" 38 11 38 36
  let%span sknapsack_full'44 = "knapsack_full.rs" 39 11 39 36
  let%span sknapsack_full'45 = "knapsack_full.rs" 42 8 46 9
  let%span sknapsack_full'46 = "knapsack_full.rs" 16 10 16 19
  let%span sknapsack_full'47 = "knapsack_full.rs" 17 11 17 33
  let%span sknapsack_full'48 = "knapsack_full.rs" 18 10 18 21
  let%span sknapsack_full'49 = "knapsack_full.rs" 21 8 22 51
  let%span sknapsack_full'50 = "knapsack_full.rs" 27 10 27 19
  let%span sknapsack_full'51 = "knapsack_full.rs" 28 11 28 33
  let%span sknapsack_full'52 = "knapsack_full.rs" 31 8 32 49
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 208 22 208 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 209 22 209 70
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 110 16 110 17
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 111 26 111 48
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'4 = "../../creusot-contracts/src/std/vec.rs" 48 8 48 31
  let%span svec'5 = "../../creusot-contracts/src/std/vec.rs" 189 16 189 17
  let%span svec'6 = "../../creusot-contracts/src/std/vec.rs" 190 16 190 48
  let%span svec'7 = "../../creusot-contracts/src/std/vec.rs" 191 16 191 56
  let%span svec'8 = "../../creusot-contracts/src/std/vec.rs" 180 16 180 48
  let%span svec'9 = "../../creusot-contracts/src/std/vec.rs" 181 16 181 56
  let%span svec'10 = "../../creusot-contracts/src/std/vec.rs" 182 16 182 59
  let%span svec'11 = "../../creusot-contracts/src/std/vec.rs" 183 16 183 64
  let%span svec'12 = "../../creusot-contracts/src/std/vec.rs" 184 26 184 55
  let%span svec'13 = "../../creusot-contracts/src/std/vec.rs" 106 26 106 44
  let%span svec'14 = "../../creusot-contracts/src/std/vec.rs" 114 16 114 17
  let%span svec'15 = "../../creusot-contracts/src/std/vec.rs" 116 35 116 36
  let%span svec'16 = "../../creusot-contracts/src/std/vec.rs" 115 26 115 56
  let%span svec'17 = "../../creusot-contracts/src/std/vec.rs" 93 20 93 41
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 215 18 215 32
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 93 26 96 17
  let%span smodel = "../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 87 12 91 76
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 32 4 32 49
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 36 4 36 34
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 37 4 37 34
  let%span srange'4 = "../../creusot-contracts/src/std/iter/range.rs" 38 4 38 44
  let%span srange'5 = "../../creusot-contracts/src/std/iter/range.rs" 15 8 17 9
  let%span srange'6 = "../../creusot-contracts/src/std/iter/range.rs" 96 4 96 49
  let%span srange'7 = "../../creusot-contracts/src/std/iter/range.rs" 97 27 97 29
  let%span srange'8 = "../../creusot-contracts/src/std/iter/range.rs" 100 4 100 34
  let%span srange'9 = "../../creusot-contracts/src/std/iter/range.rs" 101 4 101 34
  let%span srange'10 = "../../creusot-contracts/src/std/iter/range.rs" 102 4 102 44
  let%span srange'11 = "../../creusot-contracts/src/std/iter/range.rs" 103 91 103 93
  let%span srange'12 = "../../creusot-contracts/src/std/iter/range.rs" 67 10 67 43
  let%span srange'13 = "../../creusot-contracts/src/std/iter/range.rs" 70 8 71 74
  let%span srange'14 = "../../creusot-contracts/src/std/iter/range.rs" 79 8 81 9
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 250 26 250 53
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 251 26 251 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 252 26 252 91
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span snum = "../../creusot-contracts/src/std/num.rs" 23 28 23 33
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 124 20 124 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 129 20 129 37
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 134 20 134 88
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 712 20 712 91
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec'3] Seq.length (view self) <= UInt64.t'int const_MAX
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : UInt64.t = [%#svec'4] Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  let rec from_elem (elem: UInt64.t) (n: UInt64.t) (return' (x: t_Vec)) = any
    [ return''0 (result: t_Vec) -> {[%#svec] Seq.length (view result) = UInt64.t'int n}
      {[%#svec'0] forall i: int. 0 <= i /\ i < UInt64.t'int n -> index_logic result i = elem}
      (! return' {result}) ]
  
  type t_RawVec'0 = { t_RawVec__inner'0: t_RawVecInner; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0 = { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_Name
  
  type t_Item = { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate inv (_0: t_Name)
  
  predicate inv'0 (_0: t_Item)
  
  axiom inv_axiom [@rewrite]: forall x: t_Item [inv'0 x]. inv'0 x
      = match x with
        | {t_Item__name = name; t_Item__weight = weight; t_Item__value = value} -> inv name
        end
  
  predicate invariant' (self: t_Item) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_Item)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Item [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_Item) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_0: Seq.seq t_Item)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_Item [inv'2 x]. inv'2 x = invariant''0 x
  
  function view'0 (self: t_Vec'0) : Seq.seq t_Item
  
  axiom view_spec'0: forall self: t_Vec'0. [%#svec'3] Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec'0) = [%#svec'17] inv'2 (view'0 self)
  
  predicate inv'3 (_0: t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec'0 [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_Vec'0) = [%#sinvariant] inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: t_Vec'0)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Vec'0 [inv'4 x]. inv'4 x = invariant''2 x
  
  function view'1 [@inline:trivial] (self: t_Vec'0) : Seq.seq t_Item = [%#smodel] view'0 self
  
  meta "rewrite_def" function view'1
  
  let rec len (self_: t_Vec'0) (return' (x: UInt64.t)) = {[@expl:len 'self_' type invariant] [%#svec'1] inv'4 self_}
    any
    [ return''0 (result: UInt64.t) -> {[%#svec'2] UInt64.t'int result = Seq.length (view'1 self_)}
      (! return' {result}) ]
  
  type t_RawVec'1 = { t_RawVec__inner'1: t_RawVecInner; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1 = { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  function view'2 (self: t_Vec'1) : Seq.seq t_Vec
  
  axiom view_spec'1: forall self: t_Vec'1. [%#svec'3] Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  function index_logic'0 [@inline:trivial] (self: t_Vec'1) (ix: int) : t_Vec = [%#svec'4] Seq.get (view'2 self) ix
  
  meta "rewrite_def" function index_logic'0
  
  let rec from_elem'0 (elem: t_Vec) (n: UInt64.t) (return' (x: t_Vec'1)) = any
    [ return''0 (result: t_Vec'1) -> {[%#svec] Seq.length (view'2 result) = UInt64.t'int n}
      {[%#svec'0] forall i: int. 0 <= i /\ i < UInt64.t'int n -> index_logic'0 result i = elem}
      (! return' {result}) ]
  
  type t_Range = { t_Range__start: UInt64.t; t_Range__end: UInt64.t }
  
  let rec into_iter (self_: t_Range) (return' (x: t_Range)) = any
    [ return''0 (result: t_Range) -> {[%#siter] result = self_} (! return' {result}) ]
  
  predicate subseq_rev [#"knapsack_full.rs" 40 0 40 71] (s1: Seq.seq t_Item) (i1: int) (s2: Seq.seq t_Item) (i2: int)
  
  axiom subseq_rev_def: forall s1: Seq.seq t_Item, i1: int, s2: Seq.seq t_Item, i2: int. ([%#sknapsack_full'43] 0 <= i1
        /\ i1 <= Seq.length s1)
      -> ([%#sknapsack_full'44] 0 <= i2 /\ i2 <= Seq.length s2)
      -> subseq_rev s1 i1 s2 i2
      = ([%#sknapsack_full'45] if i2 = 0 then
        i1 = Seq.length s1
      else
        i1 < Seq.length s1 /\ Seq.get s1 i1 = Seq.get s2 (i2 - 1) /\ subseq_rev s1 (i1 + 1) s2 (i2 - 1)
        \/ subseq_rev s1 i1 s2 (i2 - 1)
      )
  
  function sum_weights [#"knapsack_full.rs" 19 0 19 60] (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_weights_def: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'47] 0 <= i /\ i <= Seq.length s)
      -> sum_weights s i
      = ([%#sknapsack_full'49] if i = Seq.length s then
        0
      else
        UInt64.t'int (Seq.get s i).t_Item__weight + sum_weights s (i + 1)
      )
  
  axiom sum_weights_spec: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'47] 0 <= i /\ i <= Seq.length s)
      -> ([%#sknapsack_full'48] sum_weights s i >= 0)
  
  function sum_values [#"knapsack_full.rs" 29 0 29 59] (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_values_def: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'51] i >= 0 /\ i <= Seq.length s)
      -> sum_values s i
      = ([%#sknapsack_full'52] if i = Seq.length s then
        0
      else
        UInt64.t'int (Seq.get s i).t_Item__value + sum_values s (i + 1)
      )
  
  function m [#"knapsack_full.rs" 58 0 58 57] (items: Seq.seq t_Item) (i: int) (w: int) : int
  
  axiom m_def: forall items: Seq.seq t_Item, i: int, w: int. ([%#sknapsack_full'36] 0 <= i /\ i <= Seq.length items)
      -> ([%#sknapsack_full'37] 0 <= w)
      -> m items i w
      = ([%#sknapsack_full'40] if i = 0 then
        0
      else
        if UInt64.t'int (Seq.get items (i - 1)).t_Item__weight > w then
          m items (i - 1) w
        else
          MinMax.max (m items (i - 1) w) (m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight)
          + UInt64.t'int (Seq.get items (i - 1)).t_Item__value)
      
      )
  
  axiom m_spec: forall items: Seq.seq t_Item, i: int, w: int. ([%#sknapsack_full'36] 0 <= i /\ i <= Seq.length items)
      -> ([%#sknapsack_full'37] 0 <= w) -> ([%#sknapsack_full'38] m items i w >= 0)
  
  axiom m_spec'0: forall items: Seq.seq t_Item, i: int, w: int. ([%#sknapsack_full'36] 0 <= i /\ i <= Seq.length items)
      -> ([%#sknapsack_full'37] 0 <= w)
      -> ([%#sknapsack_full'39] forall s: Seq.seq t_Item, j: int. 0 <= j
          /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w -> sum_values s j <= m items i w)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = [%#snum] UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  predicate produces (self: t_Range) (visited: Seq.seq UInt64.t) (o: t_Range) =
    [%#srange] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  function produces_trans (a: t_Range) (ab: Seq.seq UInt64.t) (b: t_Range) (bc: Seq.seq UInt64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec:
    forall a: t_Range, ab: Seq.seq UInt64.t, b: t_Range, bc: Seq.seq UInt64.t, c: t_Range. ([%#srange'2] produces a ab b)
      -> ([%#srange'3] produces b bc c) -> ([%#srange'4] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Range) : ()
  
  axiom produces_refl_spec: forall self: t_Range. [%#srange'1] produces self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate inv'5 (_0: t_Range)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Range [inv'5 x]. inv'5 x = true
  
  predicate inv'6 (_0: Seq.seq UInt64.t)
  
  axiom inv_axiom'5 [@rewrite]: forall x: Seq.seq UInt64.t [inv'6 x]. inv'6 x = true
  
  type t_Option = C_None | C_Some UInt64.t
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Range) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_Range) =
    [%#srange'5] resolve self /\ deep_model (self.current).t_Range__start >= deep_model (self.current).t_Range__end
  
  let rec next (self_: MutBorrow.t t_Range) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#siter'0] match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Range) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: UInt64.t)) = any
    [ good (field_0: UInt64.t) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: UInt64.t [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Item) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  predicate invariant''3 [@inline:trivial] (self: t_Item) = [%#sinvariant] inv'0 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'7 (_0: t_Item)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Item [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Item) (out: t_Item) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec index (self_: t_Vec'0) (ix: UInt64.t) (return' (x: t_Item)) =
    {[@expl:index 'self_' type invariant] [%#svec'5] inv'4 self_}
    {[@expl:index requires] [%#svec'6] in_bounds ix (view'1 self_)}
    any
    [ return''0 (result: t_Item) -> {inv'7 result}
      {[%#svec'7] has_value ix (view'1 self_) result}
      (! return' {result}) ]
  
  type t_RangeInclusive = {
    t_RangeInclusive__start: UInt64.t;
    t_RangeInclusive__end: UInt64.t;
    t_RangeInclusive__exhausted: bool }
  
  function start_log (self: t_RangeInclusive) : UInt64.t
  
  function end_log (self: t_RangeInclusive) : UInt64.t
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops'2] not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  let rec new (start: UInt64.t) (end': UInt64.t) (return' (x: t_RangeInclusive)) = any
    [ return''0 (result: t_RangeInclusive) -> {[%#sops] start_log result = start}
      {[%#sops'0] end_log result = end'}
      {[%#sops'1] deep_model start <= deep_model end' -> not is_empty_log result}
      (! return' {result}) ]
  
  let rec into_iter'0 (self_: t_RangeInclusive) (return' (x: t_RangeInclusive)) = any
    [ return''0 (result: t_RangeInclusive) -> {[%#siter] result = self_} (! return' {result}) ]
  
  function range_inclusive_len (r: t_RangeInclusive) : int = [%#srange'13] if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'12] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces'0 (self: t_RangeInclusive) (visited: Seq.seq UInt64.t) (o: t_RangeInclusive) =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  function produces_trans'0 (a: t_RangeInclusive) (ab: Seq.seq UInt64.t) (b: t_RangeInclusive) (bc: Seq.seq UInt64.t) (c: t_RangeInclusive) : ()
   = [%#srange'11] ()
  
  axiom produces_trans_spec'0:
    forall a: t_RangeInclusive, ab: Seq.seq UInt64.t, b: t_RangeInclusive, bc: Seq.seq UInt64.t, c: t_RangeInclusive. ([%#srange'8] produces'0 a ab b)
      -> ([%#srange'9] produces'0 b bc c) -> ([%#srange'10] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self: t_RangeInclusive) : () = [%#srange'7] ()
  
  axiom produces_refl_spec'0:
    forall self: t_RangeInclusive. [%#srange'6] produces'0 self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate inv'8 (_0: t_RangeInclusive)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_RangeInclusive [inv'8 x]. inv'8 x = true
  
  predicate completed'0 (self: MutBorrow.t t_RangeInclusive) =
    [%#srange'14] is_empty_log self.current /\ is_empty_log self.final
  
  let rec next'0 (self_: MutBorrow.t t_RangeInclusive) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#siter'0] match result with
        | C_None -> completed'0 self_
        | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_RangeInclusive) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_RangeInclusive) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate in_bounds'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds'0
  
  function view'3 [@inline:trivial] (self: t_Vec'1) : Seq.seq t_Vec = [%#smodel] view'2 self
  
  meta "rewrite_def" function view'3
  
  predicate has_value'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec) (out: t_Vec) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value'0
  
  let rec index'0 (self_: t_Vec'1) (ix: UInt64.t) (return' (x: t_Vec)) =
    {[@expl:index requires] [%#svec'6] in_bounds'0 ix (view'3 self_)}
    any [ return''0 (result: t_Vec) -> {[%#svec'7] has_value'0 ix (view'3 self_) result} (! return' {result}) ]
  
  predicate in_bounds'1 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds'1
  
  function view'4 [@inline:trivial] (self: t_Vec) : Seq.seq UInt64.t = [%#smodel] view self
  
  meta "rewrite_def" function view'4
  
  predicate has_value'1 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value'1
  
  let rec index'1 (self_: t_Vec) (ix: UInt64.t) (return' (x: UInt64.t)) =
    {[@expl:index requires] [%#svec'6] in_bounds'1 ix (view'4 self_)}
    any [ return''0 (result: UInt64.t) -> {[%#svec'7] has_value'1 ix (view'4 self_) result} (! return' {result}) ]
  
  let rec max (a: UInt64.t) (b: UInt64.t) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#sknapsack_full'41] UInt64.t'int result
      = MinMax.max (UInt64.t'int a) (UInt64.t'int b)}
      (! return' {result}) ]
  
  function view'5 [@inline:trivial] (self: MutBorrow.t t_Vec'1) : Seq.seq t_Vec = [%#smodel'0] view'2 self.current
  
  meta "rewrite_def" function view'5
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_Vec) (fin: Seq.seq t_Vec) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
      -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere
  
  let rec index_mut (self_: MutBorrow.t t_Vec'1) (ix: UInt64.t) (return' (x: MutBorrow.t t_Vec)) =
    {[@expl:index_mut requires] [%#svec'8] in_bounds'0 ix (view'5 self_)}
    any
    [ return''0 (result: MutBorrow.t t_Vec) -> {[%#svec'9] has_value'0 ix (view'5 self_) result.current}
      {[%#svec'10] has_value'0 ix (view'2 self_.final) result.final}
      {[%#svec'11] resolve_elswhere ix (view'5 self_) (view'2 self_.final)}
      {[%#svec'12] Seq.length (view'2 self_.final) = Seq.length (view'5 self_)}
      (! return' {result}) ]
  
  function view'6 [@inline:trivial] (self: MutBorrow.t t_Vec) : Seq.seq UInt64.t = [%#smodel'0] view self.current
  
  meta "rewrite_def" function view'6
  
  predicate resolve_elswhere'0 [@inline:trivial] (self: UInt64.t) (old': Seq.seq UInt64.t) (fin: Seq.seq UInt64.t) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
      -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere'0
  
  let rec index_mut'0 (self_: MutBorrow.t t_Vec) (ix: UInt64.t) (return' (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] [%#svec'8] in_bounds'1 ix (view'6 self_)}
    any
    [ return''0 (result: MutBorrow.t UInt64.t) -> {[%#svec'9] has_value'1 ix (view'6 self_) result.current}
      {[%#svec'10] has_value'1 ix (view self_.final) result.final}
      {[%#svec'11] resolve_elswhere'0 ix (view'6 self_) (view self_.final)}
      {[%#svec'12] Seq.length (view self_.final) = Seq.length (view'6 self_)}
      (! return' {result}) ]
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t UInt64.t) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_Vec) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_0: MutBorrow.t t_Vec) = resolve'5 _0
  
  meta "rewrite_def" predicate resolve'6
  
  type t_RawVec'2 = { t_RawVec__inner'2: t_RawVecInner; t_RawVec__qy95zmarker'2: () }
  
  type t_Vec'2 = { t_Vec__buf'2: t_RawVec'2; t_Vec__len'2: UInt64.t }
  
  predicate invariant''4 (self: t_Item) = [%#sboxed] inv'7 self
  
  predicate inv'9 (_0: t_Item)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Item [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: Seq.seq t_Item) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self -> inv'9 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'10 (_0: Seq.seq t_Item)
  
  axiom inv_axiom'9 [@rewrite]: forall x: Seq.seq t_Item [inv'10 x]. inv'10 x = invariant''5 x
  
  function view'7 (self: t_Vec'2) : Seq.seq t_Item
  
  axiom view_spec'2: forall self: t_Vec'2. [%#svec'3] Seq.length (view'7 self) <= UInt64.t'int const_MAX
  
  predicate invariant''6 (self: t_Vec'2) = [%#svec'17] inv'10 (view'7 self)
  
  predicate inv'11 (_0: t_Vec'2)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Vec'2 [inv'11 x]. inv'11 x = invariant''6 x
  
  let rec with_capacity (capacity: UInt64.t) (return' (x: t_Vec'2)) = any
    [ return''0 (result: t_Vec'2) -> {inv'11 result} {[%#svec'13] Seq.length (view'7 result) = 0} (! return' {result}) ]
  
  function index_logic'1 [@inline:trivial] (self: t_Vec'2) (ix: int) : t_Item = [%#svec'4] Seq.get (view'7 self) ix
  
  meta "rewrite_def" function index_logic'1
  
  predicate invariant''7 [@inline:trivial] (self: MutBorrow.t t_Vec'2) =
    [%#sinvariant'0] inv'11 self.current /\ inv'11 self.final
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'12 (_0: MutBorrow.t t_Vec'2)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Vec'2 [inv'12 x]. inv'12 x = invariant''7 x
  
  function view'8 [@inline:trivial] (self: MutBorrow.t t_Vec'2) : Seq.seq t_Item = [%#smodel'0] view'7 self.current
  
  meta "rewrite_def" function view'8
  
  let rec push (self_: MutBorrow.t t_Vec'2) (v: t_Item) (return' (x: ())) =
    {[@expl:push 'self_' type invariant] [%#svec'14] inv'12 self_}
    {[@expl:push 'v' type invariant] [%#svec'15] inv'7 v}
    any [ return''0 (result: ()) -> {[%#svec'16] view'7 self_.final = Seq.snoc (view'8 self_) v} (! return' {result}) ]
  
  function index_logic'2 [@inline:trivial] (self: t_Vec'0) (ix: int) : t_Item = [%#svec'4] Seq.get (view'0 self) ix
  
  meta "rewrite_def" function index_logic'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec knapsack01_dyn [#"knapsack_full.rs" 77 0 77 91] (items: t_Vec'0) (max_weight: UInt64.t)
    (return' (x: t_Vec'2)) = {[@expl:knapsack01_dyn 'items' type invariant] [%#sknapsack_full'27] inv'4 items}
    {[@expl:knapsack01_dyn requires #0] [%#sknapsack_full'28] Seq.length (view'1 items) < 10000000}
    {[@expl:knapsack01_dyn requires #1] [%#sknapsack_full'29] UInt64.t'int max_weight < 10000000}
    {[@expl:knapsack01_dyn requires #2] [%#sknapsack_full'30] forall i: int. 0 <= i /\ i < Seq.length (view'1 items)
      -> UInt64.t'int (index_logic'2 items i).t_Item__value <= 10000000}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.add {max_weight'0} {[%#sknapsack_full] (1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_11 <- _ret ] s1)
      | s1 = from_elem {[%#sknapsack_full'0] (0: UInt64.t)} {_11} (fun (_ret: t_Vec) -> [ &_10 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = len {items'0} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.add {_14} {[%#sknapsack_full'1] (1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_13 <- _ret ] s1)
      | s1 = from_elem'0 {_10} {_13} (fun (_ret: t_Vec'1) -> [ &best_value <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = len {items'0} (fun (_ret: UInt64.t) -> [ &_19 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_18 <- { t_Range__start = ([%#sknapsack_full'2] (0: UInt64.t)); t_Range__end = _19 } ] s1
      | s1 = into_iter {_18} (fun (_ret: t_Range) -> [ &iter <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &iter_old <- [%#sknapsack_full'3] iter ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &produced <- [%#sknapsack_full'3] Seq.empty: Seq.seq UInt64.t ] s1 | s1 = bb8 ]
    | bb8 = bb8'0
      [ bb8'0 = {[@expl:for invariant] [%#sknapsack_full'3] inv'6 produced}
        {[@expl:for invariant] [%#sknapsack_full'3] inv'5 iter}
        {[@expl:for invariant] [%#sknapsack_full'3] produces iter_old produced iter}
        {[@expl:loop invariant #0] [%#sknapsack_full'7] Seq.length (view'1 items'0) + 1
        = Seq.length (view'2 best_value)}
        {[@expl:loop invariant #1] [%#sknapsack_full'6] forall i'0: int. 0 <= i'0
            /\ i'0 < Seq.length (view'2 best_value)
          -> UInt64.t'int max_weight'0 + 1 = Seq.length (view (index_logic'0 best_value i'0))}
        {[@expl:loop invariant #2] [%#sknapsack_full'5] forall ii: int, ww: int. 0 <= ii
            /\ ii <= Seq.length produced /\ 0 <= ww /\ ww <= UInt64.t'int max_weight'0
          -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) = m (view'1 items'0) ii ww}
        {[@expl:loop invariant #3] [%#sknapsack_full'4] forall ii: int, ww: int. 0 <= ii
            /\ ii <= Seq.length (view'1 items'0) /\ 0 <= ww /\ ww <= UInt64.t'int max_weight'0
          -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) <= 10000000 * ii}
        (! s0)
        [ s0 = bb9 ]
        [ bb9 = s0
          [ s0 = MutBorrow.borrow_mut <t_Range> {iter}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_36 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Range> {_36.current} {MutBorrow.get_id _36}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_35 <- _ret ] [ &_36 <- { _36 with current = _ret.final } ] s2)
          | s2 = next {_35} (fun (_ret: t_Option) -> [ &_34 <- _ret ] s3)
          | s3 = bb10 ]
        | bb10 = s0
          [ s0 = -{resolve'0 _36}- s1
          | s1 = any [ br0 -> {_34 = C_None} (! bb13) | br1 (x0: UInt64.t) -> {_34 = C_Some x0} (! bb14) ] ]
        | bb14 = s0
          [ s0 = v_Some {_34} (fun (r0: UInt64.t) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_39 <- [%#sknapsack_full'8] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb15 ]
        | bb15 = s0
          [ s0 = [ &produced <- _39 ] s1
          | s1 = [ &i <- __creusot_proc_iter_elem ] s2
          | s2 = index {items'0} {i} (fun (_ret: t_Item) -> [ &_43 <- _ret ] s3)
          | s3 = bb16 ]
        | bb16 = s0
          [ s0 = [ &it <- _43 ] s1
          | s1 = new {[%#sknapsack_full'9] (0: UInt64.t)} {max_weight'0}
              (fun (_ret: t_RangeInclusive) -> [ &_47 <- _ret ] s2)
          | s2 = bb17 ]
        | bb17 = s0 [ s0 = into_iter'0 {_47} (fun (_ret: t_RangeInclusive) -> [ &iter'0 <- _ret ] s1) | s1 = bb18 ]
        | bb18 = s0 [ s0 = [ &iter_old'0 <- [%#sknapsack_full'10] iter'0 ] s1 | s1 = bb19 ]
        | bb19 = s0 [ s0 = [ &produced'0 <- [%#sknapsack_full'10] Seq.empty: Seq.seq UInt64.t ] s1 | s1 = bb21 ]
        | bb21 = bb21'0
          [ bb21'0 = {[@expl:for invariant] [%#sknapsack_full'10] inv'6 produced'0}
            {[@expl:for invariant] [%#sknapsack_full'10] inv'8 iter'0}
            {[@expl:for invariant] [%#sknapsack_full'10] produces'0 iter_old'0 produced'0 iter'0}
            {[@expl:loop invariant #0] [%#sknapsack_full'15] Seq.length (view'1 items'0) + 1
            = Seq.length (view'2 best_value)}
            {[@expl:loop invariant #1] [%#sknapsack_full'14] forall i'0: int. 0 <= i'0
                /\ i'0 < Seq.length (view'2 best_value)
              -> UInt64.t'int max_weight'0 + 1 = Seq.length (view (index_logic'0 best_value i'0))}
            {[@expl:loop invariant #2] [%#sknapsack_full'13] forall ii: int, ww: int. 0 <= ii
                /\ ii <= UInt64.t'int i /\ 0 <= ww /\ ww <= UInt64.t'int max_weight'0
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) = m (view'1 items'0) ii ww}
            {[@expl:loop invariant #3] [%#sknapsack_full'12] forall ww: int. 0 <= ww /\ ww <= Seq.length produced'0 - 1
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value (UInt64.t'int i + 1))) ww)
              = m (view'1 items'0) (UInt64.t'int i + 1) ww}
            {[@expl:loop invariant #4] [%#sknapsack_full'11] forall ii: int, ww: int. 0 <= ii
                /\ ii <= Seq.length (view'1 items'0) /\ 0 <= ww /\ ww <= UInt64.t'int max_weight'0
              -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) <= 10000000 * ii}
            (! s0)
            [ s0 = bb22 ]
            [ bb22 = s0
              [ s0 = MutBorrow.borrow_mut <t_RangeInclusive> {iter'0}
                  (fun (_ret: MutBorrow.t t_RangeInclusive) -> [ &_64 <- _ret ] [ &iter'0 <- _ret.final ] s1)
              | s1 = MutBorrow.borrow_final <t_RangeInclusive> {_64.current} {MutBorrow.get_id _64}
                  (fun (_ret: MutBorrow.t t_RangeInclusive) ->
                    [ &_63 <- _ret ] [ &_64 <- { _64 with current = _ret.final } ] s2)
              | s2 = next'0 {_63} (fun (_ret: t_Option) -> [ &_62 <- _ret ] s3)
              | s3 = bb23 ]
            | bb23 = s0
              [ s0 = -{resolve'2 _64}- s1
              | s1 = any [ br0 -> {_62 = C_None} (! bb8'0) | br1 (x0: UInt64.t) -> {_62 = C_Some x0} (! bb27) ] ]
            | bb27 = s0
              [ s0 = v_Some {_62} (fun (r0: UInt64.t) -> [ &__creusot_proc_iter_elem'0 <- r0 ] s1)
              | s1 = [ &_67 <- [%#sknapsack_full'16] Seq.(++) produced'0 (Seq.singleton __creusot_proc_iter_elem'0) ] s2
              | s2 = bb28 ]
            | bb28 = s0
              [ s0 = [ &produced'0 <- _67 ] s1
              | s1 = [ &w <- __creusot_proc_iter_elem'0 ] s2
              | s2 = [ &_71 <- UInt64.gt it.t_Item__weight w ] s3
              | s3 = any [ br0 -> {_71 = false} (! bb32) | br1 -> {_71} (! bb29) ] ]
            | bb29 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_76 <- _ret ] s1) | s1 = bb30 ]
            | bb30 = s0 [ s0 = index'1 {_76} {w} (fun (_ret: UInt64.t) -> [ &_74 <- _ret ] s1) | s1 = bb31 ]
            | bb31 = s0 [ s0 = [ &_70 <- _74 ] s1 | s1 = bb38 ]
            | bb32 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_83 <- _ret ] s1) | s1 = bb33 ]
            | bb33 = s0 [ s0 = index'1 {_83} {w} (fun (_ret: UInt64.t) -> [ &_81 <- _ret ] s1) | s1 = bb34 ]
            | bb34 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret: t_Vec) -> [ &_91 <- _ret ] s1) | s1 = bb35 ]
            | bb35 = s0
              [ s0 = UInt64.sub {w} {it.t_Item__weight} (fun (_ret: UInt64.t) -> [ &_94 <- _ret ] s1)
              | s1 = index'1 {_91} {_94} (fun (_ret: UInt64.t) -> [ &_89 <- _ret ] s2)
              | s2 = bb36 ]
            | bb36 = s0
              [ s0 = UInt64.add {_89} {it.t_Item__value} (fun (_ret: UInt64.t) -> [ &_87 <- _ret ] s1)
              | s1 = max {_81} {_87} (fun (_ret: UInt64.t) -> [ &_70 <- _ret ] s2)
              | s2 = bb38 ]
            | bb38 = s0
              [ s0 = MutBorrow.borrow_mut <t_Vec'1> {best_value}
                  (fun (_ret: MutBorrow.t t_Vec'1) -> [ &_101 <- _ret ] [ &best_value <- _ret.final ] s1)
              | s1 = UInt64.add {i} {[%#sknapsack_full'17] (1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_102 <- _ret ] s2)
              | s2 = index_mut {_101} {_102} (fun (_ret: MutBorrow.t t_Vec) -> [ &_100 <- _ret ] s3)
              | s3 = bb39 ]
            | bb39 = s0
              [ s0 = MutBorrow.borrow_final <t_Vec> {_100.current} {MutBorrow.get_id _100}
                  (fun (_ret: MutBorrow.t t_Vec) -> [ &_99 <- _ret ] [ &_100 <- { _100 with current = _ret.final } ] s1)
              | s1 = index_mut'0 {_99} {w} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_98 <- _ret ] s2)
              | s2 = bb40 ]
            | bb40 = s0
              [ s0 = [ &_98 <- { _98 with current = _70 } ] s1
              | s1 = -{resolve'4 _98}- s2
              | s2 = -{resolve'6 _100}- s3
              | s3 = bb21'0 ] ] ] ] ]
    | bb13 = s0 [ s0 = len {items'0} (fun (_ret: UInt64.t) -> [ &_108 <- _ret ] s1) | s1 = bb41 ]
    | bb41 = s0 [ s0 = with_capacity {_108} (fun (_ret: t_Vec'2) -> [ &result <- _ret ] s1) | s1 = bb42 ]
    | bb42 = s0
      [ s0 = [ &left_weight <- max_weight'0 ] s1
      | s1 = len {items'0} (fun (_ret: UInt64.t) -> [ &j <- _ret ] s2)
      | s2 = bb44 ]
    | bb44 = bb44'0
      [ bb44'0 = {[@expl:loop invariant #0] [%#sknapsack_full'23] inv'11 result}
        {[@expl:loop invariant #1] [%#sknapsack_full'22] UInt64.t'int j <= Seq.length (view'1 items'0)}
        {[@expl:loop invariant #2] [%#sknapsack_full'21] UInt64.t'int left_weight <= UInt64.t'int max_weight'0}
        {[@expl:loop invariant #3] [%#sknapsack_full'20] forall r: Seq.seq t_Item. Seq.length (view'7 result)
              <= Seq.length r
            /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'7 result)
                -> index_logic'1 result i'0 = Seq.get r i'0)
            /\ sum_values r (Seq.length (view'7 result))
            = m (view'1 items'0) (UInt64.t'int j) (UInt64.t'int left_weight)
          -> sum_values r 0 = m (view'1 items'0) (Seq.length (view'1 items'0)) (UInt64.t'int max_weight'0)}
        {[@expl:loop invariant #4] [%#sknapsack_full'19] forall r: Seq.seq t_Item. Seq.length (view'7 result)
              <= Seq.length r
            /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'7 result)
                -> index_logic'1 result i'0 = Seq.get r i'0)
            /\ sum_weights r (Seq.length (view'7 result)) <= UInt64.t'int left_weight
          -> sum_weights r 0 <= UInt64.t'int max_weight'0}
        {[@expl:loop invariant #5] [%#sknapsack_full'18] forall r: Seq.seq t_Item. Seq.length (view'7 result)
              <= Seq.length r
            /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'7 result)
                -> index_logic'1 result i'0 = Seq.get r i'0)
            /\ subseq_rev r (Seq.length (view'7 result)) (view'1 items'0) (UInt64.t'int j)
          -> subseq_rev r 0 (view'1 items'0) (Seq.length (view'1 items'0))}
        (! s0)
        [ s0 = bb45 ]
        [ bb45 = s0
          [ s0 = [ &_121 <- UInt64.lt ([%#sknapsack_full'24] (0: UInt64.t)) j ] s1
          | s1 = any [ br0 -> {_121 = false} (! bb56) | br1 -> {_121} (! bb46) ] ]
        | bb46 = s0
          [ s0 = UInt64.sub {j} {[%#sknapsack_full'25] (1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &j <- _ret ] s1)
          | s1 = index {items'0} {j} (fun (_ret: t_Item) -> [ &_124 <- _ret ] s2)
          | s2 = bb47 ]
        | bb47 = s0
          [ s0 = [ &it'0 <- _124 ] s1
          | s1 = UInt64.add {j} {[%#sknapsack_full'26] (1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_133 <- _ret ] s2)
          | s2 = index'0 {best_value} {_133} (fun (_ret: t_Vec) -> [ &_131 <- _ret ] s3)
          | s3 = bb48 ]
        | bb48 = s0 [ s0 = index'1 {_131} {left_weight} (fun (_ret: UInt64.t) -> [ &_129 <- _ret ] s1) | s1 = bb49 ]
        | bb49 = s0 [ s0 = index'0 {best_value} {j} (fun (_ret: t_Vec) -> [ &_139 <- _ret ] s1) | s1 = bb50 ]
        | bb50 = s0 [ s0 = index'1 {_139} {left_weight} (fun (_ret: UInt64.t) -> [ &_137 <- _ret ] s1) | s1 = bb51 ]
        | bb51 = s0
          [ s0 = [ &_127 <- _129 <> _137 ] s1 | s1 = any [ br0 -> {_127 = false} (! bb44'0) | br1 -> {_127} (! bb52) ] ]
        | bb52 = s0
          [ s0 = {inv'11 result}
            MutBorrow.borrow_mut <t_Vec'2> {result}
              (fun (_ret: MutBorrow.t t_Vec'2) -> [ &_144 <- _ret ] -{inv'11 _ret.final}- [ &result <- _ret.final ] s1)
          | s1 = push {_144} {it'0} (fun (_ret: ()) -> [ &_143 <- _ret ] s2)
          | s2 = bb53 ]
        | bb53 = s0
          [ s0 = UInt64.sub {left_weight} {it'0.t_Item__weight} (fun (_ret: UInt64.t) -> [ &left_weight <- _ret ] s1)
          | s1 = bb44'0 ] ] ]
    | bb56 = s0 [ s0 = [ &_0 <- result ] s1 | s1 = bb58 ]
    | bb58 = return''0 {_0} ]
    [ & _0: t_Vec'2 = Any.any_l ()
    | & items'0: t_Vec'0 = items
    | & max_weight'0: UInt64.t = max_weight
    | & best_value: t_Vec'1 = Any.any_l ()
    | & _10: t_Vec = Any.any_l ()
    | & _11: UInt64.t = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & iter: t_Range = Any.any_l ()
    | & _18: t_Range = Any.any_l ()
    | & _19: UInt64.t = Any.any_l ()
    | & iter_old: t_Range = Any.any_l ()
    | & produced: Seq.seq UInt64.t = Any.any_l ()
    | & _34: t_Option = Any.any_l ()
    | & _35: MutBorrow.t t_Range = Any.any_l ()
    | & _36: MutBorrow.t t_Range = Any.any_l ()
    | & __creusot_proc_iter_elem: UInt64.t = Any.any_l ()
    | & _39: Seq.seq UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & it: t_Item = Any.any_l ()
    | & _43: t_Item = Any.any_l ()
    | & iter'0: t_RangeInclusive = Any.any_l ()
    | & _47: t_RangeInclusive = Any.any_l ()
    | & iter_old'0: t_RangeInclusive = Any.any_l ()
    | & produced'0: Seq.seq UInt64.t = Any.any_l ()
    | & _62: t_Option = Any.any_l ()
    | & _63: MutBorrow.t t_RangeInclusive = Any.any_l ()
    | & _64: MutBorrow.t t_RangeInclusive = Any.any_l ()
    | & __creusot_proc_iter_elem'0: UInt64.t = Any.any_l ()
    | & _67: Seq.seq UInt64.t = Any.any_l ()
    | & w: UInt64.t = Any.any_l ()
    | & _70: UInt64.t = Any.any_l ()
    | & _71: bool = Any.any_l ()
    | & _74: UInt64.t = Any.any_l ()
    | & _76: t_Vec = Any.any_l ()
    | & _81: UInt64.t = Any.any_l ()
    | & _83: t_Vec = Any.any_l ()
    | & _87: UInt64.t = Any.any_l ()
    | & _89: UInt64.t = Any.any_l ()
    | & _91: t_Vec = Any.any_l ()
    | & _94: UInt64.t = Any.any_l ()
    | & _98: MutBorrow.t UInt64.t = Any.any_l ()
    | & _99: MutBorrow.t t_Vec = Any.any_l ()
    | & _100: MutBorrow.t t_Vec = Any.any_l ()
    | & _101: MutBorrow.t t_Vec'1 = Any.any_l ()
    | & _102: UInt64.t = Any.any_l ()
    | & result: t_Vec'2 = Any.any_l ()
    | & _108: UInt64.t = Any.any_l ()
    | & left_weight: UInt64.t = Any.any_l ()
    | & j: UInt64.t = Any.any_l ()
    | & _121: bool = Any.any_l ()
    | & it'0: t_Item = Any.any_l ()
    | & _124: t_Item = Any.any_l ()
    | & _127: bool = Any.any_l ()
    | & _129: UInt64.t = Any.any_l ()
    | & _131: t_Vec = Any.any_l ()
    | & _133: UInt64.t = Any.any_l ()
    | & _137: UInt64.t = Any.any_l ()
    | & _139: t_Vec = Any.any_l ()
    | & _143: () = Any.any_l ()
    | & _144: MutBorrow.t t_Vec'2 = Any.any_l () ])
    [ return''0 (result: t_Vec'2) -> {[@expl:knapsack01_dyn result type invariant] [%#sknapsack_full'31] inv'11 result}
      {[@expl:knapsack01_dyn ensures #0] [%#sknapsack_full'32] sum_weights (view'7 result) (Seq.length (view'7 result))
      <= UInt64.t'int max_weight}
      {[@expl:knapsack01_dyn ensures #1] [%#sknapsack_full'33] subseq_rev (view'7 result) 0 (view'1 items) (Seq.length (view'1 items))}
      {[@expl:knapsack01_dyn ensures #2] [%#sknapsack_full'34] forall s: Seq.seq t_Item. subseq_rev s 0 (view'1 items) (Seq.length (view'1 items))
          /\ sum_weights s (Seq.length s) <= UInt64.t'int max_weight
        -> sum_values s (Seq.length s) <= sum_values (view'7 result) (Seq.length (view'7 result))}
      (! return' {result}) ]
end
