module M_rc
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Rc_i32_Global
  
  predicate inv_Rc_i32_Global (_1: t_Rc_i32_Global)
  
  function view_Rc_i32_Global (self: t_Rc_i32_Global) : Int32.t
  
  let rec new_i32 (value: Int32.t) (return (x: t_Rc_i32_Global)) = any
    [ return (result: t_Rc_i32_Global) -> {inv_Rc_i32_Global result}
      {view_Rc_i32_Global result = value}
      (! return {result}) ]
  
  predicate resolve_Rc_i32_Global (_1: t_Rc_i32_Global)
  
  predicate invariant_ref_Rc_i32_Global [@inline:trivial] (self: t_Rc_i32_Global) = inv_Rc_i32_Global self
  
  meta "rewrite_def" predicate invariant_ref_Rc_i32_Global
  
  predicate inv_ref_Rc_i32_Global [@inline:trivial] (_1: t_Rc_i32_Global) = invariant_ref_Rc_i32_Global _1
  
  meta "rewrite_def" predicate inv_ref_Rc_i32_Global
  
  let rec as_ref_Rc_i32_Global (self_: t_Rc_i32_Global) (return (x: Int32.t)) =
    {[@expl:as_ref 'self_' type invariant] inv_ref_Rc_i32_Global self_}
    any [ return (result: Int32.t) -> {result = view_Rc_i32_Global self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rc (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new_i32 {(1: Int32.t)} (fun (_ret: t_Rc_i32_Global) -> [ &rc'0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] view_Rc_i32_Global rc'0 = (1: Int32.t)} s1
      | s1 = {[@expl:type invariant] inv_Rc_i32_Global rc'0} s2
      | s2 = -{resolve_Rc_i32_Global rc'0}- s3
      | s3 = as_ref_Rc_i32_Global {rc'0} (fun (_ret: Int32.t) -> [ &inner <- _ret ] s4)
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = {[@expl:assertion] Int32.to_int inner = 1} s1 | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: () = Any.any_l () | & rc'0: t_Rc_i32_Global = Any.any_l () | & inner: Int32.t = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_arc
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Arc_i32_Global
  
  predicate inv_Arc_i32_Global (_1: t_Arc_i32_Global)
  
  function view_Arc_i32_Global (self: t_Arc_i32_Global) : Int32.t
  
  let rec new_i32 (value: Int32.t) (return (x: t_Arc_i32_Global)) = any
    [ return (result: t_Arc_i32_Global) -> {inv_Arc_i32_Global result}
      {view_Arc_i32_Global result = value}
      (! return {result}) ]
  
  predicate resolve_Arc_i32_Global (_1: t_Arc_i32_Global)
  
  predicate invariant_ref_Arc_i32_Global [@inline:trivial] (self: t_Arc_i32_Global) = inv_Arc_i32_Global self
  
  meta "rewrite_def" predicate invariant_ref_Arc_i32_Global
  
  predicate inv_ref_Arc_i32_Global [@inline:trivial] (_1: t_Arc_i32_Global) = invariant_ref_Arc_i32_Global _1
  
  meta "rewrite_def" predicate inv_ref_Arc_i32_Global
  
  let rec as_ref_Arc_i32_Global (self_: t_Arc_i32_Global) (return (x: Int32.t)) =
    {[@expl:as_ref 'self_' type invariant] inv_ref_Arc_i32_Global self_}
    any [ return (result: Int32.t) -> {result = view_Arc_i32_Global self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec arc (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new_i32 {(2: Int32.t)} (fun (_ret: t_Arc_i32_Global) -> [ &arc'0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] view_Arc_i32_Global arc'0 = (2: Int32.t)} s1
      | s1 = {[@expl:type invariant] inv_Arc_i32_Global arc'0} s2
      | s2 = -{resolve_Arc_i32_Global arc'0}- s3
      | s3 = as_ref_Arc_i32_Global {arc'0} (fun (_ret: Int32.t) -> [ &inner <- _ret ] s4)
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = {[@expl:assertion] Int32.to_int inner = 2} s1 | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: () = Any.any_l () | & arc'0: t_Arc_i32_Global = Any.any_l () | & inner: Int32.t = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
