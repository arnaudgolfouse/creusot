module M_agreement
  use creusot.int.Int32
  use map.Map
  use creusot.prelude.Any
  
  type t_Resource_Ag_i32
  
  type t_Id
  
  function id_Ag_i32 (self: t_Resource_Ag_i32) : t_Id
  
  type t_Ag_i32 = { f0: Int32.t }
  
  type t_Option_Ag_i32 = None | Some t_Ag_i32
  
  function and_then_Option_Ag_i32 (self: t_Option_Ag_i32) (f: Map.map t_Ag_i32 t_Option_Ag_i32) : t_Option_Ag_i32 =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Ag_i32 (self: t_Ag_i32) (other: t_Ag_i32) : t_Option_Ag_i32 = if self.f0 = other.f0 then
      Some self
    else
      None
  
  
  function associative_Ag_i32 (a: t_Ag_i32) (b: t_Ag_i32) (c: t_Ag_i32) : ()
  
  axiom associative_Ag_i32_spec:
    forall a: t_Ag_i32, b: t_Ag_i32, c: t_Ag_i32. and_then_Option_Ag_i32 (op_Ag_i32 a b) (fun (ab: t_Ag_i32) -> op_Ag_i32 ab c)
      = and_then_Option_Ag_i32 (op_Ag_i32 b c) (fun (bc: t_Ag_i32) -> op_Ag_i32 a bc)
  
  function commutative_Ag_i32 (a: t_Ag_i32) (b: t_Ag_i32) : ()
  
  axiom commutative_Ag_i32_spec: forall a: t_Ag_i32, b: t_Ag_i32. op_Ag_i32 a b = op_Ag_i32 b a
  
  function factor_Ag_i32 (self: t_Ag_i32) (factor: t_Ag_i32) : t_Option_Ag_i32 = op_Ag_i32 self factor
  
  axiom factor_Ag_i32_spec: forall self: t_Ag_i32, factor: t_Ag_i32. match factor_Ag_i32 self factor with
        | Some c -> op_Ag_i32 factor c = Some self
        | None -> forall c: t_Ag_i32. op_Ag_i32 factor c <> Some self
        end
  
  predicate incl_Ag_i32 (self: t_Ag_i32) (other: t_Ag_i32) = factor_Ag_i32 other self <> None
  
  function incl_transitive_Ag_i32 (a: t_Ag_i32) (b: t_Ag_i32) (c: t_Ag_i32) : ()
  
  axiom incl_transitive_Ag_i32_spec: forall a: t_Ag_i32, b: t_Ag_i32, c: t_Ag_i32. incl_Ag_i32 a b
      -> incl_Ag_i32 b c -> incl_Ag_i32 a c
  
  function incl_op_Ag_i32 (self: t_Ag_i32) (other: t_Ag_i32) (comb: t_Ag_i32) : ()
  
  axiom incl_op_Ag_i32_spec: forall self: t_Ag_i32, other: t_Ag_i32, comb: t_Ag_i32. op_Ag_i32 self other = Some comb
      -> incl_Ag_i32 self comb
  
  predicate incl_eq_Ag_i32 (self: t_Ag_i32) (other: t_Ag_i32) = self = other \/ incl_Ag_i32 self other
  
  function val_Ag_i32 (self: t_Resource_Ag_i32) : t_Ag_i32
  
  function view_Resource_Ag_i32 [@inline:trivial] (self: t_Resource_Ag_i32) : t_Ag_i32 = val_Ag_i32 self
  
  meta "rewrite_def" function view_Resource_Ag_i32
  
  let rec join_shared_Ag_i32 (self: t_Resource_Ag_i32) (other: t_Resource_Ag_i32) (return (x: t_Resource_Ag_i32)) =
    {[@expl:join_shared requires] id_Ag_i32 self = id_Ag_i32 other}
    any
    [ return (result: t_Resource_Ag_i32) -> {id_Ag_i32 result = id_Ag_i32 self}
      {incl_eq_Ag_i32 (view_Resource_Ag_i32 self) (view_Resource_Ag_i32 result)
      /\ incl_eq_Ag_i32 (view_Resource_Ag_i32 other) (view_Resource_Ag_i32 result)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec agreement (x: t_Resource_Ag_i32) (y: t_Resource_Ag_i32) (return (x'0: ())) =
    {[@expl:agreement requires] id_Ag_i32 x = id_Ag_i32 y}
    (! bb0
    [ bb0 = s0 [ s0 = join_shared_Ag_i32 {x} {y} (fun (_ret: t_Resource_Ag_i32) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & x: t_Resource_Ag_i32 = x
    | & y: t_Resource_Ag_i32 = y
    | & _5: t_Resource_Ag_i32 = Any.any_l () ])
    [ return (result: ()) -> {[@expl:agreement ensures] view_Resource_Ag_i32 x = view_Resource_Ag_i32 y}
      (! return {result}) ]
end
