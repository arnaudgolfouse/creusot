module M_agree__agreement
  use creusot.int.Int32
  use map.Map
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  type t_Ag = { t_Ag__0: Int32.t }
  
  type t_Option = C_None | C_Some t_Ag
  
  function and_then_logic (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Ag. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Ag) (other: t_Ag) = factor other self <> C_None
  
  function incl_transitive (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom incl_transitive_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Ag) (other: t_Ag) (comb: t_Ag) : ()
  
  axiom incl_op_spec: forall self: t_Ag, other: t_Ag, comb: t_Ag. op self other = C_Some comb -> incl self comb
  
  predicate incl_eq (self: t_Ag) (other: t_Ag) = self = other \/ incl self other
  
  function val' (self: t_Resource) : t_Ag
  
  function view [@inline:trivial] (self: t_Resource) : t_Ag = val' self
  
  meta "rewrite_def" function view
  
  function view'0 [@inline:trivial] (self: t_Resource) : t_Ag = view self
  
  meta "rewrite_def" function view'0
  
  let rec join_shared (self: t_Resource) (other: t_Resource) (return' (x: t_Resource)) =
    {[@expl:join_shared requires] id self = id other}
    any
    [ return''0 (result: t_Resource) -> {id result = id self}
      {incl_eq (view'0 self) (view'0 result) /\ incl_eq (view'0 other) (view'0 result)}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec agreement (x: t_Resource) (y: t_Resource) (return' (x'0: ())) = {[@expl:agreement requires] id x = id y}
    (! bb0
    [ bb0 = s0 [ s0 = join_shared {x'0} {y'0} (fun (_ret: t_Resource) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return''0 {_0} ]
    [ & _0: () = Any.any_l () | & x'0: t_Resource = x | & y'0: t_Resource = y | & _5: t_Resource = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:agreement ensures] view'0 x = view'0 y} (! return' {result}) ]
end
