module M_impl_ViewRel_for_MapRelation_K_V__rel_mono (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_FMap_K_Ag_V
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_Option_Ag_V = None'0 | Some'0 t_Ag_V
  
  type t_K
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  type t_Option_V = None'1 | Some'1 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some a'0 -> forall k: t_K. match get_K f k with
          | Some'0 {f0 = v} -> get_K'0 a'0 k = Some'1 v
          | _ -> true
          end
      | None -> true
      end
  
  type t_Option_FMap_K_Ag_V = None'2 | Some'2 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type t_Option_Option_Ag_V = None'3 | Some'3 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'3 -> None'3
      | Some'3 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'0: t_Option_Ag_V; f1'0: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'0 -> None'3
      | Some'0 x -> Some'3 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0 = other.f0 then Some'0 self else None'0
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'0 = self;
                                                                                                        f1'0 = other } with
      | {f0'0 = None'0} -> Some'3 other
      | {f1'0 = None'0} -> Some'3 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'0 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'3)
      -> (forall k: t_K. Some'3 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'3 then
      Some'2 (total_op_K self other)
    else
      None'2
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'0 c -> op_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'0 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'0 = self; f1'0 = factor } with
      | {f0'0 = x; f1'0 = None'0} -> Some'3 x
      | {f0'0 = None'0} -> None'3
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> match factor_Ag_V x y with
        | Some'0 z -> Some'3 (Some'0 z)
        | None'0 -> if x = y then Some'3 (None'0) else None'3
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'3 c -> op_Option_Ag_V factor c = Some'3 self
        | None'3 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'3 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'3
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'3 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'1: t_K; f1'1: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'1 = k; f1'1 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_Ag_V (Some'0 vo) (get_K factor k) with
        | Some'3 r -> r
        | None'3 -> None'0
        end) in Some'2 res
    else
      None'2
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'2 c -> op_FMap_K_Ag_V factor c = Some'2 self
        | None'2 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'2 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'2
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'2 comb
      -> incl_FMap_K_Ag_V self comb
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_FMap_K_V
  
  constant f1 : t_FMap_K_Ag_V
  
  constant f2 : t_FMap_K_Ag_V
  
  function rel_mono_MapRelation_K_V (a: t_Option_FMap_K_V) (f1: t_FMap_K_Ag_V) (f2: t_FMap_K_Ag_V) : ()
  
  goal vc_rel_mono_MapRelation_K_V: rel_MapRelation_K_V a f1
    -> incl_FMap_K_Ag_V f2 f1 -> ([@expl:rel_mono ensures] rel_MapRelation_K_V a f2)
end
module M_impl_ViewRel_for_MapRelation_K_V__rel_none (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_FMap_K_Ag_V
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_Option_Ag_V = None'0 | Some'0 t_Ag_V
  
  type t_K
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  type t_Option_V = None'1 | Some'1 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some a'0 -> forall k: t_K. match get_K f k with
          | Some'0 {f0 = v} -> get_K'0 a'0 k = Some'1 v
          | _ -> true
          end
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_FMap_K_V
  
  constant f : t_FMap_K_Ag_V
  
  function rel_none_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) : ()
  
  goal vc_rel_none_MapRelation_K_V: rel_MapRelation_K_V a f -> ([@expl:rel_none ensures] rel_MapRelation_K_V (None) f)
end
module M_impl_ViewRel_for_MapRelation_K_V__rel_unit (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_FMap_K_Ag_V
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_Option_Ag_V = None'0 | Some'0 t_Ag_V
  
  type t_K
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  type t_Option_V = None'1 | Some'1 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some a'0 -> forall k: t_K. match get_K f k with
          | Some'0 {f0 = v} -> get_K'0 a'0 k = Some'1 v
          | _ -> true
          end
      | None -> true
      end
  
  type t_Option_FMap_K_Ag_V = None'2 | Some'2 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type t_Option_Option_Ag_V = None'3 | Some'3 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'3 -> None'3
      | Some'3 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'0: t_Option_Ag_V; f1'0: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'0 -> None'3
      | Some'0 x -> Some'3 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0 = other.f0 then Some'0 self else None'0
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'0 = self;
                                                                                                        f1'0 = other } with
      | {f0'0 = None'0} -> Some'3 other
      | {f1'0 = None'0} -> Some'3 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'0 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'3)
      -> (forall k: t_K. Some'3 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'3 then
      Some'2 (total_op_K self other)
    else
      None'2
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'0)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'2 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_FMap_K_V
  
  function rel_unit_MapRelation_K_V (a: t_Option_FMap_K_V) : ()
  
  goal vc_rel_unit_MapRelation_K_V: [@expl:rel_unit ensures] rel_MapRelation_K_V a unit_FMap_K_Ag_V
end
module M_impl_Authority_K_V__new (* Authority<K, V> *)
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_View_MapRelation_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None'0 | Some'0 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_Option_Ag_V = None'1 | Some'1 t_Ag_V
  
  type t_Option_Option_Ag_V = None'2 | Some'2 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'0: t_Option_Ag_V; f1'0: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'1 -> None'2
      | Some'1 x -> Some'2 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0 = other.f0 then Some'1 self else None'1
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'0 = self;
                                                                                                        f1'0 = other } with
      | {f0'0 = None'1} -> Some'2 other
      | {f1'0 = None'1} -> Some'2 self
      | {f0'0 = Some'1 x; f1'0 = Some'1 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'1 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  type t_K
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'2 then
      Some'0 (total_op_K self other)
    else
      None'0
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'1)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'0 x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'1 c -> op_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'1 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'0 = self; f1'0 = factor } with
      | {f0'0 = x; f1'0 = None'1} -> Some'2 x
      | {f0'0 = None'1} -> None'2
      | {f0'0 = Some'1 x; f1'0 = Some'1 y} -> match factor_Ag_V x y with
        | Some'1 z -> Some'2 (Some'1 z)
        | None'1 -> if x = y then Some'2 (None'1) else None'2
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'2 c -> op_Option_Ag_V factor c = Some'2 self
        | None'2 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'2 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'2
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'2 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'1: t_K; f1'1: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'1 -> None'1
          | Some'1 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'1 = k; f1'1 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_Ag_V (Some'1 vo) (get_K factor k) with
        | Some'2 r -> r
        | None'2 -> None'1
        end) in Some'0 res
    else
      None'0
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'0 c -> op_FMap_K_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'0 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'0
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'0 comb
      -> incl_FMap_K_Ag_V self comb
  
  type t_Option_V = None'3 | Some'3 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some a'0 -> forall k: t_K. match get_K f k with
          | Some'1 {f0 = v} -> get_K'0 a'0 k = Some'3 v
          | _ -> true
          end
      | None -> true
      end
  
  function rel_unit_MapRelation_K_V (a: t_Option_FMap_K_V) : () = ()
  
  axiom rel_unit_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V. rel_MapRelation_K_V a unit_FMap_K_Ag_V
  
  function rel_none_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_none_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V, f: t_FMap_K_Ag_V. rel_MapRelation_K_V a f
      -> rel_MapRelation_K_V (None) f
  
  function rel_mono_MapRelation_K_V (a: t_Option_FMap_K_V) (f1: t_FMap_K_Ag_V) (f2: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_mono_MapRelation_K_V_spec:
    forall a: t_Option_FMap_K_V, f1: t_FMap_K_Ag_V, f2: t_FMap_K_Ag_V. rel_MapRelation_K_V a f1
      -> incl_FMap_K_Ag_V f2 f1 -> rel_MapRelation_K_V a f2
  
  function auth_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_Option_FMap_K_V
  
  function frag_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_FMap_K_Ag_V
  
  axiom frag_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V. rel_MapRelation_K_V (auth_MapRelation_K_V self) (frag_MapRelation_K_V self)
  
  function new_MapRelation_K_V (auth: t_Option_FMap_K_V) (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V
  
  axiom new_MapRelation_K_V_spec: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> auth_MapRelation_K_V (new_MapRelation_K_V auth frag) = auth
  
  axiom new_MapRelation_K_V_spec'0: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> frag_MapRelation_K_V (new_MapRelation_K_V auth frag) = frag
  
  function new_auth_MapRelation_K_V [@inline:trivial] (auth: t_FMap_K_V) : t_View_MapRelation_K_V =
    new_MapRelation_K_V (Some auth) unit_FMap_K_Ag_V
  
  meta "rewrite_def" function new_auth_MapRelation_K_V
  
  function len_K'0 (self: t_FMap_K_V) : int
  
  axiom len_K_spec'0: forall self: t_FMap_K_V. len_K'0 self >= 0
  
  constant empty_K'0 : t_FMap_K_V
  
  axiom empty_K_spec'1: len_K'0 empty_K'0 = 0
  
  axiom empty_K_spec'2: view_FMap_K_V empty_K'0 = Const.const (None'3)
  
  type t_Resource_View_MapRelation_K_V
  
  function val_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
  
  function view_Resource_View_MapRelation_K_V [@inline:trivial] (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
   = val_View_MapRelation_K_V self
  
  meta "rewrite_def" function view_Resource_View_MapRelation_K_V
  
  let rec alloc_View_MapRelation_K_V (r: t_View_MapRelation_K_V) (return (x: t_Resource_View_MapRelation_K_V)) = any
    [ return (result: t_Resource_View_MapRelation_K_V) -> {view_Resource_View_MapRelation_K_V result = r}
      (! return {result}) ]
  
  let rec into_inner_Resource_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V)
    (return (x: t_Resource_View_MapRelation_K_V)) = any
    [ return (result: t_Resource_View_MapRelation_K_V) -> {result = self} (! return {result}) ]
  
  type t_Authority_K_V = { f0'2: t_Resource_View_MapRelation_K_V }
  
  predicate invariant_Authority_K_V (self: t_Authority_K_V) =
    auth_MapRelation_K_V (view_Resource_View_MapRelation_K_V self.f0'2) <> None
  
  predicate inv_Authority_K_V (_1: t_Authority_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_K_V [inv_Authority_K_V x]. inv_Authority_K_V x
      = invariant_Authority_K_V x
  
  predicate invariant_Ghost_Authority_K_V [@inline:trivial] (self: t_Authority_K_V) = inv_Authority_K_V self
  
  meta "rewrite_def" predicate invariant_Ghost_Authority_K_V
  
  predicate inv_Ghost_Authority_K_V [@inline:trivial] (_1: t_Authority_K_V) = invariant_Ghost_Authority_K_V _1
  
  meta "rewrite_def" predicate inv_Ghost_Authority_K_V
  
  let rec new_Authority_K_V (x: t_Authority_K_V) (return (x'0: t_Authority_K_V)) =
    {[@expl:new 'x' type invariant] inv_Authority_K_V x}
    any [ return (result: t_Authority_K_V) -> {inv_Ghost_Authority_K_V result} {result = x} (! return {result}) ]
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  function view_Authority_K_V (self: t_Authority_K_V) : t_FMap_K_V =
    unwrap_Option_FMap_K_V (auth_MapRelation_K_V (view_Resource_View_MapRelation_K_V self.f0'2))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_K (return (x: t_Authority_K_V)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- new_auth_MapRelation_K_V empty_K'0 ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = alloc_View_MapRelation_K_V {_3} (fun (_ret: t_Resource_View_MapRelation_K_V) -> [ &resource <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0
      [ s0 = into_inner_Resource_View_MapRelation_K_V {resource}
          (fun (_ret: t_Resource_View_MapRelation_K_V) -> [ &_6 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_5 <- { f0'2 = _6 } ] s1
      | s1 = new_Authority_K_V {_5} (fun (_ret: t_Authority_K_V) -> [ &_0 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_Authority_K_V = Any.any_l ()
    | & resource: t_Resource_View_MapRelation_K_V = Any.any_l ()
    | & _3: t_View_MapRelation_K_V = Any.any_l ()
    | & _5: t_Authority_K_V = Any.any_l ()
    | & _6: t_Resource_View_MapRelation_K_V = Any.any_l () ])
    [ return (result: t_Authority_K_V) -> {[@expl:new result type invariant] inv_Ghost_Authority_K_V result}
      {[@expl:new ensures] view_Authority_K_V result = empty_K'0}
      (! return {result}) ]
end
module M_impl_Authority_K_V__insert (* Authority<K, V> *)
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  type t_Resource_View_MapRelation_K_V
  
  type t_Authority_K_V = { f0: t_Resource_View_MapRelation_K_V }
  
  type t_Option_FMap_K_V = None'0 | Some'0 t_FMap_K_V
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  type t_View_MapRelation_K_V
  
  function auth_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_Option_FMap_K_V
  
  function val_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
  
  function view_Resource_View_MapRelation_K_V [@inline:trivial] (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
   = val_View_MapRelation_K_V self
  
  meta "rewrite_def" function view_Resource_View_MapRelation_K_V
  
  function view_Authority_K_V (self: t_Authority_K_V) : t_FMap_K_V =
    unwrap_Option_FMap_K_V (auth_MapRelation_K_V (view_Resource_View_MapRelation_K_V self.f0))
  
  type t_Ag_V = { f0'0: t_V }
  
  type t_FMap_K_Ag_V
  
  type t_Option_Ag_V = None'1 | Some'1 t_Ag_V
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function len_K'0 (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec'0: forall self: t_FMap_K_Ag_V. len_K'0 self >= 0
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate contains_K'0 [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) = get_K'0 self k <> None'1
  
  meta "rewrite_def" predicate contains_K'0
  
  function insert_K'0 (self: t_FMap_K_Ag_V) (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V
  
  axiom insert_K_spec'1: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. view_FMap_K_Ag_V (insert_K'0 self k v)
      = Map.set (view_FMap_K_Ag_V self) k (Some'1 v)
  
  axiom insert_K_spec'2: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. len_K'0 (insert_K'0 self k v)
      = (if contains_K'0 self k then len_K'0 self else len_K'0 self + 1)
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K'0 empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'1)
  
  function singleton_K (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V = insert_K'0 empty_K k v
  
  type t_ViewUpdateInsert_MapRelation_K_V = { f0'1: t_FMap_K_V; f1'1: t_FMap_K_Ag_V }
  
  type t_Option_FMap_K_Ag_V = None'2 | Some'2 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type t_Option_Option_Ag_V = None'3 | Some'3 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'3 -> None'3
      | Some'3 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'2: t_Option_Ag_V; f1'2: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'1 -> None'3
      | Some'1 x -> Some'3 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0'0 = other.f0'0 then
      Some'1 self
    else
      None'1
  
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'2 = self;
                                                                                                        f1'2 = other } with
      | {f0'2 = None'1} -> Some'3 other
      | {f1'2 = None'1} -> Some'3 self
      | {f0'2 = Some'1 x; f1'2 = Some'1 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'1 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K'0 self k) (get_K'0 other k)
          <> None'3)
      -> (forall k: t_K. Some'3 (get_K'0 (total_op_K self other) k) = op_Option_Ag_V (get_K'0 self k) (get_K'0 other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K'0 self k) (get_K'0 other k) <> None'3 then
      Some'2 (total_op_K self other)
    else
      None'2
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'2 x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'1 c -> op_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'1 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'2 = self; f1'2 = factor } with
      | {f0'2 = x; f1'2 = None'1} -> Some'3 x
      | {f0'2 = None'1} -> None'3
      | {f0'2 = Some'1 x; f1'2 = Some'1 y} -> match factor_Ag_V x y with
        | Some'1 z -> Some'3 (Some'1 z)
        | None'1 -> if x = y then Some'3 (None'1) else None'3
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'3 c -> op_Option_Ag_V factor c = Some'3 self
        | None'3 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'3 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'3
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'3 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'3: t_K; f1'3: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K'0 (filter_map_K self f) k]. get_K'0 (filter_map_K self f) k
        = match get_K'0 self k with
          | None'1 -> None'1
          | Some'1 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'3 = k; f1'3 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K'0 factor k) (get_K'0 self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'3 = k; f1'3 = vo} = __0 in match factor_Option_Ag_V (Some'1 vo) (get_K'0 factor k) with
        | Some'3 r -> r
        | None'3 -> None'1
        end) in Some'2 res
    else
      None'2
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'2 c -> op_FMap_K_Ag_V factor c = Some'2 self
        | None'2 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'2 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'2
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'2 comb
      -> incl_FMap_K_Ag_V self comb
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some'0 a'0 -> forall k: t_K. match get_K'0 f k with
          | Some'1 {f0'0 = v} -> get_K a'0 k = Some v
          | _ -> true
          end
      | None'0 -> true
      end
  
  function rel_unit_MapRelation_K_V (a: t_Option_FMap_K_V) : () = ()
  
  axiom rel_unit_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V. rel_MapRelation_K_V a unit_FMap_K_Ag_V
  
  function rel_none_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_none_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V, f: t_FMap_K_Ag_V. rel_MapRelation_K_V a f
      -> rel_MapRelation_K_V (None'0) f
  
  function rel_mono_MapRelation_K_V (a: t_Option_FMap_K_V) (f1: t_FMap_K_Ag_V) (f2: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_mono_MapRelation_K_V_spec:
    forall a: t_Option_FMap_K_V, f1: t_FMap_K_Ag_V, f2: t_FMap_K_Ag_V. rel_MapRelation_K_V a f1
      -> incl_FMap_K_Ag_V f2 f1 -> rel_MapRelation_K_V a f2
  
  predicate premise_ViewUpdateInsert_MapRelation_K_V (self: t_ViewUpdateInsert_MapRelation_K_V) (from: t_View_MapRelation_K_V) =
    auth_MapRelation_K_V from <> None'0
    /\ (forall f: t_FMap_K_Ag_V. rel_MapRelation_K_V (auth_MapRelation_K_V from) f
      -> match op_FMap_K_Ag_V self.f1'1 f with
        | Some'2 ff -> rel_MapRelation_K_V (Some'0 (self.f0'1)) ff
        | None'2 -> false
        end)
  
  type t_Id
  
  function id_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V) : t_Id
  
  function frag_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_FMap_K_Ag_V
  
  axiom frag_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V. rel_MapRelation_K_V (auth_MapRelation_K_V self) (frag_MapRelation_K_V self)
  
  function new_MapRelation_K_V (auth: t_Option_FMap_K_V) (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V
  
  axiom new_MapRelation_K_V_spec: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> auth_MapRelation_K_V (new_MapRelation_K_V auth frag) = auth
  
  axiom new_MapRelation_K_V_spec'0: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> frag_MapRelation_K_V (new_MapRelation_K_V auth frag) = frag
  
  function update_ViewUpdateInsert_MapRelation_K_V (self: t_ViewUpdateInsert_MapRelation_K_V) (from: t_View_MapRelation_K_V) (_3: ()) : t_View_MapRelation_K_V
   = new_MapRelation_K_V (Some'0 (self.f0'1)) self.f1'1
  
  axiom update_ViewUpdateInsert_MapRelation_K_V_spec:
    forall self: t_ViewUpdateInsert_MapRelation_K_V, from: t_View_MapRelation_K_V, _3: (). premise_ViewUpdateInsert_MapRelation_K_V self from
      -> rel_MapRelation_K_V (Some'0 (self.f0'1)) self.f1'1
  
  let rec update_View_MapRelation_K_V (self: MutBorrow.t t_Resource_View_MapRelation_K_V)
    (upd: t_ViewUpdateInsert_MapRelation_K_V) (return (x: ())) =
    {[@expl:update requires] premise_ViewUpdateInsert_MapRelation_K_V upd (view_Resource_View_MapRelation_K_V self.current)}
    any
    [ return (result: ()) -> {id_View_MapRelation_K_V self.final = id_View_MapRelation_K_V self.current}
      {view_Resource_View_MapRelation_K_V self.final
      = update_ViewUpdateInsert_MapRelation_K_V upd (view_Resource_View_MapRelation_K_V self.current) result}
      (! return {result}) ]
  
  function new_frag_MapRelation_K_V [@inline:trivial] (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V =
    new_MapRelation_K_V (None'0) frag
  
  meta "rewrite_def" function new_frag_MapRelation_K_V
  
  function new_auth_MapRelation_K_V [@inline:trivial] (auth: t_FMap_K_V) : t_View_MapRelation_K_V =
    new_MapRelation_K_V (Some'0 auth) unit_FMap_K_Ag_V
  
  meta "rewrite_def" function new_auth_MapRelation_K_V
  
  type t_Option_View_MapRelation_K_V = None'4 | Some'4 t_View_MapRelation_K_V
  
  function and_then_Option_View_MapRelation_K_V (self: t_Option_View_MapRelation_K_V) (f: Map.map t_View_MapRelation_K_V t_Option_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match self with
      | None'4 -> None'4
      | Some'4 x -> Map.get f x
      end
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'4: t_Option_FMap_K_V; f1'4: t_Option_FMap_K_V }
  
  function op_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match op_FMap_K_Ag_V (frag_MapRelation_K_V self) (frag_MapRelation_K_V other) with
      | Some'2 f -> match { f0'4 = auth_MapRelation_K_V self; f1'4 = auth_MapRelation_K_V other } with
        | {f0'4 = None'0; f1'4 = a} -> if rel_MapRelation_K_V a f then Some'4 (new_MapRelation_K_V a f) else None'4
        | {f0'4 = a; f1'4 = None'0} -> if rel_MapRelation_K_V a f then Some'4 (new_MapRelation_K_V a f) else None'4
        | _ -> None'4
        end
      | None'2 -> None'4
      end
  
  function associative_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (c: t_View_MapRelation_K_V) : ()
  
  axiom associative_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V, c: t_View_MapRelation_K_V. and_then_Option_View_MapRelation_K_V (op_View_MapRelation_K_V a b) (fun (ab: t_View_MapRelation_K_V) -> op_View_MapRelation_K_V ab c)
      = and_then_Option_View_MapRelation_K_V (op_View_MapRelation_K_V b c) (fun (bc: t_View_MapRelation_K_V) -> op_View_MapRelation_K_V a bc)
  
  function commutative_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) : ()
  
  axiom commutative_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V. op_View_MapRelation_K_V a b
      = op_View_MapRelation_K_V b a
  
  function factor_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (factor: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match factor_FMap_K_Ag_V (frag_MapRelation_K_V self) (frag_MapRelation_K_V factor) with
      | Some'2 f -> match { f0'4 = auth_MapRelation_K_V self; f1'4 = auth_MapRelation_K_V factor } with
        | {f0'4 = Some'0 a; f1'4 = None'0} -> Some'4 (new_MapRelation_K_V (Some'0 a) f)
        | {f0'4 = a1; f1'4 = a2} -> if a1 = a2 then Some'4 (new_frag_MapRelation_K_V f) else None'4
        end
      | None'2 -> None'4
      end
  
  axiom factor_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V, factor: t_View_MapRelation_K_V. match factor_View_MapRelation_K_V self factor with
        | Some'4 c -> op_View_MapRelation_K_V factor c = Some'4 self
        | None'4 -> forall c: t_View_MapRelation_K_V. op_View_MapRelation_K_V factor c <> Some'4 self
        end
  
  predicate incl_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) =
    factor_View_MapRelation_K_V other self <> None'4
  
  function incl_transitive_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (c: t_View_MapRelation_K_V) : ()
  
  axiom incl_transitive_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V, c: t_View_MapRelation_K_V. incl_View_MapRelation_K_V a b
      -> incl_View_MapRelation_K_V b c -> incl_View_MapRelation_K_V a c
  
  function incl_op_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) (comb: t_View_MapRelation_K_V) : ()
  
  axiom incl_op_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V, other: t_View_MapRelation_K_V, comb: t_View_MapRelation_K_V. op_View_MapRelation_K_V self other
        = Some'4 comb -> incl_View_MapRelation_K_V self comb
  
  predicate incl_eq_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) =
    self = other \/ incl_View_MapRelation_K_V self other
  
  predicate incl_eq_op_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (x: t_View_MapRelation_K_V) =
    match op_View_MapRelation_K_V a b with
      | None'4 -> false
      | Some'4 ab -> incl_eq_View_MapRelation_K_V ab x
      end
  
  let rec split_off_View_MapRelation_K_V (self: MutBorrow.t t_Resource_View_MapRelation_K_V) (r: t_View_MapRelation_K_V)
    (s: t_View_MapRelation_K_V) (return (x: t_Resource_View_MapRelation_K_V)) =
    {[@expl:split_off requires] incl_eq_op_View_MapRelation_K_V r s (view_Resource_View_MapRelation_K_V self.current)}
    any
    [ return (result: t_Resource_View_MapRelation_K_V) -> {id_View_MapRelation_K_V self.final
        = id_View_MapRelation_K_V self.current
      /\ id_View_MapRelation_K_V result = id_View_MapRelation_K_V self.current}
      {view_Resource_View_MapRelation_K_V self.final = s}
      {view_Resource_View_MapRelation_K_V result = r}
      (! return {result}) ]
  
  predicate invariant_Authority_K_V (self: t_Authority_K_V) =
    auth_MapRelation_K_V (view_Resource_View_MapRelation_K_V self.f0) <> None'0
  
  predicate inv_Authority_K_V (_1: t_Authority_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_K_V [inv_Authority_K_V x]. inv_Authority_K_V x
      = invariant_Authority_K_V x
  
  predicate invariant_ref_Authority_K_V [@inline:trivial] (self: MutBorrow.t t_Authority_K_V) =
    inv_Authority_K_V self.current /\ inv_Authority_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Authority_K_V
  
  predicate inv_ref_Authority_K_V [@inline:trivial] (_1: MutBorrow.t t_Authority_K_V) = invariant_ref_Authority_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Authority_K_V
  
  predicate resolve_ref_Authority_K_V [@inline:trivial] (_1: MutBorrow.t t_Authority_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Authority_K_V
  
  type t_Fragment_K_V = { f0'5: t_Resource_View_MapRelation_K_V; f1'5: t_K; f2'5: t_V }
  
  predicate invariant_Fragment_K_V (self: t_Fragment_K_V) =
    incl_View_MapRelation_K_V (new_frag_MapRelation_K_V (singleton_K self.f1'5 { f0'0 = self.f2'5 })) (view_Resource_View_MapRelation_K_V self.f0'5)
  
  predicate inv_Fragment_K_V (_1: t_Fragment_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment_K_V [inv_Fragment_K_V x]. inv_Fragment_K_V x
      = invariant_Fragment_K_V x
  
  function id_K (self: t_Authority_K_V) : t_Id = id_View_MapRelation_K_V self.f0
  
  type tup2_K_V = { f0'6: t_K; f1'6: t_V }
  
  function view_Fragment_K_V (self: t_Fragment_K_V) : tup2_K_V = { f0'6 = self.f1'5; f1'6 = self.f2'5 }
  
  function id_K'0 (self: t_Fragment_K_V) : t_Id = id_View_MapRelation_K_V self.f0'5
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert_K'1 (self: MutBorrow.t t_Authority_K_V) (k: t_K) (v: t_V) (return (x: t_Fragment_K_V)) =
    {[@expl:insert 'self' type invariant] inv_ref_Authority_K_V self}
    {[@expl:insert requires] not contains_K (view_Authority_K_V self.current) k}
    (! bb0
    [ bb0 = s0 [ s0 = [ &auth <- insert_K (view_Authority_K_V self.current) k v ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &frag <- singleton_K k { f0'0 = v } ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_15 <- { f0'1 = auth; f1'1 = frag } ] s1
      | s1 = MutBorrow.borrow_mut <t_Resource_View_MapRelation_K_V> {self.current.f0}
          (fun (_ret: MutBorrow.t t_Resource_View_MapRelation_K_V) ->
            [ &_14 <- _ret ] [ &self <- { self with current = { f0 = _ret.final } } ] s2)
      | s2 = update_View_MapRelation_K_V {_14} {_15} (fun (_ret: ()) -> [ &_13 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0 [ s0 = [ &_20 <- new_frag_MapRelation_K_V frag ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = [ &_22 <- new_auth_MapRelation_K_V auth ] s1 | s1 = bb5 ]
    | bb5 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource_View_MapRelation_K_V> {self.current.f0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Resource_View_MapRelation_K_V) ->
            [ &_19 <- _ret ] [ &self <- { self with current = { f0 = _ret.final } } ] s1)
      | s1 = split_off_View_MapRelation_K_V {_19} {_20} {_22}
          (fun (_ret: t_Resource_View_MapRelation_K_V) -> [ &_18 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Authority_K_V self} s1
      | s1 = -{resolve_ref_Authority_K_V self}- s2
      | s2 = [ &_24 <- k ] s3
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = [ &_26 <- v ] s1 | s1 = bb8 ]
    | bb8 = s0 [ s0 = [ &_0 <- { f0'5 = _18; f1'5 = _24; f2'5 = _26 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Fragment_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Authority_K_V = self
    | & k: t_K = k
    | & v: t_V = v
    | & auth: t_FMap_K_V = Any.any_l ()
    | & frag: t_FMap_K_Ag_V = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & _14: MutBorrow.t t_Resource_View_MapRelation_K_V = Any.any_l ()
    | & _15: t_ViewUpdateInsert_MapRelation_K_V = Any.any_l ()
    | & _18: t_Resource_View_MapRelation_K_V = Any.any_l ()
    | & _19: MutBorrow.t t_Resource_View_MapRelation_K_V = Any.any_l ()
    | & _20: t_View_MapRelation_K_V = Any.any_l ()
    | & _22: t_View_MapRelation_K_V = Any.any_l ()
    | & _24: t_K = Any.any_l ()
    | & _26: t_V = Any.any_l () ])
    [ return (result: t_Fragment_K_V) -> {[@expl:insert result type invariant] inv_Fragment_K_V result}
      {[@expl:insert ensures #0] view_Authority_K_V self.final = insert_K (view_Authority_K_V self.current) k v}
      {[@expl:insert ensures #1] id_K self.final = id_K self.current}
      {[@expl:insert ensures #2] view_Fragment_K_V result = { f0'6 = k; f1'6 = v }}
      {[@expl:insert ensures #3] id_K'0 result = id_K self.current}
      (! return {result}) ]
end
module M_impl_Authority_K_V__contains (* Authority<K, V> *)
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource_View_MapRelation_K_V
  
  type t_K
  
  type t_V
  
  type t_Fragment_K_V = { f0: t_Resource_View_MapRelation_K_V; f1: t_K; f2: t_V }
  
  type t_Authority_K_V = { f0'0: t_Resource_View_MapRelation_K_V }
  
  type t_Id
  
  function id_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V) : t_Id
  
  type t_View_MapRelation_K_V
  
  type t_Option_View_MapRelation_K_V = None | Some t_View_MapRelation_K_V
  
  function and_then_Option_View_MapRelation_K_V (self: t_Option_View_MapRelation_K_V) (f: Map.map t_View_MapRelation_K_V t_Option_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None'0 | Some'0 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type t_Ag_V = { f0'1: t_V }
  
  type t_Option_Ag_V = None'1 | Some'1 t_Ag_V
  
  type t_Option_Option_Ag_V = None'2 | Some'2 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'2: t_Option_Ag_V; f1'2: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'1 -> None'2
      | Some'1 x -> Some'2 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0'1 = other.f0'1 then
      Some'1 self
    else
      None'1
  
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'2 = self;
                                                                                                        f1'2 = other } with
      | {f0'2 = None'1} -> Some'2 other
      | {f1'2 = None'1} -> Some'2 self
      | {f0'2 = Some'1 x; f1'2 = Some'1 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'1 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'2 then
      Some'0 (total_op_K self other)
    else
      None'0
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None'3 | Some'3 t_FMap_K_V
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'1)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'0 x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'1 c -> op_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'1 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'2 = self; f1'2 = factor } with
      | {f0'2 = x; f1'2 = None'1} -> Some'2 x
      | {f0'2 = None'1} -> None'2
      | {f0'2 = Some'1 x; f1'2 = Some'1 y} -> match factor_Ag_V x y with
        | Some'1 z -> Some'2 (Some'1 z)
        | None'1 -> if x = y then Some'2 (None'1) else None'2
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'2 c -> op_Option_Ag_V factor c = Some'2 self
        | None'2 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'2 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'2
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'2 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'3: t_K; f1'3: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'1 -> None'1
          | Some'1 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'3 = k; f1'3 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'3 = k; f1'3 = vo} = __0 in match factor_Option_Ag_V (Some'1 vo) (get_K factor k) with
        | Some'2 r -> r
        | None'2 -> None'1
        end) in Some'0 res
    else
      None'0
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'0 c -> op_FMap_K_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'0 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'0
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'0 comb
      -> incl_FMap_K_Ag_V self comb
  
  type t_Option_V = None'4 | Some'4 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some'3 a'0 -> forall k: t_K. match get_K f k with
          | Some'1 {f0'1 = v} -> get_K'0 a'0 k = Some'4 v
          | _ -> true
          end
      | None'3 -> true
      end
  
  function rel_unit_MapRelation_K_V (a: t_Option_FMap_K_V) : () = ()
  
  axiom rel_unit_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V. rel_MapRelation_K_V a unit_FMap_K_Ag_V
  
  function rel_none_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_none_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V, f: t_FMap_K_Ag_V. rel_MapRelation_K_V a f
      -> rel_MapRelation_K_V (None'3) f
  
  function rel_mono_MapRelation_K_V (a: t_Option_FMap_K_V) (f1'0: t_FMap_K_Ag_V) (f2'0: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_mono_MapRelation_K_V_spec:
    forall a: t_Option_FMap_K_V, f1'0: t_FMap_K_Ag_V, f2'0: t_FMap_K_Ag_V. rel_MapRelation_K_V a f1'0
      -> incl_FMap_K_Ag_V f2'0 f1'0 -> rel_MapRelation_K_V a f2'0
  
  function auth_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_Option_FMap_K_V
  
  function frag_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_FMap_K_Ag_V
  
  axiom frag_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V. rel_MapRelation_K_V (auth_MapRelation_K_V self) (frag_MapRelation_K_V self)
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'4: t_Option_FMap_K_V; f1'4: t_Option_FMap_K_V }
  
  function new_MapRelation_K_V (auth: t_Option_FMap_K_V) (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V
  
  axiom new_MapRelation_K_V_spec: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> auth_MapRelation_K_V (new_MapRelation_K_V auth frag) = auth
  
  axiom new_MapRelation_K_V_spec'0: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> frag_MapRelation_K_V (new_MapRelation_K_V auth frag) = frag
  
  function op_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match op_FMap_K_Ag_V (frag_MapRelation_K_V self) (frag_MapRelation_K_V other) with
      | Some'0 f -> match { f0'4 = auth_MapRelation_K_V self; f1'4 = auth_MapRelation_K_V other } with
        | {f0'4 = None'3; f1'4 = a} -> if rel_MapRelation_K_V a f then Some (new_MapRelation_K_V a f) else None
        | {f0'4 = a; f1'4 = None'3} -> if rel_MapRelation_K_V a f then Some (new_MapRelation_K_V a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (c: t_View_MapRelation_K_V) : ()
  
  axiom associative_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V, c: t_View_MapRelation_K_V. and_then_Option_View_MapRelation_K_V (op_View_MapRelation_K_V a b) (fun (ab: t_View_MapRelation_K_V) -> op_View_MapRelation_K_V ab c)
      = and_then_Option_View_MapRelation_K_V (op_View_MapRelation_K_V b c) (fun (bc: t_View_MapRelation_K_V) -> op_View_MapRelation_K_V a bc)
  
  function commutative_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) : ()
  
  axiom commutative_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V. op_View_MapRelation_K_V a b
      = op_View_MapRelation_K_V b a
  
  function new_frag_MapRelation_K_V [@inline:trivial] (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V =
    new_MapRelation_K_V (None'3) frag
  
  meta "rewrite_def" function new_frag_MapRelation_K_V
  
  function factor_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (factor: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match factor_FMap_K_Ag_V (frag_MapRelation_K_V self) (frag_MapRelation_K_V factor) with
      | Some'0 f -> match { f0'4 = auth_MapRelation_K_V self; f1'4 = auth_MapRelation_K_V factor } with
        | {f0'4 = Some'3 a; f1'4 = None'3} -> Some (new_MapRelation_K_V (Some'3 a) f)
        | {f0'4 = a1; f1'4 = a2} -> if a1 = a2 then Some (new_frag_MapRelation_K_V f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V, factor: t_View_MapRelation_K_V. match factor_View_MapRelation_K_V self factor with
        | Some c -> op_View_MapRelation_K_V factor c = Some self
        | None -> forall c: t_View_MapRelation_K_V. op_View_MapRelation_K_V factor c <> Some self
        end
  
  predicate incl_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) =
    factor_View_MapRelation_K_V other self <> None
  
  function incl_transitive_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (c: t_View_MapRelation_K_V) : ()
  
  axiom incl_transitive_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V, c: t_View_MapRelation_K_V. incl_View_MapRelation_K_V a b
      -> incl_View_MapRelation_K_V b c -> incl_View_MapRelation_K_V a c
  
  function incl_op_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) (comb: t_View_MapRelation_K_V) : ()
  
  axiom incl_op_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V, other: t_View_MapRelation_K_V, comb: t_View_MapRelation_K_V. op_View_MapRelation_K_V self other
        = Some comb -> incl_View_MapRelation_K_V self comb
  
  predicate incl_eq_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) =
    self = other \/ incl_View_MapRelation_K_V self other
  
  function val_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
  
  function view_Resource_View_MapRelation_K_V [@inline:trivial] (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
   = val_View_MapRelation_K_V self
  
  meta "rewrite_def" function view_Resource_View_MapRelation_K_V
  
  let rec join_shared_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V)
    (other: t_Resource_View_MapRelation_K_V) (return (x: t_Resource_View_MapRelation_K_V)) =
    {[@expl:join_shared requires] id_View_MapRelation_K_V self = id_View_MapRelation_K_V other}
    any
    [ return (result: t_Resource_View_MapRelation_K_V) -> {id_View_MapRelation_K_V result
      = id_View_MapRelation_K_V self}
      {incl_eq_View_MapRelation_K_V (view_Resource_View_MapRelation_K_V self) (view_Resource_View_MapRelation_K_V result)
      /\ incl_eq_View_MapRelation_K_V (view_Resource_View_MapRelation_K_V other) (view_Resource_View_MapRelation_K_V result)}
      (! return {result}) ]
  
  type tup2_K_V = { f0'5: t_K; f1'5: t_V }
  
  function view_Fragment_K_V (self: t_Fragment_K_V) : tup2_K_V = { f0'5 = self.f1; f1'5 = self.f2 }
  
  predicate invariant_Authority_K_V (self: t_Authority_K_V) =
    auth_MapRelation_K_V (view_Resource_View_MapRelation_K_V self.f0'0) <> None'3
  
  predicate inv_Authority_K_V (_1: t_Authority_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_K_V [inv_Authority_K_V x]. inv_Authority_K_V x
      = invariant_Authority_K_V x
  
  predicate invariant_ref_Authority_K_V [@inline:trivial] (self: t_Authority_K_V) = inv_Authority_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Authority_K_V
  
  predicate inv_ref_Authority_K_V [@inline:trivial] (_1: t_Authority_K_V) = invariant_ref_Authority_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Authority_K_V
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) = get_K self k <> None'1
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_Ag_V) (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V
  
  axiom insert_K_spec: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. view_FMap_K_Ag_V (insert_K self k v)
      = Map.set (view_FMap_K_Ag_V self) k (Some'1 v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  function singleton_K (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V = insert_K empty_K k v
  
  predicate invariant_Fragment_K_V (self: t_Fragment_K_V) =
    incl_View_MapRelation_K_V (new_frag_MapRelation_K_V (singleton_K self.f1 { f0'1 = self.f2 })) (view_Resource_View_MapRelation_K_V self.f0)
  
  predicate inv_Fragment_K_V (_1: t_Fragment_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment_K_V [inv_Fragment_K_V x]. inv_Fragment_K_V x
      = invariant_Fragment_K_V x
  
  predicate invariant_ref_Fragment_K_V [@inline:trivial] (self: t_Fragment_K_V) = inv_Fragment_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Fragment_K_V
  
  predicate inv_ref_Fragment_K_V [@inline:trivial] (_1: t_Fragment_K_V) = invariant_ref_Fragment_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Fragment_K_V
  
  function id_K (self: t_Authority_K_V) : t_Id = id_View_MapRelation_K_V self.f0'0
  
  function id_K'0 (self: t_Fragment_K_V) : t_Id = id_View_MapRelation_K_V self.f0
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some'3 x -> x
      | None'3 -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  function view_Authority_K_V (self: t_Authority_K_V) : t_FMap_K_V =
    unwrap_Option_FMap_K_V (auth_MapRelation_K_V (view_Resource_View_MapRelation_K_V self.f0'0))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains_K'0 (self: t_Authority_K_V) (frag: t_Fragment_K_V) (return (x: ())) =
    {[@expl:contains 'self' type invariant] inv_ref_Authority_K_V self}
    {[@expl:contains 'frag' type invariant] inv_ref_Fragment_K_V frag}
    {[@expl:contains requires] id_K self = id_K'0 frag}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- frag.f0 ] s1
      | s1 = join_shared_View_MapRelation_K_V {self.f0'0} {_8}
          (fun (_ret: t_Resource_View_MapRelation_K_V) -> [ &new_resource <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 =
        {[@expl:assertion] get_K (frag_MapRelation_K_V (view_Resource_View_MapRelation_K_V new_resource)) (view_Fragment_K_V frag).f0'5
        = Some'1 { f0'1 = (view_Fragment_K_V frag).f1'5 }}
        s1
      | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: t_Authority_K_V = self
    | & frag: t_Fragment_K_V = frag
    | & new_resource: t_Resource_View_MapRelation_K_V = Any.any_l ()
    | & _8: t_Resource_View_MapRelation_K_V = Any.any_l () ])
    [ return (result: ()) -> {[@expl:contains ensures] get_K'0 (view_Authority_K_V self) (view_Fragment_K_V frag).f0'5
      = Some'4 ((view_Fragment_K_V frag).f1'5)}
      (! return {result}) ]
end
module M_impl_Clone_for_Fragment_K_V__clone (* <Fragment<K, V> as std::clone::Clone> *)
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource_View_MapRelation_K_V
  
  type t_K
  
  type t_V
  
  type t_Fragment_K_V = { f0: t_Resource_View_MapRelation_K_V; f1: t_K; f2: t_V }
  
  type t_View_MapRelation_K_V
  
  type t_Option_View_MapRelation_K_V = None | Some t_View_MapRelation_K_V
  
  function and_then_Option_View_MapRelation_K_V (self: t_Option_View_MapRelation_K_V) (f: Map.map t_View_MapRelation_K_V t_Option_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None'0 | Some'0 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type t_Ag_V = { f0'0: t_V }
  
  type t_Option_Ag_V = None'1 | Some'1 t_Ag_V
  
  type t_Option_Option_Ag_V = None'2 | Some'2 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'1: t_Option_Ag_V; f1'1: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'1 -> None'2
      | Some'1 x -> Some'2 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0'0 = other.f0'0 then
      Some'1 self
    else
      None'1
  
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'1 = self;
                                                                                                        f1'1 = other } with
      | {f0'1 = None'1} -> Some'2 other
      | {f1'1 = None'1} -> Some'2 self
      | {f0'1 = Some'1 x; f1'1 = Some'1 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'1 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'2 then
      Some'0 (total_op_K self other)
    else
      None'0
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None'3 | Some'3 t_FMap_K_V
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'1)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'0 x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'1 c -> op_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'1 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'1 = self; f1'1 = factor } with
      | {f0'1 = x; f1'1 = None'1} -> Some'2 x
      | {f0'1 = None'1} -> None'2
      | {f0'1 = Some'1 x; f1'1 = Some'1 y} -> match factor_Ag_V x y with
        | Some'1 z -> Some'2 (Some'1 z)
        | None'1 -> if x = y then Some'2 (None'1) else None'2
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'2 c -> op_Option_Ag_V factor c = Some'2 self
        | None'2 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'2 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'2
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'2 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'2: t_K; f1'2: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'1 -> None'1
          | Some'1 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'2 = k; f1'2 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'2 = k; f1'2 = vo} = __0 in match factor_Option_Ag_V (Some'1 vo) (get_K factor k) with
        | Some'2 r -> r
        | None'2 -> None'1
        end) in Some'0 res
    else
      None'0
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'0 c -> op_FMap_K_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'0 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'0
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'0 comb
      -> incl_FMap_K_Ag_V self comb
  
  type t_Option_V = None'4 | Some'4 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some'3 a'0 -> forall k: t_K. match get_K f k with
          | Some'1 {f0'0 = v} -> get_K'0 a'0 k = Some'4 v
          | _ -> true
          end
      | None'3 -> true
      end
  
  function rel_unit_MapRelation_K_V (a: t_Option_FMap_K_V) : () = ()
  
  axiom rel_unit_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V. rel_MapRelation_K_V a unit_FMap_K_Ag_V
  
  function rel_none_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_none_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V, f: t_FMap_K_Ag_V. rel_MapRelation_K_V a f
      -> rel_MapRelation_K_V (None'3) f
  
  function rel_mono_MapRelation_K_V (a: t_Option_FMap_K_V) (f1'0: t_FMap_K_Ag_V) (f2'0: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_mono_MapRelation_K_V_spec:
    forall a: t_Option_FMap_K_V, f1'0: t_FMap_K_Ag_V, f2'0: t_FMap_K_Ag_V. rel_MapRelation_K_V a f1'0
      -> incl_FMap_K_Ag_V f2'0 f1'0 -> rel_MapRelation_K_V a f2'0
  
  function auth_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_Option_FMap_K_V
  
  function frag_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_FMap_K_Ag_V
  
  axiom frag_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V. rel_MapRelation_K_V (auth_MapRelation_K_V self) (frag_MapRelation_K_V self)
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'3: t_Option_FMap_K_V; f1'3: t_Option_FMap_K_V }
  
  function new_MapRelation_K_V (auth: t_Option_FMap_K_V) (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V
  
  axiom new_MapRelation_K_V_spec: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> auth_MapRelation_K_V (new_MapRelation_K_V auth frag) = auth
  
  axiom new_MapRelation_K_V_spec'0: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> frag_MapRelation_K_V (new_MapRelation_K_V auth frag) = frag
  
  function op_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match op_FMap_K_Ag_V (frag_MapRelation_K_V self) (frag_MapRelation_K_V other) with
      | Some'0 f -> match { f0'3 = auth_MapRelation_K_V self; f1'3 = auth_MapRelation_K_V other } with
        | {f0'3 = None'3; f1'3 = a} -> if rel_MapRelation_K_V a f then Some (new_MapRelation_K_V a f) else None
        | {f0'3 = a; f1'3 = None'3} -> if rel_MapRelation_K_V a f then Some (new_MapRelation_K_V a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (c: t_View_MapRelation_K_V) : ()
  
  axiom associative_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V, c: t_View_MapRelation_K_V. and_then_Option_View_MapRelation_K_V (op_View_MapRelation_K_V a b) (fun (ab: t_View_MapRelation_K_V) -> op_View_MapRelation_K_V ab c)
      = and_then_Option_View_MapRelation_K_V (op_View_MapRelation_K_V b c) (fun (bc: t_View_MapRelation_K_V) -> op_View_MapRelation_K_V a bc)
  
  function commutative_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) : ()
  
  axiom commutative_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V. op_View_MapRelation_K_V a b
      = op_View_MapRelation_K_V b a
  
  function new_frag_MapRelation_K_V [@inline:trivial] (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V =
    new_MapRelation_K_V (None'3) frag
  
  meta "rewrite_def" function new_frag_MapRelation_K_V
  
  function core_Ag_V (self: t_Ag_V) : t_Option_Ag_V = Some'1 self
  
  axiom core_Ag_V_spec: forall self: t_Ag_V. match core_Ag_V self with
        | Some'1 c -> op_Ag_V c c = Some'1 c /\ op_Ag_V c self = Some'1 self
        | None'1 -> true
        end
  
  function core_total_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : t_FMap_K_Ag_V =
    let r = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f1'2 = v} = __0 in core_Ag_V v) in r
  
  axiom core_total_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V. op_FMap_K_Ag_V (core_total_FMap_K_Ag_V self) (core_total_FMap_K_Ag_V self)
      = Some'0 (core_total_FMap_K_Ag_V self)
  
  axiom core_total_FMap_K_Ag_V_spec'0: forall self: t_FMap_K_Ag_V. op_FMap_K_Ag_V (core_total_FMap_K_Ag_V self) self
      = Some'0 self
  
  function core_total_View_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_View_MapRelation_K_V =
    new_frag_MapRelation_K_V (core_total_FMap_K_Ag_V (frag_MapRelation_K_V self))
  
  axiom core_total_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V. op_View_MapRelation_K_V (core_total_View_MapRelation_K_V self) (core_total_View_MapRelation_K_V self)
      = Some (core_total_View_MapRelation_K_V self)
  
  axiom core_total_View_MapRelation_K_V_spec'0:
    forall self: t_View_MapRelation_K_V. op_View_MapRelation_K_V (core_total_View_MapRelation_K_V self) self = Some self
  
  function core_View_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V =
    Some (core_total_View_MapRelation_K_V self)
  
  axiom core_View_MapRelation_K_V_spec: forall self: t_View_MapRelation_K_V. match core_View_MapRelation_K_V self with
        | Some c -> op_View_MapRelation_K_V c c = Some c /\ op_View_MapRelation_K_V c self = Some self
        | None -> true
        end
  
  function val_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
  
  function view_Resource_View_MapRelation_K_V [@inline:trivial] (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
   = val_View_MapRelation_K_V self
  
  meta "rewrite_def" function view_Resource_View_MapRelation_K_V
  
  type t_Id
  
  function id_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V) : t_Id
  
  let rec core_View_MapRelation_K_V'0 (self: t_Resource_View_MapRelation_K_V)
    (return (x: t_Resource_View_MapRelation_K_V)) =
    {[@expl:core requires] core_View_MapRelation_K_V (view_Resource_View_MapRelation_K_V self) <> None}
    any
    [ return (result: t_Resource_View_MapRelation_K_V) -> {id_View_MapRelation_K_V result
      = id_View_MapRelation_K_V self}
      {Some (view_Resource_View_MapRelation_K_V result)
      = core_View_MapRelation_K_V (view_Resource_View_MapRelation_K_V self)}
      (! return {result}) ]
  
  function factor_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (factor: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match factor_FMap_K_Ag_V (frag_MapRelation_K_V self) (frag_MapRelation_K_V factor) with
      | Some'0 f -> match { f0'3 = auth_MapRelation_K_V self; f1'3 = auth_MapRelation_K_V factor } with
        | {f0'3 = Some'3 a; f1'3 = None'3} -> Some (new_MapRelation_K_V (Some'3 a) f)
        | {f0'3 = a1; f1'3 = a2} -> if a1 = a2 then Some (new_frag_MapRelation_K_V f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V, factor: t_View_MapRelation_K_V. match factor_View_MapRelation_K_V self factor with
        | Some c -> op_View_MapRelation_K_V factor c = Some self
        | None -> forall c: t_View_MapRelation_K_V. op_View_MapRelation_K_V factor c <> Some self
        end
  
  predicate incl_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) =
    factor_View_MapRelation_K_V other self <> None
  
  function incl_transitive_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (c: t_View_MapRelation_K_V) : ()
  
  axiom incl_transitive_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V, c: t_View_MapRelation_K_V. incl_View_MapRelation_K_V a b
      -> incl_View_MapRelation_K_V b c -> incl_View_MapRelation_K_V a c
  
  function incl_op_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) (comb: t_View_MapRelation_K_V) : ()
  
  axiom incl_op_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V, other: t_View_MapRelation_K_V, comb: t_View_MapRelation_K_V. op_View_MapRelation_K_V self other
        = Some comb -> incl_View_MapRelation_K_V self comb
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) = get_K self k <> None'1
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_Ag_V) (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V
  
  axiom insert_K_spec: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. view_FMap_K_Ag_V (insert_K self k v)
      = Map.set (view_FMap_K_Ag_V self) k (Some'1 v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  function singleton_K (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V = insert_K empty_K k v
  
  predicate invariant_Fragment_K_V (self: t_Fragment_K_V) =
    incl_View_MapRelation_K_V (new_frag_MapRelation_K_V (singleton_K self.f1 { f0'0 = self.f2 })) (view_Resource_View_MapRelation_K_V self.f0)
  
  predicate inv_Fragment_K_V (_1: t_Fragment_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment_K_V [inv_Fragment_K_V x]. inv_Fragment_K_V x
      = invariant_Fragment_K_V x
  
  predicate invariant_ref_Fragment_K_V [@inline:trivial] (self: t_Fragment_K_V) = inv_Fragment_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Fragment_K_V
  
  predicate inv_ref_Fragment_K_V [@inline:trivial] (_1: t_Fragment_K_V) = invariant_ref_Fragment_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Fragment_K_V
  
  type tup2_K_V = { f0'4: t_K; f1'4: t_V }
  
  function view_Fragment_K_V (self: t_Fragment_K_V) : tup2_K_V = { f0'4 = self.f1; f1'4 = self.f2 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Fragment_K_V (self: t_Fragment_K_V) (return (x: t_Fragment_K_V)) =
    {[@expl:clone 'self' type invariant] inv_ref_Fragment_K_V self}
    (! bb0
    [ bb0 = s0
      [ s0 = core_View_MapRelation_K_V'0 {self.f0} (fun (_ret: t_Resource_View_MapRelation_K_V) -> [ &_3 <- _ret ] s1)
      | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { f0 = _3; f1 = self.f1; f2 = self.f2 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Fragment_K_V = Any.any_l ()
    | & self: t_Fragment_K_V = self
    | & _3: t_Resource_View_MapRelation_K_V = Any.any_l () ])
    [ return (result: t_Fragment_K_V) -> {[@expl:clone result type invariant] inv_Fragment_K_V result}
      {[@expl:clone ensures] view_Fragment_K_V result = view_Fragment_K_V self}
      (! return {result}) ]
end
module M_impl_ViewRel_for_MapRelation_K_V__rel_mono__refines (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  
  type t_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None | Some t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_Option_Ag_V = None'0 | Some'0 t_Ag_V
  
  type t_Option_Option_Ag_V = None'1 | Some'1 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'0: t_Option_Ag_V; f1'0: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0 = other.f0 then Some'0 self else None'0
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'0 = self;
                                                                                                        f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'0 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  type t_K
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'1 then
      Some (total_op_K self other)
    else
      None
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'0 c -> op_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'0 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'0 = self; f1'0 = factor } with
      | {f0'0 = x; f1'0 = None'0} -> Some'1 x
      | {f0'0 = None'0} -> None'1
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> match factor_Ag_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'1 c -> op_Option_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'1 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'1
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'1 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'1: t_K; f1'1: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'1 = k; f1'1 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_Ag_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in Some res
    else
      None
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some c -> op_FMap_K_Ag_V factor c = Some self
        | None -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some comb
      -> incl_FMap_K_Ag_V self comb
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None'2 | Some'2 t_FMap_K_V
  
  type t_Option_V = None'3 | Some'3 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some'2 a'0 -> forall k: t_K. match get_K f k with
          | Some'0 {f0 = v} -> get_K'0 a'0 k = Some'3 v
          | _ -> true
          end
      | None'2 -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_FMap_K_V. forall f1: t_FMap_K_Ag_V. forall f2: t_FMap_K_Ag_V. incl_FMap_K_Ag_V f2 f1
            /\ rel_MapRelation_K_V a f1
          -> incl_FMap_K_Ag_V f2 f1
          /\ rel_MapRelation_K_V a f1 /\ (forall result: (). rel_MapRelation_K_V a f2 -> rel_MapRelation_K_V a f2)
end
module M_impl_ViewRel_for_MapRelation_K_V__rel_unit__refines (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_FMap_K_Ag_V
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_Option_Ag_V = None'0 | Some'0 t_Ag_V
  
  type t_K
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  type t_Option_V = None'1 | Some'1 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some a'0 -> forall k: t_K. match get_K f k with
          | Some'0 {f0 = v} -> get_K'0 a'0 k = Some'1 v
          | _ -> true
          end
      | None -> true
      end
  
  type t_Option_FMap_K_Ag_V = None'2 | Some'2 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type t_Option_Option_Ag_V = None'3 | Some'3 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'3 -> None'3
      | Some'3 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'0: t_Option_Ag_V; f1'0: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'0 -> None'3
      | Some'0 x -> Some'3 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0 = other.f0 then Some'0 self else None'0
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'0 = self;
                                                                                                        f1'0 = other } with
      | {f0'0 = None'0} -> Some'3 other
      | {f1'0 = None'0} -> Some'3 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'0 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'3)
      -> (forall k: t_K. Some'3 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'3 then
      Some'2 (total_op_K self other)
    else
      None'2
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'0)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'2 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_FMap_K_V. forall result: (). rel_MapRelation_K_V a unit_FMap_K_Ag_V
        -> rel_MapRelation_K_V a unit_FMap_K_Ag_V
end
module M_impl_ViewRel_for_MapRelation_K_V__rel_none__refines (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_FMap_K_Ag_V
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_Option_Ag_V = None'0 | Some'0 t_Ag_V
  
  type t_K
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  type t_Option_V = None'1 | Some'1 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some a'0 -> forall k: t_K. match get_K f k with
          | Some'0 {f0 = v} -> get_K'0 a'0 k = Some'1 v
          | _ -> true
          end
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_FMap_K_V. forall f: t_FMap_K_Ag_V. rel_MapRelation_K_V a f
        -> rel_MapRelation_K_V a f /\ (forall result: (). rel_MapRelation_K_V (None) f -> rel_MapRelation_K_V (None) f)
end
module M_impl_Clone_for_Fragment_K_V__clone__refines (* <Fragment<K, V> as std::clone::Clone> *)
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Resource_View_MapRelation_K_V
  
  type t_K
  
  type t_V
  
  type t_Fragment_K_V = { f0: t_Resource_View_MapRelation_K_V; f1: t_K; f2: t_V }
  
  type t_View_MapRelation_K_V
  
  type t_Option_View_MapRelation_K_V = None | Some t_View_MapRelation_K_V
  
  function and_then_Option_View_MapRelation_K_V (self: t_Option_View_MapRelation_K_V) (f: Map.map t_View_MapRelation_K_V t_Option_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None'0 | Some'0 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type t_Ag_V = { f0'0: t_V }
  
  type t_Option_Ag_V = None'1 | Some'1 t_Ag_V
  
  type t_Option_Option_Ag_V = None'2 | Some'2 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'1: t_Option_Ag_V; f1'1: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'1 -> None'2
      | Some'1 x -> Some'2 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0'0 = other.f0'0 then
      Some'1 self
    else
      None'1
  
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'1 = self;
                                                                                                        f1'1 = other } with
      | {f0'1 = None'1} -> Some'2 other
      | {f1'1 = None'1} -> Some'2 self
      | {f0'1 = Some'1 x; f1'1 = Some'1 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'1 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'2 then
      Some'0 (total_op_K self other)
    else
      None'0
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None'3 | Some'3 t_FMap_K_V
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'1)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'0 x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'1 c -> op_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'1 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'1 = self; f1'1 = factor } with
      | {f0'1 = x; f1'1 = None'1} -> Some'2 x
      | {f0'1 = None'1} -> None'2
      | {f0'1 = Some'1 x; f1'1 = Some'1 y} -> match factor_Ag_V x y with
        | Some'1 z -> Some'2 (Some'1 z)
        | None'1 -> if x = y then Some'2 (None'1) else None'2
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'2 c -> op_Option_Ag_V factor c = Some'2 self
        | None'2 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'2 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'2
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'2 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'2: t_K; f1'2: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'1 -> None'1
          | Some'1 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'2 = k; f1'2 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'2 = k; f1'2 = vo} = __0 in match factor_Option_Ag_V (Some'1 vo) (get_K factor k) with
        | Some'2 r -> r
        | None'2 -> None'1
        end) in Some'0 res
    else
      None'0
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'0 c -> op_FMap_K_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'0 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'0
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'0 comb
      -> incl_FMap_K_Ag_V self comb
  
  type t_Option_V = None'4 | Some'4 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate rel_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some'3 a'0 -> forall k: t_K. match get_K f k with
          | Some'1 {f0'0 = v} -> get_K'0 a'0 k = Some'4 v
          | _ -> true
          end
      | None'3 -> true
      end
  
  function rel_unit_MapRelation_K_V (a: t_Option_FMap_K_V) : () = ()
  
  axiom rel_unit_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V. rel_MapRelation_K_V a unit_FMap_K_Ag_V
  
  function rel_none_MapRelation_K_V (a: t_Option_FMap_K_V) (f: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_none_MapRelation_K_V_spec: forall a: t_Option_FMap_K_V, f: t_FMap_K_Ag_V. rel_MapRelation_K_V a f
      -> rel_MapRelation_K_V (None'3) f
  
  function rel_mono_MapRelation_K_V (a: t_Option_FMap_K_V) (f1'0: t_FMap_K_Ag_V) (f2'0: t_FMap_K_Ag_V) : () = ()
  
  axiom rel_mono_MapRelation_K_V_spec:
    forall a: t_Option_FMap_K_V, f1'0: t_FMap_K_Ag_V, f2'0: t_FMap_K_Ag_V. rel_MapRelation_K_V a f1'0
      -> incl_FMap_K_Ag_V f2'0 f1'0 -> rel_MapRelation_K_V a f2'0
  
  function auth_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_Option_FMap_K_V
  
  function frag_MapRelation_K_V (self: t_View_MapRelation_K_V) : t_FMap_K_Ag_V
  
  axiom frag_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V. rel_MapRelation_K_V (auth_MapRelation_K_V self) (frag_MapRelation_K_V self)
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'3: t_Option_FMap_K_V; f1'3: t_Option_FMap_K_V }
  
  function new_MapRelation_K_V (auth: t_Option_FMap_K_V) (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V
  
  axiom new_MapRelation_K_V_spec: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> auth_MapRelation_K_V (new_MapRelation_K_V auth frag) = auth
  
  axiom new_MapRelation_K_V_spec'0: forall auth: t_Option_FMap_K_V, frag: t_FMap_K_Ag_V. rel_MapRelation_K_V auth frag
      -> frag_MapRelation_K_V (new_MapRelation_K_V auth frag) = frag
  
  function op_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match op_FMap_K_Ag_V (frag_MapRelation_K_V self) (frag_MapRelation_K_V other) with
      | Some'0 f -> match { f0'3 = auth_MapRelation_K_V self; f1'3 = auth_MapRelation_K_V other } with
        | {f0'3 = None'3; f1'3 = a} -> if rel_MapRelation_K_V a f then Some (new_MapRelation_K_V a f) else None
        | {f0'3 = a; f1'3 = None'3} -> if rel_MapRelation_K_V a f then Some (new_MapRelation_K_V a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (c: t_View_MapRelation_K_V) : ()
  
  axiom associative_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V, c: t_View_MapRelation_K_V. and_then_Option_View_MapRelation_K_V (op_View_MapRelation_K_V a b) (fun (ab: t_View_MapRelation_K_V) -> op_View_MapRelation_K_V ab c)
      = and_then_Option_View_MapRelation_K_V (op_View_MapRelation_K_V b c) (fun (bc: t_View_MapRelation_K_V) -> op_View_MapRelation_K_V a bc)
  
  function commutative_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) : ()
  
  axiom commutative_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V. op_View_MapRelation_K_V a b
      = op_View_MapRelation_K_V b a
  
  function new_frag_MapRelation_K_V [@inline:trivial] (frag: t_FMap_K_Ag_V) : t_View_MapRelation_K_V =
    new_MapRelation_K_V (None'3) frag
  
  meta "rewrite_def" function new_frag_MapRelation_K_V
  
  function factor_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (factor: t_View_MapRelation_K_V) : t_Option_View_MapRelation_K_V
   = match factor_FMap_K_Ag_V (frag_MapRelation_K_V self) (frag_MapRelation_K_V factor) with
      | Some'0 f -> match { f0'3 = auth_MapRelation_K_V self; f1'3 = auth_MapRelation_K_V factor } with
        | {f0'3 = Some'3 a; f1'3 = None'3} -> Some (new_MapRelation_K_V (Some'3 a) f)
        | {f0'3 = a1; f1'3 = a2} -> if a1 = a2 then Some (new_frag_MapRelation_K_V f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V, factor: t_View_MapRelation_K_V. match factor_View_MapRelation_K_V self factor with
        | Some c -> op_View_MapRelation_K_V factor c = Some self
        | None -> forall c: t_View_MapRelation_K_V. op_View_MapRelation_K_V factor c <> Some self
        end
  
  predicate incl_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) =
    factor_View_MapRelation_K_V other self <> None
  
  function incl_transitive_View_MapRelation_K_V (a: t_View_MapRelation_K_V) (b: t_View_MapRelation_K_V) (c: t_View_MapRelation_K_V) : ()
  
  axiom incl_transitive_View_MapRelation_K_V_spec:
    forall a: t_View_MapRelation_K_V, b: t_View_MapRelation_K_V, c: t_View_MapRelation_K_V. incl_View_MapRelation_K_V a b
      -> incl_View_MapRelation_K_V b c -> incl_View_MapRelation_K_V a c
  
  function incl_op_View_MapRelation_K_V (self: t_View_MapRelation_K_V) (other: t_View_MapRelation_K_V) (comb: t_View_MapRelation_K_V) : ()
  
  axiom incl_op_View_MapRelation_K_V_spec:
    forall self: t_View_MapRelation_K_V, other: t_View_MapRelation_K_V, comb: t_View_MapRelation_K_V. op_View_MapRelation_K_V self other
        = Some comb -> incl_View_MapRelation_K_V self comb
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) = get_K self k <> None'1
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_Ag_V) (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V
  
  axiom insert_K_spec: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. view_FMap_K_Ag_V (insert_K self k v)
      = Map.set (view_FMap_K_Ag_V self) k (Some'1 v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  function singleton_K (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V = insert_K empty_K k v
  
  function val_View_MapRelation_K_V (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
  
  function view_Resource_View_MapRelation_K_V [@inline:trivial] (self: t_Resource_View_MapRelation_K_V) : t_View_MapRelation_K_V
   = val_View_MapRelation_K_V self
  
  meta "rewrite_def" function view_Resource_View_MapRelation_K_V
  
  predicate invariant_Fragment_K_V (self: t_Fragment_K_V) =
    incl_View_MapRelation_K_V (new_frag_MapRelation_K_V (singleton_K self.f1 { f0'0 = self.f2 })) (view_Resource_View_MapRelation_K_V self.f0)
  
  predicate inv_Fragment_K_V (_1: t_Fragment_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment_K_V [inv_Fragment_K_V x]. inv_Fragment_K_V x
      = invariant_Fragment_K_V x
  
  predicate invariant_ref_Fragment_K_V [@inline:trivial] (self: t_Fragment_K_V) = inv_Fragment_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Fragment_K_V
  
  predicate inv_ref_Fragment_K_V [@inline:trivial] (_1: t_Fragment_K_V) = invariant_ref_Fragment_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Fragment_K_V
  
  type tup2_K_V = { f0'4: t_K; f1'4: t_V }
  
  function view_Fragment_K_V (self: t_Fragment_K_V) : tup2_K_V = { f0'4 = self.f1; f1'4 = self.f2 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Fragment_K_V. inv_ref_Fragment_K_V self_
      -> inv_ref_Fragment_K_V self_
      /\ (forall result: t_Fragment_K_V. view_Fragment_K_V result = view_Fragment_K_V self_ /\ inv_Fragment_K_V result
        -> inv_Fragment_K_V result)
end
