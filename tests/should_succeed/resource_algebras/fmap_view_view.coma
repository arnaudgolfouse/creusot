module M_fmap_view_view__qyi16167685763649721615__rel_mono (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option) (f: t_FMap'0) =
    match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
          | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
          | _ -> true
          end
      | C_None -> true
      end
  
  type t_Option'2 = C_None'2 | C_Some'2 t_FMap'0
  
  function and_then_logic (self: t_Option'2) (f: Map.map t_FMap'0 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type t_Option'3 = C_None'3 | C_Some'3 t_Option'0
  
  function and_then_logic'0 (self: t_Option'3) (f: Map.map t_Option'0 t_Option'3) : t_Option'3 = match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'3 = match self with
      | C_None'0 -> C_None'3
      | C_Some'0 x -> C_Some'3 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'3 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'3 other
      | {_p1 = C_None'0} -> C_Some'3 self
      | {_p0 = C_Some'0 x; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. (forall k: t_K. op'0 (get self k) (get other k)
          <> C_None'3) -> (forall k: t_K. C_Some'3 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'2 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'3 then
      C_Some'2 (total_op self other)
    else
      C_None'2
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'1: forall a: t_FMap'0, b: t_FMap'0. op'1 a b = op'1 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'0 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Ag. op factor'0 c <> C_Some'0 self
        end
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'3 = match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x; _p1 = C_None'0} -> C_Some'3 x
      | {_p0 = C_None'0} -> C_None'3
      | {_p0 = C_Some'0 x; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'3 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'3 (C_None'0) else C_None'3
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. match factor'0 self factor'1 with
        | C_Some'3 c -> op'0 factor'1 c = C_Some'3 self
        | C_None'3 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'3 self
        end
  
  predicate incl (self: t_Option'0) (other: t_Option'0) = factor'0 other self <> C_None'3
  
  function incl_transitive (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
  axiom incl_op_spec: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. op'0 self other = C_Some'3 comb
      -> incl self comb
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'0) (a: tuple'0) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap'0) (f: Map.map tuple'0 t_Option'0) : t_FMap'0
  
  axiom filter_map_spec:
    forall self: t_FMap'0, f: Map.map tuple'0 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic f { _p0'0 = k; _p1'0 = v }
          end
  
  function factor'1 (self: t_FMap'0) (factor'2: t_FMap'0) : t_Option'2 =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k; _p1'0 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'3 r -> r
        | C_None'3 -> C_None'0
        end) in C_Some'2 res
    else
      C_None'2
  
  
  axiom factor_spec'1: forall self: t_FMap'0, factor'2: t_FMap'0. match factor'1 self factor'2 with
        | C_Some'2 c -> op'1 factor'2 c = C_Some'2 self
        | C_None'2 -> forall c: t_FMap'0. op'1 factor'2 c <> C_Some'2 self
        end
  
  predicate incl'0 (self: t_FMap'0) (other: t_FMap'0) = factor'1 other self <> C_None'2
  
  function incl_transitive'0 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap'0) (other: t_FMap'0) (comb: t_FMap'0) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap'0, other: t_FMap'0, comb: t_FMap'0. op'1 self other = C_Some'2 comb
      -> incl'0 self comb
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option
  
  constant f1 : t_FMap'0
  
  constant f2 : t_FMap'0
  
  function rel_mono (a'0: t_Option) (f1'0: t_FMap'0) (f2'0: t_FMap'0) : ()
  
  goal vc_rel_mono: rel a f1 -> incl'0 f2 f1 -> ([@expl:rel_mono ensures] rel a f2)
end
module M_fmap_view_view__qyi16167685763649721615__rel_none (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option) (f: t_FMap'0) =
    match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
          | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
          | _ -> true
          end
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option
  
  constant f : t_FMap'0
  
  function rel_none (a'0: t_Option) (f'0: t_FMap'0) : ()
  
  goal vc_rel_none: rel a f -> ([@expl:rel_none ensures] rel (C_None) f)
end
module M_fmap_view_view__qyi16167685763649721615__rel_unit (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option) (f: t_FMap'0) =
    match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
          | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
          | _ -> true
          end
      | C_None -> true
      end
  
  type t_Option'2 = C_None'2 | C_Some'2 t_FMap'0
  
  function and_then_logic (self: t_Option'2) (f: Map.map t_FMap'0 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type t_Option'3 = C_None'3 | C_Some'3 t_Option'0
  
  function and_then_logic'0 (self: t_Option'3) (f: Map.map t_Option'0 t_Option'3) : t_Option'3 = match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'3 = match self with
      | C_None'0 -> C_None'3
      | C_Some'0 x -> C_Some'3 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'3 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'3 other
      | {_p1 = C_None'0} -> C_Some'3 self
      | {_p0 = C_Some'0 x; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. (forall k: t_K. op'0 (get self k) (get other k)
          <> C_None'3) -> (forall k: t_K. C_Some'3 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'2 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'3 then
      C_Some'2 (total_op self other)
    else
      C_None'2
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'1: forall a: t_FMap'0, b: t_FMap'0. op'1 a b = op'1 b a
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. len self >= 0
  
  constant empty : t_FMap'0
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'0)
  
  constant unit': t_FMap'0 = empty
  
  axiom unit_spec: forall x: t_FMap'0 [op'1 x unit']. op'1 x unit' = C_Some'2 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option
  
  function rel_unit (a'0: t_Option) : ()
  
  goal vc_rel_unit: [@expl:rel_unit ensures] rel a unit'
end
module M_fmap_view_view__qyi16747555808275470465__new (* Authority<K, V> *)
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_FMap'0
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_FMap'0 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Ag
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option'1
  
  function and_then_logic'0 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 = match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'0: forall a: t_Option'1, b: t_Option'1. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'1 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. (forall k: t_K. op'0 (get self k) (get other k)
          <> C_None'2) -> (forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'0 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'1: forall a: t_FMap'0, b: t_FMap'0. op'1 a b = op'1 b a
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. len self >= 0
  
  constant empty : t_FMap'0
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'1)
  
  constant unit': t_FMap'0 = empty
  
  axiom unit_spec: forall x: t_FMap'0 [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
        end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 = match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) = factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. op'0 self other = C_Some'2 comb
      -> incl self comb
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap'0) (f: Map.map tuple'0 t_Option'1) : t_FMap'0
  
  axiom filter_map_spec:
    forall self: t_FMap'0, f: Map.map tuple'0 t_Option'1. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'1 -> C_None'1
          | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
          end
  
  function factor'1 (self: t_FMap'0) (factor'2: t_FMap'0) : t_Option'0 =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap'0, factor'2: t_FMap'0. match factor'1 self factor'2 with
        | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
        | C_None'0 -> forall c: t_FMap'0. op'1 factor'2 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_FMap'0) (other: t_FMap'0) = factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap'0) (other: t_FMap'0) (comb: t_FMap'0) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap'0, other: t_FMap'0, comb: t_FMap'0. op'1 self other = C_Some'0 comb
      -> incl'0 self comb
  
  type t_Option'3 = C_None'3 | C_Some'3 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'3
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'3 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option) (f: t_FMap'0) =
    match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
          | C_Some'1 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'3 v
          | _ -> true
          end
      | C_None -> true
      end
  
  function rel_unit (a: t_Option) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_FMap'0) : () = ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_FMap'0. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_FMap'0) (f2: t_FMap'0) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_FMap'0, f2: t_FMap'0. rel a f1 -> incl'0 f2 f1 -> rel a f2
  
  function auth (self: t_View) : t_Option
  
  function frag (self: t_View) : t_FMap'0
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  function new (auth'0: t_Option) (frag'0: t_FMap'0) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_FMap'0. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_FMap'0. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function new_auth [@inline:trivial] (auth'0: t_FMap) : t_View = new (C_Some auth'0) unit'
  
  meta "rewrite_def" function new_auth
  
  function len'0 (self: t_FMap) : int
  
  axiom len_spec'0: forall self: t_FMap. len'0 self >= 0
  
  constant empty'0 : t_FMap
  
  axiom empty_spec'1: len'0 empty'0 = 0
  
  axiom empty_spec'2: view'0 empty'0 = Const.const (C_None'3)
  
  type t_Resource
  
  function val' (self: t_Resource) : t_View
  
  function view'1 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'1
  
  function view'2 [@inline:trivial] (self: t_Resource) : t_View = view'1 self
  
  meta "rewrite_def" function view'2
  
  let rec alloc (r: t_View) (return' (x: t_Resource)) = any
    [ return''0 (result: t_Resource) -> {view'2 result = r} (! return' {result}) ]
  
  let rec into_inner (self: t_Resource) (return' (x: t_Resource)) = any
    [ return''0 (result: t_Resource) -> {result = self} (! return' {result}) ]
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  predicate invariant' (self: t_Authority) = auth (view'1 self.t_Authority__0) <> C_None
  
  predicate inv (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: t_Authority) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  let rec new'0 (x: t_Authority) (return' (x'0: t_Authority)) = {[@expl:new 'x' type invariant] inv x}
    any [ return''0 (result: t_Authority) -> {inv'0 result} {result = x} (! return' {result}) ]
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_FMap bool) (a: t_FMap) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. (exists x: t_FMap. index_logic'0 p x)
      -> index_logic'0 p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_FMap = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_FMap) -> true)
      end
  
  function view'3 (self: t_Authority) : t_FMap = unwrap_logic (auth (view'1 self.t_Authority__0))
  
  function view'4 [@inline:trivial] (self: t_Authority) : t_FMap = view'3 self
  
  meta "rewrite_def" function view'4
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'1 (return' (x: t_Authority)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- new_auth empty'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = alloc {_3} (fun (_ret: t_Resource) -> [ &resource <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_inner {resource} (fun (_ret: t_Resource) -> [ &_6 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_5 <- { t_Authority__0 = _6 } ] s1
      | s1 = new'0 {_5} (fun (_ret: t_Authority) -> [ &_0 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = return''0 {_0} ]
    [ & _0: t_Authority = Any.any_l ()
    | & resource: t_Resource = Any.any_l ()
    | & _3: t_View = Any.any_l ()
    | & _5: t_Authority = Any.any_l ()
    | & _6: t_Resource = Any.any_l () ])
    [ return''0 (result: t_Authority) -> {[@expl:new result type invariant] inv'0 result}
      {[@expl:new ensures] view'4 result = empty'0}
      (! return' {result}) ]
end
module M_fmap_view_view__qyi16747555808275470465__insert (* Authority<K, V> *)
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. view (insert self k v) = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_FMap
  
  predicate index_logic [@inline:trivial] (self: Map.map t_FMap bool) (a: t_FMap) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. (exists x: t_FMap. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option'0) : t_FMap = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_FMap) -> true)
      end
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  function auth (self: t_View) : t_Option'0
  
  function val' (self: t_Resource) : t_View
  
  function view'0 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'0
  
  function view'1 (self: t_Authority) : t_FMap = unwrap_logic (auth (view'0 self.t_Authority__0))
  
  function view'2 [@inline:trivial] (self: MutBorrow.t t_Authority) : t_FMap = view'1 self.current
  
  meta "rewrite_def" function view'2
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_FMap'0
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Ag
  
  function view'3 (self: t_FMap'0) : Map.map t_K t_Option'1
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. len'0 self >= 0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'1 = Map.get (view'3 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) = get'0 self k <> C_None'1
  
  meta "rewrite_def" predicate contains'0
  
  function insert'0 (self: t_FMap'0) (k: t_K) (v: t_Ag) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_K, v: t_Ag. view'3 (insert'0 self k v)
      = Map.set (view'3 self) k (C_Some'1 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_K, v: t_Ag. len'0 (insert'0 self k v)
      = (if contains'0 self k then len'0 self else len'0 self + 1)
  
  constant empty : t_FMap'0
  
  axiom empty_spec: len'0 empty = 0
  
  axiom empty_spec'0: view'3 empty = Const.const (C_None'1)
  
  function singleton (k: t_K) (v: t_Ag) : t_FMap'0 = insert'0 empty k v
  
  type t_ViewUpdateInsert = { t_ViewUpdateInsert__0: t_FMap; t_ViewUpdateInsert__1: t_FMap'0 }
  
  type t_Option'2 = C_None'2 | C_Some'2 t_FMap'0
  
  function and_then_logic (self: t_Option'2) (f: Map.map t_FMap'0 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type t_Option'3 = C_None'3 | C_Some'3 t_Option'1
  
  function and_then_logic'0 (self: t_Option'3) (f: Map.map t_Option'1 t_Option'3) : t_Option'3 = match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'3 = match self with
      | C_None'1 -> C_None'3
      | C_Some'1 x -> C_Some'3 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'3 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'3 other
      | {_p1 = C_None'1} -> C_Some'3 self
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'0: forall a: t_Option'1, b: t_Option'1. op'0 a b = op'0 b a
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. (forall k: t_K. op'0 (get'0 self k) (get'0 other k)
          <> C_None'3)
      -> (forall k: t_K. C_Some'3 (get'0 (total_op self other) k) = op'0 (get'0 self k) (get'0 other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'2 = if forall k: t_K. op'0 (get'0 self k) (get'0 other k)
      <> C_None'3 then
      C_Some'2 (total_op self other)
    else
      C_None'2
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'1: forall a: t_FMap'0, b: t_FMap'0. op'1 a b = op'1 b a
  
  constant unit': t_FMap'0 = empty
  
  axiom unit_spec: forall x: t_FMap'0 [op'1 x unit']. op'1 x unit' = C_Some'2 x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
        end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'3 = match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x; _p1 = C_None'1} -> C_Some'3 x
      | {_p0 = C_None'1} -> C_None'3
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'3 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'3 (C_None'1) else C_None'3
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. match factor'0 self factor'1 with
        | C_Some'3 c -> op'0 factor'1 c = C_Some'3 self
        | C_None'3 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'3 self
        end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) = factor'0 other self <> C_None'3
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. op'0 self other = C_Some'3 comb
      -> incl self comb
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic'0 [@inline:trivial] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function filter_map (self: t_FMap'0) (f: Map.map tuple'0 t_Option'1) : t_FMap'0
  
  axiom filter_map_spec:
    forall self: t_FMap'0, f: Map.map tuple'0 t_Option'1. forall k: t_K [get'0 (filter_map self f) k]. get'0 (filter_map self f) k
        = match get'0 self k with
          | C_None'1 -> C_None'1
          | C_Some'1 v -> index_logic'0 f { _p0'0 = k; _p1'0 = v }
          end
  
  function factor'1 (self: t_FMap'0) (factor'2: t_FMap'0) : t_Option'2 =
    if forall k: t_K. incl (get'0 factor'2 k) (get'0 self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get'0 factor'2 k) with
        | C_Some'3 r -> r
        | C_None'3 -> C_None'1
        end) in C_Some'2 res
    else
      C_None'2
  
  
  axiom factor_spec'1: forall self: t_FMap'0, factor'2: t_FMap'0. match factor'1 self factor'2 with
        | C_Some'2 c -> op'1 factor'2 c = C_Some'2 self
        | C_None'2 -> forall c: t_FMap'0. op'1 factor'2 c <> C_Some'2 self
        end
  
  predicate incl'0 (self: t_FMap'0) (other: t_FMap'0) = factor'1 other self <> C_None'2
  
  function incl_transitive'0 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap'0) (other: t_FMap'0) (comb: t_FMap'0) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap'0, other: t_FMap'0, comb: t_FMap'0. op'1 self other = C_Some'2 comb
      -> incl'0 self comb
  
  predicate rel (a: t_Option'0) (f: t_FMap'0) =
    match a with
      | C_Some'0 a'0 -> forall k: t_K. match get'0 f k with
          | C_Some'1 {t_Ag__0 = v} -> get a'0 k = C_Some v
          | _ -> true
          end
      | C_None'0 -> true
      end
  
  function rel_unit (a: t_Option'0) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option'0. rel a unit'
  
  function rel_none (a: t_Option'0) (f: t_FMap'0) : () = ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_FMap'0. rel a f -> rel (C_None'0) f
  
  function rel_mono (a: t_Option'0) (f1: t_FMap'0) (f2: t_FMap'0) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option'0, f1: t_FMap'0, f2: t_FMap'0. rel a f1 -> incl'0 f2 f1 -> rel a f2
  
  predicate premise (self: t_ViewUpdateInsert) (from: t_View) =
    auth from <> C_None'0
    /\ (forall f: t_FMap'0. rel (auth from) f
      -> match op'1 self.t_ViewUpdateInsert__1 f with
        | C_Some'2 ff -> rel (C_Some'0 (self.t_ViewUpdateInsert__0)) ff
        | C_None'2 -> false
        end)
  
  function view'4 [@inline:trivial] (self: MutBorrow.t t_Resource) : t_View = view'0 self.current
  
  meta "rewrite_def" function view'4
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  function frag (self: t_View) : t_FMap'0
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  function new (auth'0: t_Option'0) (frag'0: t_FMap'0) : t_View
  
  axiom new_spec: forall auth'0: t_Option'0, frag'0: t_FMap'0. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'0, frag'0: t_FMap'0. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function update (self: t_ViewUpdateInsert) (from: t_View) (_2: ()) : t_View =
    new (C_Some'0 (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  axiom update_spec: forall self: t_ViewUpdateInsert, from: t_View, _2: (). premise self from
      -> rel (C_Some'0 (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  let rec update'0 (self: MutBorrow.t t_Resource) (upd: t_ViewUpdateInsert) (return' (x: ())) =
    {[@expl:update requires] premise upd (view'4 self)}
    any
    [ return''0 (result: ()) -> {id self.final = id self.current}
      {view'0 self.final = update upd (view'4 self) result}
      (! return' {result}) ]
  
  function new_frag [@inline:trivial] (frag'0: t_FMap'0) : t_View = new (C_None'0) frag'0
  
  meta "rewrite_def" function new_frag
  
  function new_auth [@inline:trivial] (auth'0: t_FMap) : t_View = new (C_Some'0 auth'0) unit'
  
  meta "rewrite_def" function new_auth
  
  type t_Option'4 = C_None'4 | C_Some'4 t_View
  
  function and_then_logic'2 (self: t_Option'4) (f: Map.map t_View t_Option'4) : t_Option'4 = match self with
      | C_None'4 -> C_None'4
      | C_Some'4 x -> Map.get f x
      end
  
  type tuple'1 = { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 (self: t_View) (other: t_View) : t_Option'4 = match op'1 (frag self) (frag other) with
      | C_Some'2 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'0; _p1'1 = a} -> if rel a f then C_Some'4 (new a f) else C_None'4
        | {_p0'1 = a; _p1'1 = C_None'0} -> if rel a f then C_Some'4 (new a f) else C_None'4
        | _ -> C_None'4
        end
      | C_None'2 -> C_None'4
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2:
    forall a: t_View, b: t_View, c: t_View. and_then_logic'2 (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
      = and_then_logic'2 (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. op'2 a b = op'2 b a
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option'4 = match factor'1 (frag self) (frag factor'3) with
      | C_Some'2 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'0 a; _p1'1 = C_None'0} -> C_Some'4 (new (C_Some'0 a) f)
        | {_p0'1 = a1; _p1'1 = a2} -> if a1 = a2 then C_Some'4 (new_frag f) else C_None'4
        end
      | C_None'2 -> C_None'4
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. match factor'2 self factor'3 with
        | C_Some'4 c -> op'2 factor'3 c = C_Some'4 self
        | C_None'4 -> forall c: t_View. op'2 factor'3 c <> C_Some'4 self
        end
  
  predicate incl'1 (self: t_View) (other: t_View) = factor'2 other self <> C_None'4
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. incl'1 a b -> incl'1 b c -> incl'1 a c
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. op'2 self other = C_Some'4 comb
      -> incl'1 self comb
  
  predicate incl_eq (self: t_View) (other: t_View) = self = other \/ incl'1 self other
  
  predicate incl_eq_op (a: t_View) (b: t_View) (x: t_View) =
    match op'2 a b with
      | C_None'4 -> false
      | C_Some'4 ab -> incl_eq ab x
      end
  
  let rec split_off (self: MutBorrow.t t_Resource) (r: t_View) (s: t_View) (return' (x: t_Resource)) =
    {[@expl:split_off requires] incl_eq_op r s (view'4 self)}
    any
    [ return''0 (result: t_Resource) -> {id self.final = id self.current /\ id result = id self.current}
      {view'0 self.final = s}
      {view'0 result = r}
      (! return' {result}) ]
  
  predicate invariant' (self: t_Authority) = auth (view'0 self.t_Authority__0) <> C_None'0
  
  predicate inv (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Authority) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Authority) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Authority) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  predicate invariant''1 (self: t_Fragment) =
    incl'1 (new_frag (singleton self.t_Fragment__1 { t_Ag__0 = self.t_Fragment__2 })) (view'0 self.t_Fragment__0)
  
  predicate inv'1 (_0: t_Fragment)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x
      = (invariant''1 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  function id'0 (self: t_Authority) : t_Id = id self.t_Authority__0
  
  type tuple'2 = { _p0'2: t_K; _p1'2: t_V }
  
  function view'5 (self: t_Fragment) : tuple'2 = { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function id'1 (self: t_Fragment) : t_Id = id self.t_Fragment__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert'1 (self: MutBorrow.t t_Authority) (k: t_K) (v: t_V) (return' (x: t_Fragment)) =
    {[@expl:insert 'self' type invariant] inv'0 self}
    {[@expl:insert requires] not contains (view'2 self) k}
    (! bb0
    [ bb0 = s0 [ s0 = [ &auth'0 <- insert (view'2 self'0) k'0 v'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &frag'0 <- singleton k'0 { t_Ag__0 = v'0 } ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_15 <- { t_ViewUpdateInsert__0 = auth'0; t_ViewUpdateInsert__1 = frag'0 } ] s1
      | s1 = MutBorrow.borrow_mut <t_Resource> {(self'0.current).t_Authority__0}
          (fun (_ret: MutBorrow.t t_Resource) ->
            [ &_14 <- _ret ] [ &self'0 <- { self'0 with current = { t_Authority__0 = _ret.final } } ] s2)
      | s2 = update'0 {_14} {_15} (fun (_ret: ()) -> [ &_13 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0 [ s0 = [ &_20 <- new_frag frag'0 ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = [ &_22 <- new_auth auth'0 ] s1 | s1 = bb5 ]
    | bb5 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource> {(self'0.current).t_Authority__0}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret: MutBorrow.t t_Resource) ->
            [ &_19 <- _ret ] [ &self'0 <- { self'0 with current = { t_Authority__0 = _ret.final } } ] s1)
      | s1 = split_off {_19} {_20} {_22} (fun (_ret: t_Resource) -> [ &_18 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 = [ &_24 <- k'0 ] s3
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = [ &_26 <- v'0 ] s1 | s1 = bb8 ]
    | bb8 = s0
      [ s0 = [ &_0 <- { t_Fragment__0 = _18; t_Fragment__1 = _24; t_Fragment__2 = _26 } ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: t_Fragment = Any.any_l ()
    | & self'0: MutBorrow.t t_Authority = self
    | & k'0: t_K = k
    | & v'0: t_V = v
    | & auth'0: t_FMap = Any.any_l ()
    | & frag'0: t_FMap'0 = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & _14: MutBorrow.t t_Resource = Any.any_l ()
    | & _15: t_ViewUpdateInsert = Any.any_l ()
    | & _18: t_Resource = Any.any_l ()
    | & _19: MutBorrow.t t_Resource = Any.any_l ()
    | & _20: t_View = Any.any_l ()
    | & _22: t_View = Any.any_l ()
    | & _24: t_K = Any.any_l ()
    | & _26: t_V = Any.any_l () ])
    [ return''0 (result: t_Fragment) -> {[@expl:insert result type invariant] inv'1 result}
      {[@expl:insert ensures #0] view'1 self.final = insert (view'2 self) k v}
      {[@expl:insert ensures #1] id'0 self.final = id'0 self.current}
      {[@expl:insert ensures #2] view'5 result = { _p0'2 = k; _p1'2 = v }}
      {[@expl:insert ensures #3] id'1 result = id'0 self.current}
      (! return' {result}) ]
end
module M_fmap_view_view__qyi16747555808275470465__contains (* Authority<K, V> *)
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0 = C_None'0 | C_Some'0 t_FMap
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Ag
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 = match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'0: forall a: t_Option'1, b: t_Option'1. op'0 a b = op'0 b a
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'2)
      -> (forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  type t_FMap'0
  
  type t_Option'3 = C_None'3 | C_Some'3 t_FMap'0
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = empty
  
  axiom unit_spec: forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
        end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 = match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) = factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. op'0 self other = C_Some'2 comb
      -> incl self comb
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option'1. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'1 -> C_None'1
          | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
        | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some'0 comb
      -> incl'0 self comb
  
  type t_Option'4 = C_None'4 | C_Some'4 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'4
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'4 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option'3) (f: t_FMap) =
    match a with
      | C_Some'3 a'0 -> forall k: t_K. match get f k with
          | C_Some'1 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'4 v
          | _ -> true
          end
      | C_None'3 -> true
      end
  
  function rel_unit (a: t_Option'3) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option'3. rel a unit'
  
  function rel_none (a: t_Option'3) (f: t_FMap) : () = ()
  
  axiom rel_none_spec: forall a: t_Option'3, f: t_FMap. rel a f -> rel (C_None'3) f
  
  function rel_mono (a: t_Option'3) (f1: t_FMap) (f2: t_FMap) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option'3, f1: t_FMap, f2: t_FMap. rel a f1 -> incl'0 f2 f1 -> rel a f2
  
  function auth (self: t_View) : t_Option'3
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'1 = { _p0'1: t_Option'3; _p1'1: t_Option'3 }
  
  function new (auth'0: t_Option'3) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option'3, frag'0: t_FMap. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'3, frag'0: t_FMap. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'2 (self: t_View) (other: t_View) : t_Option = match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'3; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a; _p1'1 = C_None'3} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. op'2 a b = op'2 b a
  
  function new_frag [@inline:trivial] (frag'0: t_FMap) : t_View = new (C_None'3) frag'0
  
  meta "rewrite_def" function new_frag
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option = match factor'1 (frag self) (frag factor'3) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'3 a; _p1'1 = C_None'3} -> C_Some (new (C_Some'3 a) f)
        | {_p0'1 = a1; _p1'1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. match factor'2 self factor'3 with
        | C_Some c -> op'2 factor'3 c = C_Some self
        | C_None -> forall c: t_View. op'2 factor'3 c <> C_Some self
        end
  
  predicate incl'1 (self: t_View) (other: t_View) = factor'2 other self <> C_None
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. incl'1 a b -> incl'1 b c -> incl'1 a c
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. op'2 self other = C_Some comb
      -> incl'1 self comb
  
  predicate incl_eq (self: t_View) (other: t_View) = self = other \/ incl'1 self other
  
  function val' (self: t_Resource) : t_View
  
  function view'1 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'1
  
  function view'2 [@inline:trivial] (self: t_Resource) : t_View = view'1 self
  
  meta "rewrite_def" function view'2
  
  let rec join_shared (self: t_Resource) (other: t_Resource) (return' (x: t_Resource)) =
    {[@expl:join_shared requires] id self = id other}
    any
    [ return''0 (result: t_Resource) -> {id result = id self}
      {incl_eq (view'2 self) (view'2 result) /\ incl_eq (view'2 other) (view'2 result)}
      (! return' {result}) ]
  
  type tuple'2 = { _p0'2: t_K; _p1'2: t_V }
  
  function view'3 (self: t_Fragment) : tuple'2 = { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function view'4 [@inline:trivial] (self: t_Fragment) : tuple'2 = view'3 self
  
  meta "rewrite_def" function view'4
  
  predicate invariant' (self: t_Authority) = auth (view'1 self.t_Authority__0) <> C_None'3
  
  predicate inv (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Authority__0 = a_0} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: t_Authority) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None'1
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: t_K) (v: t_Ag) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_Ag. view (insert self k v) = Map.set (view self) k (C_Some'1 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_Ag. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function singleton (k: t_K) (v: t_Ag) : t_FMap = insert empty k v
  
  predicate invariant''1 (self: t_Fragment) =
    incl'1 (new_frag (singleton self.t_Fragment__1 { t_Ag__0 = self.t_Fragment__2 })) (view'1 self.t_Fragment__0)
  
  predicate inv'1 (_0: t_Fragment)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x
      = (invariant''1 x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''2 [@inline:trivial] (self: t_Fragment) = inv'1 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 (_0: t_Fragment)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Fragment [inv'2 x]. inv'2 x = invariant''2 x
  
  function id'0 (self: t_Authority) : t_Id = id self.t_Authority__0
  
  function id'1 (self: t_Fragment) : t_Id = id self.t_Fragment__0
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_FMap'0 bool) (a: t_FMap'0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_FMap'0 bool) : t_FMap'0
  
  axiom such_that_spec: forall p: Map.map t_FMap'0 bool. (exists x: t_FMap'0. index_logic'0 p x)
      -> index_logic'0 p (such_that p)
  
  function unwrap_logic (self: t_Option'3) : t_FMap'0 = match self with
      | C_Some'3 x -> x
      | C_None'3 -> such_that (fun (__0: t_FMap'0) -> true)
      end
  
  function view'5 (self: t_Authority) : t_FMap'0 = unwrap_logic (auth (view'1 self.t_Authority__0))
  
  function view'6 [@inline:trivial] (self: t_Authority) : t_FMap'0 = view'5 self
  
  meta "rewrite_def" function view'6
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains'0 (self: t_Authority) (frag'0: t_Fragment) (return' (x: ())) =
    {[@expl:contains 'self' type invariant] inv'0 self}
    {[@expl:contains 'frag' type invariant] inv'2 frag'0}
    {[@expl:contains requires] id'0 self = id'1 frag'0}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- frag'1.t_Fragment__0 ] s1
      | s1 = join_shared {self'0.t_Authority__0} {_8} (fun (_ret: t_Resource) -> [ &new_resource <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] get (frag (view'2 new_resource)) (view'4 frag'1)._p0'2
        = C_Some'1 { t_Ag__0 = (view'4 frag'1)._p1'2 }}
        s1
      | s1 = return''0 {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self'0: t_Authority = self
    | & frag'1: t_Fragment = frag'0
    | & new_resource: t_Resource = Any.any_l ()
    | & _8: t_Resource = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:contains ensures] get'0 (view'6 self) (view'4 frag'0)._p0'2
      = C_Some'4 ((view'4 frag'0)._p1'2)}
      (! return' {result}) ]
end
module M_fmap_view_view__qyi9127813262067876198__clone (* <Fragment<K, V> as creusot_contracts::Clone> *)
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0 = C_None'0 | C_Some'0 t_FMap
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Ag
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 = match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'0: forall a: t_Option'1, b: t_Option'1. op'0 a b = op'0 b a
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'2)
      -> (forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  type t_FMap'0
  
  type t_Option'3 = C_None'3 | C_Some'3 t_FMap'0
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = empty
  
  axiom unit_spec: forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
        end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 = match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) = factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. op'0 self other = C_Some'2 comb
      -> incl self comb
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option'1. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'1 -> C_None'1
          | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
        | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some'0 comb
      -> incl'0 self comb
  
  type t_Option'4 = C_None'4 | C_Some'4 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'4
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'4 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option'3) (f: t_FMap) =
    match a with
      | C_Some'3 a'0 -> forall k: t_K. match get f k with
          | C_Some'1 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'4 v
          | _ -> true
          end
      | C_None'3 -> true
      end
  
  function rel_unit (a: t_Option'3) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option'3. rel a unit'
  
  function rel_none (a: t_Option'3) (f: t_FMap) : () = ()
  
  axiom rel_none_spec: forall a: t_Option'3, f: t_FMap. rel a f -> rel (C_None'3) f
  
  function rel_mono (a: t_Option'3) (f1: t_FMap) (f2: t_FMap) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option'3, f1: t_FMap, f2: t_FMap. rel a f1 -> incl'0 f2 f1 -> rel a f2
  
  function auth (self: t_View) : t_Option'3
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'1 = { _p0'1: t_Option'3; _p1'1: t_Option'3 }
  
  function new (auth'0: t_Option'3) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option'3, frag'0: t_FMap. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'3, frag'0: t_FMap. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'2 (self: t_View) (other: t_View) : t_Option = match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'3; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a; _p1'1 = C_None'3} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. op'2 a b = op'2 b a
  
  function new_frag [@inline:trivial] (frag'0: t_FMap) : t_View = new (C_None'3) frag'0
  
  meta "rewrite_def" function new_frag
  
  function core (self: t_Ag) : t_Option'1 = C_Some'1 self
  
  axiom core_spec: forall self: t_Ag. match core self with
        | C_Some'1 c -> op c c = C_Some'1 c /\ op c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  function core_total (self: t_FMap) : t_FMap =
    let r = filter_map self (fun (__0: tuple'0) -> let {_p1'0 = v} = __0 in core v) in r
  
  axiom core_total_spec: forall self: t_FMap. op'1 (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. op'1 (core_total self) self = C_Some'0 self
  
  function core_total'0 (self: t_View) : t_View = new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. op'2 (core_total'0 self) (core_total'0 self)
      = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. op'2 (core_total'0 self) self = C_Some self
  
  function core'0 (self: t_View) : t_Option = C_Some (core_total'0 self)
  
  axiom core_spec'0: forall self: t_View. match core'0 self with
        | C_Some c -> op'2 c c = C_Some c /\ op'2 c self = C_Some self
        | C_None -> true
        end
  
  function val' (self: t_Resource) : t_View
  
  function view'1 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'1
  
  function view'2 [@inline:trivial] (self: t_Resource) : t_View = view'1 self
  
  meta "rewrite_def" function view'2
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  let rec core'1 (self: t_Resource) (return' (x: t_Resource)) = {[@expl:core requires] core'0 (view'2 self) <> C_None}
    any
    [ return''0 (result: t_Resource) -> {id result = id self}
      {C_Some (view'1 result) = core'0 (view'2 self)}
      (! return' {result}) ]
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option = match factor'1 (frag self) (frag factor'3) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'3 a; _p1'1 = C_None'3} -> C_Some (new (C_Some'3 a) f)
        | {_p0'1 = a1; _p1'1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. match factor'2 self factor'3 with
        | C_Some c -> op'2 factor'3 c = C_Some self
        | C_None -> forall c: t_View. op'2 factor'3 c <> C_Some self
        end
  
  predicate incl'1 (self: t_View) (other: t_View) = factor'2 other self <> C_None
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. incl'1 a b -> incl'1 b c -> incl'1 a c
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. op'2 self other = C_Some comb
      -> incl'1 self comb
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None'1
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: t_K) (v: t_Ag) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_Ag. view (insert self k v) = Map.set (view self) k (C_Some'1 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_Ag. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function singleton (k: t_K) (v: t_Ag) : t_FMap = insert empty k v
  
  predicate invariant' (self: t_Fragment) =
    incl'1 (new_frag (singleton self.t_Fragment__1 { t_Ag__0 = self.t_Fragment__2 })) (view'1 self.t_Fragment__0)
  
  predicate inv (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: t_Fragment) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''0 x
  
  type tuple'2 = { _p0'2: t_K; _p1'2: t_V }
  
  function view'3 (self: t_Fragment) : tuple'2 = { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function view'4 [@inline:trivial] (self: t_Fragment) : tuple'2 = view'3 self
  
  meta "rewrite_def" function view'4
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: t_Fragment) (return' (x: t_Fragment)) = {[@expl:clone 'self' type invariant] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = core'1 {self'0.t_Fragment__0} (fun (_ret: t_Resource) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_0 <- { t_Fragment__0 = _3;
                        t_Fragment__1 = self'0.t_Fragment__1;
                        t_Fragment__2 = self'0.t_Fragment__2 } ] s1
      | s1 = return''0 {_0} ] ]
    [ & _0: t_Fragment = Any.any_l () | & self'0: t_Fragment = self | & _3: t_Resource = Any.any_l () ])
    [ return''0 (result: t_Fragment) -> {[@expl:clone result type invariant] inv result}
      {[@expl:clone ensures] view'3 result = view'4 self}
      (! return' {result}) ]
end
module M_fmap_view_view__qyi16167685763649721615__rel_mono__refines (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Ag
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'0 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Ag. op factor'0 c <> C_Some'0 self
        end
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1 = match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x; _p1 = C_None'0} -> C_Some'1 x
      | {_p0 = C_None'0} -> C_None'1
      | {_p0 = C_Some'0 x; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl (self: t_Option'0) (other: t_Option'0) = factor'0 other self <> C_None'1
  
  function incl_transitive (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
  axiom incl_op_spec: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. op'0 self other = C_Some'1 comb
      -> incl self comb
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'0) (a: tuple'0) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic f { _p0'0 = k; _p1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k; _p1'0 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some comb
      -> incl'0 self comb
  
  type t_FMap'0
  
  type t_Option'2 = C_None'2 | C_Some'2 t_FMap'0
  
  type t_Option'3 = C_None'3 | C_Some'3 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'3
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'3 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option'2) (f: t_FMap) =
    match a with
      | C_Some'2 a'0 -> forall k: t_K. match get f k with
          | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'3 v
          | _ -> true
          end
      | C_None'2 -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option'2. forall f1: t_FMap. forall f2: t_FMap. incl'0 f2 f1 /\ rel a f1
          -> incl'0 f2 f1 /\ rel a f1 /\ (forall result: (). rel a f2 -> rel a f2)
end
module M_fmap_view_view__qyi16167685763649721615__rel_unit__refines (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option) (f: t_FMap'0) =
    match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
          | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
          | _ -> true
          end
      | C_None -> true
      end
  
  type t_Option'2 = C_None'2 | C_Some'2 t_FMap'0
  
  function and_then_logic (self: t_Option'2) (f: Map.map t_FMap'0 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type t_Option'3 = C_None'3 | C_Some'3 t_Option'0
  
  function and_then_logic'0 (self: t_Option'3) (f: Map.map t_Option'0 t_Option'3) : t_Option'3 = match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'3 = match self with
      | C_None'0 -> C_None'3
      | C_Some'0 x -> C_Some'3 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'3 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'3 other
      | {_p1 = C_None'0} -> C_Some'3 self
      | {_p0 = C_Some'0 x; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. (forall k: t_K. op'0 (get self k) (get other k)
          <> C_None'3) -> (forall k: t_K. C_Some'3 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'2 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'3 then
      C_Some'2 (total_op self other)
    else
      C_None'2
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'1: forall a: t_FMap'0, b: t_FMap'0. op'1 a b = op'1 b a
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. len self >= 0
  
  constant empty : t_FMap'0
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'0)
  
  constant unit': t_FMap'0 = empty
  
  axiom unit_spec: forall x: t_FMap'0 [op'1 x unit']. op'1 x unit' = C_Some'2 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option. forall result: (). rel a unit' -> rel a unit'
end
module M_fmap_view_view__qyi16167685763649721615__rel_none__refines (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option) (f: t_FMap'0) =
    match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
          | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
          | _ -> true
          end
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option. forall f: t_FMap'0. rel a f
        -> rel a f /\ (forall result: (). rel (C_None) f -> rel (C_None) f)
end
module M_fmap_view_view__qyi9127813262067876198__clone__refines (* <Fragment<K, V> as creusot_contracts::Clone> *)
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0 = C_None'0 | C_Some'0 t_FMap
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Ag
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple = { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 = match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 = match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'0: forall a: t_Option'1, b: t_Option'1. op'0 a b = op'0 b a
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'2)
      -> (forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  type t_FMap'0
  
  type t_Option'3 = C_None'3 | C_Some'3 t_FMap'0
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = empty
  
  axiom unit_spec: forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
        end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 = match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) = factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. op'0 self other = C_Some'2 comb
      -> incl self comb
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option'1. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'1 -> C_None'1
          | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
        | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some'0 comb
      -> incl'0 self comb
  
  type t_Option'4 = C_None'4 | C_Some'4 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'4
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'4 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate rel (a: t_Option'3) (f: t_FMap) =
    match a with
      | C_Some'3 a'0 -> forall k: t_K. match get f k with
          | C_Some'1 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'4 v
          | _ -> true
          end
      | C_None'3 -> true
      end
  
  function rel_unit (a: t_Option'3) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option'3. rel a unit'
  
  function rel_none (a: t_Option'3) (f: t_FMap) : () = ()
  
  axiom rel_none_spec: forall a: t_Option'3, f: t_FMap. rel a f -> rel (C_None'3) f
  
  function rel_mono (a: t_Option'3) (f1: t_FMap) (f2: t_FMap) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option'3, f1: t_FMap, f2: t_FMap. rel a f1 -> incl'0 f2 f1 -> rel a f2
  
  function auth (self: t_View) : t_Option'3
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'1 = { _p0'1: t_Option'3; _p1'1: t_Option'3 }
  
  function new (auth'0: t_Option'3) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option'3, frag'0: t_FMap. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'3, frag'0: t_FMap. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'2 (self: t_View) (other: t_View) : t_Option = match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'3; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a; _p1'1 = C_None'3} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. op'2 a b = op'2 b a
  
  function new_frag [@inline:trivial] (frag'0: t_FMap) : t_View = new (C_None'3) frag'0
  
  meta "rewrite_def" function new_frag
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option = match factor'1 (frag self) (frag factor'3) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'3 a; _p1'1 = C_None'3} -> C_Some (new (C_Some'3 a) f)
        | {_p0'1 = a1; _p1'1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. match factor'2 self factor'3 with
        | C_Some c -> op'2 factor'3 c = C_Some self
        | C_None -> forall c: t_View. op'2 factor'3 c <> C_Some self
        end
  
  predicate incl'1 (self: t_View) (other: t_View) = factor'2 other self <> C_None
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. incl'1 a b -> incl'1 b c -> incl'1 a c
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. op'2 self other = C_Some comb
      -> incl'1 self comb
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None'1
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: t_K) (v: t_Ag) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_Ag. view (insert self k v) = Map.set (view self) k (C_Some'1 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_Ag. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function singleton (k: t_K) (v: t_Ag) : t_FMap = insert empty k v
  
  function val' (self: t_Resource) : t_View
  
  function view'1 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'1
  
  predicate invariant' (self: t_Fragment) =
    incl'1 (new_frag (singleton self.t_Fragment__1 { t_Ag__0 = self.t_Fragment__2 })) (view'1 self.t_Fragment__0)
  
  predicate inv (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_Fragment__0 = a_0; t_Fragment__1 = a_1; t_Fragment__2 = a_2} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: t_Fragment) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''0 x
  
  type tuple'2 = { _p0'2: t_K; _p1'2: t_V }
  
  function view'2 (self: t_Fragment) : tuple'2 = { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function view'3 [@inline:trivial] (self: t_Fragment) : tuple'2 = view'2 self
  
  meta "rewrite_def" function view'3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Fragment. inv'0 self_
      -> inv'0 self_ /\ (forall result: t_Fragment. view'2 result = view'3 self_ /\ inv result -> inv result)
end
