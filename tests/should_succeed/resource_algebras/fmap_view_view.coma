module M_fmap_view_view__qyi16167685763649721615__rel_mono [#"fmap_view_view.rs" 43 4 43 70] (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 40 15 40 31
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 41 15 41 26
  let%span sfmap_view_view'1 = "fmap_view_view.rs" 42 14 42 30
  let%span sfmap_view_view'2 = "fmap_view_view.rs" 43 71 43 73
  let%span sfmap_view_view'3 = "fmap_view_view.rs" 29 12 35 13
  let%span sra = "../../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 240 14 243 5
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'1 = "../../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'2 = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'3 = "../../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span soption'4 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'5 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'2 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 =
    [%#sfmap] Map.get (view self) k
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 =
    [%#sfmap] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option) (f: t_FMap'0) =
    [%#sfmap_view_view'3] match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
        | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
        | _ -> true
        end
      | C_None -> true
      end
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_FMap'0
  
  function and_then_logic (self: t_Option'2) (f: Map.map t_FMap'0 t_Option'2) : t_Option'2 =
    [%#soption] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Option'0
  
  function and_then_logic'0 (self: t_Option'3) (f: Map.map t_Option'0 t_Option'3) : t_Option'3 =
    [%#soption] match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'3 =
    [%#soption'5] match self with
      | C_None'0 -> C_None'3
      | C_Some'0 x -> C_Some'3 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'3 =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'3 other
      | {_p1 = C_None'0} -> C_Some'3 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'4] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. ([%#sfmap'6] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'3)  -> ([%#sfmap'7] forall k: t_K. C_Some'3 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'2 =
    [%#sfmap'4] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'3 then
      C_Some'2 (total_op self other)
    else
      C_None'2
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'1] and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'0: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'0] op'1 a b = op'1 b a
  
  function commutative'1 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'1: forall a: t_Option'0, b: t_Option'0. [%#soption'3] op'0 a b = op'0 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'0 =
    [%#sagree'0] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Ag. op factor'0 c <> C_Some'0 self
    end
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'3 =
    [%#soption'1] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'0} -> C_Some'3 x
      | {_p0 = C_None'0} -> C_None'3
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'3 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'3 (C_None'0) else C_None'3
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. [%#soption'0] match factor'0 self factor'1 with
    | C_Some'3 c -> op'0 factor'1 c = C_Some'3 self
    | C_None'3 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'3 self
    end
  
  predicate incl (self: t_Option'0) (other: t_Option'0) =
    [%#sra] factor'0 other self <> C_None'3
  
  function incl_transitive (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
  axiom incl_op_spec: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. ([%#sra'0] op'0 self other
  = C_Some'3 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic (self: Map.map tuple'0 t_Option'0) (a: tuple'0) : t_Option'0 =
    [%#smapping] Map.get self a
  
  function filter_map (self: t_FMap'0) (f: Map.map tuple'0 t_Option'0) : t_FMap'0
  
  axiom filter_map_spec: forall self: t_FMap'0, f: Map.map tuple'0 t_Option'0. [%#sfmap'5] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 (self: t_FMap'0) (factor'2: t_FMap'0) : t_Option'2 =
    [%#sfmap'3] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'3 r -> r
        | C_None'3 -> C_None'0
        end) in let _ = let _ = () in () in C_Some'2 res
    else
      C_None'2
  
  
  axiom factor_spec'1: forall self: t_FMap'0, factor'2: t_FMap'0. [%#sfmap'2] match factor'1 self factor'2 with
    | C_Some'2 c -> op'1 factor'2 c = C_Some'2 self
    | C_None'2 -> forall c: t_FMap'0. op'1 factor'2 c <> C_Some'2 self
    end
  
  predicate incl'0 (self: t_FMap'0) (other: t_FMap'0) =
    [%#sra] factor'1 other self <> C_None'2
  
  function incl_transitive'0 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 (self: t_FMap'0) (other: t_FMap'0) (comb: t_FMap'0) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap'0, other: t_FMap'0, comb: t_FMap'0. ([%#sra'0] op'1 self other
  = C_Some'2 comb)  -> ([%#sra'1] incl'0 self comb)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Option
  
  constant f1  : t_FMap'0
  
  constant f2  : t_FMap'0
  
  function rel_mono [#"fmap_view_view.rs" 43 4 43 70] (a'0: t_Option) (f1'0: t_FMap'0) (f2'0: t_FMap'0) : ()
  
  goal vc_rel_mono: ([%#sfmap_view_view] rel a f1)
   -> ([%#sfmap_view_view'0] incl'0 f2 f1)  -> ([@expl:rel_mono ensures] [%#sfmap_view_view'1] rel a f2)
end
module M_fmap_view_view__qyi16167685763649721615__rel_none [#"fmap_view_view.rs" 48 4 48 53] (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 46 15 46 30
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 47 14 47 32
  let%span sfmap_view_view'1 = "fmap_view_view.rs" 48 54 48 56
  let%span sfmap_view_view'2 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 =
    [%#sfmap] Map.get (view self) k
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 =
    [%#sfmap] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option) (f: t_FMap'0) =
    [%#sfmap_view_view'2] match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
        | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
        | _ -> true
        end
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Option
  
  constant f  : t_FMap'0
  
  function rel_none [#"fmap_view_view.rs" 48 4 48 53] (a'0: t_Option) (f'0: t_FMap'0) : ()
  
  goal vc_rel_none: ([%#sfmap_view_view] rel a f)  -> ([@expl:rel_none ensures] [%#sfmap_view_view'0] rel (C_None) f)
end
module M_fmap_view_view__qyi16167685763649721615__rel_unit [#"fmap_view_view.rs" 52 4 52 38] (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 51 14 51 46
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 52 39 52 41
  let%span sfmap_view_view'1 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap = "../../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span soption = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'1 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 =
    [%#sfmap'1] Map.get (view self) k
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 =
    [%#sfmap'1] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option) (f: t_FMap'0) =
    [%#sfmap_view_view'1] match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
        | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
        | _ -> true
        end
      | C_None -> true
      end
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_FMap'0
  
  function and_then_logic (self: t_Option'2) (f: Map.map t_FMap'0 t_Option'2) : t_Option'2 =
    [%#soption'0] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Option'0
  
  function and_then_logic'0 (self: t_Option'3) (f: Map.map t_Option'0 t_Option'3) : t_Option'3 =
    [%#soption'0] match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'3 =
    [%#soption'2] match self with
      | C_None'0 -> C_None'3
      | C_Some'0 x -> C_Some'3 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 =
    [%#sagree] if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'1] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'0] op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'3 =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'3 other
      | {_p1 = C_None'0} -> C_Some'3 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. ([%#sfmap'7] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'3)  -> ([%#sfmap'8] forall k: t_K. C_Some'3 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'2 =
    [%#sfmap'2] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'3 then
      C_Some'2 (total_op self other)
    else
      C_None'2
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'6] and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'0: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'5] op'1 a b = op'1 b a
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. [%#sfmap'9] len self >= 0
  
  constant empty  : t_FMap'0
  
  axiom empty_spec: [%#sfmap'3] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'4] view empty = Const.const (C_None'0)
  
  constant unit': t_FMap'0 = [%#sfmap'0] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap] forall x: t_FMap'0 [op'1 x unit']. op'1 x unit' = C_Some'2 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Option
  
  function rel_unit [#"fmap_view_view.rs" 52 4 52 38] (a'0: t_Option) : ()
  
  goal vc_rel_unit: [@expl:rel_unit ensures] [%#sfmap_view_view] rel a unit'
end
module M_fmap_view_view__qyi16747555808275470465__new [#"fmap_view_view.rs" 112 4 112 31] (* Authority<K, V> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 113 39 113 81
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 112 20 112 31
  let%span sfmap_view_view'1 = "fmap_view_view.rs" 111 14 111 38
  let%span sfmap_view_view'2 = "fmap_view_view.rs" 89 20 89 49
  let%span sfmap_view_view'3 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap_view_view'4 = "fmap_view_view.rs" 40 15 40 31
  let%span sfmap_view_view'5 = "fmap_view_view.rs" 41 15 41 26
  let%span sfmap_view_view'6 = "fmap_view_view.rs" 42 14 42 30
  let%span sfmap_view_view'7 = "fmap_view_view.rs" 43 71 43 73
  let%span sfmap_view_view'8 = "fmap_view_view.rs" 46 15 46 30
  let%span sfmap_view_view'9 = "fmap_view_view.rs" 47 14 47 32
  let%span sfmap_view_view'10 = "fmap_view_view.rs" 48 54 48 56
  let%span sfmap_view_view'11 = "fmap_view_view.rs" 51 14 51 46
  let%span sfmap_view_view'12 = "fmap_view_view.rs" 52 39 52 41
  let%span sfmap_view_view'13 = "fmap_view_view.rs" 71 20 71 42
  let%span sra = "../../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 240 14 243 5
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'3 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'4 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'5 = "../../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'6 = "../../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'7 = "../../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sagree'2 = "../../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'3 = "../../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sview = "../../../creusot-contracts/src/logic/ra/view.rs" 104 8 104 46
  let%span sview'0 = "../../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'1 = "../../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'2 = "../../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'3 = "../../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sresource = "../../../creusot-contracts/src/resource.rs" 87 18 87 31
  let%span sresource'0 = "../../../creusot-contracts/src/resource.rs" 48 12 48 22
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 181 14 181 29
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'1 = "../../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'2 = "../../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'3 = "../../../creusot-contracts/src/ghost.rs" 89 8 89 22
  let%span sghost'4 = "../../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sutil = "../../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../../creusot-contracts/src/util.rs" 12 0 12 21
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap'0
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_FMap'0 t_Option'0) : t_Option'0 =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Ag
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Option'1
  
  function and_then_logic'0 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 =
    [%#soption'4] match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 =
    [%#sagree] if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'1] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'0] op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'3] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'1 =
    [%#sfmap'5] Map.get (view self) k
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. ([%#sfmap'8] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'2)  -> ([%#sfmap'9] forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'0 =
    [%#sfmap'4] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'7] and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'0: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'6] op'1 a b = op'1 b a
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. [%#sfmap'3] len self >= 0
  
  constant empty  : t_FMap'0
  
  axiom empty_spec: [%#sfmap] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'0] view empty = Const.const (C_None'1)
  
  constant unit': t_FMap'0 = [%#sfmap'2] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'1] forall x: t_FMap'0 [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function commutative'1 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'1: forall a: t_Option'1, b: t_Option'1. [%#soption'7] op'0 a b = op'0 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 =
    [%#sagree'3] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'2] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
    end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 =
    [%#soption'6] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. [%#soption'5] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) =
    [%#sra] factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. ([%#sra'0] op'0 self other
  = C_Some'2 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 =
    [%#smapping] Map.get self a
  
  function filter_map (self: t_FMap'0) (f: Map.map tuple'0 t_Option'1) : t_FMap'0
  
  axiom filter_map_spec: forall self: t_FMap'0, f: Map.map tuple'0 t_Option'1. [%#sfmap'12] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'1 -> C_None'1
    | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 (self: t_FMap'0) (factor'2: t_FMap'0) : t_Option'0 =
    [%#sfmap'11] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in let _ = let _ = () in () in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap'0, factor'2: t_FMap'0. [%#sfmap'10] match factor'1 self factor'2 with
    | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
    | C_None'0 -> forall c: t_FMap'0. op'1 factor'2 c <> C_Some'0 self
    end
  
  predicate incl'0 (self: t_FMap'0) (other: t_FMap'0) =
    [%#sra] factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 (self: t_FMap'0) (other: t_FMap'0) (comb: t_FMap'0) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap'0, other: t_FMap'0, comb: t_FMap'0. ([%#sra'0] op'1 self other
  = C_Some'0 comb)  -> ([%#sra'1] incl'0 self comb)
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'3
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'3 =
    [%#sfmap'5] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option) (f: t_FMap'0) =
    [%#sfmap_view_view'3] match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
        | C_Some'1 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'3 v
        | _ -> true
        end
      | C_None -> true
      end
  
  function rel_unit [#"fmap_view_view.rs" 52 4 52 38] (a: t_Option) : () =
    [%#sfmap_view_view'12] ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sfmap_view_view'11] rel a unit'
  
  function rel_none [#"fmap_view_view.rs" 48 4 48 53] (a: t_Option) (f: t_FMap'0) : () =
    [%#sfmap_view_view'10] ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_FMap'0. ([%#sfmap_view_view'8] rel a f)
   -> ([%#sfmap_view_view'9] rel (C_None) f)
  
  function rel_mono [#"fmap_view_view.rs" 43 4 43 70] (a: t_Option) (f1: t_FMap'0) (f2: t_FMap'0) : () =
    [%#sfmap_view_view'7] ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_FMap'0, f2: t_FMap'0. ([%#sfmap_view_view'4] rel a f1)
   -> ([%#sfmap_view_view'5] incl'0 f2 f1)  -> ([%#sfmap_view_view'6] rel a f2)
  
  function auth (self: t_View) : t_Option
  
  function frag (self: t_View) : t_FMap'0
  
  axiom frag_spec: forall self: t_View. [%#sview'3] rel (auth self) (frag self)
  
  function new (auth'0: t_Option) (frag'0: t_FMap'0) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_FMap'0. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'1] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_FMap'0. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'2] frag (new auth'0 frag'0) = frag'0)
  
  function new_auth (auth'0: t_FMap) : t_View =
    [%#sview] new (C_Some auth'0) unit'
  
  function len'0 (self: t_FMap) : int
  
  axiom len_spec'0: forall self: t_FMap. [%#sfmap'3] len'0 self >= 0
  
  constant empty'0  : t_FMap
  
  axiom empty_spec'1: [%#sfmap] len'0 empty'0 = 0
  
  axiom empty_spec'2: [%#sfmap'0] view'0 empty'0 = Const.const (C_None'3)
  
  type t_Resource
  
  function val' (self: t_Resource) : t_View
  
  function view'1 (self: t_Resource) : t_View =
    [%#sresource'0] val' self
  
  function view'2 (self:  t_Resource) : t_View =
    [%#sghost'3] view'1 self
  
  let rec alloc (r:t_View) (return'  (x: t_Resource))= any
    [ return''0 (result: t_Resource)-> {[%#sresource] view'2 result = r} (! return' {result}) ]
  
  
  let rec into_inner (self: t_Resource) (return'  (x:t_Resource))= any
    [ return''0 (result:t_Resource)-> {[%#sghost] result = self} (! return' {result}) ]
  
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  predicate invariant' [#"fmap_view_view.rs" 70 4 70 30] (self: t_Authority) =
    [%#sfmap_view_view'13] auth (view'1 self.t_Authority__0) <> C_None
  
  predicate inv (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate invariant''0 (self:  t_Authority) =
    [%#sghost'4] inv self
  
  predicate inv'0 (_0:  t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x:  t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  let rec new'0 (x:t_Authority) (return'  (x'0: t_Authority))= {[@expl:new 'x' type invariant] [%#sghost'0] inv x}
    any
    [ return''0 (result: t_Authority)-> {[%#sghost'1] inv'0 result} {[%#sghost'2] result = x} (! return' {result}) ]
  
  
  predicate index_logic'0 (self: Map.map t_FMap bool) (a: t_FMap) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. ([%#sutil] exists x: t_FMap. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_FMap =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_FMap) -> true)
      end
  
  function view'3 [#"fmap_view_view.rs" 88 4 88 31] (self: t_Authority) : t_FMap =
    [%#sfmap_view_view'2] unwrap_logic (auth (view'1 self.t_Authority__0))
  
  function view'4 (self:  t_Authority) : t_FMap =
    [%#sghost'3] view'3 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'1[#"fmap_view_view.rs" 112 4 112 31] (return'  (x: t_Authority))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- [%#sfmap_view_view] new_auth empty'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = alloc {_3} (fun (_ret: t_Resource) ->  [ &resource <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = into_inner {resource} (fun (_ret:t_Resource) ->  [ &_6 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 =  [ &_5 <- { t_Authority__0 = _6 } ] s1
      | s1 = new'0 {_5} (fun (_ret: t_Authority) ->  [ &_0 <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = return''0 {_0} ]
    )
    [ & _0:  t_Authority = Any.any_l ()
    | & resource:  t_Resource = Any.any_l ()
    | & _3: t_View = Any.any_l ()
    | & _5: t_Authority = Any.any_l ()
    | & _6: t_Resource = Any.any_l () ]
    
    [ return''0 (result: t_Authority)-> {[@expl:new result type invariant] [%#sfmap_view_view'0] inv'0 result}
      {[@expl:new ensures] [%#sfmap_view_view'1] view'4 result = empty'0}
      (! return' {result}) ]

end
module M_fmap_view_view__qyi16747555808275470465__insert [#"fmap_view_view.rs" 126 4 126 78] (* Authority<K, V> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 127 19 127 50
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 128 19 128 57
  let%span sfmap_view_view'1 = "fmap_view_view.rs" 132 27 132 61
  let%span sfmap_view_view'2 = "fmap_view_view.rs" 132 63 132 97
  let%span sfmap_view_view'3 = "fmap_view_view.rs" 133 12 133 25
  let%span sfmap_view_view'4 = "fmap_view_view.rs" 134 12 134 25
  let%span sfmap_view_view'5 = "fmap_view_view.rs" 126 23 126 27
  let%span sfmap_view_view'6 = "fmap_view_view.rs" 119 15 119 34
  let%span sfmap_view_view'7 = "fmap_view_view.rs" 126 64 126 78
  let%span sfmap_view_view'8 = "fmap_view_view.rs" 120 14 120 46
  let%span sfmap_view_view'9 = "fmap_view_view.rs" 121 14 121 39
  let%span sfmap_view_view'10 = "fmap_view_view.rs" 122 14 122 33
  let%span sfmap_view_view'11 = "fmap_view_view.rs" 123 14 123 38
  let%span sfmap_view_view'12 = "fmap_view_view.rs" 89 20 89 49
  let%span sfmap_view_view'13 = "fmap_view_view.rs" 104 4 104 12
  let%span sfmap_view_view'14 = "fmap_view_view.rs" 98 8 98 26
  let%span sfmap_view_view'15 = "fmap_view_view.rs" 150 4 150 12
  let%span sfmap_view_view'16 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap_view_view'17 = "fmap_view_view.rs" 40 15 40 31
  let%span sfmap_view_view'18 = "fmap_view_view.rs" 41 15 41 26
  let%span sfmap_view_view'19 = "fmap_view_view.rs" 42 14 42 30
  let%span sfmap_view_view'20 = "fmap_view_view.rs" 43 71 43 73
  let%span sfmap_view_view'21 = "fmap_view_view.rs" 46 15 46 30
  let%span sfmap_view_view'22 = "fmap_view_view.rs" 47 14 47 32
  let%span sfmap_view_view'23 = "fmap_view_view.rs" 48 54 48 56
  let%span sfmap_view_view'24 = "fmap_view_view.rs" 51 14 51 46
  let%span sfmap_view_view'25 = "fmap_view_view.rs" 52 39 52 41
  let%span sfmap_view_view'26 = "fmap_view_view.rs" 78 12 78 81
  let%span sfmap_view_view'27 = "fmap_view_view.rs" 71 20 71 42
  let%span sra = "../../../creusot-contracts/src/logic/ra.rs" 99 8 102 9
  let%span sra'0 = "../../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'5 = "../../../creusot-contracts/src/logic/ra.rs" 93 8 93 41
  let%span sra'6 = "../../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 79 8 79 34
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/fmap.rs" 240 14 243 5
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'3 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'4 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'5 = "../../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'6 = "../../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'7 = "../../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sagree'2 = "../../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'3 = "../../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sview = "../../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'0 = "../../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'1 = "../../../creusot-contracts/src/logic/ra/view.rs" 104 8 104 46
  let%span sview'2 = "../../../creusot-contracts/src/logic/ra/view.rs" 275 12 280 17
  let%span sview'3 = "../../../creusot-contracts/src/logic/ra/view.rs" 286 15 286 33
  let%span sview'4 = "../../../creusot-contracts/src/logic/ra/view.rs" 287 14 287 44
  let%span sview'5 = "../../../creusot-contracts/src/logic/ra/view.rs" 289 8 289 41
  let%span sview'6 = "../../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'7 = "../../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'8 = "../../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'9 = "../../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'10 = "../../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'11 = "../../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'12 = "../../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'13 = "../../../creusot-contracts/src/logic/ra/view.rs" 134 14 137 5
  let%span sview'14 = "../../../creusot-contracts/src/logic/ra/view.rs" 139 8 139 49
  let%span sresource = "../../../creusot-contracts/src/resource.rs" 235 19 235 37
  let%span sresource'0 = "../../../creusot-contracts/src/resource.rs" 236 18 236 43
  let%span sresource'1 = "../../../creusot-contracts/src/resource.rs" 237 18 237 56
  let%span sresource'2 = "../../../creusot-contracts/src/resource.rs" 147 19 147 47
  let%span sresource'3 = "../../../creusot-contracts/src/resource.rs" 148 18 148 71
  let%span sresource'4 = "../../../creusot-contracts/src/resource.rs" 149 18 149 32
  let%span sresource'5 = "../../../creusot-contracts/src/resource.rs" 150 18 150 31
  let%span sresource'6 = "../../../creusot-contracts/src/resource.rs" 48 12 48 22
  let%span sutil = "../../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smodel = "../../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 101 20 101 44
  
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'3] len self >= 0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option =
    [%#sfmap'8] Map.get (view self) k
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) =
    [%#sfmap'2] get self k <> C_None
  
  function insert (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap] view (insert self k v)
  = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'0] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  type t_Resource
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap
  
  predicate index_logic (self: Map.map t_FMap bool) (a: t_FMap) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. ([%#sutil] exists x: t_FMap. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option'0) : t_FMap =
    [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_FMap) -> true)
      end
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  function auth (self: t_View) : t_Option'0
  
  function val' (self: t_Resource) : t_View
  
  function view'0 (self: t_Resource) : t_View =
    [%#sresource'6] val' self
  
  function view'1 [#"fmap_view_view.rs" 88 4 88 31] (self: t_Authority) : t_FMap =
    [%#sfmap_view_view'12] unwrap_logic (auth (view'0 self.t_Authority__0))
  
  function view'2 (self: MutBorrow.t t_Authority) : t_FMap =
    [%#smodel] view'1 self.current
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_FMap'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Ag
  
  function view'3 (self: t_FMap'0) : Map.map t_K t_Option'1
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'3] len'0 self >= 0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'1 =
    [%#sfmap'8] Map.get (view'3 self) k
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) =
    [%#sfmap'2] get'0 self k <> C_None'1
  
  function insert'0 (self: t_FMap'0) (k: t_K) (v: t_Ag) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_K, v: t_Ag. [%#sfmap] view'3 (insert'0 self k v)
  = Map.set (view'3 self) k (C_Some'1 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_K, v: t_Ag. [%#sfmap'0] len'0 (insert'0 self k v)
  = (if contains'0 self k then len'0 self else len'0 self + 1)
  
  constant empty  : t_FMap'0
  
  axiom empty_spec: [%#sfmap'4] len'0 empty = 0
  
  axiom empty_spec'0: [%#sfmap'5] view'3 empty = Const.const (C_None'1)
  
  function singleton (k: t_K) (v: t_Ag) : t_FMap'0 =
    [%#sfmap'1] insert'0 empty k v
  
  type t_ViewUpdateInsert  =
    { t_ViewUpdateInsert__0: t_FMap; t_ViewUpdateInsert__1: t_FMap'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_FMap'0
  
  function and_then_logic (self: t_Option'2) (f: Map.map t_FMap'0 t_Option'2) : t_Option'2 =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Option'1
  
  function and_then_logic'0 (self: t_Option'3) (f: Map.map t_Option'1 t_Option'3) : t_Option'3 =
    [%#soption'2] match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'3 =
    [%#soption'4] match self with
      | C_None'1 -> C_None'3
      | C_Some'1 x -> C_Some'3 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 =
    [%#sagree] if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'1] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'0] op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'3 =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'3 other
      | {_p1 = C_None'1} -> C_Some'3 self
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'3] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. ([%#sfmap'12] forall k: t_K. op'0 (get'0 self k) (get'0 other k)
  <> C_None'3)
   -> ([%#sfmap'13] forall k: t_K. C_Some'3 (get'0 (total_op self other) k) = op'0 (get'0 self k) (get'0 other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'2 =
    [%#sfmap'9] if forall k: t_K. op'0 (get'0 self k) (get'0 other k) <> C_None'3 then
      C_Some'2 (total_op self other)
    else
      C_None'2
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'11] and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'0: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'10] op'1 a b = op'1 b a
  
  constant unit': t_FMap'0 = [%#sfmap'7] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'6] forall x: t_FMap'0 [op'1 x unit']. op'1 x unit' = C_Some'2 x
  
  function commutative'1 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'1: forall a: t_Option'1, b: t_Option'1. [%#soption'7] op'0 a b = op'0 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 =
    [%#sagree'3] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'2] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
    end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'3 =
    [%#soption'6] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'1} -> C_Some'3 x
      | {_p0 = C_None'1} -> C_None'3
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'3 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'3 (C_None'1) else C_None'3
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. [%#soption'5] match factor'0 self factor'1 with
    | C_Some'3 c -> op'0 factor'1 c = C_Some'3 self
    | C_None'3 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'3 self
    end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) =
    [%#sra'6] factor'0 other self <> C_None'3
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. ([%#sra'0] op'0 self other
  = C_Some'3 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic'0 (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 =
    [%#smapping] Map.get self a
  
  function filter_map (self: t_FMap'0) (f: Map.map tuple'0 t_Option'1) : t_FMap'0
  
  axiom filter_map_spec: forall self: t_FMap'0, f: Map.map tuple'0 t_Option'1. [%#sfmap'16] forall k: t_K [get'0 (filter_map self f) k]. get'0 (filter_map self f) k
  = match get'0 self k with
    | C_None'1 -> C_None'1
    | C_Some'1 v -> index_logic'0 f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 (self: t_FMap'0) (factor'2: t_FMap'0) : t_Option'2 =
    [%#sfmap'15] if forall k: t_K. incl (get'0 factor'2 k) (get'0 self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get'0 factor'2 k) with
        | C_Some'3 r -> r
        | C_None'3 -> C_None'1
        end) in let _ = let _ = () in () in C_Some'2 res
    else
      C_None'2
  
  
  axiom factor_spec'1: forall self: t_FMap'0, factor'2: t_FMap'0. [%#sfmap'14] match factor'1 self factor'2 with
    | C_Some'2 c -> op'1 factor'2 c = C_Some'2 self
    | C_None'2 -> forall c: t_FMap'0. op'1 factor'2 c <> C_Some'2 self
    end
  
  predicate incl'0 (self: t_FMap'0) (other: t_FMap'0) =
    [%#sra'6] factor'1 other self <> C_None'2
  
  function incl_transitive'0 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 (self: t_FMap'0) (other: t_FMap'0) (comb: t_FMap'0) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap'0, other: t_FMap'0, comb: t_FMap'0. ([%#sra'0] op'1 self other
  = C_Some'2 comb)  -> ([%#sra'1] incl'0 self comb)
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option'0) (f: t_FMap'0) =
    [%#sfmap_view_view'16] match a with
      | C_Some'0 a'0 -> forall k: t_K. match get'0 f k with
        | C_Some'1 {t_Ag__0 = v} -> get a'0 k = C_Some v
        | _ -> true
        end
      | C_None'0 -> true
      end
  
  function rel_unit [#"fmap_view_view.rs" 52 4 52 38] (a: t_Option'0) : () =
    [%#sfmap_view_view'25] ()
  
  axiom rel_unit_spec: forall a: t_Option'0. [%#sfmap_view_view'24] rel a unit'
  
  function rel_none [#"fmap_view_view.rs" 48 4 48 53] (a: t_Option'0) (f: t_FMap'0) : () =
    [%#sfmap_view_view'23] ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_FMap'0. ([%#sfmap_view_view'21] rel a f)
   -> ([%#sfmap_view_view'22] rel (C_None'0) f)
  
  function rel_mono [#"fmap_view_view.rs" 43 4 43 70] (a: t_Option'0) (f1: t_FMap'0) (f2: t_FMap'0) : () =
    [%#sfmap_view_view'20] ()
  
  axiom rel_mono_spec: forall a: t_Option'0, f1: t_FMap'0, f2: t_FMap'0. ([%#sfmap_view_view'17] rel a f1)
   -> ([%#sfmap_view_view'18] incl'0 f2 f1)  -> ([%#sfmap_view_view'19] rel a f2)
  
  predicate premise (self: t_ViewUpdateInsert) (from: t_View) =
    [%#sview'2] auth from <> C_None'0
    /\ (forall f: t_FMap'0. rel (auth from) f
     -> match op'1 self.t_ViewUpdateInsert__1 f with
      | C_Some'2 ff -> rel (C_Some'0 (self.t_ViewUpdateInsert__0)) ff
      | C_None'2 -> false
      end)
  
  function view'4 (self: MutBorrow.t t_Resource) : t_View =
    [%#smodel] view'0 self.current
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  function frag (self: t_View) : t_FMap'0
  
  axiom frag_spec: forall self: t_View. [%#sview'9] rel (auth self) (frag self)
  
  function new (auth'0: t_Option'0) (frag'0: t_FMap'0) : t_View
  
  axiom new_spec: forall auth'0: t_Option'0, frag'0: t_FMap'0. ([%#sview'6] rel auth'0 frag'0)
   -> ([%#sview'7] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'0, frag'0: t_FMap'0. ([%#sview'6] rel auth'0 frag'0)
   -> ([%#sview'8] frag (new auth'0 frag'0) = frag'0)
  
  function update (self: t_ViewUpdateInsert) (from: t_View) (_2: ()) : t_View =
    [%#sview'5] new (C_Some'0 (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  axiom update_spec: forall self: t_ViewUpdateInsert, from: t_View, _2: (). ([%#sview'3] premise self from)
   -> ([%#sview'4] rel (C_Some'0 (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1)
  
  let rec update'0 (self:MutBorrow.t t_Resource) (upd:t_ViewUpdateInsert) (return'  (x:()))= {[@expl:update requires] [%#sresource] premise upd (view'4 self)}
    any
    [ return''0 (result:())-> {[%#sresource'0] id self.final = id self.current}
      {[%#sresource'1] view'0 self.final = update upd (view'4 self) result}
      (! return' {result}) ]
  
  
  function new_frag (frag'0: t_FMap'0) : t_View =
    [%#sview'0] new (C_None'0) frag'0
  
  function new_auth (auth'0: t_FMap) : t_View =
    [%#sview'1] new (C_Some'0 auth'0) unit'
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_View
  
  function and_then_logic'2 (self: t_Option'4) (f: Map.map t_View t_Option'4) : t_Option'4 =
    [%#soption'2] match self with
      | C_None'4 -> C_None'4
      | C_Some'4 x -> Map.get f x
      end
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 (self: t_View) (other: t_View) : t_Option'4 =
    [%#sview'12] match op'1 (frag self) (frag other) with
      | C_Some'2 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'0 ; _p1'1 = a} -> if rel a f then C_Some'4 (new a f) else C_None'4
        | {_p0'1 = a ; _p1'1 = C_None'0} -> if rel a f then C_Some'4 (new a f) else C_None'4
        | _ -> C_None'4
        end
      | C_None'2 -> C_None'4
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2: forall a: t_View, b: t_View, c: t_View. [%#sview'11] and_then_logic'2 (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
  = and_then_logic'2 (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'10] op'2 a b = op'2 b a
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option'4 =
    [%#sview'14] let _ = () in match factor'1 (frag self) (frag factor'3) with
      | C_Some'2 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'0 a ; _p1'1 = C_None'0} -> C_Some'4 (new (C_Some'0 a) f)
        | {_p0'1 = a1 ; _p1'1 = a2} -> if a1 = a2 then C_Some'4 (new_frag f) else C_None'4
        end
      | C_None'2 -> C_None'4
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. [%#sview'13] match factor'2 self factor'3 with
    | C_Some'4 c -> op'2 factor'3 c = C_Some'4 self
    | C_None'4 -> forall c: t_View. op'2 factor'3 c <> C_Some'4 self
    end
  
  predicate incl'1 (self: t_View) (other: t_View) =
    [%#sra'6] factor'2 other self <> C_None'4
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. ([%#sra'2] incl'1 a b)
   -> ([%#sra'3] incl'1 b c)  -> ([%#sra'4] incl'1 a c)
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. ([%#sra'0] op'2 self other = C_Some'4 comb)
   -> ([%#sra'1] incl'1 self comb)
  
  predicate incl_eq (self: t_View) (other: t_View) =
    [%#sra'5] self = other \/ incl'1 self other
  
  predicate incl_eq_op (a: t_View) (b: t_View) (x: t_View) =
    [%#sra] match op'2 a b with
      | C_None'4 -> false
      | C_Some'4 ab -> incl_eq ab x
      end
  
  let rec split_off (self:MutBorrow.t t_Resource) (r:t_View) (s:t_View) (return'  (x:t_Resource))= {[@expl:split_off requires] [%#sresource'2] incl_eq_op r s (view'4 self)}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'3] id self.final = id self.current /\ id result = id self.current}
      {[%#sresource'4] view'0 self.final = s}
      {[%#sresource'5] view'0 result = r}
      (! return' {result}) ]
  
  
  predicate invariant' [#"fmap_view_view.rs" 70 4 70 30] (self: t_Authority) =
    [%#sfmap_view_view'27] auth (view'0 self.t_Authority__0) <> C_None'0
  
  predicate inv (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate invariant''0 (self: MutBorrow.t t_Authority) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve (self: MutBorrow.t t_Authority) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Authority) =
    resolve _0
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  predicate invariant''1 [#"fmap_view_view.rs" 76 4 76 30] (self: t_Fragment) =
    [%#sfmap_view_view'26] incl'1 (new_frag (singleton self.t_Fragment__1 { t_Ag__0 = self.t_Fragment__2 })) (view'0 self.t_Fragment__0)
  
  predicate inv'1 (_0: t_Fragment)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x
  = (invariant''1 x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  function id'0 [#"fmap_view_view.rs" 105 4 105 25] (self: t_Authority) : t_Id =
    [%#sfmap_view_view'13] id self.t_Authority__0
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function view'5 [#"fmap_view_view.rs" 97 4 97 27] (self: t_Fragment) : tuple'2 =
    [%#sfmap_view_view'14] { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function id'1 [#"fmap_view_view.rs" 151 4 151 25] (self: t_Fragment) : t_Id =
    [%#sfmap_view_view'15] id self.t_Fragment__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert'1[#"fmap_view_view.rs" 126 4 126 78] (self:MutBorrow.t t_Authority) (k:t_K) (v:t_V) (return'  (x:t_Fragment))= {[@expl:insert 'self' type invariant] [%#sfmap_view_view'5] inv'0 self}
    {[@expl:insert requires] [%#sfmap_view_view'6] not contains (view'2 self) k}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &auth'0 <- [%#sfmap_view_view] insert (view'2 self'0) k'0 v'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &frag'0 <- [%#sfmap_view_view'0] singleton k'0 { t_Ag__0 = v'0 } ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_15 <- { t_ViewUpdateInsert__0 = auth'0; t_ViewUpdateInsert__1 = frag'0 } ] s1
      | s1 = MutBorrow.borrow_mut <t_Resource> {(self'0.current).t_Authority__0}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_14 <- _ret ] 
             [ &self'0 <- { self'0 with current = { t_Authority__0 = _ret.final } } ] 
            s2)
      | s2 = update'0 {_14} {_15} (fun (_ret:()) ->  [ &_13 <- _ret ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0 [ s0 =  [ &_20 <- [%#sfmap_view_view'1] new_frag frag'0 ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_22 <- [%#sfmap_view_view'2] new_auth auth'0 ] s1 | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = MutBorrow.borrow_final
          <t_Resource>
          {(self'0.current).t_Authority__0}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_19 <- _ret ] 
             [ &self'0 <- { self'0 with current = { t_Authority__0 = _ret.final } } ] 
            s1)
      | s1 = split_off {_19} {_20} {_22} (fun (_ret:t_Resource) ->  [ &_18 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_24 <- [%#sfmap_view_view'3] k'0 ] s3
      | s3 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &_26 <- [%#sfmap_view_view'4] v'0 ] s1 | s1 = bb8 ] 
    | bb8 = s0
      [ s0 =  [ &_0 <- { t_Fragment__0 = _18; t_Fragment__1 = _24; t_Fragment__2 = _26 } ] s1 | s1 = return''0 {_0} ]
     ]
    )
    [ & _0: t_Fragment = Any.any_l ()
    | & self'0: MutBorrow.t t_Authority = self
    | & k'0: t_K = k
    | & v'0: t_V = v
    | & auth'0: t_FMap = Any.any_l ()
    | & frag'0: t_FMap'0 = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & _14: MutBorrow.t t_Resource = Any.any_l ()
    | & _15: t_ViewUpdateInsert = Any.any_l ()
    | & _18: t_Resource = Any.any_l ()
    | & _19: MutBorrow.t t_Resource = Any.any_l ()
    | & _20: t_View = Any.any_l ()
    | & _22: t_View = Any.any_l ()
    | & _24: t_K = Any.any_l ()
    | & _26: t_V = Any.any_l () ]
    
    [ return''0 (result:t_Fragment)-> {[@expl:insert result type invariant] [%#sfmap_view_view'7] inv'1 result}
      {[@expl:insert ensures #0] [%#sfmap_view_view'8] view'1 self.final = insert (view'2 self) k v}
      {[@expl:insert ensures #1] [%#sfmap_view_view'9] id'0 self.final = id'0 self.current}
      {[@expl:insert ensures #2] [%#sfmap_view_view'10] view'5 result = { _p0'2 = k; _p1'2 = v }}
      {[@expl:insert ensures #3] [%#sfmap_view_view'11] id'1 result = id'0 self.current}
      (! return' {result}) ]

end
module M_fmap_view_view__qyi16747555808275470465__contains [#"fmap_view_view.rs" 143 4 143 49] (* Authority<K, V> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 145 22 145 76
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 143 21 143 25
  let%span sfmap_view_view'1 = "fmap_view_view.rs" 143 27 143 31
  let%span sfmap_view_view'2 = "fmap_view_view.rs" 139 15 139 37
  let%span sfmap_view_view'3 = "fmap_view_view.rs" 140 14 140 49
  let%span sfmap_view_view'4 = "fmap_view_view.rs" 104 4 104 12
  let%span sfmap_view_view'5 = "fmap_view_view.rs" 150 4 150 12
  let%span sfmap_view_view'6 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap_view_view'7 = "fmap_view_view.rs" 98 8 98 26
  let%span sfmap_view_view'8 = "fmap_view_view.rs" 89 20 89 49
  let%span sfmap_view_view'9 = "fmap_view_view.rs" 40 15 40 31
  let%span sfmap_view_view'10 = "fmap_view_view.rs" 41 15 41 26
  let%span sfmap_view_view'11 = "fmap_view_view.rs" 42 14 42 30
  let%span sfmap_view_view'12 = "fmap_view_view.rs" 43 71 43 73
  let%span sfmap_view_view'13 = "fmap_view_view.rs" 46 15 46 30
  let%span sfmap_view_view'14 = "fmap_view_view.rs" 47 14 47 32
  let%span sfmap_view_view'15 = "fmap_view_view.rs" 48 54 48 56
  let%span sfmap_view_view'16 = "fmap_view_view.rs" 51 14 51 46
  let%span sfmap_view_view'17 = "fmap_view_view.rs" 52 39 52 41
  let%span sfmap_view_view'18 = "fmap_view_view.rs" 71 20 71 42
  let%span sfmap_view_view'19 = "fmap_view_view.rs" 78 12 78 81
  let%span sra = "../../../creusot-contracts/src/logic/ra.rs" 93 8 93 41
  let%span sra'0 = "../../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'5 = "../../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 240 14 243 5
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/fmap.rs" 79 8 79 34
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'2 = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'3 = "../../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'4 = "../../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'5 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'6 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'7 = "../../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sagree'2 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sview = "../../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'0 = "../../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'1 = "../../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'2 = "../../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'3 = "../../../creusot-contracts/src/logic/ra/view.rs" 134 14 137 5
  let%span sview'4 = "../../../creusot-contracts/src/logic/ra/view.rs" 139 8 139 49
  let%span sview'5 = "../../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'6 = "../../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'7 = "../../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'8 = "../../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'9 = "../../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sresource = "../../../creusot-contracts/src/resource.rs" 192 19 192 42
  let%span sresource'0 = "../../../creusot-contracts/src/resource.rs" 193 18 193 42
  let%span sresource'1 = "../../../creusot-contracts/src/resource.rs" 194 18 194 67
  let%span sresource'2 = "../../../creusot-contracts/src/resource.rs" 48 12 48 22
  let%span sutil = "../../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smodel = "../../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option =
    [%#soption'1] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 =
    [%#soption'1] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Ag
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 =
    [%#soption'1] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 =
    [%#soption'6] match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 =
    [%#soption'1] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 =
    [%#sagree] if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'5] and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 =
    [%#sfmap] Map.get (view self) k
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'9] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'2)
   -> ([%#sfmap'10] forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 =
    [%#sfmap'2] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'6] and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'5] op'1 a b = op'1 b a
  
  type t_FMap'0
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_FMap'0
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'12] len self >= 0
  
  constant empty  : t_FMap
  
  axiom empty_spec: [%#sfmap'7] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'8] view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = [%#sfmap'1] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'0] forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function commutative'1 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'1: forall a: t_Option'1, b: t_Option'1. [%#soption'7] op'0 a b = op'0 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 =
    [%#sagree'1] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'0] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
    end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 =
    [%#soption'4] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. [%#soption'3] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) =
    [%#sra'5] factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. ([%#sra'0] op'0 self other
  = C_Some'2 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 =
    [%#smapping] Map.get self a
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option'1. [%#sfmap'11] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'1 -> C_None'1
    | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    [%#sfmap'4] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in let _ = let _ = () in () in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'3] match factor'1 self factor'2 with
    | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
    | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
    end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) =
    [%#sra'5] factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some'0 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'4
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'4 =
    [%#sfmap] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option'3) (f: t_FMap) =
    [%#sfmap_view_view'6] match a with
      | C_Some'3 a'0 -> forall k: t_K. match get f k with
        | C_Some'1 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'4 v
        | _ -> true
        end
      | C_None'3 -> true
      end
  
  function rel_unit [#"fmap_view_view.rs" 52 4 52 38] (a: t_Option'3) : () =
    [%#sfmap_view_view'17] ()
  
  axiom rel_unit_spec: forall a: t_Option'3. [%#sfmap_view_view'16] rel a unit'
  
  function rel_none [#"fmap_view_view.rs" 48 4 48 53] (a: t_Option'3) (f: t_FMap) : () =
    [%#sfmap_view_view'15] ()
  
  axiom rel_none_spec: forall a: t_Option'3, f: t_FMap. ([%#sfmap_view_view'13] rel a f)
   -> ([%#sfmap_view_view'14] rel (C_None'3) f)
  
  function rel_mono [#"fmap_view_view.rs" 43 4 43 70] (a: t_Option'3) (f1: t_FMap) (f2: t_FMap) : () =
    [%#sfmap_view_view'12] ()
  
  axiom rel_mono_spec: forall a: t_Option'3, f1: t_FMap, f2: t_FMap. ([%#sfmap_view_view'9] rel a f1)
   -> ([%#sfmap_view_view'10] incl'0 f2 f1)  -> ([%#sfmap_view_view'11] rel a f2)
  
  function auth (self: t_View) : t_Option'3
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. [%#sview] rel (auth self) (frag self)
  
  type tuple'1  =
    { _p0'1: t_Option'3; _p1'1: t_Option'3 }
  
  function new (auth'0: t_Option'3) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option'3, frag'0: t_FMap. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'6] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'3, frag'0: t_FMap. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'7] frag (new auth'0 frag'0) = frag'0)
  
  function op'2 (self: t_View) (other: t_View) : t_Option =
    [%#sview'2] match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'3 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'3} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2: forall a: t_View, b: t_View, c: t_View. [%#sview'1] and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'0] op'2 a b = op'2 b a
  
  function new_frag (frag'0: t_FMap) : t_View =
    [%#sview'9] new (C_None'3) frag'0
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option =
    [%#sview'4] let _ = () in match factor'1 (frag self) (frag factor'3) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'3 a ; _p1'1 = C_None'3} -> C_Some (new (C_Some'3 a) f)
        | {_p0'1 = a1 ; _p1'1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. [%#sview'3] match factor'2 self factor'3 with
    | C_Some c -> op'2 factor'3 c = C_Some self
    | C_None -> forall c: t_View. op'2 factor'3 c <> C_Some self
    end
  
  predicate incl'1 (self: t_View) (other: t_View) =
    [%#sra'5] factor'2 other self <> C_None
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. ([%#sra'2] incl'1 a b)
   -> ([%#sra'3] incl'1 b c)  -> ([%#sra'4] incl'1 a c)
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. ([%#sra'0] op'2 self other = C_Some comb)
   -> ([%#sra'1] incl'1 self comb)
  
  predicate incl_eq (self: t_View) (other: t_View) =
    [%#sra] self = other \/ incl'1 self other
  
  function val' (self: t_Resource) : t_View
  
  function view'1 (self: t_Resource) : t_View =
    [%#sresource'2] val' self
  
  function view'2 (self: t_Resource) : t_View =
    [%#smodel] view'1 self
  
  let rec join_shared (self:t_Resource) (other:t_Resource) (return'  (x:t_Resource))= {[@expl:join_shared requires] [%#sresource] id self
    = id other}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'0] id result = id self}
      {[%#sresource'1] incl_eq (view'2 self) (view'2 result) /\ incl_eq (view'2 other) (view'2 result)}
      (! return' {result}) ]
  
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function view'3 [#"fmap_view_view.rs" 97 4 97 27] (self: t_Fragment) : tuple'2 =
    [%#sfmap_view_view'7] { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function view'4 (self: t_Fragment) : tuple'2 =
    [%#smodel] view'3 self
  
  predicate invariant' [#"fmap_view_view.rs" 70 4 70 30] (self: t_Authority) =
    [%#sfmap_view_view'18] auth (view'1 self.t_Authority__0) <> C_None'3
  
  predicate inv (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate invariant''0 (self: t_Authority) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) =
    [%#sfmap'16] get self k <> C_None'1
  
  function insert (self: t_FMap) (k: t_K) (v: t_Ag) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_Ag. [%#sfmap'14] view (insert self k v)
  = Map.set (view self) k (C_Some'1 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_Ag. [%#sfmap'15] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  function singleton (k: t_K) (v: t_Ag) : t_FMap =
    [%#sfmap'13] insert empty k v
  
  predicate invariant''1 [#"fmap_view_view.rs" 76 4 76 30] (self: t_Fragment) =
    [%#sfmap_view_view'19] incl'1 (new_frag (singleton self.t_Fragment__1 { t_Ag__0 = self.t_Fragment__2 })) (view'1 self.t_Fragment__0)
  
  predicate inv'1 (_0: t_Fragment)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x
  = (invariant''1 x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''2 (self: t_Fragment) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0: t_Fragment)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Fragment [inv'2 x]. inv'2 x = invariant''2 x
  
  function id'0 [#"fmap_view_view.rs" 105 4 105 25] (self: t_Authority) : t_Id =
    [%#sfmap_view_view'4] id self.t_Authority__0
  
  function id'1 [#"fmap_view_view.rs" 151 4 151 25] (self: t_Fragment) : t_Id =
    [%#sfmap_view_view'5] id self.t_Fragment__0
  
  predicate index_logic'0 (self: Map.map t_FMap'0 bool) (a: t_FMap'0) =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map t_FMap'0 bool) : t_FMap'0
  
  axiom such_that_spec: forall p: Map.map t_FMap'0 bool. ([%#sutil] exists x: t_FMap'0. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function unwrap_logic (self: t_Option'3) : t_FMap'0 =
    [%#soption'0] match self with
      | C_Some'3 x -> x
      | C_None'3 -> such_that (fun (__0: t_FMap'0) -> true)
      end
  
  function view'5 [#"fmap_view_view.rs" 88 4 88 31] (self: t_Authority) : t_FMap'0 =
    [%#sfmap_view_view'8] unwrap_logic (auth (view'1 self.t_Authority__0))
  
  function view'6 (self: t_Authority) : t_FMap'0 =
    [%#smodel] view'5 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains'0[#"fmap_view_view.rs" 143 4 143 49] (self:t_Authority) (frag'0:t_Fragment) (return'  (x:()))= {[@expl:contains 'self' type invariant] [%#sfmap_view_view'0] inv'0 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view_view'1] inv'2 frag'0}
    {[@expl:contains requires] [%#sfmap_view_view'2] id'0 self = id'1 frag'0}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_8 <- frag'1.t_Fragment__0 ] s1
      | s1 = join_shared {self'0.t_Authority__0} {_8} (fun (_ret:t_Resource) ->  [ &new_resource <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#sfmap_view_view] get (frag (view'2 new_resource)) (view'4 frag'1)._p0'2
        = C_Some'1 { t_Ag__0 = (view'4 frag'1)._p1'2 }}
        s1
      | s1 = return''0 {_0} ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: t_Authority = self
    | & frag'1: t_Fragment = frag'0
    | & new_resource: t_Resource = Any.any_l ()
    | & _8: t_Resource = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:contains ensures] [%#sfmap_view_view'3] get'0 (view'6 self) (view'4 frag'0)._p0'2
      = C_Some'4 ((view'4 frag'0)._p1'2)}
      (! return' {result}) ]

end
module M_fmap_view_view__qyi9127813262067876198__clone [#"fmap_view_view.rs" 159 4 159 27] (* <Fragment<K, V> as creusot_contracts::Clone> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 159 14 159 18
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 159 23 159 27
  let%span sfmap_view_view'1 = "fmap_view_view.rs" 158 14 158 30
  let%span sfmap_view_view'2 = "fmap_view_view.rs" 98 8 98 26
  let%span sfmap_view_view'3 = "fmap_view_view.rs" 78 12 78 81
  let%span sfmap_view_view'4 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap_view_view'5 = "fmap_view_view.rs" 40 15 40 31
  let%span sfmap_view_view'6 = "fmap_view_view.rs" 41 15 41 26
  let%span sfmap_view_view'7 = "fmap_view_view.rs" 42 14 42 30
  let%span sfmap_view_view'8 = "fmap_view_view.rs" 43 71 43 73
  let%span sfmap_view_view'9 = "fmap_view_view.rs" 46 15 46 30
  let%span sfmap_view_view'10 = "fmap_view_view.rs" 47 14 47 32
  let%span sfmap_view_view'11 = "fmap_view_view.rs" 48 54 48 56
  let%span sfmap_view_view'12 = "fmap_view_view.rs" 51 14 51 46
  let%span sfmap_view_view'13 = "fmap_view_view.rs" 52 39 52 41
  let%span sra = "../../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sfmap = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 79 8 79 34
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 240 14 243 5
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'17 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'18 = "../../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'19 = "../../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'4 = "../../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'5 = "../../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 38 14 41 5
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 43 8 43 18
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'2 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sagree'4 = "../../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'5 = "../../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sview = "../../../creusot-contracts/src/logic/ra/view.rs" 182 14 185 5
  let%span sview'0 = "../../../creusot-contracts/src/logic/ra/view.rs" 187 8 187 31
  let%span sview'1 = "../../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'2 = "../../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'3 = "../../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'4 = "../../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'5 = "../../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'6 = "../../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'7 = "../../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'8 = "../../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'9 = "../../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'10 = "../../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'11 = "../../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'12 = "../../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'13 = "../../../creusot-contracts/src/logic/ra/view.rs" 134 14 137 5
  let%span sview'14 = "../../../creusot-contracts/src/logic/ra/view.rs" 139 8 139 49
  let%span sresource = "../../../creusot-contracts/src/resource.rs" 107 19 107 39
  let%span sresource'0 = "../../../creusot-contracts/src/resource.rs" 108 18 108 42
  let%span sresource'1 = "../../../creusot-contracts/src/resource.rs" 109 18 109 47
  let%span sresource'2 = "../../../creusot-contracts/src/resource.rs" 48 12 48 22
  let%span smodel = "../../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Ag
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 =
    [%#soption] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 =
    [%#soption'2] match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'1] and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 =
    [%#sfmap'6] Map.get (view self) k
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'7] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'2)  -> ([%#sfmap'8] forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 =
    [%#sfmap] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'5] and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'4] op'1 a b = op'1 b a
  
  type t_FMap'0
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_FMap'0
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'18] len self >= 0
  
  constant empty  : t_FMap
  
  axiom empty_spec: [%#sfmap'12] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'13] view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = [%#sfmap'15] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'14] forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function commutative'1 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'1: forall a: t_Option'1, b: t_Option'1. [%#soption'5] op'0 a b = op'0 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 =
    [%#sagree'5] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'4] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
    end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 =
    [%#soption'4] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. [%#soption'3] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) =
    [%#sra] factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. ([%#sra'0] op'0 self other
  = C_Some'2 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 =
    [%#smapping] Map.get self a
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option'1. [%#sfmap'9] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'1 -> C_None'1
    | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    [%#sfmap'17] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in let _ = let _ = () in () in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'16] match factor'1 self factor'2 with
    | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
    | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
    end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some'0 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'4
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'4 =
    [%#sfmap'6] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option'3) (f: t_FMap) =
    [%#sfmap_view_view'4] match a with
      | C_Some'3 a'0 -> forall k: t_K. match get f k with
        | C_Some'1 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'4 v
        | _ -> true
        end
      | C_None'3 -> true
      end
  
  function rel_unit [#"fmap_view_view.rs" 52 4 52 38] (a: t_Option'3) : () =
    [%#sfmap_view_view'13] ()
  
  axiom rel_unit_spec: forall a: t_Option'3. [%#sfmap_view_view'12] rel a unit'
  
  function rel_none [#"fmap_view_view.rs" 48 4 48 53] (a: t_Option'3) (f: t_FMap) : () =
    [%#sfmap_view_view'11] ()
  
  axiom rel_none_spec: forall a: t_Option'3, f: t_FMap. ([%#sfmap_view_view'9] rel a f)
   -> ([%#sfmap_view_view'10] rel (C_None'3) f)
  
  function rel_mono [#"fmap_view_view.rs" 43 4 43 70] (a: t_Option'3) (f1: t_FMap) (f2: t_FMap) : () =
    [%#sfmap_view_view'8] ()
  
  axiom rel_mono_spec: forall a: t_Option'3, f1: t_FMap, f2: t_FMap. ([%#sfmap_view_view'5] rel a f1)
   -> ([%#sfmap_view_view'6] incl'0 f2 f1)  -> ([%#sfmap_view_view'7] rel a f2)
  
  function auth (self: t_View) : t_Option'3
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. [%#sview'7] rel (auth self) (frag self)
  
  type tuple'1  =
    { _p0'1: t_Option'3; _p1'1: t_Option'3 }
  
  function new (auth'0: t_Option'3) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option'3, frag'0: t_FMap. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'9] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'3, frag'0: t_FMap. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'10] frag (new auth'0 frag'0) = frag'0)
  
  function op'2 (self: t_View) (other: t_View) : t_Option =
    [%#sview'3] match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'3 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'3} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2: forall a: t_View, b: t_View, c: t_View. [%#sview'2] and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'1] op'2 a b = op'2 b a
  
  function new_frag (frag'0: t_FMap) : t_View =
    [%#sview'12] new (C_None'3) frag'0
  
  function core (self: t_Ag) : t_Option'1 =
    [%#sagree'0] C_Some'1 self
  
  axiom core_spec: forall self: t_Ag. [%#sagree] match core self with
    | C_Some'1 c -> op c c = C_Some'1 c /\ op c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  function core_total (self: t_FMap) : t_FMap =
    [%#sfmap'2] let r = filter_map self (fun (__0: tuple'0) -> let {_p1'0 = v} = __0 in core v) in let _ = let _ = () in () in let _ = let _ = () in () in r
  
  axiom core_total_spec: forall self: t_FMap. [%#sfmap'0] op'1 (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. [%#sfmap'1] op'1 (core_total self) self = C_Some'0 self
  
  function core_total'0 (self: t_View) : t_View =
    [%#sview'6] let _ = () in let _ = () in new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. [%#sview'4] op'2 (core_total'0 self) (core_total'0 self)
  = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. [%#sview'5] op'2 (core_total'0 self) self = C_Some self
  
  function core'0 (self: t_View) : t_Option =
    [%#sview'0] C_Some (core_total'0 self)
  
  axiom core_spec'0: forall self: t_View. [%#sview] match core'0 self with
    | C_Some c -> op'2 c c = C_Some c /\ op'2 c self = C_Some self
    | C_None -> true
    end
  
  function val' (self: t_Resource) : t_View
  
  function view'1 (self: t_Resource) : t_View =
    [%#sresource'2] val' self
  
  function view'2 (self: t_Resource) : t_View =
    [%#smodel] view'1 self
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  let rec core'1 (self:t_Resource) (return'  (x:t_Resource))= {[@expl:core requires] [%#sresource] core'0 (view'2 self)
    <> C_None}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'0] id result = id self}
      {[%#sresource'1] C_Some (view'1 result) = core'0 (view'2 self)}
      (! return' {result}) ]
  
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option =
    [%#sview'14] let _ = () in match factor'1 (frag self) (frag factor'3) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'3 a ; _p1'1 = C_None'3} -> C_Some (new (C_Some'3 a) f)
        | {_p0'1 = a1 ; _p1'1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. [%#sview'13] match factor'2 self factor'3 with
    | C_Some c -> op'2 factor'3 c = C_Some self
    | C_None -> forall c: t_View. op'2 factor'3 c <> C_Some self
    end
  
  predicate incl'1 (self: t_View) (other: t_View) =
    [%#sra] factor'2 other self <> C_None
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. ([%#sra'2] incl'1 a b)
   -> ([%#sra'3] incl'1 b c)  -> ([%#sra'4] incl'1 a c)
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. ([%#sra'0] op'2 self other = C_Some comb)
   -> ([%#sra'1] incl'1 self comb)
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) =
    [%#sfmap'19] get self k <> C_None'1
  
  function insert (self: t_FMap) (k: t_K) (v: t_Ag) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_Ag. [%#sfmap'10] view (insert self k v)
  = Map.set (view self) k (C_Some'1 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_Ag. [%#sfmap'11] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  function singleton (k: t_K) (v: t_Ag) : t_FMap =
    [%#sfmap'3] insert empty k v
  
  predicate invariant' [#"fmap_view_view.rs" 76 4 76 30] (self: t_Fragment) =
    [%#sfmap_view_view'3] incl'1 (new_frag (singleton self.t_Fragment__1 { t_Ag__0 = self.t_Fragment__2 })) (view'1 self.t_Fragment__0)
  
  predicate inv (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''0 (self: t_Fragment) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''0 x
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function view'3 [#"fmap_view_view.rs" 97 4 97 27] (self: t_Fragment) : tuple'2 =
    [%#sfmap_view_view'2] { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function view'4 (self: t_Fragment) : tuple'2 =
    [%#smodel] view'3 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone'[#"fmap_view_view.rs" 159 4 159 27] (self:t_Fragment) (return'  (x:t_Fragment))= {[@expl:clone 'self' type invariant] [%#sfmap_view_view] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = core'1 {self'0.t_Fragment__0} (fun (_ret:t_Resource) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = 
        [ &_0 <- { t_Fragment__0 = _3; t_Fragment__1 = self'0.t_Fragment__1; t_Fragment__2 = self'0.t_Fragment__2 } ]
        
        s1
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: t_Fragment = Any.any_l () | & self'0: t_Fragment = self | & _3: t_Resource = Any.any_l () ] 
    [ return''0 (result:t_Fragment)-> {[@expl:clone result type invariant] [%#sfmap_view_view'0] inv result}
      {[@expl:clone ensures] [%#sfmap_view_view'1] view'3 result = view'4 self}
      (! return' {result}) ]

end
module M_fmap_view_view__qyi16167685763649721615__rel_mono__refines [#"fmap_view_view.rs" 43 4 43 70] (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 43 4 43 70
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 29 12 35 13
  let%span sra = "../../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sfmap = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 240 14 243 5
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'1 = "../../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'2 = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'3 = "../../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span soption'4 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'5 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'2 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'1 =
    [%#soption'5] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'4] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 =
    [%#sfmap'3] Map.get (view self) k
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'6] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'7] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'4] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'0] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap] op'1 a b = op'1 b a
  
  function commutative'1 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'1: forall a: t_Option'0, b: t_Option'0. [%#soption'3] op'0 a b = op'0 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'0 =
    [%#sagree'0] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Ag. op factor'0 c <> C_Some'0 self
    end
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1 =
    [%#soption'1] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'0} -> C_Some'1 x
      | {_p0 = C_None'0} -> C_None'1
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. [%#soption'0] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl (self: t_Option'0) (other: t_Option'0) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
  axiom incl_op_spec: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. ([%#sra'0] op'0 self other
  = C_Some'1 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic (self: Map.map tuple'0 t_Option'0) (a: tuple'0) : t_Option'0 =
    [%#smapping] Map.get self a
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'0) : t_FMap
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option'0. [%#sfmap'5] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option =
    [%#sfmap'2] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in let _ = let _ = () in () in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'1] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some comb)
   -> ([%#sra'1] incl'0 self comb)
  
  type t_FMap'0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_FMap'0
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'3
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'3 =
    [%#sfmap'3] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option'2) (f: t_FMap) =
    [%#sfmap_view_view'0] match a with
      | C_Some'2 a'0 -> forall k: t_K. match get f k with
        | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'3 v
        | _ -> true
        end
      | C_None'2 -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap_view_view] forall a: t_Option'2. forall f1: t_FMap. forall f2: t_FMap. incl'0 f2 f1 /\ rel a f1
   -> incl'0 f2 f1 /\ rel a f1 /\ (forall result: (). rel a f2  -> rel a f2)
end
module M_fmap_view_view__qyi16167685763649721615__rel_unit__refines [#"fmap_view_view.rs" 52 4 52 38] (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 52 4 52 38
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap = "../../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span soption = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'1 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 =
    [%#sfmap'1] Map.get (view self) k
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 =
    [%#sfmap'1] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option) (f: t_FMap'0) =
    [%#sfmap_view_view'0] match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
        | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
        | _ -> true
        end
      | C_None -> true
      end
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_FMap'0
  
  function and_then_logic (self: t_Option'2) (f: Map.map t_FMap'0 t_Option'2) : t_Option'2 =
    [%#soption'0] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Option'0
  
  function and_then_logic'0 (self: t_Option'3) (f: Map.map t_Option'0 t_Option'3) : t_Option'3 =
    [%#soption'0] match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'3 =
    [%#soption'2] match self with
      | C_None'0 -> C_None'3
      | C_Some'0 x -> C_Some'3 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 =
    [%#sagree] if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'1] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'0] op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'3 =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'3 other
      | {_p1 = C_None'0} -> C_Some'3 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function total_op (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
  axiom total_op_spec: forall self: t_FMap'0, other: t_FMap'0. ([%#sfmap'7] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'3)  -> ([%#sfmap'8] forall k: t_K. C_Some'3 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap'0) (other: t_FMap'0) : t_Option'2 =
    [%#sfmap'2] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'3 then
      C_Some'2 (total_op self other)
    else
      C_None'2
  
  
  function associative'1 (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  axiom associative_spec'1: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'6] and_then_logic (op'1 a b) (fun (ab: t_FMap'0) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap'0) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'0: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'5] op'1 a b = op'1 b a
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. [%#sfmap'9] len self >= 0
  
  constant empty  : t_FMap'0
  
  axiom empty_spec: [%#sfmap'3] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'4] view empty = Const.const (C_None'0)
  
  constant unit': t_FMap'0 = [%#sfmap'0] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap] forall x: t_FMap'0 [op'1 x unit']. op'1 x unit' = C_Some'2 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap_view_view] forall a: t_Option. forall result: (). rel a unit'  -> rel a unit'
end
module M_fmap_view_view__qyi16167685763649721615__rel_none__refines [#"fmap_view_view.rs" 48 4 48 53] (* <MapRelation<K, V> as creusot_contracts::logic::ra::view::ViewRel> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 48 4 48 53
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  type t_K
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 =
    [%#sfmap] Map.get (view self) k
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 =
    [%#sfmap] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option) (f: t_FMap'0) =
    [%#sfmap_view_view'0] match a with
      | C_Some a'0 -> forall k: t_K. match get f k with
        | C_Some'0 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'1 v
        | _ -> true
        end
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap_view_view] forall a: t_Option. forall f: t_FMap'0. rel a f
   -> rel a f /\ (forall result: (). rel (C_None) f  -> rel (C_None) f)
end
module M_fmap_view_view__qyi9127813262067876198__clone__refines [#"fmap_view_view.rs" 159 4 159 27] (* <Fragment<K, V> as creusot_contracts::Clone> *)
  let%span sfmap_view_view = "fmap_view_view.rs" 159 4 159 27
  let%span sfmap_view_view'0 = "fmap_view_view.rs" 98 8 98 26
  let%span sfmap_view_view'1 = "fmap_view_view.rs" 78 12 78 81
  let%span sfmap_view_view'2 = "fmap_view_view.rs" 29 12 35 13
  let%span sfmap_view_view'3 = "fmap_view_view.rs" 40 15 40 31
  let%span sfmap_view_view'4 = "fmap_view_view.rs" 41 15 41 26
  let%span sfmap_view_view'5 = "fmap_view_view.rs" 42 14 42 30
  let%span sfmap_view_view'6 = "fmap_view_view.rs" 43 71 43 73
  let%span sfmap_view_view'7 = "fmap_view_view.rs" 46 15 46 30
  let%span sfmap_view_view'8 = "fmap_view_view.rs" 47 14 47 32
  let%span sfmap_view_view'9 = "fmap_view_view.rs" 48 54 48 56
  let%span sfmap_view_view'10 = "fmap_view_view.rs" 51 14 51 46
  let%span sfmap_view_view'11 = "fmap_view_view.rs" 52 39 52 41
  let%span sra = "../../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 79 8 79 34
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 240 14 243 5
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'1 = "../../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'2 = "../../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'3 = "../../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span soption'4 = "../../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'5 = "../../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'0 = "../../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'2 = "../../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sview = "../../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'0 = "../../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'1 = "../../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'2 = "../../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'3 = "../../../creusot-contracts/src/logic/ra/view.rs" 134 14 137 5
  let%span sview'4 = "../../../creusot-contracts/src/logic/ra/view.rs" 139 8 139 49
  let%span sview'5 = "../../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'6 = "../../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'7 = "../../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'8 = "../../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'9 = "../../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sresource = "../../../creusot-contracts/src/resource.rs" 48 12 48 22
  let%span smodel = "../../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Ag
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 =
    [%#soption] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 =
    [%#soption'5] match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'4] and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 =
    [%#sfmap'6] Map.get (view self) k
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'15] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'2)
   -> ([%#sfmap'16] forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 =
    [%#sfmap'9] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'11] and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'10] op'1 a b = op'1 b a
  
  type t_FMap'0
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_FMap'0
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'7] len self >= 0
  
  constant empty  : t_FMap
  
  axiom empty_spec: [%#sfmap'2] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'3] view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = [%#sfmap'14] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'13] forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function commutative'1 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'1: forall a: t_Option'1, b: t_Option'1. [%#soption'3] op'0 a b = op'0 b a
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 =
    [%#sagree'0] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
    end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 =
    [%#soption'1] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. [%#soption'0] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) =
    [%#sra] factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. ([%#sra'0] op'0 self other
  = C_Some'2 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 =
    [%#smapping] Map.get self a
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option'1. [%#sfmap'12] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'1 -> C_None'1
    | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    [%#sfmap'5] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in let _ = let _ = () in () in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'4] match factor'1 self factor'2 with
    | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
    | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
    end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some'0 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'4
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'4 =
    [%#sfmap'6] Map.get (view'0 self) k
  
  predicate rel [#"fmap_view_view.rs" 27 4 27 56] (a: t_Option'3) (f: t_FMap) =
    [%#sfmap_view_view'2] match a with
      | C_Some'3 a'0 -> forall k: t_K. match get f k with
        | C_Some'1 {t_Ag__0 = v} -> get'0 a'0 k = C_Some'4 v
        | _ -> true
        end
      | C_None'3 -> true
      end
  
  function rel_unit [#"fmap_view_view.rs" 52 4 52 38] (a: t_Option'3) : () =
    [%#sfmap_view_view'11] ()
  
  axiom rel_unit_spec: forall a: t_Option'3. [%#sfmap_view_view'10] rel a unit'
  
  function rel_none [#"fmap_view_view.rs" 48 4 48 53] (a: t_Option'3) (f: t_FMap) : () =
    [%#sfmap_view_view'9] ()
  
  axiom rel_none_spec: forall a: t_Option'3, f: t_FMap. ([%#sfmap_view_view'7] rel a f)
   -> ([%#sfmap_view_view'8] rel (C_None'3) f)
  
  function rel_mono [#"fmap_view_view.rs" 43 4 43 70] (a: t_Option'3) (f1: t_FMap) (f2: t_FMap) : () =
    [%#sfmap_view_view'6] ()
  
  axiom rel_mono_spec: forall a: t_Option'3, f1: t_FMap, f2: t_FMap. ([%#sfmap_view_view'3] rel a f1)
   -> ([%#sfmap_view_view'4] incl'0 f2 f1)  -> ([%#sfmap_view_view'5] rel a f2)
  
  function auth (self: t_View) : t_Option'3
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. [%#sview'9] rel (auth self) (frag self)
  
  type tuple'1  =
    { _p0'1: t_Option'3; _p1'1: t_Option'3 }
  
  function new (auth'0: t_Option'3) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option'3, frag'0: t_FMap. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'6] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'3, frag'0: t_FMap. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'7] frag (new auth'0 frag'0) = frag'0)
  
  function op'2 (self: t_View) (other: t_View) : t_Option =
    [%#sview'8] match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'3 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'3} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2: forall a: t_View, b: t_View, c: t_View. [%#sview'2] and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'1] op'2 a b = op'2 b a
  
  function new_frag (frag'0: t_FMap) : t_View =
    [%#sview'0] new (C_None'3) frag'0
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option =
    [%#sview'4] let _ = () in match factor'1 (frag self) (frag factor'3) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'3 a ; _p1'1 = C_None'3} -> C_Some (new (C_Some'3 a) f)
        | {_p0'1 = a1 ; _p1'1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. [%#sview'3] match factor'2 self factor'3 with
    | C_Some c -> op'2 factor'3 c = C_Some self
    | C_None -> forall c: t_View. op'2 factor'3 c <> C_Some self
    end
  
  predicate incl'1 (self: t_View) (other: t_View) =
    [%#sra] factor'2 other self <> C_None
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. ([%#sra'2] incl'1 a b)
   -> ([%#sra'3] incl'1 b c)  -> ([%#sra'4] incl'1 a c)
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. ([%#sra'0] op'2 self other = C_Some comb)
   -> ([%#sra'1] incl'1 self comb)
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) =
    [%#sfmap'8] get self k <> C_None'1
  
  function insert (self: t_FMap) (k: t_K) (v: t_Ag) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_Ag. [%#sfmap'0] view (insert self k v)
  = Map.set (view self) k (C_Some'1 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_Ag. [%#sfmap'1] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  function singleton (k: t_K) (v: t_Ag) : t_FMap =
    [%#sfmap] insert empty k v
  
  function val' (self: t_Resource) : t_View
  
  function view'1 (self: t_Resource) : t_View =
    [%#sresource] val' self
  
  predicate invariant' [#"fmap_view_view.rs" 76 4 76 30] (self: t_Fragment) =
    [%#sfmap_view_view'1] incl'1 (new_frag (singleton self.t_Fragment__1 { t_Ag__0 = self.t_Fragment__2 })) (view'1 self.t_Fragment__0)
  
  predicate inv (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''0 (self: t_Fragment) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''0 x
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function view'2 [#"fmap_view_view.rs" 97 4 97 27] (self: t_Fragment) : tuple'2 =
    [%#sfmap_view_view'0] { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function view'3 (self: t_Fragment) : tuple'2 =
    [%#smodel] view'2 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap_view_view] forall self_: t_Fragment. inv'0 self_
   -> inv'0 self_ /\ (forall result: t_Fragment. view'2 result = view'3 self_ /\ inv result  -> inv result)
end
