module M_mapping_test__incr
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T = { t_T__a: Int32.t }
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  function view (self: t_T) : Map.map int int
  
  axiom view_spec: forall self: t_T. forall i: int. Map.get (view self) i
        = (if 0 <= i /\ i < Int32.to_int self.t_T__a then 1 else 0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec incr (t: MutBorrow.t t_T) (return (x: ())) = {[@expl:incr requires #0] 0 <= Int32.to_int t.current.t_T__a}
    {[@expl:incr requires #1] Int32.to_int t.current.t_T__a < 1000}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_t <- t ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = Int32.add {t.current.t_T__a} {(1: Int32.t)}
          (fun (_ret: Int32.t) -> [ &t <- { t with current = { t_T__a = _ret } } ] s1)
      | s1 = -{resolve t}- s2
      | s2 = {[@expl:assertion] view t.final = Map.set (view old_t.current) (Int32.to_int old_t.current.t_T__a) 1} s3
      | s3 = return {_0} ] ]
    [ & _0: () = Any.any_l () | & t: MutBorrow.t t_T = t | & old_t: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: ()) -> {[@expl:incr ensures] view t.final
      = Map.set (view t.current) (Int32.to_int t.current.t_T__a) 1}
      (! return {result}) ]
end
module M_mapping_test__f
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T = { t_T__a: Int32.t }
  
  function view (self: t_T) : Map.map int int
  
  axiom view_spec: forall self: t_T. forall i: int. Map.get (view self) i
        = (if 0 <= i /\ i < Int32.to_int self.t_T__a then 1 else 0)
  
  let rec incr (t: MutBorrow.t t_T) (return (x: ())) = {[@expl:incr requires #0] 0 <= Int32.to_int t.current.t_T__a}
    {[@expl:incr requires #1] Int32.to_int t.current.t_T__a < 1000}
    any
    [ return (result: ()) -> {view t.final = Map.set (view t.current) (Int32.to_int t.current.t_T__a) 1}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- { t_T__a = (42: Int32.t) } ] s1
      | s1 = {[@expl:assertion] Map.get (view x) 13 = 1} s2
      | s2 = {[@expl:assertion] Map.get (view x) 42 = 0} s3
      | s3 = MutBorrow.borrow_mut <t_T> {x} (fun (_ret: MutBorrow.t t_T) -> [ &_8 <- _ret ] [ &x <- _ret.final ] s4)
      | s4 = MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_T) -> [ &_7 <- _ret ] [ &_8 <- { _8 with current = _ret.final } ] s5)
      | s5 = incr {_7} (fun (_ret: ()) -> [ &_6 <- _ret ] s6)
      | s6 = bb1 ]
    | bb1 = s0
      [ s0 = -{resolve _8}- s1
      | s1 = {[@expl:assertion] Map.get (view x) 13 = 1} s2
      | s2 = {[@expl:assertion] Map.get (view x) 42 = 1} s3
      | s3 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & _6: () = Any.any_l ()
    | & _7: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
