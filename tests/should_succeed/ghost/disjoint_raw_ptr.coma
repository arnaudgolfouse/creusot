module M_disjoint_raw_ptr__foo
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_PtrOwn
  
  type tuple = { f0: Opaque.ptr; f1: t_PtrOwn }
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches (_value: Int32.t) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : Int32.t
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  predicate inv (_1: Opaque.ptr)
  
  axiom inv_axiom [@rewrite]: forall x: Opaque.ptr [inv x]. inv x = true
  
  predicate invariant' (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self /\ metadata_matches (val' self) (metadata_logic (ptr self)) /\ inv (ptr self)
  
  predicate inv'0 (_1: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate inv'2 (_1: tuple)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple [inv'2 x]. inv'2 x = (let {f0 = x0; f1 = x1} = x in inv'1 x1)
  
  let rec new (v: Int32.t) (return (x: tuple)) = any
    [ return' (result: tuple) -> {inv'2 result} {ptr result.f1 = result.f0 /\ val' result.f1 = v} (! return {result}) ]
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 (_1: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_1: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  let rec deref_mut (self: MutBorrow.t t_PtrOwn) (return (x: MutBorrow.t t_PtrOwn)) =
    {[@expl:deref_mut 'self' type invariant] inv'3 self}
    any [ return' (result: MutBorrow.t t_PtrOwn) -> {inv'4 result} {result = self} (! return {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_PtrOwn) = inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 (_1: t_PtrOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PtrOwn [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_PtrOwn) = inv'0 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'6 (_1: t_PtrOwn)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_PtrOwn [inv'6 x]. inv'6 x = invariant''4 x
  
  let rec deref (self: t_PtrOwn) (return (x: t_PtrOwn)) = {[@expl:deref 'self' type invariant] inv'5 self}
    any [ return' (result: t_PtrOwn) -> {inv'6 result} {result = self} (! return {result}) ]
  
  let rec disjoint_lemma (own1: MutBorrow.t t_PtrOwn) (own2: t_PtrOwn) (return (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] inv'4 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] inv'6 own2}
    any
    [ return' (result: ()) -> {Ptr.addr_logic_u64 (ptr own1.current) <> Ptr.addr_logic_u64 (ptr own2)}
      {own1.current = own1.final}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  let rec new'0 (x: ()) (return (x'0: ())) = any [ return' (result: ()) -> {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec foo (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new {(1: Int32.t)} (fun (_ret: tuple) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &p1 <- _3.f0 ] s1
      | s1 = [ &own1 <- _3.f1 ] s2
      | s2 = new {(1: Int32.t)} (fun (_ret: tuple) -> [ &_6 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = [ &p2 <- _6.f0 ] s1
      | s1 = [ &own2 <- _6.f1 ] s2
      | s2 = {inv'1 own1}
        MutBorrow.borrow_mut <t_PtrOwn> {own1}
          (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_13 <- _ret ] -{inv'1 _ret.final}- [ &own1 <- _ret.final ] s3)
      | s3 = {inv'1 _13.current}
        MutBorrow.borrow_final <t_PtrOwn> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_12 <- _ret ] -{inv'1 _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s4)
      | s4 = deref_mut {_12} (fun (_ret: MutBorrow.t t_PtrOwn) -> [ &_11 <- _ret ] s5)
      | s5 = bb3 ]
    | bb3 = s0 [ s0 = [ &_17 <- own2 ] s1 | s1 = deref {_17} (fun (_ret: t_PtrOwn) -> [ &_15 <- _ret ] s2) | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv'0 _11.current}
        MutBorrow.borrow_final <t_PtrOwn> {_11.current} {MutBorrow.get_id _11}
          (fun (_ret: MutBorrow.t t_PtrOwn) ->
            [ &_10 <- _ret ] -{inv'0 _ret.final}-
            [ &_11 <- { _11 with current = _ret.final } ] s1)
      | s1 = disjoint_lemma {_10} {_15} (fun (_ret: ()) -> [ &_9 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'3 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = {[@expl:type invariant] inv'4 _11} s3
      | s3 = -{resolve'2 _11}- s4
      | s4 = new'0 {_8} (fun (_ret: ()) -> [ &_7 <- _ret ] s5)
      | s5 = bb6 ]
    | bb6 = s0 [ s0 = {[@expl:assertion] own1 <> own2} s1 | s1 = {[@expl:assertion] p1 <> p2} s2 | s2 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & p1: Opaque.ptr = Any.any_l ()
    | & own1: t_PtrOwn = Any.any_l ()
    | & _3: tuple = Any.any_l ()
    | & p2: Opaque.ptr = Any.any_l ()
    | & own2: t_PtrOwn = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _7: () = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & _10: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _11: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _12: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _13: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _15: t_PtrOwn = Any.any_l ()
    | & _17: t_PtrOwn = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
