module M_seq_iter__reverse_ghost [#"seq_iter.rs" 5 0 5 58]
  let%span sseq_iter = "seq_iter.rs" 7 18 7 36
  let%span sseq_iter'0 = "seq_iter.rs" 11 8 11 11
  let%span sseq_iter'1 = "seq_iter.rs" 9 18 9 39
  let%span sseq_iter'2 = "seq_iter.rs" 10 20 10 48
  let%span sseq_iter'3 = "seq_iter.rs" 11 8 11 11
  let%span sseq_iter'4 = "seq_iter.rs" 5 24 5 25
  let%span sseq_iter'5 = "seq_iter.rs" 5 45 5 58
  let%span sseq_iter'6 = "seq_iter.rs" 4 10 4 35
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 444 4 444 31
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 442 14 442 38
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 725 17 725 21
  let%span sseq'2 = "../../../creusot-contracts/src/logic/seq.rs" 725 4 725 36
  let%span sseq'3 = "../../../creusot-contracts/src/logic/seq.rs" 724 14 724 29
  let%span sseq'4 = "../../../creusot-contracts/src/logic/seq.rs" 776 20 776 47
  let%span sseq'5 = "../../../creusot-contracts/src/logic/seq.rs" 768 17 768 21
  let%span sseq'6 = "../../../creusot-contracts/src/logic/seq.rs" 768 4 768 35
  let%span sseq'7 = "../../../creusot-contracts/src/logic/seq.rs" 764 14 767 5
  let%span sseq'8 = "../../../creusot-contracts/src/logic/seq.rs" 513 33 513 37
  let%span sseq'9 = "../../../creusot-contracts/src/logic/seq.rs" 513 39 513 40
  let%span sseq'10 = "../../../creusot-contracts/src/logic/seq.rs" 512 14 512 41
  let%span sseq'11 = "../../../creusot-contracts/src/logic/seq.rs" 785 4 785 49
  let%span sseq'12 = "../../../creusot-contracts/src/logic/seq.rs" 789 4 789 34
  let%span sseq'13 = "../../../creusot-contracts/src/logic/seq.rs" 790 4 790 34
  let%span sseq'14 = "../../../creusot-contracts/src/logic/seq.rs" 791 4 791 44
  let%span sseq'15 = "../../../creusot-contracts/src/logic/seq.rs" 781 20 781 41
  let%span sseq'16 = "../../../creusot-contracts/src/logic/seq.rs" 249 8 249 27
  let%span sseq'17 = "../../../creusot-contracts/src/logic/seq.rs" 711 20 711 91
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 202 22 202 26
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 202 4 204 17
  let%span sghost'1 = "../../../creusot-contracts/src/ghost.rs" 200 14 200 29
  let%span sghost'2 = "../../../creusot-contracts/src/ghost.rs" 180 15 180 16
  let%span sghost'3 = "../../../creusot-contracts/src/ghost.rs" 180 4 182 17
  let%span sghost'4 = "../../../creusot-contracts/src/ghost.rs" 178 14 178 26
  let%span sghost'5 = "../../../creusot-contracts/src/ghost.rs" 117 8 117 18
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sboxed = "../../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use seq.Seq
  use mach.int.Int
  use seq.Reverse
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_0: t_T)
  
  predicate invariant' (self: t_T) = [%#sboxed] inv self
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    [%#sseq'17] forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) = [%#sghost'5] inv'1 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  let rec new (return' (x: Seq.seq t_T)) = any
    [ return''0 (result: Seq.seq t_T) -> {[%#sseq] inv'2 result}
      {[%#sseq'0] result = (Seq.empty: Seq.seq t_T)}
      (! return' {result}) ]
  
  let rec into_inner (self: Seq.seq t_T) (return' (x: Seq.seq t_T)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'2 self}
    any
    [ return''0 (result: Seq.seq t_T) -> {[%#sghost'0] inv'1 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  predicate inv'3 (_0: t_SeqIter)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_SeqIter [inv'3 x]. inv'3 x
      = match x with
        | {t_SeqIter__inner = inner} -> inv'1 inner
        end
  
  function view (self: t_SeqIter) : Seq.seq t_T
  
  let rec into_iter (self: Seq.seq t_T) (return' (x: t_SeqIter)) =
    {[@expl:into_iter 'self' type invariant] [%#sseq'1] inv'1 self}
    any
    [ return''0 (result: t_SeqIter) -> {[%#sseq'2] inv'3 result} {[%#sseq'3] view result = self} (! return' {result}) ]
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  predicate produces (self: t_SeqIter) (visited: Seq.seq t_T) (o: t_SeqIter) =
    [%#sseq'4] view self = Seq.(++) visited (view o)
  
  function produces_trans (a: t_SeqIter) (ab: Seq.seq t_T) (b: t_SeqIter) (bc: Seq.seq t_T) (c: t_SeqIter) : ()
  
  axiom produces_trans_spec:
    forall a: t_SeqIter, ab: Seq.seq t_T, b: t_SeqIter, bc: Seq.seq t_T, c: t_SeqIter. ([%#sseq'12] produces a ab b)
      -> ([%#sseq'13] produces b bc c) -> ([%#sseq'14] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_SeqIter) : ()
  
  axiom produces_refl_spec: forall self: t_SeqIter. [%#sseq'11] produces self (Seq.empty: Seq.seq t_T) self
  
  type t_Option = C_None | C_Some t_T
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_SeqIter) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 (_0: MutBorrow.t t_SeqIter)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_SeqIter [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 (_0: t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  function view'0 [@inline:trivial] (self: MutBorrow.t t_SeqIter) : Seq.seq t_T = [%#smodel] view self.current
  
  meta "rewrite_def" function view'0
  
  predicate completed (self: MutBorrow.t t_SeqIter) = [%#sseq'15] view'0 self = (Seq.empty: Seq.seq t_T)
  
  let rec next (self: MutBorrow.t t_SeqIter) (return' (x: t_Option)) =
    {[@expl:next 'self' type invariant] [%#sseq'5] inv'4 self}
    any
    [ return''0 (result: t_Option) -> {[%#sseq'6] inv'5 result}
      {[%#sseq'7] match result with
        | C_None -> completed self
        | C_Some v -> produces self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_SeqIter) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_SeqIter) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 (_0: MutBorrow.t (Seq.seq t_T))
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t (Seq.seq t_T) [inv'6 x]. inv'6 x = invariant''3 x
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = [%#sseq'16] Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  let rec push_front_ghost (self: MutBorrow.t (Seq.seq t_T)) (x: t_T) (return' (x'0: ())) =
    {[@expl:push_front_ghost 'self' type invariant] [%#sseq'8] inv'6 self}
    {[@expl:push_front_ghost 'x' type invariant] [%#sseq'9] inv x}
    any [ return''0 (result: ()) -> {[%#sseq'10] self.final = push_front self.current x} (! return' {result}) ]
  
  let rec new'0 (x: Seq.seq t_T) (return' (x'0: Seq.seq t_T)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'1 x}
    any
    [ return''0 (result: Seq.seq t_T) -> {[%#sghost'3] inv'2 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec reverse_ghost [#"seq_iter.rs" 5 0 5 58] (s: Seq.seq t_T) (return' (x: Seq.seq t_T)) =
    {[@expl:reverse_ghost 's' type invariant] [%#sseq_iter'4] inv'2 s}
    (! bb0
    [ bb0 = s0 [ s0 = [ &len <- [%#sseq_iter] Seq.length s'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: Seq.seq t_T) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_inner {_7} (fun (_ret: Seq.seq t_T) -> [ &result <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = into_inner {s'0} (fun (_ret: Seq.seq t_T) -> [ &_10 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_iter {_10} (fun (_ret: t_SeqIter) -> [ &iter <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &iter_old <- [%#sseq_iter'0] iter ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &produced <- [%#sseq_iter'0] Seq.empty: Seq.seq t_T ] s1 | s1 = bb8 ]
    | bb8 = bb8invariant
      [ bb8'0 = {[@expl:loop variant] well_founded_relation variant_old_bb8 (len - Seq.length produced)} bb8invariant
      | bb8invariant = {[@expl:for invariant] [%#sseq_iter'0] inv'1 produced}
        {[@expl:for invariant] [%#sseq_iter'0] inv'3 iter}
        {[@expl:for invariant] [%#sseq_iter'0] produces iter_old produced iter}
        {[@expl:loop invariant] [%#sseq_iter'2] result = Reverse.reverse produced}
        (! [ &variant_old_bb8 <- [%#sseq_iter'1] len - Seq.length produced ] s0)
        [ s0 = bb9 ]
        [ bb9 = s0
          [ s0 = {inv'3 iter}
            MutBorrow.borrow_mut <t_SeqIter> {iter}
              (fun (_ret: MutBorrow.t t_SeqIter) -> [ &_25 <- _ret ] -{inv'3 _ret.final}- [ &iter <- _ret.final ] s1)
          | s1 = {inv'3 _25.current}
            MutBorrow.borrow_final <t_SeqIter> {_25.current} {MutBorrow.get_id _25}
              (fun (_ret: MutBorrow.t t_SeqIter) ->
                [ &_24 <- _ret ] -{inv'3 _ret.final}-
                [ &_25 <- { _25 with current = _ret.final } ] s2)
          | s2 = next {_24} (fun (_ret: t_Option) -> [ &_23 <- _ret ] s3)
          | s3 = bb10 ]
        | bb10 = s0
          [ s0 = {[@expl:type invariant] inv'4 _25} s1
          | s1 = -{resolve'0 _25}- s2
          | s2 = any [ br0 -> {_23 = C_None} (! bb13) | br1 (x0: t_T) -> {_23 = C_Some x0} (! bb14) ] ]
        | bb14 = s0
          [ s0 = v_Some {_23} (fun (r0: t_T) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_28 <- [%#sseq_iter'3] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb15 ]
        | bb15 = s0
          [ s0 = [ &produced <- _28 ] s1
          | s1 = [ &x <- __creusot_proc_iter_elem ] s2
          | s2 = {inv'1 result}
            MutBorrow.borrow_mut <Seq.seq t_T> {result}
              (fun (_ret: MutBorrow.t (Seq.seq t_T)) ->
                [ &_32 <- _ret ] -{inv'1 _ret.final}-
                [ &result <- _ret.final ] s3)
          | s3 = push_front_ghost {_32} {x} (fun (_ret: ()) -> [ &_31 <- _ret ] s4)
          | s4 = bb8'0 ] ] ]
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'3 iter} s1 | s1 = bb20 ]
    | bb20 = s0 [ s0 = new'0 {result} (fun (_ret: Seq.seq t_T) -> [ &_0 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = return''0 {_0} ]
    [ & _0: Seq.seq t_T = Any.any_l ()
    | & s'0: Seq.seq t_T = s
    | & len: int = Any.any_l ()
    | & result: Seq.seq t_T = Any.any_l ()
    | & _7: Seq.seq t_T = Any.any_l ()
    | & iter: t_SeqIter = Any.any_l ()
    | & _10: Seq.seq t_T = Any.any_l ()
    | & iter_old: t_SeqIter = Any.any_l ()
    | & produced: Seq.seq t_T = Any.any_l ()
    | & _23: t_Option = Any.any_l ()
    | & _24: MutBorrow.t t_SeqIter = Any.any_l ()
    | & _25: MutBorrow.t t_SeqIter = Any.any_l ()
    | & __creusot_proc_iter_elem: t_T = Any.any_l ()
    | & _28: Seq.seq t_T = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & _31: () = Any.any_l ()
    | & _32: MutBorrow.t (Seq.seq t_T) = Any.any_l ()
    | & variant_old_bb8: int = Any.any_l () ])
    [ return''0 (result: Seq.seq t_T) -> {[@expl:reverse_ghost result type invariant] [%#sseq_iter'5] inv'2 result}
      {[@expl:reverse_ghost ensures] [%#sseq_iter'6] result = Reverse.reverse s}
      (! return' {result}) ]
end
module M_seq_iter__reverse_ghost_ref [#"seq_iter.rs" 19 0 19 64]
  let%span sseq_iter = "seq_iter.rs" 21 18 21 36
  let%span sseq_iter'0 = "seq_iter.rs" 25 8 25 11
  let%span sseq_iter'1 = "seq_iter.rs" 23 18 23 39
  let%span sseq_iter'2 = "seq_iter.rs" 24 20 24 48
  let%span sseq_iter'3 = "seq_iter.rs" 25 8 25 11
  let%span sseq_iter'4 = "seq_iter.rs" 19 28 19 29
  let%span sseq_iter'5 = "seq_iter.rs" 19 50 19 64
  let%span sseq_iter'6 = "seq_iter.rs" 18 10 18 49
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 444 4 444 31
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 442 14 442 38
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 801 17 801 21
  let%span sseq'2 = "../../../creusot-contracts/src/logic/seq.rs" 801 4 801 40
  let%span sseq'3 = "../../../creusot-contracts/src/logic/seq.rs" 800 14 800 30
  let%span sseq'4 = "../../../creusot-contracts/src/logic/seq.rs" 850 8 850 53
  let%span sseq'5 = "../../../creusot-contracts/src/logic/seq.rs" 834 17 834 21
  let%span sseq'6 = "../../../creusot-contracts/src/logic/seq.rs" 834 4 834 39
  let%span sseq'7 = "../../../creusot-contracts/src/logic/seq.rs" 830 14 833 5
  let%span sseq'8 = "../../../creusot-contracts/src/logic/seq.rs" 513 33 513 37
  let%span sseq'9 = "../../../creusot-contracts/src/logic/seq.rs" 513 39 513 40
  let%span sseq'10 = "../../../creusot-contracts/src/logic/seq.rs" 512 14 512 41
  let%span sseq'11 = "../../../creusot-contracts/src/logic/seq.rs" 860 4 860 49
  let%span sseq'12 = "../../../creusot-contracts/src/logic/seq.rs" 864 4 864 34
  let%span sseq'13 = "../../../creusot-contracts/src/logic/seq.rs" 865 4 865 34
  let%span sseq'14 = "../../../creusot-contracts/src/logic/seq.rs" 866 4 866 44
  let%span sseq'15 = "../../../creusot-contracts/src/logic/seq.rs" 856 20 856 41
  let%span sseq'16 = "../../../creusot-contracts/src/logic/seq.rs" 249 8 249 27
  let%span sseq'17 = "../../../creusot-contracts/src/logic/seq.rs" 711 20 711 91
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 202 22 202 26
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 202 4 204 17
  let%span sghost'1 = "../../../creusot-contracts/src/ghost.rs" 200 14 200 29
  let%span sghost'2 = "../../../creusot-contracts/src/ghost.rs" 180 15 180 16
  let%span sghost'3 = "../../../creusot-contracts/src/ghost.rs" 180 4 182 17
  let%span sghost'4 = "../../../creusot-contracts/src/ghost.rs" 178 14 178 26
  let%span sghost'5 = "../../../creusot-contracts/src/ghost.rs" 117 8 117 18
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use seq.Seq
  use mach.int.Int
  use seq.Reverse
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_0: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = [%#sinvariant'0] inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 (self: t_T) = [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) =
    [%#sseq'17] forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: Seq.seq t_T) = [%#sghost'5] inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 (_0: Seq.seq t_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Seq.seq t_T [inv'3 x]. inv'3 x = invariant''2 x
  
  let rec new (return' (x: Seq.seq t_T)) = any
    [ return''0 (result: Seq.seq t_T) -> {[%#sseq] inv'3 result}
      {[%#sseq'0] result = (Seq.empty: Seq.seq t_T)}
      (! return' {result}) ]
  
  let rec into_inner (self: Seq.seq t_T) (return' (x: Seq.seq t_T)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'3 self}
    any
    [ return''0 (result: Seq.seq t_T) -> {[%#sghost'0] inv'2 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  predicate invariant''3 (self: t_T) = [%#sboxed] inv self
  
  predicate inv'4 (_0: t_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_T [inv'4 x]. inv'4 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: Seq.seq t_T) =
    [%#sseq'17] forall i: int. 0 <= i /\ i < Seq.length self -> inv'4 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'5 (_0: Seq.seq t_T)
  
  axiom inv_axiom'4 [@rewrite]: forall x: Seq.seq t_T [inv'5 x]. inv'5 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: Seq.seq t_T) = [%#sinvariant'0] inv'5 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'6 (_0: Seq.seq t_T)
  
  axiom inv_axiom'5 [@rewrite]: forall x: Seq.seq t_T [inv'6 x]. inv'6 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: Seq.seq t_T) = [%#sghost'5] inv'6 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'7 (_0: Seq.seq t_T)
  
  axiom inv_axiom'6 [@rewrite]: forall x: Seq.seq t_T [inv'7 x]. inv'7 x = invariant''6 x
  
  let rec into_inner'0 (self: Seq.seq t_T) (return' (x: Seq.seq t_T)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'7 self}
    any
    [ return''0 (result: Seq.seq t_T) -> {[%#sghost'0] inv'6 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_SeqIterRef = { t_SeqIterRef__inner: Seq.seq t_T; t_SeqIterRef__index: int }
  
  predicate invariant''7 (self: t_SeqIterRef)
  
  predicate inv'8 (_0: t_SeqIterRef)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_SeqIterRef [inv'8 x]. inv'8 x
      = (invariant''7 x
      /\ match x with
        | {t_SeqIterRef__inner = inner; t_SeqIterRef__index = index} -> inv'6 inner
        end)
  
  function view (self: t_SeqIterRef) : Seq.seq t_T
  
  let rec into_iter (self: Seq.seq t_T) (return' (x: t_SeqIterRef)) =
    {[@expl:into_iter 'self' type invariant] [%#sseq'1] inv'6 self}
    any
    [ return''0 (result: t_SeqIterRef) -> {[%#sseq'2] inv'8 result}
      {[%#sseq'3] view result = self}
      (! return' {result}) ]
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  predicate produces (self: t_SeqIterRef) (visited: Seq.seq t_T) (o: t_SeqIterRef) =
    [%#sseq'4] let visited'0 = visited in view self = Seq.(++) visited'0 (view o)
  
  function produces_trans (a: t_SeqIterRef) (ab: Seq.seq t_T) (b: t_SeqIterRef) (bc: Seq.seq t_T) (c: t_SeqIterRef) : ()
  
  axiom produces_trans_spec:
    forall a: t_SeqIterRef, ab: Seq.seq t_T, b: t_SeqIterRef, bc: Seq.seq t_T, c: t_SeqIterRef. ([%#sseq'12] produces a ab b)
      -> ([%#sseq'13] produces b bc c) -> ([%#sseq'14] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_SeqIterRef) : ()
  
  axiom produces_refl_spec: forall self: t_SeqIterRef. [%#sseq'11] produces self (Seq.empty: Seq.seq t_T) self
  
  type t_Option = C_None | C_Some t_T
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_SeqIterRef) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'9 (_0: MutBorrow.t t_SeqIterRef)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_SeqIterRef [inv'9 x]. inv'9 x = invariant''8 x
  
  predicate inv'10 (_0: t_Option)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  function view'0 [@inline:trivial] (self: MutBorrow.t t_SeqIterRef) : Seq.seq t_T = [%#smodel] view self.current
  
  meta "rewrite_def" function view'0
  
  predicate completed (self: MutBorrow.t t_SeqIterRef) = [%#sseq'15] view'0 self = (Seq.empty: Seq.seq t_T)
  
  let rec next (self: MutBorrow.t t_SeqIterRef) (return' (x: t_Option)) =
    {[@expl:next 'self' type invariant] [%#sseq'5] inv'9 self}
    any
    [ return''0 (result: t_Option) -> {[%#sseq'6] inv'10 result}
      {[%#sseq'7] match result with
        | C_None -> completed self
        | C_Some v -> produces self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_SeqIterRef) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_SeqIterRef) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'11 (_0: MutBorrow.t (Seq.seq t_T))
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t (Seq.seq t_T) [inv'11 x]. inv'11 x = invariant''9 x
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = [%#sseq'16] Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  let rec push_front_ghost (self: MutBorrow.t (Seq.seq t_T)) (x: t_T) (return' (x'0: ())) =
    {[@expl:push_front_ghost 'self' type invariant] [%#sseq'8] inv'11 self}
    {[@expl:push_front_ghost 'x' type invariant] [%#sseq'9] inv'0 x}
    any [ return''0 (result: ()) -> {[%#sseq'10] self.final = push_front self.current x} (! return' {result}) ]
  
  let rec new'0 (x: Seq.seq t_T) (return' (x'0: Seq.seq t_T)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'2 x}
    any
    [ return''0 (result: Seq.seq t_T) -> {[%#sghost'3] inv'3 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec reverse_ghost_ref [#"seq_iter.rs" 19 0 19 64] (s: Seq.seq t_T) (return' (x: Seq.seq t_T)) =
    {[@expl:reverse_ghost_ref 's' type invariant] [%#sseq_iter'4] inv'7 s}
    (! bb0
    [ bb0 = s0 [ s0 = [ &len <- [%#sseq_iter] Seq.length s'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: Seq.seq t_T) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_inner {_7} (fun (_ret: Seq.seq t_T) -> [ &result <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = into_inner'0 {s'0} (fun (_ret: Seq.seq t_T) -> [ &_10 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_iter {_10} (fun (_ret: t_SeqIterRef) -> [ &iter <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &iter_old <- [%#sseq_iter'0] iter ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &produced <- [%#sseq_iter'0] Seq.empty: Seq.seq t_T ] s1 | s1 = bb8 ]
    | bb8 = bb8invariant
      [ bb8'0 = {[@expl:loop variant] well_founded_relation variant_old_bb8 (len - Seq.length produced)} bb8invariant
      | bb8invariant = {[@expl:for invariant] [%#sseq_iter'0] inv'2 produced}
        {[@expl:for invariant] [%#sseq_iter'0] inv'8 iter}
        {[@expl:for invariant] [%#sseq_iter'0] produces iter_old produced iter}
        {[@expl:loop invariant] [%#sseq_iter'2] result = Reverse.reverse produced}
        (! [ &variant_old_bb8 <- [%#sseq_iter'1] len - Seq.length produced ] s0)
        [ s0 = bb9 ]
        [ bb9 = s0
          [ s0 = {inv'8 iter}
            MutBorrow.borrow_mut <t_SeqIterRef> {iter}
              (fun (_ret: MutBorrow.t t_SeqIterRef) -> [ &_25 <- _ret ] -{inv'8 _ret.final}- [ &iter <- _ret.final ] s1)
          | s1 = {inv'8 _25.current}
            MutBorrow.borrow_final <t_SeqIterRef> {_25.current} {MutBorrow.get_id _25}
              (fun (_ret: MutBorrow.t t_SeqIterRef) ->
                [ &_24 <- _ret ] -{inv'8 _ret.final}-
                [ &_25 <- { _25 with current = _ret.final } ] s2)
          | s2 = next {_24} (fun (_ret: t_Option) -> [ &_23 <- _ret ] s3)
          | s3 = bb10 ]
        | bb10 = s0
          [ s0 = {[@expl:type invariant] inv'9 _25} s1
          | s1 = -{resolve'0 _25}- s2
          | s2 = any [ br0 -> {_23 = C_None} (! bb13) | br1 (x0: t_T) -> {_23 = C_Some x0} (! bb14) ] ]
        | bb14 = s0
          [ s0 = v_Some {_23} (fun (r0: t_T) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_28 <- [%#sseq_iter'3] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb15 ]
        | bb15 = s0
          [ s0 = [ &produced <- _28 ] s1
          | s1 = [ &x <- __creusot_proc_iter_elem ] s2
          | s2 = {inv'2 result}
            MutBorrow.borrow_mut <Seq.seq t_T> {result}
              (fun (_ret: MutBorrow.t (Seq.seq t_T)) ->
                [ &_32 <- _ret ] -{inv'2 _ret.final}-
                [ &result <- _ret.final ] s3)
          | s3 = push_front_ghost {_32} {x} (fun (_ret: ()) -> [ &_31 <- _ret ] s4)
          | s4 = bb8'0 ] ] ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'8 iter} s1
      | s1 = new'0 {result} (fun (_ret: Seq.seq t_T) -> [ &_0 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = return''0 {_0} ]
    [ & _0: Seq.seq t_T = Any.any_l ()
    | & s'0: Seq.seq t_T = s
    | & len: int = Any.any_l ()
    | & result: Seq.seq t_T = Any.any_l ()
    | & _7: Seq.seq t_T = Any.any_l ()
    | & iter: t_SeqIterRef = Any.any_l ()
    | & _10: Seq.seq t_T = Any.any_l ()
    | & iter_old: t_SeqIterRef = Any.any_l ()
    | & produced: Seq.seq t_T = Any.any_l ()
    | & _23: t_Option = Any.any_l ()
    | & _24: MutBorrow.t t_SeqIterRef = Any.any_l ()
    | & _25: MutBorrow.t t_SeqIterRef = Any.any_l ()
    | & __creusot_proc_iter_elem: t_T = Any.any_l ()
    | & _28: Seq.seq t_T = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & _31: () = Any.any_l ()
    | & _32: MutBorrow.t (Seq.seq t_T) = Any.any_l ()
    | & variant_old_bb8: int = Any.any_l () ])
    [ return''0 (result: Seq.seq t_T) -> {[@expl:reverse_ghost_ref result type invariant] [%#sseq_iter'5] inv'3 result}
      {[@expl:reverse_ghost_ref ensures] [%#sseq_iter'6] result = Reverse.reverse s}
      (! return' {result}) ]
end
