module M_integers__in_ghost_block
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  let rec new (value: Int128.t) (return (x: int)) = any
    [ return (result: int) -> {result = Int128.to_int value} (! return {result}) ]
  
  let rec into_inner (self: int) (return (x: int)) = any [ return (result: int) -> {result = self} (! return {result}) ]
  
  let rec new'0 (x: int) (return (x'0: int)) = any [ return (result: int) -> {result = x} (! return {result}) ]
  
  let rec deref (self: int) (return (x: int)) = any [ return (result: int) -> {result = self} (! return {result}) ]
  
  let rec add (self: int) (other: int) (return (x: int)) = any
    [ return (result: int) -> {result = self + other} (! return {result}) ]
  
  let rec mul (self: int) (other: int) (return (x: int)) = any
    [ return (result: int) -> {result = self * other} (! return {result}) ]
  
  let rec new'1 (x: ()) (return (x'0: ())) = any [ return (result: ()) -> {result = x} (! return {result}) ]
  
  let rec ghost_function (x: int) (y: int) (z: int) (return (x'0: int)) = any
    [ return (result: int) -> {result = x + Int.mod y z} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec in_ghost_block (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new {(1: Int128.t)} (fun (_ret: int) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_inner {_3} (fun (_ret: int) -> [ &_2 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = new'0 {_2} (fun (_ret: int) -> [ &x <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {(2: Int128.t)} (fun (_ret: int) -> [ &_7 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_inner {_7} (fun (_ret: int) -> [ &y <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = deref {x} (fun (_ret: int) -> [ &_10 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = add {_10} {y} (fun (_ret: int) -> [ &z <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = new {(3: Int128.t)} (fun (_ret: int) -> [ &_16 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = into_inner {_16} (fun (_ret: int) -> [ &_15 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0 [ s0 = mul {z} {_15} (fun (_ret: int) -> [ &w <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0
      [ s0 = {[@expl:assertion] w = 9} s1 | s1 = new'1 {_5} (fun (_ret: ()) -> [ &_4 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0 [ s0 = new {(4: Int128.t)} (fun (_ret: int) -> [ &_23 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = into_inner {_23} (fun (_ret: int) -> [ &_22 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = new {(13: Int128.t)} (fun (_ret: int) -> [ &_25 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0 [ s0 = into_inner {_25} (fun (_ret: int) -> [ &_24 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = new {(5: Int128.t)} (fun (_ret: int) -> [ &_27 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = s0 [ s0 = into_inner {_27} (fun (_ret: int) -> [ &_26 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0 [ s0 = ghost_function {_22} {_24} {_26} (fun (_ret: int) -> [ &x'0 <- _ret ] s1) | s1 = bb18 ]
    | bb18 = s0
      [ s0 = {[@expl:assertion] x'0 = 7} s1 | s1 = new'1 {_20} (fun (_ret: ()) -> [ &_19 <- _ret ] s2) | s2 = bb19 ]
    | bb19 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & x: int = Any.any_l ()
    | & _2: int = Any.any_l ()
    | & _3: int = Any.any_l ()
    | & _4: () = Any.any_l ()
    | & _5: () = Any.any_l ()
    | & y: int = Any.any_l ()
    | & _7: int = Any.any_l ()
    | & z: int = Any.any_l ()
    | & _10: int = Any.any_l ()
    | & w: int = Any.any_l ()
    | & _15: int = Any.any_l ()
    | & _16: int = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _20: () = Any.any_l ()
    | & x'0: int = Any.any_l ()
    | & _22: int = Any.any_l ()
    | & _23: int = Any.any_l ()
    | & _24: int = Any.any_l ()
    | & _25: int = Any.any_l ()
    | & _26: int = Any.any_l ()
    | & _27: int = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_integers__ghost_function
  use mach.int.Int
  use creusot.prelude.Any
  
  let rec rem (self: int) (other: int) (return (x: int)) = any
    [ return (result: int) -> {result = Int.mod self other} (! return {result}) ]
  
  let rec add (self: int) (other: int) (return (x: int)) = any
    [ return (result: int) -> {result = self + other} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ghost_function (x: int) (y: int) (z: int) (return (x'0: int)) = (! bb0
    [ bb0 = s0 [ s0 = rem {y} {z} (fun (_ret: int) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = add {x} {_6} (fun (_ret: int) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: int = Any.any_l () | & x: int = x | & y: int = y | & z: int = z | & _6: int = Any.any_l () ])
    [ return (result: int) -> {[@expl:ghost_function ensures] result = x + Int.mod y z} (! return {result}) ]
end
