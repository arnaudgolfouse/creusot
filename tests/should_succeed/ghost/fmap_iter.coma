module M_complicated_identity
  use map.Map
  use mach.int.Int
  use map.Const
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_Ghost_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_Ghost_FMap_K_V
  
  predicate inv_Ghost_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_Ghost_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_Ghost_FMap_K_V
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_V empty_K = Const.const (None)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  let rec new_K (return (x: t_FMap_K_V)) = any
    [ return (result: t_FMap_K_V) -> {inv_Ghost_FMap_K_V result} {is_empty_K result} (! return {result}) ]
  
  let rec into_inner_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMap_K_V)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_FMap_K_V self}
    any [ return (result: t_FMap_K_V) -> {inv_FMap_K_V result} {result = self} (! return {result}) ]
  
  type t_FMapIter_K_V
  
  predicate inv_FMapIter_K_V (_1: t_FMapIter_K_V)
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V
  
  let rec into_iter_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMapIter_K_V)) =
    {[@expl:into_iter 'self' type invariant] inv_FMap_K_V self}
    any
    [ return (result: t_FMapIter_K_V) -> {inv_FMapIter_K_V result}
      {view_FMapIter_K_V result = self}
      (! return {result}) ]
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  type t_Option_tup2_K_V = None'0 | Some'0 tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some'0 { f0 = k; f1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  function produces_trans_FMapIter_K_V (a: t_FMapIter_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMapIter_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMapIter_K_V) : ()
  
  axiom produces_trans_FMapIter_K_V_spec:
    forall a: t_FMapIter_K_V, ab: Seq.seq tup2_K_V, b: t_FMapIter_K_V, bc: Seq.seq tup2_K_V, c: t_FMapIter_K_V. produces_FMapIter_K_V a ab b
      -> produces_FMapIter_K_V b bc c -> produces_FMapIter_K_V a (Seq.(++) ab bc) c
  
  function produces_refl_FMapIter_K_V (self: t_FMapIter_K_V) : ()
  
  axiom produces_refl_FMapIter_K_V_spec:
    forall self: t_FMapIter_K_V. produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate invariant_Box_tup2_K_V_Global (self: tup2_K_V) = inv_tup2_K_V self
  
  predicate inv_Box_tup2_K_V_Global [@inline:trivial] (_1: tup2_K_V) = invariant_Box_tup2_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_tup2_K_V_Global
  
  predicate invariant_Seq_tup2_K_V [@inline:trivial] (self: Seq.seq tup2_K_V) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_tup2_K_V_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_tup2_K_V
  
  predicate inv_Seq_tup2_K_V [@inline:trivial] (_1: Seq.seq tup2_K_V) = invariant_Seq_tup2_K_V _1
  
  meta "rewrite_def" predicate inv_Seq_tup2_K_V
  
  predicate invariant_ref_FMapIter_K_V [@inline:trivial] (self: MutBorrow.t t_FMapIter_K_V) =
    inv_FMapIter_K_V self.current /\ inv_FMapIter_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMapIter_K_V
  
  predicate inv_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = invariant_ref_FMapIter_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMapIter_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_tup2_K_V f0'0
        end
  
  predicate completed_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) = is_empty_K (view_FMapIter_K_V self.current)
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  let rec next_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:next 'self' type invariant] inv_ref_FMapIter_K_V self}
    any
    [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result}
      {match result with
        | None'0 -> completed_FMapIter_K_V self
        | Some'0 {f0 = k; f1 = v} -> produces_FMapIter_K_V self.current (Seq.singleton { f0 = k; f1 = v }) self.final
        /\ view_FMapIter_K_V self.current = insert_K (view_FMapIter_K_V self.final) k v
        end}
      (! return {result}) ]
  
  predicate resolve_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FMapIter_K_V
  
  let rec elim_Some (input: t_Option_tup2_K_V) (ret (f0'0: tup2_K_V)) = any
    [ good (f0'0: tup2_K_V) -> {Some'0 f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: tup2_K_V [Some'0 f0'0: t_Option_tup2_K_V]. Some'0 f0'0 <> input} (! {false} any) ]
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: MutBorrow.t t_FMap_K_V) =
    inv_FMap_K_V self.current /\ inv_FMap_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: MutBorrow.t t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate inv_Option_V (_1: t_Option_V)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_V [inv_Option_V x]. inv_Option_V x
      = match x with
        | None -> true
        | Some f0'0 -> inv_V f0'0
        end
  
  let rec insert_ghost_K (self: MutBorrow.t t_FMap_K_V) (key: t_K) (value: t_V) (return (x: t_Option_V)) =
    {[@expl:insert_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    {[@expl:insert_ghost 'key' type invariant] inv_K key}
    {[@expl:insert_ghost 'value' type invariant] inv_V value}
    any
    [ return (result: t_Option_V) -> {inv_Option_V result}
      {self.final = insert_K self.current key value}
      {result = get_K self.current key}
      (! return {result}) ]
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Option_V (_1: t_Option_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_V [resolve_Option_V x]. resolve_Option_V x
      = match x with
        | None -> true
        | Some x0 -> resolve_V x0
        end
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_FMap_K_V (self: t_FMap_K_V) =
    forall k: t_K, v: t_V. get_K self k = Some v -> resolve_K k /\ resolve_V v
  
  predicate resolve_FMap_K_V'0 (_1: t_FMap_K_V)
  
  axiom resolve_axiom'0: forall x: t_FMap_K_V [resolve_FMap_K_V'0 x]. resolve_FMap_K_V'0 x -> resolve_FMap_K_V x
  
  predicate resolve_FMapIter_K_V (self: t_FMapIter_K_V) = resolve_FMap_K_V'0 (view_FMapIter_K_V self)
  
  predicate resolve_FMapIter_K_V'0 (_1: t_FMapIter_K_V)
  
  axiom resolve_axiom'1: forall x: t_FMapIter_K_V [resolve_FMapIter_K_V'0 x]. resolve_FMapIter_K_V'0 x
      -> resolve_FMapIter_K_V x
  
  let rec new_FMap_K_V (x: t_FMap_K_V) (return (x'0: t_FMap_K_V)) = {[@expl:new 'x' type invariant] inv_FMap_K_V x}
    any [ return (result: t_FMap_K_V) -> {inv_Ghost_FMap_K_V result} {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec complicated_identity_K (m: t_FMap_K_V) (return (x: t_FMap_K_V)) =
    {[@expl:complicated_identity 'm' type invariant] inv_Ghost_FMap_K_V m}
    (! bb0
    [ bb0 = s0 [ s0 = new_K (fun (_ret: t_FMap_K_V) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_inner_FMap_K_V {_5} (fun (_ret: t_FMap_K_V) -> [ &result <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &len <- len_K m ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &m_snap <- m ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_inner_FMap_K_V {m} (fun (_ret: t_FMap_K_V) -> [ &_12 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = into_iter_FMap_K_V {_12} (fun (_ret: t_FMapIter_K_V) -> [ &iter <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb7 ]
    | bb7 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq tup2_K_V ] s1 | s1 = bb9 ]
    | bb9 = bb9invariant
      [ bb9 = {[@expl:loop variant] well_founded_relation_Int variant_old_bb9 (len - Seq.length produced)} bb9invariant
      | bb9invariant = {[@expl:for invariant] inv_Seq_tup2_K_V produced}
        {[@expl:for invariant] inv_FMapIter_K_V iter}
        {[@expl:for invariant] produces_FMapIter_K_V iter_old produced iter}
        {[@expl:loop invariant] forall k'0: t_K, v'0: t_V. (get_K m_snap k'0 = Some v'0)
          = (get_K result k'0 = Some v'0 \/ get_K (view_FMapIter_K_V iter) k'0 = Some v'0)}
        (! [ &variant_old_bb9 <- len - Seq.length produced ] s0)
        [ s0 = bb10 ]
        [ bb10 = s0
          [ s0 = {inv_FMapIter_K_V iter}
            MutBorrow.borrow_mut <t_FMapIter_K_V> {iter}
              (fun (_ret: MutBorrow.t t_FMapIter_K_V) ->
                [ &_27 <- _ret ] -{inv_FMapIter_K_V _ret.final}-
                [ &iter <- _ret.final ] s1)
          | s1 = {inv_FMapIter_K_V _27.current}
            MutBorrow.borrow_final <t_FMapIter_K_V> {_27.current} {MutBorrow.get_id _27}
              (fun (_ret: MutBorrow.t t_FMapIter_K_V) ->
                [ &_26 <- _ret ] -{inv_FMapIter_K_V _ret.final}-
                [ &_27 <- { _27 with current = _ret.final } ] s2)
          | s2 = next_FMapIter_K_V {_26} (fun (_ret: t_Option_tup2_K_V) -> [ &_25 <- _ret ] s3)
          | s3 = bb11 ]
        | bb11 = s0
          [ s0 = {[@expl:type invariant] inv_ref_FMapIter_K_V _27} s1
          | s1 = -{resolve_ref_FMapIter_K_V _27}- s2
          | s2 = any [ br0 -> {_25 = None'0} (! bb14) | br1 (x0: tup2_K_V) -> {_25 = Some'0 x0} (! bb15) ] ]
        | bb15 = s0
          [ s0 = elim_Some {_25} (fun (r0: tup2_K_V) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_30 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb16 ]
        | bb16 = s0
          [ s0 = [ &produced <- _30 ] s1
          | s1 = [ &k <- __creusot_proc_iter_elem.f0 ] s2
          | s2 = [ &v <- __creusot_proc_iter_elem.f1 ] s3
          | s3 = {inv_FMap_K_V result}
            MutBorrow.borrow_mut <t_FMap_K_V> {result}
              (fun (_ret: MutBorrow.t t_FMap_K_V) ->
                [ &_35 <- _ret ] -{inv_FMap_K_V _ret.final}-
                [ &result <- _ret.final ] s4)
          | s4 = insert_ghost_K {_35} {k} {v} (fun (_ret: t_Option_V) -> [ &_34 <- _ret ] s5)
          | s5 = {[@expl:type invariant] inv_Option_V _34} s6
          | s6 = -{resolve_Option_V _34}- s7
          | s7 = bb9 ] ] ]
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv_FMapIter_K_V iter} s1 | s1 = -{resolve_FMapIter_K_V'0 iter}- s2 | s2 = bb23 ]
    | bb23 = s0
      [ s0 = {[@expl:assertion] ext_eq_K result m_snap} s1
      | s1 = new_FMap_K_V {result} (fun (_ret: t_FMap_K_V) -> [ &_0 <- _ret ] s2)
      | s2 = bb24 ]
    | bb24 = return {_0} ]
    [ & _0: t_FMap_K_V = Any.any_l ()
    | & m: t_FMap_K_V = m
    | & result: t_FMap_K_V = Any.any_l ()
    | & _5: t_FMap_K_V = Any.any_l ()
    | & len: int = Any.any_l ()
    | & m_snap: t_FMap_K_V = Any.any_l ()
    | & iter: t_FMapIter_K_V = Any.any_l ()
    | & _12: t_FMap_K_V = Any.any_l ()
    | & iter_old: t_FMapIter_K_V = Any.any_l ()
    | & produced: Seq.seq tup2_K_V = Any.any_l ()
    | & _25: t_Option_tup2_K_V = Any.any_l ()
    | & _26: MutBorrow.t t_FMapIter_K_V = Any.any_l ()
    | & _27: MutBorrow.t t_FMapIter_K_V = Any.any_l ()
    | & __creusot_proc_iter_elem: tup2_K_V = Any.any_l ()
    | & _30: Seq.seq tup2_K_V = Any.any_l ()
    | & k: t_K = Any.any_l ()
    | & v: t_V = Any.any_l ()
    | & _34: t_Option_V = Any.any_l ()
    | & _35: MutBorrow.t t_FMap_K_V = Any.any_l ()
    | & variant_old_bb9: int = Any.any_l () ])
    [ return (result: t_FMap_K_V) -> {[@expl:complicated_identity result type invariant] inv_Ghost_FMap_K_V result}
      {[@expl:complicated_identity ensures] result = m}
      (! return {result}) ]
end
module M_merge_fmaps
  use map.Map
  use mach.int.Int
  use seq.Seq
  use creusot.prelude.MutBorrow
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_V
  
  type tup2_V_V = { f0: t_V; f1: t_V }
  
  type t_Option_V = None | Some t_V
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some x; f1'0 = Some y} -> get_K (merge_K self m f) k
          = Some (index_Mapping_tup2_V_V_V f { f0 = x; f1 = y })
          end
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_Ghost_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_Ghost_FMap_K_V
  
  predicate inv_Ghost_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_Ghost_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_Ghost_FMap_K_V
  
  let rec into_inner_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMap_K_V)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_FMap_K_V self}
    any [ return (result: t_FMap_K_V) -> {inv_FMap_K_V result} {result = self} (! return {result}) ]
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  type t_FMapIter_K_V
  
  predicate inv_FMapIter_K_V (_1: t_FMapIter_K_V)
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V
  
  let rec into_iter_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMapIter_K_V)) =
    {[@expl:into_iter 'self' type invariant] inv_FMap_K_V self}
    any
    [ return (result: t_FMapIter_K_V) -> {inv_FMapIter_K_V result}
      {view_FMapIter_K_V result = self}
      (! return {result}) ]
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  type t_Option_tup2_K_V = None'0 | Some'0 tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0'1 <> (Seq.get visited j).f0'1)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some'0 { f0'1 = k; f1'1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0'1 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  function produces_trans_FMapIter_K_V (a: t_FMapIter_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMapIter_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMapIter_K_V) : ()
  
  axiom produces_trans_FMapIter_K_V_spec:
    forall a: t_FMapIter_K_V, ab: Seq.seq tup2_K_V, b: t_FMapIter_K_V, bc: Seq.seq tup2_K_V, c: t_FMapIter_K_V. produces_FMapIter_K_V a ab b
      -> produces_FMapIter_K_V b bc c -> produces_FMapIter_K_V a (Seq.(++) ab bc) c
  
  function produces_refl_FMapIter_K_V (self: t_FMapIter_K_V) : ()
  
  axiom produces_refl_FMapIter_K_V_spec:
    forall self: t_FMapIter_K_V. produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'1 /\ inv_V _1.f1'1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate invariant_Box_tup2_K_V_Global (self: tup2_K_V) = inv_tup2_K_V self
  
  predicate inv_Box_tup2_K_V_Global [@inline:trivial] (_1: tup2_K_V) = invariant_Box_tup2_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_tup2_K_V_Global
  
  predicate invariant_Seq_tup2_K_V [@inline:trivial] (self: Seq.seq tup2_K_V) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_tup2_K_V_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_tup2_K_V
  
  predicate inv_Seq_tup2_K_V [@inline:trivial] (_1: Seq.seq tup2_K_V) = invariant_Seq_tup2_K_V _1
  
  meta "rewrite_def" predicate inv_Seq_tup2_K_V
  
  predicate invariant_ref_FMapIter_K_V [@inline:trivial] (self: MutBorrow.t t_FMapIter_K_V) =
    inv_FMapIter_K_V self.current /\ inv_FMapIter_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMapIter_K_V
  
  predicate inv_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = invariant_ref_FMapIter_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMapIter_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'2 -> inv_tup2_K_V f0'2
        end
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_V empty_K = Const.const (None)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  predicate completed_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) = is_empty_K (view_FMapIter_K_V self.current)
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  let rec next_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:next 'self' type invariant] inv_ref_FMapIter_K_V self}
    any
    [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result}
      {match result with
        | None'0 -> completed_FMapIter_K_V self
        | Some'0 {f0'1 = k; f1'1 = v} -> produces_FMapIter_K_V self.current (Seq.singleton { f0'1 = k;
                                                                                             f1'1 = v }) self.final
        /\ view_FMapIter_K_V self.current = insert_K (view_FMapIter_K_V self.final) k v
        end}
      (! return {result}) ]
  
  predicate resolve_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FMapIter_K_V
  
  let rec elim_Some (input: t_Option_tup2_K_V) (ret (f0'2: tup2_K_V)) = any
    [ good (f0'2: tup2_K_V) -> {Some'0 f0'2 = input} (! ret {f0'2})
    | bad -> {forall f0'2: tup2_K_V [Some'0 f0'2: t_Option_tup2_K_V]. Some'0 f0'2 <> input} (! {false} any) ]
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: MutBorrow.t t_FMap_K_V) =
    inv_FMap_K_V self.current /\ inv_FMap_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: MutBorrow.t t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate inv_Option_V (_1: t_Option_V)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_V [inv_Option_V x]. inv_Option_V x
      = match x with
        | None -> true
        | Some f0'2 -> inv_V f0'2
        end
  
  let rec insert_ghost_K (self: MutBorrow.t t_FMap_K_V) (key: t_K) (value: t_V) (return (x: t_Option_V)) =
    {[@expl:insert_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    {[@expl:insert_ghost 'key' type invariant] inv_K key}
    {[@expl:insert_ghost 'value' type invariant] inv_V value}
    any
    [ return (result: t_Option_V) -> {inv_Option_V result}
      {self.final = insert_K self.current key value}
      {result = get_K self.current key}
      (! return {result}) ]
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Option_V (_1: t_Option_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_V [resolve_Option_V x]. resolve_Option_V x
      = match x with
        | None -> true
        | Some x0 -> resolve_V x0
        end
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_FMap_K_V (self: t_FMap_K_V) =
    forall k: t_K, v: t_V. get_K self k = Some v -> resolve_K k /\ resolve_V v
  
  predicate resolve_FMap_K_V'0 (_1: t_FMap_K_V)
  
  axiom resolve_axiom'0: forall x: t_FMap_K_V [resolve_FMap_K_V'0 x]. resolve_FMap_K_V'0 x -> resolve_FMap_K_V x
  
  predicate resolve_FMapIter_K_V (self: t_FMapIter_K_V) = resolve_FMap_K_V'0 (view_FMapIter_K_V self)
  
  predicate resolve_FMapIter_K_V'0 (_1: t_FMapIter_K_V)
  
  axiom resolve_axiom'1: forall x: t_FMapIter_K_V [resolve_FMapIter_K_V'0 x]. resolve_FMapIter_K_V'0 x
      -> resolve_FMapIter_K_V x
  
  let rec new_FMap_K_V (x: t_FMap_K_V) (return (x'0: t_FMap_K_V)) = {[@expl:new 'x' type invariant] inv_FMap_K_V x}
    any [ return (result: t_FMap_K_V) -> {inv_Ghost_FMap_K_V result} {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec merge_fmaps_K (m1: t_FMap_K_V) (m2: t_FMap_K_V) (return (x: t_FMap_K_V)) =
    {[@expl:merge_fmaps 'm1' type invariant] inv_Ghost_FMap_K_V m1}
    {[@expl:merge_fmaps 'm2' type invariant] inv_Ghost_FMap_K_V m2}
    (! bb0
    [ bb0 = s0 [ s0 = [ &merge <- merge_K m1 m2 (fun (__0: tup2_V_V) -> let {f0 = v1} = __0 in v1) ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_inner_FMap_K_V {m2} (fun (_ret: t_FMap_K_V) -> [ &result <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &len <- len_K m1 ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = into_inner_FMap_K_V {m1} (fun (_ret: t_FMap_K_V) -> [ &_13 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_iter_FMap_K_V {_13} (fun (_ret: t_FMapIter_K_V) -> [ &iter <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq tup2_K_V ] s1 | s1 = bb8 ]
    | bb8 = bb8invariant
      [ bb8 = {[@expl:loop variant] well_founded_relation_Int variant_old_bb8 (len - Seq.length produced)} bb8invariant
      | bb8invariant = {[@expl:for invariant] inv_Seq_tup2_K_V produced}
        {[@expl:for invariant] inv_FMapIter_K_V iter}
        {[@expl:for invariant] produces_FMapIter_K_V iter_old produced iter}
        {[@expl:loop invariant #0] ext_eq_K merge (merge_K (view_FMapIter_K_V iter) result (fun (__0: tup2_V_V) -> let {f0 = v1} = __0 in v1))}
        {[@expl:loop invariant #1] inv_FMap_K_V result}
        (! [ &variant_old_bb8 <- len - Seq.length produced ] s0)
        [ s0 = bb9 ]
        [ bb9 = s0
          [ s0 = {inv_FMapIter_K_V iter}
            MutBorrow.borrow_mut <t_FMapIter_K_V> {iter}
              (fun (_ret: MutBorrow.t t_FMapIter_K_V) ->
                [ &_29 <- _ret ] -{inv_FMapIter_K_V _ret.final}-
                [ &iter <- _ret.final ] s1)
          | s1 = {inv_FMapIter_K_V _29.current}
            MutBorrow.borrow_final <t_FMapIter_K_V> {_29.current} {MutBorrow.get_id _29}
              (fun (_ret: MutBorrow.t t_FMapIter_K_V) ->
                [ &_28 <- _ret ] -{inv_FMapIter_K_V _ret.final}-
                [ &_29 <- { _29 with current = _ret.final } ] s2)
          | s2 = next_FMapIter_K_V {_28} (fun (_ret: t_Option_tup2_K_V) -> [ &_27 <- _ret ] s3)
          | s3 = bb10 ]
        | bb10 = s0
          [ s0 = {[@expl:type invariant] inv_ref_FMapIter_K_V _29} s1
          | s1 = -{resolve_ref_FMapIter_K_V _29}- s2
          | s2 = any [ br0 -> {_27 = None'0} (! bb13) | br1 (x0: tup2_K_V) -> {_27 = Some'0 x0} (! bb14) ] ]
        | bb14 = s0
          [ s0 = elim_Some {_27} (fun (r0: tup2_K_V) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_32 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb15 ]
        | bb15 = s0
          [ s0 = [ &produced <- _32 ] s1
          | s1 = [ &k <- __creusot_proc_iter_elem.f0'1 ] s2
          | s2 = [ &v <- __creusot_proc_iter_elem.f1'1 ] s3
          | s3 = {inv_FMap_K_V result}
            MutBorrow.borrow_mut <t_FMap_K_V> {result}
              (fun (_ret: MutBorrow.t t_FMap_K_V) ->
                [ &_37 <- _ret ] -{inv_FMap_K_V _ret.final}-
                [ &result <- _ret.final ] s4)
          | s4 = insert_ghost_K {_37} {k} {v} (fun (_ret: t_Option_V) -> [ &_36 <- _ret ] s5)
          | s5 = {[@expl:type invariant] inv_Option_V _36} s6
          | s6 = -{resolve_Option_V _36}- s7
          | s7 = bb8 ] ] ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_FMapIter_K_V iter} s1 | s1 = -{resolve_FMapIter_K_V'0 iter}- s2 | s2 = bb22 ]
    | bb22 = s0
      [ s0 = {[@expl:assertion] ext_eq_K result merge} s1
      | s1 = new_FMap_K_V {result} (fun (_ret: t_FMap_K_V) -> [ &_0 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = return {_0} ]
    [ & _0: t_FMap_K_V = Any.any_l ()
    | & m1: t_FMap_K_V = m1
    | & m2: t_FMap_K_V = m2
    | & merge: t_FMap_K_V = Any.any_l ()
    | & result: t_FMap_K_V = Any.any_l ()
    | & len: int = Any.any_l ()
    | & iter: t_FMapIter_K_V = Any.any_l ()
    | & _13: t_FMap_K_V = Any.any_l ()
    | & iter_old: t_FMapIter_K_V = Any.any_l ()
    | & produced: Seq.seq tup2_K_V = Any.any_l ()
    | & _27: t_Option_tup2_K_V = Any.any_l ()
    | & _28: MutBorrow.t t_FMapIter_K_V = Any.any_l ()
    | & _29: MutBorrow.t t_FMapIter_K_V = Any.any_l ()
    | & __creusot_proc_iter_elem: tup2_K_V = Any.any_l ()
    | & _32: Seq.seq tup2_K_V = Any.any_l ()
    | & k: t_K = Any.any_l ()
    | & v: t_V = Any.any_l ()
    | & _36: t_Option_V = Any.any_l ()
    | & _37: MutBorrow.t t_FMap_K_V = Any.any_l ()
    | & variant_old_bb8: int = Any.any_l () ])
    [ return (result: t_FMap_K_V) -> {[@expl:merge_fmaps result type invariant] inv_Ghost_FMap_K_V result}
      {[@expl:merge_fmaps ensures] result = merge_K m1 m2 (fun (__0: tup2_V_V) -> let {f0 = v1} = __0 in v1)}
      (! return {result}) ]
end
