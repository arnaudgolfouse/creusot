module M_fmap_iter__complicated_identity [#"fmap_iter.rs" 5 0 5 76]
  let%span sfmap_iter = "fmap_iter.rs" 8 18 8 36
  let%span sfmap_iter'0 = "fmap_iter.rs" 10 31 10 32
  let%span sfmap_iter'1 = "fmap_iter.rs" 14 8 14 11
  let%span sfmap_iter'2 = "fmap_iter.rs" 12 18 12 39
  let%span sfmap_iter'3 = "fmap_iter.rs" 13 20 13 116
  let%span sfmap_iter'4 = "fmap_iter.rs" 14 8 14 11
  let%span sfmap_iter'5 = "fmap_iter.rs" 18 8 18 46
  let%span sfmap_iter'6 = "fmap_iter.rs" 5 34 5 35
  let%span sfmap_iter'7 = "fmap_iter.rs" 5 59 5 76
  let%span sfmap_iter'8 = "fmap_iter.rs" 4 10 4 21
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 271 4 271 31
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 269 4 269 33
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 567 17 567 21
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 567 4 567 40
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 566 14 566 29
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 603 12 609 115
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 593 17 593 21
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 593 4 593 40
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 589 14 592 5
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 437 29 437 33
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 437 35 437 38
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 437 43 437 48
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/fmap.rs" 437 4 437 65
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/fmap.rs" 435 14 435 49
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/fmap.rs" 436 14 436 40
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/fmap.rs" 174 14 174 39
  let%span sfmap'17 = "../../../creusot-contracts/src/logic/fmap.rs" 177 12 177 35
  let%span sfmap'18 = "../../../creusot-contracts/src/logic/fmap.rs" 112 4 112 18
  let%span sfmap'19 = "../../../creusot-contracts/src/logic/fmap.rs" 619 4 619 49
  let%span sfmap'20 = "../../../creusot-contracts/src/logic/fmap.rs" 623 4 623 34
  let%span sfmap'21 = "../../../creusot-contracts/src/logic/fmap.rs" 624 4 624 34
  let%span sfmap'22 = "../../../creusot-contracts/src/logic/fmap.rs" 625 4 625 44
  let%span sfmap'23 = "../../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'24 = "../../../creusot-contracts/src/logic/fmap.rs" 615 20 615 36
  let%span sfmap'25 = "../../../creusot-contracts/src/logic/fmap.rs" 68 14 68 46
  let%span sfmap'26 = "../../../creusot-contracts/src/logic/fmap.rs" 69 14 69 88
  let%span sfmap'27 = "../../../creusot-contracts/src/logic/fmap.rs" 51 14 51 31
  let%span sfmap'28 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 43
  let%span sfmap'29 = "../../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span sfmap'30 = "../../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'31 = "../../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 203 22 203 26
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 203 4 205 17
  let%span sghost'1 = "../../../creusot-contracts/src/ghost.rs" 201 14 201 29
  let%span sghost'2 = "../../../creusot-contracts/src/ghost.rs" 181 15 181 16
  let%span sghost'3 = "../../../creusot-contracts/src/ghost.rs" 181 4 183 17
  let%span sghost'4 = "../../../creusot-contracts/src/ghost.rs" 179 14 179 26
  let%span sghost'5 = "../../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 74 8 74 82
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 712 20 712 91
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 772 8 775 9
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'1 = "../../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sboxed = "../../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span slogic = "../../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  
  use map.Map
  use mach.int.Int
  use map.Const
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = [%#sfmap'5] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = [%#sfmap'23] get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#slogic] exists x: t_V. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_V = [%#soption'1] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = [%#sfmap'31] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = [%#sfmap'30] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    [%#sfmap'29] forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_0: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_FMap) = [%#sghost'5] inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_0: t_FMap)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = [%#sfmap'17] forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'16] ext_eq self other = (self = other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'1] len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'27] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'28] view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = [%#sfmap'18] ext_eq self empty
  
  let rec new (return' (x: t_FMap)) = any
    [ return''0 (result: t_FMap) -> {[%#sfmap] inv'2 result} {[%#sfmap'0] is_empty result} (! return' {result}) ]
  
  let rec into_inner (self: t_FMap) (return' (x: t_FMap)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'2 self}
    any [ return''0 (result: t_FMap) -> {[%#sghost'0] inv'1 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  predicate inv'3 (_0: t_FMapIter)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapIter [inv'3 x]. inv'3 x
      = match x with
        | {t_FMapIter__inner = inner} -> inv'1 inner
        end
  
  function view'0 (self: t_FMapIter) : t_FMap
  
  let rec into_iter (self: t_FMap) (return' (x: t_FMapIter)) =
    {[@expl:into_iter 'self' type invariant] [%#sfmap'2] inv'1 self}
    any
    [ return''0 (result: t_FMapIter) -> {[%#sfmap'3] inv'3 result}
      {[%#sfmap'4] view'0 result = self}
      (! return' {result}) ]
  
  type tuple = { _p0: t_K; _p1: t_V }
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple
  
  function get'0 (self: Seq.seq tuple) (ix: int) : t_Option'0 = [%#sseq] if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple) (o: t_FMapIter) =
    [%#sfmap'6] (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i)._p0 <> (Seq.get visited j)._p0)
    /\ (forall k: t_K, v: t_V, i: int. get'0 visited i = C_Some'0 { _p0 = k; _p1 = v }
        -> not contains (view'0 o) k /\ get (view'0 self) k = C_Some v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i)._p0 <> k)
      -> get (view'0 o) k = get (view'0 self) k)
  
  function produces_trans (a: t_FMapIter) (ab: Seq.seq tuple) (b: t_FMapIter) (bc: Seq.seq tuple) (c: t_FMapIter) : ()
  
  axiom produces_trans_spec:
    forall a: t_FMapIter, ab: Seq.seq tuple, b: t_FMapIter, bc: Seq.seq tuple, c: t_FMapIter. ([%#sfmap'20] produces a ab b)
      -> ([%#sfmap'21] produces b bc c) -> ([%#sfmap'22] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_FMapIter) : ()
  
  axiom produces_refl_spec: forall self: t_FMapIter. [%#sfmap'19] produces self (Seq.empty: Seq.seq tuple) self
  
  predicate inv'4 (_0: tuple)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple [inv'4 x]. inv'4 x
      = (let {_p0 = x0; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate invariant''1 (self: tuple) = [%#sboxed] inv'4 self
  
  predicate inv'5 (_0: tuple)
  
  axiom inv_axiom'3 [@rewrite]: forall x: tuple [inv'5 x]. inv'5 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: Seq.seq tuple) =
    [%#sseq'0] forall i: int. 0 <= i /\ i < Seq.length self -> inv'5 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'6 (_0: Seq.seq tuple)
  
  axiom inv_axiom'4 [@rewrite]: forall x: Seq.seq tuple [inv'6 x]. inv'6 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_FMapIter) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'7 (_0: MutBorrow.t t_FMapIter)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_FMapIter [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate inv'8 (_0: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'4 a_0
        end
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_FMapIter) : t_FMap = [%#smodel] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  predicate completed (self: MutBorrow.t t_FMapIter) = [%#sfmap'24] is_empty (view'1 self)
  
  function insert (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'25] view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'26] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec next (self: MutBorrow.t t_FMapIter) (return' (x: t_Option'0)) =
    {[@expl:next 'self' type invariant] [%#sfmap'7] inv'7 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'8] inv'8 result}
      {[%#sfmap'9] match result with
        | C_None'0 -> completed self
        | C_Some'0 {_p0 = k; _p1 = v} -> produces self.current (Seq.singleton { _p0 = k; _p1 = v }) self.final
        /\ view'0 self.current = insert (view'0 self.final) k v
        end}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_FMapIter) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_FMapIter) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option'0) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate inv'10 (_0: t_Option)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_K) (value: t_V) (return' (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'10] inv'9 self}
    {[@expl:insert_ghost 'key' type invariant] [%#sfmap'11] inv key}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'12] inv'0 value}
    any
    [ return''0 (result: t_Option) -> {[%#sfmap'13] inv'10 result}
      {[%#sfmap'14] self.final = insert self.current key value}
      {[%#sfmap'15] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve'1 (_0: t_V)
  
  predicate resolve'2 [@inline:trivial] (self: t_Option) =
    [%#soption] match self with
      | C_Some x -> resolve'1 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: t_Option) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  let rec new'0 (x: t_FMap) (return' (x'0: t_FMap)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'1 x}
    any [ return''0 (result: t_FMap) -> {[%#sghost'3] inv'2 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec complicated_identity [#"fmap_iter.rs" 5 0 5 76] (m: t_FMap) (return' (x: t_FMap)) =
    {[@expl:complicated_identity 'm' type invariant] [%#sfmap_iter'6] inv'2 m}
    (! bb0
    [ bb0 = s0 [ s0 = new (fun (_ret: t_FMap) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_inner {_5} (fun (_ret: t_FMap) -> [ &result <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &len'0 <- [%#sfmap_iter] len m'0 ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &m_snap <- [%#sfmap_iter'0] m'0 ] s1 | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_inner {m'0} (fun (_ret: t_FMap) -> [ &_12 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = into_iter {_12} (fun (_ret: t_FMapIter) -> [ &iter <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &iter_old <- [%#sfmap_iter'1] iter ] s1 | s1 = bb7 ]
    | bb7 = s0 [ s0 = [ &produced <- [%#sfmap_iter'1] Seq.empty: Seq.seq tuple ] s1 | s1 = bb9 ]
    | bb9 = bb9invariant
      [ bb9'0 = {[@expl:loop variant] well_founded_relation variant_old_bb9 (len'0 - Seq.length produced)} bb9invariant
      | bb9invariant = {[@expl:for invariant] [%#sfmap_iter'1] inv'6 produced}
        {[@expl:for invariant] [%#sfmap_iter'1] inv'3 iter}
        {[@expl:for invariant] [%#sfmap_iter'1] produces iter_old produced iter}
        {[@expl:loop invariant] [%#sfmap_iter'3] forall k'0: t_K, v'0: t_V. (get m_snap k'0 = C_Some v'0)
          = (get result k'0 = C_Some v'0 \/ get (view'0 iter) k'0 = C_Some v'0)}
        (! [ &variant_old_bb9 <- [%#sfmap_iter'2] len'0 - Seq.length produced ] s0)
        [ s0 = bb10 ]
        [ bb10 = s0
          [ s0 = {inv'3 iter}
            MutBorrow.borrow_mut <t_FMapIter> {iter}
              (fun (_ret: MutBorrow.t t_FMapIter) -> [ &_27 <- _ret ] -{inv'3 _ret.final}- [ &iter <- _ret.final ] s1)
          | s1 = {inv'3 _27.current}
            MutBorrow.borrow_final <t_FMapIter> {_27.current} {MutBorrow.get_id _27}
              (fun (_ret: MutBorrow.t t_FMapIter) ->
                [ &_26 <- _ret ] -{inv'3 _ret.final}-
                [ &_27 <- { _27 with current = _ret.final } ] s2)
          | s2 = next {_26} (fun (_ret: t_Option'0) -> [ &_25 <- _ret ] s3)
          | s3 = bb11 ]
        | bb11 = s0
          [ s0 = {[@expl:type invariant] inv'7 _27} s1
          | s1 = -{resolve'0 _27}- s2
          | s2 = any [ br0 -> {_25 = C_None'0} (! bb14) | br1 (x0: tuple) -> {_25 = C_Some'0 x0} (! bb15) ] ]
        | bb15 = s0
          [ s0 = v_Some {_25} (fun (r0: tuple) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_30 <- [%#sfmap_iter'4] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb16 ]
        | bb16 = s0
          [ s0 = [ &produced <- _30 ] s1
          | s1 = [ &k <- __creusot_proc_iter_elem._p0 ] s2
          | s2 = [ &v <- __creusot_proc_iter_elem._p1 ] s3
          | s3 = {inv'1 result}
            MutBorrow.borrow_mut <t_FMap> {result}
              (fun (_ret: MutBorrow.t t_FMap) -> [ &_35 <- _ret ] -{inv'1 _ret.final}- [ &result <- _ret.final ] s4)
          | s4 = insert_ghost {_35} {k} {v} (fun (_ret: t_Option) -> [ &_34 <- _ret ] s5)
          | s5 = {[@expl:type invariant] inv'10 _34} s6
          | s6 = -{resolve'3 _34}- s7
          | s7 = bb9'0 ] ] ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'3 iter} s1 | s1 = bb23 ]
    | bb23 = s0
      [ s0 = {[@expl:assertion] [%#sfmap_iter'5] ext_eq result m_snap} s1
      | s1 = new'0 {result} (fun (_ret: t_FMap) -> [ &_0 <- _ret ] s2)
      | s2 = bb24 ]
    | bb24 = return''0 {_0} ]
    [ & _0: t_FMap = Any.any_l ()
    | & m'0: t_FMap = m
    | & result: t_FMap = Any.any_l ()
    | & _5: t_FMap = Any.any_l ()
    | & len'0: int = Any.any_l ()
    | & m_snap: t_FMap = Any.any_l ()
    | & iter: t_FMapIter = Any.any_l ()
    | & _12: t_FMap = Any.any_l ()
    | & iter_old: t_FMapIter = Any.any_l ()
    | & produced: Seq.seq tuple = Any.any_l ()
    | & _25: t_Option'0 = Any.any_l ()
    | & _26: MutBorrow.t t_FMapIter = Any.any_l ()
    | & _27: MutBorrow.t t_FMapIter = Any.any_l ()
    | & __creusot_proc_iter_elem: tuple = Any.any_l ()
    | & _30: Seq.seq tuple = Any.any_l ()
    | & k: t_K = Any.any_l ()
    | & v: t_V = Any.any_l ()
    | & _34: t_Option = Any.any_l ()
    | & _35: MutBorrow.t t_FMap = Any.any_l ()
    | & variant_old_bb9: int = Any.any_l () ])
    [ return''0 (result: t_FMap) -> {[@expl:complicated_identity result type invariant] [%#sfmap_iter'7] inv'2 result}
      {[@expl:complicated_identity ensures] [%#sfmap_iter'8] result = m}
      (! return' {result}) ]
end
module M_fmap_iter__merge_fmaps [#"fmap_iter.rs" 25 0 25 91]
  let%span sfmap_iter = "fmap_iter.rs" 27 20 27 58
  let%span sfmap_iter'0 = "fmap_iter.rs" 29 18 29 37
  let%span sfmap_iter'1 = "fmap_iter.rs" 34 8 34 11
  let%span sfmap_iter'2 = "fmap_iter.rs" 31 18 31 39
  let%span sfmap_iter'3 = "fmap_iter.rs" 33 20 33 31
  let%span sfmap_iter'4 = "fmap_iter.rs" 31 8 31 41
  let%span sfmap_iter'5 = "fmap_iter.rs" 34 8 34 11
  let%span sfmap_iter'6 = "fmap_iter.rs" 38 8 38 44
  let%span sfmap_iter'7 = "fmap_iter.rs" 25 25 25 27
  let%span sfmap_iter'8 = "fmap_iter.rs" 25 48 25 50
  let%span sfmap_iter'9 = "fmap_iter.rs" 25 74 25 91
  let%span sfmap_iter'10 = "fmap_iter.rs" 24 10 24 48
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 188 8 193 13
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 567 17 567 21
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 567 4 567 40
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 566 14 566 29
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 174 14 174 39
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 177 12 177 35
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 603 12 609 115
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 593 17 593 21
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 593 4 593 40
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 589 14 592 5
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 437 29 437 33
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 437 35 437 38
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 437 43 437 48
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/fmap.rs" 437 4 437 65
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/fmap.rs" 435 14 435 49
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/fmap.rs" 436 14 436 40
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'17 = "../../../creusot-contracts/src/logic/fmap.rs" 619 4 619 49
  let%span sfmap'18 = "../../../creusot-contracts/src/logic/fmap.rs" 623 4 623 34
  let%span sfmap'19 = "../../../creusot-contracts/src/logic/fmap.rs" 624 4 624 34
  let%span sfmap'20 = "../../../creusot-contracts/src/logic/fmap.rs" 625 4 625 44
  let%span sfmap'21 = "../../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'22 = "../../../creusot-contracts/src/logic/fmap.rs" 615 20 615 36
  let%span sfmap'23 = "../../../creusot-contracts/src/logic/fmap.rs" 68 14 68 46
  let%span sfmap'24 = "../../../creusot-contracts/src/logic/fmap.rs" 69 14 69 88
  let%span sfmap'25 = "../../../creusot-contracts/src/logic/fmap.rs" 553 20 553 76
  let%span sfmap'26 = "../../../creusot-contracts/src/logic/fmap.rs" 112 4 112 18
  let%span sfmap'27 = "../../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'28 = "../../../creusot-contracts/src/logic/fmap.rs" 51 14 51 31
  let%span sfmap'29 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 43
  let%span sfmap'30 = "../../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 203 22 203 26
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 203 4 205 17
  let%span sghost'1 = "../../../creusot-contracts/src/ghost.rs" 201 14 201 29
  let%span sghost'2 = "../../../creusot-contracts/src/ghost.rs" 181 15 181 16
  let%span sghost'3 = "../../../creusot-contracts/src/ghost.rs" 181 4 183 17
  let%span sghost'4 = "../../../creusot-contracts/src/ghost.rs" 179 14 179 26
  let%span sghost'5 = "../../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 74 8 74 82
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 712 20 712 91
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 772 8 775 9
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'1 = "../../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sboxed = "../../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span slogic = "../../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  
  use map.Map
  use mach.int.Int
  use seq.Seq
  use creusot.prelude.MutBorrow
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_V
  
  type tuple = { _p0: t_V; _p1: t_V }
  
  type t_Option = C_None | C_Some t_V
  
  type tuple'0 = { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = [%#sfmap'16] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function index_logic [@inline:trivial] (self: Map.map tuple t_V) (a: tuple) : t_V = [%#smapping] Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap] forall k: t_K [get (merge self m f) k]. match { _p0'0 = get self k;
                                                                                                                    _p1'0 = get m k } with
          | {_p0'0 = C_None; _p1'0 = y} -> get (merge self m f) k = y
          | {_p0'0 = x; _p1'0 = C_None} -> get (merge self m f) k = x
          | {_p0'0 = C_Some x; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
          end
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = [%#sfmap'21] get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#slogic] exists x: t_V. index_logic'0 p x)
      -> ([%#slogic'0] index_logic'0 p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_V = [%#soption'1] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = [%#sfmap'30] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'1 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = [%#sfmap'27] lookup self key
  
  meta "rewrite_def" function index_logic'1
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    [%#sfmap'25] forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'1 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_0: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_FMap) = [%#sghost'5] inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_0: t_FMap)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''0 x
  
  let rec into_inner (self: t_FMap) (return' (x: t_FMap)) =
    {[@expl:into_inner 'self' type invariant] [%#sghost] inv'2 self}
    any [ return''0 (result: t_FMap) -> {[%#sghost'0] inv'1 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'0] len self >= 0
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  predicate inv'3 (_0: t_FMapIter)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapIter [inv'3 x]. inv'3 x
      = match x with
        | {t_FMapIter__inner = inner} -> inv'1 inner
        end
  
  function view'0 (self: t_FMapIter) : t_FMap
  
  let rec into_iter (self: t_FMap) (return' (x: t_FMapIter)) =
    {[@expl:into_iter 'self' type invariant] [%#sfmap'1] inv'1 self}
    any
    [ return''0 (result: t_FMapIter) -> {[%#sfmap'2] inv'3 result}
      {[%#sfmap'3] view'0 result = self}
      (! return' {result}) ]
  
  type tuple'1 = { _p0'1: t_K; _p1'1: t_V }
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = [%#sfmap'5] forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'4] ext_eq self other = (self = other)
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple'1
  
  function get'0 (self: Seq.seq tuple'1) (ix: int) : t_Option'0 = [%#sseq] if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple'1) (o: t_FMapIter) =
    [%#sfmap'6] (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i)._p0'1 <> (Seq.get visited j)._p0'1)
    /\ (forall k: t_K, v: t_V, i: int. get'0 visited i = C_Some'0 { _p0'1 = k; _p1'1 = v }
        -> not contains (view'0 o) k /\ get (view'0 self) k = C_Some v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i)._p0'1 <> k)
      -> get (view'0 o) k = get (view'0 self) k)
  
  function produces_trans (a: t_FMapIter) (ab: Seq.seq tuple'1) (b: t_FMapIter) (bc: Seq.seq tuple'1) (c: t_FMapIter) : ()
  
  axiom produces_trans_spec:
    forall a: t_FMapIter, ab: Seq.seq tuple'1, b: t_FMapIter, bc: Seq.seq tuple'1, c: t_FMapIter. ([%#sfmap'18] produces a ab b)
      -> ([%#sfmap'19] produces b bc c) -> ([%#sfmap'20] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_FMapIter) : ()
  
  axiom produces_refl_spec: forall self: t_FMapIter. [%#sfmap'17] produces self (Seq.empty: Seq.seq tuple'1) self
  
  predicate inv'4 (_0: tuple'1)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple'1 [inv'4 x]. inv'4 x
      = (let {_p0'1 = x0; _p1'1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate invariant''1 (self: tuple'1) = [%#sboxed] inv'4 self
  
  predicate inv'5 (_0: tuple'1)
  
  axiom inv_axiom'3 [@rewrite]: forall x: tuple'1 [inv'5 x]. inv'5 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: Seq.seq tuple'1) =
    [%#sseq'0] forall i: int. 0 <= i /\ i < Seq.length self -> inv'5 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'6 (_0: Seq.seq tuple'1)
  
  axiom inv_axiom'4 [@rewrite]: forall x: Seq.seq tuple'1 [inv'6 x]. inv'6 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_FMapIter) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'7 (_0: MutBorrow.t t_FMapIter)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_FMapIter [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate inv'8 (_0: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'4 a_0
        end
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'28] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'29] view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = [%#sfmap'26] ext_eq self empty
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_FMapIter) : t_FMap = [%#smodel] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  predicate completed (self: MutBorrow.t t_FMapIter) = [%#sfmap'22] is_empty (view'1 self)
  
  function insert (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'23] view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'24] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec next (self: MutBorrow.t t_FMapIter) (return' (x: t_Option'0)) =
    {[@expl:next 'self' type invariant] [%#sfmap'7] inv'7 self}
    any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'8] inv'8 result}
      {[%#sfmap'9] match result with
        | C_None'0 -> completed self
        | C_Some'0 {_p0'1 = k; _p1'1 = v} -> produces self.current (Seq.singleton { _p0'1 = k; _p1'1 = v }) self.final
        /\ view'0 self.current = insert (view'0 self.final) k v
        end}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_FMapIter) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_FMapIter) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option'0) (ret (field_0: tuple'1)) = any
    [ good (field_0: tuple'1) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple'1 [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate inv'10 (_0: t_Option)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: t_K) (value: t_V) (return' (x: t_Option)) =
    {[@expl:insert_ghost 'self' type invariant] [%#sfmap'10] inv'9 self}
    {[@expl:insert_ghost 'key' type invariant] [%#sfmap'11] inv key}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'12] inv'0 value}
    any
    [ return''0 (result: t_Option) -> {[%#sfmap'13] inv'10 result}
      {[%#sfmap'14] self.final = insert self.current key value}
      {[%#sfmap'15] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve'1 (_0: t_V)
  
  predicate resolve'2 [@inline:trivial] (self: t_Option) =
    [%#soption] match self with
      | C_Some x -> resolve'1 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: t_Option) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  let rec new (x: t_FMap) (return' (x'0: t_FMap)) = {[@expl:new 'x' type invariant] [%#sghost'2] inv'1 x}
    any [ return''0 (result: t_FMap) -> {[%#sghost'3] inv'2 result} {[%#sghost'4] result = x} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec merge_fmaps [#"fmap_iter.rs" 25 0 25 91] (m1: t_FMap) (m2: t_FMap) (return' (x: t_FMap)) =
    {[@expl:merge_fmaps 'm1' type invariant] [%#sfmap_iter'7] inv'2 m1}
    {[@expl:merge_fmaps 'm2' type invariant] [%#sfmap_iter'8] inv'2 m2}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &merge'0 <- [%#sfmap_iter] merge m1'0 m2'0 (fun (__0: tuple) -> let {_p0 = v1} = __0 in v1) ] s1
      | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_inner {m2'0} (fun (_ret: t_FMap) -> [ &result <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &len'0 <- [%#sfmap_iter'0] len m1'0 ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = into_inner {m1'0} (fun (_ret: t_FMap) -> [ &_13 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = into_iter {_13} (fun (_ret: t_FMapIter) -> [ &iter <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &iter_old <- [%#sfmap_iter'1] iter ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &produced <- [%#sfmap_iter'1] Seq.empty: Seq.seq tuple'1 ] s1 | s1 = bb8 ]
    | bb8 = bb8invariant
      [ bb8'0 = {[@expl:loop variant] well_founded_relation variant_old_bb8 (len'0 - Seq.length produced)} bb8invariant
      | bb8invariant = {[@expl:for invariant] [%#sfmap_iter'1] inv'6 produced}
        {[@expl:for invariant] [%#sfmap_iter'1] inv'3 iter}
        {[@expl:for invariant] [%#sfmap_iter'1] produces iter_old produced iter}
        {[@expl:loop invariant #0] [%#sfmap_iter'4] ext_eq merge'0 (merge (view'0 iter) result (fun (__0: tuple) -> let {_p0 = v1} = __0 in v1))}
        {[@expl:loop invariant #1] [%#sfmap_iter'3] inv'1 result}
        (! [ &variant_old_bb8 <- [%#sfmap_iter'2] len'0 - Seq.length produced ] s0)
        [ s0 = bb9 ]
        [ bb9 = s0
          [ s0 = {inv'3 iter}
            MutBorrow.borrow_mut <t_FMapIter> {iter}
              (fun (_ret: MutBorrow.t t_FMapIter) -> [ &_29 <- _ret ] -{inv'3 _ret.final}- [ &iter <- _ret.final ] s1)
          | s1 = {inv'3 _29.current}
            MutBorrow.borrow_final <t_FMapIter> {_29.current} {MutBorrow.get_id _29}
              (fun (_ret: MutBorrow.t t_FMapIter) ->
                [ &_28 <- _ret ] -{inv'3 _ret.final}-
                [ &_29 <- { _29 with current = _ret.final } ] s2)
          | s2 = next {_28} (fun (_ret: t_Option'0) -> [ &_27 <- _ret ] s3)
          | s3 = bb10 ]
        | bb10 = s0
          [ s0 = {[@expl:type invariant] inv'7 _29} s1
          | s1 = -{resolve'0 _29}- s2
          | s2 = any [ br0 -> {_27 = C_None'0} (! bb13) | br1 (x0: tuple'1) -> {_27 = C_Some'0 x0} (! bb14) ] ]
        | bb14 = s0
          [ s0 = v_Some {_27} (fun (r0: tuple'1) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_32 <- [%#sfmap_iter'5] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb15 ]
        | bb15 = s0
          [ s0 = [ &produced <- _32 ] s1
          | s1 = [ &k <- __creusot_proc_iter_elem._p0'1 ] s2
          | s2 = [ &v <- __creusot_proc_iter_elem._p1'1 ] s3
          | s3 = {inv'1 result}
            MutBorrow.borrow_mut <t_FMap> {result}
              (fun (_ret: MutBorrow.t t_FMap) -> [ &_37 <- _ret ] -{inv'1 _ret.final}- [ &result <- _ret.final ] s4)
          | s4 = insert_ghost {_37} {k} {v} (fun (_ret: t_Option) -> [ &_36 <- _ret ] s5)
          | s5 = {[@expl:type invariant] inv'10 _36} s6
          | s6 = -{resolve'3 _36}- s7
          | s7 = bb8'0 ] ] ]
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'3 iter} s1 | s1 = bb22 ]
    | bb22 = s0
      [ s0 = {[@expl:assertion] [%#sfmap_iter'6] ext_eq result merge'0} s1
      | s1 = new {result} (fun (_ret: t_FMap) -> [ &_0 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = return''0 {_0} ]
    [ & _0: t_FMap = Any.any_l ()
    | & m1'0: t_FMap = m1
    | & m2'0: t_FMap = m2
    | & merge'0: t_FMap = Any.any_l ()
    | & result: t_FMap = Any.any_l ()
    | & len'0: int = Any.any_l ()
    | & iter: t_FMapIter = Any.any_l ()
    | & _13: t_FMap = Any.any_l ()
    | & iter_old: t_FMapIter = Any.any_l ()
    | & produced: Seq.seq tuple'1 = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _28: MutBorrow.t t_FMapIter = Any.any_l ()
    | & _29: MutBorrow.t t_FMapIter = Any.any_l ()
    | & __creusot_proc_iter_elem: tuple'1 = Any.any_l ()
    | & _32: Seq.seq tuple'1 = Any.any_l ()
    | & k: t_K = Any.any_l ()
    | & v: t_V = Any.any_l ()
    | & _36: t_Option = Any.any_l ()
    | & _37: MutBorrow.t t_FMap = Any.any_l ()
    | & variant_old_bb8: int = Any.any_l () ])
    [ return''0 (result: t_FMap) -> {[@expl:merge_fmaps result type invariant] [%#sfmap_iter'9] inv'2 result}
      {[@expl:merge_fmaps ensures] [%#sfmap_iter'10] result
      = merge m1 m2 (fun (__0: tuple) -> let {_p0 = v1} = __0 in v1)}
      (! return' {result}) ]
end
