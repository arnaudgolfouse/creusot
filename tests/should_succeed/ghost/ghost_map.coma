module M_ghost_map__ghost_map [#"ghost_map.rs" 4 0 4 18]
  let%span sghost_map = "ghost_map.rs" 7 22 7 53
  let%span sghost_map'0 = "ghost_map.rs" 8 25 8 26
  let%span sghost_map'1 = "ghost_map.rs" 8 28 8 30
  let%span sghost_map'2 = "ghost_map.rs" 10 22 10 47
  let%span sghost_map'3 = "ghost_map.rs" 11 22 11 34
  let%span sghost_map'4 = "ghost_map.rs" 12 44 12 45
  let%span sghost_map'5 = "ghost_map.rs" 13 17 13 19
  let%span sghost_map'6 = "ghost_map.rs" 15 22 15 47
  let%span sghost_map'7 = "ghost_map.rs" 17 45 17 46
  let%span sghost_map'8 = "ghost_map.rs" 17 48 17 50
  let%span sghost_map'9 = "ghost_map.rs" 18 45 18 46
  let%span sghost_map'10 = "ghost_map.rs" 18 48 18 51
  let%span sghost_map'11 = "ghost_map.rs" 20 22 20 43
  let%span sghost_map'12 = "ghost_map.rs" 21 22 21 50
  let%span sghost_map'13 = "ghost_map.rs" 22 22 22 34
  let%span sghost_map'14 = "ghost_map.rs" 23 22 23 48
  let%span sghost_map'15 = "ghost_map.rs" 24 22 24 47
  let%span sghost_map'16 = "ghost_map.rs" 26 45 26 46
  let%span sghost_map'17 = "ghost_map.rs" 27 13 27 15
  let%span sghost_map'18 = "ghost_map.rs" 28 26 28 27
  let%span sghost_map'19 = "ghost_map.rs" 28 29 28 32
  let%span sghost_map'20 = "ghost_map.rs" 29 26 29 27
  let%span sghost_map'21 = "ghost_map.rs" 29 29 29 31
  let%span sghost_map'22 = "ghost_map.rs" 31 22 31 47
  let%span sghost_map'23 = "ghost_map.rs" 32 22 32 48
  let%span sghost_map'24 = "ghost_map.rs" 34 45 34 46
  let%span sghost_map'25 = "ghost_map.rs" 35 44 35 45
  let%span sghost_map'26 = "ghost_map.rs" 36 45 36 46
  let%span sghost_map'27 = "ghost_map.rs" 37 22 37 42
  let%span sghost_map'28 = "ghost_map.rs" 38 22 38 49
  let%span sghost_map'29 = "ghost_map.rs" 39 22 39 42
  let%span sghost_map'30 = "ghost_map.rs" 40 22 40 43
  let%span sghost_map'31 = "ghost_map.rs" 42 44 42 45
  let%span sghost_map'32 = "ghost_map.rs" 43 44 43 45
  let%span sghost_map'33 = "ghost_map.rs" 44 44 44 45
  let%span sghost_map'34 = "ghost_map.rs" 45 22 45 31
  let%span sghost_map'35 = "ghost_map.rs" 46 8 46 33
  let%span sghost_map'36 = "ghost_map.rs" 47 8 47 33
  let%span sghost_map'37 = "ghost_map.rs" 49 34 49 35
  let%span sghost_map'38 = "ghost_map.rs" 50 34 50 35
  let%span sghost_map'39 = "ghost_map.rs" 51 34 51 35
  let%span sghost_map'40 = "ghost_map.rs" 52 22 52 42
  let%span sghost_map'41 = "ghost_map.rs" 53 22 53 34
  let%span sghost_map'42 = "ghost_map.rs" 54 22 54 34
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 284 4 284 33
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 443 14 443 49
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 444 14 444 40
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 311 14 311 34
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 104 4 104 12
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 376 14 384 9
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 385 14 385 73
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 386 14 386 44
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 414 4 414 36
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 415 14 415 47
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 416 14 416 85
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 468 14 468 43
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 469 14 469 41
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/fmap.rs" 94 4 94 12
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/fmap.rs" 331 14 331 43
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/fmap.rs" 353 14 353 55
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/fmap.rs" 120 4 120 12
  let%span sfmap'17 = "../../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'18 = "../../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'19 = "../../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'20 = "../../../creusot-contracts/src/logic/fmap.rs" 271 4 271 12
  let%span sfmap'21 = "../../../creusot-contracts/src/logic/fmap.rs" 85 14 85 43
  let%span sfmap'22 = "../../../creusot-contracts/src/logic/fmap.rs" 86 14 86 84
  let%span sfmap'23 = "../../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'24 = "../../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'25 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'26 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 88 14 88 35
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'1 = "../../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 52 20 52 34
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 756 15 756 27
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 758 8 761 9
  let%span soption'1 = "../../../creusot-contracts/src/std/option.rs" 776 8 779 9
  let%span slogic = "../../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 67 4 67 12
  
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Option = C_None | C_Some Int32.t
  
  function view (self: t_FMap) : Map.map Int32.t t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: Int32.t) : t_Option = [%#sfmap'13] Map.get (view self) k
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = [%#sfmap'24] forall k: Int32.t. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'23] ext_eq self other = (self = other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'19] len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'25] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'26] view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = [%#sfmap'16] ext_eq self empty
  
  let rec new (return' (x: t_FMap)) = any
    [ return''0 (result: t_FMap) -> {[%#sfmap] is_empty result} (! return' {result}) ]
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: Int32.t) = [%#sfmap'0] get self k <> C_None
  
  let rec deref_mut (self: MutBorrow.t t_FMap) (return' (x: MutBorrow.t t_FMap)) = any
    [ return''0 (result: MutBorrow.t t_FMap) -> {[%#sghost] result = self} (! return' {result}) ]
  
  function insert (self: t_FMap) (k: Int32.t) (v: Int32.t) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: Int32.t, v: Int32.t. [%#sfmap'17] view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: Int32.t, v: Int32.t. [%#sfmap'18] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: Int32.t) (value: Int32.t) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#sfmap'1] self.final = insert self.current key value}
      {[%#sfmap'2] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_FMap) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0: MutBorrow.t t_FMap) = resolve _0
  
  let rec deref (self: t_FMap) (return' (x: t_FMap)) = any
    [ return''0 (result: t_FMap) -> {[%#sghost'0] result = self} (! return' {result}) ]
  
  let rec len_ghost (self: t_FMap) (return' (x: int)) = any
    [ return''0 (result: int) -> {[%#sfmap'3] result = len self} (! return' {result}) ]
  
  predicate index_logic (self: Map.map Int32.t bool) (a: Int32.t) = [%#smapping] Map.get self a
  
  function such_that (p: Map.map Int32.t bool) : Int32.t
  
  axiom such_that_spec: forall p: Map.map Int32.t bool. ([%#slogic] exists x: Int32.t. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : Int32.t = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: Int32.t) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: Int32.t) : Int32.t = [%#sfmap'4] unwrap_logic (get self k)
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t Int32.t)
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: Int32.t) : Int32.t = [%#sfmap'20] lookup self key
  
  let rec get_mut_ghost (self: MutBorrow.t t_FMap) (key: Int32.t) (return' (x: t_Option'0)) = any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'5] if contains self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains self.final key
          /\ index_logic'0 self.current key = r.current /\ index_logic'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap'6] forall k: Int32.t. k <> key -> get self.current k = get self.final k}
      {[%#sfmap'7] len self.current = len self.final}
      (! return' {result}) ]
  
  predicate resolve'1 (self: MutBorrow.t Int32.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (_0: MutBorrow.t Int32.t) = resolve'1 _0
  
  let rec v_Some (input: t_Option'0) (ret (field_0: MutBorrow.t Int32.t)) = any
    [ good (field_0: MutBorrow.t Int32.t) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t Int32.t [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  type tuple = { _p0: MutBorrow.t Int32.t; _p1: MutBorrow.t t_FMap }
  
  function remove (self: t_FMap) (k: Int32.t) : t_FMap
  
  axiom remove_spec: forall self: t_FMap, k: Int32.t. [%#sfmap'21] view (remove self k) = Map.set (view self) k (C_None)
  
  axiom remove_spec'0: forall self: t_FMap, k: Int32.t. [%#sfmap'22] len (remove self k)
      = (if contains self k then len self - 1 else len self)
  
  let rec split_mut_ghost (self: MutBorrow.t t_FMap) (key: Int32.t) (return' (x: tuple)) =
    {[@expl:split_mut_ghost requires] [%#sfmap'8] contains self.current key}
    any
    [ return''0 (result: tuple) -> {[%#sfmap'9] (result._p1).current = remove self.current key}
      {[%#sfmap'10] index_logic'0 self.current key = (result._p0).current
      /\ self.final = insert (result._p1).final key (result._p0).final}
      (! return' {result}) ]
  
  let rec remove_ghost (self: MutBorrow.t t_FMap) (key: Int32.t) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#sfmap'11] self.final = remove self.current key}
      {[%#sfmap'12] result = get self.current key}
      (! return' {result}) ]
  
  let rec contains_ghost (self: t_FMap) (key: Int32.t) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#sfmap'14] result = contains self key} (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 Int32.t
  
  function map_logic (self: t_Option) (f: Map.map Int32.t Int32.t) : t_Option'1 = [%#soption'1] match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: Int32.t) (return' (x: t_Option'1)) = any
    [ return''0 (result: t_Option'1) -> {[%#sfmap'15] result = map_logic (get self key) (fun (v: Int32.t) -> v)}
      (! return' {result}) ]
  
  let rec new'0 (x: ()) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#sghost'1] result = x} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ghost_map [#"ghost_map.rs" 4 0 4 18] (return' (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new (fun (_ret: t_FMap) -> [ &map <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map] forall k: Int32.t. not contains map k} s1
      | s1 = MutBorrow.borrow_mut <t_FMap> {map}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_9 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_9} (fun (_ret: MutBorrow.t t_FMap) -> [ &_8 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_7 <- _ret ] [ &_8 <- { _8 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_7} {[%#sghost_map'0] (1: Int32.t)} {[%#sghost_map'1] (21: Int32.t)}
          (fun (_ret: t_Option) -> [ &_6 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = -{resolve'0 _8}- s1 | s1 = deref {map} (fun (_ret: t_FMap) -> [ &_12 <- _ret ] s2) | s2 = bb4 ]
    | bb4 = s0 [ s0 = len_ghost {_12} (fun (_ret: int) -> [ &length1 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'2] lookup map (1: Int32.t) = (21: Int32.t)} s1
      | s1 = {[@expl:assertion] [%#sghost_map'3] length1 = 1} s2
      | s2 = MutBorrow.borrow_mut <t_FMap> {map}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_22 <- _ret ] [ &map <- _ret.final ] s3)
      | s3 = deref_mut {_22} (fun (_ret: MutBorrow.t t_FMap) -> [ &_21 <- _ret ] s4)
      | s4 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'4] (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_162 <- _const ] s1 ]
      | s1 = [ &_24 <- _162 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_20 <- _ret ] [ &_21 <- { _21 with current = _ret.final } ] s3)
      | s3 = get_mut_ghost {_20} {_24} (fun (_ret: t_Option'0) -> [ &_19 <- _ret ] s4)
      | s4 = bb7 ]
    | bb7 = any [ br0 -> {_19 = C_None'0} (! bb10) | br1 (x0: MutBorrow.t Int32.t) -> {_19 = C_Some'0 x0} (! bb9) ]
    | bb10 = s0
      [ s0 = -{match _19 with
          | C_Some'0 x'1 -> resolve'2 x'1
          | _ -> true
          end}-
        s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = bb11 ]
    | bb9 = s0
      [ s0 = v_Some {_19} (fun (r0: MutBorrow.t Int32.t) -> [ &x <- r0 ] s1)
      | s1 = [ &x <- { x with current = ([%#sghost_map'5] (43: Int32.t)) } ] s2
      | s2 = -{resolve'2 x}- s3
      | s3 = -{resolve'0 _21}- s4
      | s4 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'6] lookup map (1: Int32.t) = (43: Int32.t)} s1
      | s1 = MutBorrow.borrow_mut <t_FMap> {map}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_33 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_33} (fun (_ret: MutBorrow.t t_FMap) -> [ &_32 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap> {_32.current} {MutBorrow.get_id _32}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_31 <- _ret ] [ &_32 <- { _32 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_31} {[%#sghost_map'7] (2: Int32.t)} {[%#sghost_map'8] (50: Int32.t)}
          (fun (_ret: t_Option) -> [ &inserted_none <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = -{resolve'0 _32}- s1
      | s1 = MutBorrow.borrow_mut <t_FMap> {map}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_37 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_37} (fun (_ret: MutBorrow.t t_FMap) -> [ &_36 <- _ret ] s3)
      | s3 = bb14 ]
    | bb14 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_35 <- _ret ] [ &_36 <- { _36 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_35} {[%#sghost_map'9] (2: Int32.t)} {[%#sghost_map'10] (100: Int32.t)}
          (fun (_ret: t_Option) -> [ &inserted_some <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0 [ s0 = -{resolve'0 _36}- s1 | s1 = deref {map} (fun (_ret: t_FMap) -> [ &_40 <- _ret ] s2) | s2 = bb16 ]
    | bb16 = s0 [ s0 = len_ghost {_40} (fun (_ret: int) -> [ &length2 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'11] inserted_none = C_None} s1
      | s1 = {[@expl:assertion] [%#sghost_map'12] inserted_some = C_Some (50: Int32.t)} s2
      | s2 = {[@expl:assertion] [%#sghost_map'13] length2 = 2} s3
      | s3 = {[@expl:assertion] [%#sghost_map'14] lookup map (2: Int32.t) = (100: Int32.t)} s4
      | s4 = {[@expl:assertion] [%#sghost_map'15] lookup map (1: Int32.t) = (43: Int32.t)} s5
      | s5 = MutBorrow.borrow_mut <t_FMap> {map}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_57 <- _ret ] [ &map <- _ret.final ] s6)
      | s6 = deref_mut {_57} (fun (_ret: MutBorrow.t t_FMap) -> [ &_56 <- _ret ] s7)
      | s7 = bb18 ]
    | bb18 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'16] (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_161 <- _const ] s1 ]
      | s1 = [ &_59 <- _161 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_56.current} {MutBorrow.get_id _56}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_55 <- _ret ] [ &_56 <- { _56 with current = _ret.final } ] s3)
      | s3 = split_mut_ghost {_55} {_59} (fun (_ret: tuple) -> [ &_54 <- _ret ] s4)
      | s4 = bb19 ]
    | bb19 = s0
      [ s0 = [ &x'0 <- _54._p0 ] s1
      | s1 = [ &map2 <- _54._p1 ] s2
      | s2 = -{resolve'0 _56}- s3
      | s3 = [ &x'0 <- { x'0 with current = ([%#sghost_map'17] (42: Int32.t)) } ] s4
      | s4 = -{resolve'2 x'0}- s5
      | s5 = MutBorrow.borrow_mut <t_FMap> {map2.current}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_62 <- _ret ] [ &map2 <- { map2 with current = _ret.final } ] s6)
      | s6 = insert_ghost {_62} {[%#sghost_map'18] (2: Int32.t)} {[%#sghost_map'19] (200: Int32.t)}
          (fun (_ret: t_Option) -> [ &_61 <- _ret ] s7)
      | s7 = bb20 ]
    | bb20 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap> {map2.current} {MutBorrow.get_id map2}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_64 <- _ret ] [ &map2 <- { map2 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_64} {[%#sghost_map'20] (1: Int32.t)} {[%#sghost_map'21] (56: Int32.t)}
          (fun (_ret: t_Option) -> [ &_63 <- _ret ] s2)
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = -{resolve'0 map2}- s1
      | s1 = {[@expl:assertion] [%#sghost_map'22] lookup map (1: Int32.t) = (42: Int32.t)} s2
      | s2 = {[@expl:assertion] [%#sghost_map'23] lookup map (2: Int32.t) = (200: Int32.t)} s3
      | s3 = MutBorrow.borrow_mut <t_FMap> {map}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_72 <- _ret ] [ &map <- _ret.final ] s4)
      | s4 = deref_mut {_72} (fun (_ret: MutBorrow.t t_FMap) -> [ &_71 <- _ret ] s5)
      | s5 = bb22 ]
    | bb22 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'24] (3: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_160 <- _const ] s1 ]
      | s1 = [ &_74 <- _160 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_71.current} {MutBorrow.get_id _71}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_70 <- _ret ] [ &_71 <- { _71 with current = _ret.final } ] s3)
      | s3 = remove_ghost {_70} {_74} (fun (_ret: t_Option) -> [ &remove_none1 <- _ret ] s4)
      | s4 = bb23 ]
    | bb23 = s0
      [ s0 = -{resolve'0 _71}- s1
      | s1 = MutBorrow.borrow_mut <t_FMap> {map}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_79 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_79} (fun (_ret: MutBorrow.t t_FMap) -> [ &_78 <- _ret ] s3)
      | s3 = bb24 ]
    | bb24 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'25] (2: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_159 <- _const ] s1 ]
      | s1 = [ &_81 <- _159 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_78.current} {MutBorrow.get_id _78}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_77 <- _ret ] [ &_78 <- { _78 with current = _ret.final } ] s3)
      | s3 = remove_ghost {_77} {_81} (fun (_ret: t_Option) -> [ &remove_some <- _ret ] s4)
      | s4 = bb25 ]
    | bb25 = s0
      [ s0 = -{resolve'0 _78}- s1
      | s1 = MutBorrow.borrow_mut <t_FMap> {map}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_86 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_86} (fun (_ret: MutBorrow.t t_FMap) -> [ &_85 <- _ret ] s3)
      | s3 = bb26 ]
    | bb26 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'26] (2: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_158 <- _const ] s1 ]
      | s1 = [ &_88 <- _158 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_85.current} {MutBorrow.get_id _85}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_84 <- _ret ] [ &_85 <- { _85 with current = _ret.final } ] s3)
      | s3 = remove_ghost {_84} {_88} (fun (_ret: t_Option) -> [ &remove_none2 <- _ret ] s4)
      | s4 = bb27 ]
    | bb27 = s0
      [ s0 = -{resolve'0 _85}- s1
      | s1 = {[@expl:assertion] [%#sghost_map'27] remove_none1 = C_None} s2
      | s2 = {[@expl:assertion] [%#sghost_map'28] remove_some = C_Some (200: Int32.t)} s3
      | s3 = {[@expl:assertion] [%#sghost_map'29] remove_none2 = C_None} s4
      | s4 = {[@expl:assertion] [%#sghost_map'30] get map (2: Int32.t) = C_None} s5
      | s5 = deref {map} (fun (_ret: t_FMap) -> [ &_100 <- _ret ] s6)
      | s6 = bb28 ]
    | bb28 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'31] (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_157 <- _const ] s1 ]
      | s1 = [ &_103 <- _157 ] s2
      | s2 = contains_ghost {_100} {_103} (fun (_ret: bool) -> [ &contains1 <- _ret ] s3)
      | s3 = bb29 ]
    | bb29 = s0 [ s0 = deref {map} (fun (_ret: t_FMap) -> [ &_107 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'32] (2: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_156 <- _const ] s1 ]
      | s1 = [ &_110 <- _156 ] s2
      | s2 = contains_ghost {_107} {_110} (fun (_ret: bool) -> [ &contains2 <- _ret ] s3)
      | s3 = bb31 ]
    | bb31 = s0 [ s0 = deref {map} (fun (_ret: t_FMap) -> [ &_114 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'33] (3: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_155 <- _const ] s1 ]
      | s1 = [ &_117 <- _155 ] s2
      | s2 = contains_ghost {_114} {_117} (fun (_ret: bool) -> [ &contains3 <- _ret ] s3)
      | s3 = bb33 ]
    | bb33 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'34] contains1} s1
      | s1 = {[@expl:assertion] [%#sghost_map'35] not contains2} s2
      | s2 = {[@expl:assertion] [%#sghost_map'36] not contains3} s3
      | s3 = deref {map} (fun (_ret: t_FMap) -> [ &_127 <- _ret ] s4)
      | s4 = bb34 ]
    | bb34 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'37] (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_154 <- _const ] s1 ]
      | s1 = [ &_130 <- _154 ] s2
      | s2 = get_ghost {_127} {_130} (fun (_ret: t_Option'1) -> [ &get1 <- _ret ] s3)
      | s3 = bb35 ]
    | bb35 = s0 [ s0 = deref {map} (fun (_ret: t_FMap) -> [ &_134 <- _ret ] s1) | s1 = bb36 ]
    | bb36 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'38] (2: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_153 <- _const ] s1 ]
      | s1 = [ &_137 <- _153 ] s2
      | s2 = get_ghost {_134} {_137} (fun (_ret: t_Option'1) -> [ &get2 <- _ret ] s3)
      | s3 = bb37 ]
    | bb37 = s0 [ s0 = deref {map} (fun (_ret: t_FMap) -> [ &_141 <- _ret ] s1) | s1 = bb38 ]
    | bb38 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- [%#sghost_map'39] (3: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_152 <- _const ] s1 ]
      | s1 = [ &_144 <- _152 ] s2
      | s2 = get_ghost {_141} {_144} (fun (_ret: t_Option'1) -> [ &get3 <- _ret ] s3)
      | s3 = bb39 ]
    | bb39 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'40] get1 = C_Some'1 (42: Int32.t)} s1
      | s1 = {[@expl:assertion] [%#sghost_map'41] get2 = C_None'1} s2
      | s2 = {[@expl:assertion] [%#sghost_map'42] get3 = C_None'1} s3
      | s3 = new'0 {_3} (fun (_ret: ()) -> [ &_2 <- _ret ] s4)
      | s4 = bb40 ]
    | bb40 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & map: t_FMap = Any.any_l ()
    | & _2: () = Any.any_l ()
    | & _3: () = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _7: MutBorrow.t t_FMap = Any.any_l ()
    | & _8: MutBorrow.t t_FMap = Any.any_l ()
    | & _9: MutBorrow.t t_FMap = Any.any_l ()
    | & length1: int = Any.any_l ()
    | & _12: t_FMap = Any.any_l ()
    | & _19: t_Option'0 = Any.any_l ()
    | & _20: MutBorrow.t t_FMap = Any.any_l ()
    | & _21: MutBorrow.t t_FMap = Any.any_l ()
    | & _22: MutBorrow.t t_FMap = Any.any_l ()
    | & _24: Int32.t = Any.any_l ()
    | & x: MutBorrow.t Int32.t = Any.any_l ()
    | & inserted_none: t_Option = Any.any_l ()
    | & _31: MutBorrow.t t_FMap = Any.any_l ()
    | & _32: MutBorrow.t t_FMap = Any.any_l ()
    | & _33: MutBorrow.t t_FMap = Any.any_l ()
    | & inserted_some: t_Option = Any.any_l ()
    | & _35: MutBorrow.t t_FMap = Any.any_l ()
    | & _36: MutBorrow.t t_FMap = Any.any_l ()
    | & _37: MutBorrow.t t_FMap = Any.any_l ()
    | & length2: int = Any.any_l ()
    | & _40: t_FMap = Any.any_l ()
    | & x'0: MutBorrow.t Int32.t = Any.any_l ()
    | & map2: MutBorrow.t t_FMap = Any.any_l ()
    | & _54: tuple = Any.any_l ()
    | & _55: MutBorrow.t t_FMap = Any.any_l ()
    | & _56: MutBorrow.t t_FMap = Any.any_l ()
    | & _57: MutBorrow.t t_FMap = Any.any_l ()
    | & _59: Int32.t = Any.any_l ()
    | & _61: t_Option = Any.any_l ()
    | & _62: MutBorrow.t t_FMap = Any.any_l ()
    | & _63: t_Option = Any.any_l ()
    | & _64: MutBorrow.t t_FMap = Any.any_l ()
    | & remove_none1: t_Option = Any.any_l ()
    | & _70: MutBorrow.t t_FMap = Any.any_l ()
    | & _71: MutBorrow.t t_FMap = Any.any_l ()
    | & _72: MutBorrow.t t_FMap = Any.any_l ()
    | & _74: Int32.t = Any.any_l ()
    | & remove_some: t_Option = Any.any_l ()
    | & _77: MutBorrow.t t_FMap = Any.any_l ()
    | & _78: MutBorrow.t t_FMap = Any.any_l ()
    | & _79: MutBorrow.t t_FMap = Any.any_l ()
    | & _81: Int32.t = Any.any_l ()
    | & remove_none2: t_Option = Any.any_l ()
    | & _84: MutBorrow.t t_FMap = Any.any_l ()
    | & _85: MutBorrow.t t_FMap = Any.any_l ()
    | & _86: MutBorrow.t t_FMap = Any.any_l ()
    | & _88: Int32.t = Any.any_l ()
    | & contains1: bool = Any.any_l ()
    | & _100: t_FMap = Any.any_l ()
    | & _103: Int32.t = Any.any_l ()
    | & contains2: bool = Any.any_l ()
    | & _107: t_FMap = Any.any_l ()
    | & _110: Int32.t = Any.any_l ()
    | & contains3: bool = Any.any_l ()
    | & _114: t_FMap = Any.any_l ()
    | & _117: Int32.t = Any.any_l ()
    | & get1: t_Option'1 = Any.any_l ()
    | & _127: t_FMap = Any.any_l ()
    | & _130: Int32.t = Any.any_l ()
    | & get2: t_Option'1 = Any.any_l ()
    | & _134: t_FMap = Any.any_l ()
    | & _137: Int32.t = Any.any_l ()
    | & get3: t_Option'1 = Any.any_l ()
    | & _141: t_FMap = Any.any_l ()
    | & _144: Int32.t = Any.any_l ()
    | & _152: Int32.t = Any.any_l ()
    | & _153: Int32.t = Any.any_l ()
    | & _154: Int32.t = Any.any_l ()
    | & _155: Int32.t = Any.any_l ()
    | & _156: Int32.t = Any.any_l ()
    | & _157: Int32.t = Any.any_l ()
    | & _158: Int32.t = Any.any_l ()
    | & _159: Int32.t = Any.any_l ()
    | & _160: Int32.t = Any.any_l ()
    | & _161: Int32.t = Any.any_l ()
    | & _162: Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
