module M_09_fnonce_resolve__f
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type closure0 = { _0: bool; _1: MutBorrow.t Int32.t; _2: MutBorrow.t Int32.t }
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t Int32.t) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0'0: MutBorrow.t Int32.t) = resolve _0'0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t Int32.t) = resolve'0 self
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0'0: MutBorrow.t Int32.t) = resolve'1 _0'0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t Int32.t) = resolve'2 self
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0'0: MutBorrow.t Int32.t) = resolve'3 _0'0
  
  meta "rewrite_def" predicate resolve'4
  
  let rec closure0 (self: closure0) (return' (x: ())) = {[@expl:closure requires] Int32.to_int (self._2).current = 1
    /\ Int32.to_int (self._1).current = 1}
    (! bb0
    [ bb0 = any [ br0 -> {_1'0._0 = false} (! bb3) | br1 -> {_1'0._0} (! bb1) ]
    | bb1 = s0
      [ s0 = -{match _1'0 with
          | {_1 = x} -> resolve'4 x
          | _ -> true
          end}-
        s1
      | s1 = {[@expl:assertion] Int32.to_int (_1'0._1).final = 1} s2
      | s2 = [ &bx2 <- _1'0._2 ] s3
      | s3 = Int32.add {bx2.current} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &bx2 <- { bx2 with current = _ret } ] s4)
      | s4 = -{resolve'0 bx2}- s5
      | s5 = {[@expl:assertion] Int32.to_int bx2.final = 2} s6
      | s6 = bb6 ]
    | bb3 = s0
      [ s0 = -{match _1'0 with
          | {_2 = x} -> resolve'2 x
          | _ -> true
          end}-
        s1
      | s1 = {[@expl:assertion] Int32.to_int (_1'0._2).final = 1} s2
      | s2 = [ &by2 <- _1'0._1 ] s3
      | s3 = Int32.add {by2.current} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &by2 <- { by2 with current = _ret } ] s4)
      | s4 = -{resolve'0 by2}- s5
      | s5 = {[@expl:assertion] Int32.to_int by2.final = 2} s6
      | s6 = bb6 ]
    | bb6 = return''0 {_0'0} ]
    [ & _0'0: () = Any.any_l ()
    | & _1'0: closure0 = self
    | & bx2: MutBorrow.t Int32.t = Any.any_l ()
    | & by2: MutBorrow.t Int32.t = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:closure ensures] Int32.to_int (self._2).final + Int32.to_int (self._1).final
      = 3}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (c: bool) (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- (1: Int32.t) ] s1
      | s1 = [ &y <- (1: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_5 <- _ret ] [ &x <- _ret.final ] s3)
      | s3 = [ &bx <- _5 ] s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {y}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_8 <- _ret ] [ &y <- _ret.final ] s1)
      | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &by' <- _8 ] s1 | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &f'0 <- { _0 = c'0; _1 = by'; _2 = bx } ] s1
      | s1 = closure0 {f'0} (fun (_ret: ()) -> [ &_10 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = {[@expl:assertion] Int32.to_int x + Int32.to_int y = 3} s1 | s1 = bb7 ]
    | bb7 = return''0 {_0'0} ]
    [ & _0'0: () = Any.any_l ()
    | & c'0: bool = c
    | & x: Int32.t = Any.any_l ()
    | & y: Int32.t = Any.any_l ()
    | & bx: MutBorrow.t Int32.t = Any.any_l ()
    | & _5: MutBorrow.t Int32.t = Any.any_l ()
    | & by': MutBorrow.t Int32.t = Any.any_l ()
    | & _8: MutBorrow.t Int32.t = Any.any_l ()
    | & f'0: closure0 = Any.any_l ()
    | & _10: () = Any.any_l ()
    | & _12: () = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
