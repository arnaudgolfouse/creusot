module M_10_tyinv__f
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  type t_T
  
  type t_Zero = { t_Zero__0: UInt32.t; t_Zero__1: t_T }
  
  predicate invariant' (self: t_Zero) = UInt32.t'int self.t_Zero__0 = 0
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Zero)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zero [inv'0 x]. inv'0 x = (invariant' x /\ inv x.t_Zero__1)
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_Zero)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Zero [resolve'0 x]. resolve'0 x = resolve x.t_Zero__1
  
  type closure0 = { c0: t_Zero; c1: t_Zero }
  
  type closure1 = { c0'0: t_Zero }
  
  predicate invariant''0 [@inline:trivial] (self: t_Zero) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_Zero) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 [@inline:trivial] (_1: closure1) = let {c0'0 = x0} = _1 in inv'1 x0
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''1 [@inline:trivial] (self: closure1) = inv'2 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 [@inline:trivial] (_1: closure1) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'3
  
  let rec closure1 (self: closure1) (return (x: UInt32.t)) = {[@expl:closure 'self' type invariant] inv'3 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] UInt32.t'int self.c0'0.t_Zero__0 = 0} s1
      | s1 = [ &_5 <- self.c0'0 ] s2
      | s2 = [ &res <- _5.t_Zero__0 ] s3
      | s3 = [ &_0 <- res ] s4
      | s4 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l ()
    | & self: closure1 = self
    | & res: UInt32.t = Any.any_l ()
    | & _5: t_Zero = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:closure ensures] UInt32.t'int result = 0} (! return {result}) ]
  
  predicate inv'4 [@inline:trivial] (_1: closure0) = let {c0 = x0; c1 = x1} = _1 in inv'1 x0 /\ inv'1 x1
  
  meta "rewrite_def" predicate inv'4
  
  predicate invariant''2 [@inline:trivial] (self: closure0) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 [@inline:trivial] (_1: closure0) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'5
  
  let rec closure0 (self: closure0) (return (x: UInt32.t)) = {[@expl:closure 'self' type invariant] inv'5 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] UInt32.t'int self.c0.t_Zero__0 = 0} s1
      | s1 = [ &clos2 <- { c0'0 = self.c1 } ] s2
      | s2 = closure1 {clos2} (fun (_ret: UInt32.t) -> [ &_7 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_10 <- self.c0 ] s1 | s1 = [ &res <- _10.t_Zero__0 ] s2 | s2 = [ &_0 <- res ] s3 | s3 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l ()
    | & self: closure0 = self
    | & res: UInt32.t = Any.any_l ()
    | & clos2: closure1 = Any.any_l ()
    | & _7: UInt32.t = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & _10: t_Zero = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:closure ensures] UInt32.t'int result = 0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (x: t_Zero) (y: t_Zero) (return (x'0: ())) = {[@expl:f 'x' type invariant] inv'0 x}
    {[@expl:f 'y' type invariant] inv'0 y}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:type invariant] inv'0 x} s1
      | s1 = -{resolve'0 x}- s2
      | s2 = {[@expl:type invariant] inv'0 y} s3
      | s3 = -{resolve'0 y}- s4
      | s4 = [ &clos <- { c0 = x; c1 = y } ] s5
      | s5 = closure0 {clos} (fun (_ret: UInt32.t) -> [ &_6 <- _ret ] s6)
      | s6 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & x: t_Zero = x
    | & y: t_Zero = y
    | & clos: closure0 = Any.any_l ()
    | & _6: UInt32.t = Any.any_l ()
    | & _8: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
