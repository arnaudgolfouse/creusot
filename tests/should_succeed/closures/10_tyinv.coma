module M_10_tyinv__f
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  type t_T
  
  type t_Zero = { t_Zero__0: UInt32.t; t_Zero__1: t_T }
  
  predicate invariant' (self: t_Zero) = UInt32.t'int self.t_Zero__0 = 0
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Zero)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zero [inv'0 x]. inv'0 x
      = (invariant' x
      /\ match x with
        | {t_Zero__0 = a_0; t_Zero__1 = a_1} -> inv a_1
        end)
  
  type closure0 = { c0: t_Zero; c1: t_Zero }
  
  type closure1 = { c0'0: t_Zero }
  
  predicate invariant''0 [@inline:trivial] (self: t_Zero) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_1: t_Zero)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Zero [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate inv'2 (_1: closure1)
  
  axiom inv_axiom'1 [@rewrite]: forall x: closure1 [inv'2 x]. inv'2 x = (let {c0'0 = x0} = x in inv'1 x0)
  
  predicate invariant''1 [@inline:trivial] (self: closure1) = inv'2 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 (_1: closure1)
  
  axiom inv_axiom'2 [@rewrite]: forall x: closure1 [inv'3 x]. inv'3 x = invariant''1 x
  
  let rec closure1 (self: closure1) (return (x: UInt32.t)) = {[@expl:closure 'self' type invariant] inv'3 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] UInt32.t'int self.c0'0.t_Zero__0 = 0} s1
      | s1 = [ &_5 <- self.c0'0 ] s2
      | s2 = [ &res <- _5.t_Zero__0 ] s3
      | s3 = [ &_0 <- res ] s4
      | s4 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l ()
    | & self: closure1 = self
    | & res: UInt32.t = Any.any_l ()
    | & _5: t_Zero = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:closure ensures] UInt32.t'int result = 0} (! return {result}) ]
  
  predicate inv'4 (_1: closure0)
  
  axiom inv_axiom'3 [@rewrite]: forall x: closure0 [inv'4 x]. inv'4 x
      = (let {c0 = x0; c1 = x1} = x in inv'1 x0 /\ inv'1 x1)
  
  predicate invariant''2 [@inline:trivial] (self: closure0) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_1: closure0)
  
  axiom inv_axiom'4 [@rewrite]: forall x: closure0 [inv'5 x]. inv'5 x = invariant''2 x
  
  let rec closure0 (self: closure0) (return (x: UInt32.t)) = {[@expl:closure 'self' type invariant] inv'5 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] UInt32.t'int self.c0.t_Zero__0 = 0} s1
      | s1 = [ &clos2 <- { c0'0 = self.c1 } ] s2
      | s2 = closure1 {clos2} (fun (_ret: UInt32.t) -> [ &_7 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_10 <- self.c0 ] s1 | s1 = [ &res <- _10.t_Zero__0 ] s2 | s2 = [ &_0 <- res ] s3 | s3 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l ()
    | & self: closure0 = self
    | & res: UInt32.t = Any.any_l ()
    | & clos2: closure1 = Any.any_l ()
    | & _7: UInt32.t = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & _10: t_Zero = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:closure ensures] UInt32.t'int result = 0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (x: t_Zero) (y: t_Zero) (return (x'0: ())) = {[@expl:f 'x' type invariant] inv'0 x}
    {[@expl:f 'y' type invariant] inv'0 y}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:type invariant] inv'0 x} s1
      | s1 = {[@expl:type invariant] inv'0 y} s2
      | s2 = [ &clos <- { c0 = x; c1 = y } ] s3
      | s3 = closure0 {clos} (fun (_ret: UInt32.t) -> [ &_6 <- _ret ] s4)
      | s4 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & x: t_Zero = x
    | & y: t_Zero = y
    | & clos: closure0 = Any.any_l ()
    | & _6: UInt32.t = Any.any_l ()
    | & _8: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
