module M_10_tyinv__f
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  type t_T
  
  type t_Zero = { t_Zero__0: UInt32.t; t_Zero__1: t_T }
  
  predicate invariant' (self: t_Zero) = UInt32.t'int self.t_Zero__0 = 0
  
  predicate inv (_0: t_T)
  
  predicate inv'0 (_0: t_Zero)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zero [inv'0 x]. inv'0 x
      = (invariant' x
      /\ match x with
        | {t_Zero__0 = a_0; t_Zero__1 = a_1} -> inv a_1
        end)
  
  type closure0 = { _0: t_Zero; _1: t_Zero }
  
  type closure1 = { _0'0: t_Zero }
  
  predicate invariant''0 [@inline:trivial] (self: t_Zero) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_0'1: t_Zero)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Zero [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate inv'2 (_0'1: closure1)
  
  axiom inv_axiom'1 [@rewrite]: forall x: closure1 [inv'2 x]. inv'2 x = (let {_0'0 = x0} = x in inv'1 x0)
  
  predicate invariant''1 [@inline:trivial] (self: closure1) = inv'2 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 (_0'1: closure1)
  
  axiom inv_axiom'2 [@rewrite]: forall x: closure1 [inv'3 x]. inv'3 x = invariant''1 x
  
  let rec closure1 (self: closure1) (return' (x: UInt32.t)) = {[@expl:closure 'self' type invariant] inv'3 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] UInt32.t'int (_1'0._0'0).t_Zero__0 = 0} s1
      | s1 = [ &_5 <- _1'0._0'0 ] s2
      | s2 = [ &res <- _5.t_Zero__0 ] s3
      | s3 = [ &_0'1 <- res ] s4
      | s4 = return''0 {_0'1} ] ]
    [ & _0'1: UInt32.t = Any.any_l ()
    | & _1'0: closure1 = self
    | & res: UInt32.t = Any.any_l ()
    | & _5: t_Zero = Any.any_l () ])
    [ return''0 (result: UInt32.t) -> {[@expl:closure ensures] UInt32.t'int result = 0} (! return' {result}) ]
  
  predicate inv'4 (_0'1: closure0)
  
  axiom inv_axiom'3 [@rewrite]: forall x: closure0 [inv'4 x]. inv'4 x
      = (let {_0 = x0; _1 = x1} = x in inv'1 x0 /\ inv'1 x1)
  
  predicate invariant''2 [@inline:trivial] (self: closure0) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 (_0'1: closure0)
  
  axiom inv_axiom'4 [@rewrite]: forall x: closure0 [inv'5 x]. inv'5 x = invariant''2 x
  
  let rec closure0 (self: closure0) (return' (x: UInt32.t)) = {[@expl:closure 'self' type invariant] inv'5 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] UInt32.t'int (_1'0._0).t_Zero__0 = 0} s1
      | s1 = [ &clos2 <- { _0'0 = _1'0._1 } ] s2
      | s2 = closure1 {clos2} (fun (_ret: UInt32.t) -> [ &_7 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_10 <- _1'0._0 ] s1
      | s1 = [ &res <- _10.t_Zero__0 ] s2
      | s2 = [ &_0'1 <- res ] s3
      | s3 = return''0 {_0'1} ] ]
    [ & _0'1: UInt32.t = Any.any_l ()
    | & _1'0: closure0 = self
    | & res: UInt32.t = Any.any_l ()
    | & clos2: closure1 = Any.any_l ()
    | & _7: UInt32.t = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & _10: t_Zero = Any.any_l () ])
    [ return''0 (result: UInt32.t) -> {[@expl:closure ensures] UInt32.t'int result = 0} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (x: t_Zero) (y: t_Zero) (return' (x'0: ())) = {[@expl:f 'x' type invariant] inv'0 x}
    {[@expl:f 'y' type invariant] inv'0 y}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:type invariant] inv'0 x'0} s1
      | s1 = {[@expl:type invariant] inv'0 y'0} s2
      | s2 = [ &clos <- { _0 = x'0; _1 = y'0 } ] s3
      | s3 = closure0 {clos} (fun (_ret: UInt32.t) -> [ &_6 <- _ret ] s4)
      | s4 = bb3 ]
    | bb3 = return''0 {_0'1} ]
    [ & _0'1: () = Any.any_l ()
    | & x'0: t_Zero = x
    | & y'0: t_Zero = y
    | & clos: closure0 = Any.any_l ()
    | & _6: UInt32.t = Any.any_l ()
    | & _8: () = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
