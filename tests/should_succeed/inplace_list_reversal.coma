module M_inplace_list_reversal__rev
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type tuple = { f0: t_T; f1: t_List }
  with t_List = C_Nil | C_Cons tuple
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_List)
  
  predicate inv'1 [@inline:trivial] (_1: tuple) = inv _1.f0 /\ inv'0 _1.f1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant' (self: tuple) = inv'1 self
  
  predicate inv'2 [@inline:trivial] (_1: tuple) = invariant' _1
  
  meta "rewrite_def" predicate inv'2
  
  axiom inv_axiom [@rewrite]: forall x: t_List [inv'0 x]. inv'0 x
      = match x with
        | C_Nil -> true
        | C_Cons a_0 -> inv'2 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_List) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'3 [@inline:trivial] (_1: MutBorrow.t t_List) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'3
  
  let rec replace (dest: MutBorrow.t t_List) (src: t_List) (return (x: t_List)) =
    {[@expl:replace 'dest' type invariant] inv'3 dest}
    {[@expl:replace 'src' type invariant] inv'0 src}
    any [ return (result: t_List) -> {inv'0 result} {dest.final = src} {result = dest.current} (! return {result}) ]
  
  function rev_append (n: t_List) (o: t_List) : t_List = match n with
      | C_Nil -> o
      | C_Cons {f0 = hd; f1 = tl} -> rev_append tl (C_Cons { f0 = hd; f1 = o })
      end
  
  let rec v_Cons (input: t_List) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Cons field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Cons field_0: t_List]. C_Cons field_0 <> input} (! {false} any) ]
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_List)
  
  predicate resolve'1 [@inline:trivial] (_1: tuple) = resolve _1.f0 /\ resolve'0 _1.f1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: tuple) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  axiom resolve_axiom [@rewrite]: forall x: t_List [resolve'0 x]. resolve'0 x
      = match x with
        | C_Nil -> true
        | C_Cons x0 -> resolve'2 x0
        end
  
  predicate resolve'3 [@inline:trivial] (_1: MutBorrow.t t_List) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rev (l: MutBorrow.t t_List) (return (x: ())) = {[@expl:rev 'l' type invariant] inv'3 l}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_l <- l ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &prev <- C_Nil ] s1
      | s1 = [ &_8 <- C_Nil ] s2
      | s2 = {inv'0 l.current}
        MutBorrow.borrow_mut <t_List> {l.current}
          (fun (_ret: MutBorrow.t t_List) ->
            [ &_7 <- _ret ] -{inv'0 _ret.final}-
            [ &l <- { l with current = _ret.final } ] s3)
      | s3 = replace {_7} {_8} (fun (_ret: t_List) -> [ &head <- _ret ] s4)
      | s4 = bb3 ]
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant #0] inv'0 prev}
        {[@expl:loop invariant #1] inv'0 head}
        {[@expl:loop invariant #2] rev_append head prev = rev_append old_l.current (C_Nil)}
        (! s0)
        [ s0 = bb4 ]
        [ bb4 = any [ br0 -> {head = C_Nil} (! bb18) | br1 (x0: tuple) -> {head = C_Cons x0} (! bb6) ]
        | bb6 = s0
          [ s0 = v_Cons {head} (fun (r0: tuple) -> [ &curr <- r0 ] s1) | s1 = [ &next <- curr.f1 ] s2 | s2 = bb7 ]
        | bb7 = s0 [ s0 = [ &curr <- { curr with f1 = prev } ] s1 | s1 = bb9 ]
        | bb9 = s0 [ s0 = [ &_19 <- C_Cons curr ] s1 | s1 = bb11 ]
        | bb11 = s0 [ s0 = [ &prev <- _19 ] s1 | s1 = bb14 ]
        | bb14 = s0 [ s0 = [ &head <- next ] s1 | s1 = bb3 ] ] ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] match head with
          | C_Cons x -> inv'2 x
          | _ -> true
          end}
        s1
      | s1 = -{match head with
          | C_Cons x -> resolve'2 x
          | _ -> true
          end}-
        s2
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv'0 l.current} s1
      | s1 = -{resolve'0 l.current}- s2
      | s2 = [ &l <- { l with current = prev } ] s3
      | s3 = {[@expl:type invariant] inv'3 l} s4
      | s4 = -{resolve'3 l}- s5
      | s5 = bb24 ]
    | bb24 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & l: MutBorrow.t t_List = l
    | & old_l: MutBorrow.t t_List = Any.any_l ()
    | & prev: t_List = Any.any_l ()
    | & head: t_List = Any.any_l ()
    | & _7: MutBorrow.t t_List = Any.any_l ()
    | & _8: t_List = Any.any_l ()
    | & curr: tuple = Any.any_l ()
    | & next: t_List = Any.any_l ()
    | & _19: t_List = Any.any_l () ])
    [ return (result: ()) -> {[@expl:rev ensures] l.final = rev_append l.current (C_Nil)} (! return {result}) ]
end
