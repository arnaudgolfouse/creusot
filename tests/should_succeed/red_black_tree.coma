module M_red_black_tree__qyi11959472507597060150__clone (* <Color as creusot_contracts::Clone> *)
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type tuple = { f0: t_Color; f1: t_Color }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: t_Color) (return (x: t_Color)) = (! bb0
    [ bb0 = any [ br0 -> {self = C_Red} (! bb4) | br1 -> {self = C_Black} (! bb3) ]
    | bb3 = s0 [ s0 = [ &_0 <- C_Black ] s1 | s1 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_Red ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ] [ & _0: t_Color = Any.any_l () | & self: t_Color = self ])
    [ return (result: t_Color) -> {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = C_Red; f1 = C_Red} -> true
        | {f0 = C_Black; f1 = C_Black} -> true
        | _ -> false
        end}
      (! return {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__model_acc_has_mapping (* Tree<K, V> *)
  use map.Map
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  constant accu : Map.map t_DeepModelTy t_Option'0
  
  constant k : t_DeepModelTy
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
  goal vc_model_acc_has_mapping: match self with
      | {t_Tree__node = C_None} -> [@expl:model_acc_has_mapping ensures] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> Map.get (model_acc left accu) k
          = Map.get accu k
        \/ (exists v: t_V. Map.get (model_acc left accu) k = C_Some'0 v /\ has_mapping left k v)
      -> (let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in Map.get (model_acc right accu2) k
          = Map.get accu2 k
        \/ (exists v: t_V. Map.get (model_acc right accu2) k = C_Some'0 v /\ has_mapping right k v)
      -> ([@expl:model_acc_has_mapping ensures] Map.get (model_acc self accu) k = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)))
      end
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_model_acc (* Tree<K, V> *)
  use map.Map
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  constant accu : Map.map t_DeepModelTy t_Option'0
  
  constant k : t_DeepModelTy
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model_acc: bst_invariant self
    -> match self with
      | {t_Tree__node = C_None} -> [@expl:has_mapping_model_acc ensures] forall v: t_V. has_mapping self k v
        -> Map.get (model_acc self accu) k = C_Some'0 v
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> ([@expl:has_mapping_model_acc requires] bst_invariant left)
      /\ ((forall v: t_V. has_mapping left k v -> Map.get (model_acc left accu) k = C_Some'0 v)
      -> (let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in ([@expl:has_mapping_model_acc requires] bst_invariant right)
      /\ ((forall v: t_V. has_mapping right k v -> Map.get (model_acc right accu2) k = C_Some'0 v)
      -> (let _ = has_mapping_model_acc right accu2 k in Map.get (model_acc right accu2) k = Map.get accu2 k
        \/ (exists v: t_V. Map.get (model_acc right accu2) k = C_Some'0 v /\ has_mapping right k v)
      -> ([@expl:has_mapping_model_acc ensures] forall v: t_V. has_mapping self k v
        -> Map.get (model_acc self accu) k = C_Some'0 v)))))
      end
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_model (* Tree<K, V> *)
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  constant k : t_DeepModelTy
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model: bst_invariant self
    -> Map.get (model_acc self (Const.const (C_None'0))) k = Map.get (Const.const (C_None'0)) k
      \/ (exists v: t_V. Map.get (model_acc self (Const.const (C_None'0))) k = C_Some'0 v /\ has_mapping self k v)
    -> (let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in ([@expl:has_mapping_model_acc requires] bst_invariant self)
    /\ ((forall v: t_V. has_mapping self k v -> Map.get (model_acc self (Const.const (C_None'0))) k = C_Some'0 v)
    -> ([@expl:has_mapping_model ensures] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))))
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_inj (* Tree<K, V> *)
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  constant k : t_DeepModelTy
  
  constant v1 : t_V
  
  constant v2 : t_V
  
  function has_mapping_inj (self: t_Tree) (k: t_DeepModelTy) (v1: t_V) (v2: t_V) : ()
  
  goal vc_has_mapping_inj: bst_invariant self
    -> has_mapping self k v1
    -> has_mapping self k v2
    -> ([@expl:has_mapping_model requires] bst_invariant self)
    /\ ((forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
    -> (let _ = has_mapping_model self k in match Map.get (view self) k with
      | C_None'0 -> [@expl:has_mapping_inj ensures] v1 = v2
      | C_Some'0 _v -> [@expl:has_mapping_inj ensures] v1 = v2
      end))
end
module M_red_black_tree__qyi3665871523867809084__has_mapping (* Node<K, V> *)
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node
  
  constant k : t_DeepModelTy
  
  constant v : t_V
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V)
  
  goal vc_has_mapping: if has_mapping self.t_Node__left k v then
      [@expl:has_mapping ensures] forall node: t_Node. self = node
        -> true = has_mapping { t_Tree__node = C_Some node } k v
    else
      if has_mapping self.t_Node__right k v then
        [@expl:has_mapping ensures] forall node: t_Node. self = node
          -> true = has_mapping { t_Tree__node = C_Some node } k v
      else
        if k = deep_model self.t_Node__key then
          [@expl:has_mapping ensures] forall node: t_Node. self = node
            -> (v = self.t_Node__val) = has_mapping { t_Tree__node = C_Some node } k v
        else
          [@expl:has_mapping ensures] forall node: t_Node. self = node
            -> false = has_mapping { t_Tree__node = C_Some node } k v
      
    

end
module M_red_black_tree__qyi8412372133095258695__resolve_coherence (* <Tree<K, V> as creusot_contracts::Resolve> *)
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve (_1: t_V)
  
  predicate resolve'0 (self: t_Node) = forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_1: t_Node) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (self: t_Node) = resolve'1 self
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_Node) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_Option) =
    match self with
      | C_Some x -> resolve'3 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: t_Option) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  predicate structural_resolve (_1: t_Tree) =
    match _1 with
      | {t_Tree__node = x0} -> resolve'5 x0
      end
  
  predicate resolve'6 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  function resolve_coherence (self: t_Tree) : ()
  
  goal vc_resolve_coherence: structural_resolve self -> ([@expl:resolve_coherence ensures] resolve'6 self)
end
module M_red_black_tree__qyi17767811206440054577__resolve_coherence (* <Node<K, V> as creusot_contracts::Resolve> *)
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_1: t_V)
  
  predicate resolve'0 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_1: t_Tree) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (_1: t_K)
  
  predicate structural_resolve (_1: t_Node) =
    match _1 with
      | {t_Node__left = x0; t_Node__color = x1; t_Node__key = x2; t_Node__val = x3; t_Node__right = x4} -> resolve'1 x4
      /\ resolve x3 /\ resolve'2 x2 /\ resolve'1 x0
      end
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'3 (self: t_Node) = forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node
  
  function resolve_coherence (self: t_Node) : ()
  
  goal vc_resolve_coherence: structural_resolve self -> ([@expl:resolve_coherence ensures] resolve'3 self)
end
module M_red_black_tree__qyi3529752165842986389__height (* Tree<K, V> *)
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  function height (self: t_Tree) : int
  
  goal vc_height: match self with
      | {t_Tree__node = C_None} -> [@expl:height ensures] 0 >= 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left >= 0 -> ([@expl:height ensures] height left >= 0)
        | C_Black -> height left >= 0 -> ([@expl:height ensures] height left + 1 >= 0)
        end
      end
end
module M_red_black_tree__qyi3665871523867809084__height (* Node<K, V> *)
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node
  
  function height'0 (self: t_Node) : int
  
  goal vc_height: match self.t_Node__color with
      | C_Red -> height self.t_Node__left >= 0
      -> ([@expl:height ensures] forall node: t_Node. self = node
        -> height self.t_Node__left = height { t_Tree__node = C_Some node })
      | C_Black -> height self.t_Node__left >= 0
      -> ([@expl:height ensures] forall node: t_Node. self = node
        -> height self.t_Node__left + 1 = height { t_Tree__node = C_Some node })
      end
end
module M_red_black_tree__qyi3529752165842986389__is_red (* Tree<K, V> *)
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate inv'2 (_1: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate invariant''0 [@inline:trivial] (self: t_Tree) = inv'2 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'5 self}
    (! bb0
    [ bb0 = any
      [ br0 -> {self.t_Tree__node = C_None} (! bb1) | br1 (x0: t_Node) -> {self.t_Tree__node = C_Some x0} (! bb2) ]
    | bb2 = v_Some {self.t_Tree__node}
        (fun (r0: t_Node) ->
          any [ br0 -> {r0.t_Node__color = C_Red} (! bb4) | br1 -> {r0.t_Node__color = C_Black} (! bb1) ])
    | bb1 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ] [ & _0: bool = Any.any_l () | & self: t_Tree = self ])
    [ return (result: bool) -> {[@expl:is_red ensures] result = (color self = C_Red)} (! return {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__rotate_right (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return (x: t_Option)) = any
    [ return' (result: t_Option) -> {inv'2 result} {result = C_None} (! return {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return (x: t_Option)) = {[@expl:take 'dest' type invariant] inv'5 dest}
    any
    [ return' (result: t_Option) -> {inv'2 result}
      {result = dest.current}
      {postcondition () () dest.final}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  let rec unwrap (self_: t_Option) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'2 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return' (result: t_Node) -> {inv'4 result} {C_Some result = self_} (! return {result}) ]
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  let rec swap (x: MutBorrow.t t_Tree) (y: MutBorrow.t t_Tree) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv'6 x}
    {[@expl:swap 'y' type invariant] inv'6 y}
    any [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Tree) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: MutBorrow.t t_Tree) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  let rec swap'0 (x: MutBorrow.t t_Node) (y: MutBorrow.t t_Node) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv'7 x}
    {[@expl:swap 'y' type invariant] inv'7 y}
    any [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  let rec swap'1 (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Color) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: MutBorrow.t t_Color) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve'8 (_1: t_V)
  
  predicate resolve'9 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_1: t_Tree) = resolve'9 _1
  
  meta "rewrite_def" predicate resolve'10
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'11 _1
  
  meta "rewrite_def" predicate resolve'12
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple = { f0: t_Tree; f1: t_Tree; f2: t_Tree }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv'7 self}
    {[@expl:rotate_right requires #0] internal_invariant self.current}
    {[@expl:rotate_right requires #1] color self.current.t_Node__left = C_Red}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 self.current.t_Node__left.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Node__left.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_16 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__left = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = {inv'2 _16.current}
        MutBorrow.borrow_final <t_Option> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &_16 <- { _16 with current = _ret.final } ] s2)
      | s2 = take {_15} (fun (_ret: t_Option) -> [ &_14 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'5 _16} s1
      | s1 = -{resolve'1 _16}- s2
      | s2 = unwrap {_14} (fun (_ret: t_Node) -> [ &x <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'1 self.current.t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {self.current.t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_19 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__left = _ret.final } } ] s1)
      | s1 = {inv'1 x.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {x.t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_21 <- _ret ] -{inv'1 _ret.final}-
            [ &x <- { x with t_Node__right = _ret.final } ] s2)
      | s2 = {inv'1 _19.current}
        MutBorrow.borrow_final <t_Tree> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_18 <- _ret ] -{inv'1 _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s3)
      | s3 = {inv'1 _21.current}
        MutBorrow.borrow_final <t_Tree> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_20 <- _ret ] -{inv'1 _ret.final}-
            [ &_21 <- { _21 with current = _ret.final } ] s4)
      | s4 = swap {_18} {_20} (fun (_ret: ()) -> [ &_17 <- _ret ] s5)
      | s5 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'3 _21}- s2
      | s2 = {[@expl:type invariant] inv'6 _19} s3
      | s3 = -{resolve'3 _19}- s4
      | s4 = {inv'4 x}
        MutBorrow.borrow_mut <t_Node> {x}
          (fun (_ret: MutBorrow.t t_Node) -> [ &_25 <- _ret ] -{inv'4 _ret.final}- [ &x <- _ret.final ] s5)
      | s5 = {inv'3 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_23 <- _ret ] -{inv'3 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s6)
      | s6 = {inv'3 _25.current}
        MutBorrow.borrow_final <t_Node> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_24 <- _ret ] -{inv'3 _ret.final}-
            [ &_25 <- { _25 with current = _ret.final } ] s7)
      | s7 = swap'0 {_23} {_24} (fun (_ret: ()) -> [ &_22 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'8 _25} s1
      | s1 = -{resolve'5 _25}- s2
      | s2 = MutBorrow.borrow_final <t_Color> {self.current.t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_28 <- _ret ] [ &self <- { self with current = { self.current with t_Node__color = _ret.final } } ] s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.t_Node__color}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_30 <- _ret ] [ &x <- { x with t_Node__color = _ret.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_27 <- _ret ] [ &_28 <- { _28 with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_29 <- _ret ] [ &_30 <- { _30 with current = _ret.final } ] s6)
      | s6 = swap'1 {_27} {_29} (fun (_ret: ()) -> [ &_26 <- _ret ] s7)
      | s7 = bb6 ]
    | bb6 = s0
      [ s0 = -{resolve'7 _30}- s1
      | s1 = -{resolve'7 _28}- s2
      | s2 =
        {[@expl:assertion] has_mapping old_self.current.t_Node__left (deep_model self.current.t_Node__key) self.current.t_Node__val}
        s3
      | s3 = [ &_34 <- C_Some x ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_33 <- { t_Tree__node = _34 } ] s1 | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'1 self.current.t_Node__right} s1
      | s1 = -{resolve'10 self.current.t_Node__right}- s2
      | s2 = [ &self <- { self with current = { self.current with t_Node__right = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'12 self}- s5
      | s5 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Node = self
    | & old_self: MutBorrow.t t_Node = Any.any_l ()
    | & x: t_Node = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: MutBorrow.t t_Tree = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _21: MutBorrow.t t_Tree = Any.any_l ()
    | & _22: () = Any.any_l ()
    | & _23: MutBorrow.t t_Node = Any.any_l ()
    | & _24: MutBorrow.t t_Node = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Color = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _33: t_Tree = Any.any_l ()
    | & _34: t_Option = Any.any_l () ])
    [ return (result: ()) -> {[@expl:rotate_right ensures #0] same_mappings self.current self.final}
      {[@expl:rotate_right ensures #1] internal_invariant self.final}
      {[@expl:rotate_right ensures #2] height'0 self.current = height'0 self.final}
      {[@expl:rotate_right ensures #3] lt_log (deep_model self.final.t_Node__key) (deep_model self.current.t_Node__key)}
      {[@expl:rotate_right ensures #4] color self.final.t_Node__right = C_Red}
      {[@expl:rotate_right ensures #5] self.final.t_Node__color = self.current.t_Node__color}
      {[@expl:rotate_right ensures #6] exists l: t_Node, r: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l
        /\ self.final.t_Node__right.t_Tree__node = C_Some r
        /\ { f0 = self.final.t_Node__left; f1 = r.t_Node__left; f2 = r.t_Node__right }
          = { f0 = l.t_Node__left; f1 = l.t_Node__right; f2 = self.current.t_Node__right }
        /\ r.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__rotate_left (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return (x: t_Option)) = any
    [ return' (result: t_Option) -> {inv'2 result} {result = C_None} (! return {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return (x: t_Option)) = {[@expl:take 'dest' type invariant] inv'5 dest}
    any
    [ return' (result: t_Option) -> {inv'2 result}
      {result = dest.current}
      {postcondition () () dest.final}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  let rec unwrap (self_: t_Option) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'2 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return' (result: t_Node) -> {inv'4 result} {C_Some result = self_} (! return {result}) ]
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  let rec swap (x: MutBorrow.t t_Tree) (y: MutBorrow.t t_Tree) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv'6 x}
    {[@expl:swap 'y' type invariant] inv'6 y}
    any [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Tree) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: MutBorrow.t t_Tree) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  let rec swap'0 (x: MutBorrow.t t_Node) (y: MutBorrow.t t_Node) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv'7 x}
    {[@expl:swap 'y' type invariant] inv'7 y}
    any [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  let rec swap'1 (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Color) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: MutBorrow.t t_Color) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve'8 (_1: t_V)
  
  predicate resolve'9 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_1: t_Tree) = resolve'9 _1
  
  meta "rewrite_def" predicate resolve'10
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'11 _1
  
  meta "rewrite_def" predicate resolve'12
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple = { f0: t_Tree; f1: t_Tree; f2: t_Tree }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rotate_left (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv'7 self}
    {[@expl:rotate_left requires #0] internal_invariant self.current}
    {[@expl:rotate_left requires #1] color self.current.t_Node__right = C_Red}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 self.current.t_Node__right.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Node__right.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_16 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__right = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = {inv'2 _16.current}
        MutBorrow.borrow_final <t_Option> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &_16 <- { _16 with current = _ret.final } ] s2)
      | s2 = take {_15} (fun (_ret: t_Option) -> [ &_14 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'5 _16} s1
      | s1 = -{resolve'1 _16}- s2
      | s2 = unwrap {_14} (fun (_ret: t_Node) -> [ &x <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'1 self.current.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {self.current.t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_19 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__right = _ret.final } } ] s1)
      | s1 = {inv'1 x.t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {x.t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_21 <- _ret ] -{inv'1 _ret.final}-
            [ &x <- { x with t_Node__left = _ret.final } ] s2)
      | s2 = {inv'1 _19.current}
        MutBorrow.borrow_final <t_Tree> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_18 <- _ret ] -{inv'1 _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s3)
      | s3 = {inv'1 _21.current}
        MutBorrow.borrow_final <t_Tree> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_20 <- _ret ] -{inv'1 _ret.final}-
            [ &_21 <- { _21 with current = _ret.final } ] s4)
      | s4 = swap {_18} {_20} (fun (_ret: ()) -> [ &_17 <- _ret ] s5)
      | s5 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'3 _21}- s2
      | s2 = {[@expl:type invariant] inv'6 _19} s3
      | s3 = -{resolve'3 _19}- s4
      | s4 = {inv'4 x}
        MutBorrow.borrow_mut <t_Node> {x}
          (fun (_ret: MutBorrow.t t_Node) -> [ &_25 <- _ret ] -{inv'4 _ret.final}- [ &x <- _ret.final ] s5)
      | s5 = {inv'3 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_23 <- _ret ] -{inv'3 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s6)
      | s6 = {inv'3 _25.current}
        MutBorrow.borrow_final <t_Node> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_24 <- _ret ] -{inv'3 _ret.final}-
            [ &_25 <- { _25 with current = _ret.final } ] s7)
      | s7 = swap'0 {_23} {_24} (fun (_ret: ()) -> [ &_22 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'8 _25} s1
      | s1 = -{resolve'5 _25}- s2
      | s2 = MutBorrow.borrow_final <t_Color> {self.current.t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_28 <- _ret ] [ &self <- { self with current = { self.current with t_Node__color = _ret.final } } ] s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.t_Node__color}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_30 <- _ret ] [ &x <- { x with t_Node__color = _ret.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_27 <- _ret ] [ &_28 <- { _28 with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_29 <- _ret ] [ &_30 <- { _30 with current = _ret.final } ] s6)
      | s6 = swap'1 {_27} {_29} (fun (_ret: ()) -> [ &_26 <- _ret ] s7)
      | s7 = bb6 ]
    | bb6 = s0
      [ s0 = -{resolve'7 _30}- s1
      | s1 = -{resolve'7 _28}- s2
      | s2 =
        {[@expl:assertion] has_mapping old_self.current.t_Node__right (deep_model self.current.t_Node__key) self.current.t_Node__val}
        s3
      | s3 = [ &_34 <- C_Some x ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_33 <- { t_Tree__node = _34 } ] s1 | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'1 self.current.t_Node__left} s1
      | s1 = -{resolve'10 self.current.t_Node__left}- s2
      | s2 = [ &self <- { self with current = { self.current with t_Node__left = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'12 self}- s5
      | s5 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Node = self
    | & old_self: MutBorrow.t t_Node = Any.any_l ()
    | & x: t_Node = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: MutBorrow.t t_Tree = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _21: MutBorrow.t t_Tree = Any.any_l ()
    | & _22: () = Any.any_l ()
    | & _23: MutBorrow.t t_Node = Any.any_l ()
    | & _24: MutBorrow.t t_Node = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Color = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _33: t_Tree = Any.any_l ()
    | & _34: t_Option = Any.any_l () ])
    [ return (result: ()) -> {[@expl:rotate_left ensures #0] same_mappings self.current self.final}
      {[@expl:rotate_left ensures #1] internal_invariant self.final}
      {[@expl:rotate_left ensures #2] height'0 self.current = height'0 self.final}
      {[@expl:rotate_left ensures #3] lt_log (deep_model self.current.t_Node__key) (deep_model self.final.t_Node__key)}
      {[@expl:rotate_left ensures #4] color self.final.t_Node__left = C_Red}
      {[@expl:rotate_left ensures #5] self.final.t_Node__color = self.current.t_Node__color}
      {[@expl:rotate_left ensures #6] exists l: t_Node, r: t_Node. self.current.t_Node__right.t_Tree__node = C_Some r
        /\ self.final.t_Node__left.t_Tree__node = C_Some l
        /\ { f0 = l.t_Node__left; f1 = l.t_Node__right; f2 = self.final.t_Node__right }
          = { f0 = self.current.t_Node__left; f1 = r.t_Node__left; f2 = r.t_Node__right }
        /\ l.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__flip_colors (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_1: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] inv'5 self_}
    any
    [ return' (result: t_Option'0) -> {inv'7 result}
      {self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'7 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'6 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec swap (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Color) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Color) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec flip_colors (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv'8 self}
    {[@expl:flip_colors requires #0] internal_invariant self.current}
    {[@expl:flip_colors requires #1] self.current.t_Node__left.t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] self.current.t_Node__right.t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] color self.current.t_Node__left = color self.current.t_Node__right}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 self.current.t_Node__left.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Node__left.t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__left = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = as_mut {_15} (fun (_ret: t_Option'0) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret: MutBorrow.t t_Node) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_13 <- { _13 with current = { _13.current with t_Node__color = self.current.t_Node__color } } ] s1
      | s1 = {[@expl:type invariant] inv'6 _13} s2
      | s2 = -{resolve'0 _13}- s3
      | s3 = MutBorrow.borrow_final <t_Color> {self.current.t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_18 <- _ret ] [ &self <- { self with current = { self.current with t_Node__color = _ret.final } } ] s4)
      | s4 = {inv'2 self.current.t_Node__right.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Node__right.t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 5) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_23 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__right = { t_Tree__node = _ret.final } } } ] s5)
      | s5 = as_mut {_23} (fun (_ret: t_Option'0) -> [ &_22 <- _ret ] s6)
      | s6 = bb3 ]
    | bb3 = s0 [ s0 = unwrap {_22} (fun (_ret: MutBorrow.t t_Node) -> [ &_21 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_final <t_Color> {_21.current.t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id _21) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_20 <- _ret ] [ &_21 <- { _21 with current = { _21.current with t_Node__color = _ret.final } } ] s1)
      | s1 = MutBorrow.borrow_final <t_Color> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_17 <- _ret ] [ &_18 <- { _18 with current = _ret.final } ] s2)
      | s2 = MutBorrow.borrow_final <t_Color> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_19 <- _ret ] [ &_20 <- { _20 with current = _ret.final } ] s3)
      | s3 = swap {_17} {_19} (fun (_ret: ()) -> [ &_16 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = -{resolve'2 _20}- s3
      | s3 = -{resolve'2 _18}- s4
      | s4 = {[@expl:type invariant] inv'8 self} s5
      | s5 = -{resolve'4 self}- s6
      | s6 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Node = self
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: MutBorrow.t t_Color = Any.any_l ()
    | & _18: MutBorrow.t t_Color = Any.any_l ()
    | & _19: MutBorrow.t t_Color = Any.any_l ()
    | & _20: MutBorrow.t t_Color = Any.any_l ()
    | & _21: MutBorrow.t t_Node = Any.any_l ()
    | & _22: t_Option'0 = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l () ])
    [ return (result: ()) -> {[@expl:flip_colors ensures #0] internal_invariant self.final}
      {[@expl:flip_colors ensures #1] height'0 self.current = height'0 self.final}
      {[@expl:flip_colors ensures #2] same_mappings self.current self.final}
      {[@expl:flip_colors ensures #3] self.current.t_Node__key = self.final.t_Node__key}
      {[@expl:flip_colors ensures #4] exists l1: t_Node, l2: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l1
        /\ self.final.t_Node__left.t_Tree__node = C_Some l2
        /\ l1.t_Node__left = l2.t_Node__left
        /\ l1.t_Node__right = l2.t_Node__right
        /\ l1.t_Node__key = l2.t_Node__key
        /\ self.current.t_Node__color = l2.t_Node__color /\ self.final.t_Node__color = l1.t_Node__color}
      {[@expl:flip_colors ensures #5] exists r1: t_Node, r2: t_Node. self.current.t_Node__right.t_Tree__node = C_Some r1
        /\ self.final.t_Node__right.t_Tree__node = C_Some r2
        /\ r1.t_Node__left = r2.t_Node__left
        /\ r1.t_Node__right = r2.t_Node__right
        /\ r1.t_Node__key = r2.t_Node__key
        /\ self.current.t_Node__color = r2.t_Node__color
        /\ self.final.t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__balance (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate inv'2 (_1: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate invariant''0 [@inline:trivial] (self: t_Tree) = inv'2 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'5 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple = { f0: t_Tree; f1: t_Tree; f2: t_Tree }
  
  let rec rotate_left (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv'6 self}
    {[@expl:rotate_left requires #0] internal_invariant self.current}
    {[@expl:rotate_left requires #1] color self.current.t_Node__right = C_Red}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {lt_log (deep_model self.current.t_Node__key) (deep_model self.final.t_Node__key)}
      {color self.final.t_Node__left = C_Red}
      {self.final.t_Node__color = self.current.t_Node__color}
      {exists l: t_Node, r: t_Node. self.current.t_Node__right.t_Tree__node = C_Some r
        /\ self.final.t_Node__left.t_Tree__node = C_Some l
        /\ { f0 = l.t_Node__left; f1 = l.t_Node__right; f2 = self.final.t_Node__right }
          = { f0 = self.current.t_Node__left; f1 = r.t_Node__left; f2 = r.t_Node__right }
        /\ l.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Node
  
  predicate invariant''2 [@inline:trivial] (self: t_Option) = inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: t_Option)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: t_Node) = inv'3 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate inv'9 (_1: t_Option'0)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Option'0 [inv'9 x]. inv'9 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'8 a_0
        end
  
  let rec as_ref (self_: t_Option) (return (x: t_Option'0)) = {[@expl:as_ref 'self_' type invariant] inv'7 self_}
    any
    [ return' (result: t_Option'0) -> {inv'9 result}
      {self_ = C_None -> result = C_None'0}
      {self_ = C_None \/ (exists r: t_Node. result = C_Some'0 r /\ self_ = C_Some r)}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'9 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: t_Node) -> {inv'8 result} {C_Some'0 result = self_} (! return {result}) ]
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv'6 self}
    {[@expl:rotate_right requires #0] internal_invariant self.current}
    {[@expl:rotate_right requires #1] color self.current.t_Node__left = C_Red}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {lt_log (deep_model self.final.t_Node__key) (deep_model self.current.t_Node__key)}
      {color self.final.t_Node__right = C_Red}
      {self.final.t_Node__color = self.current.t_Node__color}
      {exists l: t_Node, r: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l
        /\ self.final.t_Node__right.t_Tree__node = C_Some r
        /\ { f0 = self.final.t_Node__left; f1 = r.t_Node__left; f2 = r.t_Node__right }
          = { f0 = l.t_Node__left; f1 = l.t_Node__right; f2 = self.current.t_Node__right }
        /\ r.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
  
  let rec flip_colors (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv'6 self}
    {[@expl:flip_colors requires #0] internal_invariant self.current}
    {[@expl:flip_colors requires #1] self.current.t_Node__left.t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] self.current.t_Node__right.t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] color self.current.t_Node__left = color self.current.t_Node__right}
    any
    [ return' (result: ()) -> {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {same_mappings self.current self.final}
      {self.current.t_Node__key = self.final.t_Node__key}
      {exists l1: t_Node, l2: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l1
        /\ self.final.t_Node__left.t_Tree__node = C_Some l2
        /\ l1.t_Node__left = l2.t_Node__left
        /\ l1.t_Node__right = l2.t_Node__right
        /\ l1.t_Node__key = l2.t_Node__key
        /\ self.current.t_Node__color = l2.t_Node__color /\ self.final.t_Node__color = l1.t_Node__color}
      {exists r1: t_Node, r2: t_Node. self.current.t_Node__right.t_Tree__node = C_Some r1
        /\ self.final.t_Node__right.t_Tree__node = C_Some r2
        /\ r1.t_Node__left = r2.t_Node__left
        /\ r1.t_Node__right = r2.t_Node__right
        /\ r1.t_Node__key = r2.t_Node__key
        /\ self.current.t_Node__color = r2.t_Node__color
        /\ self.final.t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant'0 (self: t_Node) =
    color_invariant_here self /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n (self: t_CP) (node: t_Node) =
    match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec balance (self: MutBorrow.t t_Node) (return (x: ())) = {[@expl:balance 'self' type invariant] inv'6 self}
    {[@expl:balance requires #0] internal_invariant self.current}
    {[@expl:balance requires #1] self.current.t_Node__color = C_Red /\ color self.current.t_Node__left = C_Red
    -> color_invariant self.current.t_Node__left}
    {[@expl:balance requires #2] self.current.t_Node__color = C_Red /\ color self.current.t_Node__right = C_Red
    -> color_invariant self.current.t_Node__right}
    {[@expl:balance requires #3] self.current.t_Node__color = C_Red
      /\ color self.current.t_Node__right = C_Red /\ color self.current.t_Node__left = C_Red -> false}
    (! bb0
    [ bb0 = s0 [ s0 = is_red {self.current.t_Node__right} (fun (_ret: bool) -> [ &_15 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb2) ]
    | bb2 = s0 [ s0 = is_red {self.current.t_Node__left} (fun (_ret: bool) -> [ &_17 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb9) ]
    | bb5 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_20 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = rotate_left {_20} (fun (_ret: ()) -> [ &_19 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = is_red {self.current.t_Node__left} (fun (_ret: bool) -> [ &_22 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb20) | br1 -> {_22} (! bb11) ]
    | bb11 = s0
      [ s0 = as_ref {self.current.t_Node__left.t_Tree__node} (fun (_ret: t_Option'0) -> [ &_27 <- _ret ] s1)
      | s1 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_27} (fun (_ret: t_Node) -> [ &_26 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = is_red {_26.t_Node__left} (fun (_ret: bool) -> [ &_24 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb15) ]
    | bb15 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_30 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = rotate_right {_30} (fun (_ret: ()) -> [ &_29 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = is_red {self.current.t_Node__left} (fun (_ret: bool) -> [ &_31 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = any [ br0 -> {_31 = false} (! bb27) | br1 -> {_31} (! bb22) ]
    | bb22 = s0 [ s0 = is_red {self.current.t_Node__right} (fun (_ret: bool) -> [ &_33 <- _ret ] s1) | s1 = bb23 ]
    | bb23 = any [ br0 -> {_33 = false} (! bb26) | br1 -> {_33} (! bb24) ]
    | bb24 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_final <t_Node> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_36 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors {_36} (fun (_ret: ()) -> [ &_35 <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0 [ s0 = {[@expl:type invariant] inv'6 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb29 ]
    | bb26 = s0 [ s0 = {[@expl:type invariant] inv'6 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb29 ]
    | bb27 = s0 [ s0 = {[@expl:type invariant] inv'6 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb29 ]
    | bb29 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Node = self
    | & _15: bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Node = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_Node = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _35: () = Any.any_l ()
    | & _36: MutBorrow.t t_Node = Any.any_l () ])
    [ return (result: ()) -> {[@expl:balance ensures #0] same_mappings self.current self.final}
      {[@expl:balance ensures #1] internal_invariant self.final}
      {[@expl:balance ensures #2] height'0 self.current = height'0 self.final}
      {[@expl:balance ensures #3] color_invariant self.current.t_Node__left
        /\ color self.current.t_Node__right = C_Black -> self.current = self.final}
      {[@expl:balance ensures #4] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {[@expl:balance ensures #5] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[@expl:balance ensures #6] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[@expl:balance ensures #7] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      (! return {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__move_red_left (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'2 (_1: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  predicate inv'4 (_1: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
      = match x with
        | {t_Tree__node = node} -> inv'3 node
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'4 left
        /\ inv key /\ inv'0 val' /\ inv'4 right
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Node [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec flip_colors (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv'5 self}
    {[@expl:flip_colors requires #0] internal_invariant self.current}
    {[@expl:flip_colors requires #1] self.current.t_Node__left.t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] self.current.t_Node__right.t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] color self.current.t_Node__left = color self.current.t_Node__right}
    any
    [ return' (result: ()) -> {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {same_mappings self.current self.final}
      {self.current.t_Node__key = self.final.t_Node__key}
      {exists l1: t_Node, l2: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l1
        /\ self.final.t_Node__left.t_Tree__node = C_Some l2
        /\ l1.t_Node__left = l2.t_Node__left
        /\ l1.t_Node__right = l2.t_Node__right
        /\ l1.t_Node__key = l2.t_Node__key
        /\ self.current.t_Node__color = l2.t_Node__color /\ self.final.t_Node__color = l1.t_Node__color}
      {exists r1: t_Node, r2: t_Node. self.current.t_Node__right.t_Tree__node = C_Some r1
        /\ self.final.t_Node__right.t_Tree__node = C_Some r2
        /\ r1.t_Node__left = r2.t_Node__left
        /\ r1.t_Node__right = r2.t_Node__right
        /\ r1.t_Node__key = r2.t_Node__key
        /\ self.current.t_Node__color = r2.t_Node__color
        /\ self.final.t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_1: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'7 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] inv'6 self_}
    any
    [ return' (result: t_Option'0) -> {inv'8 result}
      {self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'8 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'7 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = inv'4 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_1: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'9 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  type tuple = { f0: t_Tree; f1: t_Tree; f2: t_Tree }
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv'5 self}
    {[@expl:rotate_right requires #0] internal_invariant self.current}
    {[@expl:rotate_right requires #1] color self.current.t_Node__left = C_Red}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {lt_log (deep_model self.final.t_Node__key) (deep_model self.current.t_Node__key)}
      {color self.final.t_Node__right = C_Red}
      {self.final.t_Node__color = self.current.t_Node__color}
      {exists l: t_Node, r: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l
        /\ self.final.t_Node__right.t_Tree__node = C_Some r
        /\ { f0 = self.final.t_Node__left; f1 = r.t_Node__left; f2 = r.t_Node__right }
          = { f0 = l.t_Node__left; f1 = l.t_Node__right; f2 = self.current.t_Node__right }
        /\ r.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
  
  let rec rotate_left (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv'5 self}
    {[@expl:rotate_left requires #0] internal_invariant self.current}
    {[@expl:rotate_left requires #1] color self.current.t_Node__right = C_Red}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {lt_log (deep_model self.current.t_Node__key) (deep_model self.final.t_Node__key)}
      {color self.final.t_Node__left = C_Red}
      {self.final.t_Node__color = self.current.t_Node__color}
      {exists l: t_Node, r: t_Node. self.current.t_Node__right.t_Tree__node = C_Some r
        /\ self.final.t_Node__left.t_Tree__node = C_Some l
        /\ { f0 = l.t_Node__left; f1 = l.t_Node__right; f2 = self.final.t_Node__right }
          = { f0 = self.current.t_Node__left; f1 = r.t_Node__left; f2 = r.t_Node__right }
        /\ l.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 (self: t_Node) =
    color_invariant_here self /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n (self: t_CP) (node: t_Node) =
    match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec move_red_left (self: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_left 'self' type invariant] inv'5 self}
    {[@expl:move_red_left requires #0] self.current.t_Node__right.t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] internal_invariant self.current}
    {[@expl:move_red_left requires #2] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_16 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors {_16} (fun (_ret: ()) -> [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'3 self.current.t_Node__right.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Node__right.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_22 <- _ret ] -{inv'3 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__right = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = as_mut {_22} (fun (_ret: t_Option'0) -> [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_21} (fun (_ret: MutBorrow.t t_Node) -> [ &_20 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'7 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = is_red {_20.current.t_Node__left} (fun (_ret: bool) -> [ &_18 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_18 = false} (! bb13) | br1 -> {_18} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv'3 self.current.t_Node__right.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Node__right.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_28 <- _ret ] -{inv'3 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__right = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = as_mut {_28} (fun (_ret: t_Option'0) -> [ &_27 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = unwrap {_27} (fun (_ret: MutBorrow.t t_Node) -> [ &_26 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'1 _26.current}
        MutBorrow.borrow_final <t_Node> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_25 <- _ret ] -{inv'1 _ret.final}-
            [ &_26 <- { _26 with current = _ret.final } ] s1)
      | s1 = rotate_right {_25} (fun (_ret: ()) -> [ &_24 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'7 _26} s1
      | s1 = -{resolve'0 _26}- s2
      | s2 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_30 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s3)
      | s3 = rotate_left {_30} (fun (_ret: ()) -> [ &_29 <- _ret ] s4)
      | s4 = bb9 ]
    | bb9 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_32 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors {_32} (fun (_ret: ()) -> [ &_31 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'3 self.current.t_Node__left.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Node__left.t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_35 <- _ret ] -{inv'3 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__left = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = as_mut {_35} (fun (_ret: t_Option'0) -> [ &_34 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0 [ s0 = unwrap {_34} (fun (_ret: MutBorrow.t t_Node) -> [ &_33 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = {inv'1 _33.current}
        MutBorrow.borrow_final <t_Node> {_33.current} {MutBorrow.get_id _33}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_0 <- _ret ] -{inv'1 _ret.final}-
            [ &_33 <- { _33 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'7 _33} s2
      | s2 = -{resolve'0 _33}- s3
      | s3 = bb16 ]
    | bb16 = s0 [ s0 = {[@expl:type invariant] inv'5 self} s1 | s1 = -{resolve'2 self}- s2 | s2 = bb14 ]
    | bb13 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = bb14 ]
    | bb14 = return {_0} ]
    [ & _0: MutBorrow.t t_Node = Any.any_l ()
    | & self: MutBorrow.t t_Node = self
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Node = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _21: t_Option'0 = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: MutBorrow.t t_Node = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _28: MutBorrow.t t_Option = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_Node = Any.any_l ()
    | & _31: () = Any.any_l ()
    | & _32: MutBorrow.t t_Node = Any.any_l ()
    | & _33: MutBorrow.t t_Node = Any.any_l ()
    | & _34: t_Option'0 = Any.any_l ()
    | & _35: MutBorrow.t t_Option = Any.any_l () ])
    [ return (result: MutBorrow.t t_Node) -> {[@expl:move_red_left result type invariant] inv'5 result}
      {[@expl:move_red_left ensures #0] internal_invariant result.current}
      {[@expl:move_red_left ensures #1] internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {[@expl:move_red_left ensures #2] height'0 result.current = height'0 result.final
      -> height'0 self.current = height'0 self.final}
      {[@expl:move_red_left ensures #3] self.current.t_Node__key = result.current.t_Node__key}
      {[@expl:move_red_left ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
        -> has_mapping'0 self.current k v}
      {[@expl:move_red_left ensures #5] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
          /\ le_log k (deep_model self.current.t_Node__key) -> has_mapping'0 result.current k v}
      {[@expl:move_red_left ensures #6] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:move_red_left ensures #7] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[@expl:move_red_left ensures #8] color_invariant'0 result.final
        /\ (color result.current.t_Node__right = C_Black -> result.final.t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__move_red_right (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'2 (_1: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  predicate inv'4 (_1: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
      = match x with
        | {t_Tree__node = node} -> inv'3 node
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'4 left
        /\ inv key /\ inv'0 val' /\ inv'4 right
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Node [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec flip_colors (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv'5 self}
    {[@expl:flip_colors requires #0] internal_invariant self.current}
    {[@expl:flip_colors requires #1] self.current.t_Node__left.t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] self.current.t_Node__right.t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] color self.current.t_Node__left = color self.current.t_Node__right}
    any
    [ return' (result: ()) -> {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {same_mappings self.current self.final}
      {self.current.t_Node__key = self.final.t_Node__key}
      {exists l1: t_Node, l2: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l1
        /\ self.final.t_Node__left.t_Tree__node = C_Some l2
        /\ l1.t_Node__left = l2.t_Node__left
        /\ l1.t_Node__right = l2.t_Node__right
        /\ l1.t_Node__key = l2.t_Node__key
        /\ self.current.t_Node__color = l2.t_Node__color /\ self.final.t_Node__color = l1.t_Node__color}
      {exists r1: t_Node, r2: t_Node. self.current.t_Node__right.t_Tree__node = C_Some r1
        /\ self.final.t_Node__right.t_Tree__node = C_Some r2
        /\ r1.t_Node__left = r2.t_Node__left
        /\ r1.t_Node__right = r2.t_Node__right
        /\ r1.t_Node__key = r2.t_Node__key
        /\ self.current.t_Node__color = r2.t_Node__color
        /\ self.final.t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_1: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'7 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] inv'6 self_}
    any
    [ return' (result: t_Option'0) -> {inv'8 result}
      {self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'8 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'7 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = inv'4 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_1: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'9 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  type tuple = { f0: t_Tree; f1: t_Tree; f2: t_Tree }
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv'5 self}
    {[@expl:rotate_right requires #0] internal_invariant self.current}
    {[@expl:rotate_right requires #1] color self.current.t_Node__left = C_Red}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {lt_log (deep_model self.final.t_Node__key) (deep_model self.current.t_Node__key)}
      {color self.final.t_Node__right = C_Red}
      {self.final.t_Node__color = self.current.t_Node__color}
      {exists l: t_Node, r: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l
        /\ self.final.t_Node__right.t_Tree__node = C_Some r
        /\ { f0 = self.final.t_Node__left; f1 = r.t_Node__left; f2 = r.t_Node__right }
          = { f0 = l.t_Node__left; f1 = l.t_Node__right; f2 = self.current.t_Node__right }
        /\ r.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 (self: t_Node) =
    color_invariant_here self /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n (self: t_CP) (node: t_Node) =
    match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec move_red_right (self: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_right 'self' type invariant] inv'5 self}
    {[@expl:move_red_right requires #0] self.current.t_Node__left.t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] internal_invariant self.current}
    {[@expl:move_red_right requires #2] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_16 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors {_16} (fun (_ret: ()) -> [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'3 self.current.t_Node__left.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Node__left.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_22 <- _ret ] -{inv'3 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__left = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = as_mut {_22} (fun (_ret: t_Option'0) -> [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_21} (fun (_ret: MutBorrow.t t_Node) -> [ &_20 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'7 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = is_red {_20.current.t_Node__left} (fun (_ret: bool) -> [ &_18 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_25 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = rotate_right {_25} (fun (_ret: ()) -> [ &_24 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_Node> {self.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_27 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors {_27} (fun (_ret: ()) -> [ &_26 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'3 self.current.t_Node__right.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Node__right.t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 5) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_30 <- _ret ] -{inv'3 _ret.final}-
            [ &self <- { self with current = { self.current with t_Node__right = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = as_mut {_30} (fun (_ret: t_Option'0) -> [ &_29 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0 [ s0 = unwrap {_29} (fun (_ret: MutBorrow.t t_Node) -> [ &_28 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {inv'1 _28.current}
        MutBorrow.borrow_final <t_Node> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_0 <- _ret ] -{inv'1 _ret.final}-
            [ &_28 <- { _28 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'7 _28} s2
      | s2 = -{resolve'0 _28}- s3
      | s3 = bb13 ]
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'5 self} s1 | s1 = -{resolve'2 self}- s2 | s2 = bb11 ]
    | bb10 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: MutBorrow.t t_Node = Any.any_l ()
    | & self: MutBorrow.t t_Node = self
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Node = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _21: t_Option'0 = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Node = Any.any_l ()
    | & _28: MutBorrow.t t_Node = Any.any_l ()
    | & _29: t_Option'0 = Any.any_l ()
    | & _30: MutBorrow.t t_Option = Any.any_l () ])
    [ return (result: MutBorrow.t t_Node) -> {[@expl:move_red_right result type invariant] inv'5 result}
      {[@expl:move_red_right ensures #0] internal_invariant result.current}
      {[@expl:move_red_right ensures #1] internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {[@expl:move_red_right ensures #2] height'0 result.current = height'0 result.final
      -> height'0 self.current = height'0 self.final}
      {[@expl:move_red_right ensures #3] result.current.t_Node__key = self.current.t_Node__key}
      {[@expl:move_red_right ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
        -> has_mapping'0 self.current k v}
      {[@expl:move_red_right ensures #5] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
          /\ le_log (deep_model self.current.t_Node__key) k -> has_mapping'0 result.current k v}
      {[@expl:move_red_right ensures #6] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:move_red_right ensures #7] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[@expl:move_red_right ensures #8] color_invariant'0 result.final
        /\ (color result.current.t_Node__left = C_Black -> result.final.t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__insert_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'1 (_1: t_V)
  
  predicate resolve'2 (self: t_Node) = forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve'1 v
  
  predicate resolve'3 [@inline:trivial] (_1: t_Node) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_Node) = resolve'3 self
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: t_Node) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (self: t_Option) =
    match self with
      | C_Some x -> resolve'5 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: t_Option) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate resolve'8 [@inline:trivial] (self: MutBorrow.t t_Tree) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 [@inline:trivial] (_1: MutBorrow.t t_Tree) = resolve'8 _1
  
  meta "rewrite_def" predicate resolve'9
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_K; f1: t_K }
  
  predicate invariant''2 [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: t_K)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_K [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'7 rhs
        /\ inv'7 self_) -> precondition () args
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) = {[@expl:cmp requires] precondition () { f0 = self_;
                                                                                                         f1 = rhs }}
    any [ return' (result: t_Ordering) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  predicate resolve'10 (_1: t_K)
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'11 _1
  
  meta "rewrite_def" predicate resolve'12
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant'0 (self: t_Node) =
    color_invariant_here self /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n (self: t_CP) (node: t_Node) =
    match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  let rec balance (self: MutBorrow.t t_Node) (return (x: ())) = {[@expl:balance 'self' type invariant] inv'9 self}
    {[@expl:balance requires #0] internal_invariant self.current}
    {[@expl:balance requires #1] self.current.t_Node__color = C_Red /\ color self.current.t_Node__left = C_Red
    -> color_invariant self.current.t_Node__left}
    {[@expl:balance requires #2] self.current.t_Node__color = C_Red /\ color self.current.t_Node__right = C_Red
    -> color_invariant self.current.t_Node__right}
    {[@expl:balance requires #3] self.current.t_Node__color = C_Red
      /\ color self.current.t_Node__right = C_Red /\ color self.current.t_Node__left = C_Red -> false}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {color_invariant self.current.t_Node__left /\ color self.current.t_Node__right = C_Black
      -> self.current = self.final}
      {match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current -> match_n (C_CPL (C_Red)) self.final}
      (! return {result}) ]
  
  predicate internal_invariant'0 (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert_rec (self: MutBorrow.t t_Tree) (key: t_K) (val': t_V) (return (x: ())) =
    {[@expl:insert_rec 'self' type invariant] inv'6 self}
    {[@expl:insert_rec 'key' type invariant] inv key}
    {[@expl:insert_rec 'val' type invariant] inv'0 val'}
    {[@expl:insert_rec requires #0] internal_invariant'0 self.current}
    {[@expl:insert_rec requires #1] color_invariant self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 self.current.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_11 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = any [ br0 -> {_11.current = C_None} (! bb17) | br1 (x0: t_Node) -> {_11.current = C_Some x0} (! bb2) ] ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'5 _11} s1
      | s1 = -{resolve'0 _11}- s2
      | s2 = [ &_35 <- C_None ] s3
      | s3 = [ &_34 <- { t_Tree__node = _35 } ] s4
      | s4 = bb18 ]
    | bb18 = s0
      [ s0 = [ &_36 <- C_Red ] s1
      | s1 = [ &_40 <- C_None ] s2
      | s2 = [ &_39 <- { t_Tree__node = _40 } ] s3
      | s3 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_33 <- { t_Node__left = _34;
                         t_Node__color = _36;
                         t_Node__key = key;
                         t_Node__val = val';
                         t_Node__right = _39 } ] s1
      | s1 = bb24 ]
    | bb24 = s0 [ s0 = [ &_31 <- C_Some _33 ] s1 | s1 = bb26 ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] inv'2 self.current.t_Tree__node} s1
      | s1 = -{resolve'7 self.current.t_Tree__node}- s2
      | s2 = [ &self <- { self with current = { t_Tree__node = _31 } } ] s3
      | s3 = {[@expl:type invariant] inv'6 self} s4
      | s4 = -{resolve'9 self}- s5
      | s5 = bb32 ]
    | bb2 = s0
      [ s0 = v_Some {_11.current}
          (fun (r0: t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _11) 1}
              (fun (_ret: MutBorrow.t t_Node) ->
                [ &node <- _ret ] -{inv'4 _ret.final}-
                [ &_11 <- { _11 with current = C_Some _ret.final } ] s1))
      | s1 = [ &_18 <- node.current.t_Node__key ] s2
      | s2 = cmp {key} {_18} (fun (_ret: t_Ordering) -> [ &_15 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = any [ br0 -> {_15 = C_Less} (! bb9) | br1 -> {_15 = C_Equal} (! bb6) | br2 -> {_15 = C_Greater} (! bb7) ]
    | bb7 = s0
      [ s0 = {inv'1 node.current.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {node.current.t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_25 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = insert_rec {_25} {key} {val'} (fun (_ret: ()) -> [ &_14 <- _ret ] s2)
      | s2 = bb15 ]
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv key} s1 | s1 = -{resolve'10 key}- s2 | s2 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'0 node.current.t_Node__val} s1
      | s1 = -{resolve'1 node.current.t_Node__val}- s2
      | s2 = [ &node <- { node with current = { node.current with t_Node__val = val' } } ] s3
      | s3 = {[@expl:type invariant] inv'8 node} s4
      | s4 = -{resolve'12 node}- s5
      | s5 = {[@expl:type invariant] inv'5 _11} s6
      | s6 = -{resolve'0 _11}- s7
      | s7 = {[@expl:type invariant] inv'6 self} s8
      | s8 = -{resolve'9 self}- s9
      | s9 = bb32 ]
    | bb9 = s0
      [ s0 = {inv'1 node.current.t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {node.current.t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_20 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] s1)
      | s1 = insert_rec {_20} {key} {val'} (fun (_ret: ()) -> [ &_14 <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_29 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = balance {_29} (fun (_ret: ()) -> [ &_28 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'12 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _11} s3
      | s3 = -{resolve'0 _11}- s4
      | s4 = {[@expl:type invariant] inv'6 self} s5
      | s5 = -{resolve'9 self}- s6
      | s6 = bb32 ]
    | bb32 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Tree = self
    | & key: t_K = key
    | & val': t_V = val'
    | & _11: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _14: () = Any.any_l ()
    | & _15: t_Ordering = Any.any_l ()
    | & _18: t_K = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _25: MutBorrow.t t_Tree = Any.any_l ()
    | & _28: () = Any.any_l ()
    | & _29: MutBorrow.t t_Node = Any.any_l ()
    | & _31: t_Option = Any.any_l ()
    | & _33: t_Node = Any.any_l ()
    | & _34: t_Tree = Any.any_l ()
    | & _35: t_Option = Any.any_l ()
    | & _36: t_Color = Any.any_l ()
    | & _39: t_Tree = Any.any_l ()
    | & _40: t_Option = Any.any_l () ])
    [ return (result: ()) -> {[@expl:insert_rec ensures #0] internal_invariant'0 self.final}
      {[@expl:insert_rec ensures #1] height self.current = height self.final}
      {[@expl:insert_rec ensures #2] match_t (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final
        /\ color self.current = C_Red
      \/ color_invariant self.final}
      {[@expl:insert_rec ensures #3] has_mapping self.final (deep_model key) val'}
      {[@expl:insert_rec ensures #4] forall k: t_DeepModelTy, v: t_V. k = deep_model key
        \/ has_mapping self.current k v = has_mapping self.final k v}
      (! return {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__delete_max_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_1: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] inv'5 self_}
    any
    [ return' (result: t_Option'0) -> {inv'7 result}
      {self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'7 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'6 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'self_' type invariant] inv'6 self_}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'8 result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_1: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'9 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple = { f0: t_Tree; f1: t_Tree; f2: t_Tree }
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv'8 self}
    {[@expl:rotate_right requires #0] internal_invariant self.current}
    {[@expl:rotate_right requires #1] color self.current.t_Node__left = C_Red}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {lt_log (deep_model self.final.t_Node__key) (deep_model self.current.t_Node__key)}
      {color self.final.t_Node__right = C_Red}
      {self.final.t_Node__color = self.current.t_Node__color}
      {exists l: t_Node, r: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l
        /\ self.final.t_Node__right.t_Tree__node = C_Some r
        /\ { f0 = self.final.t_Node__left; f1 = r.t_Node__left; f2 = r.t_Node__right }
          = { f0 = l.t_Node__left; f1 = l.t_Node__right; f2 = self.current.t_Node__right }
        /\ r.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Node
  
  predicate invariant''4 [@inline:trivial] (self: t_Option) = inv'2 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_1: t_Option)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: t_Node) = inv'4 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'11 (_1: t_Node)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Node [inv'11 x]. inv'11 x = invariant''5 x
  
  predicate inv'12 (_1: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'11 a_0
        end
  
  let rec as_ref (self_: t_Option) (return (x: t_Option'1)) = {[@expl:as_ref 'self_' type invariant] inv'10 self_}
    any
    [ return' (result: t_Option'1) -> {inv'12 result}
      {self_ = C_None -> result = C_None'1}
      {self_ = C_None \/ (exists r: t_Node. result = C_Some'1 r /\ self_ = C_Some r)}
      (! return {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'12 self_}
    {[@expl:unwrap requires] self_ <> C_None'1}
    any [ return' (result: t_Node) -> {inv'11 result} {C_Some'1 result = self_} (! return {result}) ]
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 (self: t_Node) =
    color_invariant_here self /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n (self: t_CP) (node: t_Node) =
    match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  let rec move_red_right (self: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_right 'self' type invariant] inv'8 self}
    {[@expl:move_red_right requires #0] self.current.t_Node__left.t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] internal_invariant self.current}
    {[@expl:move_red_right requires #2] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'8 result}
      {internal_invariant result.current}
      {internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {height'0 result.current = height'0 result.final -> height'0 self.current = height'0 self.final}
      {result.current.t_Node__key = self.current.t_Node__key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v -> has_mapping'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v /\ le_log (deep_model self.current.t_Node__key) k
        -> has_mapping'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {color_invariant'0 result.final
        /\ (color result.current.t_Node__left = C_Black -> result.final.t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple'0 = { f0'0: t_K; f1'0: t_V }
  
  let rec balance (self: MutBorrow.t t_Node) (return (x: ())) = {[@expl:balance 'self' type invariant] inv'8 self}
    {[@expl:balance requires #0] internal_invariant self.current}
    {[@expl:balance requires #1] self.current.t_Node__color = C_Red /\ color self.current.t_Node__left = C_Red
    -> color_invariant self.current.t_Node__left}
    {[@expl:balance requires #2] self.current.t_Node__color = C_Red /\ color self.current.t_Node__right = C_Red
    -> color_invariant self.current.t_Node__right}
    {[@expl:balance requires #3] self.current.t_Node__color = C_Red
      /\ color self.current.t_Node__right = C_Red /\ color self.current.t_Node__left = C_Red -> false}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {color_invariant self.current.t_Node__left /\ color self.current.t_Node__right = C_Black
      -> self.current = self.final}
      {match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current -> match_n (C_CPL (C_Red)) self.final}
      (! return {result}) ]
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'13 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'13 x]. inv'13 x = invariant''6 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Tree) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Tree) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve'5 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'5
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'5 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. postcondition_once self args res
      = (postcondition self args res /\ resolve'5 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return (x: t_Option)) = any
    [ return' (result: t_Option) -> {inv'2 result} {result = C_None} (! return {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return (x: t_Option)) = {[@expl:take 'dest' type invariant] inv'5 dest}
    any
    [ return' (result: t_Option) -> {inv'2 result}
      {result = dest.current}
      {postcondition () () dest.final}
      (! return {result}) ]
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  let rec unwrap'1 (self_: t_Option) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'2 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return' (result: t_Node) -> {inv'4 result} {C_Some result = self_} (! return {result}) ]
  
  predicate resolve'8 (_1: t_V)
  
  predicate resolve'9 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_1: t_Tree) = resolve'9 _1
  
  meta "rewrite_def" predicate resolve'10
  
  predicate internal_invariant'0 (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  predicate inv'14 (_1: tuple'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: tuple'0 [inv'14 x]. inv'14 x
      = (let {f0'0 = x0; f1'0 = x1} = x in inv x0 /\ inv'0 x1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_max_rec (self: MutBorrow.t t_Tree) (return (x: tuple'0)) =
    {[@expl:delete_max_rec 'self' type invariant] inv'13 self}
    {[@expl:delete_max_rec requires #0] internal_invariant'0 self.current}
    {[@expl:delete_max_rec requires #1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 self.current.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = as_mut {_15} (fun (_ret: t_Option'0) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret: MutBorrow.t t_Node) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv'4 _13.current}
        MutBorrow.borrow_final <t_Node> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_12 <- _ret ] -{inv'4 _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = as_mut'0 {_12} (fun (_ret: MutBorrow.t t_Node) -> [ &node <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = is_red {node.current.t_Node__left} (fun (_ret: bool) -> [ &_17 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_17 = false} (! bb8) | br1 -> {_17} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_mut <t_Node> {node.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_19 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = rotate_right {_19} (fun (_ret: ()) -> [ &_16 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = any
      [ br0 -> {node.current.t_Node__right.t_Tree__node = C_None} (! bb9)
      | br1 (x0: t_Node) -> {node.current.t_Node__right.t_Tree__node = C_Some x0} (! bb15) ]
    | bb15 = s0 [ s0 = is_red {node.current.t_Node__right} (fun (_ret: bool) -> [ &_30 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb26) ]
    | bb18 = s0
      [ s0 = as_ref {node.current.t_Node__right.t_Tree__node} (fun (_ret: t_Option'1) -> [ &_35 <- _ret ] s1)
      | s1 = bb19 ]
    | bb19 = s0 [ s0 = unwrap'0 {_35} (fun (_ret: t_Node) -> [ &_34 <- _ret ] s1) | s1 = bb20 ]
    | bb20 = s0 [ s0 = is_red {_34.t_Node__left} (fun (_ret: bool) -> [ &_32 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = any [ br0 -> {_32 = false} (! bb23) | br1 -> {_32} (! bb26) ]
    | bb23 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_39 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = move_red_right {_39} (fun (_ret: MutBorrow.t t_Node) -> [ &_38 <- _ret ] s2)
      | s2 = bb24 ]
    | bb24 = s0
      [ s0 = {inv'3 _38.current}
        MutBorrow.borrow_final <t_Node> {_38.current} {MutBorrow.get_id _38}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_37 <- _ret ] -{inv'3 _ret.final}-
            [ &_38 <- { _38 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 = [ &node <- _37 ] s4
      | s4 = {[@expl:type invariant] inv'8 _38} s5
      | s5 = -{resolve'2 _38}- s6
      | s6 = bb26 ]
    | bb26 = s0
      [ s0 = {inv'1 node.current.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {node.current.t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_41 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = delete_max_rec {_41} (fun (_ret: tuple'0) -> [ &r <- _ret ] s2)
      | s2 = bb27 ]
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_43 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = balance {_43} (fun (_ret: ()) -> [ &_42 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'13 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb31 ]
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'8 node} s1 | s1 = -{resolve'2 node}- s2 | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'2 self.current.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Tree__node} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_26 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = {inv'2 _26.current}
        MutBorrow.borrow_final <t_Option> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_25 <- _ret ] -{inv'2 _ret.final}-
            [ &_26 <- { _26 with current = _ret.final } ] s2)
      | s2 = take {_25} (fun (_ret: t_Option) -> [ &_24 <- _ret ] s3)
      | s3 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'5 _26} s1
      | s1 = -{resolve'7 _26}- s2
      | s2 = {[@expl:type invariant] inv'13 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 = unwrap'1 {_24} (fun (_ret: t_Node) -> [ &node'0 <- _ret ] s5)
      | s5 = bb12 ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'1 node'0.t_Node__right} s1
      | s1 = -{resolve'10 node'0.t_Node__right}- s2
      | s2 = {[@expl:type invariant] inv'1 node'0.t_Node__left} s3
      | s3 = -{resolve'10 node'0.t_Node__left}- s4
      | s4 = [ &_0 <- { f0'0 = node'0.t_Node__key; f1'0 = node'0.t_Node__val } ] s5
      | s5 = bb31 ]
    | bb31 = return {_0} ]
    [ & _0: tuple'0 = Any.any_l ()
    | & self: MutBorrow.t t_Tree = self
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _12: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: MutBorrow.t t_Node = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _24: t_Option = Any.any_l ()
    | & _25: MutBorrow.t t_Option = Any.any_l ()
    | & _26: MutBorrow.t t_Option = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _34: t_Node = Any.any_l ()
    | & _35: t_Option'1 = Any.any_l ()
    | & _37: MutBorrow.t t_Node = Any.any_l ()
    | & _38: MutBorrow.t t_Node = Any.any_l ()
    | & _39: MutBorrow.t t_Node = Any.any_l ()
    | & r: tuple'0 = Any.any_l ()
    | & _41: MutBorrow.t t_Tree = Any.any_l ()
    | & _42: () = Any.any_l ()
    | & _43: MutBorrow.t t_Node = Any.any_l () ])
    [ return (result: tuple'0) -> {[@expl:delete_max_rec result type invariant] inv'14 result}
      {[@expl:delete_max_rec ensures #0] internal_invariant'0 self.final}
      {[@expl:delete_max_rec ensures #1] height self.current = height self.final}
      {[@expl:delete_max_rec ensures #2] has_mapping self.current (deep_model result.f0'0) result.f1'0}
      {[@expl:delete_max_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
        -> le_log k (deep_model result.f0'0)}
      {[@expl:delete_max_rec ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result.f0'0 <> k /\ has_mapping self.current k v)}
      {[@expl:delete_max_rec ensures #5] color_invariant self.final}
      {[@expl:delete_max_rec ensures #6] color self.current = C_Black -> color self.final = C_Black}
      (! return {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__delete_min_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_1: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] inv'5 self_}
    any
    [ return' (result: t_Option'0) -> {inv'7 result}
      {self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'7 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'6 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'self_' type invariant] inv'6 self_}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'8 result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_1: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'9 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Node
  
  predicate invariant''4 [@inline:trivial] (self: t_Option) = inv'2 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_1: t_Option)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: t_Node) = inv'4 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'11 (_1: t_Node)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Node [inv'11 x]. inv'11 x = invariant''5 x
  
  predicate inv'12 (_1: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'11 a_0
        end
  
  let rec as_ref (self_: t_Option) (return (x: t_Option'1)) = {[@expl:as_ref 'self_' type invariant] inv'10 self_}
    any
    [ return' (result: t_Option'1) -> {inv'12 result}
      {self_ = C_None -> result = C_None'1}
      {self_ = C_None \/ (exists r: t_Node. result = C_Some'1 r /\ self_ = C_Some r)}
      (! return {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'12 self_}
    {[@expl:unwrap requires] self_ <> C_None'1}
    any [ return' (result: t_Node) -> {inv'11 result} {C_Some'1 result = self_} (! return {result}) ]
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 (self: t_Node) =
    color_invariant_here self /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n (self: t_CP) (node: t_Node) =
    match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  let rec move_red_left (self: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_left 'self' type invariant] inv'8 self}
    {[@expl:move_red_left requires #0] self.current.t_Node__right.t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] internal_invariant self.current}
    {[@expl:move_red_left requires #2] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'8 result}
      {internal_invariant result.current}
      {internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {height'0 result.current = height'0 result.final -> height'0 self.current = height'0 self.final}
      {self.current.t_Node__key = result.current.t_Node__key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v -> has_mapping'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v /\ le_log k (deep_model self.current.t_Node__key)
        -> has_mapping'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {color_invariant'0 result.final
        /\ (color result.current.t_Node__right = C_Black -> result.final.t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple = { f0: t_K; f1: t_V }
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec balance (self: MutBorrow.t t_Node) (return (x: ())) = {[@expl:balance 'self' type invariant] inv'8 self}
    {[@expl:balance requires #0] internal_invariant self.current}
    {[@expl:balance requires #1] self.current.t_Node__color = C_Red /\ color self.current.t_Node__left = C_Red
    -> color_invariant self.current.t_Node__left}
    {[@expl:balance requires #2] self.current.t_Node__color = C_Red /\ color self.current.t_Node__right = C_Red
    -> color_invariant self.current.t_Node__right}
    {[@expl:balance requires #3] self.current.t_Node__color = C_Red
      /\ color self.current.t_Node__right = C_Red /\ color self.current.t_Node__left = C_Red -> false}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {color_invariant self.current.t_Node__left /\ color self.current.t_Node__right = C_Black
      -> self.current = self.final}
      {match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current -> match_n (C_CPL (C_Red)) self.final}
      (! return {result}) ]
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'13 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'13 x]. inv'13 x = invariant''6 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Tree) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Tree) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve'5 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'5
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'5 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. postcondition_once self args res
      = (postcondition self args res /\ resolve'5 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return (x: t_Option)) = any
    [ return' (result: t_Option) -> {inv'2 result} {result = C_None} (! return {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return (x: t_Option)) = {[@expl:take 'dest' type invariant] inv'5 dest}
    any
    [ return' (result: t_Option) -> {inv'2 result}
      {result = dest.current}
      {postcondition () () dest.final}
      (! return {result}) ]
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  let rec unwrap'1 (self_: t_Option) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'2 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return' (result: t_Node) -> {inv'4 result} {C_Some result = self_} (! return {result}) ]
  
  predicate resolve'8 (_1: t_V)
  
  predicate resolve'9 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_1: t_Tree) = resolve'9 _1
  
  meta "rewrite_def" predicate resolve'10
  
  predicate internal_invariant'0 (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  predicate inv'14 (_1: tuple)
  
  axiom inv_axiom'12 [@rewrite]: forall x: tuple [inv'14 x]. inv'14 x
      = (let {f0 = x0; f1 = x1} = x in inv x0 /\ inv'0 x1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_min_rec (self: MutBorrow.t t_Tree) (return (x: tuple)) =
    {[@expl:delete_min_rec 'self' type invariant] inv'13 self}
    {[@expl:delete_min_rec requires #0] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 self.current.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = as_mut {_15} (fun (_ret: t_Option'0) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret: MutBorrow.t t_Node) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv'4 _13.current}
        MutBorrow.borrow_final <t_Node> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_12 <- _ret ] -{inv'4 _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = as_mut'0 {_12} (fun (_ret: MutBorrow.t t_Node) -> [ &node <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = any
        [ br0 -> {node.current.t_Node__left.t_Tree__node = C_None} (! bb4)
        | br1 (x0: t_Node) -> {node.current.t_Node__left.t_Tree__node = C_Some x0} (! bb10) ] ]
    | bb10 = s0 [ s0 = is_red {node.current.t_Node__left} (fun (_ret: bool) -> [ &_26 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb21) ]
    | bb13 = s0
      [ s0 = as_ref {node.current.t_Node__left.t_Tree__node} (fun (_ret: t_Option'1) -> [ &_31 <- _ret ] s1)
      | s1 = bb14 ]
    | bb14 = s0 [ s0 = unwrap'0 {_31} (fun (_ret: t_Node) -> [ &_30 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = is_red {_30.t_Node__left} (fun (_ret: bool) -> [ &_28 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = any [ br0 -> {_28 = false} (! bb18) | br1 -> {_28} (! bb21) ]
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_35 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = move_red_left {_35} (fun (_ret: MutBorrow.t t_Node) -> [ &_34 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = {inv'3 _34.current}
        MutBorrow.borrow_final <t_Node> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_33 <- _ret ] -{inv'3 _ret.final}-
            [ &_34 <- { _34 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 = [ &node <- _33 ] s4
      | s4 = {[@expl:type invariant] inv'8 _34} s5
      | s5 = -{resolve'2 _34}- s6
      | s6 = bb21 ]
    | bb21 = s0
      [ s0 = {inv'1 node.current.t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {node.current.t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_37 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] s1)
      | s1 = delete_min_rec {_37} (fun (_ret: tuple) -> [ &r <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_39 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = balance {_39} (fun (_ret: ()) -> [ &_38 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'13 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb26 ]
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'8 node} s1 | s1 = -{resolve'2 node}- s2 | s2 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'2 self.current.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Tree__node} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_22 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = {inv'2 _22.current}
        MutBorrow.borrow_final <t_Option> {_22.current} {MutBorrow.get_id _22}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_21 <- _ret ] -{inv'2 _ret.final}-
            [ &_22 <- { _22 with current = _ret.final } ] s2)
      | s2 = take {_21} (fun (_ret: t_Option) -> [ &_20 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'5 _22} s1
      | s1 = -{resolve'7 _22}- s2
      | s2 = {[@expl:type invariant] inv'13 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 = unwrap'1 {_20} (fun (_ret: t_Node) -> [ &node'0 <- _ret ] s5)
      | s5 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 node'0.t_Node__right} s1
      | s1 = -{resolve'10 node'0.t_Node__right}- s2
      | s2 = {[@expl:type invariant] inv'1 node'0.t_Node__left} s3
      | s3 = -{resolve'10 node'0.t_Node__left}- s4
      | s4 = [ &_0 <- { f0 = node'0.t_Node__key; f1 = node'0.t_Node__val } ] s5
      | s5 = bb26 ]
    | bb26 = return {_0} ]
    [ & _0: tuple = Any.any_l ()
    | & self: MutBorrow.t t_Tree = self
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _12: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _20: t_Option = Any.any_l ()
    | & _21: MutBorrow.t t_Option = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: t_Node = Any.any_l ()
    | & _31: t_Option'1 = Any.any_l ()
    | & _33: MutBorrow.t t_Node = Any.any_l ()
    | & _34: MutBorrow.t t_Node = Any.any_l ()
    | & _35: MutBorrow.t t_Node = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _37: MutBorrow.t t_Tree = Any.any_l ()
    | & _38: () = Any.any_l ()
    | & _39: MutBorrow.t t_Node = Any.any_l () ])
    [ return (result: tuple) -> {[@expl:delete_min_rec result type invariant] inv'14 result}
      {[@expl:delete_min_rec ensures #0] internal_invariant'0 self.final}
      {[@expl:delete_min_rec ensures #1] height self.current = height self.final}
      {[@expl:delete_min_rec ensures #2] has_mapping self.current (deep_model result.f0) result.f1}
      {[@expl:delete_min_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
        -> le_log (deep_model result.f0) k}
      {[@expl:delete_min_rec ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result.f0 <> k /\ has_mapping self.current k v)}
      {[@expl:delete_min_rec ensures #5] color_invariant self.final}
      {[@expl:delete_min_rec ensures #6] color self.current = C_Black -> color self.final = C_Black}
      (! return {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__delete_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_1: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] inv'5 self_}
    any
    [ return' (result: t_Option'0) -> {inv'7 result}
      {self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'7 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'6 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'self_' type invariant] inv'6 self_}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'8 result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_K; f1: t_K }
  
  predicate invariant''3 [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_1: t_K)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_K [inv'9 x]. inv'9 x = invariant''3 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'9 rhs
        /\ inv'9 self_) -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) = {[@expl:cmp requires] precondition () { f0 = self_;
                                                                                                         f1 = rhs }}
    any [ return' (result: t_Ordering) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: t_Tree) = inv'1 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_1: t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Tree [inv'10 x]. inv'10 x = invariant''4 x
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'10 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 (self: t_Node) =
    bst_invariant_here self /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 (self: t_Node) =
    height_invariant_here self /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant (self: t_Node) = bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings (self: t_Node) (o: t_Node) =
    forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 (self: t_Node) : int = match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple'0 = { f0'0: t_Tree; f1'0: t_Tree; f2: t_Tree }
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv'8 self}
    {[@expl:rotate_right requires #0] internal_invariant self.current}
    {[@expl:rotate_right requires #1] color self.current.t_Node__left = C_Red}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {lt_log (deep_model self.final.t_Node__key) (deep_model self.current.t_Node__key)}
      {color self.final.t_Node__right = C_Red}
      {self.final.t_Node__color = self.current.t_Node__color}
      {exists l: t_Node, r: t_Node. self.current.t_Node__left.t_Tree__node = C_Some l
        /\ self.final.t_Node__right.t_Tree__node = C_Some r
        /\ { f0'0 = self.final.t_Node__left; f1'0 = r.t_Node__left; f2 = r.t_Node__right }
          = { f0'0 = l.t_Node__left; f1'0 = l.t_Node__right; f2 = self.current.t_Node__right }
        /\ r.t_Node__key = self.current.t_Node__key}
      (! return {result}) ]
  
  type tuple'1 = { f0'1: t_K; f1'1: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple'1
  
  predicate invariant''5 [@inline:trivial] (self: t_Option) = inv'2 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'11 (_1: t_Option)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Option [inv'11 x]. inv'11 x = invariant''5 x
  
  let rec is_none (self_: t_Option) (return (x: bool)) = {[@expl:is_none 'self_' type invariant] inv'11 self_}
    any [ return' (result: bool) -> {result = (self_ = C_None)} (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate postcondition_once'0 [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once'0
  
  predicate resolve'3 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'3
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'3 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. postcondition_once'0 self args res
      = (postcondition self args res /\ resolve'3 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return (x: t_Option)) = any
    [ return' (result: t_Option) -> {inv'2 result} {result = C_None} (! return {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return (x: t_Option)) = {[@expl:take 'dest' type invariant] inv'5 dest}
    any
    [ return' (result: t_Option) -> {inv'2 result}
      {result = dest.current}
      {postcondition () () dest.final}
      (! return {result}) ]
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'12 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'12 x]. inv'12 x = invariant''6 x
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Tree) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_1: MutBorrow.t t_Tree) = resolve'6 _1
  
  meta "rewrite_def" predicate resolve'7
  
  let rec unwrap'0 (self_: t_Option) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'2 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return' (result: t_Node) -> {inv'4 result} {C_Some result = self_} (! return {result}) ]
  
  predicate resolve'8 (_1: t_V)
  
  predicate resolve'9 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_1: t_Tree) = resolve'9 _1
  
  meta "rewrite_def" predicate resolve'10
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Node
  
  predicate invariant''7 [@inline:trivial] (self: t_Node) = inv'4 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'13 (_1: t_Node)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Node [inv'13 x]. inv'13 x = invariant''7 x
  
  predicate inv'14 (_1: t_Option'2)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'2 [inv'14 x]. inv'14 x
      = match x with
        | C_None'2 -> true
        | C_Some'2 a_0 -> inv'13 a_0
        end
  
  let rec as_ref (self_: t_Option) (return (x: t_Option'2)) = {[@expl:as_ref 'self_' type invariant] inv'11 self_}
    any
    [ return' (result: t_Option'2) -> {inv'14 result}
      {self_ = C_None -> result = C_None'2}
      {self_ = C_None \/ (exists r: t_Node. result = C_Some'2 r /\ self_ = C_Some r)}
      (! return {result}) ]
  
  let rec unwrap'1 (self_: t_Option'2) (return (x: t_Node)) = {[@expl:unwrap 'self_' type invariant] inv'14 self_}
    {[@expl:unwrap requires] self_ <> C_None'2}
    any [ return' (result: t_Node) -> {inv'13 result} {C_Some'2 result = self_} (! return {result}) ]
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 (self: t_Node) =
    color_invariant_here self /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n (self: t_CP) (node: t_Node) =
    match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  let rec move_red_right (self: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_right 'self' type invariant] inv'8 self}
    {[@expl:move_red_right requires #0] self.current.t_Node__left.t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] internal_invariant self.current}
    {[@expl:move_red_right requires #2] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'8 result}
      {internal_invariant result.current}
      {internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {height'0 result.current = height'0 result.final -> height'0 self.current = height'0 self.final}
      {result.current.t_Node__key = self.current.t_Node__key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v -> has_mapping'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v /\ le_log (deep_model self.current.t_Node__key) k
        -> has_mapping'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {color_invariant'0 result.final
        /\ (color result.current.t_Node__left = C_Black -> result.final.t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return {result}) ]
  
  predicate internal_invariant'0 (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  predicate inv'15 (_1: tuple'1)
  
  axiom inv_axiom'13 [@rewrite]: forall x: tuple'1 [inv'15 x]. inv'15 x
      = (let {f0'1 = x0; f1'1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_min_rec (self: MutBorrow.t t_Tree) (return (x: tuple'1)) =
    {[@expl:delete_min_rec 'self' type invariant] inv'12 self}
    {[@expl:delete_min_rec requires #0] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return' (result: tuple'1) -> {inv'15 result}
      {internal_invariant'0 self.final}
      {height self.current = height self.final}
      {has_mapping self.current (deep_model result.f0'1) result.f1'1}
      {forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v -> le_log (deep_model result.f0'1) k}
      {forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result.f0'1 <> k /\ has_mapping self.current k v)}
      {color_invariant self.final}
      {color self.current = C_Black -> color self.final = C_Black}
      (! return {result}) ]
  
  type t_Option'3 = C_None'3 | C_Some'3 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) : Map.map t_DeepModelTy t_Option'3 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'3 = model_acc self (Const.const (C_None'3))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'3, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'3 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'3, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'3 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'3)) k in has_mapping_model_acc self (Const.const (C_None'3)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'3 v))
  
  function has_mapping_inj (self: t_Tree) (k: t_DeepModelTy) (v1: t_V) (v2: t_V) : () =
    let _ = has_mapping_model self k in match Map.get (view self) k with
      | C_None'3 -> ()
      | C_Some'3 _v -> ()
      end
  
  axiom has_mapping_inj_spec: forall self: t_Tree, k: t_DeepModelTy, v1: t_V, v2: t_V. bst_invariant self
      -> has_mapping self k v1 -> has_mapping self k v2 -> v1 = v2
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_K) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'16 (_1: MutBorrow.t t_K)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_K [inv'16 x]. inv'16 x = invariant''8 x
  
  let rec swap (x: MutBorrow.t t_K) (y: MutBorrow.t t_K) (return (x'0: ())) = {[@expl:swap 'x' type invariant] inv'16 x}
    {[@expl:swap 'y' type invariant] inv'16 y}
    any [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_K) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_1: MutBorrow.t t_K) = resolve'11 _1
  
  meta "rewrite_def" predicate resolve'12
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t t_V) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'17 (_1: MutBorrow.t t_V)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_V [inv'17 x]. inv'17 x = invariant''9 x
  
  let rec swap'0 (x: MutBorrow.t t_V) (y: MutBorrow.t t_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv'17 x}
    {[@expl:swap 'y' type invariant] inv'17 y}
    any [ return' (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve'13 [@inline:trivial] (self: MutBorrow.t t_V) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'13
  
  predicate resolve'14 [@inline:trivial] (_1: MutBorrow.t t_V) = resolve'13 _1
  
  meta "rewrite_def" predicate resolve'14
  
  let rec move_red_left (self: MutBorrow.t t_Node) (return (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_left 'self' type invariant] inv'8 self}
    {[@expl:move_red_left requires #0] self.current.t_Node__right.t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] internal_invariant self.current}
    {[@expl:move_red_left requires #2] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    any
    [ return' (result: MutBorrow.t t_Node) -> {inv'8 result}
      {internal_invariant result.current}
      {internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {height'0 result.current = height'0 result.final -> height'0 self.current = height'0 self.final}
      {self.current.t_Node__key = result.current.t_Node__key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v -> has_mapping'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v /\ le_log k (deep_model self.current.t_Node__key)
        -> has_mapping'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {color_invariant'0 result.final
        /\ (color result.current.t_Node__right = C_Black -> result.final.t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return {result}) ]
  
  let rec balance (self: MutBorrow.t t_Node) (return (x: ())) = {[@expl:balance 'self' type invariant] inv'8 self}
    {[@expl:balance requires #0] internal_invariant self.current}
    {[@expl:balance requires #1] self.current.t_Node__color = C_Red /\ color self.current.t_Node__left = C_Red
    -> color_invariant self.current.t_Node__left}
    {[@expl:balance requires #2] self.current.t_Node__color = C_Red /\ color self.current.t_Node__right = C_Red
    -> color_invariant self.current.t_Node__right}
    {[@expl:balance requires #3] self.current.t_Node__color = C_Red
      /\ color self.current.t_Node__right = C_Red /\ color self.current.t_Node__left = C_Red -> false}
    any
    [ return' (result: ()) -> {same_mappings self.current self.final}
      {internal_invariant self.final}
      {height'0 self.current = height'0 self.final}
      {color_invariant self.current.t_Node__left /\ color self.current.t_Node__right = C_Black
      -> self.current = self.final}
      {match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current -> match_n (C_CPL (C_Red)) self.final}
      (! return {result}) ]
  
  predicate inv'18 (_1: t_Option'1)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Option'1 [inv'18 x]. inv'18 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'15 a_0
        end
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_rec (self: MutBorrow.t t_Tree) (key: t_K) (return (x: t_Option'1)) =
    {[@expl:delete_rec 'self' type invariant] inv'12 self}
    {[@expl:delete_rec 'key' type invariant] inv'9 key}
    {[@expl:delete_rec requires #0] internal_invariant'0 self.current}
    {[@expl:delete_rec requires #1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 self.current.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_16 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = as_mut {_16} (fun (_ret: t_Option'0) -> [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_15} (fun (_ret: MutBorrow.t t_Node) -> [ &_14 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv'4 _14.current}
        MutBorrow.borrow_final <t_Node> {_14.current} {MutBorrow.get_id _14}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_13 <- _ret ] -{inv'4 _ret.final}-
            [ &_14 <- { _14 with current = _ret.final } ] s1)
      | s1 = as_mut'0 {_13} (fun (_ret: MutBorrow.t t_Node) -> [ &node <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 = [ &_21 <- node.current.t_Node__key ] s3
      | s3 = cmp {key} {_21} (fun (_ret: t_Ordering) -> [ &_18 <- _ret ] s4)
      | s4 = bb4 ]
    | bb4 = any [ br0 -> {_18 = C_Less} (! bb7) | br1 -> {_18 = C_Equal} (! bb5) | br2 -> {_18 = C_Greater} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &ord <- _18 ] s1
      | s1 = is_red {node.current.t_Node__left} (fun (_ret: bool) -> [ &_42 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = any [ br0 -> {_42 = false} (! bb33) | br1 -> {_42} (! bb27) ]
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_mut <t_Node> {node.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_45 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = rotate_right {_45} (fun (_ret: ()) -> [ &_44 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0
      [ s0 = {inv'1 node.current.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {node.current.t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_47 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = delete_rec {_47} {key} (fun (_ret: t_Option'1) -> [ &_46 <- _ret ] s2)
      | s2 = bb30 ]
    | bb30 = s0 [ s0 = [ &r <- _46 ] s1 | s1 = bb69 ]
    | bb33 = s0
      [ s0 = is_none {node.current.t_Node__right.t_Tree__node} (fun (_ret: bool) -> [ &_50 <- _ret ] s1) | s1 = bb34 ]
    | bb34 = any [ br0 -> {_50 = false} (! bb44) | br1 -> {_50} (! bb35) ]
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = any
        [ br0 -> {ord = C_Less} (! bb38) | br1 -> {ord = C_Equal} (! bb38) | br2 -> {ord = C_Greater} (! bb36) ] ]
    | bb38 = s0
      [ s0 = {inv'2 self.current.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Tree__node} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_59 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = {inv'2 _59.current}
        MutBorrow.borrow_final <t_Option> {_59.current} {MutBorrow.get_id _59}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_58 <- _ret ] -{inv'2 _ret.final}-
            [ &_59 <- { _59 with current = _ret.final } ] s2)
      | s2 = take {_58} (fun (_ret: t_Option) -> [ &_57 <- _ret ] s3)
      | s3 = bb39 ]
    | bb39 = s0
      [ s0 = {[@expl:type invariant] inv'5 _59} s1
      | s1 = -{resolve'5 _59}- s2
      | s2 = {[@expl:type invariant] inv'12 self} s3
      | s3 = -{resolve'7 self}- s4
      | s4 = unwrap'0 {_57} (fun (_ret: t_Node) -> [ &node'0 <- _ret ] s5)
      | s5 = bb40 ]
    | bb40 = s0
      [ s0 = {[@expl:type invariant] inv'1 node'0.t_Node__right} s1
      | s1 = -{resolve'10 node'0.t_Node__right}- s2
      | s2 = {[@expl:type invariant] inv'1 node'0.t_Node__left} s3
      | s3 = -{resolve'10 node'0.t_Node__left}- s4
      | s4 = [ &_60 <- { f0'1 = node'0.t_Node__key; f1'1 = node'0.t_Node__val } ] s5
      | s5 = bb42 ]
    | bb42 = s0 [ s0 = [ &_0 <- C_Some'1 _60 ] s1 | s1 = bb76 ]
    | bb36 = s0 [ s0 = {[@expl:type invariant] inv'12 self} s1 | s1 = -{resolve'7 self}- s2 | s2 = bb37 ]
    | bb37 = s0 [ s0 = [ &_0 <- C_None'1 ] s1 | s1 = bb76 ]
    | bb44 = s0
      [ s0 = as_ref {node.current.t_Node__right.t_Tree__node} (fun (_ret: t_Option'2) -> [ &_67 <- _ret ] s1)
      | s1 = bb45 ]
    | bb45 = s0 [ s0 = unwrap'1 {_67} (fun (_ret: t_Node) -> [ &_66 <- _ret ] s1) | s1 = bb46 ]
    | bb46 = s0 [ s0 = is_red {_66.t_Node__left} (fun (_ret: bool) -> [ &_64 <- _ret ] s1) | s1 = bb47 ]
    | bb47 = any [ br0 -> {_64 = false} (! bb49) | br1 -> {_64} (! bb51) ]
    | bb49 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_71 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = move_red_right {_71} (fun (_ret: MutBorrow.t t_Node) -> [ &_70 <- _ret ] s2)
      | s2 = bb50 ]
    | bb50 = s0
      [ s0 = {inv'3 _70.current}
        MutBorrow.borrow_final <t_Node> {_70.current} {MutBorrow.get_id _70}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_69 <- _ret ] -{inv'3 _ret.final}-
            [ &_70 <- { _70 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 = [ &node <- _69 ] s4
      | s4 = {[@expl:type invariant] inv'8 _70} s5
      | s5 = -{resolve'2 _70}- s6
      | s6 = bb51 ]
    | bb51 = any
      [ br0 -> {ord = C_Less} (! bb63) | br1 -> {ord = C_Equal} (! bb53) | br2 -> {ord = C_Greater} (! bb63) ]
    | bb63 = s0
      [ s0 = {inv'1 node.current.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {node.current.t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_90 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = delete_rec {_90} {key} (fun (_ret: t_Option'1) -> [ &_89 <- _ret ] s2)
      | s2 = bb65 ]
    | bb65 = s0 [ s0 = [ &r <- _89 ] s1 | s1 = bb69 ]
    | bb53 = s0
      [ s0 = {inv'1 node.current.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {node.current.t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_74 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = delete_min_rec {_74} (fun (_ret: tuple'1) -> [ &kv <- _ret ] s2)
      | s2 = bb54 ]
    | bb54 = s0 [ s0 = [ &_75 <- () ] s1 | s1 = bb55 ]
    | bb55 = s0
      [ s0 = {inv node.current.t_Node__key}
        MutBorrow.borrow_mut <t_K> {node.current.t_Node__key}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_79 <- _ret ] -{inv _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__key = _ret.final } } ] s1)
      | s1 = {inv kv.f0'1}
        MutBorrow.borrow_mut <t_K> {kv.f0'1}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_81 <- _ret ] -{inv _ret.final}-
            [ &kv <- { kv with f0'1 = _ret.final } ] s2)
      | s2 = {inv _79.current}
        MutBorrow.borrow_final <t_K> {_79.current} {MutBorrow.get_id _79}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_78 <- _ret ] -{inv _ret.final}-
            [ &_79 <- { _79 with current = _ret.final } ] s3)
      | s3 = {inv _81.current}
        MutBorrow.borrow_final <t_K> {_81.current} {MutBorrow.get_id _81}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_80 <- _ret ] -{inv _ret.final}-
            [ &_81 <- { _81 with current = _ret.final } ] s4)
      | s4 = swap {_78} {_80} (fun (_ret: ()) -> [ &_77 <- _ret ] s5)
      | s5 = bb56 ]
    | bb56 = s0
      [ s0 = {[@expl:type invariant] inv'16 _81} s1
      | s1 = -{resolve'12 _81}- s2
      | s2 = {[@expl:type invariant] inv'16 _79} s3
      | s3 = -{resolve'12 _79}- s4
      | s4 = {inv'0 node.current.t_Node__val}
        MutBorrow.borrow_mut <t_V> {node.current.t_Node__val}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_84 <- _ret ] -{inv'0 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__val = _ret.final } } ] s5)
      | s5 = {inv'0 kv.f1'1}
        MutBorrow.borrow_mut <t_V> {kv.f1'1}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_86 <- _ret ] -{inv'0 _ret.final}-
            [ &kv <- { kv with f1'1 = _ret.final } ] s6)
      | s6 = {inv'0 _84.current}
        MutBorrow.borrow_final <t_V> {_84.current} {MutBorrow.get_id _84}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_83 <- _ret ] -{inv'0 _ret.final}-
            [ &_84 <- { _84 with current = _ret.final } ] s7)
      | s7 = {inv'0 _86.current}
        MutBorrow.borrow_final <t_V> {_86.current} {MutBorrow.get_id _86}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_85 <- _ret ] -{inv'0 _ret.final}-
            [ &_86 <- { _86 with current = _ret.final } ] s8)
      | s8 = swap'0 {_83} {_85} (fun (_ret: ()) -> [ &_82 <- _ret ] s9)
      | s9 = bb57 ]
    | bb57 = s0
      [ s0 = {[@expl:type invariant] inv'17 _86} s1
      | s1 = -{resolve'14 _86}- s2
      | s2 = {[@expl:type invariant] inv'17 _84} s3
      | s3 = -{resolve'14 _84}- s4
      | s4 = [ &_87 <- C_Some'1 kv ] s5
      | s5 = bb59 ]
    | bb59 = s0 [ s0 = [ &r <- _87 ] s1 | s1 = bb69 ]
    | bb7 = s0
      [ s0 = is_none {node.current.t_Node__left.t_Tree__node} (fun (_ret: bool) -> [ &_24 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = any [ br0 -> {_24 = false} (! bb10) | br1 -> {_24} (! bb9) ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'12 self} s3
      | s3 = -{resolve'7 self}- s4
      | s4 = [ &_0 <- C_None'1 ] s5
      | s5 = bb76 ]
    | bb10 = s0 [ s0 = is_red {node.current.t_Node__left} (fun (_ret: bool) -> [ &_28 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = any [ br0 -> {_28 = false} (! bb13) | br1 -> {_28} (! bb21) ]
    | bb13 = s0
      [ s0 = as_ref {node.current.t_Node__left.t_Tree__node} (fun (_ret: t_Option'2) -> [ &_33 <- _ret ] s1)
      | s1 = bb14 ]
    | bb14 = s0 [ s0 = unwrap'1 {_33} (fun (_ret: t_Node) -> [ &_32 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = is_red {_32.t_Node__left} (fun (_ret: bool) -> [ &_30 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb21) ]
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_37 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = move_red_left {_37} (fun (_ret: MutBorrow.t t_Node) -> [ &_36 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = {inv'3 _36.current}
        MutBorrow.borrow_final <t_Node> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_35 <- _ret ] -{inv'3 _ret.final}-
            [ &_36 <- { _36 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 = [ &node <- _35 ] s4
      | s4 = {[@expl:type invariant] inv'8 _36} s5
      | s5 = -{resolve'2 _36}- s6
      | s6 = bb21 ]
    | bb21 = s0
      [ s0 = {inv'1 node.current.t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {node.current.t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_39 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] s1)
      | s1 = delete_rec {_39} {key} (fun (_ret: t_Option'1) -> [ &_38 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0 [ s0 = [ &r <- _38 ] s1 | s1 = bb69 ]
    | bb69 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_93 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = balance {_93} (fun (_ret: ()) -> [ &_92 <- _ret ] s2)
      | s2 = bb70 ]
    | bb70 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'12 self} s3
      | s3 = -{resolve'7 self}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb76 ]
    | bb76 = return {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self: MutBorrow.t t_Tree = self
    | & key: t_K = key
    | & r: t_Option'1 = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: MutBorrow.t t_Node = Any.any_l ()
    | & _15: t_Option'0 = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _18: t_Ordering = Any.any_l ()
    | & _21: t_K = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _32: t_Node = Any.any_l ()
    | & _33: t_Option'2 = Any.any_l ()
    | & _35: MutBorrow.t t_Node = Any.any_l ()
    | & _36: MutBorrow.t t_Node = Any.any_l ()
    | & _37: MutBorrow.t t_Node = Any.any_l ()
    | & _38: t_Option'1 = Any.any_l ()
    | & _39: MutBorrow.t t_Tree = Any.any_l ()
    | & ord: t_Ordering = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: () = Any.any_l ()
    | & _45: MutBorrow.t t_Node = Any.any_l ()
    | & _46: t_Option'1 = Any.any_l ()
    | & _47: MutBorrow.t t_Tree = Any.any_l ()
    | & _50: bool = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _57: t_Option = Any.any_l ()
    | & _58: MutBorrow.t t_Option = Any.any_l ()
    | & _59: MutBorrow.t t_Option = Any.any_l ()
    | & _60: tuple'1 = Any.any_l ()
    | & _64: bool = Any.any_l ()
    | & _66: t_Node = Any.any_l ()
    | & _67: t_Option'2 = Any.any_l ()
    | & _69: MutBorrow.t t_Node = Any.any_l ()
    | & _70: MutBorrow.t t_Node = Any.any_l ()
    | & _71: MutBorrow.t t_Node = Any.any_l ()
    | & kv: tuple'1 = Any.any_l ()
    | & _74: MutBorrow.t t_Tree = Any.any_l ()
    | & _75: () = Any.any_l ()
    | & _77: () = Any.any_l ()
    | & _78: MutBorrow.t t_K = Any.any_l ()
    | & _79: MutBorrow.t t_K = Any.any_l ()
    | & _80: MutBorrow.t t_K = Any.any_l ()
    | & _81: MutBorrow.t t_K = Any.any_l ()
    | & _82: () = Any.any_l ()
    | & _83: MutBorrow.t t_V = Any.any_l ()
    | & _84: MutBorrow.t t_V = Any.any_l ()
    | & _85: MutBorrow.t t_V = Any.any_l ()
    | & _86: MutBorrow.t t_V = Any.any_l ()
    | & _87: t_Option'1 = Any.any_l ()
    | & _89: t_Option'1 = Any.any_l ()
    | & _90: MutBorrow.t t_Tree = Any.any_l ()
    | & _92: () = Any.any_l ()
    | & _93: MutBorrow.t t_Node = Any.any_l () ])
    [ return (result: t_Option'1) -> {[@expl:delete_rec result type invariant] inv'18 result}
      {[@expl:delete_rec ensures #0] internal_invariant'0 self.final}
      {[@expl:delete_rec ensures #1] height self.current = height self.final}
      {[@expl:delete_rec ensures #2] match result with
        | C_None'1 -> forall v: t_V. not has_mapping self.current (deep_model'0 key) v
        | C_Some'1 {f0'1 = k; f1'1 = v} -> deep_model'0 key = deep_model k /\ has_mapping self.current (deep_model k) v
        end}
      {[@expl:delete_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model'0 key <> k /\ has_mapping self.current k v)}
      {[@expl:delete_rec ensures #4] color_invariant self.final}
      {[@expl:delete_rec ensures #5] color self.current = C_Black -> color self.final = C_Black}
      (! return {result}) ]
end
module M_red_black_tree__qyi7670249875066633436__resolve_coherence (* <Map<K, V> as creusot_contracts::Resolve> *)
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_Map = { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_1: t_V)
  
  predicate resolve'0 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_1: t_Tree) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate structural_resolve (_1: t_Map) =
    match _1 with
      | {t_Map__0 = x0} -> resolve'1 x0
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  predicate resolve'2 [@inline:trivial] (self: t_Option'0) =
    match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_Option'0) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'0 = view self.t_Map__0
  
  predicate resolve'4 (self: t_Map) = forall k: t_DeepModelTy. resolve'3 (Map.get (view'0 self) k)
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map
  
  function resolve_coherence (self: t_Map) : ()
  
  goal vc_resolve_coherence: structural_resolve self -> ([@expl:resolve_coherence ensures] resolve'4 self)
end
module M_red_black_tree__qyi1722927563742988856__new (* Map<K, V> *)
  use creusot.prelude.Any
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  type t_Map = { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant' (self: t_Map) =
    internal_invariant self.t_Map__0 /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate inv'2 (_1: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color'0; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant''0 (self: t_Node) = inv'1 self
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate inv'5 (_1: t_Map)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Map [inv'5 x]. inv'5 x
      = (invariant' x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'0 = view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new (return (x: t_Map)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- C_None ] s1 | s1 = [ &_2 <- { t_Tree__node = _3 } ] s2 | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { t_Map__0 = _2 } ] s1 | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_Map = Any.any_l () | & _2: t_Tree = Any.any_l () | & _3: t_Option = Any.any_l () ])
    [ return (result: t_Map) -> {[@expl:new result type invariant] inv'5 result}
      {[@expl:new ensures] view'0 result = Const.const (C_None'0)}
      (! return {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__insert (* Map<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate inv'2 (_1: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  let rec insert_rec (self: MutBorrow.t t_Tree) (key: t_K) (val': t_V) (return (x: ())) =
    {[@expl:insert_rec 'self' type invariant] inv'5 self}
    {[@expl:insert_rec 'key' type invariant] inv key}
    {[@expl:insert_rec 'val' type invariant] inv'0 val'}
    {[@expl:insert_rec requires #0] internal_invariant self.current}
    {[@expl:insert_rec requires #1] color_invariant self.current}
    any
    [ return' (result: ()) -> {internal_invariant self.final}
      {height self.current = height self.final}
      {match_t (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final /\ color self.current = C_Red
      \/ color_invariant self.final}
      {has_mapping self.final (deep_model key) val'}
      {forall k: t_DeepModelTy, v: t_V. k = deep_model key \/ has_mapping self.current k v = has_mapping self.final k v}
      (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_1: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'7 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] inv'6 self_}
    any
    [ return' (result: t_Option'0) -> {inv'8 result}
      {self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'8 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'7 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''3 (self: t_Map) =
    internal_invariant self.t_Map__0 /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'9 (_1: t_Map)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Map [inv'9 x]. inv'9 x
      = (invariant''3 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Map) = inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_1: MutBorrow.t t_Map)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Map [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Map) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Map) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) : Map.map t_DeepModelTy t_Option'1 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'1 = model_acc self (Const.const (C_None'1))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'1, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'1 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'1, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'1 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'1)) k in has_mapping_model_acc self (Const.const (C_None'1)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'1 v))
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'1 = view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert (self: MutBorrow.t t_Map) (key: t_K) (val': t_V) (return (x: ())) =
    {[@expl:insert 'self' type invariant] inv'10 self}
    {[@expl:insert 'key' type invariant] inv key}
    {[@expl:insert 'val' type invariant] inv'0 val'}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 self.current.t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {self.current.t_Map__0}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_6 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = _ret.final } } ] s1)
      | s1 = insert_rec {_6} {key} {val'} (fun (_ret: ()) -> [ &_5 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- C_Black ] s1
      | s1 = {inv'4 self.current.t_Map__0.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Map__0.t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_12 <- _ret ] -{inv'4 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s2)
      | s2 = as_mut {_12} (fun (_ret: t_Option'0) -> [ &_11 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_11} (fun (_ret: MutBorrow.t t_Node) -> [ &_10 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_10 <- { _10 with current = { _10.current with t_Node__color = _9 } } ] s1
      | s1 = {[@expl:type invariant] inv'7 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'10 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = [ &_13 <- () ] s6
      | s6 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Map = self
    | & key: t_K = key
    | & val': t_V = val'
    | & _5: () = Any.any_l ()
    | & _6: MutBorrow.t t_Tree = Any.any_l ()
    | & _9: t_Color = Any.any_l ()
    | & _10: MutBorrow.t t_Node = Any.any_l ()
    | & _11: t_Option'0 = Any.any_l ()
    | & _12: MutBorrow.t t_Option = Any.any_l ()
    | & _13: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:insert ensures] view'0 self.final
      = Map.set (view'0 self.current) (deep_model key) (C_Some'1 val')}
      (! return {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__delete_max (* Map<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 (self: t_Map) =
    internal_invariant self.t_Map__0 /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_1: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
      = (invariant''1 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'1 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Map) = inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Map) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Map) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'8 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate same_mappings (self: t_Tree) (o: t_Tree) =
    forall k: t_DeepModelTy, v: t_V. has_mapping self k v = has_mapping o k v
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'10 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  predicate inv'11 (_1: tuple)
  
  axiom inv_axiom'9 [@rewrite]: forall x: tuple [inv'11 x]. inv'11 x
      = (let {f0 = x0; f1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_max_rec (self: MutBorrow.t t_Tree) (return (x: tuple)) =
    {[@expl:delete_max_rec 'self' type invariant] inv'10 self}
    {[@expl:delete_max_rec requires #0] internal_invariant self.current}
    {[@expl:delete_max_rec requires #1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return' (result: tuple) -> {inv'11 result}
      {internal_invariant self.final}
      {height self.current = height self.final}
      {has_mapping self.current (deep_model result.f0) result.f1}
      {forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v -> le_log k (deep_model result.f0)}
      {forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result.f0 <> k /\ has_mapping self.current k v)}
      {color_invariant self.final}
      {color self.current = C_Black -> color self.final = C_Black}
      (! return {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_Node)
  
  predicate inv'12 (_1: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'9 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'1)) =
    {[@expl:as_mut 'self_' type invariant] inv'5 self_}
    any
    [ return' (result: t_Option'1) -> {inv'12 result}
      {self_.current = C_None -> result = C_None'1 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'1 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'1) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'12 self_}
    {[@expl:unwrap requires] self_ <> C_None'1}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'9 result} {C_Some'1 result = self_} (! return {result}) ]
  
  type t_Option'2 = C_None'2 | C_Some'2 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) : Map.map t_DeepModelTy t_Option'2 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'2 = model_acc self (Const.const (C_None'2))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'2, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'2 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'2, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'2 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'2)) k in has_mapping_model_acc self (Const.const (C_None'2)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'2 v))
  
  predicate inv'13 (_1: t_Option'0)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'11 a_0
        end
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'2 = view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_max (self: MutBorrow.t t_Map) (return (x: t_Option'0)) =
    {[@expl:delete_max 'self' type invariant] inv'7 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 self.current.t_Map__0.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Map__0.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_6 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = any [ br0 -> {_6.current = C_None} (! bb8) | br1 (x0: t_Node) -> {_6.current = C_Some x0} (! bb3) ] ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = [ &_0 <- C_None'0 ] s5
      | s5 = bb19 ]
    | bb3 = s0
      [ s0 = v_Some {_6.current}
          (fun (r0: t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _6) 1}
              (fun (_ret: MutBorrow.t t_Node) ->
                [ &node <- _ret ] -{inv'4 _ret.final}-
                [ &_6 <- { _6 with current = C_Some _ret.final } ] s1))
      | s1 = is_red {node.current.t_Node__left} (fun (_ret: bool) -> [ &_9 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
    | bb6 = s0
      [ s0 = [ &_11 <- C_Red ] s1
      | s1 = [ &node <- { node with current = { node.current with t_Node__color = _11 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:assertion] same_mappings old_self.current.t_Map__0 self.current.t_Map__0} s1
      | s1 = {inv'1 self.current.t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {self.current.t_Map__0}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_16 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = _ret.final } } ] s2)
      | s2 = delete_max_rec {_16} (fun (_ret: tuple) -> [ &r <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0 [ s0 = is_red {self.current.t_Map__0} (fun (_ret: bool) -> [ &_18 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_18 = false} (! bb14) | br1 -> {_18} (! bb11) ]
    | bb11 = s0
      [ s0 = [ &_20 <- C_Black ] s1
      | s1 = {inv'2 self.current.t_Map__0.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Map__0.t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_23 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s2)
      | s2 = as_mut {_23} (fun (_ret: t_Option'1) -> [ &_22 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_22} (fun (_ret: MutBorrow.t t_Node) -> [ &_21 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_21 <- { _21 with current = { _21.current with t_Node__color = _20 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _21} s2
      | s2 = -{resolve'4 _21}- s3
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb15 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self} s1 | s1 = -{resolve'2 self}- s2 | s2 = bb15 ]
    | bb15 = s0 [ s0 = [ &_24 <- () ] s1 | s1 = bb16 ]
    | bb16 = s0 [ s0 = [ &_0 <- C_Some'0 r ] s1 | s1 = bb19 ]
    | bb19 = return {_0} ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self: MutBorrow.t t_Map = self
    | & old_self: MutBorrow.t t_Map = Any.any_l ()
    | & _6: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _11: t_Color = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _16: MutBorrow.t t_Tree = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: t_Color = Any.any_l ()
    | & _21: MutBorrow.t t_Node = Any.any_l ()
    | & _22: t_Option'1 = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l () ])
    [ return (result: t_Option'0) -> {[@expl:delete_max result type invariant] inv'13 result}
      {[@expl:delete_max ensures] match result with
        | C_Some'0 {f0 = k; f1 = v} -> Map.get (view'0 self.current) (deep_model k) = C_Some'2 v
        /\ (forall k2: t_DeepModelTy. Map.get (view'0 self.current) k2 = C_None'2 \/ le_log k2 (deep_model k))
        /\ view'0 self.final = Map.set (view'0 self.current) (deep_model k) (C_None'2)
        | C_None'0 -> view'0 self.final = view'0 self.current /\ view'0 self.current = Const.const (C_None'2)
        end}
      (! return {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__delete_min (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 (self: t_Map) =
    internal_invariant self.t_Map__0 /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_1: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
      = (invariant''1 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'1 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Map) = inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Map) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Map) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'8 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'10 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  predicate inv'11 (_1: tuple)
  
  axiom inv_axiom'9 [@rewrite]: forall x: tuple [inv'11 x]. inv'11 x
      = (let {f0 = x0; f1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_min_rec (self: MutBorrow.t t_Tree) (return (x: tuple)) =
    {[@expl:delete_min_rec 'self' type invariant] inv'10 self}
    {[@expl:delete_min_rec requires #0] internal_invariant self.current}
    {[@expl:delete_min_rec requires #1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return' (result: tuple) -> {inv'11 result}
      {internal_invariant self.final}
      {height self.current = height self.final}
      {has_mapping self.current (deep_model result.f0) result.f1}
      {forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v -> le_log (deep_model result.f0) k}
      {forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result.f0 <> k /\ has_mapping self.current k v)}
      {color_invariant self.final}
      {color self.current = C_Black -> color self.final = C_Black}
      (! return {result}) ]
  
  type t_Option'2 = C_None'2 | C_Some'2 (MutBorrow.t t_Node)
  
  predicate inv'12 (_1: t_Option'2)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'2 [inv'12 x]. inv'12 x
      = match x with
        | C_None'2 -> true
        | C_Some'2 a_0 -> inv'9 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'2)) =
    {[@expl:as_mut 'self_' type invariant] inv'5 self_}
    any
    [ return' (result: t_Option'2) -> {inv'12 result}
      {self_.current = C_None -> result = C_None'2 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'2 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'2) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'12 self_}
    {[@expl:unwrap requires] self_ <> C_None'2}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'9 result} {C_Some'2 result = self_} (! return {result}) ]
  
  predicate inv'13 (_1: t_Option'1)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'1 [inv'13 x]. inv'13 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'11 a_0
        end
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'0 = view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_min (self: MutBorrow.t t_Map) (return (x: t_Option'1)) =
    {[@expl:delete_min 'self' type invariant] inv'7 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 self.current.t_Map__0.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Map__0.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_6 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = any [ br0 -> {_6.current = C_None} (! bb8) | br1 (x0: t_Node) -> {_6.current = C_Some x0} (! bb3) ] ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = [ &_0 <- C_None'1 ] s5
      | s5 = bb18 ]
    | bb3 = s0
      [ s0 = v_Some {_6.current}
          (fun (r0: t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _6) 1}
              (fun (_ret: MutBorrow.t t_Node) ->
                [ &node <- _ret ] -{inv'4 _ret.final}-
                [ &_6 <- { _6 with current = C_Some _ret.final } ] s1))
      | s1 = is_red {node.current.t_Node__left} (fun (_ret: bool) -> [ &_9 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
    | bb6 = s0
      [ s0 = [ &_11 <- C_Red ] s1
      | s1 = [ &node <- { node with current = { node.current with t_Node__color = _11 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'1 self.current.t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {self.current.t_Map__0}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_14 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = _ret.final } } ] s1)
      | s1 = delete_min_rec {_14} (fun (_ret: tuple) -> [ &r <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = is_red {self.current.t_Map__0} (fun (_ret: bool) -> [ &_16 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb11) ]
    | bb11 = s0
      [ s0 = [ &_18 <- C_Black ] s1
      | s1 = {inv'2 self.current.t_Map__0.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Map__0.t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_21 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s2)
      | s2 = as_mut {_21} (fun (_ret: t_Option'2) -> [ &_20 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_20} (fun (_ret: MutBorrow.t t_Node) -> [ &_19 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_19 <- { _19 with current = { _19.current with t_Node__color = _18 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _19} s2
      | s2 = -{resolve'4 _19}- s3
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb15 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self} s1 | s1 = -{resolve'2 self}- s2 | s2 = bb15 ]
    | bb15 = s0 [ s0 = [ &_0 <- C_Some'1 r ] s1 | s1 = bb18 ]
    | bb18 = return {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self: MutBorrow.t t_Map = self
    | & _3: () = Any.any_l ()
    | & _6: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _11: t_Color = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _14: MutBorrow.t t_Tree = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: t_Color = Any.any_l ()
    | & _19: MutBorrow.t t_Node = Any.any_l ()
    | & _20: t_Option'2 = Any.any_l ()
    | & _21: MutBorrow.t t_Option = Any.any_l () ])
    [ return (result: t_Option'1) -> {[@expl:delete_min result type invariant] inv'13 result}
      {[@expl:delete_min ensures] match result with
        | C_Some'1 {f0 = k; f1 = v} -> Map.get (view'0 self.current) (deep_model k) = C_Some'0 v
        /\ (forall k2: t_DeepModelTy. Map.get (view'0 self.current) k2 = C_None'0 \/ le_log (deep_model k) k2)
        /\ view'0 self.final = Map.set (view'0 self.current) (deep_model k) (C_None'0)
        | C_None'1 -> view'0 self.final = view'0 self.current /\ view'0 self.current = Const.const (C_None'0)
        end}
      (! return {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__delete (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Tree)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = inv'3 self
  
  predicate inv'4 (_1: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 (self: t_Map) =
    internal_invariant self.t_Map__0 /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_1: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
      = (invariant''1 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'1 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Map) = inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Map) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Map) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv'8 self}
    any [ return' (result: bool) -> {result = (color self = C_Red)} (! return {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'10 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'11 (_1: t_K)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_K [inv'11 x]. inv'11 x = invariant''6 x
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = C_CPN c l r
  
  predicate inv'12 (_1: tuple)
  
  axiom inv_axiom'10 [@rewrite]: forall x: tuple [inv'12 x]. inv'12 x
      = (let {f0 = x0; f1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate inv'13 (_1: t_Option'1)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'1 [inv'13 x]. inv'13 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'12 a_0
        end
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  let rec delete_rec (self: MutBorrow.t t_Tree) (key: t_K) (return (x: t_Option'1)) =
    {[@expl:delete_rec 'self' type invariant] inv'10 self}
    {[@expl:delete_rec 'key' type invariant] inv'11 key}
    {[@expl:delete_rec requires #0] internal_invariant self.current}
    {[@expl:delete_rec requires #1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return' (result: t_Option'1) -> {inv'13 result}
      {internal_invariant self.final}
      {height self.current = height self.final}
      {match result with
        | C_None'1 -> forall v: t_V. not has_mapping self.current (deep_model'0 key) v
        | C_Some'1 {f0 = k; f1 = v} -> deep_model'0 key = deep_model k /\ has_mapping self.current (deep_model k) v
        end}
      {forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model'0 key <> k /\ has_mapping self.current k v)}
      {color_invariant self.final}
      {color self.current = C_Black -> color self.final = C_Black}
      (! return {result}) ]
  
  type t_Option'2 = C_None'2 | C_Some'2 (MutBorrow.t t_Node)
  
  predicate inv'14 (_1: t_Option'2)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'2 [inv'14 x]. inv'14 x
      = match x with
        | C_None'2 -> true
        | C_Some'2 a_0 -> inv'9 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'2)) =
    {[@expl:as_mut 'self_' type invariant] inv'5 self_}
    any
    [ return' (result: t_Option'2) -> {inv'14 result}
      {self_.current = C_None -> result = C_None'2 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'2 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'2) (return (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] inv'14 self_}
    {[@expl:unwrap requires] self_ <> C_None'2}
    any [ return' (result: MutBorrow.t t_Node) -> {inv'9 result} {C_Some'2 result = self_} (! return {result}) ]
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'0 = view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete (self: MutBorrow.t t_Map) (key: t_K) (return (x: t_Option'1)) =
    {[@expl:delete 'self' type invariant] inv'7 self}
    {[@expl:delete 'key' type invariant] inv'11 key}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 self.current.t_Map__0.t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {self.current.t_Map__0.t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_8 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = any [ br0 -> {_8.current = C_None} (! bb8) | br1 (x0: t_Node) -> {_8.current = C_Some x0} (! bb3) ] ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _8} s1
      | s1 = -{resolve'0 _8}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = [ &_0 <- C_None'1 ] s5
      | s5 = bb17 ]
    | bb3 = s0
      [ s0 = v_Some {_8.current}
          (fun (r0: t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _8) 1}
              (fun (_ret: MutBorrow.t t_Node) ->
                [ &node <- _ret ] -{inv'4 _ret.final}-
                [ &_8 <- { _8 with current = C_Some _ret.final } ] s1))
      | s1 = is_red {node.current.t_Node__left} (fun (_ret: bool) -> [ &_11 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = any [ br0 -> {_11 = false} (! bb6) | br1 -> {_11} (! bb5) ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _8} s3
      | s3 = -{resolve'0 _8}- s4
      | s4 = bb7 ]
    | bb6 = s0
      [ s0 = [ &_13 <- C_Red ] s1
      | s1 = [ &node <- { node with current = { node.current with t_Node__color = _13 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _8} s5
      | s5 = -{resolve'0 _8}- s6
      | s6 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'1 self.current.t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {self.current.t_Map__0}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_16 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = _ret.final } } ] s1)
      | s1 = delete_rec {_16} {key} (fun (_ret: t_Option'1) -> [ &r <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = is_red {self.current.t_Map__0} (fun (_ret: bool) -> [ &_19 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_19 = false} (! bb14) | br1 -> {_19} (! bb11) ]
    | bb11 = s0
      [ s0 = [ &_21 <- C_Black ] s1
      | s1 = {inv'2 self.current.t_Map__0.t_Tree__node}
        MutBorrow.borrow_final <t_Option> {self.current.t_Map__0.t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_24 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s2)
      | s2 = as_mut {_24} (fun (_ret: t_Option'2) -> [ &_23 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_23} (fun (_ret: MutBorrow.t t_Node) -> [ &_22 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_22 <- { _22 with current = { _22.current with t_Node__color = _21 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _22} s2
      | s2 = -{resolve'4 _22}- s3
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb15 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self} s1 | s1 = -{resolve'2 self}- s2 | s2 = bb15 ]
    | bb15 = s0 [ s0 = [ &_0 <- r ] s1 | s1 = bb17 ]
    | bb17 = return {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self: MutBorrow.t t_Map = self
    | & key: t_K = key
    | & _5: () = Any.any_l ()
    | & _8: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: t_Color = Any.any_l ()
    | & r: t_Option'1 = Any.any_l ()
    | & _16: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Color = Any.any_l ()
    | & _22: MutBorrow.t t_Node = Any.any_l ()
    | & _23: t_Option'2 = Any.any_l ()
    | & _24: MutBorrow.t t_Option = Any.any_l () ])
    [ return (result: t_Option'1) -> {[@expl:delete result type invariant] inv'13 result}
      {[@expl:delete ensures #0] match result with
        | C_Some'1 {f0 = k; f1 = v} -> deep_model k = deep_model'0 key
        /\ Map.get (view'0 self.current) (deep_model'0 key) = C_Some'0 v
        | C_None'1 -> Map.get (view'0 self.current) (deep_model'0 key) = C_None'0
        end}
      {[@expl:delete ensures #1] view'0 self.final = Map.set (view'0 self.current) (deep_model'0 key) (C_None'0)}
      (! return {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__get (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map = { t_Map__0: t_Tree }
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate inv'2 (_1: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate invariant''0 [@inline:trivial] (self: t_Tree) = inv'2 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type tuple = { f0: t_K; f1: t_K }
  
  predicate invariant''1 [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: t_K)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_K [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'6 rhs
        /\ inv'6 self_) -> precondition () args
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) = {[@expl:cmp requires] precondition () { f0 = self_;
                                                                                                         f1 = rhs }}
    any [ return' (result: t_Ordering) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''2 (self: t_Map) =
    internal_invariant self.t_Map__0 /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'7 (_1: t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map [inv'7 x]. inv'7 x
      = (invariant''2 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  predicate invariant''3 [@inline:trivial] (self: t_Map) = inv'7 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: t_Map)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Map [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_V) = inv'0 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_1: t_V)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_V [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate inv'10 (_1: t_Option'1)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option'1 [inv'10 x]. inv'10 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'9 a_0
        end
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'0 = view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get (self: t_Map) (key: t_K) (return (x: t_Option'1)) = {[@expl:get 'self' type invariant] inv'8 self}
    {[@expl:get 'key' type invariant] inv'6 key}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &tree <- self.t_Map__0 ] s1 | s1 = bb2 ]
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant #0] inv'5 tree}
        {[@expl:loop invariant #1] bst_invariant tree}
        {[@expl:loop invariant #2] forall v: t_V. has_mapping self.t_Map__0 (deep_model'0 key) v
          = has_mapping tree (deep_model'0 key) v}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_14 <- tree.t_Tree__node ] s1
          | s1 = any [ br0 -> {_14 = C_None} (! bb14) | br1 (x0: t_Node) -> {_14 = C_Some x0} (! bb5) ] ]
        | bb5 = s0
          [ s0 = v_Some {_14} (fun (r0: t_Node) -> [ &node <- r0 ] s1)
          | s1 = [ &_20 <- node.t_Node__key ] s2
          | s2 = cmp {key} {_20} (fun (_ret: t_Ordering) -> [ &_17 <- _ret ] s3)
          | s3 = bb6 ]
        | bb6 = any
          [ br0 -> {_17 = C_Less} (! bb12) | br1 -> {_17 = C_Equal} (! bb11) | br2 -> {_17 = C_Greater} (! bb10) ]
        | bb10 = s0 [ s0 = [ &_28 <- node.t_Node__right ] s1 | s1 = [ &tree <- _28 ] s2 | s2 = bb2 ]
        | bb12 = s0 [ s0 = [ &_23 <- node.t_Node__left ] s1 | s1 = [ &tree <- _23 ] s2 | s2 = bb2 ] ] ]
    | bb14 = s0 [ s0 = [ &_0 <- C_None'1 ] s1 | s1 = bb15 ]
    | bb11 = s0 [ s0 = [ &_26 <- node.t_Node__val ] s1 | s1 = [ &_0 <- C_Some'1 _26 ] s2 | s2 = bb15 ]
    | bb15 = return {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self: t_Map = self
    | & key: t_K = key
    | & _5: () = Any.any_l ()
    | & tree: t_Tree = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & node: t_Node = Any.any_l ()
    | & _17: t_Ordering = Any.any_l ()
    | & _20: t_K = Any.any_l ()
    | & _23: t_Tree = Any.any_l ()
    | & _26: t_V = Any.any_l ()
    | & _28: t_Tree = Any.any_l () ])
    [ return (result: t_Option'1) -> {[@expl:get result type invariant] inv'10 result}
      {[@expl:get ensures] match result with
        | C_Some'1 v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'0 v
        | C_None'1 -> Map.get (view'0 self) (deep_model'0 key) = C_None'0
        end}
      (! return {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__get_mut (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : () =
    match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model (self: t_Tree) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. bst_invariant self
      -> (forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate inv'2 (_1: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate match_t (self: t_CP) (tree: t_Tree) =
    match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Tree) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_1: MutBorrow.t t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type tuple = { f0: t_K; f1: t_K }
  
  predicate invariant''1 [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_1: t_K)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_K [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'6 rhs
        /\ inv'6 self_) -> precondition () args
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) = {[@expl:cmp requires] precondition () { f0 = self_;
                                                                                                         f1 = rhs }}
    any [ return' (result: t_Ordering) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Tree) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Tree) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_1: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Node) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_1: MutBorrow.t t_Option)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Option [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Option) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Option) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_V)
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_V) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_1: MutBorrow.t t_V)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_V [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_V) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_1: MutBorrow.t t_V) = resolve'5 _1
  
  meta "rewrite_def" predicate resolve'6
  
  predicate internal_invariant (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  predicate invariant''5 (self: t_Map) =
    internal_invariant self.t_Map__0 /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'10 (_1: t_Map)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Map [inv'10 x]. inv'10 x
      = (invariant''5 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_Map) = inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'11 (_1: MutBorrow.t t_Map)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_Map [inv'11 x]. inv'11 x = invariant''6 x
  
  predicate resolve'7 [@inline:trivial] (self: MutBorrow.t t_Map) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_1: MutBorrow.t t_Map) = resolve'7 _1
  
  meta "rewrite_def" predicate resolve'8
  
  predicate inv'12 (_1: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'9 a_0
        end
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'0 = view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_mut (self: MutBorrow.t t_Map) (key: t_K) (return (x: t_Option'1)) =
    {[@expl:get_mut 'self' type invariant] inv'11 self}
    {[@expl:get_mut 'key' type invariant] inv'6 key}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 self.current.t_Map__0}
        MutBorrow.borrow_final <t_Tree> {self.current.t_Map__0} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &tree <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = { t_Map__0 = _ret.final } } ] s1)
      | s1 = [ &old_tree <- tree ] s2
      | s2 = bb3 ]
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant #0] inv'5 tree}
        {[@expl:loop invariant #1] bst_invariant tree.current}
        {[@expl:loop invariant #2] height_invariant tree.current}
        {[@expl:loop invariant #3] color_invariant tree.current}
        {[@expl:loop invariant #4] forall v: t_V. has_mapping tree.final (deep_model'0 key) v
          = has_mapping old_tree.final (deep_model'0 key) v}
        {[@expl:loop invariant #5] forall v: t_V. has_mapping tree.current (deep_model'0 key) v
          = has_mapping old_tree.current (deep_model'0 key) v}
        {[@expl:loop invariant #6] (forall k: t_DeepModelTy, v: t_V. k = deep_model'0 key
            \/ has_mapping tree.current k v = has_mapping tree.final k v)
        -> bst_invariant tree.final -> bst_invariant old_tree.final}
        {[@expl:loop invariant #7] height tree.current = height tree.final /\ height_invariant tree.final
        -> height_invariant old_tree.final}
        {[@expl:loop invariant #8] match_t (C_CPL (color tree.current)) tree.final
        -> match_t (C_CPL (C_Black)) old_tree.final}
        {[@expl:loop invariant #9] forall k: t_DeepModelTy, v: t_V. has_mapping tree.current k v
            = has_mapping tree.final k v -> has_mapping old_tree.current k v = has_mapping old_tree.final k v}
        (! s0)
        [ s0 = bb4 ]
        [ bb4 = s0
          [ s0 = {inv'4 tree.current.t_Tree__node}
            MutBorrow.borrow_final <t_Option> {tree.current.t_Tree__node}
              {MutBorrow.inherit_id (MutBorrow.get_id tree) 1}
              (fun (_ret: MutBorrow.t t_Option) ->
                [ &_23 <- _ret ] -{inv'4 _ret.final}-
                [ &tree <- { tree with current = { t_Tree__node = _ret.final } } ] s1)
          | s1 = any
            [ br0 -> {_23.current = C_None} (! bb15) | br1 (x0: t_Node) -> {_23.current = C_Some x0} (! bb6) ] ]
        | bb6 = s0
          [ s0 = v_Some {_23.current}
              (fun (r0: t_Node) ->
                {inv'3 r0}
                MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _23) 1}
                  (fun (_ret: MutBorrow.t t_Node) ->
                    [ &node <- _ret ] -{inv'3 _ret.final}-
                    [ &_23 <- { _23 with current = C_Some _ret.final } ] s1))
          | s1 = [ &_29 <- node.current.t_Node__key ] s2
          | s2 = cmp {key} {_29} (fun (_ret: t_Ordering) -> [ &_26 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = any
          [ br0 -> {_26 = C_Less} (! bb13) | br1 -> {_26 = C_Equal} (! bb12) | br2 -> {_26 = C_Greater} (! bb11) ]
        | bb11 = s0
          [ s0 = {inv'2 node.current.t_Node__right}
            MutBorrow.borrow_final <t_Tree> {node.current.t_Node__right}
              {MutBorrow.inherit_id (MutBorrow.get_id node) 5}
              (fun (_ret: MutBorrow.t t_Tree) ->
                [ &_37 <- _ret ] -{inv'2 _ret.final}-
                [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
          | s1 = {inv'2 _37.current}
            MutBorrow.borrow_final <t_Tree> {_37.current} {MutBorrow.get_id _37}
              (fun (_ret: MutBorrow.t t_Tree) ->
                [ &_36 <- _ret ] -{inv'2 _ret.final}-
                [ &_37 <- { _37 with current = _ret.final } ] s2)
          | s2 = {[@expl:type invariant] inv'5 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 = [ &tree <- _36 ] s5
          | s5 = {[@expl:type invariant] inv'5 _37} s6
          | s6 = -{resolve'0 _37}- s7
          | s7 = bb14 ]
        | bb13 = s0
          [ s0 = {inv'2 node.current.t_Node__left}
            MutBorrow.borrow_final <t_Tree> {node.current.t_Node__left} {MutBorrow.inherit_id (MutBorrow.get_id node) 1}
              (fun (_ret: MutBorrow.t t_Tree) ->
                [ &_32 <- _ret ] -{inv'2 _ret.final}-
                [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] s1)
          | s1 = {inv'2 _32.current}
            MutBorrow.borrow_final <t_Tree> {_32.current} {MutBorrow.get_id _32}
              (fun (_ret: MutBorrow.t t_Tree) ->
                [ &_31 <- _ret ] -{inv'2 _ret.final}-
                [ &_32 <- { _32 with current = _ret.final } ] s2)
          | s2 = {[@expl:type invariant] inv'5 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 = [ &tree <- _31 ] s5
          | s5 = {[@expl:type invariant] inv'5 _32} s6
          | s6 = -{resolve'0 _32}- s7
          | s7 = bb14 ]
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv'7 node} s1
          | s1 = -{resolve'2 node}- s2
          | s2 = {[@expl:type invariant] inv'8 _23} s3
          | s3 = -{resolve'4 _23}- s4
          | s4 = bb3 ] ] ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'8 _23} s1
      | s1 = -{resolve'4 _23}- s2
      | s2 = [ &_0 <- C_None'1 ] s3
      | s3 = bb16 ]
    | bb12 = s0
      [ s0 = {inv'0 node.current.t_Node__val}
        MutBorrow.borrow_final <t_V> {node.current.t_Node__val} {MutBorrow.inherit_id (MutBorrow.get_id node) 4}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_35 <- _ret ] -{inv'0 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__val = _ret.final } } ] s1)
      | s1 = {inv'0 _35.current}
        MutBorrow.borrow_final <t_V> {_35.current} {MutBorrow.get_id _35}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_34 <- _ret ] -{inv'0 _ret.final}-
            [ &_35 <- { _35 with current = _ret.final } ] s2)
      | s2 = [ &_0 <- C_Some'1 _34 ] s3
      | s3 = {[@expl:type invariant] inv'9 _35} s4
      | s4 = -{resolve'6 _35}- s5
      | s5 = {[@expl:type invariant] inv'7 node} s6
      | s6 = -{resolve'2 node}- s7
      | s7 = {[@expl:type invariant] inv'8 _23} s8
      | s8 = -{resolve'4 _23}- s9
      | s9 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'5 tree} s1
      | s1 = -{resolve'0 tree}- s2
      | s2 = {[@expl:type invariant] inv'11 self} s3
      | s3 = -{resolve'8 self}- s4
      | s4 = return {_0} ] ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self: MutBorrow.t t_Map = self
    | & key: t_K = key
    | & _5: () = Any.any_l ()
    | & tree: MutBorrow.t t_Tree = Any.any_l ()
    | & old_tree: MutBorrow.t t_Tree = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _26: t_Ordering = Any.any_l ()
    | & _29: t_K = Any.any_l ()
    | & _31: MutBorrow.t t_Tree = Any.any_l ()
    | & _32: MutBorrow.t t_Tree = Any.any_l ()
    | & _34: MutBorrow.t t_V = Any.any_l ()
    | & _35: MutBorrow.t t_V = Any.any_l ()
    | & _36: MutBorrow.t t_Tree = Any.any_l ()
    | & _37: MutBorrow.t t_Tree = Any.any_l () ])
    [ return (result: t_Option'1) -> {[@expl:get_mut result type invariant] inv'12 result}
      {[@expl:get_mut ensures] match result with
        | C_Some'1 v -> Map.get (view'0 self.current) (deep_model'0 key) = C_Some'0 (v.current)
        /\ view'0 self.final = Map.set (view'0 self.current) (deep_model'0 key) (C_Some'0 (v.final))
        | C_None'1 -> Map.get (view'0 self.current) (deep_model'0 key) = C_None'0
        /\ view'0 self.final = view'0 self.current
        end}
      (! return {result}) ]
end
module M_red_black_tree__qyi8412372133095258695__resolve_coherence__refines (* <Tree<K, V> as creusot_contracts::Resolve> *)
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve (_1: t_V)
  
  predicate resolve'0 (self: t_Node) = forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_1: t_Node) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (self: t_Node) = resolve'1 self
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_Node) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_Option) =
    match self with
      | C_Some x -> resolve'3 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: t_Option) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  predicate structural_resolve (_1: t_Tree) =
    match _1 with
      | {t_Tree__node = x0} -> resolve'5 x0
      end
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate inv'2 (_1: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate resolve'6 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Tree. structural_resolve self /\ inv'2 self
      -> structural_resolve self /\ (forall result: (). resolve'6 self -> resolve'6 self)
end
module M_red_black_tree__qyi17767811206440054577__resolve_coherence__refines (* <Node<K, V> as creusot_contracts::Resolve> *)
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_1: t_V)
  
  predicate resolve'0 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_1: t_Tree) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (_1: t_K)
  
  predicate structural_resolve (_1: t_Node) =
    match _1 with
      | {t_Node__left = x0; t_Node__color = x1; t_Node__key = x2; t_Node__val = x3; t_Node__right = x4} -> resolve'1 x4
      /\ resolve x3 /\ resolve'2 x2 /\ resolve'1 x0
      end
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate invariant' (self: t_Node) = inv'1 self
  
  predicate inv'2 (_1: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  predicate inv'4 (_1: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
      = match x with
        | {t_Tree__node = node} -> inv'3 node
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'4 left
        /\ inv key /\ inv'0 val' /\ inv'4 right
        end
  
  predicate has_mapping'0 (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'3 (self: t_Node) = forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Node. structural_resolve self /\ inv'1 self
      -> structural_resolve self /\ (forall result: (). resolve'3 self -> resolve'3 self)
end
module M_red_black_tree__qyi7670249875066633436__resolve_coherence__refines (* <Map<K, V> as creusot_contracts::Resolve> *)
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_Map = { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_1: t_V)
  
  predicate resolve'0 (self: t_Tree) = forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_1: t_Tree) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  predicate structural_resolve (_1: t_Map) =
    match _1 with
      | {t_Map__0 = x0} -> resolve'1 x0
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here (self: t_Node) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height (self: t_Tree) : int = match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. height self >= 0
  
  predicate height_invariant_here (self: t_Node) = height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant (self: t_Tree) = bst_invariant self /\ height_invariant self
  
  function color (self: t_Tree) : t_Color = match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here (self: t_Node) =
    color self.t_Node__right = C_Black /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant (self: t_Tree) =
    match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant' (self: t_Map) =
    internal_invariant self.t_Map__0 /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate inv'1 (_1: t_Node)
  
  predicate inv'2 (_1: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color'0; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant''0 (self: t_Node) = inv'1 self
  
  predicate inv'3 (_1: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate inv'5 (_1: t_Map)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Map [inv'5 x]. inv'5 x
      = (invariant' x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  predicate resolve'2 [@inline:trivial] (self: t_Option'0) =
    match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_Option'0) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  function model_acc (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0 =
    match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 = model_acc self (Const.const (C_None'0))
  
  function view'0 (self: t_Map) : Map.map t_DeepModelTy t_Option'0 = view self.t_Map__0
  
  predicate resolve'4 (self: t_Map) = forall k: t_DeepModelTy. resolve'3 (Map.get (view'0 self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map. structural_resolve self /\ inv'5 self
      -> structural_resolve self /\ (forall result: (). resolve'4 self -> resolve'4 self)
end
