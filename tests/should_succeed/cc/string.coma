module M_string__test_string_len
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use creusot.prelude.Char
  use creusot.int.UInt8
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_String = { t_String__vec: t_Vec }
  
  function tail (self: Seq.seq Char.t) : Seq.seq Char.t = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map (self: Seq.seq Char.t) (other: Map.map Char.t (Seq.seq UInt8.t)) : Seq.seq UInt8.t
  
  axiom flat_map_def: forall self: Seq.seq Char.t, other: Map.map Char.t (Seq.seq UInt8.t). flat_map self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq UInt8.t
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
      )
  
  function to_utf8 (self: Char.t) : Seq.seq UInt8.t
  
  axiom to_utf8_spec: forall self: Char.t. 1 <= Seq.length (to_utf8 self) /\ Seq.length (to_utf8 self) <= 4
  
  function to_bytes (self: Seq.seq Char.t) : Seq.seq UInt8.t = flat_map self (fun (c: Char.t) -> to_utf8 c)
  
  function view (self: t_String) : Seq.seq Char.t
  
  function view'0 [@inline:trivial] (self: t_String) : Seq.seq Char.t = view self
  
  meta "rewrite_def" function view'0
  
  let rec len (self_: t_String) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {UInt64.t'int result = Seq.length (to_bytes (view'0 self_))}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_string_len (s: t_String) (return' (x: UInt64.t)) = {[@expl:test_string_len requires #0] view s
    = Seq.create 1 [|Char.of_int 195|]}
    {[@expl:test_string_len requires #1] to_utf8 (Char.of_int 195) = Seq.create 2 [|(195: UInt8.t);(131: UInt8.t)|]}
    (! bb0
    [ bb0 = s0 [ s0 = len {s'0} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = bb2 ] | bb2 = return''0 {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & s'0: t_String = s ])
    [ return''0 (result: UInt64.t) -> {[@expl:test_string_len ensures] UInt64.t'int result = 2} (! return' {result}) ]
end
module M_string__test_str_len
  use creusot.int.UInt64
  use seq.Seq
  use creusot.prelude.Char
  use creusot.int.UInt8
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  function tail (self: Seq.seq Char.t) : Seq.seq Char.t = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map (self: Seq.seq Char.t) (other: Map.map Char.t (Seq.seq UInt8.t)) : Seq.seq UInt8.t
  
  axiom flat_map_def: forall self: Seq.seq Char.t, other: Map.map Char.t (Seq.seq UInt8.t). flat_map self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq UInt8.t
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
      )
  
  function to_utf8 (self: Char.t) : Seq.seq UInt8.t
  
  axiom to_utf8_spec: forall self: Char.t. 1 <= Seq.length (to_utf8 self) /\ Seq.length (to_utf8 self) <= 4
  
  function to_bytes (self: Seq.seq Char.t) : Seq.seq UInt8.t = flat_map self (fun (c: Char.t) -> to_utf8 c)
  
  function view (self: string) : Seq.seq Char.t
  
  function view'0 [@inline:trivial] (self: string) : Seq.seq Char.t = view self
  
  meta "rewrite_def" function view'0
  
  let rec len (self_: string) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {UInt64.t'int result = Seq.length (to_bytes (view'0 self_))}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_str_len (s: string) (return' (x: UInt64.t)) = {[@expl:test_str_len requires #0] view'0 s
    = Seq.create 1 [|Char.of_int 195|]}
    {[@expl:test_str_len requires #1] to_utf8 (Char.of_int 195) = Seq.create 2 [|(195: UInt8.t);(131: UInt8.t)|]}
    (! bb0
    [ bb0 = s0 [ s0 = len {s'0} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return''0 {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & s'0: string = s ])
    [ return''0 (result: UInt64.t) -> {[@expl:test_str_len ensures] UInt64.t'int result = 2} (! return' {result}) ]
end
module M_string__test_split_at
  use creusot.prelude.Char
  use seq.Seq
  use creusot.int.UInt8
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  function tail (self: Seq.seq Char.t) : Seq.seq Char.t = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map (self: Seq.seq Char.t) (other: Map.map Char.t (Seq.seq UInt8.t)) : Seq.seq UInt8.t
  
  axiom flat_map_def: forall self: Seq.seq Char.t, other: Map.map Char.t (Seq.seq UInt8.t). flat_map self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq UInt8.t
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
      )
  
  constant flat_map_singleton: () = ()
  
  axiom flat_map_singleton_spec: forall x: Char.t, f: Map.map Char.t (Seq.seq UInt8.t). flat_map (Seq.singleton x) f
      = Map.get f x
  
  function view (self: string) : Seq.seq Char.t
  
  function view'0 [@inline:trivial] (self: string) : Seq.seq Char.t = view self
  
  meta "rewrite_def" function view'0
  
  type tuple = { _p0: string; _p1: string }
  
  function to_utf8 (self: Char.t) : Seq.seq UInt8.t
  
  axiom to_utf8_spec: forall self: Char.t. 1 <= Seq.length (to_utf8 self) /\ Seq.length (to_utf8 self) <= 4
  
  function to_bytes (self: Seq.seq Char.t) : Seq.seq UInt8.t = flat_map self (fun (c: Char.t) -> to_utf8 c)
  
  let rec split_at (self_: string) (ix: UInt64.t) (return' (x: tuple)) = {[@expl:split_at requires] exists i0: int. 0
        <= i0
      /\ i0 <= Seq.length (view'0 self_) /\ Seq.length (to_bytes (Seq.([..]) (view'0 self_) 0 i0)) = UInt64.t'int ix}
    any
    [ return''0 (result: tuple) -> {Seq.(++) (view'0 result._p0) (view'0 result._p1) = view'0 self_}
      {Seq.length (to_bytes (view'0 result._p0)) = UInt64.t'int ix}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_split_at (s: string) (return' (x: tuple)) = {[@expl:test_split_at requires #0] view'0 s
    = Seq.create 1 [|Char.of_int 195|]}
    {[@expl:test_split_at requires #1] to_utf8 (Char.of_int 195) = Seq.create 2 [|(195: UInt8.t);(131: UInt8.t)|]}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- flat_map_singleton ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] Seq.([..]) (view'0 s'0) 0 1 = view'0 s'0} s1
      | s1 = split_at {s'0} {(2: UInt64.t)} (fun (_ret: tuple) -> [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = return''0 {_0} ] [ & _0: tuple = Any.any_l () | & s'0: string = s | & _5: () = Any.any_l () ])
    [ return''0 (result: tuple) -> {[@expl:test_split_at ensures] view'0 result._p0 = view'0 s
      /\ view'0 result._p1 = (Seq.empty: Seq.seq Char.t)}
      (! return' {result}) ]
end
