module M_collections__roundtrip_hashmap_into_iter
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0 = { t_HashMap__base: t_HashMap }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_AlignmentEnum =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment = { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout = { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple = { f0: t_NonNull; f1: t_Layout; f2: () }
  
  type t_Option = C_None | C_Some tuple
  
  type t_RawIntoIter = {
    t_RawIntoIter__iter: t_RawIter;
    t_RawIntoIter__allocation: t_Option;
    t_RawIntoIter__marker: () }
  
  type t_IntoIter = { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0 = { t_IntoIter__base: t_IntoIter }
  
  type t_FMap
  
  function view (self: t_HashMap'0) : t_FMap
  
  function view'0 (self: t_IntoIter'0) : t_FMap
  
  let rec into_iter (self_: t_HashMap'0) (return (x: t_IntoIter'0)) = any
    [ return (result: t_IntoIter'0) -> {view self_ = view'0 result} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: t_IntoIter'0) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_K
  
  type t_V
  
  type tuple'0 = { f0'0: t_K; f1'0: t_V }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate contains (self: Seq.seq tuple'0) (x: tuple'0) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view'1 (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0 = Map.get (view'1 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate produces (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0) =
    len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K, v: t_V. contains visited { f0'0 = k; f1'0 = v }
        -> get (view'0 self) (deep_model k) = C_Some'0 v /\ get (view'0 o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 o) k = C_Some'0 v
        -> get (view'0 self) k = C_Some'0 v
        /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { f0'0 = k2; f1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 self) k = C_Some'0 v
        -> (exists k1: t_K. deep_model k1 = k /\ contains visited { f0'0 = k1; f1'0 = v })
        \/ get (view'0 o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1).f0'0 = deep_model (Seq.get visited i2).f0'0
      -> i1 = i2)
  
  function produces_trans (a: t_IntoIter'0) (ab: Seq.seq tuple'0) (b: t_IntoIter'0) (bc: Seq.seq tuple'0) (c: t_IntoIter'0) : ()
   = ()
  
  axiom produces_trans_spec:
    forall a: t_IntoIter'0, ab: Seq.seq tuple'0, b: t_IntoIter'0, bc: Seq.seq tuple'0, c: t_IntoIter'0. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IntoIter'0) : () = ()
  
  axiom produces_refl_spec: forall self: t_IntoIter'0. produces self (Seq.empty: Seq.seq tuple'0) self
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_IntoIter'0) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_DeepModelTy. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view'1 empty = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap) = ext_eq self empty
  
  predicate completed (self: MutBorrow.t t_IntoIter'0) = resolve'0 self /\ is_empty (view'0 self.current)
  
  predicate from_iter_post (prod: Seq.seq tuple'0) (res: t_HashMap'0) =
    forall k: t_DeepModelTy, v: t_V. (get (view res) k = C_Some'0 v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model k1 = k
        /\ Seq.get prod i = { f0'0 = k1; f1'0 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model (Seq.get prod j).f0'0 <> k))
  
  let rec collect (self_: t_IntoIter'0) (return (x: t_HashMap'0)) = any
    [ return (result: t_HashMap'0) ->
    {exists done': MutBorrow.t t_IntoIter'0, prod: Seq.seq tuple'0. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) = get self k <> C_None'0
  
  meta "rewrite_def" predicate contains'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option'0) : t_V = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_DeepModelTy) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_into_iter (xs: t_HashMap'0) (return (x: t_HashMap'0)) = (! bb0
    [ bb0 = s0 [ s0 = [ &xs_snap <- xs ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_iter {xs} (fun (_ret: t_IntoIter'0) -> [ &it <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &it0 <- it ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap'0) -> [ &r <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:assertion] exists prod: Seq.seq tuple'0, it1: MutBorrow.t t_IntoIter'0. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: t_V. (get (view r) k = C_Some'0 v)
            = (exists k1: t_K. deep_model k1 = k /\ contains prod { f0'0 = k1; f1'0 = v }))}
        s1
      | s1 = {[@expl:assertion] forall k: t_DeepModelTy. contains'0 (view r) k = contains'0 (view xs_snap) k} s2
      | s2 = {[@expl:assertion] forall k: t_DeepModelTy. index_logic'0 (view r) k = index_logic'0 (view xs_snap) k} s3
      | s3 = {[@expl:assertion] ext_eq (view r) (view xs_snap)} s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_HashMap'0 = Any.any_l ()
    | & xs: t_HashMap'0 = xs
    | & xs_snap: t_HashMap'0 = Any.any_l ()
    | & it: t_IntoIter'0 = Any.any_l ()
    | & it0: t_IntoIter'0 = Any.any_l ()
    | & r: t_HashMap'0 = Any.any_l () ])
    [ return (result: t_HashMap'0) -> {[@expl:roundtrip_hashmap_into_iter ensures] view result = view xs}
      (! return {result}) ]
end
module M_collections__roundtrip_hashmap_iter
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0 = { t_HashMap__base: t_HashMap }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter = { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0 = { t_Iter__base: t_Iter }
  
  type t_FMap
  
  function view (self: t_HashMap'0) : t_FMap
  
  function view'0 (self: t_Iter'0) : t_FMap
  
  let rec iter (self_: t_HashMap'0) (return (x: t_Iter'0)) = any
    [ return (result: t_Iter'0) -> {view self_ = view'0 result} (! return {result}) ]
  
  type t_RawTable'0 = { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1 = { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'2 = { t_HashMap__base'0: t_HashMap'1 }
  
  predicate resolve [@inline:trivial] (_1: t_Iter'0) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'1 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'1 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0) =
    len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view'0 self) (deep_model'0 k) = C_Some v /\ get (view'0 o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 o) k = C_Some v
        -> get (view'0 self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 self) k = C_Some v
        -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v }) \/ get (view'0 o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  function produces_trans (a: t_Iter'0) (ab: Seq.seq tuple) (b: t_Iter'0) (bc: Seq.seq tuple) (c: t_Iter'0) : () = ()
  
  axiom produces_trans_spec:
    forall a: t_Iter'0, ab: Seq.seq tuple, b: t_Iter'0, bc: Seq.seq tuple, c: t_Iter'0. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Iter'0) : () = ()
  
  axiom produces_refl_spec: forall self: t_Iter'0. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Iter'0) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_DeepModelTy. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view'1 empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = ext_eq self empty
  
  predicate completed (self: MutBorrow.t t_Iter'0) = resolve'0 self /\ is_empty (view'0 self.current)
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view'2 (self: t_FMap'0) : Map.map t_DeepModelTy t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'0 = Map.get (view'2 self) k
  
  meta "rewrite_def" function get'0
  
  function view'3 (self: t_HashMap'2) : t_FMap'0
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap'2) =
    forall k: t_DeepModelTy, v: t_V. (get'0 (view'3 res) k = C_Some'0 v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model'0 k1 = k
        /\ Seq.get prod i = { f0 = k1; f1 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model'0 (Seq.get prod j).f0 <> k))
  
  let rec collect (self_: t_Iter'0) (return (x: t_HashMap'2)) = any
    [ return (result: t_HashMap'2) -> {exists done': MutBorrow.t t_Iter'0, prod: Seq.seq tuple. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_iter (xs: t_HashMap'0) (return (x: t_HashMap'2)) = (! bb0
    [ bb0 = s0 [ s0 = iter {xs} (fun (_ret: t_Iter'0) -> [ &it <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &it0 <- it ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap'2) -> [ &r <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] exists prod: Seq.seq tuple, it1: MutBorrow.t t_Iter'0. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: t_V. (get'0 (view'3 r) k = C_Some'0 v)
            = (exists k1: t_K. deep_model'0 k1 = k /\ contains prod { f0 = k1; f1 = v }))}
        s1
      | s1 = [ &_0 <- r ] s2
      | s2 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_HashMap'2 = Any.any_l ()
    | & xs: t_HashMap'0 = xs
    | & it: t_Iter'0 = Any.any_l ()
    | & it0: t_Iter'0 = Any.any_l ()
    | & r: t_HashMap'2 = Any.any_l () ])
    [ return (result: t_HashMap'2) ->
    {[@expl:roundtrip_hashmap_iter ensures] forall k: t_DeepModelTy, v: t_V. (get'0 (view'3 result) k = C_Some'0 v)
        = (get (view xs) k = C_Some v)}
      (! return {result}) ]
end
module M_collections__roundtrip_hashmap_iter_mut
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use map.Map
  use seq.Seq
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0 = { t_HashMap__base: t_HashMap }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut = { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0 = { t_IterMut__base: t_IterMut }
  
  type t_FMap
  
  type t_DeepModelTy
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  function view'0 (self: t_HashMap'0) : t_FMap
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_V)
  
  function view'1 (self: t_FMap'0) : Map.map t_DeepModelTy t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'0 = Map.get (view'1 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains'0
  
  function view'2 (self: t_IterMut'0) : t_FMap'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_DeepModelTy) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (MutBorrow.t t_V) bool) (a: MutBorrow.t t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (MutBorrow.t t_V) bool) : MutBorrow.t t_V
  
  axiom such_that_spec'0: forall p: Map.map (MutBorrow.t t_V) bool. (exists x: MutBorrow.t t_V. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'0) : MutBorrow.t t_V = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: MutBorrow.t t_V) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : MutBorrow.t t_V =
    unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_DeepModelTy) : MutBorrow.t t_V = lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  let rec iter_mut (self_: MutBorrow.t t_HashMap'0) (return (x: t_IterMut'0)) = any
    [ return (result: t_IterMut'0) -> {forall k: t_DeepModelTy. contains (view'0 self_.current) k
        = contains (view'0 self_.final) k}
      {forall k: t_DeepModelTy. contains (view'0 self_.current) k = contains'0 (view'2 result) k}
      {forall k: t_DeepModelTy. contains (view'0 self_.current) k
        -> index_logic'0 (view'0 self_.current) k = (index_logic'2 (view'2 result) k).current
        /\ index_logic'0 (view'0 self_.final) k = (index_logic'2 (view'2 result) k).final}
      (! return {result}) ]
  
  type t_RawTable'0 = { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1 = { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'2 = { t_HashMap__base'0: t_HashMap'1 }
  
  predicate resolve [@inline:trivial] (_1: t_IterMut'0) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_K
  
  type tuple = { f0: t_K; f1: MutBorrow.t t_V }
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. len self >= 0
  
  predicate contains'1 (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0) =
    len (view'2 self) = Seq.length visited + len (view'2 o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains'1 visited { f0 = k; f1 = v }
        -> get'0 (view'2 self) (deep_model k) = C_Some'0 v /\ get'0 (view'2 o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'2 o) k = C_Some'0 v
        -> get'0 (view'2 self) k = C_Some'0 v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains'1 visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'2 self) k = C_Some'0 v
        -> (exists k1: t_K. deep_model'0 k1 = k /\ contains'1 visited { f0 = k1; f1 = v })
        \/ get'0 (view'2 o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  function produces_trans (a: t_IterMut'0) (ab: Seq.seq tuple) (b: t_IterMut'0) (bc: Seq.seq tuple) (c: t_IterMut'0) : ()
   = ()
  
  axiom produces_trans_spec:
    forall a: t_IterMut'0, ab: Seq.seq tuple, b: t_IterMut'0, bc: Seq.seq tuple, c: t_IterMut'0. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IterMut'0) : () = ()
  
  axiom produces_refl_spec: forall self: t_IterMut'0. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_IterMut'0) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) = forall k: t_DeepModelTy. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. ext_eq self other = (self = other)
  
  constant empty : t_FMap'0
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view'1 empty = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap'0) = ext_eq self empty
  
  predicate completed (self: MutBorrow.t t_IterMut'0) = resolve'0 self /\ is_empty (view'2 self.current)
  
  function view'3 (self: t_HashMap'2) : t_FMap'0
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap'2) =
    forall k: t_DeepModelTy, v: MutBorrow.t t_V. (get'0 (view'3 res) k = C_Some'0 v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model'0 k1 = k
        /\ Seq.get prod i = { f0 = k1; f1 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model'0 (Seq.get prod j).f0 <> k))
  
  let rec collect (self_: t_IterMut'0) (return (x: t_HashMap'2)) = any
    [ return (result: t_HashMap'2) -> {exists done': MutBorrow.t t_IterMut'0, prod: Seq.seq tuple. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_HashMap'0) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_HashMap'0) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_iter_mut (xs: MutBorrow.t t_HashMap'0) (return (x: t_HashMap'2)) = (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_HashMap'0> {xs.current} {MutBorrow.get_id xs}
          (fun (_ret: MutBorrow.t t_HashMap'0) -> [ &_6 <- _ret ] [ &xs <- { xs with current = _ret.final } ] s1)
      | s1 = iter_mut {_6} (fun (_ret: t_IterMut'0) -> [ &it <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &it0 <- it ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap'2) -> [ &r <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] exists prod: Seq.seq tuple, it1: MutBorrow.t t_IterMut'0. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. (get'0 (view'3 r) k = C_Some'0 v)
            = (exists k1: t_K. deep_model'0 k1 = k /\ contains'1 prod { f0 = k1; f1 = v }))}
        s1
      | s1 = [ &_0 <- r ] s2
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = -{resolve'2 xs}- s1 | s1 = return {_0} ] ]
    [ & _0: t_HashMap'2 = Any.any_l ()
    | & xs: MutBorrow.t t_HashMap'0 = xs
    | & it: t_IterMut'0 = Any.any_l ()
    | & _6: MutBorrow.t t_HashMap'0 = Any.any_l ()
    | & it0: t_IterMut'0 = Any.any_l ()
    | & r: t_HashMap'2 = Any.any_l () ])
    [ return (result: t_HashMap'2) ->
    {[@expl:roundtrip_hashmap_iter_mut ensures #0] forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'3 result) k
          = C_Some'0 v -> get (view'0 xs.current) k = C_Some (v.current) /\ get (view'0 xs.final) k = C_Some (v.final)}
      {[@expl:roundtrip_hashmap_iter_mut ensures #1] forall k: t_DeepModelTy, v: t_V. get (view'0 xs.current) k
          = C_Some v -> contains'0 (view'3 result) k /\ (index_logic'2 (view'3 result) k).current = v}
      {[@expl:roundtrip_hashmap_iter_mut ensures #2] forall k: t_DeepModelTy, v: t_V. get (view'0 xs.final) k = C_Some v
        -> contains'0 (view'3 result) k /\ (index_logic'2 (view'3 result) k).final = v}
      (! return {result}) ]
end
module M_collections__roundtrip_hashset_into_iter
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet = { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0 = { t_HashSet__base: t_HashSet }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_AlignmentEnum =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment = { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout = { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple = { f0: t_NonNull; f1: t_Layout; f2: () }
  
  type t_Option = C_None | C_Some tuple
  
  type t_RawIntoIter = {
    t_RawIntoIter__iter: t_RawIter;
    t_RawIntoIter__allocation: t_Option;
    t_RawIntoIter__marker: () }
  
  type t_IntoIter = { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0 = { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1 = { t_IntoIter__base: t_IntoIter'0 }
  
  type t_DeepModelTy
  
  function view (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  let rec into_iter (self_: t_HashSet'0) (return (x: t_IntoIter'1)) = any
    [ return (result: t_IntoIter'1) -> {view self_ = view'0 result} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: t_IntoIter'1) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1) =
    Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x: t_DeepModelTy. contains (view'0 start) x
        -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view'0 end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view'0 start) (deep_model x) /\ not contains (view'0 end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view'0 end') x
        -> contains (view'0 start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j) -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_IntoIter'1) (ab: Seq.seq t_T) (b: t_IntoIter'1) (bc: Seq.seq t_T) (c: t_IntoIter'1) : ()
   = let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_IntoIter'1, ab: Seq.seq t_T, b: t_IntoIter'1, bc: Seq.seq t_T, c: t_IntoIter'1. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  predicate produces (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1) = set_produces self visited o
  
  function produces_trans (a: t_IntoIter'1) (ab: Seq.seq t_T) (b: t_IntoIter'1) (bc: Seq.seq t_T) (c: t_IntoIter'1) : ()
   = let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_IntoIter'1, ab: Seq.seq t_T, b: t_IntoIter'1, bc: Seq.seq t_T, c: t_IntoIter'1. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IntoIter'1) : () = ()
  
  axiom produces_refl_spec: forall self: t_IntoIter'1. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate completed (self: MutBorrow.t t_IntoIter'1) = Fset.is_empty (view'0 self.current)
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    forall x: t_DeepModelTy. contains (view res) x = (exists x1: t_T. deep_model x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_: t_IntoIter'1) (return (x: t_HashSet'0)) = any
    [ return (result: t_HashSet'0) -> {exists done': MutBorrow.t t_IntoIter'1, prod: Seq.seq t_T. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashset_into_iter (xs: t_HashSet'0) (return (x: t_HashSet'0)) = (! bb0
    [ bb0 = s0 [ s0 = into_iter {xs} (fun (_ret: t_IntoIter'1) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = collect {_3} (fun (_ret: t_HashSet'0) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_HashSet'0 = Any.any_l () | & xs: t_HashSet'0 = xs | & _3: t_IntoIter'1 = Any.any_l () ])
    [ return (result: t_HashSet'0) -> {[@expl:roundtrip_hashset_into_iter ensures] view result = view xs}
      (! return {result}) ]
end
module M_collections__roundtrip_hashset_iter
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet = { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0 = { t_HashSet__base: t_HashSet }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter = { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys = { t_Keys__inner: t_Iter }
  
  type t_Iter'0 = { t_Iter__iter: t_Keys }
  
  type t_Iter'1 = { t_Iter__base: t_Iter'0 }
  
  type t_DeepModelTy
  
  function view (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  let rec iter (self_: t_HashSet'0) (return (x: t_Iter'1)) = any
    [ return (result: t_Iter'1) -> {view self_ = view'0 result} (! return {result}) ]
  
  type t_RawTable'0 = { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0 = { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1 = { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'2 = { t_HashSet__base'0: t_HashSet'1 }
  
  predicate resolve [@inline:trivial] (_1: t_Iter'1) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1) =
    Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x: t_DeepModelTy. contains (view'0 start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view'0 end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view'0 start) (deep_model'0 x) /\ not contains (view'0 end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view'0 end') x
        -> contains (view'0 start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Iter'1) (ab: Seq.seq t_T) (b: t_Iter'1) (bc: Seq.seq t_T) (c: t_Iter'1) : () =
    let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Iter'1, ab: Seq.seq t_T, b: t_Iter'1, bc: Seq.seq t_T, c: t_Iter'1. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  predicate produces (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1) = set_produces self visited o
  
  function produces_trans (a: t_Iter'1) (ab: Seq.seq t_T) (b: t_Iter'1) (bc: Seq.seq t_T) (c: t_Iter'1) : () =
    let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_Iter'1, ab: Seq.seq t_T, b: t_Iter'1, bc: Seq.seq t_T, c: t_Iter'1. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Iter'1) : () = ()
  
  axiom produces_refl_spec: forall self: t_Iter'1. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate completed (self: MutBorrow.t t_Iter'1) = Fset.is_empty (view'0 self.current)
  
  function view'1 (self: t_HashSet'2) : Fset.fset t_DeepModelTy
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'2) =
    forall x: t_DeepModelTy. contains (view'1 res) x = (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_: t_Iter'1) (return (x: t_HashSet'2)) = any
    [ return (result: t_HashSet'2) -> {exists done': MutBorrow.t t_Iter'1, prod: Seq.seq t_T. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashset_iter (xs: t_HashSet'0) (return (x: t_HashSet'2)) = (! bb0
    [ bb0 = s0 [ s0 = iter {xs} (fun (_ret: t_Iter'1) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = collect {_3} (fun (_ret: t_HashSet'2) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_HashSet'2 = Any.any_l () | & xs: t_HashSet'0 = xs | & _3: t_Iter'1 = Any.any_l () ])
    [ return (result: t_HashSet'2) -> {[@expl:roundtrip_hashset_iter ensures] view'1 result = view xs}
      (! return {result}) ]
end
module M_collections__hashset_intersection
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet = { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0 = { t_HashSet__base: t_HashSet }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter = { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys = { t_Keys__inner: t_Iter }
  
  type t_Iter'0 = { t_Iter__iter: t_Keys }
  
  type t_Iter'1 = { t_Iter__base: t_Iter'0 }
  
  type t_Intersection = { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_DeepModelTy
  
  function view (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  let rec intersection (self_: t_HashSet'0) (other: t_HashSet'0) (return (x: t_Intersection)) = any
    [ return (result: t_Intersection) -> {view result = Fset.inter (view'0 self_) (view'0 other)} (! return {result}) ]
  
  type t_Copied = { t_Copied__it: t_Intersection }
  
  predicate inv (_1: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv x]. inv x = true
  
  predicate inv'0 (_1: t_Intersection)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Intersection [inv'0 x]. inv'0 x = true
  
  function iter (self: t_Copied) : t_Intersection
  
  axiom iter_spec: forall self: t_Copied. inv self -> inv'0 (iter self)
  
  let rec copied (self_: t_Intersection) (return (x: t_Copied)) = any
    [ return (result: t_Copied) -> {iter result = self_} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: t_Intersection) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (self: t_Copied) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_1: t_Copied) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
   = let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  predicate produces (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection) = set_produces self visited o
  
  function produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
   = let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Intersection) : () = ()
  
  axiom produces_refl_spec: forall self: t_Intersection. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Copied, ab: Seq.seq t_T, b: t_Copied, bc: Seq.seq t_T, c: t_Copied. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Copied) : ()
  
  axiom produces_refl_spec'0: forall self: t_Copied. produces'0 self (Seq.empty: Seq.seq t_T) self
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Intersection) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate completed (self: MutBorrow.t t_Intersection) = resolve'2 self /\ Fset.is_empty (view self.current)
  
  predicate completed'0 (self: MutBorrow.t t_Copied) =
    exists inner: MutBorrow.t t_Intersection. inner.current = iter self.current
      /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    forall x: t_DeepModelTy. contains (view'0 res) x = (exists x1: t_T. deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_: t_Copied) (return (x: t_HashSet'0)) = any
    [ return (result: t_HashSet'0) -> {exists done': MutBorrow.t t_Copied, prod: Seq.seq t_T. resolve'1 done'.final
        /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashset_intersection (xs: t_HashSet'0) (ys: t_HashSet'0) (return (x: t_HashSet'0)) = (! bb0
    [ bb0 = s0 [ s0 = intersection {xs} {ys} (fun (_ret: t_Intersection) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret: t_Copied) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret: t_HashSet'0) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_HashSet'0 = Any.any_l ()
    | & xs: t_HashSet'0 = xs
    | & ys: t_HashSet'0 = ys
    | & _4: t_Copied = Any.any_l ()
    | & _5: t_Intersection = Any.any_l () ])
    [ return (result: t_HashSet'0) -> {[@expl:hashset_intersection ensures] view'0 result
      = Fset.inter (view'0 xs) (view'0 ys)}
      (! return {result}) ]
end
module M_collections__hashset_difference
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet = { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0 = { t_HashSet__base: t_HashSet }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter = { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys = { t_Keys__inner: t_Iter }
  
  type t_Iter'0 = { t_Iter__iter: t_Keys }
  
  type t_Iter'1 = { t_Iter__base: t_Iter'0 }
  
  type t_Difference = { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_DeepModelTy
  
  function view (self: t_Difference) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  let rec difference (self_: t_HashSet'0) (other: t_HashSet'0) (return (x: t_Difference)) = any
    [ return (result: t_Difference) -> {view result = Fset.diff (view'0 self_) (view'0 other)} (! return {result}) ]
  
  type t_Copied = { t_Copied__it: t_Difference }
  
  predicate inv (_1: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv x]. inv x = true
  
  predicate inv'0 (_1: t_Difference)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Difference [inv'0 x]. inv'0 x = true
  
  function iter (self: t_Copied) : t_Difference
  
  axiom iter_spec: forall self: t_Copied. inv self -> inv'0 (iter self)
  
  let rec copied (self_: t_Difference) (return (x: t_Copied)) = any
    [ return (result: t_Copied) -> {iter result = self_} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: t_Difference) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (self: t_Copied) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_1: t_Copied) = resolve'0 _1
  
  meta "rewrite_def" predicate resolve'1
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
   = let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  predicate produces (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference) = set_produces self visited o
  
  function produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
   = let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Difference) : () = ()
  
  axiom produces_refl_spec: forall self: t_Difference. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Copied, ab: Seq.seq t_T, b: t_Copied, bc: Seq.seq t_T, c: t_Copied. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Copied) : ()
  
  axiom produces_refl_spec'0: forall self: t_Copied. produces'0 self (Seq.empty: Seq.seq t_T) self
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Difference) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate completed (self: MutBorrow.t t_Difference) = resolve'2 self /\ Fset.is_empty (view self.current)
  
  predicate completed'0 (self: MutBorrow.t t_Copied) =
    exists inner: MutBorrow.t t_Difference. inner.current = iter self.current
      /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    forall x: t_DeepModelTy. contains (view'0 res) x = (exists x1: t_T. deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_: t_Copied) (return (x: t_HashSet'0)) = any
    [ return (result: t_HashSet'0) -> {exists done': MutBorrow.t t_Copied, prod: Seq.seq t_T. resolve'1 done'.final
        /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashset_difference (xs: t_HashSet'0) (ys: t_HashSet'0) (return (x: t_HashSet'0)) = (! bb0
    [ bb0 = s0 [ s0 = difference {xs} {ys} (fun (_ret: t_Difference) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret: t_Copied) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret: t_HashSet'0) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_HashSet'0 = Any.any_l ()
    | & xs: t_HashSet'0 = xs
    | & ys: t_HashSet'0 = ys
    | & _4: t_Copied = Any.any_l ()
    | & _5: t_Difference = Any.any_l () ])
    [ return (result: t_HashSet'0) -> {[@expl:hashset_difference ensures] view'0 result
      = Fset.diff (view'0 xs) (view'0 ys)}
      (! return {result}) ]
end
