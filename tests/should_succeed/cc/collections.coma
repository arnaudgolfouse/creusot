module M_collections__roundtrip_hashmap_into_iter
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_HashMap
  
  type t_IntoIter
  
  predicate inv (_1: t_HashMap)
  
  predicate inv'0 (_1: t_IntoIter)
  
  type t_FMap
  
  function view (self: t_HashMap) : t_FMap
  
  function view'0 (self: t_IntoIter) : t_FMap
  
  let rec into_iter (self_: t_HashMap) (return (x: t_IntoIter)) = {[@expl:into_iter 'self_' type invariant] inv self_}
    any [ return (result: t_IntoIter) -> {inv'0 result} {view self_ = view'0 result} (! return {result}) ]
  
  predicate resolve (_1: t_IntoIter)
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'1 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'1 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate produces [@inline:trivial] (self: t_IntoIter) (visited: Seq.seq tuple) (o: t_IntoIter) =
    len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view'0 self) (deep_model k) = C_Some v /\ get (view'0 o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 o) k = C_Some v
        -> get (view'0 self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 self) k = C_Some v
        -> (exists k1: t_K. deep_model k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view'0 o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2 /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1).f0 = deep_model (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq tuple) (b: t_IntoIter) (bc: Seq.seq tuple) (c: t_IntoIter) : () =
    ()
  
  axiom produces_trans_spec:
    forall a: t_IntoIter, ab: Seq.seq tuple, b: t_IntoIter, bc: Seq.seq tuple, c: t_IntoIter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IntoIter) : () = ()
  
  axiom produces_refl_spec: forall self: t_IntoIter. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_IntoIter) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_DeepModelTy. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view'1 empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = ext_eq self empty
  
  predicate completed (self: MutBorrow.t t_IntoIter) = resolve'0 self /\ is_empty (view'0 self.current)
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap) =
    forall k: t_DeepModelTy, v: t_V. (get (view res) k = C_Some v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model k1 = k
        /\ Seq.get prod i = { f0 = k1; f1 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model (Seq.get prod j).f0 <> k))
  
  let rec collect (self_: t_IntoIter) (return (x: t_HashMap)) = {[@expl:collect 'self_' type invariant] inv'0 self_}
    any
    [ return (result: t_HashMap) -> {inv result}
      {exists done': MutBorrow.t t_IntoIter, prod: Seq.seq tuple. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) = get self k <> C_None
  
  meta "rewrite_def" predicate contains'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_DeepModelTy) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_into_iter (xs: t_HashMap) (return (x: t_HashMap)) =
    {[@expl:roundtrip_hashmap_into_iter 'xs' type invariant] inv xs}
    (! bb0
    [ bb0 = s0 [ s0 = [ &xs_snap <- xs ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_iter {xs} (fun (_ret: t_IntoIter) -> [ &it <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &it0 <- it ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap) -> [ &r <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:assertion] exists prod: Seq.seq tuple, it1: MutBorrow.t t_IntoIter. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: t_V. (get (view r) k = C_Some v)
            = (exists k1: t_K. deep_model k1 = k /\ contains prod { f0 = k1; f1 = v }))}
        s1
      | s1 = {[@expl:assertion] forall k: t_DeepModelTy. contains'0 (view r) k = contains'0 (view xs_snap) k} s2
      | s2 = {[@expl:assertion] forall k: t_DeepModelTy. index_logic'0 (view r) k = index_logic'0 (view xs_snap) k} s3
      | s3 = {[@expl:assertion] ext_eq (view r) (view xs_snap)} s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_HashMap = Any.any_l ()
    | & xs: t_HashMap = xs
    | & xs_snap: t_HashMap = Any.any_l ()
    | & it: t_IntoIter = Any.any_l ()
    | & it0: t_IntoIter = Any.any_l ()
    | & r: t_HashMap = Any.any_l () ])
    [ return (result: t_HashMap) -> {[@expl:roundtrip_hashmap_into_iter result type invariant] inv result}
      {[@expl:roundtrip_hashmap_into_iter ensures] view result = view xs}
      (! return {result}) ]
end
module M_collections__roundtrip_hashmap_iter
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_HashMap
  
  type t_Iter
  
  predicate inv (_1: t_HashMap)
  
  predicate invariant' [@inline:trivial] (self: t_HashMap) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_HashMap) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Iter)
  
  type t_FMap
  
  function view (self: t_HashMap) : t_FMap
  
  function view'0 (self: t_Iter) : t_FMap
  
  let rec iter (self_: t_HashMap) (return (x: t_Iter)) = {[@expl:iter 'self_' type invariant] inv'0 self_}
    any [ return (result: t_Iter) -> {inv'1 result} {view self_ = view'0 result} (! return {result}) ]
  
  type t_HashMap'0
  
  predicate inv'2 (_1: t_HashMap'0)
  
  predicate resolve (_1: t_Iter)
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'1 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'1 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces [@inline:trivial] (self: t_Iter) (visited: Seq.seq tuple) (o: t_Iter) =
    len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view'0 self) (deep_model'0 k) = C_Some v /\ get (view'0 o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 o) k = C_Some v
        -> get (view'0 self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 self) k = C_Some v
        -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v }) \/ get (view'0 o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces
  
  function produces_trans (a: t_Iter) (ab: Seq.seq tuple) (b: t_Iter) (bc: Seq.seq tuple) (c: t_Iter) : () = ()
  
  axiom produces_trans_spec:
    forall a: t_Iter, ab: Seq.seq tuple, b: t_Iter, bc: Seq.seq tuple, c: t_Iter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Iter) : () = ()
  
  axiom produces_refl_spec: forall self: t_Iter. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Iter) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_DeepModelTy. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view'1 empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = ext_eq self empty
  
  predicate completed (self: MutBorrow.t t_Iter) = resolve'0 self /\ is_empty (view'0 self.current)
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view'2 (self: t_FMap'0) : Map.map t_DeepModelTy t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'0 = Map.get (view'2 self) k
  
  meta "rewrite_def" function get'0
  
  function view'3 (self: t_HashMap'0) : t_FMap'0
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap'0) =
    forall k: t_DeepModelTy, v: t_V. (get'0 (view'3 res) k = C_Some'0 v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model'0 k1 = k
        /\ Seq.get prod i = { f0 = k1; f1 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model'0 (Seq.get prod j).f0 <> k))
  
  let rec collect (self_: t_Iter) (return (x: t_HashMap'0)) = {[@expl:collect 'self_' type invariant] inv'1 self_}
    any
    [ return (result: t_HashMap'0) -> {inv'2 result}
      {exists done': MutBorrow.t t_Iter, prod: Seq.seq tuple. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_iter (xs: t_HashMap) (return (x: t_HashMap'0)) =
    {[@expl:roundtrip_hashmap_iter 'xs' type invariant] inv'0 xs}
    (! bb0
    [ bb0 = s0 [ s0 = iter {xs} (fun (_ret: t_Iter) -> [ &it <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &it0 <- it ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap'0) -> [ &r <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] exists prod: Seq.seq tuple, it1: MutBorrow.t t_Iter. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: t_V. (get'0 (view'3 r) k = C_Some'0 v)
            = (exists k1: t_K. deep_model'0 k1 = k /\ contains prod { f0 = k1; f1 = v }))}
        s1
      | s1 = [ &_0 <- r ] s2
      | s2 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_HashMap'0 = Any.any_l ()
    | & xs: t_HashMap = xs
    | & it: t_Iter = Any.any_l ()
    | & it0: t_Iter = Any.any_l ()
    | & r: t_HashMap'0 = Any.any_l () ])
    [ return (result: t_HashMap'0) -> {[@expl:roundtrip_hashmap_iter result type invariant] inv'2 result}
      {[@expl:roundtrip_hashmap_iter ensures] forall k: t_DeepModelTy, v: t_V. (get'0 (view'3 result) k = C_Some'0 v)
        = (get (view xs) k = C_Some v)}
      (! return {result}) ]
end
module M_collections__roundtrip_hashmap_iter_mut
  use creusot.prelude.MutBorrow
  use map.Map
  use seq.Seq
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_HashMap
  
  predicate inv (_1: t_HashMap)
  
  type t_IterMut
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_HashMap) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_HashMap) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_IterMut)
  
  type t_FMap
  
  type t_DeepModelTy
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  function view'0 (self: t_HashMap) : t_FMap
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_V)
  
  function view'1 (self: t_FMap'0) : Map.map t_DeepModelTy t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'0 = Map.get (view'1 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains'0
  
  function view'2 (self: t_IterMut) : t_FMap'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_DeepModelTy) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (MutBorrow.t t_V) bool) (a: MutBorrow.t t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (MutBorrow.t t_V) bool) : MutBorrow.t t_V
  
  axiom such_that_spec'0: forall p: Map.map (MutBorrow.t t_V) bool. (exists x: MutBorrow.t t_V. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'0) : MutBorrow.t t_V = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: MutBorrow.t t_V) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : MutBorrow.t t_V =
    unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_DeepModelTy) : MutBorrow.t t_V = lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  let rec iter_mut (self_: MutBorrow.t t_HashMap) (return (x: t_IterMut)) =
    {[@expl:iter_mut 'self_' type invariant] inv'0 self_}
    any
    [ return (result: t_IterMut) -> {inv'1 result}
      {forall k: t_DeepModelTy. contains (view'0 self_.current) k = contains (view'0 self_.final) k}
      {forall k: t_DeepModelTy. contains (view'0 self_.current) k = contains'0 (view'2 result) k}
      {forall k: t_DeepModelTy. contains (view'0 self_.current) k
        -> index_logic'0 (view'0 self_.current) k = (index_logic'2 (view'2 result) k).current
        /\ index_logic'0 (view'0 self_.final) k = (index_logic'2 (view'2 result) k).final}
      (! return {result}) ]
  
  type t_HashMap'0
  
  predicate inv'2 (_1: t_HashMap'0)
  
  predicate resolve (_1: t_IterMut)
  
  type t_K
  
  type tuple = { f0: t_K; f1: MutBorrow.t t_V }
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. len self >= 0
  
  predicate contains'1 (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces [@inline:trivial] (self: t_IterMut) (visited: Seq.seq tuple) (o: t_IterMut) =
    len (view'2 self) = Seq.length visited + len (view'2 o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains'1 visited { f0 = k; f1 = v }
        -> get'0 (view'2 self) (deep_model k) = C_Some'0 v /\ get'0 (view'2 o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'2 o) k = C_Some'0 v
        -> get'0 (view'2 self) k = C_Some'0 v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains'1 visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'2 self) k = C_Some'0 v
        -> (exists k1: t_K. deep_model'0 k1 = k /\ contains'1 visited { f0 = k1; f1 = v })
        \/ get'0 (view'2 o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces
  
  function produces_trans (a: t_IterMut) (ab: Seq.seq tuple) (b: t_IterMut) (bc: Seq.seq tuple) (c: t_IterMut) : () = ()
  
  axiom produces_trans_spec:
    forall a: t_IterMut, ab: Seq.seq tuple, b: t_IterMut, bc: Seq.seq tuple, c: t_IterMut. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IterMut) : () = ()
  
  axiom produces_refl_spec: forall self: t_IterMut. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_IterMut) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) = forall k: t_DeepModelTy. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. ext_eq self other = (self = other)
  
  constant empty : t_FMap'0
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view'1 empty = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap'0) = ext_eq self empty
  
  predicate completed (self: MutBorrow.t t_IterMut) = resolve'0 self /\ is_empty (view'2 self.current)
  
  function view'3 (self: t_HashMap'0) : t_FMap'0
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap'0) =
    forall k: t_DeepModelTy, v: MutBorrow.t t_V. (get'0 (view'3 res) k = C_Some'0 v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model'0 k1 = k
        /\ Seq.get prod i = { f0 = k1; f1 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model'0 (Seq.get prod j).f0 <> k))
  
  let rec collect (self_: t_IterMut) (return (x: t_HashMap'0)) = {[@expl:collect 'self_' type invariant] inv'1 self_}
    any
    [ return (result: t_HashMap'0) -> {inv'2 result}
      {exists done': MutBorrow.t t_IterMut, prod: Seq.seq tuple. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_HashMap) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_iter_mut (xs: MutBorrow.t t_HashMap) (return (x: t_HashMap'0)) =
    {[@expl:roundtrip_hashmap_iter_mut 'xs' type invariant] inv'0 xs}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv xs.current}
        MutBorrow.borrow_final <t_HashMap> {xs.current} {MutBorrow.get_id xs}
          (fun (_ret: MutBorrow.t t_HashMap) ->
            [ &_6 <- _ret ] -{inv _ret.final}-
            [ &xs <- { xs with current = _ret.final } ] s1)
      | s1 = iter_mut {_6} (fun (_ret: t_IterMut) -> [ &it <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &it0 <- it ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap'0) -> [ &r <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] exists prod: Seq.seq tuple, it1: MutBorrow.t t_IterMut. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. (get'0 (view'3 r) k = C_Some'0 v)
            = (exists k1: t_K. deep_model'0 k1 = k /\ contains'1 prod { f0 = k1; f1 = v }))}
        s1
      | s1 = [ &_0 <- r ] s2
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 xs} s1 | s1 = -{resolve'1 xs}- s2 | s2 = return {_0} ] ]
    [ & _0: t_HashMap'0 = Any.any_l ()
    | & xs: MutBorrow.t t_HashMap = xs
    | & it: t_IterMut = Any.any_l ()
    | & _6: MutBorrow.t t_HashMap = Any.any_l ()
    | & it0: t_IterMut = Any.any_l ()
    | & r: t_HashMap'0 = Any.any_l () ])
    [ return (result: t_HashMap'0) -> {[@expl:roundtrip_hashmap_iter_mut result type invariant] inv'2 result}
      {[@expl:roundtrip_hashmap_iter_mut ensures #0] forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'3 result) k
          = C_Some'0 v -> get (view'0 xs.current) k = C_Some (v.current) /\ get (view'0 xs.final) k = C_Some (v.final)}
      {[@expl:roundtrip_hashmap_iter_mut ensures #1] forall k: t_DeepModelTy, v: t_V. get (view'0 xs.current) k
          = C_Some v -> contains'0 (view'3 result) k /\ (index_logic'2 (view'3 result) k).current = v}
      {[@expl:roundtrip_hashmap_iter_mut ensures #2] forall k: t_DeepModelTy, v: t_V. get (view'0 xs.final) k = C_Some v
        -> contains'0 (view'3 result) k /\ (index_logic'2 (view'3 result) k).final = v}
      (! return {result}) ]
end
module M_collections__roundtrip_hashset_into_iter
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_HashSet
  
  type t_IntoIter
  
  predicate inv (_1: t_HashSet)
  
  predicate inv'0 (_1: t_IntoIter)
  
  type t_DeepModelTy
  
  function view (self: t_HashSet) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_IntoIter) : Fset.fset t_DeepModelTy
  
  let rec into_iter (self_: t_HashSet) (return (x: t_IntoIter)) = {[@expl:into_iter 'self_' type invariant] inv self_}
    any [ return (result: t_IntoIter) -> {inv'0 result} {view self_ = view'0 result} (! return {result}) ]
  
  predicate resolve (_1: t_IntoIter)
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_IntoIter) (visited: Seq.seq t_T) (end': t_IntoIter) =
    Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x: t_DeepModelTy. contains (view'0 start) x
        -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view'0 end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view'0 start) (deep_model x) /\ not contains (view'0 end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view'0 end') x
        -> contains (view'0 start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j) -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_IntoIter) (ab: Seq.seq t_T) (b: t_IntoIter) (bc: Seq.seq t_T) (c: t_IntoIter) : () =
    let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_IntoIter, ab: Seq.seq t_T, b: t_IntoIter, bc: Seq.seq t_T, c: t_IntoIter. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = set_produces self visited o
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq t_T) (b: t_IntoIter) (bc: Seq.seq t_T) (c: t_IntoIter) : () =
    let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_IntoIter, ab: Seq.seq t_T, b: t_IntoIter, bc: Seq.seq t_T, c: t_IntoIter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IntoIter) : () = ()
  
  axiom produces_refl_spec: forall self: t_IntoIter. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate completed (self: MutBorrow.t t_IntoIter) = Fset.is_empty (view'0 self.current)
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet) =
    forall x: t_DeepModelTy. contains (view res) x = (exists x1: t_T. deep_model x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_: t_IntoIter) (return (x: t_HashSet)) = {[@expl:collect 'self_' type invariant] inv'0 self_}
    any
    [ return (result: t_HashSet) -> {inv result}
      {exists done': MutBorrow.t t_IntoIter, prod: Seq.seq t_T. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashset_into_iter (xs: t_HashSet) (return (x: t_HashSet)) =
    {[@expl:roundtrip_hashset_into_iter 'xs' type invariant] inv xs}
    (! bb0
    [ bb0 = s0 [ s0 = into_iter {xs} (fun (_ret: t_IntoIter) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = collect {_3} (fun (_ret: t_HashSet) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ] [ & _0: t_HashSet = Any.any_l () | & xs: t_HashSet = xs | & _3: t_IntoIter = Any.any_l () ])
    [ return (result: t_HashSet) -> {[@expl:roundtrip_hashset_into_iter result type invariant] inv result}
      {[@expl:roundtrip_hashset_into_iter ensures] view result = view xs}
      (! return {result}) ]
end
module M_collections__roundtrip_hashset_iter
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_HashSet
  
  type t_Iter
  
  predicate inv (_1: t_HashSet)
  
  predicate invariant' [@inline:trivial] (self: t_HashSet) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_HashSet) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Iter)
  
  type t_DeepModelTy
  
  function view (self: t_HashSet) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_Iter) : Fset.fset t_DeepModelTy
  
  let rec iter (self_: t_HashSet) (return (x: t_Iter)) = {[@expl:iter 'self_' type invariant] inv'0 self_}
    any [ return (result: t_Iter) -> {inv'1 result} {view self_ = view'0 result} (! return {result}) ]
  
  type t_HashSet'0
  
  predicate inv'2 (_1: t_HashSet'0)
  
  predicate resolve (_1: t_Iter)
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Iter) (visited: Seq.seq t_T) (end': t_Iter) =
    Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x: t_DeepModelTy. contains (view'0 start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view'0 end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view'0 start) (deep_model'0 x) /\ not contains (view'0 end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view'0 end') x
        -> contains (view'0 start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : () =
    let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Iter, ab: Seq.seq t_T, b: t_Iter, bc: Seq.seq t_T, c: t_Iter. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) = set_produces self visited o
  
  function produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : () =
    let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec: forall a: t_Iter, ab: Seq.seq t_T, b: t_Iter, bc: Seq.seq t_T, c: t_Iter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Iter) : () = ()
  
  axiom produces_refl_spec: forall self: t_Iter. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate completed (self: MutBorrow.t t_Iter) = Fset.is_empty (view'0 self.current)
  
  function view'1 (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    forall x: t_DeepModelTy. contains (view'1 res) x = (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_: t_Iter) (return (x: t_HashSet'0)) = {[@expl:collect 'self_' type invariant] inv'1 self_}
    any
    [ return (result: t_HashSet'0) -> {inv'2 result}
      {exists done': MutBorrow.t t_Iter, prod: Seq.seq t_T. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashset_iter (xs: t_HashSet) (return (x: t_HashSet'0)) =
    {[@expl:roundtrip_hashset_iter 'xs' type invariant] inv'0 xs}
    (! bb0
    [ bb0 = s0 [ s0 = iter {xs} (fun (_ret: t_Iter) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = collect {_3} (fun (_ret: t_HashSet'0) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_HashSet'0 = Any.any_l () | & xs: t_HashSet = xs | & _3: t_Iter = Any.any_l () ])
    [ return (result: t_HashSet'0) -> {[@expl:roundtrip_hashset_iter result type invariant] inv'2 result}
      {[@expl:roundtrip_hashset_iter ensures] view'1 result = view xs}
      (! return {result}) ]
end
module M_collections__hashset_intersection
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_HashSet
  
  type t_Intersection
  
  predicate inv (_1: t_HashSet)
  
  predicate invariant' [@inline:trivial] (self: t_HashSet) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_HashSet) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Intersection)
  
  type t_DeepModelTy
  
  function view (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet) : Fset.fset t_DeepModelTy
  
  let rec intersection (self_: t_HashSet) (other: t_HashSet) (return (x: t_Intersection)) =
    {[@expl:intersection 'self_' type invariant] inv'0 self_}
    {[@expl:intersection 'other' type invariant] inv'0 other}
    any
    [ return (result: t_Intersection) -> {inv'1 result}
      {view result = Fset.inter (view'0 self_) (view'0 other)}
      (! return {result}) ]
  
  type t_Copied
  
  function iter (self: t_Copied) : t_Intersection
  
  predicate invariant''0 [@inline:trivial] (self: t_Copied) = inv'1 (iter self)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_Copied)
  
  axiom inv_axiom: forall x: t_Copied [inv'2 x]. inv'2 x -> invariant''0 x
  
  let rec copied (self_: t_Intersection) (return (x: t_Copied)) = {[@expl:copied 'self_' type invariant] inv'1 self_}
    any [ return (result: t_Copied) -> {inv'2 result} {iter result = self_} (! return {result}) ]
  
  predicate resolve (_1: t_Intersection)
  
  predicate resolve'0 [@inline:trivial] (self: t_Copied) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 (_1: t_Copied)
  
  axiom resolve_axiom: forall x: t_Copied [resolve'1 x]. resolve'1 x -> resolve'0 x
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
   = let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  predicate produces (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection) = set_produces self visited o
  
  function produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
   = let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Intersection) : () = ()
  
  axiom produces_refl_spec: forall self: t_Intersection. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Copied, ab: Seq.seq t_T, b: t_Copied, bc: Seq.seq t_T, c: t_Copied. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Copied) : ()
  
  axiom produces_refl_spec'0: forall self: t_Copied. produces'0 self (Seq.empty: Seq.seq t_T) self
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Intersection) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate completed (self: MutBorrow.t t_Intersection) = resolve'2 self /\ Fset.is_empty (view self.current)
  
  predicate completed'0 (self: MutBorrow.t t_Copied) =
    exists inner: MutBorrow.t t_Intersection. inner.current = iter self.current
      /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet) =
    forall x: t_DeepModelTy. contains (view'0 res) x = (exists x1: t_T. deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_: t_Copied) (return (x: t_HashSet)) = {[@expl:collect 'self_' type invariant] inv'2 self_}
    any
    [ return (result: t_HashSet) -> {inv result}
      {exists done': MutBorrow.t t_Copied, prod: Seq.seq t_T. resolve'1 done'.final
        /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashset_intersection (xs: t_HashSet) (ys: t_HashSet) (return (x: t_HashSet)) =
    {[@expl:hashset_intersection 'xs' type invariant] inv'0 xs}
    {[@expl:hashset_intersection 'ys' type invariant] inv'0 ys}
    (! bb0
    [ bb0 = s0 [ s0 = intersection {xs} {ys} (fun (_ret: t_Intersection) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret: t_Copied) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret: t_HashSet) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_HashSet = Any.any_l ()
    | & xs: t_HashSet = xs
    | & ys: t_HashSet = ys
    | & _4: t_Copied = Any.any_l ()
    | & _5: t_Intersection = Any.any_l () ])
    [ return (result: t_HashSet) -> {[@expl:hashset_intersection result type invariant] inv result}
      {[@expl:hashset_intersection ensures] view'0 result = Fset.inter (view'0 xs) (view'0 ys)}
      (! return {result}) ]
end
module M_collections__hashset_difference
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_HashSet
  
  type t_Difference
  
  predicate inv (_1: t_HashSet)
  
  predicate invariant' [@inline:trivial] (self: t_HashSet) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_HashSet) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Difference)
  
  type t_DeepModelTy
  
  function view (self: t_Difference) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet) : Fset.fset t_DeepModelTy
  
  let rec difference (self_: t_HashSet) (other: t_HashSet) (return (x: t_Difference)) =
    {[@expl:difference 'self_' type invariant] inv'0 self_}
    {[@expl:difference 'other' type invariant] inv'0 other}
    any
    [ return (result: t_Difference) -> {inv'1 result}
      {view result = Fset.diff (view'0 self_) (view'0 other)}
      (! return {result}) ]
  
  type t_Copied
  
  function iter (self: t_Copied) : t_Difference
  
  predicate invariant''0 [@inline:trivial] (self: t_Copied) = inv'1 (iter self)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_Copied)
  
  axiom inv_axiom: forall x: t_Copied [inv'2 x]. inv'2 x -> invariant''0 x
  
  let rec copied (self_: t_Difference) (return (x: t_Copied)) = {[@expl:copied 'self_' type invariant] inv'1 self_}
    any [ return (result: t_Copied) -> {inv'2 result} {iter result = self_} (! return {result}) ]
  
  predicate resolve (_1: t_Difference)
  
  predicate resolve'0 [@inline:trivial] (self: t_Copied) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 (_1: t_Copied)
  
  axiom resolve_axiom: forall x: t_Copied [resolve'1 x]. resolve'1 x -> resolve'0 x
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
   = let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  predicate produces (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference) = set_produces self visited o
  
  function produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
   = let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Difference) : () = ()
  
  axiom produces_refl_spec: forall self: t_Difference. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Copied, ab: Seq.seq t_T, b: t_Copied, bc: Seq.seq t_T, c: t_Copied. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Copied) : ()
  
  axiom produces_refl_spec'0: forall self: t_Copied. produces'0 self (Seq.empty: Seq.seq t_T) self
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Difference) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate completed (self: MutBorrow.t t_Difference) = resolve'2 self /\ Fset.is_empty (view self.current)
  
  predicate completed'0 (self: MutBorrow.t t_Copied) =
    exists inner: MutBorrow.t t_Difference. inner.current = iter self.current
      /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet) =
    forall x: t_DeepModelTy. contains (view'0 res) x = (exists x1: t_T. deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_: t_Copied) (return (x: t_HashSet)) = {[@expl:collect 'self_' type invariant] inv'2 self_}
    any
    [ return (result: t_HashSet) -> {inv result}
      {exists done': MutBorrow.t t_Copied, prod: Seq.seq t_T. resolve'1 done'.final
        /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashset_difference (xs: t_HashSet) (ys: t_HashSet) (return (x: t_HashSet)) =
    {[@expl:hashset_difference 'xs' type invariant] inv'0 xs}
    {[@expl:hashset_difference 'ys' type invariant] inv'0 ys}
    (! bb0
    [ bb0 = s0 [ s0 = difference {xs} {ys} (fun (_ret: t_Difference) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret: t_Copied) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret: t_HashSet) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_HashSet = Any.any_l ()
    | & xs: t_HashSet = xs
    | & ys: t_HashSet = ys
    | & _4: t_Copied = Any.any_l ()
    | & _5: t_Difference = Any.any_l () ])
    [ return (result: t_HashSet) -> {[@expl:hashset_difference result type invariant] inv result}
      {[@expl:hashset_difference ensures] view'0 result = Fset.diff (view'0 xs) (view'0 ys)}
      (! return {result}) ]
end
