module M_collections__roundtrip_hashmap_into_iter [#"collections.rs" 14 0 16 18]
  let%span scollections = "collections.rs" 17 18 17 31
  let%span scollections'0 = "collections.rs" 19 14 19 30
  let%span scollections'1 = "collections.rs" 22 8 25 79
  let%span scollections'2 = "collections.rs" 27 20 27 87
  let%span scollections'3 = "collections.rs" 28 20 28 69
  let%span scollections'4 = "collections.rs" 29 20 29 39
  let%span scollections'5 = "collections.rs" 13 10 13 24
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 39 18 39 34
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 86 8 86 56
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 70 12 80 29
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 199 20 201 81
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 90 4 90 49
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 91 27 91 29
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 94 4 94 34
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 95 4 95 34
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 96 4 96 44
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 98 8 98 99
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 168 26 169 119
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 174 14 174 39
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 177 12 177 35
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 112 4 112 18
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 51 14 51 31
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 43
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 365 20 365 71
  let%span ssnapshot = "../../../creusot-contracts/src/snapshot.rs" 57 4 57 26
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0 = { t_HashMap__base: t_HashMap }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_AlignmentEnum =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment = { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout = { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple = { _p0: t_NonNull; _p1: t_Layout; _p2: () }
  
  type t_Option = C_None | C_Some tuple
  
  type t_RawIntoIter = {
    t_RawIntoIter__iter: t_RawIter;
    t_RawIntoIter__allocation: t_Option;
    t_RawIntoIter__marker: () }
  
  type t_IntoIter = { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0 = { t_IntoIter__base: t_IntoIter }
  
  type t_FMap
  
  function view (self: t_HashMap'0) : t_FMap
  
  function view'0 (self: t_IntoIter'0) : t_FMap
  
  let rec into_iter (self_: t_HashMap'0) (return' (x: t_IntoIter'0)) = any
    [ return''0 (result: t_IntoIter'0) -> {[%#shash_map] view self_ = view'0 result} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (_0: t_IntoIter'0) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_K
  
  type t_V
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_V }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'5] len self >= 0
  
  predicate contains (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view'1 (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0 = [%#sfmap] Map.get (view'1 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate produces (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0) =
    [%#shash_map'1] len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
        -> get (view'0 self) (deep_model k) = C_Some'0 v /\ get (view'0 o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 o) k = C_Some'0 v
        -> get (view'0 self) k = C_Some'0 v
        /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 self) k = C_Some'0 v
        -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
        \/ get (view'0 o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
      -> i1 = i2)
  
  function produces_trans (a: t_IntoIter'0) (ab: Seq.seq tuple'0) (b: t_IntoIter'0) (bc: Seq.seq tuple'0) (c: t_IntoIter'0) : ()
   = [%#shash_map'8] ()
  
  axiom produces_trans_spec:
    forall a: t_IntoIter'0, ab: Seq.seq tuple'0, b: t_IntoIter'0, bc: Seq.seq tuple'0, c: t_IntoIter'0. ([%#shash_map'5] produces a ab b)
      -> ([%#shash_map'6] produces b bc c) -> ([%#shash_map'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_IntoIter'0) : () = [%#shash_map'4] ()
  
  axiom produces_refl_spec: forall self: t_IntoIter'0. [%#shash_map'3] produces self (Seq.empty: Seq.seq tuple'0) self
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_IntoIter'0) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = [%#sfmap'3] forall k: t_DeepModelTy. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'2] ext_eq self other = (self = other)
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'7] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'8] view'1 empty = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap) = [%#sfmap'4] ext_eq self empty
  
  function view'2 [@inline:trivial] (self: MutBorrow.t t_IntoIter'0) : t_FMap = [%#smodel] view'0 self.current
  
  meta "rewrite_def" function view'2
  
  predicate completed (self: MutBorrow.t t_IntoIter'0) = [%#shash_map'0] resolve'0 self /\ is_empty (view'2 self)
  
  predicate from_iter_post (prod: Seq.seq tuple'0) (res: t_HashMap'0) =
    [%#shash_map'2] forall k: t_DeepModelTy, v: t_V. (get (view res) k = C_Some'0 v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model k1 = k
        /\ Seq.get prod i = { _p0'0 = k1; _p1'0 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model (Seq.get prod j)._p0'0 <> k))
  
  let rec collect (self_: t_IntoIter'0) (return' (x: t_HashMap'0)) = any
    [ return''0 (result: t_HashMap'0) ->
    {[%#siter] exists done': MutBorrow.t t_IntoIter'0, prod: Seq.seq tuple'0. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  predicate contains'0 [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) = [%#sfmap'0] get self k <> C_None'0
  
  meta "rewrite_def" predicate contains'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#slogic] exists x: t_V. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option'0) : t_V = [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V = [%#sfmap'6] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_DeepModelTy) : t_V = [%#sfmap'1] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  function view'3 [@inline:trivial] (self: t_HashMap'0) : t_FMap = [%#smodel'0] view self
  
  meta "rewrite_def" function view'3
  
  function view'4 [@inline:trivial] (self: t_HashMap'0) : t_FMap = [%#ssnapshot] view'3 self
  
  meta "rewrite_def" function view'4
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_into_iter [#"collections.rs" 14 0 16 18] (xs: t_HashMap'0) (return' (x: t_HashMap'0)) =
    (! bb0
    [ bb0 = s0 [ s0 = [ &xs_snap <- [%#scollections] xs'0 ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_iter {xs'0} (fun (_ret: t_IntoIter'0) -> [ &it <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &it0 <- [%#scollections'0] it ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap'0) -> [ &r <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 =
        {[@expl:assertion] [%#scollections'1] exists prod: Seq.seq tuple'0, it1: MutBorrow.t t_IntoIter'0. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: t_V. (get (view r) k = C_Some'0 v)
            = (exists k1: t_K. deep_model k1 = k /\ contains prod { _p0'0 = k1; _p1'0 = v }))}
        s1
      | s1 = {[@expl:assertion] [%#scollections'2] forall k: t_DeepModelTy. contains'0 (view r) k
          = contains'0 (view xs_snap) k}
        s2
      | s2 = {[@expl:assertion] [%#scollections'3] forall k: t_DeepModelTy. index_logic'0 (view r) k
          = index_logic'0 (view xs_snap) k}
        s3
      | s3 = {[@expl:assertion] [%#scollections'4] ext_eq (view r) (view'4 xs_snap)} s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb7 ]
    | bb7 = return''0 {_0} ]
    [ & _0: t_HashMap'0 = Any.any_l ()
    | & xs'0: t_HashMap'0 = xs
    | & xs_snap: t_HashMap'0 = Any.any_l ()
    | & it: t_IntoIter'0 = Any.any_l ()
    | & it0: t_IntoIter'0 = Any.any_l ()
    | & r: t_HashMap'0 = Any.any_l () ])
    [ return''0 (result: t_HashMap'0) -> {[@expl:roundtrip_hashmap_into_iter ensures] [%#scollections'5] view result
      = view xs}
      (! return' {result}) ]
end
module M_collections__roundtrip_hashmap_iter [#"collections.rs" 34 0 34 97]
  let%span scollections = "collections.rs" 36 14 36 30
  let%span scollections'0 = "collections.rs" 40 4 43 76
  let%span scollections'1 = "collections.rs" 33 10 33 98
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 26 30 26 46
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 132 8 132 56
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 116 12 126 29
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 199 20 201 81
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 136 4 136 49
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 137 27 137 29
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 140 4 140 34
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 141 4 141 34
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 142 4 142 44
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 144 8 144 99
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 168 26 169 119
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 112 4 112 18
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 174 14 174 39
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 177 12 177 35
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 51 14 51 31
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 43
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 365 20 365 71
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0 = { t_HashMap__base: t_HashMap }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter = { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0 = { t_Iter__base: t_Iter }
  
  type t_FMap
  
  function view (self: t_HashMap'0) : t_FMap
  
  function view'0 [@inline:trivial] (self: t_HashMap'0) : t_FMap = [%#smodel'0] view self
  
  meta "rewrite_def" function view'0
  
  function view'1 (self: t_Iter'0) : t_FMap
  
  let rec iter (self_: t_HashMap'0) (return' (x: t_Iter'0)) = any
    [ return''0 (result: t_Iter'0) -> {[%#shash_map] view'0 self_ = view'1 result} (! return' {result}) ]
  
  type t_RawTable'0 = { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1 = { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'2 = { t_HashMap__base'0: t_HashMap'1 }
  
  predicate resolve [@inline:trivial] (_0: t_Iter'0) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_K
  
  type t_V
  
  type tuple = { _p0: t_K; _p1: t_V }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'1] len self >= 0
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'2 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = [%#sfmap] Map.get (view'2 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0) =
    [%#shash_map'1] len (view'1 self) = Seq.length visited + len (view'1 o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
        -> get (view'1 self) (deep_model'0 k) = C_Some v /\ get (view'1 o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'1 o) k = C_Some v
        -> get (view'1 self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'1 self) k = C_Some v
        -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v })
        \/ get (view'1 o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
      -> i1 = i2)
  
  function produces_trans (a: t_Iter'0) (ab: Seq.seq tuple) (b: t_Iter'0) (bc: Seq.seq tuple) (c: t_Iter'0) : () =
    [%#shash_map'8] ()
  
  axiom produces_trans_spec:
    forall a: t_Iter'0, ab: Seq.seq tuple, b: t_Iter'0, bc: Seq.seq tuple, c: t_Iter'0. ([%#shash_map'5] produces a ab b)
      -> ([%#shash_map'6] produces b bc c) -> ([%#shash_map'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Iter'0) : () = [%#shash_map'4] ()
  
  axiom produces_refl_spec: forall self: t_Iter'0. [%#shash_map'3] produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Iter'0) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = [%#sfmap'3] forall k: t_DeepModelTy. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'2] ext_eq self other = (self = other)
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'4] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'5] view'2 empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = [%#sfmap'0] ext_eq self empty
  
  function view'3 [@inline:trivial] (self: MutBorrow.t t_Iter'0) : t_FMap = [%#smodel'1] view'1 self.current
  
  meta "rewrite_def" function view'3
  
  predicate completed (self: MutBorrow.t t_Iter'0) = [%#shash_map'0] resolve'0 self /\ is_empty (view'3 self)
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view'4 (self: t_FMap'0) : Map.map t_DeepModelTy t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'0 = [%#sfmap] Map.get (view'4 self) k
  
  meta "rewrite_def" function get'0
  
  function view'5 (self: t_HashMap'2) : t_FMap'0
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap'2) =
    [%#shash_map'2] forall k: t_DeepModelTy, v: t_V. (get'0 (view'5 res) k = C_Some'0 v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model'0 k1 = k
        /\ Seq.get prod i = { _p0 = k1; _p1 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model'0 (Seq.get prod j)._p0 <> k))
  
  let rec collect (self_: t_Iter'0) (return' (x: t_HashMap'2)) = any
    [ return''0 (result: t_HashMap'2) ->
    {[%#siter] exists done': MutBorrow.t t_Iter'0, prod: Seq.seq tuple. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_iter [#"collections.rs" 34 0 34 97] (xs: t_HashMap'0) (return' (x: t_HashMap'2)) = (! bb0
    [ bb0 = s0 [ s0 = iter {xs'0} (fun (_ret: t_Iter'0) -> [ &it <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &it0 <- [%#scollections] it ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap'2) -> [ &r <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections'0] exists prod: Seq.seq tuple, it1: MutBorrow.t t_Iter'0. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: t_V. (get'0 (view'5 r) k = C_Some'0 v)
            = (exists k1: t_K. deep_model'0 k1 = k /\ contains prod { _p0 = k1; _p1 = v }))}
        s1
      | s1 = [ &_0 <- r ] s2
      | s2 = bb4 ]
    | bb4 = return''0 {_0} ]
    [ & _0: t_HashMap'2 = Any.any_l ()
    | & xs'0: t_HashMap'0 = xs
    | & it: t_Iter'0 = Any.any_l ()
    | & it0: t_Iter'0 = Any.any_l ()
    | & r: t_HashMap'2 = Any.any_l () ])
    [ return''0 (result: t_HashMap'2) ->
    {[@expl:roundtrip_hashmap_iter ensures] [%#scollections'1] forall k: t_DeepModelTy, v: t_V. (get'0 (view'5 result) k
          = C_Some'0 v)
        = (get (view'0 xs) k = C_Some v)}
      (! return' {result}) ]
end
module M_collections__roundtrip_hashmap_iter_mut [#"collections.rs" 50 0 52 24]
  let%span scollections = "collections.rs" 54 14 54 30
  let%span scollections'0 = "collections.rs" 57 8 60 80
  let%span scollections'1 = "collections.rs" 47 10 47 128
  let%span scollections'2 = "collections.rs" 48 10 48 107
  let%span scollections'3 = "collections.rs" 49 10 49 110
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 29 30 29 100
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 30 30 30 99
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 31 30 31 137
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 178 8 178 56
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 162 12 172 29
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 199 20 201 81
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 182 4 182 49
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 183 27 183 29
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 186 4 186 34
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 187 4 187 34
  let%span shash_map'9 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 188 4 188 44
  let%span shash_map'10 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 190 8 190 99
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 168 26 169 119
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 92 4 92 26
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 108 8 108 27
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 258 4 258 26
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 112 4 112 18
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 60 14 60 25
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 100 4 100 26
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 174 14 174 39
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 177 12 177 35
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 51 14 51 31
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 52 14 52 43
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 365 20 365 71
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 744 15 744 27
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 746 8 749 9
  let%span slogic = "../../../creusot-contracts/src/logic.rs" 32 11 32 28
  let%span slogic'0 = "../../../creusot-contracts/src/logic.rs" 33 0 33 21
  let%span smapping = "../../../creusot-contracts/src/logic/mapping.rs" 62 4 62 26
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use map.Map
  use seq.Seq
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0 = { t_HashMap__base: t_HashMap }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut = { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0 = { t_IterMut__base: t_IterMut }
  
  type t_FMap
  
  type t_DeepModelTy
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = [%#sfmap] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) = [%#sfmap'0] get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  function view'0 (self: t_HashMap'0) : t_FMap
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_V)
  
  function view'1 (self: t_FMap'0) : Map.map t_DeepModelTy t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'0 = [%#sfmap] Map.get (view'1 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) = [%#sfmap'0] get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains'0
  
  function view'2 (self: t_IterMut'0) : t_FMap'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#slogic] exists x: t_V. index_logic p x)
      -> ([%#slogic'0] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : t_V = [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V = [%#sfmap'4] unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_DeepModelTy) : t_V = [%#sfmap'1] lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map (MutBorrow.t t_V) bool) (a: MutBorrow.t t_V) =
    [%#smapping] Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map (MutBorrow.t t_V) bool) : MutBorrow.t t_V
  
  axiom such_that_spec'0:
    forall p: Map.map (MutBorrow.t t_V) bool. ([%#slogic] exists x: MutBorrow.t t_V. index_logic'1 p x)
      -> ([%#slogic'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic'0 (self: t_Option'0) : MutBorrow.t t_V = [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: MutBorrow.t t_V) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : MutBorrow.t t_V =
    [%#sfmap'4] unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_DeepModelTy) : MutBorrow.t t_V =
    [%#sfmap'1] lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  let rec iter_mut (self_: MutBorrow.t t_HashMap'0) (return' (x: t_IterMut'0)) = any
    [ return''0 (result: t_IterMut'0) -> {[%#shash_map] forall k: t_DeepModelTy. contains (view'0 self_.current) k
        = contains (view'0 self_.final) k}
      {[%#shash_map'0] forall k: t_DeepModelTy. contains (view'0 self_.current) k = contains'0 (view'2 result) k}
      {[%#shash_map'1] forall k: t_DeepModelTy. contains (view'0 self_.current) k
        -> index_logic'0 (view'0 self_.current) k = (index_logic'2 (view'2 result) k).current
        /\ index_logic'0 (view'0 self_.final) k = (index_logic'2 (view'2 result) k).final}
      (! return' {result}) ]
  
  type t_RawTable'0 = { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1 = { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'2 = { t_HashMap__base'0: t_HashMap'1 }
  
  predicate resolve [@inline:trivial] (_0: t_IterMut'0) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_K
  
  type tuple = { _p0: t_K; _p1: MutBorrow.t t_V }
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. [%#sfmap'3] len self >= 0
  
  predicate contains'1 (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0) =
    [%#shash_map'3] len (view'2 self) = Seq.length visited + len (view'2 o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains'1 visited { _p0 = k; _p1 = v }
        -> get'0 (view'2 self) (deep_model k) = C_Some'0 v /\ get'0 (view'2 o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'2 o) k = C_Some'0 v
        -> get'0 (view'2 self) k = C_Some'0 v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains'1 visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'2 self) k = C_Some'0 v
        -> (exists k1: t_K. deep_model'0 k1 = k /\ contains'1 visited { _p0 = k1; _p1 = v })
        \/ get'0 (view'2 o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
      -> i1 = i2)
  
  function produces_trans (a: t_IterMut'0) (ab: Seq.seq tuple) (b: t_IterMut'0) (bc: Seq.seq tuple) (c: t_IterMut'0) : ()
   = [%#shash_map'10] ()
  
  axiom produces_trans_spec:
    forall a: t_IterMut'0, ab: Seq.seq tuple, b: t_IterMut'0, bc: Seq.seq tuple, c: t_IterMut'0. ([%#shash_map'7] produces a ab b)
      -> ([%#shash_map'8] produces b bc c) -> ([%#shash_map'9] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_IterMut'0) : () = [%#shash_map'6] ()
  
  axiom produces_refl_spec: forall self: t_IterMut'0. [%#shash_map'5] produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_IterMut'0) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) =
    [%#sfmap'6] forall k: t_DeepModelTy. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap'5] ext_eq self other = (self = other)
  
  constant empty : t_FMap'0
  
  axiom empty_spec: [%#sfmap'7] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'8] view'1 empty = Const.const (C_None'0)
  
  predicate is_empty (self: t_FMap'0) = [%#sfmap'2] ext_eq self empty
  
  function view'3 [@inline:trivial] (self: MutBorrow.t t_IterMut'0) : t_FMap'0 = [%#smodel'0] view'2 self.current
  
  meta "rewrite_def" function view'3
  
  predicate completed (self: MutBorrow.t t_IterMut'0) = [%#shash_map'2] resolve'0 self /\ is_empty (view'3 self)
  
  function view'4 (self: t_HashMap'2) : t_FMap'0
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap'2) =
    [%#shash_map'4] forall k: t_DeepModelTy, v: MutBorrow.t t_V. (get'0 (view'4 res) k = C_Some'0 v)
      = (exists i: int, k1: t_K. 0 <= i
        /\ i < Seq.length prod
        /\ deep_model'0 k1 = k
        /\ Seq.get prod i = { _p0 = k1; _p1 = v }
        /\ (forall j: int. i < j /\ j < Seq.length prod -> deep_model'0 (Seq.get prod j)._p0 <> k))
  
  let rec collect (self_: t_IterMut'0) (return' (x: t_HashMap'2)) = any
    [ return''0 (result: t_HashMap'2) ->
    {[%#siter] exists done': MutBorrow.t t_IterMut'0, prod: Seq.seq tuple. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_HashMap'0) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_HashMap'0) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  function view'5 [@inline:trivial] (self: MutBorrow.t t_HashMap'0) : t_FMap = [%#smodel'0] view'0 self.current
  
  meta "rewrite_def" function view'5
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashmap_iter_mut [#"collections.rs" 50 0 52 24] (xs: MutBorrow.t t_HashMap'0)
    (return' (x: t_HashMap'2)) = (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_HashMap'0> {xs'0.current} {MutBorrow.get_id xs'0}
          (fun (_ret: MutBorrow.t t_HashMap'0) -> [ &_6 <- _ret ] [ &xs'0 <- { xs'0 with current = _ret.final } ] s1)
      | s1 = iter_mut {_6} (fun (_ret: t_IterMut'0) -> [ &it <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &it0 <- [%#scollections] it ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {it} (fun (_ret: t_HashMap'2) -> [ &r <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 =
        {[@expl:assertion] [%#scollections'0] exists prod: Seq.seq tuple, it1: MutBorrow.t t_IterMut'0. completed it1
          /\ produces it0 prod it1.current
          /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. (get'0 (view'4 r) k = C_Some'0 v)
            = (exists k1: t_K. deep_model'0 k1 = k /\ contains'1 prod { _p0 = k1; _p1 = v }))}
        s1
      | s1 = [ &_0 <- r ] s2
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = -{resolve'2 xs'0}- s1 | s1 = return''0 {_0} ] ]
    [ & _0: t_HashMap'2 = Any.any_l ()
    | & xs'0: MutBorrow.t t_HashMap'0 = xs
    | & it: t_IterMut'0 = Any.any_l ()
    | & _6: MutBorrow.t t_HashMap'0 = Any.any_l ()
    | & it0: t_IterMut'0 = Any.any_l ()
    | & r: t_HashMap'2 = Any.any_l () ])
    [ return''0 (result: t_HashMap'2) ->
    {[@expl:roundtrip_hashmap_iter_mut ensures #0] [%#scollections'1] forall k: t_DeepModelTy, v: MutBorrow.t t_V. get'0 (view'4 result) k
          = C_Some'0 v -> get (view'5 xs) k = C_Some (v.current) /\ get (view'0 xs.final) k = C_Some (v.final)}
      {[@expl:roundtrip_hashmap_iter_mut ensures #1] [%#scollections'2] forall k: t_DeepModelTy, v: t_V. get (view'5 xs) k
          = C_Some v -> contains'0 (view'4 result) k /\ (index_logic'2 (view'4 result) k).current = v}
      {[@expl:roundtrip_hashmap_iter_mut ensures #2] [%#scollections'3] forall k: t_DeepModelTy, v: t_V. get (view'0 xs.final) k
          = C_Some v -> contains'0 (view'4 result) k /\ (index_logic'2 (view'4 result) k).final = v}
      (! return' {result}) ]
end
module M_collections__roundtrip_hashset_into_iter [#"collections.rs" 66 0 66 90]
  let%span scollections = "collections.rs" 65 10 65 24
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 168 26 169 119
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 365 20 365 71
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 391 29 391 31
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 47 18 47 34
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 107 20 107 38
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 102 8 102 38
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 159 20 159 121
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 111 4 111 49
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 112 27 112 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 115 4 115 34
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 116 4 116 34
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 117 4 117 44
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 119 8 119 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 72 16 79 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 84 11 84 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 85 11 85 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 86 10 86 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 94 4 94 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet = { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0 = { t_HashSet__base: t_HashSet }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_AlignmentEnum =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment = { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout = { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple = { _p0: t_NonNull; _p1: t_Layout; _p2: () }
  
  type t_Option = C_None | C_Some tuple
  
  type t_RawIntoIter = {
    t_RawIntoIter__iter: t_RawIter;
    t_RawIntoIter__allocation: t_Option;
    t_RawIntoIter__marker: () }
  
  type t_IntoIter = { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0 = { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1 = { t_IntoIter__base: t_IntoIter'0 }
  
  type t_DeepModelTy
  
  function view (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  let rec into_iter (self_: t_HashSet'0) (return' (x: t_IntoIter'1)) = any
    [ return''0 (result: t_IntoIter'1) -> {[%#shash_set] view self_ = view'0 result} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (_0: t_IntoIter'1) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1) =
    [%#shash_set'9] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x: t_DeepModelTy. contains (view'0 start) x
        -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view'0 end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view'0 start) (deep_model x) /\ not contains (view'0 end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view'0 end') x
        -> contains (view'0 start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j) -> i = j)
  
  constant concat_contains: () = [%#sseq'1] ()
  
  axiom concat_contains_spec: [%#sseq'0] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_IntoIter'1) (ab: Seq.seq t_T) (b: t_IntoIter'1) (bc: Seq.seq t_T) (c: t_IntoIter'1) : ()
   = [%#shash_set'13] let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_IntoIter'1, ab: Seq.seq t_T, b: t_IntoIter'1, bc: Seq.seq t_T, c: t_IntoIter'1. ([%#shash_set'10] set_produces a ab b)
      -> ([%#shash_set'11] set_produces b bc c) -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1) =
    [%#shash_set'1] set_produces self visited o
  
  function produces_trans (a: t_IntoIter'1) (ab: Seq.seq t_T) (b: t_IntoIter'1) (bc: Seq.seq t_T) (c: t_IntoIter'1) : ()
   = [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_IntoIter'1, ab: Seq.seq t_T, b: t_IntoIter'1, bc: Seq.seq t_T, c: t_IntoIter'1. ([%#shash_set'5] produces a ab b)
      -> ([%#shash_set'6] produces b bc c) -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_IntoIter'1) : () = [%#shash_set'4] ()
  
  axiom produces_refl_spec: forall self: t_IntoIter'1. [%#shash_set'3] produces self (Seq.empty: Seq.seq t_T) self
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_IntoIter'1) : Fset.fset t_DeepModelTy =
    [%#smodel] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  predicate completed (self: MutBorrow.t t_IntoIter'1) = [%#shash_set'0] Fset.is_empty (view'1 self)
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    [%#shash_set'2] forall x: t_DeepModelTy. contains (view res) x
      = (exists x1: t_T. deep_model x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_: t_IntoIter'1) (return' (x: t_HashSet'0)) = any
    [ return''0 (result: t_HashSet'0) ->
    {[%#siter] exists done': MutBorrow.t t_IntoIter'1, prod: Seq.seq t_T. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashset_into_iter [#"collections.rs" 66 0 66 90] (xs: t_HashSet'0) (return' (x: t_HashSet'0)) =
    (! bb0
    [ bb0 = s0 [ s0 = into_iter {xs'0} (fun (_ret: t_IntoIter'1) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = collect {_3} (fun (_ret: t_HashSet'0) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return''0 {_0} ]
    [ & _0: t_HashSet'0 = Any.any_l () | & xs'0: t_HashSet'0 = xs | & _3: t_IntoIter'1 = Any.any_l () ])
    [ return''0 (result: t_HashSet'0) -> {[@expl:roundtrip_hashset_into_iter ensures] [%#scollections] view result
      = view xs}
      (! return' {result}) ]
end
module M_collections__roundtrip_hashset_iter [#"collections.rs" 71 0 71 87]
  let%span scollections = "collections.rs" 70 10 70 24
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 168 26 169 119
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 365 20 365 71
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 391 29 391 31
  let%span smodel = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 22 30 22 46
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 140 20 140 38
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 135 8 135 38
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 159 20 159 121
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 144 4 144 49
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 145 27 145 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 148 4 148 34
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 149 4 149 34
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 150 4 150 44
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 152 8 152 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 72 16 79 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 84 11 84 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 85 11 85 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 86 10 86 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 94 4 94 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet = { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0 = { t_HashSet__base: t_HashSet }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter = { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys = { t_Keys__inner: t_Iter }
  
  type t_Iter'0 = { t_Iter__iter: t_Keys }
  
  type t_Iter'1 = { t_Iter__base: t_Iter'0 }
  
  type t_DeepModelTy
  
  function view (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'0 [@inline:trivial] (self: t_HashSet'0) : Fset.fset t_DeepModelTy = [%#smodel] view self
  
  meta "rewrite_def" function view'0
  
  function view'1 (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  let rec iter (self_: t_HashSet'0) (return' (x: t_Iter'1)) = any
    [ return''0 (result: t_Iter'1) -> {[%#shash_set] view'0 self_ = view'1 result} (! return' {result}) ]
  
  type t_RawTable'0 = { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0 = { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1 = { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'2 = { t_HashSet__base'0: t_HashSet'1 }
  
  predicate resolve [@inline:trivial] (_0: t_Iter'1) = true
  
  meta "rewrite_def" predicate resolve
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = [%#smodel'1] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1) =
    [%#shash_set'9] Fset.cardinal (view'1 start) = Seq.length visited + Fset.cardinal (view'1 end')
    /\ (forall x: t_DeepModelTy. contains (view'1 start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view'1 end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view'1 start) (deep_model'0 x) /\ not contains (view'1 end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view'1 end') x
        -> contains (view'1 start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = [%#sseq'1] ()
  
  axiom concat_contains_spec: [%#sseq'0] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Iter'1) (ab: Seq.seq t_T) (b: t_Iter'1) (bc: Seq.seq t_T) (c: t_Iter'1) : () =
    [%#shash_set'13] let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Iter'1, ab: Seq.seq t_T, b: t_Iter'1, bc: Seq.seq t_T, c: t_Iter'1. ([%#shash_set'10] set_produces a ab b)
      -> ([%#shash_set'11] set_produces b bc c) -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1) = [%#shash_set'1] set_produces self visited o
  
  function produces_trans (a: t_Iter'1) (ab: Seq.seq t_T) (b: t_Iter'1) (bc: Seq.seq t_T) (c: t_Iter'1) : () =
    [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_Iter'1, ab: Seq.seq t_T, b: t_Iter'1, bc: Seq.seq t_T, c: t_Iter'1. ([%#shash_set'5] produces a ab b)
      -> ([%#shash_set'6] produces b bc c) -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Iter'1) : () = [%#shash_set'4] ()
  
  axiom produces_refl_spec: forall self: t_Iter'1. [%#shash_set'3] produces self (Seq.empty: Seq.seq t_T) self
  
  function view'2 [@inline:trivial] (self: MutBorrow.t t_Iter'1) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view'1 self.current
  
  meta "rewrite_def" function view'2
  
  predicate completed (self: MutBorrow.t t_Iter'1) = [%#shash_set'0] Fset.is_empty (view'2 self)
  
  function view'3 (self: t_HashSet'2) : Fset.fset t_DeepModelTy
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'2) =
    [%#shash_set'2] forall x: t_DeepModelTy. contains (view'3 res) x
      = (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_: t_Iter'1) (return' (x: t_HashSet'2)) = any
    [ return''0 (result: t_HashSet'2) ->
    {[%#siter] exists done': MutBorrow.t t_Iter'1, prod: Seq.seq t_T. resolve done'.final
        /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec roundtrip_hashset_iter [#"collections.rs" 71 0 71 87] (xs: t_HashSet'0) (return' (x: t_HashSet'2)) = (! bb0
    [ bb0 = s0 [ s0 = iter {xs'0} (fun (_ret: t_Iter'1) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = collect {_3} (fun (_ret: t_HashSet'2) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return''0 {_0} ]
    [ & _0: t_HashSet'2 = Any.any_l () | & xs'0: t_HashSet'0 = xs | & _3: t_Iter'1 = Any.any_l () ])
    [ return''0 (result: t_HashSet'2) -> {[@expl:roundtrip_hashset_iter ensures] [%#scollections] view'3 result
      = view'0 xs}
      (! return' {result}) ]
end
module M_collections__hashset_intersection [#"collections.rs" 76 0 79 15]
  let%span scollections = "collections.rs" 75 10 75 42
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 116 26 116 47
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 168 26 169 119
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 365 20 365 71
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 391 29 391 31
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 30 30 30 67
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 159 20 159 121
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 189 8 189 58
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 184 8 184 38
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 193 4 193 49
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 27 194 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 34
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 198 4 198 34
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 199 4 199 44
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 201 8 201 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 72 16 79 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 84 11 84 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 85 11 85 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 86 10 86 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 94 4 94 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span scopied = "../../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  let%span scopied'0 = "../../../creusot-contracts/src/std/iter/copied.rs" 40 12 40 104
  let%span scopied'1 = "../../../creusot-contracts/src/std/iter/copied.rs" 47 12 50 74
  let%span scopied'2 = "../../../creusot-contracts/src/std/iter/copied.rs" 22 8 22 28
  let%span scopied'3 = "../../../creusot-contracts/src/std/iter/copied.rs" 55 4 55 49
  let%span scopied'4 = "../../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 34
  let%span scopied'5 = "../../../creusot-contracts/src/std/iter/copied.rs" 60 4 60 34
  let%span scopied'6 = "../../../creusot-contracts/src/std/iter/copied.rs" 61 4 61 44
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet = { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0 = { t_HashSet__base: t_HashSet }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter = { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys = { t_Keys__inner: t_Iter }
  
  type t_Iter'0 = { t_Iter__iter: t_Keys }
  
  type t_Iter'1 = { t_Iter__base: t_Iter'0 }
  
  type t_Intersection = { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_DeepModelTy
  
  function view (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'1 [@inline:trivial] (self: t_HashSet'0) : Fset.fset t_DeepModelTy = [%#smodel] view'0 self
  
  meta "rewrite_def" function view'1
  
  let rec intersection (self_: t_HashSet'0) (other: t_HashSet'0) (return' (x: t_Intersection)) = any
    [ return''0 (result: t_Intersection) -> {[%#shash_set] view result = Fset.inter (view'1 self_) (view'1 other)}
      (! return' {result}) ]
  
  type t_Copied = { t_Copied__it: t_Intersection }
  
  predicate inv (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv x]. inv x = true
  
  predicate inv'0 (_0: t_Intersection)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Intersection [inv'0 x]. inv'0 x = true
  
  function iter (self: t_Copied) : t_Intersection
  
  axiom iter_spec: forall self: t_Copied. [%#scopied] inv self -> inv'0 (iter self)
  
  let rec copied (self_: t_Intersection) (return' (x: t_Copied)) = any
    [ return''0 (result: t_Copied) -> {[%#siter] iter result = self_} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (_0: t_Intersection) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (self: t_Copied) = [%#scopied'2] resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_0: t_Copied) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = [%#smodel'1] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection) =
    [%#shash_set'9] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = [%#sseq'1] ()
  
  axiom concat_contains_spec: [%#sseq'0] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
   = [%#shash_set'13] let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. ([%#shash_set'10] set_produces a ab b)
      -> ([%#shash_set'11] set_produces b bc c) -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection) =
    [%#shash_set'2] set_produces self visited o
  
  function produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
   = [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. ([%#shash_set'5] produces a ab b)
      -> ([%#shash_set'6] produces b bc c) -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Intersection) : () = [%#shash_set'4] ()
  
  axiom produces_refl_spec: forall self: t_Intersection. [%#shash_set'3] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    [%#scopied'1] exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Copied, ab: Seq.seq t_T, b: t_Copied, bc: Seq.seq t_T, c: t_Copied. ([%#scopied'4] produces'0 a ab b)
      -> ([%#scopied'5] produces'0 b bc c) -> ([%#scopied'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self: t_Copied) : ()
  
  axiom produces_refl_spec'0: forall self: t_Copied. [%#scopied'3] produces'0 self (Seq.empty: Seq.seq t_T) self
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Intersection) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  function view'2 [@inline:trivial] (self: MutBorrow.t t_Intersection) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view self.current
  
  meta "rewrite_def" function view'2
  
  predicate completed (self: MutBorrow.t t_Intersection) = [%#shash_set'1] resolve'2 self /\ Fset.is_empty (view'2 self)
  
  predicate completed'0 (self: MutBorrow.t t_Copied) =
    [%#scopied'0] exists inner: MutBorrow.t t_Intersection. inner.current = iter self.current
      /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    [%#shash_set'0] forall x: t_DeepModelTy. contains (view'0 res) x
      = (exists x1: t_T. deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_: t_Copied) (return' (x: t_HashSet'0)) = any
    [ return''0 (result: t_HashSet'0) ->
    {[%#siter'0] exists done': MutBorrow.t t_Copied, prod: Seq.seq t_T. resolve'1 done'.final
        /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashset_intersection [#"collections.rs" 76 0 79 15] (xs: t_HashSet'0) (ys: t_HashSet'0)
    (return' (x: t_HashSet'0)) = (! bb0
    [ bb0 = s0 [ s0 = intersection {xs'0} {ys'0} (fun (_ret: t_Intersection) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret: t_Copied) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret: t_HashSet'0) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return''0 {_0} ]
    [ & _0: t_HashSet'0 = Any.any_l ()
    | & xs'0: t_HashSet'0 = xs
    | & ys'0: t_HashSet'0 = ys
    | & _4: t_Copied = Any.any_l ()
    | & _5: t_Intersection = Any.any_l () ])
    [ return''0 (result: t_HashSet'0) -> {[@expl:hashset_intersection ensures] [%#scollections] view'0 result
      = Fset.inter (view'1 xs) (view'1 ys)}
      (! return' {result}) ]
end
module M_collections__hashset_difference [#"collections.rs" 84 0 87 15]
  let%span scollections = "collections.rs" 83 10 83 40
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 116 26 116 47
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 168 26 169 119
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 365 20 365 71
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 391 29 391 31
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 33 30 33 65
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 159 20 159 121
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 213 8 213 58
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 208 8 208 38
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 217 4 217 49
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 218 27 218 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 221 4 221 34
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 222 4 222 34
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 223 4 223 44
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 225 8 225 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 72 16 79 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 84 11 84 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 85 11 85 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 86 10 86 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 94 4 94 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 39 8 39 26
  let%span scopied = "../../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  let%span scopied'0 = "../../../creusot-contracts/src/std/iter/copied.rs" 40 12 40 104
  let%span scopied'1 = "../../../creusot-contracts/src/std/iter/copied.rs" 47 12 50 74
  let%span scopied'2 = "../../../creusot-contracts/src/std/iter/copied.rs" 22 8 22 28
  let%span scopied'3 = "../../../creusot-contracts/src/std/iter/copied.rs" 55 4 55 49
  let%span scopied'4 = "../../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 34
  let%span scopied'5 = "../../../creusot-contracts/src/std/iter/copied.rs" 60 4 60 34
  let%span scopied'6 = "../../../creusot-contracts/src/std/iter/copied.rs" 61 4 61 44
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState = { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner = {
    t_RawTableInner__bucket_mask: UInt64.t;
    t_RawTableInner__ctrl: t_NonNull;
    t_RawTableInner__growth_left: UInt64.t;
    t_RawTableInner__items: UInt64.t }
  
  type t_RawTable = { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap = { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet = { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0 = { t_HashSet__base: t_HashSet }
  
  type t_BitMask = { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter = { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket = { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange = {
    t_RawIterRange__current_group: t_BitMaskIter;
    t_RawIterRange__data: t_Bucket;
    t_RawIterRange__next_ctrl: Opaque.ptr;
    t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter = { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter = { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys = { t_Keys__inner: t_Iter }
  
  type t_Iter'0 = { t_Iter__iter: t_Keys }
  
  type t_Iter'1 = { t_Iter__base: t_Iter'0 }
  
  type t_Difference = { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_DeepModelTy
  
  function view (self: t_Difference) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'1 [@inline:trivial] (self: t_HashSet'0) : Fset.fset t_DeepModelTy = [%#smodel] view'0 self
  
  meta "rewrite_def" function view'1
  
  let rec difference (self_: t_HashSet'0) (other: t_HashSet'0) (return' (x: t_Difference)) = any
    [ return''0 (result: t_Difference) -> {[%#shash_set] view result = Fset.diff (view'1 self_) (view'1 other)}
      (! return' {result}) ]
  
  type t_Copied = { t_Copied__it: t_Difference }
  
  predicate inv (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv x]. inv x = true
  
  predicate inv'0 (_0: t_Difference)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Difference [inv'0 x]. inv'0 x = true
  
  function iter (self: t_Copied) : t_Difference
  
  axiom iter_spec: forall self: t_Copied. [%#scopied] inv self -> inv'0 (iter self)
  
  let rec copied (self_: t_Difference) (return' (x: t_Copied)) = any
    [ return''0 (result: t_Copied) -> {[%#siter] iter result = self_} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (_0: t_Difference) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (self: t_Copied) = [%#scopied'2] resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_0: t_Copied) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = [%#sfset] Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = [%#smodel'1] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference) =
    [%#shash_set'9] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  constant concat_contains: () = [%#sseq'1] ()
  
  axiom concat_contains_spec: [%#sseq'0] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
   = [%#shash_set'13] let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. ([%#shash_set'10] set_produces a ab b)
      -> ([%#shash_set'11] set_produces b bc c) -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference) =
    [%#shash_set'2] set_produces self visited o
  
  function produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
   = [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec:
    forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. ([%#shash_set'5] produces a ab b)
      -> ([%#shash_set'6] produces b bc c) -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Difference) : () = [%#shash_set'4] ()
  
  axiom produces_refl_spec: forall self: t_Difference. [%#shash_set'3] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    [%#scopied'1] exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Copied, ab: Seq.seq t_T, b: t_Copied, bc: Seq.seq t_T, c: t_Copied. ([%#scopied'4] produces'0 a ab b)
      -> ([%#scopied'5] produces'0 b bc c) -> ([%#scopied'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self: t_Copied) : ()
  
  axiom produces_refl_spec'0: forall self: t_Copied. [%#scopied'3] produces'0 self (Seq.empty: Seq.seq t_T) self
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Difference) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  function view'2 [@inline:trivial] (self: MutBorrow.t t_Difference) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view self.current
  
  meta "rewrite_def" function view'2
  
  predicate completed (self: MutBorrow.t t_Difference) = [%#shash_set'1] resolve'2 self /\ Fset.is_empty (view'2 self)
  
  predicate completed'0 (self: MutBorrow.t t_Copied) =
    [%#scopied'0] exists inner: MutBorrow.t t_Difference. inner.current = iter self.current
      /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    [%#shash_set'0] forall x: t_DeepModelTy. contains (view'0 res) x
      = (exists x1: t_T. deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_: t_Copied) (return' (x: t_HashSet'0)) = any
    [ return''0 (result: t_HashSet'0) ->
    {[%#siter'0] exists done': MutBorrow.t t_Copied, prod: Seq.seq t_T. resolve'1 done'.final
        /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashset_difference [#"collections.rs" 84 0 87 15] (xs: t_HashSet'0) (ys: t_HashSet'0)
    (return' (x: t_HashSet'0)) = (! bb0
    [ bb0 = s0 [ s0 = difference {xs'0} {ys'0} (fun (_ret: t_Difference) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret: t_Copied) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret: t_HashSet'0) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return''0 {_0} ]
    [ & _0: t_HashSet'0 = Any.any_l ()
    | & xs'0: t_HashSet'0 = xs
    | & ys'0: t_HashSet'0 = ys
    | & _4: t_Copied = Any.any_l ()
    | & _5: t_Difference = Any.any_l () ])
    [ return''0 (result: t_HashSet'0) -> {[@expl:hashset_difference ensures] [%#scollections] view'0 result
      = Fset.diff (view'1 xs) (view'1 ys)}
      (! return' {result}) ]
end
