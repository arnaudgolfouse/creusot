module M_fmap__resolves [#"fmap.rs" 5 0 5 33]
  let%span sfmap = "fmap.rs" 7 20 7 21
  let%span sfmap'0 = "fmap.rs" 8 20 8 21
  let%span sfmap'1 = "fmap.rs" 12 21 12 39
  let%span sfmap'2 = "fmap.rs" 13 21 13 39
  let%span sfmap'3 = "fmap.rs" 18 8 18 11
  let%span sfmap'4 = "fmap.rs" 17 18 17 36
  let%span sfmap'5 = "fmap.rs" 16 20 16 81
  let%span sfmap'6 = "fmap.rs" 15 20 15 39
  let%span sfmap'7 = "fmap.rs" 18 8 18 11
  let%span sfmap'8 = "fmap.rs" 19 18 19 19
  let%span sfmap'9 = "fmap.rs" 20 18 20 19
  let%span sfmap'10 = "fmap.rs" 4 10 4 27
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 271 4 271 33
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 437 14 437 49
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/fmap.rs" 438 14 438 40
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/fmap.rs" 567 14 567 29
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/fmap.rs" 604 12 610 115
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/fmap.rs" 590 14 593 5
  let%span sfmap'17 = "../../../creusot-contracts/src/logic/fmap.rs" 114 4 114 18
  let%span sfmap'18 = "../../../creusot-contracts/src/logic/fmap.rs" 70 14 70 46
  let%span sfmap'19 = "../../../creusot-contracts/src/logic/fmap.rs" 71 14 71 88
  let%span sfmap'20 = "../../../creusot-contracts/src/logic/fmap.rs" 94 4 94 26
  let%span sfmap'21 = "../../../creusot-contracts/src/logic/fmap.rs" 620 4 620 49
  let%span sfmap'22 = "../../../creusot-contracts/src/logic/fmap.rs" 624 4 624 34
  let%span sfmap'23 = "../../../creusot-contracts/src/logic/fmap.rs" 625 4 625 34
  let%span sfmap'24 = "../../../creusot-contracts/src/logic/fmap.rs" 626 4 626 44
  let%span sfmap'25 = "../../../creusot-contracts/src/logic/fmap.rs" 110 8 110 27
  let%span sfmap'26 = "../../../creusot-contracts/src/logic/fmap.rs" 62 14 62 25
  let%span sfmap'27 = "../../../creusot-contracts/src/logic/fmap.rs" 616 20 616 36
  let%span sfmap'28 = "../../../creusot-contracts/src/logic/fmap.rs" 736 20 736 34
  let%span sfmap'29 = "../../../creusot-contracts/src/logic/fmap.rs" 176 14 176 39
  let%span sfmap'30 = "../../../creusot-contracts/src/logic/fmap.rs" 179 12 179 35
  let%span sfmap'31 = "../../../creusot-contracts/src/logic/fmap.rs" 53 14 53 31
  let%span sfmap'32 = "../../../creusot-contracts/src/logic/fmap.rs" 54 14 54 43
  let%span sfmap'33 = "../../../creusot-contracts/src/logic/fmap.rs" 723 20 723 90
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 203 14 203 29
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 181 14 181 26
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  let%span ssnapshot = "../../../creusot-contracts/src/snapshot.rs" 68 20 68 27
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 772 8 775 9
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 76 8 76 82
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use seq.Seq
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Option = C_None | C_Some (MutBorrow.t UInt64.t)
  
  function view (self: t_FMap) : Map.map (MutBorrow.t UInt64.t) t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: MutBorrow.t UInt64.t) : t_Option =
    [%#sfmap'20] Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) =
    [%#sfmap'30] forall k: MutBorrow.t UInt64.t. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'29] ext_eq self other = (self = other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'26] len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: [%#sfmap'31] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'32] view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = [%#sfmap'17] ext_eq self empty
  
  let rec new (return' (x: t_FMap)) = any
    [ return''0 (result: t_FMap) -> {[%#sfmap'11] is_empty result} (! return' {result}) ]
  
  let rec into_inner (self: t_FMap) (return' (x: t_FMap)) = any
    [ return''0 (result: t_FMap) -> {[%#sghost] result = self} (! return' {result}) ]
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: MutBorrow.t UInt64.t) = [%#sfmap'25] get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: MutBorrow.t UInt64.t) (v: MutBorrow.t UInt64.t) : t_FMap
  
  axiom insert_spec:
    forall self: t_FMap, k: MutBorrow.t UInt64.t, v: MutBorrow.t UInt64.t. [%#sfmap'18] view (insert self k v)
      = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0:
    forall self: t_FMap, k: MutBorrow.t UInt64.t, v: MutBorrow.t UInt64.t. [%#sfmap'19] len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec insert_ghost (self: MutBorrow.t t_FMap) (key: MutBorrow.t UInt64.t) (value: MutBorrow.t UInt64.t)
    (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#sfmap'12] self.final = insert self.current key value}
      {[%#sfmap'13] result = get self.current key}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t UInt64.t) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: t_Option) =
    [%#soption] match self with
      | C_Some x -> resolve'0 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: t_Option) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  function view'0 (self: t_FMapIter) : t_FMap
  
  let rec into_iter (self: t_FMap) (return' (x: t_FMapIter)) = any
    [ return''0 (result: t_FMapIter) -> {[%#sfmap'14] view'0 result = self} (! return' {result}) ]
  
  type tuple = { _p0: MutBorrow.t UInt64.t; _p1: MutBorrow.t UInt64.t }
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function fin [@inline:trivial] (self: MutBorrow.t UInt64.t) : UInt64.t = [%#ssnapshot] self.final
  
  meta "rewrite_def" function fin
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple
  
  function get'0 (self: Seq.seq tuple) (ix: int) : t_Option'0 = [%#sseq] if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple) (o: t_FMapIter) =
    [%#sfmap'15] (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i)._p0 <> (Seq.get visited j)._p0)
    /\ (forall k: MutBorrow.t UInt64.t, v: MutBorrow.t UInt64.t, i: int. get'0 visited i = C_Some'0 { _p0 = k; _p1 = v }
        -> not contains (view'0 o) k /\ get (view'0 self) k = C_Some v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: MutBorrow.t UInt64.t. (forall i: int. 0 <= i /\ i < Seq.length visited
          -> (Seq.get visited i)._p0 <> k) -> get (view'0 o) k = get (view'0 self) k)
  
  function produces_trans (a: t_FMapIter) (ab: Seq.seq tuple) (b: t_FMapIter) (bc: Seq.seq tuple) (c: t_FMapIter) : ()
  
  axiom produces_trans_spec:
    forall a: t_FMapIter, ab: Seq.seq tuple, b: t_FMapIter, bc: Seq.seq tuple, c: t_FMapIter. ([%#sfmap'22] produces a ab b)
      -> ([%#sfmap'23] produces b bc c) -> ([%#sfmap'24] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_FMapIter) : ()
  
  axiom produces_refl_spec: forall self: t_FMapIter. [%#sfmap'21] produces self (Seq.empty: Seq.seq tuple) self
  
  predicate inv (_0: t_FMapIter)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMapIter [inv x]. inv x = true
  
  predicate inv'0 (_0: Seq.seq tuple)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq tuple [inv'0 x]. inv'0 x = true
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_FMapIter) : t_FMap = [%#smodel] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  predicate completed (self: MutBorrow.t t_FMapIter) = [%#sfmap'27] is_empty (view'1 self)
  
  let rec next (self: MutBorrow.t t_FMapIter) (return' (x: t_Option'0)) = any
    [ return''0 (result: t_Option'0) -> {[%#sfmap'16] match result with
        | C_None'0 -> completed self
        | C_Some'0 {_p0 = k; _p1 = v} -> produces self.current (Seq.singleton { _p0 = k; _p1 = v }) self.final
        /\ view'0 self.current = insert (view'0 self.final) k v
        end}
      (! return' {result}) ]
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_FMapIter) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_FMapIter) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  let rec v_Some (input: t_Option'0) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  predicate resolve'5 (self: t_FMap) =
    [%#sfmap'33] forall k: MutBorrow.t UInt64.t, v: MutBorrow.t UInt64.t. get self k = C_Some v
      -> resolve'0 k /\ resolve'0 v
  
  predicate resolve'6 [@inline:trivial] (_0: t_FMap) = resolve'5 _0
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 (self: t_FMapIter) = [%#sfmap'28] resolve'6 (view'0 self)
  
  predicate resolve'8 [@inline:trivial] (_0: t_FMapIter) = resolve'7 _0
  
  meta "rewrite_def" predicate resolve'8
  
  let rec new'0 (x: UInt64.t) (return' (x'0: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#sghost'0] result = x} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec resolves [#"fmap.rs" 5 0 5 33] (return' (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &k <- [%#sfmap] (0: UInt64.t) ] s1
      | s1 = [ &v <- [%#sfmap'0] (0: UInt64.t) ] s2
      | s2 = new (fun (_ret: t_FMap) -> [ &_6 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = into_inner {_6} (fun (_ret: t_FMap) -> [ &s <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = MutBorrow.borrow_mut <UInt64.t> {k}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &bor_k <- _ret ] [ &k <- _ret.final ] s1)
      | s1 = MutBorrow.borrow_mut <UInt64.t> {v}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &bor_v <- _ret ] [ &v <- _ret.final ] s2)
      | s2 = [ &snap_k <- [%#sfmap'1] bor_k ] s3
      | s3 = bb3 ]
    | bb3 = s0 [ s0 = [ &snap_v <- [%#sfmap'2] bor_v ] s1 | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_mut <t_FMap> {s}
          (fun (_ret: MutBorrow.t t_FMap) -> [ &_14 <- _ret ] [ &s <- _ret.final ] s1)
      | s1 = insert_ghost {_14} {bor_k} {bor_v} (fun (_ret: t_Option) -> [ &_13 <- _ret ] s2)
      | s2 = -{resolve'2 _13}- s3
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = into_iter {s} (fun (_ret: t_FMapIter) -> [ &iter <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &iter_old <- [%#sfmap'3] iter ] s1 | s1 = bb7 ]
    | bb7 = s0 [ s0 = [ &produced <- [%#sfmap'3] Seq.empty: Seq.seq tuple ] s1 | s1 = bb9 ]
    | bb9 = bb9invariant
      [ bb9'0 = {[@expl:loop variant] well_founded_relation variant_old_bb9 (1 - Seq.length produced)} bb9invariant
      | bb9invariant = {[@expl:for invariant] [%#sfmap'3] inv'0 produced}
        {[@expl:for invariant] [%#sfmap'3] inv iter}
        {[@expl:for invariant] [%#sfmap'3] produces iter_old produced iter}
        {[@expl:loop invariant #0] [%#sfmap'6] Seq.length produced <= 1}
        {[@expl:loop invariant #1] [%#sfmap'5] Seq.length produced = 0
        \/ fin snap_k = (1: UInt64.t) /\ fin snap_v = (1: UInt64.t)}
        (! [ &variant_old_bb9 <- [%#sfmap'4] 1 - Seq.length produced ] s0)
        [ s0 = bb10 ]
        [ bb10 = s0
          [ s0 = MutBorrow.borrow_mut <t_FMapIter> {iter}
              (fun (_ret: MutBorrow.t t_FMapIter) -> [ &_34 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_FMapIter> {_34.current} {MutBorrow.get_id _34}
              (fun (_ret: MutBorrow.t t_FMapIter) -> [ &_33 <- _ret ] [ &_34 <- { _34 with current = _ret.final } ] s2)
          | s2 = next {_33} (fun (_ret: t_Option'0) -> [ &_32 <- _ret ] s3)
          | s3 = bb11 ]
        | bb11 = s0
          [ s0 = -{resolve'4 _34}- s1
          | s1 = any [ br0 -> {_32 = C_None'0} (! bb14) | br1 (x0: tuple) -> {_32 = C_Some'0 x0} (! bb15) ] ]
        | bb15 = s0
          [ s0 = v_Some {_32} (fun (r0: tuple) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_37 <- [%#sfmap'7] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb16 ]
        | bb16 = s0
          [ s0 = [ &produced <- _37 ] s1
          | s1 = [ &k2 <- __creusot_proc_iter_elem._p0 ] s2
          | s2 = [ &v2 <- __creusot_proc_iter_elem._p1 ] s3
          | s3 = [ &k2 <- { k2 with current = ([%#sfmap'8] (1: UInt64.t)) } ] s4
          | s4 = -{resolve'0 k2}- s5
          | s5 = [ &v2 <- { v2 with current = ([%#sfmap'9] (1: UInt64.t)) } ] s6
          | s6 = -{resolve'0 v2}- s7
          | s7 = bb9'0 ] ] ]
    | bb14 = s0
      [ s0 = -{resolve'8 iter}- s1
      | s1 = UInt64.add {k} {v} (fun (_ret: UInt64.t) -> [ &_2 <- _ret ] s2)
      | s2 = new'0 {_2} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s3)
      | s3 = bb17 ]
    | bb17 = return''0 {_0} ]
    [ & _0: UInt64.t = Any.any_l ()
    | & _2: UInt64.t = Any.any_l ()
    | & k: UInt64.t = Any.any_l ()
    | & v: UInt64.t = Any.any_l ()
    | & s: t_FMap = Any.any_l ()
    | & _6: t_FMap = Any.any_l ()
    | & bor_k: MutBorrow.t UInt64.t = Any.any_l ()
    | & bor_v: MutBorrow.t UInt64.t = Any.any_l ()
    | & snap_k: MutBorrow.t UInt64.t = Any.any_l ()
    | & snap_v: MutBorrow.t UInt64.t = Any.any_l ()
    | & _13: t_Option = Any.any_l ()
    | & _14: MutBorrow.t t_FMap = Any.any_l ()
    | & iter: t_FMapIter = Any.any_l ()
    | & iter_old: t_FMapIter = Any.any_l ()
    | & produced: Seq.seq tuple = Any.any_l ()
    | & _32: t_Option'0 = Any.any_l ()
    | & _33: MutBorrow.t t_FMapIter = Any.any_l ()
    | & _34: MutBorrow.t t_FMapIter = Any.any_l ()
    | & __creusot_proc_iter_elem: tuple = Any.any_l ()
    | & _37: Seq.seq tuple = Any.any_l ()
    | & k2: MutBorrow.t UInt64.t = Any.any_l ()
    | & v2: MutBorrow.t UInt64.t = Any.any_l ()
    | & variant_old_bb9: int = Any.any_l () ])
    [ return''0 (result: UInt64.t) -> {[@expl:resolves ensures] [%#sfmap'10] result = (2: UInt64.t)}
      (! return' {result}) ]
end
