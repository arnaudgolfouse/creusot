module M_test_array
  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.prelude.Any
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  
  type t_Iter_i32
  
  predicate inv_Iter_i32 (_1: t_Iter_i32)
  
  function view_Iter_i32 (self: t_Iter_i32) : Slice64.slice Int32.t
  
  let rec iter_i32 (self_: Slice64.slice Int32.t) (return (x: t_Iter_i32)) = any
    [ return (result: t_Iter_i32) -> {inv_Iter_i32 result} {view_Iter_i32 result = self_} (! return {result}) ]
  
  type t_Option_ref_i32 = None | Some Int32.t
  
  predicate invariant_ref_Iter_i32 [@inline:trivial] (self: MutBorrow.t t_Iter_i32) =
    inv_Iter_i32 self.current /\ inv_Iter_i32 self.final
  
  meta "rewrite_def" predicate invariant_ref_Iter_i32
  
  predicate inv_ref_Iter_i32 [@inline:trivial] (_1: MutBorrow.t t_Iter_i32) = invariant_ref_Iter_i32 _1
  
  meta "rewrite_def" predicate inv_ref_Iter_i32
  
  function index_slice_i32 [@inline:trivial] (self: Slice64.slice Int32.t) (ix: int) : Int32.t =
    Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_i32
  
  function to_ref_seq_slice_i32 (self: Slice64.slice Int32.t) : Seq.seq Int32.t
  
  axiom to_ref_seq_slice_i32_spec: forall self: Slice64.slice Int32.t. Seq.length (to_ref_seq_slice_i32 self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_i32_spec'0: forall self: Slice64.slice Int32.t. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_i32 self)
        -> Seq.get (to_ref_seq_slice_i32 self) i = index_slice_i32 self i
  
  predicate produces_Iter_i32 (self: t_Iter_i32) (visited: Seq.seq Int32.t) (tl: t_Iter_i32) =
    to_ref_seq_slice_i32 (view_Iter_i32 self) = Seq.(++) visited (to_ref_seq_slice_i32 (view_Iter_i32 tl))
  
  function produces_trans_Iter_i32 (a: t_Iter_i32) (ab: Seq.seq Int32.t) (b: t_Iter_i32) (bc: Seq.seq Int32.t) (c: t_Iter_i32) : ()
   = ()
  
  axiom produces_trans_Iter_i32_spec:
    forall a: t_Iter_i32, ab: Seq.seq Int32.t, b: t_Iter_i32, bc: Seq.seq Int32.t, c: t_Iter_i32. produces_Iter_i32 a ab b
      -> produces_Iter_i32 b bc c -> produces_Iter_i32 a (Seq.(++) ab bc) c
  
  function produces_refl_Iter_i32 (self: t_Iter_i32) : () = ()
  
  axiom produces_refl_Iter_i32_spec: forall self: t_Iter_i32. produces_Iter_i32 self (Seq.empty: Seq.seq Int32.t) self
  
  predicate resolve_ref_Iter_i32 [@inline:trivial] (_1: MutBorrow.t t_Iter_i32) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Iter_i32
  
  predicate completed_Iter_i32 (self: MutBorrow.t t_Iter_i32) =
    resolve_ref_Iter_i32 self /\ Slice64.view (view_Iter_i32 self.current) = (Seq.empty: Seq.seq Int32.t)
  
  let rec next_Iter_i32 (self_: MutBorrow.t t_Iter_i32) (return (x: t_Option_ref_i32)) =
    {[@expl:next 'self_' type invariant] inv_ref_Iter_i32 self_}
    any
    [ return (result: t_Option_ref_i32) -> {match result with
        | None -> completed_Iter_i32 self_
        | Some v -> produces_Iter_i32 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  type tup2_ref_Option_ref_i32_ref_Option_ref_i32 = { f0: t_Option_ref_i32; f1: t_Option_ref_i32 }
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  function deep_model_Option_ref_i32 [@inline:trivial] (self: t_Option_ref_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_ref_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_ref_i32
  
  function deep_model_ref_Option_ref_i32 [@inline:trivial] (self: t_Option_ref_i32) : t_Option_Int =
    deep_model_Option_ref_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_ref_i32
  
  let rec eq_Option_ref_i32 (self_: t_Option_ref_i32) (rhs: t_Option_ref_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_ref_i32 self_ = deep_model_ref_Option_ref_i32 rhs)}
      (! return {result}) ]
  
  predicate resolve_Iter_i32 (_1: t_Iter_i32)
  
  type t_IntoIter_i32
  
  predicate inv_Seq_i32 [@inline:trivial] (_1: Seq.seq Int32.t) = true
  
  meta "rewrite_def" predicate inv_Seq_i32
  
  predicate invariant_array_i32_1 (self: Slice64.array Int32.t) =
    inv_Seq_i32 (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (1: UInt64.t)
  
  predicate inv_array_i32_1 [@inline:trivial] (_1: Slice64.array Int32.t) = invariant_array_i32_1 _1
  
  meta "rewrite_def" predicate inv_array_i32_1
  
  predicate inv_IntoIter_i32 (_1: t_IntoIter_i32)
  
  function view_IntoIter_i32 (self: t_IntoIter_i32) : Seq.seq Int32.t
  
  let rec into_iter_array_i32_1 (self_: Slice64.array Int32.t) (return (x: t_IntoIter_i32)) =
    {[@expl:into_iter 'self_' type invariant] inv_array_i32_1 self_}
    any
    [ return (result: t_IntoIter_i32) -> {inv_IntoIter_i32 result}
      {Slice64.view self_ = view_IntoIter_i32 result}
      (! return {result}) ]
  
  type t_Option_i32 = None'1 | Some'1 Int32.t
  
  predicate invariant_ref_IntoIter_i32 [@inline:trivial] (self: MutBorrow.t t_IntoIter_i32) =
    inv_IntoIter_i32 self.current /\ inv_IntoIter_i32 self.final
  
  meta "rewrite_def" predicate invariant_ref_IntoIter_i32
  
  predicate inv_ref_IntoIter_i32 [@inline:trivial] (_1: MutBorrow.t t_IntoIter_i32) = invariant_ref_IntoIter_i32 _1
  
  meta "rewrite_def" predicate inv_ref_IntoIter_i32
  
  predicate produces_IntoIter_i32 (self: t_IntoIter_i32) (visited: Seq.seq Int32.t) (o: t_IntoIter_i32) =
    view_IntoIter_i32 self = Seq.(++) visited (view_IntoIter_i32 o)
  
  function produces_trans_IntoIter_i32 (a: t_IntoIter_i32) (ab: Seq.seq Int32.t) (b: t_IntoIter_i32) (bc: Seq.seq Int32.t) (c: t_IntoIter_i32) : ()
   = ()
  
  axiom produces_trans_IntoIter_i32_spec:
    forall a: t_IntoIter_i32, ab: Seq.seq Int32.t, b: t_IntoIter_i32, bc: Seq.seq Int32.t, c: t_IntoIter_i32. produces_IntoIter_i32 a ab b
      -> produces_IntoIter_i32 b bc c -> produces_IntoIter_i32 a (Seq.(++) ab bc) c
  
  function produces_refl_IntoIter_i32 (self: t_IntoIter_i32) : () = ()
  
  axiom produces_refl_IntoIter_i32_spec:
    forall self: t_IntoIter_i32. produces_IntoIter_i32 self (Seq.empty: Seq.seq Int32.t) self
  
  predicate resolve_ref_IntoIter_i32 [@inline:trivial] (_1: MutBorrow.t t_IntoIter_i32) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_IntoIter_i32
  
  predicate completed_IntoIter_i32 (self: MutBorrow.t t_IntoIter_i32) =
    resolve_ref_IntoIter_i32 self /\ view_IntoIter_i32 self.current = (Seq.empty: Seq.seq Int32.t)
  
  let rec next_IntoIter_i32 (self_: MutBorrow.t t_IntoIter_i32) (return (x: t_Option_i32)) =
    {[@expl:next 'self_' type invariant] inv_ref_IntoIter_i32 self_}
    any
    [ return (result: t_Option_i32) -> {match result with
        | None'1 -> completed_IntoIter_i32 self_
        | Some'1 v -> produces_IntoIter_i32 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  type tup2_ref_Option_i32_ref_Option_i32 = { f0'0: t_Option_i32; f1'0: t_Option_i32 }
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some'1 t -> Some'0 (deep_model_i32 t)
      | None'1 -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  predicate resolve_IntoIter_i32 (_1: t_IntoIter_i32)
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_array (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0 = (1: Int32.t)
              /\ Seq.get __arr_temp.Slice64.elts 1 = (2: Int32.t) /\ Seq.length __arr_temp.Slice64.elts = 2}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array Int32.t = Any.any_l () | & _1: Slice64.array Int32.t = Any.any_l () ]
        [ _const_ret (_const: Slice64.array Int32.t) -> [ &_121 <- _const ] s1 ]
      | s1 = iter_i32 {_121} (fun (_ret: t_Iter_i32) -> [ &a <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Iter_i32 a}
        MutBorrow.borrow_mut <t_Iter_i32> {a}
          (fun (_ret: MutBorrow.t t_Iter_i32) -> [ &_9 <- _ret ] -{inv_Iter_i32 _ret.final}- [ &a <- _ret.final ] s1)
      | s1 = next_Iter_i32 {_9} (fun (_ret: t_Option_ref_i32) -> [ &_8 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_i32 = Any.any_l () | & _1: t_Option_ref_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_i32) -> [ &_120 <- _const ] s1 ]
      | s1 = [ &_6 <- { f0 = _8; f1 = _120 } ] s2
      | s2 = [ &left_val <- _6.f0 ] s3
      | s3 = [ &right_val <- _6.f1 ] s4
      | s4 = eq_Option_ref_i32 {left_val} {right_val} (fun (_ret: bool) -> [ &_16 <- _ret ] s5)
      | s5 = bb3 ]
    | bb3 = any [ br0 -> {_16 = false} (! bb5) | br1 -> {_16} (! bb4) ]
    | bb4 = s0
      [ s0 = {inv_Iter_i32 a}
        MutBorrow.borrow_mut <t_Iter_i32> {a}
          (fun (_ret: MutBorrow.t t_Iter_i32) -> [ &_32 <- _ret ] -{inv_Iter_i32 _ret.final}- [ &a <- _ret.final ] s1)
      | s1 = next_Iter_i32 {_32} (fun (_ret: t_Option_ref_i32) -> [ &_31 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: Int32.t) ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_i32 = Any.any_l () | & _1: t_Option_ref_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_i32) -> [ &_119 <- _const ] s1 ]
      | s1 = [ &_29 <- { f0 = _31; f1 = _119 } ] s2
      | s2 = [ &left_val'0 <- _29.f0 ] s3
      | s3 = [ &right_val'0 <- _29.f1 ] s4
      | s4 = eq_Option_ref_i32 {left_val'0} {right_val'0} (fun (_ret: bool) -> [ &_39 <- _ret ] s5)
      | s5 = bb7 ]
    | bb7 = any [ br0 -> {_39 = false} (! bb9) | br1 -> {_39} (! bb8) ]
    | bb8 = s0
      [ s0 = {inv_Iter_i32 a}
        MutBorrow.borrow_mut <t_Iter_i32> {a}
          (fun (_ret: MutBorrow.t t_Iter_i32) -> [ &_55 <- _ret ] -{inv_Iter_i32 _ret.final}- [ &a <- _ret.final ] s1)
      | s1 = next_Iter_i32 {_55} (fun (_ret: t_Option_ref_i32) -> [ &_54 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_Iter_i32 a} s1
      | s1 = -{resolve_Iter_i32 a}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_i32 = Any.any_l () | & _1: t_Option_ref_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_i32) -> [ &_118 <- _const ] s3 ]
      | s3 = [ &_52 <- { f0 = _54; f1 = _118 } ] s4
      | s4 = [ &left_val'1 <- _52.f0 ] s5
      | s5 = [ &right_val'1 <- _52.f1 ] s6
      | s6 = eq_Option_ref_i32 {left_val'1} {right_val'1} (fun (_ret: bool) -> [ &_60 <- _ret ] s7)
      | s7 = bb11 ]
    | bb11 = any [ br0 -> {_60 = false} (! bb13) | br1 -> {_60} (! bb12) ]
    | bb12 = s0
      [ s0 = any
        [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0 = (1: Int32.t)
          /\ Seq.length __arr_temp.Slice64.elts = 1}-
          [ &_73 <- __arr_temp ] s1) ]
      | s1 = into_iter_array_i32_1 {_73} (fun (_ret: t_IntoIter_i32) -> [ &b <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {inv_IntoIter_i32 b}
        MutBorrow.borrow_mut <t_IntoIter_i32> {b}
          (fun (_ret: MutBorrow.t t_IntoIter_i32) ->
            [ &_78 <- _ret ] -{inv_IntoIter_i32 _ret.final}-
            [ &b <- _ret.final ] s1)
      | s1 = next_IntoIter_i32 {_78} (fun (_ret: t_Option_i32) -> [ &_77 <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some'1 (1: Int32.t) ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_117 <- _const ] s1 ]
      | s1 = [ &_75 <- { f0'0 = _77; f1'0 = _117 } ] s2
      | s2 = [ &left_val'2 <- _75.f0'0 ] s3
      | s3 = [ &right_val'2 <- _75.f1'0 ] s4
      | s4 = eq_Option_i32 {left_val'2} {right_val'2} (fun (_ret: bool) -> [ &_83 <- _ret ] s5)
      | s5 = bb16 ]
    | bb16 = any [ br0 -> {_83 = false} (! bb18) | br1 -> {_83} (! bb17) ]
    | bb17 = s0
      [ s0 = {inv_IntoIter_i32 b}
        MutBorrow.borrow_mut <t_IntoIter_i32> {b}
          (fun (_ret: MutBorrow.t t_IntoIter_i32) ->
            [ &_99 <- _ret ] -{inv_IntoIter_i32 _ret.final}-
            [ &b <- _ret.final ] s1)
      | s1 = next_IntoIter_i32 {_99} (fun (_ret: t_Option_i32) -> [ &_98 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv_IntoIter_i32 b} s1
      | s1 = -{resolve_IntoIter_i32 b}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None'1 ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_116 <- _const ] s3 ]
      | s3 = [ &_96 <- { f0'0 = _98; f1'0 = _116 } ] s4
      | s4 = [ &left_val'3 <- _96.f0'0 ] s5
      | s5 = [ &right_val'3 <- _96.f1'0 ] s6
      | s6 = eq_Option_i32 {left_val'3} {right_val'3} (fun (_ret: bool) -> [ &_104 <- _ret ] s7)
      | s7 = bb20 ]
    | bb20 = any [ br0 -> {_104 = false} (! bb22) | br1 -> {_104} (! bb23) ]
    | bb23 = return {_0}
    | bb22 = s0
      [ s0 = [ &kind'3 <- Eq ] s1
      | s1 = [ &_112 <- left_val'3 ] s2
      | s2 = [ &_114 <- right_val'3 ] s3
      | s3 = {false} any ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_IntoIter_i32 b} s1
      | s1 = -{resolve_IntoIter_i32 b}- s2
      | s2 = [ &kind'2 <- Eq ] s3
      | s3 = [ &_91 <- left_val'2 ] s4
      | s4 = [ &_93 <- right_val'2 ] s5
      | s5 = {false} any ]
    | bb13 = s0
      [ s0 = [ &kind'1 <- Eq ] s1
      | s1 = [ &_68 <- left_val'1 ] s2
      | s2 = [ &_70 <- right_val'1 ] s3
      | s3 = {false} any ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_Iter_i32 a} s1
      | s1 = -{resolve_Iter_i32 a}- s2
      | s2 = [ &kind'0 <- Eq ] s3
      | s3 = [ &_47 <- left_val'0 ] s4
      | s4 = [ &_49 <- right_val'0 ] s5
      | s5 = {false} any ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_Iter_i32 a} s1
      | s1 = -{resolve_Iter_i32 a}- s2
      | s2 = [ &kind <- Eq ] s3
      | s3 = [ &_24 <- left_val ] s4
      | s4 = [ &_26 <- right_val ] s5
      | s5 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & a: t_Iter_i32 = Any.any_l ()
    | & _6: tup2_ref_Option_ref_i32_ref_Option_ref_i32 = Any.any_l ()
    | & _8: t_Option_ref_i32 = Any.any_l ()
    | & _9: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & left_val: t_Option_ref_i32 = Any.any_l ()
    | & right_val: t_Option_ref_i32 = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _24: t_Option_ref_i32 = Any.any_l ()
    | & _26: t_Option_ref_i32 = Any.any_l ()
    | & _29: tup2_ref_Option_ref_i32_ref_Option_ref_i32 = Any.any_l ()
    | & _31: t_Option_ref_i32 = Any.any_l ()
    | & _32: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & left_val'0: t_Option_ref_i32 = Any.any_l ()
    | & right_val'0: t_Option_ref_i32 = Any.any_l ()
    | & _39: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _47: t_Option_ref_i32 = Any.any_l ()
    | & _49: t_Option_ref_i32 = Any.any_l ()
    | & _52: tup2_ref_Option_ref_i32_ref_Option_ref_i32 = Any.any_l ()
    | & _54: t_Option_ref_i32 = Any.any_l ()
    | & _55: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & left_val'1: t_Option_ref_i32 = Any.any_l ()
    | & right_val'1: t_Option_ref_i32 = Any.any_l ()
    | & _60: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _68: t_Option_ref_i32 = Any.any_l ()
    | & _70: t_Option_ref_i32 = Any.any_l ()
    | & b: t_IntoIter_i32 = Any.any_l ()
    | & _73: Slice64.array Int32.t = Any.any_l ()
    | & _75: tup2_ref_Option_i32_ref_Option_i32 = Any.any_l ()
    | & _77: t_Option_i32 = Any.any_l ()
    | & _78: MutBorrow.t t_IntoIter_i32 = Any.any_l ()
    | & left_val'2: t_Option_i32 = Any.any_l ()
    | & right_val'2: t_Option_i32 = Any.any_l ()
    | & _83: bool = Any.any_l ()
    | & kind'2: t_AssertKind = Any.any_l ()
    | & _91: t_Option_i32 = Any.any_l ()
    | & _93: t_Option_i32 = Any.any_l ()
    | & _96: tup2_ref_Option_i32_ref_Option_i32 = Any.any_l ()
    | & _98: t_Option_i32 = Any.any_l ()
    | & _99: MutBorrow.t t_IntoIter_i32 = Any.any_l ()
    | & left_val'3: t_Option_i32 = Any.any_l ()
    | & right_val'3: t_Option_i32 = Any.any_l ()
    | & _104: bool = Any.any_l ()
    | & kind'3: t_AssertKind = Any.any_l ()
    | & _112: t_Option_i32 = Any.any_l ()
    | & _114: t_Option_i32 = Any.any_l ()
    | & _116: t_Option_i32 = Any.any_l ()
    | & _117: t_Option_i32 = Any.any_l ()
    | & _118: t_Option_ref_i32 = Any.any_l ()
    | & _119: t_Option_ref_i32 = Any.any_l ()
    | & _120: t_Option_ref_i32 = Any.any_l ()
    | & _121: Slice64.array Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
