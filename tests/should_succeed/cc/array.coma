module M_array__test_array [#"array.rs" 3 0 3 19]
  let%span sarray = "array.rs" 4 17 4 18
  let%span sarray'0 = "array.rs" 4 20 4 21
  let%span sarray'1 = "array.rs" 5 31 5 32
  let%span sarray'2 = "array.rs" 6 31 6 32
  let%span sarray'3 = "array.rs" 9 54 9 55
  let%span sarray'4 = "array.rs" 10 30 10 31
  let%span sarray'5 = "../../../creusot-contracts/src/std/array.rs" 102 8 102 9
  let%span sarray'6 = "../../../creusot-contracts/src/std/array.rs" 103 18 103 34
  let%span sarray'7 = "../../../creusot-contracts/src/std/array.rs" 86 8 86 61
  let%span sarray'8 = "../../../creusot-contracts/src/std/array.rs" 81 20 81 47
  let%span sarray'9 = "../../../creusot-contracts/src/std/array.rs" 90 4 90 49
  let%span sarray'10 = "../../../creusot-contracts/src/std/array.rs" 91 27 91 29
  let%span sarray'11 = "../../../creusot-contracts/src/std/array.rs" 94 4 94 34
  let%span sarray'12 = "../../../creusot-contracts/src/std/array.rs" 95 4 95 34
  let%span sarray'13 = "../../../creusot-contracts/src/std/array.rs" 96 4 96 44
  let%span sarray'14 = "../../../creusot-contracts/src/std/array.rs" 97 91 97 93
  let%span sarray'15 = "../../../creusot-contracts/src/std/array.rs" 10 20 10 51
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 319 18 319 33
  let%span sslice'0 = "../../../creusot-contracts/src/std/slice.rs" 445 8 445 65
  let%span sslice'1 = "../../../creusot-contracts/src/std/slice.rs" 451 12 451 66
  let%span sslice'2 = "../../../creusot-contracts/src/std/slice.rs" 456 4 456 49
  let%span sslice'3 = "../../../creusot-contracts/src/std/slice.rs" 457 27 457 29
  let%span sslice'4 = "../../../creusot-contracts/src/std/slice.rs" 460 4 460 34
  let%span sslice'5 = "../../../creusot-contracts/src/std/slice.rs" 461 4 461 34
  let%span sslice'6 = "../../../creusot-contracts/src/std/slice.rs" 462 4 462 44
  let%span sslice'7 = "../../../creusot-contracts/src/std/slice.rs" 463 91 463 93
  let%span sslice'8 = "../../../creusot-contracts/src/std/slice.rs" 90 14 90 41
  let%span sslice'9 = "../../../creusot-contracts/src/std/slice.rs" 91 14 91 76
  let%span sslice'10 = "../../../creusot-contracts/src/std/slice.rs" 54 8 54 31
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 93 26 96 17
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 93 16 93 17
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 24 18 24 67
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 14 8 17 9
  let%span smodel = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span snum = "../../../creusot-contracts/src/std/num.rs" 23 28 23 33
  
  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.prelude.Any
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter = { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  function view (self: t_Iter) : Slice64.slice Int32.t
  
  let rec iter (self_: Slice64.slice Int32.t) (return' (x: t_Iter)) = any
    [ return''0 (result: t_Iter) -> {[%#sslice] view result = self_} (! return' {result}) ]
  
  type t_Option = C_None | C_Some Int32.t
  
  function view'0 (self: Slice64.slice Int32.t) : Seq.seq Int32.t = [%#smodel'1] Slice64.view self
  
  function index_logic [@inline:trivial] (self: Slice64.slice Int32.t) (ix: int) : Int32.t =
    [%#sslice'10] Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice Int32.t) : Seq.seq Int32.t
  
  axiom to_ref_seq_spec: forall self: Slice64.slice Int32.t. [%#sslice'8] Seq.length (to_ref_seq self)
      = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice Int32.t. [%#sslice'9] forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq self) -> Seq.get (to_ref_seq self) i = index_logic self i
  
  predicate produces (self: t_Iter) (visited: Seq.seq Int32.t) (tl: t_Iter) =
    [%#sslice'1] to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  function produces_trans (a: t_Iter) (ab: Seq.seq Int32.t) (b: t_Iter) (bc: Seq.seq Int32.t) (c: t_Iter) : () =
    [%#sslice'7] ()
  
  axiom produces_trans_spec:
    forall a: t_Iter, ab: Seq.seq Int32.t, b: t_Iter, bc: Seq.seq Int32.t, c: t_Iter. ([%#sslice'4] produces a ab b)
      -> ([%#sslice'5] produces b bc c) -> ([%#sslice'6] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Iter) : () = [%#sslice'3] ()
  
  axiom produces_refl_spec: forall self: t_Iter. [%#sslice'2] produces self (Seq.empty: Seq.seq Int32.t) self
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Iter) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  function view'1 (self: MutBorrow.t t_Iter) : Slice64.slice Int32.t = [%#smodel'0] view self.current
  
  predicate completed (self: MutBorrow.t t_Iter) =
    [%#sslice'0] resolve self /\ Slice64.view (view'1 self) = (Seq.empty: Seq.seq Int32.t)
  
  let rec next (self_: MutBorrow.t t_Iter) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#siter] match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  type tuple = { _p0: t_Option; _p1: t_Option }
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: Int32.t) : int = [%#smodel] deep_model self
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#soption'0] match self with
      | C_Some t -> C_Some'0 (deep_model'0 t)
      | C_None -> C_None'0
      end
  
  function deep_model'2 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'1 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption] result = (deep_model'2 self_ = deep_model'2 rhs)} (! return' {result}) ]
  
  type t_IndexRange = { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_ManuallyDrop = { t_ManuallyDrop__value: Int32.t }
  
  type t_MaybeUninit = { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_PolymorphicIter = {
    t_PolymorphicIter__alive: t_IndexRange;
    t_PolymorphicIter__data: Slice64.array t_MaybeUninit }
  
  type t_IntoIter = { t_IntoIter__inner: t_PolymorphicIter }
  
  predicate inv (_0: Seq.seq Int32.t)
  
  axiom inv_axiom [@rewrite]: forall x: Seq.seq Int32.t [inv x]. inv x = true
  
  predicate invariant' (self: Slice64.array Int32.t) =
    [%#sarray'15] inv (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (1: UInt64.t)
  
  predicate inv'0 (_0: Slice64.array Int32.t)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Slice64.array Int32.t [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 (_0: Seq.seq t_MaybeUninit)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_MaybeUninit [inv'1 x]. inv'1 x = true
  
  predicate invariant''0 (self: Slice64.array t_MaybeUninit) =
    [%#sarray'15] inv'1 (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (1: UInt64.t)
  
  predicate inv'2 (_0: Slice64.array t_MaybeUninit)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Slice64.array t_MaybeUninit [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate inv'3 (_0: t_PolymorphicIter)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PolymorphicIter [inv'3 x]. inv'3 x
      = match x with
        | {t_PolymorphicIter__alive = alive; t_PolymorphicIter__data = data} -> inv'2 data
        end
  
  predicate inv'4 (_0: t_IntoIter)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_IntoIter [inv'4 x]. inv'4 x
      = match x with
        | {t_IntoIter__inner = inner} -> inv'3 inner
        end
  
  function view'2 (self: t_IntoIter) : Seq.seq Int32.t
  
  let rec into_iter (self_: Slice64.array Int32.t) (return' (x: t_IntoIter)) =
    {[@expl:into_iter 'self_' type invariant] [%#sarray'5] inv'0 self_}
    any
    [ return''0 (result: t_IntoIter) -> {inv'4 result}
      {[%#sarray'6] Slice64.view self_ = view'2 result}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 Int32.t
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_IntoIter) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'5 (_0: MutBorrow.t t_IntoIter)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_IntoIter [inv'5 x]. inv'5 x = invariant''1 x
  
  predicate produces'0 (self: t_IntoIter) (visited: Seq.seq Int32.t) (o: t_IntoIter) =
    [%#sarray'8] view'2 self = Seq.(++) visited (view'2 o)
  
  function produces_trans'0 (a: t_IntoIter) (ab: Seq.seq Int32.t) (b: t_IntoIter) (bc: Seq.seq Int32.t) (c: t_IntoIter) : ()
   = [%#sarray'14] ()
  
  axiom produces_trans_spec'0:
    forall a: t_IntoIter, ab: Seq.seq Int32.t, b: t_IntoIter, bc: Seq.seq Int32.t, c: t_IntoIter. ([%#sarray'11] produces'0 a ab b)
      -> ([%#sarray'12] produces'0 b bc c) -> ([%#sarray'13] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self: t_IntoIter) : () = [%#sarray'10] ()
  
  axiom produces_refl_spec'0: forall self: t_IntoIter. [%#sarray'9] produces'0 self (Seq.empty: Seq.seq Int32.t) self
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_IntoIter) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  function view'3 (self: MutBorrow.t t_IntoIter) : Seq.seq Int32.t = [%#smodel'0] view'2 self.current
  
  predicate completed'0 (self: MutBorrow.t t_IntoIter) =
    [%#sarray'7] resolve'0 self /\ view'3 self = (Seq.empty: Seq.seq Int32.t)
  
  let rec next'0 (self_: MutBorrow.t t_IntoIter) (return' (x: t_Option'1)) =
    {[@expl:next 'self_' type invariant] [%#siter'0] inv'5 self_}
    any
    [ return''0 (result: t_Option'1) -> {[%#siter] match result with
        | C_None'1 -> completed'0 self_
        | C_Some'1 v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  type tuple'0 = { _p0'0: t_Option'1; _p1'0: t_Option'1 }
  
  function deep_model'3 (self: t_Option'1) : t_Option'0 = [%#soption'0] match self with
      | C_Some'1 t -> C_Some'0 (deep_model t)
      | C_None'1 -> C_None'0
      end
  
  function deep_model'4 (self: t_Option'1) : t_Option'0 = [%#smodel] deep_model'3 self
  
  let rec eq'0 (self_: t_Option'1) (rhs: t_Option'1) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption] result = (deep_model'4 self_ = deep_model'4 rhs)} (! return' {result}) ]
  
  type t_AssertKind = C_Eq | C_Ne | C_Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_array [#"array.rs" 3 0 3 19] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0
                = ([%#sarray] (1: Int32.t))
              /\ Seq.get __arr_temp.Slice64.elts 1 = ([%#sarray'0] (2: Int32.t))
              /\ Seq.length __arr_temp.Slice64.elts = 2}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array Int32.t = Any.any_l () | & _1: Slice64.array Int32.t = Any.any_l () ]
        [ _const_ret (_const: Slice64.array Int32.t) -> [ &_121 <- _const ] s1 ]
      | s1 = iter {_121} (fun (_ret: t_Iter) -> [ &a <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <t_Iter> {a}
          (fun (_ret: MutBorrow.t t_Iter) -> [ &_9 <- _ret ] [ &a <- _ret.final ] s1)
      | s1 = next {_9} (fun (_ret: t_Option) -> [ &_8 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#sarray'1] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_120 <- _const ] s1 ]
      | s1 = [ &_6 <- { _p0 = _8; _p1 = _120 } ] s2
      | s2 = [ &left_val <- _6._p0 ] s3
      | s3 = [ &right_val <- _6._p1 ] s4
      | s4 = eq {left_val} {right_val} (fun (_ret: bool) -> [ &_16 <- _ret ] s5)
      | s5 = bb3 ]
    | bb3 = any [ br0 -> {_16 = false} (! bb5) | br1 -> {_16} (! bb4) ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_mut <t_Iter> {a}
          (fun (_ret: MutBorrow.t t_Iter) -> [ &_32 <- _ret ] [ &a <- _ret.final ] s1)
      | s1 = next {_32} (fun (_ret: t_Option) -> [ &_31 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#sarray'2] (2: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_119 <- _const ] s1 ]
      | s1 = [ &_29 <- { _p0 = _31; _p1 = _119 } ] s2
      | s2 = [ &left_val'0 <- _29._p0 ] s3
      | s3 = [ &right_val'0 <- _29._p1 ] s4
      | s4 = eq {left_val'0} {right_val'0} (fun (_ret: bool) -> [ &_39 <- _ret ] s5)
      | s5 = bb7 ]
    | bb7 = any [ br0 -> {_39 = false} (! bb9) | br1 -> {_39} (! bb8) ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Iter> {a}
          (fun (_ret: MutBorrow.t t_Iter) -> [ &_55 <- _ret ] [ &a <- _ret.final ] s1)
      | s1 = next {_55} (fun (_ret: t_Option) -> [ &_54 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_118 <- _const ] s1 ]
      | s1 = [ &_52 <- { _p0 = _54; _p1 = _118 } ] s2
      | s2 = [ &left_val'1 <- _52._p0 ] s3
      | s3 = [ &right_val'1 <- _52._p1 ] s4
      | s4 = eq {left_val'1} {right_val'1} (fun (_ret: bool) -> [ &_60 <- _ret ] s5)
      | s5 = bb11 ]
    | bb11 = any [ br0 -> {_60 = false} (! bb13) | br1 -> {_60} (! bb12) ]
    | bb12 = s0
      [ s0 = any
        [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0
            = ([%#sarray'3] (1: Int32.t))
          /\ Seq.length __arr_temp.Slice64.elts = 1}-
          [ &_73 <- __arr_temp ] s1) ]
      | s1 = into_iter {_73} (fun (_ret: t_IntoIter) -> [ &b <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {inv'4 b}
        MutBorrow.borrow_mut <t_IntoIter> {b}
          (fun (_ret: MutBorrow.t t_IntoIter) -> [ &_78 <- _ret ] -{inv'4 _ret.final}- [ &b <- _ret.final ] s1)
      | s1 = next'0 {_78} (fun (_ret: t_Option'1) -> [ &_77 <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some'1 ([%#sarray'4] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option'1 = Any.any_l () | & _1: t_Option'1 = Any.any_l () ]
        [ _const_ret (_const: t_Option'1) -> [ &_117 <- _const ] s1 ]
      | s1 = [ &_75 <- { _p0'0 = _77; _p1'0 = _117 } ] s2
      | s2 = [ &left_val'2 <- _75._p0'0 ] s3
      | s3 = [ &right_val'2 <- _75._p1'0 ] s4
      | s4 = eq'0 {left_val'2} {right_val'2} (fun (_ret: bool) -> [ &_83 <- _ret ] s5)
      | s5 = bb16 ]
    | bb16 = any [ br0 -> {_83 = false} (! bb18) | br1 -> {_83} (! bb17) ]
    | bb17 = s0
      [ s0 = {inv'4 b}
        MutBorrow.borrow_mut <t_IntoIter> {b}
          (fun (_ret: MutBorrow.t t_IntoIter) -> [ &_99 <- _ret ] -{inv'4 _ret.final}- [ &b <- _ret.final ] s1)
      | s1 = next'0 {_99} (fun (_ret: t_Option'1) -> [ &_98 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None'1 ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option'1 = Any.any_l () | & _1: t_Option'1 = Any.any_l () ]
        [ _const_ret (_const: t_Option'1) -> [ &_116 <- _const ] s1 ]
      | s1 = [ &_96 <- { _p0'0 = _98; _p1'0 = _116 } ] s2
      | s2 = [ &left_val'3 <- _96._p0'0 ] s3
      | s3 = [ &right_val'3 <- _96._p1'0 ] s4
      | s4 = eq'0 {left_val'3} {right_val'3} (fun (_ret: bool) -> [ &_104 <- _ret ] s5)
      | s5 = bb20 ]
    | bb20 = any [ br0 -> {_104 = false} (! bb22) | br1 -> {_104} (! bb23) ]
    | bb23 = return''0 {_0}
    | bb22 = s0
      [ s0 = [ &kind'3 <- C_Eq ] s1
      | s1 = [ &_112 <- left_val'3 ] s2
      | s2 = [ &_114 <- right_val'3 ] s3
      | s3 = {false} any ]
    | bb18 = s0
      [ s0 = [ &kind'2 <- C_Eq ] s1
      | s1 = [ &_91 <- left_val'2 ] s2
      | s2 = [ &_93 <- right_val'2 ] s3
      | s3 = {false} any ]
    | bb13 = s0
      [ s0 = [ &kind'1 <- C_Eq ] s1
      | s1 = [ &_68 <- left_val'1 ] s2
      | s2 = [ &_70 <- right_val'1 ] s3
      | s3 = {false} any ]
    | bb9 = s0
      [ s0 = [ &kind'0 <- C_Eq ] s1
      | s1 = [ &_47 <- left_val'0 ] s2
      | s2 = [ &_49 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb5 = s0
      [ s0 = [ &kind <- C_Eq ] s1 | s1 = [ &_24 <- left_val ] s2 | s2 = [ &_26 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & a: t_Iter = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _8: t_Option = Any.any_l ()
    | & _9: MutBorrow.t t_Iter = Any.any_l ()
    | & left_val: t_Option = Any.any_l ()
    | & right_val: t_Option = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _24: t_Option = Any.any_l ()
    | & _26: t_Option = Any.any_l ()
    | & _29: tuple = Any.any_l ()
    | & _31: t_Option = Any.any_l ()
    | & _32: MutBorrow.t t_Iter = Any.any_l ()
    | & left_val'0: t_Option = Any.any_l ()
    | & right_val'0: t_Option = Any.any_l ()
    | & _39: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _47: t_Option = Any.any_l ()
    | & _49: t_Option = Any.any_l ()
    | & _52: tuple = Any.any_l ()
    | & _54: t_Option = Any.any_l ()
    | & _55: MutBorrow.t t_Iter = Any.any_l ()
    | & left_val'1: t_Option = Any.any_l ()
    | & right_val'1: t_Option = Any.any_l ()
    | & _60: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _68: t_Option = Any.any_l ()
    | & _70: t_Option = Any.any_l ()
    | & b: t_IntoIter = Any.any_l ()
    | & _73: Slice64.array Int32.t = Any.any_l ()
    | & _75: tuple'0 = Any.any_l ()
    | & _77: t_Option'1 = Any.any_l ()
    | & _78: MutBorrow.t t_IntoIter = Any.any_l ()
    | & left_val'2: t_Option'1 = Any.any_l ()
    | & right_val'2: t_Option'1 = Any.any_l ()
    | & _83: bool = Any.any_l ()
    | & kind'2: t_AssertKind = Any.any_l ()
    | & _91: t_Option'1 = Any.any_l ()
    | & _93: t_Option'1 = Any.any_l ()
    | & _96: tuple'0 = Any.any_l ()
    | & _98: t_Option'1 = Any.any_l ()
    | & _99: MutBorrow.t t_IntoIter = Any.any_l ()
    | & left_val'3: t_Option'1 = Any.any_l ()
    | & right_val'3: t_Option'1 = Any.any_l ()
    | & _104: bool = Any.any_l ()
    | & kind'3: t_AssertKind = Any.any_l ()
    | & _112: t_Option'1 = Any.any_l ()
    | & _114: t_Option'1 = Any.any_l ()
    | & _116: t_Option'1 = Any.any_l ()
    | & _117: t_Option'1 = Any.any_l ()
    | & _118: t_Option = Any.any_l ()
    | & _119: t_Option = Any.any_l ()
    | & _120: t_Option = Any.any_l ()
    | & _121: Slice64.array Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
