module M_test_mut_ref
  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.prelude.Any
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_Iter_i32
  
  predicate inv_Iter_i32 (_1: t_Iter_i32)
  
  function view_Iter_i32 (self: t_Iter_i32) : Slice64.slice Int32.t
  
  let rec iter_i32 (self_: Slice64.slice Int32.t) (return (x: t_Iter_i32)) = any
    [ return (result: t_Iter_i32) -> {inv_Iter_i32 result} {view_Iter_i32 result = self_} (! return {result}) ]
  
  type t_Option_ref_i32 = None | Some Int32.t
  
  predicate invariant_ref_Iter_i32 [@inline:trivial] (self: MutBorrow.t t_Iter_i32) =
    inv_Iter_i32 self.current /\ inv_Iter_i32 self.final
  
  meta "rewrite_def" predicate invariant_ref_Iter_i32
  
  predicate inv_ref_Iter_i32 [@inline:trivial] (_1: MutBorrow.t t_Iter_i32) = invariant_ref_Iter_i32 _1
  
  meta "rewrite_def" predicate inv_ref_Iter_i32
  
  function index_slice_i32 [@inline:trivial] (self: Slice64.slice Int32.t) (ix: int) : Int32.t =
    Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_i32
  
  function to_ref_seq_slice_i32 (self: Slice64.slice Int32.t) : Seq.seq Int32.t
  
  axiom to_ref_seq_slice_i32_spec: forall self: Slice64.slice Int32.t. Seq.length (to_ref_seq_slice_i32 self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_i32_spec'0: forall self: Slice64.slice Int32.t. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_i32 self)
        -> Seq.get (to_ref_seq_slice_i32 self) i = index_slice_i32 self i
  
  predicate produces_Iter_i32 (self: t_Iter_i32) (visited: Seq.seq Int32.t) (tl: t_Iter_i32) =
    to_ref_seq_slice_i32 (view_Iter_i32 self) = Seq.(++) visited (to_ref_seq_slice_i32 (view_Iter_i32 tl))
  
  function produces_trans_Iter_i32 (a: t_Iter_i32) (ab: Seq.seq Int32.t) (b: t_Iter_i32) (bc: Seq.seq Int32.t) (c: t_Iter_i32) : ()
   = ()
  
  axiom produces_trans_Iter_i32_spec:
    forall a: t_Iter_i32, ab: Seq.seq Int32.t, b: t_Iter_i32, bc: Seq.seq Int32.t, c: t_Iter_i32. produces_Iter_i32 a ab b
      -> produces_Iter_i32 b bc c -> produces_Iter_i32 a (Seq.(++) ab bc) c
  
  function produces_refl_Iter_i32 (self: t_Iter_i32) : () = ()
  
  axiom produces_refl_Iter_i32_spec: forall self: t_Iter_i32. produces_Iter_i32 self (Seq.empty: Seq.seq Int32.t) self
  
  predicate resolve_ref_Iter_i32 [@inline:trivial] (_1: MutBorrow.t t_Iter_i32) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Iter_i32
  
  predicate completed_Iter_i32 (self: MutBorrow.t t_Iter_i32) =
    resolve_ref_Iter_i32 self /\ Slice64.view (view_Iter_i32 self.current) = (Seq.empty: Seq.seq Int32.t)
  
  let rec next_Iter_i32 (self_: MutBorrow.t t_Iter_i32) (return (x: t_Option_ref_i32)) =
    {[@expl:next 'self_' type invariant] inv_ref_Iter_i32 self_}
    any
    [ return (result: t_Option_ref_i32) -> {match result with
        | None -> completed_Iter_i32 self_
        | Some v -> produces_Iter_i32 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  type tup2_ref_Option_ref_i32_ref_Option_ref_i32 = { f0: t_Option_ref_i32; f1: t_Option_ref_i32 }
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  function deep_model_Option_ref_i32 [@inline:trivial] (self: t_Option_ref_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_ref_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_ref_i32
  
  function deep_model_ref_Option_ref_i32 [@inline:trivial] (self: t_Option_ref_i32) : t_Option_Int =
    deep_model_Option_ref_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_ref_i32
  
  let rec eq_Option_ref_i32 (self_: t_Option_ref_i32) (rhs: t_Option_ref_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_ref_i32 self_ = deep_model_ref_Option_ref_i32 rhs)}
      (! return {result}) ]
  
  predicate resolve_Iter_i32 (_1: t_Iter_i32)
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mut_ref (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0 = (1: Int32.t)
              /\ Seq.get __arr_temp.Slice64.elts 1 = (2: Int32.t) /\ Seq.length __arr_temp.Slice64.elts = 2}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array Int32.t = Any.any_l () | & _1: Slice64.array Int32.t = Any.any_l () ]
        [ _const_ret (_const: Slice64.array Int32.t) -> [ &_78 <- _const ] s1 ]
      | s1 = iter_i32 {_78} (fun (_ret: t_Iter_i32) -> [ &a <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Iter_i32 a}
        MutBorrow.borrow_mut <t_Iter_i32> {a}
          (fun (_ret: MutBorrow.t t_Iter_i32) -> [ &_10 <- _ret ] -{inv_Iter_i32 _ret.final}- [ &a <- _ret.final ] s1)
      | s1 = {inv_Iter_i32 _10.current}
        MutBorrow.borrow_final <t_Iter_i32> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret: MutBorrow.t t_Iter_i32) ->
            [ &_9 <- _ret ] -{inv_Iter_i32 _ret.final}-
            [ &_10 <- { _10 with current = _ret.final } ] s2)
      | s2 = next_Iter_i32 {_9} (fun (_ret: t_Option_ref_i32) -> [ &_8 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Iter_i32 _10} s1
      | s1 = -{resolve_ref_Iter_i32 _10}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_i32 = Any.any_l () | & _1: t_Option_ref_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_i32) -> [ &_77 <- _const ] s3 ]
      | s3 = [ &_6 <- { f0 = _8; f1 = _77 } ] s4
      | s4 = [ &left_val <- _6.f0 ] s5
      | s5 = [ &right_val <- _6.f1 ] s6
      | s6 = eq_Option_ref_i32 {left_val} {right_val} (fun (_ret: bool) -> [ &_17 <- _ret ] s7)
      | s7 = bb3 ]
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb4) ]
    | bb4 = s0
      [ s0 = {inv_Iter_i32 a}
        MutBorrow.borrow_mut <t_Iter_i32> {a}
          (fun (_ret: MutBorrow.t t_Iter_i32) -> [ &_34 <- _ret ] -{inv_Iter_i32 _ret.final}- [ &a <- _ret.final ] s1)
      | s1 = {inv_Iter_i32 _34.current}
        MutBorrow.borrow_final <t_Iter_i32> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret: MutBorrow.t t_Iter_i32) ->
            [ &_33 <- _ret ] -{inv_Iter_i32 _ret.final}-
            [ &_34 <- { _34 with current = _ret.final } ] s2)
      | s2 = next_Iter_i32 {_33} (fun (_ret: t_Option_ref_i32) -> [ &_32 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Iter_i32 _34} s1
      | s1 = -{resolve_ref_Iter_i32 _34}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: Int32.t) ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_i32 = Any.any_l () | & _1: t_Option_ref_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_i32) -> [ &_76 <- _const ] s3 ]
      | s3 = [ &_30 <- { f0 = _32; f1 = _76 } ] s4
      | s4 = [ &left_val'0 <- _30.f0 ] s5
      | s5 = [ &right_val'0 <- _30.f1 ] s6
      | s6 = eq_Option_ref_i32 {left_val'0} {right_val'0} (fun (_ret: bool) -> [ &_41 <- _ret ] s7)
      | s7 = bb7 ]
    | bb7 = any [ br0 -> {_41 = false} (! bb9) | br1 -> {_41} (! bb8) ]
    | bb8 = s0
      [ s0 = {inv_Iter_i32 a}
        MutBorrow.borrow_mut <t_Iter_i32> {a}
          (fun (_ret: MutBorrow.t t_Iter_i32) -> [ &_58 <- _ret ] -{inv_Iter_i32 _ret.final}- [ &a <- _ret.final ] s1)
      | s1 = {inv_Iter_i32 _58.current}
        MutBorrow.borrow_final <t_Iter_i32> {_58.current} {MutBorrow.get_id _58}
          (fun (_ret: MutBorrow.t t_Iter_i32) ->
            [ &_57 <- _ret ] -{inv_Iter_i32 _ret.final}-
            [ &_58 <- { _58 with current = _ret.final } ] s2)
      | s2 = next_Iter_i32 {_57} (fun (_ret: t_Option_ref_i32) -> [ &_56 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Iter_i32 _58} s1
      | s1 = -{resolve_ref_Iter_i32 _58}- s2
      | s2 = {[@expl:type invariant] inv_Iter_i32 a} s3
      | s3 = -{resolve_Iter_i32 a}- s4
      | s4 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_i32 = Any.any_l () | & _1: t_Option_ref_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_i32) -> [ &_75 <- _const ] s5 ]
      | s5 = [ &_54 <- { f0 = _56; f1 = _75 } ] s6
      | s6 = [ &left_val'1 <- _54.f0 ] s7
      | s7 = [ &right_val'1 <- _54.f1 ] s8
      | s8 = eq_Option_ref_i32 {left_val'1} {right_val'1} (fun (_ret: bool) -> [ &_63 <- _ret ] s9)
      | s9 = bb11 ]
    | bb11 = any [ br0 -> {_63 = false} (! bb13) | br1 -> {_63} (! bb12) ]
    | bb12 = return {_0}
    | bb13 = s0
      [ s0 = [ &kind'1 <- Eq ] s1
      | s1 = [ &_71 <- left_val'1 ] s2
      | s2 = [ &_73 <- right_val'1 ] s3
      | s3 = {false} any ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_Iter_i32 a} s1
      | s1 = -{resolve_Iter_i32 a}- s2
      | s2 = [ &kind'0 <- Eq ] s3
      | s3 = [ &_49 <- left_val'0 ] s4
      | s4 = [ &_51 <- right_val'0 ] s5
      | s5 = {false} any ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_Iter_i32 a} s1
      | s1 = -{resolve_Iter_i32 a}- s2
      | s2 = [ &kind <- Eq ] s3
      | s3 = [ &_25 <- left_val ] s4
      | s4 = [ &_27 <- right_val ] s5
      | s5 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & a: t_Iter_i32 = Any.any_l ()
    | & _6: tup2_ref_Option_ref_i32_ref_Option_ref_i32 = Any.any_l ()
    | & _8: t_Option_ref_i32 = Any.any_l ()
    | & _9: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & _10: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & left_val: t_Option_ref_i32 = Any.any_l ()
    | & right_val: t_Option_ref_i32 = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _25: t_Option_ref_i32 = Any.any_l ()
    | & _27: t_Option_ref_i32 = Any.any_l ()
    | & _30: tup2_ref_Option_ref_i32_ref_Option_ref_i32 = Any.any_l ()
    | & _32: t_Option_ref_i32 = Any.any_l ()
    | & _33: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & _34: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & left_val'0: t_Option_ref_i32 = Any.any_l ()
    | & right_val'0: t_Option_ref_i32 = Any.any_l ()
    | & _41: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _49: t_Option_ref_i32 = Any.any_l ()
    | & _51: t_Option_ref_i32 = Any.any_l ()
    | & _54: tup2_ref_Option_ref_i32_ref_Option_ref_i32 = Any.any_l ()
    | & _56: t_Option_ref_i32 = Any.any_l ()
    | & _57: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & _58: MutBorrow.t t_Iter_i32 = Any.any_l ()
    | & left_val'1: t_Option_ref_i32 = Any.any_l ()
    | & right_val'1: t_Option_ref_i32 = Any.any_l ()
    | & _63: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _71: t_Option_ref_i32 = Any.any_l ()
    | & _73: t_Option_ref_i32 = Any.any_l ()
    | & _75: t_Option_ref_i32 = Any.any_l ()
    | & _76: t_Option_ref_i32 = Any.any_l ()
    | & _77: t_Option_ref_i32 = Any.any_l ()
    | & _78: Slice64.array Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_filter
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter_bool
  
  predicate inv_Iter_bool (_1: t_Iter_bool)
  
  function view_Iter_bool (self: t_Iter_bool) : Slice64.slice bool
  
  let rec iter_bool (self_: Slice64.slice bool) (return (x: t_Iter_bool)) = any
    [ return (result: t_Iter_bool) -> {inv_Iter_bool result} {view_Iter_bool result = self_} (! return {result}) ]
  
  predicate resolve_ref_closure0 [@inline:trivial] (_1: MutBorrow.t ()) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let b = args in result = b
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  predicate resolve_closure0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_closure0
  
  predicate hist_inv_closure0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_closure0
  
  predicate postcondition_mut_closure0 [@inline:trivial] (self: ()) (args: bool) (result_state: ()) (result: bool) =
    let b = args in result = b /\ hist_inv_closure0 self result_state
  
  meta "rewrite_def" predicate postcondition_mut_closure0
  
  function fn_mut_once_closure0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_mut_once_closure0_spec: forall self: (), args: bool, res: bool. postcondition_once_closure0 self args res
      = (exists res_state: (). postcondition_mut_closure0 self args res_state res /\ resolve_closure0 res_state)
  
  function hist_inv_trans_closure0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_closure0_spec: forall self: (), b: (), c: (). hist_inv_closure0 self b
      -> hist_inv_closure0 b c -> hist_inv_closure0 self c
  
  function hist_inv_refl_closure0 (self: ()) : ()
  
  axiom hist_inv_refl_closure0_spec: forall self: (). hist_inv_closure0 self self
  
  function postcondition_mut_hist_inv_closure0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_closure0_spec:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut_closure0 self args res_state res
      -> hist_inv_closure0 self res_state
  
  let rec closure0 (self: MutBorrow.t ()) (b: bool) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = -{resolve_ref_closure0 self}- s1 | s1 = [ &res <- b ] s2 | s2 = [ &_0 <- res ] s3 | s3 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self: MutBorrow.t () = self | & b: bool = b | & res: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:closure ensures] result = b}
      {[@expl:closure hist_inv post] hist_inv_closure0 self.current self.final}
      (! return {result}) ]
  
  type t_Filter_Iter_bool_closure0
  
  predicate immutable_ref_ref_bool (_1: ()) = forall f: (), g: (). hist_inv_closure0 f g -> f = g
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: bool) = let b = args in true
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate no_precondition_ref_ref_bool (_1: ()) = forall f: (), i: bool. precondition_closure0 f i
  
  predicate precise_ref_ref_bool (_1: ()) =
    forall f1: (), f2: (), i: bool. not (postcondition_mut_closure0 f1 i f2 true
      /\ postcondition_mut_closure0 f1 i f2 false)
  
  function iter_Filter_Iter_bool_closure0 (self: t_Filter_Iter_bool_closure0) : t_Iter_bool
  
  predicate inv_closure0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate inv_closure0
  
  function func_Filter_Iter_bool_closure0 (self: t_Filter_Iter_bool_closure0) : ()
  
  predicate private_invariant_Iter_bool (f: t_Filter_Iter_bool_closure0)
  
  predicate invariant_Filter_Iter_bool_closure0 [@inline:trivial] (self: t_Filter_Iter_bool_closure0) =
    inv_Iter_bool (iter_Filter_Iter_bool_closure0 self)
    /\ inv_closure0 (func_Filter_Iter_bool_closure0 self) /\ private_invariant_Iter_bool self
  
  meta "rewrite_def" predicate invariant_Filter_Iter_bool_closure0
  
  axiom invariant_Filter_Iter_bool_closure0_spec:
    forall self: t_Filter_Iter_bool_closure0. invariant_Filter_Iter_bool_closure0 self
      -> inv_Iter_bool (iter_Filter_Iter_bool_closure0 self) /\ inv_closure0 (func_Filter_Iter_bool_closure0 self)
  
  predicate inv_Filter_Iter_bool_closure0 (_1: t_Filter_Iter_bool_closure0)
  
  axiom inv_axiom:
    forall x: t_Filter_Iter_bool_closure0 [inv_Filter_Iter_bool_closure0 x]. inv_Filter_Iter_bool_closure0 x
      -> invariant_Filter_Iter_bool_closure0 x
  
  let rec filter_Iter_bool (self_: t_Iter_bool) (f: ()) (return (x: t_Filter_Iter_bool_closure0)) =
    {[@expl:filter 'self_' type invariant] inv_Iter_bool self_}
    {[@expl:filter requires #0] immutable_ref_ref_bool f}
    {[@expl:filter requires #1] no_precondition_ref_ref_bool f}
    {[@expl:filter requires #2] precise_ref_ref_bool f}
    any
    [ return (result: t_Filter_Iter_bool_closure0) -> {inv_Filter_Iter_bool_closure0 result}
      {iter_Filter_Iter_bool_closure0 result = self_ /\ func_Filter_Iter_bool_closure0 result = f}
      (! return {result}) ]
  
  type t_Option_ref_bool = None | Some bool
  
  predicate invariant_ref_Filter_Iter_bool_closure0 [@inline:trivial] (self: MutBorrow.t t_Filter_Iter_bool_closure0) =
    inv_Filter_Iter_bool_closure0 self.current /\ inv_Filter_Iter_bool_closure0 self.final
  
  meta "rewrite_def" predicate invariant_ref_Filter_Iter_bool_closure0
  
  predicate inv_ref_Filter_Iter_bool_closure0 [@inline:trivial] (_1: MutBorrow.t t_Filter_Iter_bool_closure0) =
    invariant_ref_Filter_Iter_bool_closure0 _1
  
  meta "rewrite_def" predicate inv_ref_Filter_Iter_bool_closure0
  
  predicate index_slice_bool [@inline:trivial] (self: Slice64.slice bool) (ix: int) = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" predicate index_slice_bool
  
  function to_ref_seq_slice_bool (self: Slice64.slice bool) : Seq.seq bool
  
  axiom to_ref_seq_slice_bool_spec: forall self: Slice64.slice bool. Seq.length (to_ref_seq_slice_bool self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_bool_spec'0: forall self: Slice64.slice bool. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_bool self)
        -> Seq.get (to_ref_seq_slice_bool self) i = index_slice_bool self i
  
  predicate produces_Iter_bool (self: t_Iter_bool) (visited: Seq.seq bool) (tl: t_Iter_bool) =
    to_ref_seq_slice_bool (view_Iter_bool self) = Seq.(++) visited (to_ref_seq_slice_bool (view_Iter_bool tl))
  
  function produces_trans_Iter_bool (a: t_Iter_bool) (ab: Seq.seq bool) (b: t_Iter_bool) (bc: Seq.seq bool) (c: t_Iter_bool) : ()
   = ()
  
  axiom produces_trans_Iter_bool_spec:
    forall a: t_Iter_bool, ab: Seq.seq bool, b: t_Iter_bool, bc: Seq.seq bool, c: t_Iter_bool. produces_Iter_bool a ab b
      -> produces_Iter_bool b bc c -> produces_Iter_bool a (Seq.(++) ab bc) c
  
  function produces_refl_Iter_bool (self: t_Iter_bool) : () = ()
  
  axiom produces_refl_Iter_bool_spec: forall self: t_Iter_bool. produces_Iter_bool self (Seq.empty: Seq.seq bool) self
  
  predicate produces_Filter_Iter_bool_closure0 (self: t_Filter_Iter_bool_closure0) (visited: Seq.seq bool) (succ: t_Filter_Iter_bool_closure0) =
    private_invariant_Iter_bool self
    -> hist_inv_closure0 (func_Filter_Iter_bool_closure0 self) (func_Filter_Iter_bool_closure0 succ)
    /\ (exists s: Seq.seq bool, f: Map.map int int. produces_Iter_bool (iter_Filter_Iter_bool_closure0 self) s (iter_Filter_Iter_bool_closure0 succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_closure0 (func_Filter_Iter_bool_closure0 self) (Seq.get s i) (func_Filter_Iter_bool_closure0 self) true))
  
  function produces_trans_Filter_Iter_bool_closure0 (a: t_Filter_Iter_bool_closure0) (ab: Seq.seq bool) (b: t_Filter_Iter_bool_closure0) (bc: Seq.seq bool) (c: t_Filter_Iter_bool_closure0) : ()
  
  axiom produces_trans_Filter_Iter_bool_closure0_spec:
    forall a: t_Filter_Iter_bool_closure0, ab: Seq.seq bool, b: t_Filter_Iter_bool_closure0, bc: Seq.seq bool, c: t_Filter_Iter_bool_closure0. produces_Filter_Iter_bool_closure0 a ab b
      -> produces_Filter_Iter_bool_closure0 b bc c -> produces_Filter_Iter_bool_closure0 a (Seq.(++) ab bc) c
  
  function produces_refl_Filter_Iter_bool_closure0 (self: t_Filter_Iter_bool_closure0) : ()
  
  axiom produces_refl_Filter_Iter_bool_closure0_spec:
    forall self: t_Filter_Iter_bool_closure0. produces_Filter_Iter_bool_closure0 self (Seq.empty: Seq.seq bool) self
  
  predicate resolve_ref_Iter_bool [@inline:trivial] (_1: MutBorrow.t t_Iter_bool) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Iter_bool
  
  predicate completed_Iter_bool (self: MutBorrow.t t_Iter_bool) =
    resolve_ref_Iter_bool self /\ Slice64.view (view_Iter_bool self.current) = (Seq.empty: Seq.seq bool)
  
  predicate completed_Filter_Iter_bool_closure0 (self: MutBorrow.t t_Filter_Iter_bool_closure0) =
    (exists s: Seq.seq bool, e: MutBorrow.t t_Iter_bool. produces_Iter_bool (iter_Filter_Iter_bool_closure0 self.current) s e.current
        /\ completed_Iter_bool e
        /\ (forall i: int. 0 <= i /\ i < Seq.length s
          -> postcondition_mut_closure0 (func_Filter_Iter_bool_closure0 self.current) (Seq.get s i) (func_Filter_Iter_bool_closure0 self.final) false))
    /\ func_Filter_Iter_bool_closure0 self.current = func_Filter_Iter_bool_closure0 self.final
  
  let rec next_Filter_Iter_bool_closure0 (self_: MutBorrow.t t_Filter_Iter_bool_closure0)
    (return (x: t_Option_ref_bool)) = {[@expl:next 'self_' type invariant] inv_ref_Filter_Iter_bool_closure0 self_}
    any
    [ return (result: t_Option_ref_bool) -> {match result with
        | None -> completed_Filter_Iter_bool_closure0 self_
        | Some v -> produces_Filter_Iter_bool_closure0 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve_ref_Filter_Iter_bool_closure0 [@inline:trivial] (_1: MutBorrow.t t_Filter_Iter_bool_closure0) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Filter_Iter_bool_closure0
  
  type tup2_ref_Option_ref_bool_ref_Option_ref_bool = { f0: t_Option_ref_bool; f1: t_Option_ref_bool }
  
  type t_Option_bool = None'0 | Some'0 bool
  
  predicate deep_model_bool [@inline:trivial] (self: bool) = self
  
  meta "rewrite_def" predicate deep_model_bool
  
  predicate deep_model_ref_bool [@inline:trivial] (self: bool) = deep_model_bool self
  
  meta "rewrite_def" predicate deep_model_ref_bool
  
  function deep_model_Option_ref_bool [@inline:trivial] (self: t_Option_ref_bool) : t_Option_bool = match self with
      | Some t -> Some'0 (deep_model_ref_bool t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_ref_bool
  
  function deep_model_ref_Option_ref_bool [@inline:trivial] (self: t_Option_ref_bool) : t_Option_bool =
    deep_model_Option_ref_bool self
  
  meta "rewrite_def" function deep_model_ref_Option_ref_bool
  
  let rec eq_Option_ref_bool (self_: t_Option_ref_bool) (rhs: t_Option_ref_bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_ref_bool self_ = deep_model_ref_Option_ref_bool rhs)}
      (! return {result}) ]
  
  predicate resolve_Filter_Iter_bool_closure0 (_1: t_Filter_Iter_bool_closure0)
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_filter (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array bool) -> (! -{Seq.get __arr_temp.Slice64.elts 0
              /\ Seq.get __arr_temp.Slice64.elts 1 = false
              /\ Seq.get __arr_temp.Slice64.elts 2 /\ Seq.length __arr_temp.Slice64.elts = 3}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array bool = Any.any_l () | & _1: Slice64.array bool = Any.any_l () ]
        [ _const_ret (_const: Slice64.array bool) -> [ &_80 <- _const ] s1 ]
      | s1 = iter_bool {_80} (fun (_ret: t_Iter_bool) -> [ &_2 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_6 <- () ] s1
      | s1 = filter_Iter_bool {_2} {_6} (fun (_ret: t_Filter_Iter_bool_closure0) -> [ &a <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_Filter_Iter_bool_closure0 a}
        MutBorrow.borrow_mut <t_Filter_Iter_bool_closure0> {a}
          (fun (_ret: MutBorrow.t t_Filter_Iter_bool_closure0) ->
            [ &_12 <- _ret ] -{inv_Filter_Iter_bool_closure0 _ret.final}-
            [ &a <- _ret.final ] s1)
      | s1 = {inv_Filter_Iter_bool_closure0 _12.current}
        MutBorrow.borrow_final <t_Filter_Iter_bool_closure0> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t t_Filter_Iter_bool_closure0) ->
            [ &_11 <- _ret ] -{inv_Filter_Iter_bool_closure0 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = next_Filter_Iter_bool_closure0 {_11} (fun (_ret: t_Option_ref_bool) -> [ &_10 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Filter_Iter_bool_closure0 _12} s1
      | s1 = -{resolve_ref_Filter_Iter_bool_closure0 _12}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- Some true ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_bool = Any.any_l () | & _1: t_Option_ref_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_bool) -> [ &_79 <- _const ] s3 ]
      | s3 = [ &_8 <- { f0 = _10; f1 = _79 } ] s4
      | s4 = [ &left_val <- _8.f0 ] s5
      | s5 = [ &right_val <- _8.f1 ] s6
      | s6 = eq_Option_ref_bool {left_val} {right_val} (fun (_ret: bool) -> [ &_19 <- _ret ] s7)
      | s7 = bb4 ]
    | bb4 = any [ br0 -> {_19 = false} (! bb6) | br1 -> {_19} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv_Filter_Iter_bool_closure0 a}
        MutBorrow.borrow_mut <t_Filter_Iter_bool_closure0> {a}
          (fun (_ret: MutBorrow.t t_Filter_Iter_bool_closure0) ->
            [ &_36 <- _ret ] -{inv_Filter_Iter_bool_closure0 _ret.final}-
            [ &a <- _ret.final ] s1)
      | s1 = {inv_Filter_Iter_bool_closure0 _36.current}
        MutBorrow.borrow_final <t_Filter_Iter_bool_closure0> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret: MutBorrow.t t_Filter_Iter_bool_closure0) ->
            [ &_35 <- _ret ] -{inv_Filter_Iter_bool_closure0 _ret.final}-
            [ &_36 <- { _36 with current = _ret.final } ] s2)
      | s2 = next_Filter_Iter_bool_closure0 {_35} (fun (_ret: t_Option_ref_bool) -> [ &_34 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Filter_Iter_bool_closure0 _36} s1
      | s1 = -{resolve_ref_Filter_Iter_bool_closure0 _36}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- Some true ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_bool = Any.any_l () | & _1: t_Option_ref_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_bool) -> [ &_78 <- _const ] s3 ]
      | s3 = [ &_32 <- { f0 = _34; f1 = _78 } ] s4
      | s4 = [ &left_val'0 <- _32.f0 ] s5
      | s5 = [ &right_val'0 <- _32.f1 ] s6
      | s6 = eq_Option_ref_bool {left_val'0} {right_val'0} (fun (_ret: bool) -> [ &_43 <- _ret ] s7)
      | s7 = bb8 ]
    | bb8 = any [ br0 -> {_43 = false} (! bb10) | br1 -> {_43} (! bb9) ]
    | bb9 = s0
      [ s0 = {inv_Filter_Iter_bool_closure0 a}
        MutBorrow.borrow_mut <t_Filter_Iter_bool_closure0> {a}
          (fun (_ret: MutBorrow.t t_Filter_Iter_bool_closure0) ->
            [ &_60 <- _ret ] -{inv_Filter_Iter_bool_closure0 _ret.final}-
            [ &a <- _ret.final ] s1)
      | s1 = {inv_Filter_Iter_bool_closure0 _60.current}
        MutBorrow.borrow_final <t_Filter_Iter_bool_closure0> {_60.current} {MutBorrow.get_id _60}
          (fun (_ret: MutBorrow.t t_Filter_Iter_bool_closure0) ->
            [ &_59 <- _ret ] -{inv_Filter_Iter_bool_closure0 _ret.final}-
            [ &_60 <- { _60 with current = _ret.final } ] s2)
      | s2 = next_Filter_Iter_bool_closure0 {_59} (fun (_ret: t_Option_ref_bool) -> [ &_58 <- _ret ] s3)
      | s3 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Filter_Iter_bool_closure0 _60} s1
      | s1 = -{resolve_ref_Filter_Iter_bool_closure0 _60}- s2
      | s2 = {[@expl:type invariant] inv_Filter_Iter_bool_closure0 a} s3
      | s3 = -{resolve_Filter_Iter_bool_closure0 a}- s4
      | s4 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_ref_bool = Any.any_l () | & _1: t_Option_ref_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_ref_bool) -> [ &_77 <- _const ] s5 ]
      | s5 = [ &_56 <- { f0 = _58; f1 = _77 } ] s6
      | s6 = [ &left_val'1 <- _56.f0 ] s7
      | s7 = [ &right_val'1 <- _56.f1 ] s8
      | s8 = eq_Option_ref_bool {left_val'1} {right_val'1} (fun (_ret: bool) -> [ &_65 <- _ret ] s9)
      | s9 = bb12 ]
    | bb12 = any [ br0 -> {_65 = false} (! bb14) | br1 -> {_65} (! bb13) ]
    | bb13 = return {_0}
    | bb14 = s0
      [ s0 = [ &kind'1 <- Eq ] s1
      | s1 = [ &_73 <- left_val'1 ] s2
      | s2 = [ &_75 <- right_val'1 ] s3
      | s3 = {false} any ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_Filter_Iter_bool_closure0 a} s1
      | s1 = -{resolve_Filter_Iter_bool_closure0 a}- s2
      | s2 = [ &kind'0 <- Eq ] s3
      | s3 = [ &_51 <- left_val'0 ] s4
      | s4 = [ &_53 <- right_val'0 ] s5
      | s5 = {false} any ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv_Filter_Iter_bool_closure0 a} s1
      | s1 = -{resolve_Filter_Iter_bool_closure0 a}- s2
      | s2 = [ &kind <- Eq ] s3
      | s3 = [ &_27 <- left_val ] s4
      | s4 = [ &_29 <- right_val ] s5
      | s5 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & a: t_Filter_Iter_bool_closure0 = Any.any_l ()
    | & _2: t_Iter_bool = Any.any_l ()
    | & _6: () = Any.any_l ()
    | & _8: tup2_ref_Option_ref_bool_ref_Option_ref_bool = Any.any_l ()
    | & _10: t_Option_ref_bool = Any.any_l ()
    | & _11: MutBorrow.t t_Filter_Iter_bool_closure0 = Any.any_l ()
    | & _12: MutBorrow.t t_Filter_Iter_bool_closure0 = Any.any_l ()
    | & left_val: t_Option_ref_bool = Any.any_l ()
    | & right_val: t_Option_ref_bool = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _27: t_Option_ref_bool = Any.any_l ()
    | & _29: t_Option_ref_bool = Any.any_l ()
    | & _32: tup2_ref_Option_ref_bool_ref_Option_ref_bool = Any.any_l ()
    | & _34: t_Option_ref_bool = Any.any_l ()
    | & _35: MutBorrow.t t_Filter_Iter_bool_closure0 = Any.any_l ()
    | & _36: MutBorrow.t t_Filter_Iter_bool_closure0 = Any.any_l ()
    | & left_val'0: t_Option_ref_bool = Any.any_l ()
    | & right_val'0: t_Option_ref_bool = Any.any_l ()
    | & _43: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _51: t_Option_ref_bool = Any.any_l ()
    | & _53: t_Option_ref_bool = Any.any_l ()
    | & _56: tup2_ref_Option_ref_bool_ref_Option_ref_bool = Any.any_l ()
    | & _58: t_Option_ref_bool = Any.any_l ()
    | & _59: MutBorrow.t t_Filter_Iter_bool_closure0 = Any.any_l ()
    | & _60: MutBorrow.t t_Filter_Iter_bool_closure0 = Any.any_l ()
    | & left_val'1: t_Option_ref_bool = Any.any_l ()
    | & right_val'1: t_Option_ref_bool = Any.any_l ()
    | & _65: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _73: t_Option_ref_bool = Any.any_l ()
    | & _75: t_Option_ref_bool = Any.any_l ()
    | & _77: t_Option_ref_bool = Any.any_l ()
    | & _78: t_Option_ref_bool = Any.any_l ()
    | & _79: t_Option_ref_bool = Any.any_l ()
    | & _80: Slice64.array bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_filter_map
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter_bool
  
  predicate inv_Iter_bool (_1: t_Iter_bool)
  
  function view_Iter_bool (self: t_Iter_bool) : Slice64.slice bool
  
  let rec iter_bool (self_: Slice64.slice bool) (return (x: t_Iter_bool)) = any
    [ return (result: t_Iter_bool) -> {inv_Iter_bool result} {view_Iter_bool result = self_} (! return {result}) ]
  
  predicate resolve_ref_closure0 [@inline:trivial] (_1: MutBorrow.t ()) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_closure0
  
  type t_Option_bool = None | Some bool
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: bool) (result: t_Option_bool) =
    let b = args in result = (if b then Some false else None)
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  predicate resolve_closure0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_closure0
  
  predicate hist_inv_closure0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_closure0
  
  predicate postcondition_mut_closure0 [@inline:trivial] (self: ()) (args: bool) (result_state: ()) (result: t_Option_bool) =
    let b = args in result = (if b then Some false else None) /\ hist_inv_closure0 self result_state
  
  meta "rewrite_def" predicate postcondition_mut_closure0
  
  function fn_mut_once_closure0 (self: ()) (args: bool) (res: t_Option_bool) : ()
  
  axiom fn_mut_once_closure0_spec:
    forall self: (), args: bool, res: t_Option_bool. postcondition_once_closure0 self args res
      = (exists res_state: (). postcondition_mut_closure0 self args res_state res /\ resolve_closure0 res_state)
  
  function hist_inv_trans_closure0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_closure0_spec: forall self: (), b: (), c: (). hist_inv_closure0 self b
      -> hist_inv_closure0 b c -> hist_inv_closure0 self c
  
  function hist_inv_refl_closure0 (self: ()) : ()
  
  axiom hist_inv_refl_closure0_spec: forall self: (). hist_inv_closure0 self self
  
  function postcondition_mut_hist_inv_closure0 (self: ()) (args: bool) (res_state: ()) (res: t_Option_bool) : ()
  
  axiom postcondition_mut_hist_inv_closure0_spec:
    forall self: (), args: bool, res_state: (), res: t_Option_bool. postcondition_mut_closure0 self args res_state res
      -> hist_inv_closure0 self res_state
  
  let rec closure0 (self: MutBorrow.t ()) (b: bool) (return (x: t_Option_bool)) = (! bb0
    [ bb0 = s0 [ s0 = -{resolve_ref_closure0 self}- s1 | s1 = any [ br0 -> {b = false} (! bb2) | br1 -> {b} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &res <- Some false ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &res <- None ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0 <- res ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Option_bool = Any.any_l ()
    | & self: MutBorrow.t () = self
    | & b: bool = b
    | & res: t_Option_bool = Any.any_l () ])
    [ return (result: t_Option_bool) -> {[@expl:closure ensures] result = (if b then Some false else None)}
      {[@expl:closure hist_inv post] hist_inv_closure0 self.current self.final}
      (! return {result}) ]
  
  type t_FilterMap_Iter_bool_closure0
  
  predicate immutable_ref_bool (f: ()) = forall g: (). hist_inv_closure0 f g -> f = g
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: bool) = let b = args in true
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate no_precondition_ref_bool (f: ()) = forall i: bool. precondition_closure0 f i
  
  predicate precise_ref_bool (f1: ()) =
    forall f2: (), i: bool. not ((exists b: bool. postcondition_mut_closure0 f1 i f2 (Some b))
      /\ postcondition_mut_closure0 f1 i f2 (None))
  
  function iter_FilterMap_Iter_bool_closure0 (self: t_FilterMap_Iter_bool_closure0) : t_Iter_bool
  
  predicate inv_closure0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate inv_closure0
  
  function func_FilterMap_Iter_bool_closure0 (self: t_FilterMap_Iter_bool_closure0) : ()
  
  predicate private_invariant_bool (f: t_FilterMap_Iter_bool_closure0)
  
  predicate invariant_FilterMap_Iter_bool_closure0 [@inline:trivial] (self: t_FilterMap_Iter_bool_closure0) =
    inv_Iter_bool (iter_FilterMap_Iter_bool_closure0 self)
    /\ inv_closure0 (func_FilterMap_Iter_bool_closure0 self) /\ private_invariant_bool self
  
  meta "rewrite_def" predicate invariant_FilterMap_Iter_bool_closure0
  
  predicate inv_FilterMap_Iter_bool_closure0 (_1: t_FilterMap_Iter_bool_closure0)
  
  axiom inv_axiom:
    forall x: t_FilterMap_Iter_bool_closure0 [inv_FilterMap_Iter_bool_closure0 x]. inv_FilterMap_Iter_bool_closure0 x
      -> invariant_FilterMap_Iter_bool_closure0 x
  
  let rec filter_map_Iter_bool (self_: t_Iter_bool) (f: ()) (return (x: t_FilterMap_Iter_bool_closure0)) =
    {[@expl:filter_map 'self_' type invariant] inv_Iter_bool self_}
    {[@expl:filter_map requires #0] immutable_ref_bool f}
    {[@expl:filter_map requires #1] no_precondition_ref_bool f}
    {[@expl:filter_map requires #2] precise_ref_bool f}
    any
    [ return (result: t_FilterMap_Iter_bool_closure0) -> {inv_FilterMap_Iter_bool_closure0 result}
      {iter_FilterMap_Iter_bool_closure0 result = self_ /\ func_FilterMap_Iter_bool_closure0 result = f}
      (! return {result}) ]
  
  predicate invariant_ref_FilterMap_Iter_bool_closure0 [@inline:trivial] (self: MutBorrow.t t_FilterMap_Iter_bool_closure0) =
    inv_FilterMap_Iter_bool_closure0 self.current /\ inv_FilterMap_Iter_bool_closure0 self.final
  
  meta "rewrite_def" predicate invariant_ref_FilterMap_Iter_bool_closure0
  
  predicate inv_ref_FilterMap_Iter_bool_closure0 [@inline:trivial] (_1: MutBorrow.t t_FilterMap_Iter_bool_closure0) =
    invariant_ref_FilterMap_Iter_bool_closure0 _1
  
  meta "rewrite_def" predicate inv_ref_FilterMap_Iter_bool_closure0
  
  predicate index_slice_bool [@inline:trivial] (self: Slice64.slice bool) (ix: int) = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" predicate index_slice_bool
  
  function to_ref_seq_slice_bool (self: Slice64.slice bool) : Seq.seq bool
  
  axiom to_ref_seq_slice_bool_spec: forall self: Slice64.slice bool. Seq.length (to_ref_seq_slice_bool self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_bool_spec'0: forall self: Slice64.slice bool. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_bool self)
        -> Seq.get (to_ref_seq_slice_bool self) i = index_slice_bool self i
  
  predicate produces_Iter_bool (self: t_Iter_bool) (visited: Seq.seq bool) (tl: t_Iter_bool) =
    to_ref_seq_slice_bool (view_Iter_bool self) = Seq.(++) visited (to_ref_seq_slice_bool (view_Iter_bool tl))
  
  function produces_trans_Iter_bool (a: t_Iter_bool) (ab: Seq.seq bool) (b: t_Iter_bool) (bc: Seq.seq bool) (c: t_Iter_bool) : ()
   = ()
  
  axiom produces_trans_Iter_bool_spec:
    forall a: t_Iter_bool, ab: Seq.seq bool, b: t_Iter_bool, bc: Seq.seq bool, c: t_Iter_bool. produces_Iter_bool a ab b
      -> produces_Iter_bool b bc c -> produces_Iter_bool a (Seq.(++) ab bc) c
  
  function produces_refl_Iter_bool (self: t_Iter_bool) : () = ()
  
  axiom produces_refl_Iter_bool_spec: forall self: t_Iter_bool. produces_Iter_bool self (Seq.empty: Seq.seq bool) self
  
  predicate produces_FilterMap_Iter_bool_closure0 (self: t_FilterMap_Iter_bool_closure0) (visited: Seq.seq bool) (succ: t_FilterMap_Iter_bool_closure0) =
    private_invariant_bool self
    -> hist_inv_closure0 (func_FilterMap_Iter_bool_closure0 self) (func_FilterMap_Iter_bool_closure0 succ)
    /\ (exists s: Seq.seq bool, f: Map.map int int. produces_Iter_bool (iter_FilterMap_Iter_bool_closure0 self) s (iter_FilterMap_Iter_bool_closure0 succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_closure0 (func_FilterMap_Iter_bool_closure0 self) (Seq.get s (Map.get f i)) (func_FilterMap_Iter_bool_closure0 self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_closure0 (func_FilterMap_Iter_bool_closure0 self) (Seq.get s j) (func_FilterMap_Iter_bool_closure0 self) (None)))
  
  function produces_trans_FilterMap_Iter_bool_closure0 (a: t_FilterMap_Iter_bool_closure0) (ab: Seq.seq bool) (b: t_FilterMap_Iter_bool_closure0) (bc: Seq.seq bool) (c: t_FilterMap_Iter_bool_closure0) : ()
  
  axiom produces_trans_FilterMap_Iter_bool_closure0_spec:
    forall a: t_FilterMap_Iter_bool_closure0, ab: Seq.seq bool, b: t_FilterMap_Iter_bool_closure0, bc: Seq.seq bool, c: t_FilterMap_Iter_bool_closure0. produces_FilterMap_Iter_bool_closure0 a ab b
      -> produces_FilterMap_Iter_bool_closure0 b bc c -> produces_FilterMap_Iter_bool_closure0 a (Seq.(++) ab bc) c
  
  function produces_refl_FilterMap_Iter_bool_closure0 (self: t_FilterMap_Iter_bool_closure0) : ()
  
  axiom produces_refl_FilterMap_Iter_bool_closure0_spec:
    forall self: t_FilterMap_Iter_bool_closure0. produces_FilterMap_Iter_bool_closure0 self (Seq.empty: Seq.seq bool) self
  
  predicate resolve_ref_Iter_bool [@inline:trivial] (_1: MutBorrow.t t_Iter_bool) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Iter_bool
  
  predicate completed_Iter_bool (self: MutBorrow.t t_Iter_bool) =
    resolve_ref_Iter_bool self /\ Slice64.view (view_Iter_bool self.current) = (Seq.empty: Seq.seq bool)
  
  predicate completed_FilterMap_Iter_bool_closure0 (self: MutBorrow.t t_FilterMap_Iter_bool_closure0) =
    (exists s: Seq.seq bool, e: MutBorrow.t t_Iter_bool. produces_Iter_bool (iter_FilterMap_Iter_bool_closure0 self.current) s e.current
        /\ completed_Iter_bool e
        /\ (forall i: int. 0 <= i /\ i < Seq.length s
          -> postcondition_mut_closure0 (func_FilterMap_Iter_bool_closure0 self.current) (Seq.get s i) (func_FilterMap_Iter_bool_closure0 self.final) (None)))
    /\ func_FilterMap_Iter_bool_closure0 self.current = func_FilterMap_Iter_bool_closure0 self.final
  
  let rec next_FilterMap_Iter_bool_closure0 (self_: MutBorrow.t t_FilterMap_Iter_bool_closure0)
    (return (x: t_Option_bool)) = {[@expl:next 'self_' type invariant] inv_ref_FilterMap_Iter_bool_closure0 self_}
    any
    [ return (result: t_Option_bool) -> {match result with
        | None -> completed_FilterMap_Iter_bool_closure0 self_
        | Some v -> produces_FilterMap_Iter_bool_closure0 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve_ref_FilterMap_Iter_bool_closure0 [@inline:trivial] (_1: MutBorrow.t t_FilterMap_Iter_bool_closure0) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FilterMap_Iter_bool_closure0
  
  type tup2_ref_Option_bool_ref_Option_bool = { f0: t_Option_bool; f1: t_Option_bool }
  
  predicate deep_model_bool [@inline:trivial] (self: bool) = self
  
  meta "rewrite_def" predicate deep_model_bool
  
  function deep_model_Option_bool [@inline:trivial] (self: t_Option_bool) : t_Option_bool = match self with
      | Some t -> Some (deep_model_bool t)
      | None -> None
      end
  
  meta "rewrite_def" function deep_model_Option_bool
  
  function deep_model_ref_Option_bool [@inline:trivial] (self: t_Option_bool) : t_Option_bool =
    deep_model_Option_bool self
  
  meta "rewrite_def" function deep_model_ref_Option_bool
  
  let rec eq_Option_bool (self_: t_Option_bool) (rhs: t_Option_bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_bool self_ = deep_model_ref_Option_bool rhs)}
      (! return {result}) ]
  
  predicate resolve_FilterMap_Iter_bool_closure0 (_1: t_FilterMap_Iter_bool_closure0)
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_filter_map (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array bool) -> (! -{Seq.get __arr_temp.Slice64.elts 0
              /\ Seq.get __arr_temp.Slice64.elts 1 = false
              /\ Seq.get __arr_temp.Slice64.elts 2 /\ Seq.length __arr_temp.Slice64.elts = 3}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array bool = Any.any_l () | & _1: Slice64.array bool = Any.any_l () ]
        [ _const_ret (_const: Slice64.array bool) -> [ &_76 <- _const ] s1 ]
      | s1 = iter_bool {_76} (fun (_ret: t_Iter_bool) -> [ &_2 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_6 <- () ] s1
      | s1 = filter_map_Iter_bool {_2} {_6} (fun (_ret: t_FilterMap_Iter_bool_closure0) -> [ &a <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_FilterMap_Iter_bool_closure0 a}
        MutBorrow.borrow_mut <t_FilterMap_Iter_bool_closure0> {a}
          (fun (_ret: MutBorrow.t t_FilterMap_Iter_bool_closure0) ->
            [ &_12 <- _ret ] -{inv_FilterMap_Iter_bool_closure0 _ret.final}-
            [ &a <- _ret.final ] s1)
      | s1 = {inv_FilterMap_Iter_bool_closure0 _12.current}
        MutBorrow.borrow_final <t_FilterMap_Iter_bool_closure0> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t t_FilterMap_Iter_bool_closure0) ->
            [ &_11 <- _ret ] -{inv_FilterMap_Iter_bool_closure0 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = next_FilterMap_Iter_bool_closure0 {_11} (fun (_ret: t_Option_bool) -> [ &_10 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_FilterMap_Iter_bool_closure0 _12} s1
      | s1 = -{resolve_ref_FilterMap_Iter_bool_closure0 _12}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- Some false ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_bool = Any.any_l () | & _1: t_Option_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_bool) -> [ &_75 <- _const ] s3 ]
      | s3 = [ &_8 <- { f0 = _10; f1 = _75 } ] s4
      | s4 = [ &left_val <- _8.f0 ] s5
      | s5 = [ &right_val <- _8.f1 ] s6
      | s6 = eq_Option_bool {left_val} {right_val} (fun (_ret: bool) -> [ &_17 <- _ret ] s7)
      | s7 = bb4 ]
    | bb4 = any [ br0 -> {_17 = false} (! bb6) | br1 -> {_17} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv_FilterMap_Iter_bool_closure0 a}
        MutBorrow.borrow_mut <t_FilterMap_Iter_bool_closure0> {a}
          (fun (_ret: MutBorrow.t t_FilterMap_Iter_bool_closure0) ->
            [ &_34 <- _ret ] -{inv_FilterMap_Iter_bool_closure0 _ret.final}-
            [ &a <- _ret.final ] s1)
      | s1 = {inv_FilterMap_Iter_bool_closure0 _34.current}
        MutBorrow.borrow_final <t_FilterMap_Iter_bool_closure0> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret: MutBorrow.t t_FilterMap_Iter_bool_closure0) ->
            [ &_33 <- _ret ] -{inv_FilterMap_Iter_bool_closure0 _ret.final}-
            [ &_34 <- { _34 with current = _ret.final } ] s2)
      | s2 = next_FilterMap_Iter_bool_closure0 {_33} (fun (_ret: t_Option_bool) -> [ &_32 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_ref_FilterMap_Iter_bool_closure0 _34} s1
      | s1 = -{resolve_ref_FilterMap_Iter_bool_closure0 _34}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- Some false ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_bool = Any.any_l () | & _1: t_Option_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_bool) -> [ &_74 <- _const ] s3 ]
      | s3 = [ &_30 <- { f0 = _32; f1 = _74 } ] s4
      | s4 = [ &left_val'0 <- _30.f0 ] s5
      | s5 = [ &right_val'0 <- _30.f1 ] s6
      | s6 = eq_Option_bool {left_val'0} {right_val'0} (fun (_ret: bool) -> [ &_39 <- _ret ] s7)
      | s7 = bb8 ]
    | bb8 = any [ br0 -> {_39 = false} (! bb10) | br1 -> {_39} (! bb9) ]
    | bb9 = s0
      [ s0 = {inv_FilterMap_Iter_bool_closure0 a}
        MutBorrow.borrow_mut <t_FilterMap_Iter_bool_closure0> {a}
          (fun (_ret: MutBorrow.t t_FilterMap_Iter_bool_closure0) ->
            [ &_56 <- _ret ] -{inv_FilterMap_Iter_bool_closure0 _ret.final}-
            [ &a <- _ret.final ] s1)
      | s1 = {inv_FilterMap_Iter_bool_closure0 _56.current}
        MutBorrow.borrow_final <t_FilterMap_Iter_bool_closure0> {_56.current} {MutBorrow.get_id _56}
          (fun (_ret: MutBorrow.t t_FilterMap_Iter_bool_closure0) ->
            [ &_55 <- _ret ] -{inv_FilterMap_Iter_bool_closure0 _ret.final}-
            [ &_56 <- { _56 with current = _ret.final } ] s2)
      | s2 = next_FilterMap_Iter_bool_closure0 {_55} (fun (_ret: t_Option_bool) -> [ &_54 <- _ret ] s3)
      | s3 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_ref_FilterMap_Iter_bool_closure0 _56} s1
      | s1 = -{resolve_ref_FilterMap_Iter_bool_closure0 _56}- s2
      | s2 = {[@expl:type invariant] inv_FilterMap_Iter_bool_closure0 a} s3
      | s3 = -{resolve_FilterMap_Iter_bool_closure0 a}- s4
      | s4 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option_bool = Any.any_l () | & _1: t_Option_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_bool) -> [ &_73 <- _const ] s5 ]
      | s5 = [ &_52 <- { f0 = _54; f1 = _73 } ] s6
      | s6 = [ &left_val'1 <- _52.f0 ] s7
      | s7 = [ &right_val'1 <- _52.f1 ] s8
      | s8 = eq_Option_bool {left_val'1} {right_val'1} (fun (_ret: bool) -> [ &_61 <- _ret ] s9)
      | s9 = bb12 ]
    | bb12 = any [ br0 -> {_61 = false} (! bb14) | br1 -> {_61} (! bb13) ]
    | bb13 = return {_0}
    | bb14 = s0
      [ s0 = [ &kind'1 <- Eq ] s1
      | s1 = [ &_69 <- left_val'1 ] s2
      | s2 = [ &_71 <- right_val'1 ] s3
      | s3 = {false} any ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_FilterMap_Iter_bool_closure0 a} s1
      | s1 = -{resolve_FilterMap_Iter_bool_closure0 a}- s2
      | s2 = [ &kind'0 <- Eq ] s3
      | s3 = [ &_47 <- left_val'0 ] s4
      | s4 = [ &_49 <- right_val'0 ] s5
      | s5 = {false} any ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv_FilterMap_Iter_bool_closure0 a} s1
      | s1 = -{resolve_FilterMap_Iter_bool_closure0 a}- s2
      | s2 = [ &kind <- Eq ] s3
      | s3 = [ &_25 <- left_val ] s4
      | s4 = [ &_27 <- right_val ] s5
      | s5 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & a: t_FilterMap_Iter_bool_closure0 = Any.any_l ()
    | & _2: t_Iter_bool = Any.any_l ()
    | & _6: () = Any.any_l ()
    | & _8: tup2_ref_Option_bool_ref_Option_bool = Any.any_l ()
    | & _10: t_Option_bool = Any.any_l ()
    | & _11: MutBorrow.t t_FilterMap_Iter_bool_closure0 = Any.any_l ()
    | & _12: MutBorrow.t t_FilterMap_Iter_bool_closure0 = Any.any_l ()
    | & left_val: t_Option_bool = Any.any_l ()
    | & right_val: t_Option_bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _25: t_Option_bool = Any.any_l ()
    | & _27: t_Option_bool = Any.any_l ()
    | & _30: tup2_ref_Option_bool_ref_Option_bool = Any.any_l ()
    | & _32: t_Option_bool = Any.any_l ()
    | & _33: MutBorrow.t t_FilterMap_Iter_bool_closure0 = Any.any_l ()
    | & _34: MutBorrow.t t_FilterMap_Iter_bool_closure0 = Any.any_l ()
    | & left_val'0: t_Option_bool = Any.any_l ()
    | & right_val'0: t_Option_bool = Any.any_l ()
    | & _39: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _47: t_Option_bool = Any.any_l ()
    | & _49: t_Option_bool = Any.any_l ()
    | & _52: tup2_ref_Option_bool_ref_Option_bool = Any.any_l ()
    | & _54: t_Option_bool = Any.any_l ()
    | & _55: MutBorrow.t t_FilterMap_Iter_bool_closure0 = Any.any_l ()
    | & _56: MutBorrow.t t_FilterMap_Iter_bool_closure0 = Any.any_l ()
    | & left_val'1: t_Option_bool = Any.any_l ()
    | & right_val'1: t_Option_bool = Any.any_l ()
    | & _61: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _69: t_Option_bool = Any.any_l ()
    | & _71: t_Option_bool = Any.any_l ()
    | & _73: t_Option_bool = Any.any_l ()
    | & _74: t_Option_bool = Any.any_l ()
    | & _75: t_Option_bool = Any.any_l ()
    | & _76: Slice64.array bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
