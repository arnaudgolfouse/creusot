module M_foo99
  use creusot.int.Int32
  use creusot.slice.Slice64
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec elim_Some (input: t_Option_i32) (ret (f0: Int32.t)) = any
    [ good (f0: Int32.t) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: Int32.t [Some f0: t_Option_i32]. Some f0 <> input} (! {false} any) ]
  
  type t_Argument
  
  let rec closure0 [@coma:extspec] (self: ()) (x: t_Option_i32) (return (x'0: Int32.t)) = bb0
    [ bb0 = any [ br0 -> {x = None} (! bb3) | br1 (x0: Int32.t) -> {x = Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = elim_Some {x} (fun (r0: Int32.t) -> [ &y <- r0 ] s1) | s1 = [ &_0 <- y ] s2 | s2 = return {_0} ]
    | bb3 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array string) -> (! -{Seq.get __arr_temp.Slice64.elts 0
                = "internal error: entered unreachable code: unwrapped None"
              /\ Seq.length __arr_temp.Slice64.elts = 1}-
              [ &self <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- self ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array string = Any.any_l () | & self: Slice64.array string = Any.any_l () ]
        [ _const_ret (_const: Slice64.array string) -> [ &_15 <- _const ] s1 ]
      | s1 = [ &_9 <- _15 ] s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array t_Argument) -> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
              [ &self <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- self ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array t_Argument = Any.any_l () | & self: Slice64.array t_Argument = Any.any_l () ]
        [ _const_ret (_const: Slice64.array t_Argument) -> [ &_14 <- _const ] s3 ]
      | s3 = [ &_12 <- _14 ] s4
      | s4 = {false} any ] ]
    [ & _0: Int32.t = Any.any_l ()
    | & x: t_Option_i32 = x
    | & y: Int32.t = Any.any_l ()
    | & _9: Slice64.array string = Any.any_l ()
    | & _12: Slice64.array t_Argument = Any.any_l ()
    | & _14: Slice64.array t_Argument = Any.any_l ()
    | & _15: Slice64.array string = Any.any_l () ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec foo99 (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = [ &_my_closure <- () ] s1 | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l () | & _my_closure: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
