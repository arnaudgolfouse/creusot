module M_594__test_program
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  type tuple = { f0: UInt32.t; f1: UInt32.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_program (_1: tuple) (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &x <- _1.f0 ] s1 | s1 = [ &_0 <- x ] s2 | s2 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l () | & _1: tuple = _1 | & x: UInt32.t = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:test_program ensures] let {f0 = x} = _1 in result = x} (! return {result}) ]
end
module M_594__test_closure
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type tuple = { f0: Int32.t; f1: Int32.t }
  
  let rec closure0 (self: ()) (_c: Int32.t) (_1: tuple) (return (x: Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_a <- _1.f0 ] s1
      | s1 = [ &b <- _1.f1 ] s2
      | s2 = [ &res <- b ] s3
      | s3 = [ &_0 <- res ] s4
      | s4 = return {_0} ] ]
    [ & _0: Int32.t = Any.any_l ()
    | & _1: tuple = _1
    | & _a: Int32.t = Any.any_l ()
    | & b: Int32.t = Any.any_l ()
    | & res: Int32.t = Any.any_l () ])
    [ return (result: Int32.t) -> {[@expl:closure ensures] let {f0 = _a; f1 = b} = _1 in result = b}
      (! return {result}) ]
  
  let rec closure1 (self: ()) (_0: tuple) (return (x: Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_a <- _0.f0 ] s1
      | s1 = [ &b <- _0.f1 ] s2
      | s2 = [ &res <- b ] s3
      | s3 = [ &_0'0 <- res ] s4
      | s4 = return {_0'0} ] ]
    [ & _0'0: Int32.t = Any.any_l ()
    | & _0: tuple = _0
    | & _a: Int32.t = Any.any_l ()
    | & b: Int32.t = Any.any_l ()
    | & res: Int32.t = Any.any_l () ])
    [ return (result: Int32.t) -> {[@expl:closure ensures] let {f0 = _a; f1 = b} = _0 in result = b}
      (! return {result}) ]
  
  type tuple'0 = { f0'0: Int32.t; f1'0: tuple }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_closure (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &cl1 <- () ] s1
      | s1 = [ &cl2 <- () ] s2
      | s2 = [ &_6 <- { f0 = (0: Int32.t); f1 = (3: Int32.t) } ] s3
      | s3 = [ &_5 <- { f0'0 = (4: Int32.t); f1'0 = _6 } ] s4
      | s4 = closure0 {cl1} {_5.f0'0} {_5.f1'0} (fun (_ret: Int32.t) -> [ &_a <- _ret ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_10 <- { f0 = (0: Int32.t); f1 = (4: Int32.t) } ] s1
      | s1 = [ &_9 <- _10 ] s2
      | s2 = closure1 {cl2} {_9} (fun (_ret: Int32.t) -> [ &_b <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & cl1: () = Any.any_l ()
    | & cl2: () = Any.any_l ()
    | & _a: Int32.t = Any.any_l ()
    | & _5: tuple'0 = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _b: Int32.t = Any.any_l ()
    | & _9: tuple = Any.any_l ()
    | & _10: tuple = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_594__qyi1704796797730763899__test_method (* T *)
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  type tuple = { f0: UInt32.t; f1: UInt32.t }
  
  type t_T = { t_T__0: UInt32.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_method (self: t_T) (_2: tuple) (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &x <- _2.f0 ] s1 | s1 = [ &_0 <- x ] s2 | s2 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l () | & _2: tuple = _2 | & x: UInt32.t = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:test_method ensures] let {f0 = x} = _2 in result = x} (! return {result}) ]
end
