module M_try_option
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Infallible = None'0 | Some'0 ()
  
  type t_ControlFlow_Option_Infallible_T = Continue t_T | Break t_Option_Infallible
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_Infallible f0
        end
  
  predicate inv_ControlFlow_Option_Infallible_T (_1: t_ControlFlow_Option_Infallible_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_T [inv_ControlFlow_Option_Infallible_T x]. inv_ControlFlow_Option_Infallible_T x
      = match x with
        | Continue f0 -> inv_T f0
        | Break f0 -> inv_Option_Infallible f0
        end
  
  let rec branch_Option_T (self_: t_Option_T) (return (x: t_ControlFlow_Option_Infallible_T)) =
    {[@expl:branch 'self_' type invariant] inv_Option_T self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_T) -> {inv_ControlFlow_Option_Infallible_T result}
      {match self_ with
        | Some v -> result = Continue v
        | None -> result = Break (None'0)
        end}
      (! return {result}) ]
  
  let rec elim_Break (input: t_ControlFlow_Option_Infallible_T) (ret (f0: t_Option_Infallible)) = any
    [ good (f0: t_Option_Infallible) -> {Break f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Option_Infallible [Break f0: t_ControlFlow_Option_Infallible_T]. Break f0 <> input}
      (! {false}
      any) ]
  
  let rec from_residual_Option_T (residual: t_Option_Infallible) (return (x: t_Option_T)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_T) -> {inv_Option_T result} {result = None} (! return {result}) ]
  
  let rec elim_Continue (input: t_ControlFlow_Option_Infallible_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Continue f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Continue f0: t_ControlFlow_Option_Infallible_T]. Continue f0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec try_option_T (x: t_Option_T) (return (x'0: t_Option_T)) =
    {[@expl:try_option 'x' type invariant] inv_Option_T x}
    (! bb0
    [ bb0 = s0
      [ s0 = branch_Option_T {x} (fun (_ret: t_ControlFlow_Option_Infallible_T) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any
      [ br0 (x0: t_T) -> {_4 = Continue x0} (! bb4) | br1 (x0: t_Option_Infallible) -> {_4 = Break x0} (! bb5) ]
    | bb5 = s0
      [ s0 = elim_Break {_4} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = from_residual_Option_T {residual} (fun (_ret: t_Option_T) -> [ &_0 <- _ret ] s2)
      | s2 = bb11 ]
    | bb4 = s0 [ s0 = elim_Continue {_4} (fun (r0: t_T) -> [ &val' <- r0 ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = [ &_0 <- Some val' ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & x: t_Option_T = x
    | & _4: t_ControlFlow_Option_Infallible_T = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val': t_T = Any.any_l () ])
    [ return (result: t_Option_T) -> {[@expl:try_option result type invariant] inv_Option_T result}
      {[@expl:try_option ensures] result = x}
      (! return {result}) ]
end
module M_try_result
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  type t_Result_Infallible_E = Ok'0 () | Err'0 t_E
  
  type t_ControlFlow_Result_Infallible_E_T = Continue t_T | Break t_Result_Infallible_E
  
  predicate inv_T (_1: t_T)
  
  predicate inv_E (_1: t_E)
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Result_Infallible_E (_1: t_Result_Infallible_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_Infallible_E [inv_Result_Infallible_E x]. inv_Result_Infallible_E x
      = match x with
        | Ok'0 f0 -> inv_Infallible f0
        | Err'0 f0 -> inv_E f0
        end
  
  predicate inv_ControlFlow_Result_Infallible_E_T (_1: t_ControlFlow_Result_Infallible_E_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_ControlFlow_Result_Infallible_E_T [inv_ControlFlow_Result_Infallible_E_T x]. inv_ControlFlow_Result_Infallible_E_T x
      = match x with
        | Continue f0 -> inv_T f0
        | Break f0 -> inv_Result_Infallible_E f0
        end
  
  let rec branch_Result_T_E (self_: t_Result_T_E) (return (x: t_ControlFlow_Result_Infallible_E_T)) =
    {[@expl:branch 'self_' type invariant] inv_Result_T_E self_}
    any
    [ return (result: t_ControlFlow_Result_Infallible_E_T) -> {inv_ControlFlow_Result_Infallible_E_T result}
      {match self_ with
        | Ok v -> result = Continue v
        | Err e -> result = Break (Err'0 e)
        end}
      (! return {result}) ]
  
  let rec elim_Break (input: t_ControlFlow_Result_Infallible_E_T) (ret (f0: t_Result_Infallible_E)) = any
    [ good (f0: t_Result_Infallible_E) -> {Break f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Result_Infallible_E [Break f0: t_ControlFlow_Result_Infallible_E_T]. Break f0 <> input}
      (! {false}
      any) ]
  
  type tup2_Result_T_E_Result_Infallible_E = { f0: t_Result_T_E; f1: t_Result_Infallible_E }
  
  predicate postcondition_once_from [@inline:trivial] (self: ()) (args: t_E) (result: t_E) =
    let self_ = args in result = self_ /\ inv_E result
  
  meta "rewrite_def" predicate postcondition_once_from
  
  predicate resolve_from [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_from
  
  predicate postcondition_mut_from [@inline:trivial] (self: ()) (args: t_E) (result_state: ()) (result: t_E) =
    let self_ = args in result = self_ /\ inv_E result
  
  meta "rewrite_def" predicate postcondition_mut_from
  
  function fn_mut_once_from (self: ()) (args: t_E) (res: t_E) : ()
  
  axiom fn_mut_once_from_spec: forall self: (), args: t_E, res: t_E. postcondition_once_from self args res
      = (exists res_state: (). postcondition_mut_from self args res_state res /\ resolve_from res_state)
  
  predicate hist_inv_from [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_from
  
  function hist_inv_trans_from (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_from_spec: forall self: (), b: (), c: (). hist_inv_from self b
      -> hist_inv_from b c -> hist_inv_from self c
  
  function hist_inv_refl_from (self: ()) : ()
  
  axiom hist_inv_refl_from_spec: forall self: (). hist_inv_from self self
  
  function postcondition_mut_hist_inv_from (self: ()) (args: t_E) (res_state: ()) (res: t_E) : ()
  
  axiom postcondition_mut_hist_inv_from_spec:
    forall self: (), args: t_E, res_state: (), res: t_E. postcondition_mut_from self args res_state res
      -> hist_inv_from self res_state
  
  function fn_hist_inv_from (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_from_spec: forall self: (), res_state: (). hist_inv_from self res_state = (self = res_state)
  
  predicate postcondition_from [@inline:trivial] (self: ()) (args: t_E) (result: t_E) =
    let self_ = args in result = self_ /\ inv_E result
  
  meta "rewrite_def" predicate postcondition_from
  
  function fn_once_from (self: ()) (args: t_E) (res: t_E) : ()
  
  axiom fn_once_from_spec: forall self: (), args: t_E, res: t_E. postcondition_once_from self args res
      = (postcondition_from self args res /\ resolve_from self)
  
  function fn_mut_from (self: ()) (args: t_E) (res_state: ()) (res: t_E) : ()
  
  axiom fn_mut_from_spec:
    forall self: (), args: t_E, res_state: (), res: t_E. postcondition_mut_from self args res_state res
      = (postcondition_from self args res /\ self = res_state)
  
  let rec from_E (self_: t_E) (return (x: t_E)) = {[@expl:from 'self_' type invariant] inv_E self_}
    any [ return (result: t_E) -> {inv_E result} {result = self_} (! return {result}) ]
  
  let rec from_residual_Result_T_E (residual: t_Result_Infallible_E) (return (x: t_Result_T_E)) =
    {[@expl:from_residual 'residual' type invariant] inv_Result_Infallible_E residual}
    any
    [ return (result: t_Result_T_E) -> {inv_Result_T_E result}
      {match { f0 = result; f1 = residual } with
        | {f0 = Err result'0; f1 = Err'0 residual'0} -> postcondition_from () residual'0 result'0
        | _ -> false
        end}
      (! return {result}) ]
  
  let rec elim_Continue (input: t_ControlFlow_Result_Infallible_E_T) (ret (f0'0: t_T)) = any
    [ good (f0'0: t_T) -> {Continue f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_T [Continue f0'0: t_ControlFlow_Result_Infallible_E_T]. Continue f0'0 <> input}
      (! {false}
      any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec try_result_T (x: t_Result_T_E) (return (x'0: t_Result_T_E)) =
    {[@expl:try_result 'x' type invariant] inv_Result_T_E x}
    (! bb0
    [ bb0 = s0
      [ s0 = branch_Result_T_E {x} (fun (_ret: t_ControlFlow_Result_Infallible_E_T) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any
      [ br0 (x0: t_T) -> {_4 = Continue x0} (! bb4) | br1 (x0: t_Result_Infallible_E) -> {_4 = Break x0} (! bb5) ]
    | bb5 = s0
      [ s0 = elim_Break {_4} (fun (r0: t_Result_Infallible_E) -> [ &residual <- r0 ] s1)
      | s1 = from_residual_Result_T_E {residual} (fun (_ret: t_Result_T_E) -> [ &_0 <- _ret ] s2)
      | s2 = bb12 ]
    | bb4 = s0 [ s0 = elim_Continue {_4} (fun (r0: t_T) -> [ &val' <- r0 ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = [ &_0 <- Ok val' ] s1 | s1 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: t_Result_T_E = Any.any_l ()
    | & x: t_Result_T_E = x
    | & _4: t_ControlFlow_Result_Infallible_E_T = Any.any_l ()
    | & residual: t_Result_Infallible_E = Any.any_l ()
    | & val': t_T = Any.any_l () ])
    [ return (result: t_Result_T_E) -> {[@expl:try_result result type invariant] inv_Result_T_E result}
      {[@expl:try_result ensures] result = x}
      (! return {result}) ]
end
module M_elim_empty
  predicate inv_Empty [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Empty
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec elim_empty (x: ()) (return (x'0: ())) = {[@expl:elim_empty 'x' type invariant] inv_Empty x}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv_Empty x} s1 | s1 = {false} any ] ] [ & x: () = x ])
    [ return (result: ()) -> (! return {result}) ]
end
