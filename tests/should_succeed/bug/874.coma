module M_874__can_extend
  use creusot.slice.Slice64
  use creusot.int.Int32
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Vec
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq Int32.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 [@inline:trivial] (self: Slice64.slice Int32.t) : Seq.seq Int32.t = Slice64.view self
  
  meta "rewrite_def" function view'0
  
  let rec into_vec (self_: Slice64.slice Int32.t) (return (x: t_Vec)) = any
    [ return (result: t_Vec) -> {view result = view'0 self_} (! return {result}) ]
  
  predicate precondition [@inline:trivial] (self: ()) (args: t_Vec) = let self_ = args in true
  
  meta "rewrite_def" predicate precondition
  
  type t_IntoIter
  
  function view'1 (self: t_IntoIter) : Seq.seq Int32.t
  
  let rec into_iter (self_: t_Vec) (return (x: t_IntoIter)) = any
    [ return (result: t_IntoIter) -> {view self_ = view'1 result} (! return {result}) ]
  
  predicate inv [@inline:trivial] (_1: t_IntoIter) = true
  
  meta "rewrite_def" predicate inv
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_IntoIter) = true
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq Int32.t) = true
  
  meta "rewrite_def" predicate inv'1
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: t_Vec) (result: t_IntoIter) =
    let self_ = args in view self_ = view'1 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: t_Vec) (result_state: ()) (result: t_IntoIter) =
    let self_ = args in view self_ = view'1 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: t_Vec) (res: t_IntoIter) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_Vec, res: t_IntoIter. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_Vec) (res_state: ()) (res: t_IntoIter) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_Vec, res_state: (), res: t_IntoIter. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: t_Vec) (result: t_IntoIter) =
    let self_ = args in view self_ = view'1 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: t_Vec) (res: t_IntoIter) : ()
  
  axiom fn_once_spec: forall self: (), args: t_Vec, res: t_IntoIter. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_Vec) (res_state: ()) (res: t_IntoIter) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: t_Vec, res_state: (), res: t_IntoIter. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq Int32.t) (rhs: t_IntoIter) =
    view'1 self = Seq.(++) visited (view'1 rhs)
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq Int32.t) (b: t_IntoIter) (bc: Seq.seq Int32.t) (c: t_IntoIter) : ()
   = ()
  
  axiom produces_trans_spec:
    forall a: t_IntoIter, ab: Seq.seq Int32.t, b: t_IntoIter, bc: Seq.seq Int32.t, c: t_IntoIter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IntoIter) : () = ()
  
  axiom produces_refl_spec: forall self: t_IntoIter. produces self (Seq.empty: Seq.seq Int32.t) self
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_IntoIter) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate completed (self: MutBorrow.t t_IntoIter) =
    resolve'0 self /\ view'1 self.current = (Seq.empty: Seq.seq Int32.t)
  
  let rec extend (self_: MutBorrow.t t_Vec) (iter: t_Vec) (return (x: ())) =
    {[@expl:extend requires] precondition () iter}
    any
    [ return (result: ()) ->
    {exists start_: t_IntoIter, done': MutBorrow.t t_IntoIter, prod: Seq.seq Int32.t. inv start_
        /\ inv'0 done'
        /\ inv'1 prod
        /\ postcondition () iter start_
        /\ completed done'
        /\ produces start_ prod done'.current /\ view self_.final = Seq.(++) (view self_.current) prod}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec can_extend (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0 = (1: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 1 = (2: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 2 = (3: Int32.t) /\ Seq.length __arr_temp.Slice64.elts = 3}-
          [ &_4 <- __arr_temp ] s1) ]
      | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_vec {_4} (fun (_ret: t_Vec) -> [ &v <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = any
        [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0 = (4: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 1 = (5: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 2 = (6: Int32.t) /\ Seq.length __arr_temp.Slice64.elts = 3}-
          [ &_8 <- __arr_temp ] s1) ]
      | s1 = bb5 ]
    | bb5 = s0 [ s0 = into_vec {_8} (fun (_ret: t_Vec) -> [ &w <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = MutBorrow.borrow_mut <t_Vec> {v}
          (fun (_ret: MutBorrow.t t_Vec) -> [ &_10 <- _ret ] [ &v <- _ret.final ] s1)
      | s1 = extend {_10} {w} (fun (_ret: ()) -> [ &_9 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = any
        [ any_ (__arr_temp: Slice64.array Int32.t) -> (! -{Seq.get __arr_temp.Slice64.elts 0 = (1: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 1 = (2: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 2 = (3: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 3 = (4: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 4 = (5: Int32.t)
          /\ Seq.get __arr_temp.Slice64.elts 5 = (6: Int32.t) /\ Seq.length __arr_temp.Slice64.elts = 6}-
          [ &_15 <- __arr_temp ] s1) ]
      | s1 = bb9 ]
    | bb9 = s0 [ s0 = into_vec {_15} (fun (_ret: t_Vec) -> [ &z <- _ret ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = {[@expl:assertion] Seq.(==) (view z) (view v)} s1 | s1 = bb13 ]
    | bb13 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & v: t_Vec = Any.any_l ()
    | & _4: Slice64.array Int32.t = Any.any_l ()
    | & w: t_Vec = Any.any_l ()
    | & _8: Slice64.array Int32.t = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & _10: MutBorrow.t t_Vec = Any.any_l ()
    | & z: t_Vec = Any.any_l ()
    | & _15: Slice64.array Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
