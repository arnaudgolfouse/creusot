module M_max_usize
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  function max_int (a: int) (b: int) : int = if a < b then b else a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec max_usize (a: UInt64.t) (b: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- UInt64.lt a b ] s1 | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- b ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_0 <- a ] s1 | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & a: UInt64.t = a | & b: UInt64.t = b | & _4: bool = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:max_usize ensures] UInt64.t'int result
      = max_int (UInt64.t'int a) (UInt64.t'int b)}
      (! return {result}) ]
end
