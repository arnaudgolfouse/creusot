module M_signed_division
  use creusot.int.Int32
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec signed_division (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- (10: Int32.t) ] s1
      | s1 = [ &y <- (1: Int32.t) ] s2
      | s2 = [ &_6 <- x ] s3
      | s3 = [ &_7 <- y ] s4
      | s4 = [ &_8 <- _7 = (0: Int32.t) ] s5
      | s5 = {[@expl:division by zero] not _8} s6
      | s6 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (-1: Int32.t) ] s1
      | s1 = [ &_10 <- _6 = (-2147483648: Int32.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0
      [ s0 = Int32.div {_6} {_7} (fun (_ret: Int32.t) -> [ &_5 <- _ret ] s1)
      | s1 = [ &_4 <- _5 = (10: Int32.t) ] s2
      | s2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] ]
    | bb3 = return {_0}
    | bb4 = {false} any ]
    [ & _0: () = Any.any_l ()
    | & x: Int32.t = Any.any_l ()
    | & y: Int32.t = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _6: Int32.t = Any.any_l ()
    | & _7: Int32.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
