module M_1562__qyi17754419174301240535__foo [#"1562.rs" 17 4 17 64] (* List<T> *)
  let%span src = "../../../creusot-contracts/src/std/rc.rs" 45 18 45 33
  let%span src'0 = "../../../creusot-contracts/src/std/rc.rs" 37 26 37 46
  let%span s1562 = "1562.rs" 16 15 16 20
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 80 26 80 51
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 434 26 434 58
  let%span soption'1 = "../../../creusot-contracts/src/std/option.rs" 150 27 150 39
  let%span soption'2 = "../../../creusot-contracts/src/std/option.rs" 151 26 151 46
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 149 14 149 36
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 109 20 109 27
  let%span sghost'1 = "../../../creusot-contracts/src/ghost.rs" 99 8 99 22
  let%span sghost'2 = "../../../creusot-contracts/src/ghost.rs" 127 8 127 22
  let%span spermcell = "../../../creusot-contracts/src/cell/permcell.rs" 191 15 191 37
  let%span spermcell'0 = "../../../creusot-contracts/src/cell/permcell.rs" 192 14 192 39
  let%span spermcell'1 = "../../../creusot-contracts/src/cell/permcell.rs" 193 14 193 30
  let%span spermcell'2 = "../../../creusot-contracts/src/cell/permcell.rs" 194 14 194 33
  let%span spermcell'3 = "../../../creusot-contracts/src/cell/permcell.rs" 34 4 34 12
  let%span spermcell'4 = "../../../creusot-contracts/src/cell/permcell.rs" 45 8 45 27
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 52 20 52 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 63 8 63 22
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Rc = { t_Rc__ptr: t_NonNull; t_Rc__phantom: (); t_Rc__alloc: () }
  
  type t_Node = { t_Node__next: t_Rc }
  
  type t_Option = C_None | C_Some t_Node
  
  type t_List = { t_List__head: t_Option }
  
  let rec is_none (self_: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  let rec take (self_: MutBorrow.t t_Option) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'0] result = self_.current /\ self_.final = C_None}
      (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t t_List) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0: MutBorrow.t t_List) = resolve _0
  
  let rec unwrap (self_: t_Option) (return' (x: t_Node)) = {[@expl:unwrap requires] [%#soption'1] self_ <> C_None}
    any [ return''0 (result: t_Node) -> {[%#soption'2] C_Some result = self_} (! return' {result}) ]
  
  let rec clone' (self_: t_Rc) (return' (x: t_Rc)) = any
    [ return''0 (result: t_Rc) -> {[%#src] result = self_} (! return' {result}) ]
  
  type t_PermCell
  
  function view (self: t_Rc) : t_PermCell
  
  let rec as_ref (self_: t_Rc) (return' (x: t_PermCell)) = any
    [ return''0 (result: t_PermCell) -> {[%#src'0] result = view self_} (! return' {result}) ]
  
  type t_PermCellOwn
  
  let rec borrow_mut (self: MutBorrow.t t_PermCellOwn) (return' (x: MutBorrow.t t_PermCellOwn)) = any
    [ return''0 (result: MutBorrow.t t_PermCellOwn) -> {[%#sghost] result = self} (! return' {result}) ]
  
  type t_Id
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function fin (self: MutBorrow.t t_PermCellOwn) : t_PermCellOwn = [%#sghost'0] self.final
  
  function val' (self: t_PermCellOwn) : t_List
  
  function view'0 (self: t_PermCellOwn) : t_List = [%#spermcell'3] val' self
  
  function view'1 (self: MutBorrow.t t_PermCellOwn) : t_List = [%#smodel] view'0 self.current
  
  function view'2 (self: MutBorrow.t t_PermCellOwn) : t_List = [%#sghost'1] view'1 self
  
  let rec borrow_mut'0 (self: t_PermCell) (perm: MutBorrow.t t_PermCellOwn) (return' (x: MutBorrow.t t_List)) =
    {[@expl:borrow_mut requires] [%#spermcell] id self = id'0 perm.current}
    any
    [ return''0 (result: MutBorrow.t t_List) -> {[%#spermcell'0] id self = id'0 (fin perm)}
      {[%#spermcell'1] result.current = view'2 perm}
      {[%#spermcell'2] result.final = view'0 (fin perm)}
      (! return' {result}) ]
  
  predicate resolve'1 (_0: t_List) = true
  
  predicate resolve'2 (self: t_PermCellOwn) = [%#spermcell'4] resolve'1 (val' self)
  
  predicate resolve'3 (_0: t_PermCellOwn) = resolve'2 _0
  
  predicate resolve'4 (self: t_PermCellOwn) = [%#sghost'2] resolve'3 self
  
  predicate resolve'5 (_0: t_PermCellOwn) = resolve'4 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec foo [#"1562.rs" 17 4 17 64] (self: MutBorrow.t t_List) (perm: t_PermCellOwn) (return' (x: ())) =
    {[@expl:foo requires] [%#s1562] false}
    (! bb0
    [ bb0 = s0 [ s0 = [ &p <- self'0 ] s1 | s1 = bb2 ]
    | bb2 = bb2'0
      [ bb2'0 = (! s0
        [ s0 = is_none {(p.current).t_List__head} (fun (_ret: bool) -> [ &_7 <- _ret ] s1) | s1 = bb3 ])
        [ bb3 = any [ br0 -> {_7 = false} (! bb5) | br1 -> {_7} (! bb4) ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <t_Option> {(p.current).t_List__head}
              {MutBorrow.inherit_id (MutBorrow.get_id p) 1}
              (fun (_ret: MutBorrow.t t_Option) ->
                [ &_11 <- _ret ] [ &p <- { p with current = { t_List__head = _ret.final } } ] s1)
          | s1 = take {_11} (fun (_ret: t_Option) -> [ &_10 <- _ret ] s2)
          | s2 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve'0 p}- s1 | s1 = unwrap {_10} (fun (_ret: t_Node) -> [ &curr <- _ret ] s2) | s2 = bb7 ]
        | bb7 = s0 [ s0 = clone' {curr.t_Node__next} (fun (_ret: t_Rc) -> [ &_12 <- _ret ] s1) | s1 = bb9 ]
        | bb9 = s0 [ s0 = [ &next <- _12 ] s1 | s1 = bb11 ]
        | bb11 = s0 [ s0 = as_ref {next} (fun (_ret: t_PermCell) -> [ &_17 <- _ret ] s1) | s1 = bb12 ]
        | bb12 = s0
          [ s0 = MutBorrow.borrow_mut <t_PermCellOwn> {perm'0}
              (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_20 <- _ret ] [ &perm'0 <- _ret.final ] s1)
          | s1 = borrow_mut {_20} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_19 <- _ret ] s2)
          | s2 = bb13 ]
        | bb13 = s0
          [ s0 = borrow_mut'0 {_17} {_19} (fun (_ret: MutBorrow.t t_List) -> [ &_15 <- _ret ] s1) | s1 = bb14 ]
        | bb14 = s0
          [ s0 = MutBorrow.borrow_final <t_List> {_15.current} {MutBorrow.get_id _15}
              (fun (_ret: MutBorrow.t t_List) -> [ &_14 <- _ret ] [ &_15 <- { _15 with current = _ret.final } ] s1)
          | s1 = [ &p <- _14 ] s2
          | s2 = -{resolve'0 _15}- s3
          | s3 = bb2'0 ] ] ]
    | bb4 = s0 [ s0 = -{resolve'0 p}- s1 | s1 = -{resolve'5 perm'0}- s2 | s2 = bb16 ]
    | bb16 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_List = self
    | & perm'0: t_PermCellOwn = perm
    | & p: MutBorrow.t t_List = Any.any_l ()
    | & next: t_Rc = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & curr: t_Node = Any.any_l ()
    | & _10: t_Option = Any.any_l ()
    | & _11: MutBorrow.t t_Option = Any.any_l ()
    | & _12: t_Rc = Any.any_l ()
    | & _14: MutBorrow.t t_List = Any.any_l ()
    | & _15: MutBorrow.t t_List = Any.any_l ()
    | & _17: t_PermCell = Any.any_l ()
    | & _19: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _20: MutBorrow.t t_PermCellOwn = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
