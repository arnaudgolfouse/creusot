module M_1562__qyi17754419174301240535__foo (* List<T> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Rc
  
  type t_Node = { t_Node__next: t_Rc }
  
  type t_Option = C_None | C_Some t_Node
  
  type t_List = { t_List__head: t_Option }
  
  let rec is_none (self_: t_Option) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = C_None)} (! return {result}) ]
  
  let rec take (self_: MutBorrow.t t_Option) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = self_.current /\ self_.final = C_None} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_List) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  let rec unwrap (self_: t_Option) (return (x: t_Node)) = {[@expl:unwrap requires] self_ <> C_None}
    any [ return (result: t_Node) -> {C_Some result = self_} (! return {result}) ]
  
  predicate resolve'0 (_1: t_Rc)
  
  predicate resolve'1 (_1: t_Node)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node [resolve'1 x]. resolve'1 x = resolve'0 x.t_Node__next
  
  let rec clone' (self_: t_Rc) (return (x: t_Rc)) = any
    [ return (result: t_Rc) -> {result = self_} (! return {result}) ]
  
  type t_PermCell
  
  function view (self: t_Rc) : t_PermCell
  
  let rec as_ref (self_: t_Rc) (return (x: t_PermCell)) = any
    [ return (result: t_PermCell) -> {result = view self_} (! return {result}) ]
  
  type t_PermCellOwn
  
  let rec borrow_mut (self: MutBorrow.t t_PermCellOwn) (return (x: MutBorrow.t t_PermCellOwn)) = any
    [ return (result: MutBorrow.t t_PermCellOwn) -> {result = self} (! return {result}) ]
  
  type t_Id
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) : t_PermCellOwn = self.final
  
  meta "rewrite_def" function fin
  
  function val' (self: t_PermCellOwn) : t_List
  
  function view'0 [@inline:trivial] (self: t_PermCellOwn) : t_List = val' self
  
  meta "rewrite_def" function view'0
  
  let rec borrow_mut'0 (self: t_PermCell) (perm: MutBorrow.t t_PermCellOwn) (return (x: MutBorrow.t t_List)) =
    {[@expl:borrow_mut requires] id self = id'0 perm.current}
    any
    [ return (result: MutBorrow.t t_List) -> {id self = id'0 (fin perm)}
      {result.current = view'0 perm.current}
      {result.final = view'0 (fin perm)}
      (! return {result}) ]
  
  predicate resolve'2 [@inline:trivial] (_1: t_List) = true
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (self: t_PermCellOwn) = resolve'2 (val' self)
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 (_1: t_PermCellOwn)
  
  axiom resolve_axiom'0: forall x: t_PermCellOwn [resolve'4 x]. resolve'4 x -> resolve'3 x
  
  predicate resolve'5 [@inline:trivial] (_1: t_PermCellOwn) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec foo (self: MutBorrow.t t_List) (perm: t_PermCellOwn) (return (x: ())) = {[@expl:foo requires] false}
    (! bb0
    [ bb0 = s0 [ s0 = [ &p <- self ] s1 | s1 = bb2 ]
    | bb2 = bb2
      [ bb2 = (! s0
        [ s0 = is_none {p.current.t_List__head} (fun (_ret: bool) -> [ &_7 <- _ret ] s1) | s1 = bb3 ])
        [ bb3 = any [ br0 -> {_7 = false} (! bb5) | br1 -> {_7} (! bb4) ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <t_Option> {p.current.t_List__head}
              {MutBorrow.inherit_id (MutBorrow.get_id p) 1}
              (fun (_ret: MutBorrow.t t_Option) ->
                [ &_11 <- _ret ] [ &p <- { p with current = { t_List__head = _ret.final } } ] s1)
          | s1 = take {_11} (fun (_ret: t_Option) -> [ &_10 <- _ret ] s2)
          | s2 = bb6 ]
        | bb6 = s0 [ s0 = -{resolve p}- s1 | s1 = unwrap {_10} (fun (_ret: t_Node) -> [ &curr <- _ret ] s2) | s2 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve'1 curr}- s1
          | s1 = clone' {curr.t_Node__next} (fun (_ret: t_Rc) -> [ &_12 <- _ret ] s2)
          | s2 = bb9 ]
        | bb9 = s0 [ s0 = [ &next <- _12 ] s1 | s1 = bb11 ]
        | bb11 = s0
          [ s0 = -{resolve'0 next}- s1
          | s1 = as_ref {next} (fun (_ret: t_PermCell) -> [ &_17 <- _ret ] s2)
          | s2 = bb12 ]
        | bb12 = s0
          [ s0 = MutBorrow.borrow_mut <t_PermCellOwn> {perm}
              (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_20 <- _ret ] [ &perm <- _ret.final ] s1)
          | s1 = borrow_mut {_20} (fun (_ret: MutBorrow.t t_PermCellOwn) -> [ &_19 <- _ret ] s2)
          | s2 = bb13 ]
        | bb13 = s0
          [ s0 = borrow_mut'0 {_17} {_19} (fun (_ret: MutBorrow.t t_List) -> [ &_15 <- _ret ] s1) | s1 = bb14 ]
        | bb14 = s0
          [ s0 = MutBorrow.borrow_final <t_List> {_15.current} {MutBorrow.get_id _15}
              (fun (_ret: MutBorrow.t t_List) -> [ &_14 <- _ret ] [ &_15 <- { _15 with current = _ret.final } ] s1)
          | s1 = [ &p <- _14 ] s2
          | s2 = -{resolve _15}- s3
          | s3 = bb2 ] ] ]
    | bb4 = s0 [ s0 = -{resolve p}- s1 | s1 = -{resolve'5 perm}- s2 | s2 = bb16 ]
    | bb16 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_List = self
    | & perm: t_PermCellOwn = perm
    | & p: MutBorrow.t t_List = Any.any_l ()
    | & next: t_Rc = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & curr: t_Node = Any.any_l ()
    | & _10: t_Option = Any.any_l ()
    | & _11: MutBorrow.t t_Option = Any.any_l ()
    | & _12: t_Rc = Any.any_l ()
    | & _14: MutBorrow.t t_List = Any.any_l ()
    | & _15: MutBorrow.t t_List = Any.any_l ()
    | & _17: t_PermCell = Any.any_l ()
    | & _19: MutBorrow.t t_PermCellOwn = Any.any_l ()
    | & _20: MutBorrow.t t_PermCellOwn = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
