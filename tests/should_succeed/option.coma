module M_option__is_some_none [#"option.rs" 4 0 4 21]
  let%span soption = "option.rs" 6 33 6 34
  let%span soption'0 = "option.rs" 8 12 8 45
  let%span soption'1 = "option.rs" 9 12 9 45
  let%span soption'2 = "option.rs" 9 12 9 45
  let%span soption'3 = "option.rs" 8 12 8 45
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 54 26 54 51
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 80 26 80 51
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec is_some (self_: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'4] result = (self_ <> C_None)} (! return' {result}) ]
  
  let rec is_none (self_: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'5] result = (self_ = C_None)} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_some_none [#"option.rs" 4 0 4 21] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = is_some {some} (fun (_ret: bool) -> [ &_5 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ]
    | bb2 = s0 [ s0 = is_some {none} (fun (_ret: bool) -> [ &_7 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = [ &_4 <- not _7 ] s1 | s1 = bb5 ]
    | bb3 = s0 [ s0 = [ &_4 <- [%#soption'0] false ] s1 | s1 = bb5 ]
    | bb5 = any [ br0 -> {_4 = false} (! bb6) | br1 -> {_4} (! bb8) ]
    | bb8 = s0 [ s0 = is_none {some} (fun (_ret: bool) -> [ &_12 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]
    | bb10 = s0 [ s0 = [ &_11 <- [%#soption'1] false ] s1 | s1 = bb13 ]
    | bb11 = s0 [ s0 = is_none {none} (fun (_ret: bool) -> [ &_11 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = any [ br0 -> {_11 = false} (! bb14) | br1 -> {_11} (! bb16) ]
    | bb16 = return''0 {_0}
    | bb14 = {[%#soption'2] false} any
    | bb6 = {[%#soption'3] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: bool = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__unwrap [#"option.rs" 12 0 12 15]
  let%span soption = "option.rs" 14 33 14 34
  let%span soption'0 = "option.rs" 16 29 16 30
  let%span soption'1 = "option.rs" 17 24 17 32
  let%span soption'2 = "option.rs" 17 37 17 38
  let%span soption'3 = "option.rs" 19 27 19 28
  let%span soption'4 = "option.rs" 19 33 19 34
  let%span soption'5 = "option.rs" 20 27 20 28
  let%span soption'6 = "option.rs" 20 33 20 34
  let%span soption'7 = "option.rs" 22 40 22 41
  let%span soption'8 = "option.rs" 23 40 23 41
  let%span soption'9 = "option.rs" 25 48 25 49
  let%span soption'10 = "option.rs" 26 41 26 42
  let%span soption'11 = "option.rs" 28 50 28 51
  let%span soption'12 = "option.rs" 28 12 28 51
  let%span soption'13 = "option.rs" 26 12 26 42
  let%span soption'14 = "option.rs" 25 12 25 49
  let%span soption'15 = "option.rs" 23 12 23 41
  let%span soption'16 = "option.rs" 22 12 22 41
  let%span soption'17 = "option.rs" 20 12 20 34
  let%span soption'18 = "option.rs" 19 12 19 34
  let%span soption'19 = "option.rs" 17 12 17 38
  let%span soption'20 = "option.rs" 16 12 16 30
  let%span soption'21 = "../../creusot-contracts/src/std/option.rs" 150 27 150 39
  let%span soption'22 = "../../creusot-contracts/src/std/option.rs" 151 26 151 46
  let%span soption'23 = "../../creusot-contracts/src/std/option.rs" 140 27 140 39
  let%span soption'24 = "../../creusot-contracts/src/std/option.rs" 141 26 141 46
  let%span soption'25 = "../../creusot-contracts/src/std/option.rs" 161 26 161 60
  let%span soption'26 = "../../creusot-contracts/src/std/option.rs" 162 26 162 84
  let%span soption'27 = "../../creusot-contracts/src/std/option.rs" 186 26 186 79
  let%span soption'28 = "../../creusot-contracts/src/std/option.rs" 187 26 187 62
  let%span soption'29 = "../../creusot-contracts/src/std/option.rs" 171 27 171 62
  let%span soption'30 = "../../creusot-contracts/src/std/option.rs" 172 26 175 17
  let%span soption'31 = "option.rs" 26 35 26 36
  let%span soption'32 = "../../creusot-contracts/src/std/option.rs" 198 27 198 39
  let%span soption'33 = "../../creusot-contracts/src/std/option.rs" 199 26 199 46
  let%span soption'34 = "option.rs" 25 32 25 34
  let%span soption'35 = "option.rs" 26 32 26 34
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 4 133 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 4 134 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 4 139 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 4 144 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 4 145 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 4 146 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec unwrap (self_: t_Option) (return' (x: Int32.t)) = {[@expl:unwrap requires] [%#soption'21] self_ <> C_None}
    any [ return''0 (result: Int32.t) -> {[%#soption'22] C_Some result = self_} (! return' {result}) ]
  
  let rec expect (self_: t_Option) (msg: string) (return' (x: Int32.t)) = {[@expl:expect requires] [%#soption'23] self_
    <> C_None}
    any [ return''0 (result: Int32.t) -> {[%#soption'24] C_Some result = self_} (! return' {result}) ]
  
  predicate resolve (_0: Int32.t) = true
  
  let rec unwrap_or (self_: t_Option) (default: Int32.t) (return' (x: Int32.t)) = any
    [ return''0 (result: Int32.t) -> {[%#soption'25] self_ = C_None -> result = default}
      {[%#soption'26] self_ = C_None \/ self_ = C_Some result /\ resolve default}
      (! return' {result}) ]
  
  predicate postcondition_once (self: ()) (args: ()) (result: Int32.t) = let () = args in result = (0: Int32.t)
  
  predicate resolve'0 (_0: ()) = true
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  function fn_mut_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: Int32.t. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) = true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: Int32.t. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: Int32.t) = let () = args in result = (0: Int32.t)
  
  function fn_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: Int32.t. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve'0 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: (), res_state: (), res: Int32.t. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return' (x: Int32.t)) = any
    [ return''0 (result: Int32.t) -> {[%#snum] result = (0: Int32.t)} (! return' {result}) ]
  
  let rec unwrap_or_default (self_: t_Option) (return' (x: Int32.t)) = any
    [ return''0 (result: Int32.t) -> {[%#soption'27] self_ = C_None -> postcondition () () result}
      {[%#soption'28] self_ = C_None \/ self_ = C_Some result}
      (! return' {result}) ]
  
  let rec closure0 [#"option.rs" 25 32 25 34] [@coma:extspec] (self: ()) (return' (x: Int32.t)) = bb0
    [ bb0 = {false} any ]
  
  predicate precondition (self: ()) (args: ()) = [%#soption'34] let () = args in closure0'pre self
  
  predicate postcondition_once'0 (self: ()) (args: ()) (result: Int32.t) =
    [%#soption'34] let () = args in closure0'post'return' self result
  
  let rec unwrap_or_else (self_: t_Option) (f: ()) (return' (x: Int32.t)) =
    {[@expl:unwrap_or_else requires] [%#soption'29] self_ = C_None -> precondition f ()}
    any
    [ return''0 (result: Int32.t) -> {[%#soption'30] match self_ with
        | C_None -> postcondition_once'0 f () result
        | C_Some t -> result = t
        end}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 26 32 26 34] [@coma:extspec] (self: ()) (return' (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- [%#soption'31] (3: Int32.t) ] s1 | s1 = return' {_0} ] ] [ & _0: Int32.t = Any.any_l () ]
  
  predicate precondition'0 (self: ()) (args: ()) = [%#soption'35] let () = args in closure1'pre self
  
  predicate postcondition_once'1 (self: ()) (args: ()) (result: Int32.t) =
    [%#soption'35] let () = args in closure1'post'return' self result
  
  let rec unwrap_or_else'0 (self_: t_Option) (f: ()) (return' (x: Int32.t)) =
    {[@expl:unwrap_or_else requires] [%#soption'29] self_ = C_None -> precondition'0 f ()}
    any
    [ return''0 (result: Int32.t) -> {[%#soption'30] match self_ with
        | C_None -> postcondition_once'1 f () result
        | C_Some t -> result = t
        end}
      (! return' {result}) ]
  
  let rec unwrap_unchecked (self_: t_Option) (return' (x: Int32.t)) =
    {[@expl:unwrap_unchecked requires] [%#soption'32] self_ <> C_None}
    any [ return''0 (result: Int32.t) -> {[%#soption'33] C_Some result = self_} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec unwrap'0 [#"option.rs" 12 0 12 15] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = unwrap {some} (fun (_ret: Int32.t) -> [ &_5 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_4 <- _5 = ([%#soption'0] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb4) ] ]
    | bb4 = s0
      [ s0 = [ &_13 <- [%#soption'1] "failed" ] s1
      | s1 = expect {some} {_13} (fun (_ret: Int32.t) -> [ &_10 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_9 <- _10 = ([%#soption'2] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb8) ] ]
    | bb8 = s0
      [ s0 = unwrap_or {some} {[%#soption'3] (2: Int32.t)} (fun (_ret: Int32.t) -> [ &_17 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_16 <- _17 = ([%#soption'4] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb12) ] ]
    | bb12 = s0
      [ s0 = unwrap_or {none} {[%#soption'5] (2: Int32.t)} (fun (_ret: Int32.t) -> [ &_22 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_21 <- _22 = ([%#soption'6] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb14) | br1 -> {_21} (! bb16) ] ]
    | bb16 = s0 [ s0 = unwrap_or_default {some} (fun (_ret: Int32.t) -> [ &_27 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_26 <- _27 = ([%#soption'7] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_26 = false} (! bb18) | br1 -> {_26} (! bb20) ] ]
    | bb20 = s0 [ s0 = unwrap_or_default {none} (fun (_ret: Int32.t) -> [ &_32 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = s0
      [ s0 = [ &_31 <- _32 = ([%#soption'8] (0: Int32.t)) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb22) | br1 -> {_31} (! bb24) ] ]
    | bb24 = s0
      [ s0 = [ &_39 <- () ] s1
      | s1 = unwrap_or_else {some} {_39} (fun (_ret: Int32.t) -> [ &_37 <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0
      [ s0 = [ &_36 <- _37 = ([%#soption'9] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_36 = false} (! bb26) | br1 -> {_36} (! bb28) ] ]
    | bb28 = s0
      [ s0 = [ &_45 <- () ] s1
      | s1 = unwrap_or_else'0 {none} {_45} (fun (_ret: Int32.t) -> [ &_43 <- _ret ] s2)
      | s2 = bb29 ]
    | bb29 = s0
      [ s0 = [ &_42 <- _43 = ([%#soption'10] (3: Int32.t)) ] s1
      | s1 = any [ br0 -> {_42 = false} (! bb30) | br1 -> {_42} (! bb32) ] ]
    | bb32 = s0 [ s0 = unwrap_unchecked {some} (fun (_ret: Int32.t) -> [ &_49 <- _ret ] s1) | s1 = bb33 ]
    | bb33 = s0
      [ s0 = [ &_48 <- _49 = ([%#soption'11] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_48 = false} (! bb34) | br1 -> {_48} (! bb36) ] ]
    | bb36 = return''0 {_0}
    | bb34 = {[%#soption'12] false} any
    | bb30 = {[%#soption'13] false} any
    | bb26 = {[%#soption'14] false} any
    | bb22 = {[%#soption'15] false} any
    | bb18 = {[%#soption'16] false} any
    | bb14 = {[%#soption'17] false} any
    | bb10 = {[%#soption'18] false} any
    | bb6 = {[%#soption'19] false} any
    | bb2 = {[%#soption'20] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: Int32.t = Any.any_l ()
    | & _13: string = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: Int32.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: Int32.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _32: Int32.t = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _37: Int32.t = Any.any_l ()
    | & _39: () = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _43: Int32.t = Any.any_l ()
    | & _45: () = Any.any_l ()
    | & _48: bool = Any.any_l ()
    | & _49: Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__map [#"option.rs" 31 0 31 12]
  let%span soption = "option.rs" 33 33 33 34
  let%span soption'0 = "option.rs" 36 36 36 37
  let%span soption'1 = "option.rs" 37 40 37 41
  let%span soption'2 = "option.rs" 37 12 37 42
  let%span soption'3 = "option.rs" 36 12 36 38
  let%span soption'4 = "option.rs" 35 12 35 42
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 208 27 211 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 212 26 215 17
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'8 = "option.rs" 36 25 36 26
  let%span soption'9 = "option.rs" 37 29 37 30
  let%span soption'10 = "option.rs" 35 21 35 24
  let%span soption'11 = "option.rs" 36 21 36 24
  let%span soption'12 = "option.rs" 37 21 37 24
  let%span soption'13 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  let%span stuples = "../../creusot-contracts/src/std/tuples.rs" 9 20 9 22
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec closure0 [#"option.rs" 35 21 35 24] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: ())) = bb0
    [ bb0 = {false} any ]
  
  type t_Option'0 = C_None'0 | C_Some'0 ()
  
  predicate precondition (self: ()) (args: Int32.t) = [%#soption'10] let _0 = args in closure0'pre self _0
  
  predicate postcondition_once (self: ()) (args: Int32.t) (result: ()) =
    [%#soption'10] let _0 = args in closure0'post'return' self _0 result
  
  let rec map (self_: t_Option) (f: ()) (return' (x: t_Option'0)) = {[@expl:map requires] [%#soption'5] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    any
    [ return''0 (result: t_Option'0) -> {[%#soption'6] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> exists r: (). result = C_Some'0 r /\ postcondition_once f t r
        end}
      (! return' {result}) ]
  
  function deep_model (self: ()) : () = [%#stuples] ()
  
  function deep_model'0 (self: t_Option'0) : t_Option'0 = [%#soption'13] match self with
      | C_Some'0 t -> C_Some'0 (deep_model t)
      | C_None'0 -> C_None'0
      end
  
  function deep_model'1 (self: t_Option'0) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option'0) (rhs: t_Option'0) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'7] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 36 21 36 24] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_0'0 <- [%#soption'8] (3: Int32.t) ] s1 | s1 = return' {_0'0} ] ]
    [ & _0'0: Int32.t = Any.any_l () ]
  
  predicate precondition'0 (self: ()) (args: Int32.t) = [%#soption'11] let _0 = args in closure1'pre self _0
  
  predicate postcondition_once'0 (self: ()) (args: Int32.t) (result: Int32.t) =
    [%#soption'11] let _0 = args in closure1'post'return' self _0 result
  
  let rec map'0 (self_: t_Option) (f: ()) (return' (x: t_Option)) = {[@expl:map requires] [%#soption'5] match self_ with
      | C_None -> true
      | C_Some t -> precondition'0 f t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'6] match self_ with
        | C_None -> result = C_None
        | C_Some t -> exists r: Int32.t. result = C_Some r /\ postcondition_once'0 f t r
        end}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 int
  
  function deep_model'2 (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'3 (self: t_Option) : t_Option'1 = [%#soption'13] match self with
      | C_Some t -> C_Some'1 (deep_model'2 t)
      | C_None -> C_None'1
      end
  
  function deep_model'4 (self: t_Option) : t_Option'1 = [%#smodel] deep_model'3 self
  
  let rec eq'0 (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'7] result = (deep_model'4 self_ = deep_model'4 rhs)}
      (! return' {result}) ]
  
  let rec closure2 [#"option.rs" 37 21 37 24] [@coma:extspec] (self: ()) (x: Int32.t) (return' (x'0: Int32.t)) = bb0
    [ bb0 = s0
      [ s0 = Int32.add {x'0} {[%#soption'9] (1: Int32.t)} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1)
      | s1 = return' {_0} ] ] [ & _0: Int32.t = Any.any_l () | & x'0: Int32.t = x ]
  
  predicate precondition'1 (self: ()) (args: Int32.t) = [%#soption'12] let x = args in closure2'pre self x
  
  predicate postcondition_once'1 (self: ()) (args: Int32.t) (result: Int32.t) =
    [%#soption'12] let x = args in closure2'post'return' self x result
  
  let rec map'1 (self_: t_Option) (f: ()) (return' (x: t_Option)) = {[@expl:map requires] [%#soption'5] match self_ with
      | C_None -> true
      | C_Some t -> precondition'1 f t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'6] match self_ with
        | C_None -> result = C_None
        | C_Some t -> exists r: Int32.t. result = C_Some r /\ postcondition_once'1 f t r
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec map'2 [#"option.rs" 31 0 31 12] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = map {none} {_8} (fun (_ret: t_Option'0) -> [ &_6 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None'0 ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option'0 = Any.any_l () | & _1: t_Option'0 = Any.any_l () ]
        [ _const_ret (_const: t_Option'0) -> [ &_32 <- _const ] s1 ]
      | s1 = eq {_6} {_32} (fun (_ret: bool) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &_17 <- () ] s1 | s1 = map'0 {some} {_17} (fun (_ret: t_Option) -> [ &_15 <- _ret ] s2) | s2 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'0] (3: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_31 <- _const ] s1 ]
      | s1 = eq'0 {_15} {_31} (fun (_ret: bool) -> [ &_13 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb10) ]
    | bb10 = s0
      [ s0 = [ &_26 <- () ] s1 | s1 = map'1 {some} {_26} (fun (_ret: t_Option) -> [ &_24 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'1] (2: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_30 <- _const ] s1 ]
      | s1 = eq'0 {_24} {_30} (fun (_ret: bool) -> [ &_22 <- _ret ] s2)
      | s2 = bb12 ]
    | bb12 = any [ br0 -> {_22 = false} (! bb13) | br1 -> {_22} (! bb15) ]
    | bb15 = return''0 {_0}
    | bb13 = {[%#soption'2] false} any
    | bb8 = {[%#soption'3] false} any
    | bb3 = {[%#soption'4] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _30: t_Option = Any.any_l ()
    | & _31: t_Option = Any.any_l ()
    | & _32: t_Option'0 = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__inspect [#"option.rs" 40 0 40 16]
  let%span soption = "option.rs" 42 33 42 34
  let%span soption'0 = "option.rs" 45 41 45 42
  let%span soption'1 = "option.rs" 45 12 45 43
  let%span soption'2 = "option.rs" 44 12 44 46
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 225 27 228 17
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 229 26 229 40
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 230 26 233 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'7 = "option.rs" 44 25 44 28
  let%span soption'8 = "option.rs" 45 25 45 28
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec closure0 [#"option.rs" 44 25 44 28] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: ())) = bb0
    [ bb0 = {false} any ]
  
  predicate precondition (self: ()) (args: Int32.t) = [%#soption'7] let _0 = args in closure0'pre self _0
  
  predicate postcondition_once (self: ()) (args: Int32.t) (result: ()) =
    [%#soption'7] let _0 = args in closure0'post'return' self _0 result
  
  let rec inspect (self_: t_Option) (f: ()) (return' (x: t_Option)) =
    {[@expl:inspect requires] [%#soption'3] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'4] result = self_}
      {[%#soption'5] match self_ with
        | C_None -> true
        | C_Some t -> postcondition_once f t ()
        end}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option) : t_Option'0 = [%#soption'9] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'6] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 45 25 45 28] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: ())) = bb0
    [ bb0 = return' {_0'0} ] [ & _0'0: () = Any.any_l () ]
  
  predicate precondition'0 (self: ()) (args: Int32.t) = [%#soption'8] let _0 = args in closure1'pre self _0
  
  predicate postcondition_once'0 (self: ()) (args: Int32.t) (result: ()) =
    [%#soption'8] let _0 = args in closure1'post'return' self _0 result
  
  let rec inspect'0 (self_: t_Option) (f: ()) (return' (x: t_Option)) =
    {[@expl:inspect requires] [%#soption'3] match self_ with
      | C_None -> true
      | C_Some t -> precondition'0 f t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'4] result = self_}
      {[%#soption'5] match self_ with
        | C_None -> true
        | C_Some t -> postcondition_once'0 f t ()
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec inspect'1 [#"option.rs" 40 0 40 16] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = inspect {none} {_8} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_22 <- _const ] s1 ]
      | s1 = eq {_6} {_22} (fun (_ret: bool) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &_17 <- () ] s1 | s1 = inspect'0 {some} {_17} (fun (_ret: t_Option) -> [ &_15 <- _ret ] s2) | s2 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'0] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_21 <- _const ] s1 ]
      | s1 = eq {_15} {_21} (fun (_ret: bool) -> [ &_13 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb10) ]
    | bb10 = return''0 {_0}
    | bb8 = {[%#soption'1] false} any
    | bb3 = {[%#soption'2] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _21: t_Option = Any.any_l ()
    | & _22: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__map_or [#"option.rs" 48 0 48 15]
  let%span soption = "option.rs" 50 33 50 34
  let%span soption'0 = "option.rs" 53 24 53 25
  let%span soption'1 = "option.rs" 53 44 53 45
  let%span soption'2 = "option.rs" 54 24 54 26
  let%span soption'3 = "option.rs" 54 38 54 39
  let%span soption'4 = "option.rs" 55 24 55 26
  let%span soption'5 = "option.rs" 55 42 55 43
  let%span soption'6 = "option.rs" 58 52 58 53
  let%span soption'7 = "option.rs" 59 56 59 57
  let%span soption'8 = "option.rs" 59 12 59 57
  let%span soption'9 = "option.rs" 58 12 58 53
  let%span soption'10 = "option.rs" 55 12 55 43
  let%span soption'11 = "option.rs" 54 12 54 39
  let%span soption'12 = "option.rs" 53 12 53 45
  let%span soption'13 = "../../creusot-contracts/src/std/option.rs" 243 27 246 17
  let%span soption'14 = "../../creusot-contracts/src/std/option.rs" 247 26 250 17
  let%span soption'15 = "option.rs" 54 32 54 33
  let%span soption'16 = "option.rs" 55 36 55 37
  let%span soption'17 = "option.rs" 58 32 58 33
  let%span soption'18 = "../../creusot-contracts/src/std/option.rs" 260 27 263 17
  let%span soption'19 = "../../creusot-contracts/src/std/option.rs" 264 26 267 17
  let%span soption'20 = "option.rs" 59 50 59 51
  let%span soption'21 = "option.rs" 53 27 53 30
  let%span soption'22 = "option.rs" 54 28 54 31
  let%span soption'23 = "option.rs" 55 28 55 31
  let%span soption'24 = "option.rs" 58 29 58 31
  let%span soption'25 = "option.rs" 58 35 58 38
  let%span soption'26 = "option.rs" 59 29 59 31
  let%span soption'27 = "option.rs" 59 42 59 45
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec closure0 [#"option.rs" 53 27 53 30] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: Int32.t)) = bb0
    [ bb0 = {false} any ]
  
  predicate precondition (self: ()) (args: Int32.t) = [%#soption'21] let _0 = args in closure0'pre self _0
  
  predicate postcondition_once (self: ()) (args: Int32.t) (result: Int32.t) =
    [%#soption'21] let _0 = args in closure0'post'return' self _0 result
  
  let rec map_or (self_: t_Option) (default: Int32.t) (f: ()) (return' (x: Int32.t)) =
    {[@expl:map_or requires] [%#soption'13] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    any
    [ return''0 (result: Int32.t) -> {[%#soption'14] match self_ with
        | C_None -> result = default
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 54 28 54 31] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_0'0 <- [%#soption'15] (3: Int32.t) ] s1 | s1 = return' {_0'0} ] ]
    [ & _0'0: Int32.t = Any.any_l () ]
  
  predicate precondition'0 (self: ()) (args: Int32.t) = [%#soption'22] let _0 = args in closure1'pre self _0
  
  predicate postcondition_once'0 (self: ()) (args: Int32.t) (result: Int32.t) =
    [%#soption'22] let _0 = args in closure1'post'return' self _0 result
  
  let rec map_or'0 (self_: t_Option) (default: Int32.t) (f: ()) (return' (x: Int32.t)) =
    {[@expl:map_or requires] [%#soption'13] match self_ with
      | C_None -> true
      | C_Some t -> precondition'0 f t
      end}
    any
    [ return''0 (result: Int32.t) -> {[%#soption'14] match self_ with
        | C_None -> result = default
        | C_Some t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]
  
  let rec closure2 [#"option.rs" 55 28 55 31] [@coma:extspec] (self: ()) (x: Int32.t) (return' (x'0: Int32.t)) = bb0
    [ bb0 = s0
      [ s0 = Int32.add {x'0} {[%#soption'16] (1: Int32.t)} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1)
      | s1 = return' {_0} ] ] [ & _0: Int32.t = Any.any_l () | & x'0: Int32.t = x ]
  
  predicate precondition'1 (self: ()) (args: Int32.t) = [%#soption'23] let x = args in closure2'pre self x
  
  predicate postcondition_once'1 (self: ()) (args: Int32.t) (result: Int32.t) =
    [%#soption'23] let x = args in closure2'post'return' self x result
  
  let rec map_or'1 (self_: t_Option) (default: Int32.t) (f: ()) (return' (x: Int32.t)) =
    {[@expl:map_or requires] [%#soption'13] match self_ with
      | C_None -> true
      | C_Some t -> precondition'1 f t
      end}
    any
    [ return''0 (result: Int32.t) -> {[%#soption'14] match self_ with
        | C_None -> result = default
        | C_Some t -> postcondition_once'1 f t result
        end}
      (! return' {result}) ]
  
  let rec closure3 [#"option.rs" 58 29 58 31] [@coma:extspec] (self: ()) (return' (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- [%#soption'17] (2: Int32.t) ] s1 | s1 = return' {_0} ] ] [ & _0: Int32.t = Any.any_l () ]
  
  let rec closure4 [#"option.rs" 58 35 58 38] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: Int32.t)) = bb0
    [ bb0 = {false} any ]
  
  predicate precondition'2 (self: ()) (args: ()) = [%#soption'24] let () = args in closure3'pre self
  
  predicate precondition'3 (self: ()) (args: Int32.t) = [%#soption'25] let _0 = args in closure4'pre self _0
  
  predicate postcondition_once'2 (self: ()) (args: ()) (result: Int32.t) =
    [%#soption'24] let () = args in closure3'post'return' self result
  
  predicate postcondition_once'3 (self: ()) (args: Int32.t) (result: Int32.t) =
    [%#soption'25] let _0 = args in closure4'post'return' self _0 result
  
  let rec map_or_else (self_: t_Option) (default: ()) (f: ()) (return' (x: Int32.t)) =
    {[@expl:map_or_else requires] [%#soption'18] match self_ with
      | C_None -> precondition'2 default ()
      | C_Some t -> precondition'3 f t
      end}
    any
    [ return''0 (result: Int32.t) -> {[%#soption'19] match self_ with
        | C_None -> postcondition_once'2 default () result
        | C_Some t -> postcondition_once'3 f t result
        end}
      (! return' {result}) ]
  
  let rec closure5 [#"option.rs" 59 29 59 31] [@coma:extspec] (self: ()) (return' (x: Int32.t)) = bb0
    [ bb0 = {false} any ]
  
  let rec closure6 [#"option.rs" 59 42 59 45] [@coma:extspec] (self: ()) (x: Int32.t) (return' (x'0: Int32.t)) = bb0
    [ bb0 = s0
      [ s0 = Int32.add {x'0} {[%#soption'20] (1: Int32.t)} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1)
      | s1 = return' {_0} ] ] [ & _0: Int32.t = Any.any_l () | & x'0: Int32.t = x ]
  
  predicate precondition'4 (self: ()) (args: ()) = [%#soption'26] let () = args in closure5'pre self
  
  predicate precondition'5 (self: ()) (args: Int32.t) = [%#soption'27] let x = args in closure6'pre self x
  
  predicate postcondition_once'4 (self: ()) (args: ()) (result: Int32.t) =
    [%#soption'26] let () = args in closure5'post'return' self result
  
  predicate postcondition_once'5 (self: ()) (args: Int32.t) (result: Int32.t) =
    [%#soption'27] let x = args in closure6'post'return' self x result
  
  let rec map_or_else'0 (self_: t_Option) (default: ()) (f: ()) (return' (x: Int32.t)) =
    {[@expl:map_or_else requires] [%#soption'18] match self_ with
      | C_None -> precondition'4 default ()
      | C_Some t -> precondition'5 f t
      end}
    any
    [ return''0 (result: Int32.t) -> {[%#soption'19] match self_ with
        | C_None -> postcondition_once'4 default () result
        | C_Some t -> postcondition_once'5 f t result
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec map_or'2 [#"option.rs" 48 0 48 15] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &_7 <- () ] s3
      | s3 = map_or {none} {[%#soption'0] (2: Int32.t)} {_7} (fun (_ret: Int32.t) -> [ &_5 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_4 <- _5 = ([%#soption'1] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb4) ] ]
    | bb4 = s0
      [ s0 = [ &_13 <- () ] s1
      | s1 = map_or'0 {some} {[%#soption'2] (-1: Int32.t)} {_13} (fun (_ret: Int32.t) -> [ &_11 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_10 <- _11 = ([%#soption'3] (3: Int32.t)) ] s1
      | s1 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb8) ] ]
    | bb8 = s0
      [ s0 = [ &_19 <- () ] s1
      | s1 = map_or'1 {some} {[%#soption'4] (-1: Int32.t)} {_19} (fun (_ret: Int32.t) -> [ &_17 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_16 <- _17 = ([%#soption'5] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb12) ] ]
    | bb12 = s0
      [ s0 = [ &_25 <- () ] s1
      | s1 = [ &_26 <- () ] s2
      | s2 = map_or_else {none} {_25} {_26} (fun (_ret: Int32.t) -> [ &_23 <- _ret ] s3)
      | s3 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_22 <- _23 = ([%#soption'6] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_22 = false} (! bb14) | br1 -> {_22} (! bb16) ] ]
    | bb16 = s0
      [ s0 = [ &_32 <- () ] s1
      | s1 = [ &_33 <- () ] s2
      | s2 = map_or_else'0 {some} {_32} {_33} (fun (_ret: Int32.t) -> [ &_30 <- _ret ] s3)
      | s3 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_29 <- _30 = ([%#soption'7] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_29 = false} (! bb18) | br1 -> {_29} (! bb20) ] ]
    | bb20 = return''0 {_0}
    | bb18 = {[%#soption'8] false} any
    | bb14 = {[%#soption'9] false} any
    | bb10 = {[%#soption'10] false} any
    | bb6 = {[%#soption'11] false} any
    | bb2 = {[%#soption'12] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _7: () = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int32.t = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: Int32.t = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _23: Int32.t = Any.any_l ()
    | & _25: () = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: Int32.t = Any.any_l ()
    | & _32: () = Any.any_l ()
    | & _33: () = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__ok_or [#"option.rs" 62 0 62 14]
  let%span soption = "option.rs" 64 33 64 34
  let%span soption'0 = "option.rs" 66 25 66 29
  let%span soption'1 = "option.rs" 67 18 67 34
  let%span soption'2 = "option.rs" 68 24 68 29
  let%span soption'3 = "option.rs" 69 18 69 32
  let%span soption'4 = "option.rs" 72 18 72 34
  let%span soption'5 = "option.rs" 74 18 74 32
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 279 26 282 17
  let%span soption'7 = "option.rs" 71 33 71 37
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 290 27 290 64
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 291 26 294 17
  let%span soption'10 = "option.rs" 73 32 73 37
  let%span soption'11 = "option.rs" 71 30 71 32
  let%span soption'12 = "option.rs" 73 29 73 31
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  type t_Result = C_Ok Int32.t | C_Err bool
  
  predicate resolve (_0: bool) = true
  
  let rec ok_or (self_: t_Option) (err: bool) (return' (x: t_Result)) = any
    [ return''0 (result: t_Result) -> {[%#soption'6] match self_ with
        | C_None -> result = C_Err err
        | C_Some t -> result = C_Ok t /\ resolve err
        end}
      (! return' {result}) ]
  
  let rec closure0 [#"option.rs" 71 30 71 32] [@coma:extspec] (self: ()) (return' (x: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- [%#soption'7] true ] s1 | s1 = return' {_0} ] ] [ & _0: bool = Any.any_l () ]
  
  predicate precondition (self: ()) (args: ()) = [%#soption'11] let () = args in closure0'pre self
  
  predicate postcondition_once (self: ()) (args: ()) (result: bool) =
    [%#soption'11] let () = args in closure0'post'return' self result
  
  let rec ok_or_else (self_: t_Option) (err: ()) (return' (x: t_Result)) =
    {[@expl:ok_or_else requires] [%#soption'8] self_ = C_None -> precondition err ()}
    any
    [ return''0 (result: t_Result) -> {[%#soption'9] match self_ with
        | C_None -> exists r: bool. result = C_Err r /\ postcondition_once err () r
        | C_Some t -> result = C_Ok t
        end}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 73 29 73 31] [@coma:extspec] (self: ()) (return' (x: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- [%#soption'10] false ] s1 | s1 = return' {_0} ] ] [ & _0: bool = Any.any_l () ]
  
  predicate precondition'0 (self: ()) (args: ()) = [%#soption'12] let () = args in closure1'pre self
  
  predicate postcondition_once'0 (self: ()) (args: ()) (result: bool) =
    [%#soption'12] let () = args in closure1'post'return' self result
  
  let rec ok_or_else'0 (self_: t_Option) (err: ()) (return' (x: t_Result)) =
    {[@expl:ok_or_else requires] [%#soption'8] self_ = C_None -> precondition'0 err ()}
    any
    [ return''0 (result: t_Result) -> {[%#soption'9] match self_ with
        | C_None -> exists r: bool. result = C_Err r /\ postcondition_once'0 err () r
        | C_Some t -> result = C_Ok t
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ok_or'0 [#"option.rs" 62 0 62 14] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = ok_or {none} {[%#soption'0] true} (fun (_ret: t_Result) -> [ &err <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#soption'1] err = C_Err true} s1
      | s1 = ok_or {some} {[%#soption'2] false} (fun (_ret: t_Result) -> [ &ok <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:assertion] [%#soption'3] ok = C_Ok (1: Int32.t)} s1
      | s1 = [ &_13 <- () ] s2
      | s2 = ok_or_else {none} {_13} (fun (_ret: t_Result) -> [ &err'0 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#soption'4] err'0 = C_Err true} s1
      | s1 = [ &_18 <- () ] s2
      | s2 = ok_or_else'0 {some} {_18} (fun (_ret: t_Result) -> [ &ok'0 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = s0 [ s0 = {[@expl:assertion] [%#soption'5] ok'0 = C_Ok (1: Int32.t)} s1 | s1 = return''0 {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & err: t_Result = Any.any_l ()
    | & ok: t_Result = Any.any_l ()
    | & err'0: t_Result = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & ok'0: t_Result = Any.any_l ()
    | & _18: () = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__as_mut [#"option.rs" 77 0 77 15]
  let%span soption = "option.rs" 79 37 79 38
  let%span soption'0 = "option.rs" 82 30 82 31
  let%span soption'1 = "option.rs" 83 29 83 30
  let%span soption'2 = "option.rs" 84 30 84 31
  let%span soption'3 = "option.rs" 85 29 85 30
  let%span soption'4 = "option.rs" 85 12 85 30
  let%span soption'5 = "option.rs" 83 12 83 30
  let%span soption'6 = "option.rs" 81 12 81 35
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 100 26 100 75
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 102 20 103 100
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 80 26 80 51
  let%span soption'10 = "../../creusot-contracts/src/std/option.rs" 150 27 150 39
  let%span soption'11 = "../../creusot-contracts/src/std/option.rs" 151 26 151 46
  let%span soption'12 = "../../creusot-contracts/src/std/option.rs" 787 8 790 9
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t Int32.t)
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'0)) = any
    [ return''0 (result: t_Option'0) -> {[%#soption'7] self_.current = C_None
      -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'8] self_.current = C_None
      \/ (exists r: MutBorrow.t Int32.t. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec is_none (self_: t_Option'0) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'9] result = (self_ = C_None'0)} (! return' {result}) ]
  
  predicate resolve (self: MutBorrow.t Int32.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0: MutBorrow.t Int32.t) = resolve _0
  
  predicate resolve'1 (self: t_Option'0) =
    [%#soption'12] match self with
      | C_Some'0 x -> resolve'0 x
      | C_None'0 -> true
      end
  
  predicate resolve'2 (_0: t_Option'0) = resolve'1 _0
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t Int32.t)) = {[@expl:unwrap requires] [%#soption'10] self_
    <> C_None'0}
    any [ return''0 (result: MutBorrow.t Int32.t) -> {[%#soption'11] C_Some'0 result = self_} (! return' {result}) ]
  
  let rec unwrap'0 (self_: t_Option) (return' (x: Int32.t)) = {[@expl:unwrap requires] [%#soption'10] self_ <> C_None}
    any [ return''0 (result: Int32.t) -> {[%#soption'11] C_Some result = self_} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_mut'0 [#"option.rs" 77 0 77 15] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_7 <- _ret ] [ &none <- _ret.final ] s3)
      | s3 = as_mut {_7} (fun (_ret: t_Option'0) -> [ &_6 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = -{resolve'2 _6}- s1 | s1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ] ]
    | bb5 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_11 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = as_mut {_11} (fun (_ret: t_Option'0) -> [ &_10 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = unwrap {_10} (fun (_ret: MutBorrow.t Int32.t) -> [ &_9 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_9 <- { _9 with current = ([%#soption'0] (2: Int32.t)) } ] s1
      | s1 = -{resolve'0 _9}- s2
      | s2 = unwrap'0 {some} (fun (_ret: Int32.t) -> [ &_14 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = s0
      [ s0 = [ &_13 <- _14 = ([%#soption'1] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_13 = false} (! bb9) | br1 -> {_13} (! bb11) ] ]
    | bb11 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_19 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = as_mut {_19} (fun (_ret: t_Option'0) -> [ &_18 <- _ret ] s2)
      | s2 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_18} (fun (_ret: MutBorrow.t Int32.t) -> [ &_17 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_17 <- { _17 with current = ([%#soption'2] (1: Int32.t)) } ] s1
      | s1 = -{resolve'0 _17}- s2
      | s2 = unwrap'0 {some} (fun (_ret: Int32.t) -> [ &_22 <- _ret ] s3)
      | s3 = bb14 ]
    | bb14 = s0
      [ s0 = [ &_21 <- _22 = ([%#soption'3] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb17) ] ]
    | bb17 = return''0 {_0}
    | bb15 = {[%#soption'4] false} any
    | bb9 = {[%#soption'5] false} any
    | bb3 = {[%#soption'6] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l ()
    | & _7: MutBorrow.t t_Option = Any.any_l ()
    | & _9: MutBorrow.t Int32.t = Any.any_l ()
    | & _10: t_Option'0 = Any.any_l ()
    | & _11: MutBorrow.t t_Option = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _17: MutBorrow.t Int32.t = Any.any_l ()
    | & _18: t_Option'0 = Any.any_l ()
    | & _19: MutBorrow.t t_Option = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__as_ref [#"option.rs" 88 0 88 15]
  let%span soption = "option.rs" 90 33 90 34
  let%span soption'0 = "option.rs" 93 39 93 40
  let%span soption'1 = "option.rs" 93 12 93 40
  let%span soption'2 = "option.rs" 92 12 92 35
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 87 26 87 58
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 89 20 89 89
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 80 26 80 51
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 150 27 150 39
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 151 26 151 46
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  type t_Option'0 = C_None'0 | C_Some'0 Int32.t
  
  let rec as_ref (self_: t_Option) (return' (x: t_Option'0)) = any
    [ return''0 (result: t_Option'0) -> {[%#soption'3] self_ = C_None -> result = C_None'0}
      {[%#soption'4] self_ = C_None \/ (exists r: Int32.t. result = C_Some'0 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  let rec is_none (self_: t_Option'0) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'5] result = (self_ = C_None'0)} (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: Int32.t)) = {[@expl:unwrap requires] [%#soption'6] self_ <> C_None'0}
    any [ return''0 (result: Int32.t) -> {[%#soption'7] C_Some'0 result = self_} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_ref'0 [#"option.rs" 88 0 88 15] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = as_ref {none} (fun (_ret: t_Option'0) -> [ &_6 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0 [ s0 = as_ref {some} (fun (_ret: t_Option'0) -> [ &_13 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = unwrap {_13} (fun (_ret: Int32.t) -> [ &_12 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_10 <- _12 = ([%#soption'0] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_10 = false} (! bb8) | br1 -> {_10} (! bb10) ] ]
    | bb10 = return''0 {_0}
    | bb8 = {[%#soption'1] false} any
    | bb3 = {[%#soption'2] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _12: Int32.t = Any.any_l ()
    | & _13: t_Option'0 = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__replace [#"option.rs" 96 0 96 16]
  let%span soption = "option.rs" 98 37 98 38
  let%span soption'0 = "option.rs" 100 25 100 26
  let%span soption'1 = "option.rs" 101 29 101 30
  let%span soption'2 = "option.rs" 102 25 102 26
  let%span soption'3 = "option.rs" 102 40 102 41
  let%span soption'4 = "option.rs" 103 29 103 30
  let%span soption'5 = "option.rs" 104 25 104 26
  let%span soption'6 = "option.rs" 104 40 104 41
  let%span soption'7 = "option.rs" 105 29 105 30
  let%span soption'8 = "option.rs" 105 12 105 30
  let%span soption'9 = "option.rs" 104 12 104 41
  let%span soption'10 = "option.rs" 103 12 103 30
  let%span soption'11 = "option.rs" 102 12 102 41
  let%span soption'12 = "option.rs" 101 12 101 30
  let%span soption'13 = "option.rs" 100 12 100 37
  let%span soption'14 = "../../creusot-contracts/src/std/option.rs" 463 26 463 65
  let%span soption'15 = "../../creusot-contracts/src/std/option.rs" 80 26 80 51
  let%span soption'16 = "../../creusot-contracts/src/std/option.rs" 150 27 150 39
  let%span soption'17 = "../../creusot-contracts/src/std/option.rs" 151 26 151 46
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec replace (self_: MutBorrow.t t_Option) (value: Int32.t) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'14] result = self_.current /\ self_.final = C_Some value}
      (! return' {result}) ]
  
  let rec is_none (self_: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'15] result = (self_ = C_None)} (! return' {result}) ]
  
  let rec unwrap (self_: t_Option) (return' (x: Int32.t)) = {[@expl:unwrap requires] [%#soption'16] self_ <> C_None}
    any [ return''0 (result: Int32.t) -> {[%#soption'17] C_Some result = self_} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec replace'0 [#"option.rs" 96 0 96 16] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_7 <- _ret ] [ &none <- _ret.final ] s3)
      | s3 = replace {_7} {[%#soption'0] (2: Int32.t)} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0 [ s0 = unwrap {none} (fun (_ret: Int32.t) -> [ &_11 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_10 <- _11 = ([%#soption'1] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb9) ] ]
    | bb9 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_18 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = replace {_18} {[%#soption'2] (2: Int32.t)} (fun (_ret: t_Option) -> [ &_17 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0 [ s0 = unwrap {_17} (fun (_ret: Int32.t) -> [ &_16 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = [ &_15 <- _16 = ([%#soption'3] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_15 = false} (! bb12) | br1 -> {_15} (! bb14) ] ]
    | bb14 = s0 [ s0 = unwrap {some} (fun (_ret: Int32.t) -> [ &_22 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0
      [ s0 = [ &_21 <- _22 = ([%#soption'4] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb16) | br1 -> {_21} (! bb18) ] ]
    | bb18 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_29 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = replace {_29} {[%#soption'5] (1: Int32.t)} (fun (_ret: t_Option) -> [ &_28 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0 [ s0 = unwrap {_28} (fun (_ret: Int32.t) -> [ &_27 <- _ret ] s1) | s1 = bb20 ]
    | bb20 = s0
      [ s0 = [ &_26 <- _27 = ([%#soption'6] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_26 = false} (! bb21) | br1 -> {_26} (! bb23) ] ]
    | bb23 = s0 [ s0 = unwrap {some} (fun (_ret: Int32.t) -> [ &_33 <- _ret ] s1) | s1 = bb24 ]
    | bb24 = s0
      [ s0 = [ &_32 <- _33 = ([%#soption'7] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_32 = false} (! bb25) | br1 -> {_32} (! bb27) ] ]
    | bb27 = return''0 {_0}
    | bb25 = {[%#soption'8] false} any
    | bb21 = {[%#soption'9] false} any
    | bb16 = {[%#soption'10] false} any
    | bb12 = {[%#soption'11] false} any
    | bb7 = {[%#soption'12] false} any
    | bb3 = {[%#soption'13] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _7: MutBorrow.t t_Option = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int32.t = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _16: Int32.t = Any.any_l ()
    | & _17: t_Option = Any.any_l ()
    | & _18: MutBorrow.t t_Option = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: Int32.t = Any.any_l ()
    | & _28: t_Option = Any.any_l ()
    | & _29: MutBorrow.t t_Option = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _33: Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__and_or_xor [#"option.rs" 108 0 108 19]
  let%span soption = "option.rs" 110 33 110 34
  let%span soption'0 = "option.rs" 114 26 114 27
  let%span soption'1 = "option.rs" 116 26 116 27
  let%span soption'2 = "option.rs" 116 38 116 39
  let%span soption'3 = "option.rs" 119 25 119 26
  let%span soption'4 = "option.rs" 119 37 119 38
  let%span soption'5 = "option.rs" 120 34 120 35
  let%span soption'6 = "option.rs" 121 25 121 26
  let%span soption'7 = "option.rs" 121 37 121 38
  let%span soption'8 = "option.rs" 124 26 124 27
  let%span soption'9 = "option.rs" 124 38 124 39
  let%span soption'10 = "option.rs" 125 35 125 36
  let%span soption'11 = "option.rs" 126 26 126 27
  let%span soption'12 = "option.rs" 126 12 126 37
  let%span soption'13 = "option.rs" 125 12 125 37
  let%span soption'14 = "option.rs" 124 12 124 40
  let%span soption'15 = "option.rs" 123 12 123 34
  let%span soption'16 = "option.rs" 121 12 121 39
  let%span soption'17 = "option.rs" 120 12 120 36
  let%span soption'18 = "option.rs" 119 12 119 39
  let%span soption'19 = "option.rs" 118 12 118 33
  let%span soption'20 = "option.rs" 116 12 116 40
  let%span soption'21 = "option.rs" 115 12 115 34
  let%span soption'22 = "option.rs" 114 12 114 37
  let%span soption'23 = "option.rs" 113 12 113 34
  let%span soption'24 = "../../creusot-contracts/src/std/option.rs" 305 26 305 75
  let%span soption'25 = "../../creusot-contracts/src/std/option.rs" 306 26 306 76
  let%span soption'26 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'27 = "../../creusot-contracts/src/std/option.rs" 352 26 352 57
  let%span soption'28 = "../../creusot-contracts/src/std/option.rs" 353 26 353 76
  let%span soption'29 = "../../creusot-contracts/src/std/option.rs" 376 26 381 17
  let%span soption'30 = "../../creusot-contracts/src/std/option.rs" 787 8 790 9
  let%span soption'31 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  predicate resolve (_0: Int32.t) = true
  
  predicate resolve'0 (self: t_Option) =
    [%#soption'30] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  let rec and (self_: t_Option) (optb: t_Option) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'24] self_ = C_None -> result = C_None /\ resolve'0 optb}
      {[%#soption'25] self_ = C_None \/ result = optb /\ resolve'0 self_}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option) : t_Option'0 = [%#soption'31] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'26] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec or (self_: t_Option) (optb: t_Option) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'27] self_ = C_None -> result = optb}
      {[%#soption'28] self_ = C_None \/ result = self_ /\ resolve'0 optb}
      (! return' {result}) ]
  
  type tuple = { _p0: t_Option; _p1: t_Option }
  
  let rec xor (self_: t_Option) (optb: t_Option) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'29] match { _p0 = self_; _p1 = optb } with
        | {_p0 = C_None; _p1 = C_None} -> result = C_None
        | {_p0 = C_Some t1; _p1 = C_Some t2} -> result = C_None /\ resolve t1 /\ resolve t2
        | {_p0 = C_Some t; _p1 = C_None} -> result = C_Some t
        | {_p0 = C_None; _p1 = C_Some t} -> result = C_Some t
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec and_or_xor [#"option.rs" 108 0 108 19] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = and {none} {none} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_122 <- _const ] s1 ]
      | s1 = eq {_6} {_122} (fun (_ret: bool) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &_17 <- C_Some ([%#soption'0] (2: Int32.t)) ] s1
      | s1 = and {none} {_17} (fun (_ret: t_Option) -> [ &_15 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_121 <- _const ] s1 ]
      | s1 = eq {_15} {_121} (fun (_ret: bool) -> [ &_13 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb10) ]
    | bb10 = s0 [ s0 = and {some} {none} (fun (_ret: t_Option) -> [ &_24 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_120 <- _const ] s1 ]
      | s1 = eq {_24} {_120} (fun (_ret: bool) -> [ &_22 <- _ret ] s2)
      | s2 = bb12 ]
    | bb12 = any [ br0 -> {_22 = false} (! bb13) | br1 -> {_22} (! bb15) ]
    | bb15 = s0
      [ s0 = [ &_35 <- C_Some ([%#soption'1] (2: Int32.t)) ] s1
      | s1 = and {some} {_35} (fun (_ret: t_Option) -> [ &_33 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'2] (2: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_119 <- _const ] s1 ]
      | s1 = eq {_33} {_119} (fun (_ret: bool) -> [ &_31 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = any [ br0 -> {_31 = false} (! bb18) | br1 -> {_31} (! bb20) ]
    | bb20 = s0 [ s0 = or {none} {none} (fun (_ret: t_Option) -> [ &_42 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_118 <- _const ] s1 ]
      | s1 = eq {_42} {_118} (fun (_ret: bool) -> [ &_40 <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = any [ br0 -> {_40 = false} (! bb23) | br1 -> {_40} (! bb25) ]
    | bb25 = s0
      [ s0 = [ &_53 <- C_Some ([%#soption'3] (2: Int32.t)) ] s1
      | s1 = or {none} {_53} (fun (_ret: t_Option) -> [ &_51 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'4] (2: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_117 <- _const ] s1 ]
      | s1 = eq {_51} {_117} (fun (_ret: bool) -> [ &_49 <- _ret ] s2)
      | s2 = bb27 ]
    | bb27 = any [ br0 -> {_49 = false} (! bb28) | br1 -> {_49} (! bb30) ]
    | bb30 = s0 [ s0 = or {some} {none} (fun (_ret: t_Option) -> [ &_60 <- _ret ] s1) | s1 = bb31 ]
    | bb31 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'5] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_116 <- _const ] s1 ]
      | s1 = eq {_60} {_116} (fun (_ret: bool) -> [ &_58 <- _ret ] s2)
      | s2 = bb32 ]
    | bb32 = any [ br0 -> {_58 = false} (! bb33) | br1 -> {_58} (! bb35) ]
    | bb35 = s0
      [ s0 = [ &_71 <- C_Some ([%#soption'6] (2: Int32.t)) ] s1
      | s1 = or {some} {_71} (fun (_ret: t_Option) -> [ &_69 <- _ret ] s2)
      | s2 = bb36 ]
    | bb36 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'7] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_115 <- _const ] s1 ]
      | s1 = eq {_69} {_115} (fun (_ret: bool) -> [ &_67 <- _ret ] s2)
      | s2 = bb37 ]
    | bb37 = any [ br0 -> {_67 = false} (! bb38) | br1 -> {_67} (! bb40) ]
    | bb40 = s0 [ s0 = xor {none} {none} (fun (_ret: t_Option) -> [ &_78 <- _ret ] s1) | s1 = bb41 ]
    | bb41 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_114 <- _const ] s1 ]
      | s1 = eq {_78} {_114} (fun (_ret: bool) -> [ &_76 <- _ret ] s2)
      | s2 = bb42 ]
    | bb42 = any [ br0 -> {_76 = false} (! bb43) | br1 -> {_76} (! bb45) ]
    | bb45 = s0
      [ s0 = [ &_89 <- C_Some ([%#soption'8] (2: Int32.t)) ] s1
      | s1 = xor {none} {_89} (fun (_ret: t_Option) -> [ &_87 <- _ret ] s2)
      | s2 = bb46 ]
    | bb46 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'9] (2: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_113 <- _const ] s1 ]
      | s1 = eq {_87} {_113} (fun (_ret: bool) -> [ &_85 <- _ret ] s2)
      | s2 = bb47 ]
    | bb47 = any [ br0 -> {_85 = false} (! bb48) | br1 -> {_85} (! bb50) ]
    | bb50 = s0 [ s0 = xor {some} {none} (fun (_ret: t_Option) -> [ &_96 <- _ret ] s1) | s1 = bb51 ]
    | bb51 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'10] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_112 <- _const ] s1 ]
      | s1 = eq {_96} {_112} (fun (_ret: bool) -> [ &_94 <- _ret ] s2)
      | s2 = bb52 ]
    | bb52 = any [ br0 -> {_94 = false} (! bb53) | br1 -> {_94} (! bb55) ]
    | bb55 = s0
      [ s0 = [ &_107 <- C_Some ([%#soption'11] (2: Int32.t)) ] s1
      | s1 = xor {some} {_107} (fun (_ret: t_Option) -> [ &_105 <- _ret ] s2)
      | s2 = bb56 ]
    | bb56 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_111 <- _const ] s1 ]
      | s1 = eq {_105} {_111} (fun (_ret: bool) -> [ &_103 <- _ret ] s2)
      | s2 = bb57 ]
    | bb57 = any [ br0 -> {_103 = false} (! bb58) | br1 -> {_103} (! bb60) ]
    | bb60 = return''0 {_0}
    | bb58 = {[%#soption'12] false} any
    | bb53 = {[%#soption'13] false} any
    | bb48 = {[%#soption'14] false} any
    | bb43 = {[%#soption'15] false} any
    | bb38 = {[%#soption'16] false} any
    | bb33 = {[%#soption'17] false} any
    | bb28 = {[%#soption'18] false} any
    | bb23 = {[%#soption'19] false} any
    | bb18 = {[%#soption'20] false} any
    | bb13 = {[%#soption'21] false} any
    | bb8 = {[%#soption'22] false} any
    | bb3 = {[%#soption'23] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option = Any.any_l ()
    | & _17: t_Option = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _33: t_Option = Any.any_l ()
    | & _35: t_Option = Any.any_l ()
    | & _40: bool = Any.any_l ()
    | & _42: t_Option = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: t_Option = Any.any_l ()
    | & _53: t_Option = Any.any_l ()
    | & _58: bool = Any.any_l ()
    | & _60: t_Option = Any.any_l ()
    | & _67: bool = Any.any_l ()
    | & _69: t_Option = Any.any_l ()
    | & _71: t_Option = Any.any_l ()
    | & _76: bool = Any.any_l ()
    | & _78: t_Option = Any.any_l ()
    | & _85: bool = Any.any_l ()
    | & _87: t_Option = Any.any_l ()
    | & _89: t_Option = Any.any_l ()
    | & _94: bool = Any.any_l ()
    | & _96: t_Option = Any.any_l ()
    | & _103: bool = Any.any_l ()
    | & _105: t_Option = Any.any_l ()
    | & _107: t_Option = Any.any_l ()
    | & _111: t_Option = Any.any_l ()
    | & _112: t_Option = Any.any_l ()
    | & _113: t_Option = Any.any_l ()
    | & _114: t_Option = Any.any_l ()
    | & _115: t_Option = Any.any_l ()
    | & _116: t_Option = Any.any_l ()
    | & _117: t_Option = Any.any_l ()
    | & _118: t_Option = Any.any_l ()
    | & _119: t_Option = Any.any_l ()
    | & _120: t_Option = Any.any_l ()
    | & _121: t_Option = Any.any_l ()
    | & _122: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__and_then [#"option.rs" 129 0 129 17]
  let%span soption = "option.rs" 131 34 131 35
  let%span soption'0 = "option.rs" 132 34 132 35
  let%span soption'1 = "option.rs" 142 41 142 45
  let%span soption'2 = "option.rs" 143 12 143 40
  let%span soption'3 = "option.rs" 142 12 142 46
  let%span soption'4 = "option.rs" 134 12 134 66
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 314 27 317 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 318 26 321 17
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'8 = "option.rs" 140 16 140 17
  let%span soption'9 = "option.rs" 140 29 140 30
  let%span soption'10 = "option.rs" 136 8 137 38
  let%span soption'11 = "option.rs" 134 26 134 44
  let%span soption'12 = "option.rs" 135 15 138 6
  let%span soption'13 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  
  use creusot.int.Int32
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec closure0 [#"option.rs" 134 26 134 44] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: t_Option)) = bb0
    [ bb0 = {false} any ]
  
  predicate precondition (self: ()) (args: Int32.t) = [%#soption'11] let _0 = args in closure0'pre self _0
  
  predicate postcondition_once (self: ()) (args: Int32.t) (result: t_Option) =
    [%#soption'11] let _0 = args in closure0'post'return' self _0 result
  
  let rec and_then (self_: t_Option) (f: ()) (return' (x: t_Option)) =
    {[@expl:and_then requires] [%#soption'5] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'6] match self_ with
        | C_None -> result = C_None
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option) : t_Option'0 = [%#soption'13] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'7] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 135 15 138 6] (self: ()) (x: Int32.t) (return' (x'0: t_Option)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- x'0 = ([%#soption'8] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ] ]
    | bb1 = s0
      [ s0 = Int32.add {x'0} {[%#soption'9] (1: Int32.t)} (fun (_ret: Int32.t) -> [ &_6 <- _ret ] s1)
      | s1 = [ &res <- C_Some _6 ] s2
      | s2 = bb3 ]
    | bb2 = s0 [ s0 = [ &res <- C_None ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0 <- res ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: t_Option = Any.any_l ()
    | & x'0: Int32.t = x
    | & res: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: Int32.t = Any.any_l () ])
    [ return''0 (result: t_Option) -> {[@expl:closure ensures] [%#soption'10] Int32.to_int x = 1
        /\ (exists y: Int32.t. result = C_Some y /\ Int32.to_int y = Int32.to_int x + 1)
      \/ Int32.to_int x <> 1 /\ result = C_None}
      (! return' {result}) ]
  
  predicate precondition'0 (self: ()) (args: Int32.t) = [%#soption'12] let x = args in true
  
  predicate postcondition_once'0 (self: ()) (args: Int32.t) (result: t_Option) =
    [%#soption'12] let x = args in Int32.to_int x = 1
      /\ (exists y: Int32.t. result = C_Some y /\ Int32.to_int y = Int32.to_int x + 1)
    \/ Int32.to_int x <> 1 /\ result = C_None
  
  let rec and_then'0 (self_: t_Option) (f: ()) (return' (x: t_Option)) =
    {[@expl:and_then requires] [%#soption'5] match self_ with
      | C_None -> true
      | C_Some t -> precondition'0 f t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'6] match self_ with
        | C_None -> result = C_None
        | C_Some t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec and_then'1 [#"option.rs" 129 0 129 17] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some1 <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &some2 <- C_Some ([%#soption'0] (3: Int32.t)) ] s3
      | s3 = [ &_9 <- () ] s4
      | s4 = and_then {none} {_9} (fun (_ret: t_Option) -> [ &_7 <- _ret ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_34 <- _const ] s1 ]
      | s1 = eq {_7} {_34} (fun (_ret: bool) -> [ &_5 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &clos <- () ] s1
      | s1 = and_then'0 {some1} {clos} (fun (_ret: t_Option) -> [ &_17 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'1] (2: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_33 <- _const ] s1 ]
      | s1 = eq {_17} {_33} (fun (_ret: bool) -> [ &_15 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = any [ br0 -> {_15 = false} (! bb8) | br1 -> {_15} (! bb10) ]
    | bb10 = s0 [ s0 = and_then'0 {some2} {clos} (fun (_ret: t_Option) -> [ &_26 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_32 <- _const ] s1 ]
      | s1 = eq {_26} {_32} (fun (_ret: bool) -> [ &_24 <- _ret ] s2)
      | s2 = bb12 ]
    | bb12 = any [ br0 -> {_24 = false} (! bb13) | br1 -> {_24} (! bb15) ]
    | bb15 = return''0 {_0}
    | bb13 = {[%#soption'2] false} any
    | bb8 = {[%#soption'3] false} any
    | bb3 = {[%#soption'4] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some1: t_Option = Any.any_l ()
    | & some2: t_Option = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: t_Option = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & clos: () = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _17: t_Option = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Option = Any.any_l ()
    | & _32: t_Option = Any.any_l ()
    | & _33: t_Option = Any.any_l ()
    | & _34: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__filter [#"option.rs" 146 0 146 15]
  let%span soption = "option.rs" 148 33 148 34
  let%span soption'0 = "option.rs" 151 45 151 49
  let%span soption'1 = "option.rs" 152 12 152 44
  let%span soption'2 = "option.rs" 151 12 151 50
  let%span soption'3 = "option.rs" 150 12 150 45
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 331 27 334 17
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 335 26 341 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'7 = "option.rs" 151 34 151 35
  let%span soption'8 = "option.rs" 152 34 152 35
  let%span soption'9 = "option.rs" 150 24 150 27
  let%span soption'10 = "option.rs" 151 24 151 27
  let%span soption'11 = "option.rs" 152 24 152 27
  let%span soption'12 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec closure0 [#"option.rs" 150 24 150 27] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: bool)) = bb0
    [ bb0 = {false} any ]
  
  predicate precondition (self: ()) (args: Int32.t) = [%#soption'9] let _0 = args in closure0'pre self _0
  
  predicate postcondition_once (self: ()) (args: Int32.t) (result: bool) =
    [%#soption'9] let _0 = args in closure0'post'return' self _0 result
  
  predicate resolve (_0: Int32.t) = true
  
  let rec filter (self_: t_Option) (predicate': ()) (return' (x: t_Option)) =
    {[@expl:filter requires] [%#soption'4] match self_ with
      | C_None -> true
      | C_Some t -> precondition predicate' t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'5] match self_ with
        | C_None -> result = C_None
        | C_Some t -> match result with
          | C_None -> postcondition_once predicate' t false /\ resolve t
          | C_Some r -> postcondition_once predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option) : t_Option'0 = [%#soption'12] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'6] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 151 24 151 27] [@coma:extspec] (self: ()) (x: Int32.t) (return' (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- x'0 = ([%#soption'7] (1: Int32.t)) ] s1 | s1 = return' {_0} ] ]
    [ & _0: bool = Any.any_l () | & x'0: Int32.t = x ]
  
  predicate precondition'0 (self: ()) (args: Int32.t) = [%#soption'10] let x = args in closure1'pre self x
  
  predicate postcondition_once'0 (self: ()) (args: Int32.t) (result: bool) =
    [%#soption'10] let x = args in closure1'post'return' self x result
  
  let rec filter'0 (self_: t_Option) (predicate': ()) (return' (x: t_Option)) =
    {[@expl:filter requires] [%#soption'4] match self_ with
      | C_None -> true
      | C_Some t -> precondition'0 predicate' t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'5] match self_ with
        | C_None -> result = C_None
        | C_Some t -> match result with
          | C_None -> postcondition_once'0 predicate' t false /\ resolve t
          | C_Some r -> postcondition_once'0 predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]
  
  let rec closure2 [#"option.rs" 152 24 152 27] [@coma:extspec] (self: ()) (x: Int32.t) (return' (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- x'0 = ([%#soption'8] (2: Int32.t)) ] s1 | s1 = return' {_0} ] ]
    [ & _0: bool = Any.any_l () | & x'0: Int32.t = x ]
  
  predicate precondition'1 (self: ()) (args: Int32.t) = [%#soption'11] let x = args in closure2'pre self x
  
  predicate postcondition_once'1 (self: ()) (args: Int32.t) (result: bool) =
    [%#soption'11] let x = args in closure2'post'return' self x result
  
  let rec filter'1 (self_: t_Option) (predicate': ()) (return' (x: t_Option)) =
    {[@expl:filter requires] [%#soption'4] match self_ with
      | C_None -> true
      | C_Some t -> precondition'1 predicate' t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'5] match self_ with
        | C_None -> result = C_None
        | C_Some t -> match result with
          | C_None -> postcondition_once'1 predicate' t false /\ resolve t
          | C_Some r -> postcondition_once'1 predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec filter'2 [#"option.rs" 146 0 146 15] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = filter {none} {_8} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_32 <- _const ] s1 ]
      | s1 = eq {_6} {_32} (fun (_ret: bool) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &_17 <- () ] s1 | s1 = filter'0 {some} {_17} (fun (_ret: t_Option) -> [ &_15 <- _ret ] s2) | s2 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'0] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_31 <- _const ] s1 ]
      | s1 = eq {_15} {_31} (fun (_ret: bool) -> [ &_13 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb10) ]
    | bb10 = s0
      [ s0 = [ &_26 <- () ] s1 | s1 = filter'1 {some} {_26} (fun (_ret: t_Option) -> [ &_24 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_30 <- _const ] s1 ]
      | s1 = eq {_24} {_30} (fun (_ret: bool) -> [ &_22 <- _ret ] s2)
      | s2 = bb12 ]
    | bb12 = any [ br0 -> {_22 = false} (! bb13) | br1 -> {_22} (! bb15) ]
    | bb15 = return''0 {_0}
    | bb13 = {[%#soption'1] false} any
    | bb8 = {[%#soption'2] false} any
    | bb3 = {[%#soption'3] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _30: t_Option = Any.any_l ()
    | & _31: t_Option = Any.any_l ()
    | & _32: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__is_some_and [#"option.rs" 155 0 155 20]
  let%span soption = "option.rs" 157 34 157 35
  let%span soption'0 = "option.rs" 158 34 158 35
  let%span soption'1 = "option.rs" 162 12 162 39
  let%span soption'2 = "option.rs" 161 12 161 42
  let%span soption'3 = "option.rs" 160 12 160 41
  let%span soption'4 = "option.rs" 160 39 160 40
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 63 27 66 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 67 26 70 17
  let%span soption'7 = "option.rs" 161 40 161 41
  let%span soption'8 = "option.rs" 162 34 162 38
  let%span soption'9 = "option.rs" 160 30 160 33
  let%span soption'10 = "option.rs" 161 31 161 34
  let%span soption'11 = "option.rs" 162 30 162 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec closure0 [#"option.rs" 160 30 160 33] [@coma:extspec] (self: ()) (x: Int32.t) (return' (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- x'0 = ([%#soption'4] (1: Int32.t)) ] s1 | s1 = return' {_0} ] ]
    [ & _0: bool = Any.any_l () | & x'0: Int32.t = x ]
  
  predicate precondition (self: ()) (args: Int32.t) = [%#soption'9] let x = args in closure0'pre self x
  
  predicate postcondition_once (self: ()) (args: Int32.t) (result: bool) =
    [%#soption'9] let x = args in closure0'post'return' self x result
  
  let rec is_some_and (self_: t_Option) (f: ()) (return' (x: bool)) =
    {[@expl:is_some_and requires] [%#soption'5] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    any
    [ return''0 (result: bool) -> {[%#soption'6] match self_ with
        | C_None -> result = false
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 161 31 161 34] [@coma:extspec] (self: ()) (x: Int32.t) (return' (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- x'0 = ([%#soption'7] (1: Int32.t)) ] s1 | s1 = return' {_0} ] ]
    [ & _0: bool = Any.any_l () | & x'0: Int32.t = x ]
  
  predicate precondition'0 (self: ()) (args: Int32.t) = [%#soption'10] let x = args in closure1'pre self x
  
  predicate postcondition_once'0 (self: ()) (args: Int32.t) (result: bool) =
    [%#soption'10] let x = args in closure1'post'return' self x result
  
  let rec is_some_and'0 (self_: t_Option) (f: ()) (return' (x: bool)) =
    {[@expl:is_some_and requires] [%#soption'5] match self_ with
      | C_None -> true
      | C_Some t -> precondition'0 f t
      end}
    any
    [ return''0 (result: bool) -> {[%#soption'6] match self_ with
        | C_None -> result = false
        | C_Some t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]
  
  let rec closure2 [#"option.rs" 162 30 162 33] [@coma:extspec] (self: ()) (_0: Int32.t) (return' (x: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_0'0 <- [%#soption'8] true ] s1 | s1 = return' {_0'0} ] ] [ & _0'0: bool = Any.any_l () ]
  
  predicate precondition'1 (self: ()) (args: Int32.t) = [%#soption'11] let _0 = args in closure2'pre self _0
  
  predicate postcondition_once'1 (self: ()) (args: Int32.t) (result: bool) =
    [%#soption'11] let _0 = args in closure2'post'return' self _0 result
  
  let rec is_some_and'1 (self_: t_Option) (f: ()) (return' (x: bool)) =
    {[@expl:is_some_and requires] [%#soption'5] match self_ with
      | C_None -> true
      | C_Some t -> precondition'1 f t
      end}
    any
    [ return''0 (result: bool) -> {[%#soption'6] match self_ with
        | C_None -> result = false
        | C_Some t -> postcondition_once'1 f t result
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_some_and'2 [#"option.rs" 155 0 155 20] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some1 <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &some2 <- C_Some ([%#soption'0] (2: Int32.t)) ] s3
      | s3 = [ &_7 <- () ] s4
      | s4 = is_some_and {some1} {_7} (fun (_ret: bool) -> [ &_5 <- _ret ] s5)
      | s5 = bb1 ]
    | bb1 = any [ br0 -> {_5 = false} (! bb2) | br1 -> {_5} (! bb4) ]
    | bb4 = s0
      [ s0 = [ &_13 <- () ] s1 | s1 = is_some_and'0 {some2} {_13} (fun (_ret: bool) -> [ &_11 <- _ret ] s2) | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_10 <- not _11 ] s1 | s1 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb8) ] ]
    | bb8 = s0
      [ s0 = [ &_19 <- () ] s1 | s1 = is_some_and'1 {none} {_19} (fun (_ret: bool) -> [ &_17 <- _ret ] s2) | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_16 <- not _17 ] s1 | s1 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb12) ] ]
    | bb12 = return''0 {_0}
    | bb10 = {[%#soption'1] false} any
    | bb6 = {[%#soption'2] false} any
    | bb2 = {[%#soption'3] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some1: t_Option = Any.any_l ()
    | & some2: t_Option = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: () = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: () = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__or_else [#"option.rs" 165 0 165 16]
  let%span soption = "option.rs" 167 33 167 34
  let%span soption'0 = "option.rs" 169 45 169 46
  let%span soption'1 = "option.rs" 171 46 171 47
  let%span soption'2 = "option.rs" 171 12 171 48
  let%span soption'3 = "option.rs" 170 12 170 41
  let%span soption'4 = "option.rs" 169 12 169 47
  let%span soption'5 = "option.rs" 169 33 169 34
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 361 27 361 62
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 362 26 365 17
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'9 = "option.rs" 169 25 169 27
  let%span soption'10 = "option.rs" 170 25 170 27
  let%span soption'11 = "option.rs" 171 25 171 27
  let%span soption'12 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec closure0 [#"option.rs" 169 25 169 27] [@coma:extspec] (self: ()) (return' (x: t_Option)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- C_Some ([%#soption'5] (2: Int32.t)) ] s1 | s1 = return' {_0} ] ]
    [ & _0: t_Option = Any.any_l () ]
  
  predicate precondition (self: ()) (args: ()) = [%#soption'9] let () = args in closure0'pre self
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_Option) =
    [%#soption'9] let () = args in closure0'post'return' self result
  
  let rec or_else (self_: t_Option) (f: ()) (return' (x: t_Option)) = {[@expl:or_else requires] [%#soption'6] self_
      = C_None -> precondition f ()}
    any
    [ return''0 (result: t_Option) -> {[%#soption'7] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = C_Some t
        end}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option) : t_Option'0 = [%#soption'12] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'8] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 170 25 170 27] [@coma:extspec] (self: ()) (return' (x: t_Option)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = return' {_0} ] ] [ & _0: t_Option = Any.any_l () ]
  
  predicate precondition'0 (self: ()) (args: ()) = [%#soption'10] let () = args in closure1'pre self
  
  predicate postcondition_once'0 (self: ()) (args: ()) (result: t_Option) =
    [%#soption'10] let () = args in closure1'post'return' self result
  
  let rec or_else'0 (self_: t_Option) (f: ()) (return' (x: t_Option)) = {[@expl:or_else requires] [%#soption'6] self_
      = C_None -> precondition'0 f ()}
    any
    [ return''0 (result: t_Option) -> {[%#soption'7] match self_ with
        | C_None -> postcondition_once'0 f () result
        | C_Some t -> result = C_Some t
        end}
      (! return' {result}) ]
  
  let rec closure2 [#"option.rs" 171 25 171 27] [@coma:extspec] (self: ()) (return' (x: t_Option)) = bb0
    [ bb0 = {false} any ]
  
  predicate precondition'1 (self: ()) (args: ()) = [%#soption'11] let () = args in closure2'pre self
  
  predicate postcondition_once'1 (self: ()) (args: ()) (result: t_Option) =
    [%#soption'11] let () = args in closure2'post'return' self result
  
  let rec or_else'1 (self_: t_Option) (f: ()) (return' (x: t_Option)) = {[@expl:or_else requires] [%#soption'6] self_
      = C_None -> precondition'1 f ()}
    any
    [ return''0 (result: t_Option) -> {[%#soption'7] match self_ with
        | C_None -> postcondition_once'1 f () result
        | C_Some t -> result = C_Some t
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec or_else'2 [#"option.rs" 165 0 165 16] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = or_else {none} {_8} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'0] (2: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_32 <- _const ] s1 ]
      | s1 = eq {_6} {_32} (fun (_ret: bool) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &_17 <- () ] s1 | s1 = or_else'0 {none} {_17} (fun (_ret: t_Option) -> [ &_15 <- _ret ] s2) | s2 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_31 <- _const ] s1 ]
      | s1 = eq {_15} {_31} (fun (_ret: bool) -> [ &_13 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb10) ]
    | bb10 = s0
      [ s0 = [ &_26 <- () ] s1 | s1 = or_else'1 {some} {_26} (fun (_ret: t_Option) -> [ &_24 <- _ret ] s2) | s2 = bb11 ]
    | bb11 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'1] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_30 <- _const ] s1 ]
      | s1 = eq {_24} {_30} (fun (_ret: bool) -> [ &_22 <- _ret ] s2)
      | s2 = bb12 ]
    | bb12 = any [ br0 -> {_22 = false} (! bb13) | br1 -> {_22} (! bb15) ]
    | bb15 = return''0 {_0}
    | bb13 = {[%#soption'2] false} any
    | bb8 = {[%#soption'3] false} any
    | bb3 = {[%#soption'4] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _30: t_Option = Any.any_l ()
    | & _31: t_Option = Any.any_l ()
    | & _32: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__insert [#"option.rs" 174 0 174 15]
  let%span soption = "option.rs" 176 37 176 38
  let%span soption'0 = "option.rs" 178 25 178 26
  let%span soption'1 = "option.rs" 179 19 179 20
  let%span soption'2 = "option.rs" 180 10 180 11
  let%span soption'3 = "option.rs" 181 25 181 26
  let%span soption'4 = "option.rs" 182 25 182 26
  let%span soption'5 = "option.rs" 183 19 183 20
  let%span soption'6 = "option.rs" 184 10 184 11
  let%span soption'7 = "option.rs" 185 25 185 26
  let%span soption'8 = "option.rs" 185 12 185 27
  let%span soption'9 = "option.rs" 183 12 183 20
  let%span soption'10 = "option.rs" 181 12 181 27
  let%span soption'11 = "option.rs" 179 12 179 20
  let%span soption'12 = "../../creusot-contracts/src/std/option.rs" 390 26 393 17
  let%span soption'13 = "../../creusot-contracts/src/std/option.rs" 394 26 394 68
  let%span soption'14 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'15 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  predicate resolve (_0: Int32.t) = true
  
  let rec insert (self_: MutBorrow.t t_Option) (value: Int32.t) (return' (x: MutBorrow.t Int32.t)) = any
    [ return''0 (result: MutBorrow.t Int32.t) -> {[%#soption'12] match self_.current with
        | C_Some t -> resolve t
        | C_None -> true
        end}
      {[%#soption'13] result.current = value /\ self_.final = C_Some (result.final)}
      (! return' {result}) ]
  
  predicate resolve'0 (self: MutBorrow.t Int32.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 (_0: MutBorrow.t Int32.t) = resolve'0 _0
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option) : t_Option'0 = [%#soption'15] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'14] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert'0 [#"option.rs" 174 0 174 15] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_4 <- _ret ] [ &none <- _ret.final ] s3)
      | s3 = insert {_4} {[%#soption'0] (2: Int32.t)} (fun (_ret: MutBorrow.t Int32.t) -> [ &i1 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_6 <- i1.current = ([%#soption'1] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_6 = false} (! bb2) | br1 -> {_6} (! bb4) ] ]
    | bb4 = s0
      [ s0 = [ &i1 <- { i1 with current = ([%#soption'2] (3: Int32.t)) } ] s1
      | s1 = -{resolve'1 i1}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'3] (3: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_28 <- _const ] s3 ]
      | s3 = eq {none} {_28} (fun (_ret: bool) -> [ &_10 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb8) ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_16 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = insert {_16} {[%#soption'4] (4: Int32.t)} (fun (_ret: MutBorrow.t Int32.t) -> [ &i2 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_18 <- i2.current = ([%#soption'5] (4: Int32.t)) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb12) ] ]
    | bb12 = s0
      [ s0 = [ &i2 <- { i2 with current = ([%#soption'6] (5: Int32.t)) } ] s1
      | s1 = -{resolve'1 i2}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'7] (5: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_27 <- _const ] s3 ]
      | s3 = eq {some} {_27} (fun (_ret: bool) -> [ &_22 <- _ret ] s4)
      | s4 = bb13 ]
    | bb13 = any [ br0 -> {_22 = false} (! bb14) | br1 -> {_22} (! bb16) ]
    | bb16 = return''0 {_0}
    | bb14 = {[%#soption'8] false} any
    | bb10 = s0 [ s0 = -{resolve'1 i2}- s1 | s1 = {[%#soption'9] false} any ]
    | bb6 = {[%#soption'10] false} any
    | bb2 = s0 [ s0 = -{resolve'1 i1}- s1 | s1 = {[%#soption'11] false} any ] ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & i1: MutBorrow.t Int32.t = Any.any_l ()
    | & _4: MutBorrow.t t_Option = Any.any_l ()
    | & _6: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & i2: MutBorrow.t Int32.t = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _27: t_Option = Any.any_l ()
    | & _28: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__get_or_insert [#"option.rs" 188 0 188 22]
  let%span soption = "option.rs" 190 37 190 38
  let%span soption'0 = "option.rs" 193 32 193 33
  let%span soption'1 = "option.rs" 194 19 194 20
  let%span soption'2 = "option.rs" 195 10 195 11
  let%span soption'3 = "option.rs" 196 25 196 26
  let%span soption'4 = "option.rs" 197 32 197 33
  let%span soption'5 = "option.rs" 198 19 198 20
  let%span soption'6 = "option.rs" 199 10 199 11
  let%span soption'7 = "option.rs" 200 25 200 26
  let%span soption'8 = "option.rs" 203 16 203 17
  let%span soption'9 = "option.rs" 207 19 207 20
  let%span soption'10 = "option.rs" 208 10 208 11
  let%span soption'11 = "option.rs" 209 25 209 26
  let%span soption'12 = "option.rs" 211 19 211 20
  let%span soption'13 = "option.rs" 212 10 212 11
  let%span soption'14 = "option.rs" 213 25 213 26
  let%span soption'15 = "option.rs" 213 12 213 27
  let%span soption'16 = "option.rs" 211 12 211 20
  let%span soption'17 = "option.rs" 209 12 209 27
  let%span soption'18 = "option.rs" 207 12 207 20
  let%span soption'19 = "option.rs" 200 12 200 27
  let%span soption'20 = "option.rs" 198 12 198 20
  let%span soption'21 = "option.rs" 196 12 196 27
  let%span soption'22 = "option.rs" 194 12 194 20
  let%span soption'23 = "../../creusot-contracts/src/std/option.rs" 404 26 407 17
  let%span soption'24 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'25 = "option.rs" 206 40 206 41
  let%span soption'26 = "../../creusot-contracts/src/std/option.rs" 419 27 419 63
  let%span soption'27 = "../../creusot-contracts/src/std/option.rs" 420 26 423 17
  let%span soption'28 = "option.rs" 206 37 206 39
  let%span soption'29 = "option.rs" 210 37 210 39
  let%span soption'30 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  predicate resolve (_0: Int32.t) = true
  
  let rec get_or_insert (self_: MutBorrow.t t_Option) (value: Int32.t) (return' (x: MutBorrow.t Int32.t)) = any
    [ return''0 (result: MutBorrow.t Int32.t) -> {[%#soption'23] match self_.current with
        | C_None -> result.current = value /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final) /\ resolve value
        end}
      (! return' {result}) ]
  
  predicate resolve'0 (self: MutBorrow.t Int32.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 (_0: MutBorrow.t Int32.t) = resolve'0 _0
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option) : t_Option'0 = [%#soption'30] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'24] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec closure0 [#"option.rs" 206 37 206 39] [@coma:extspec] (self: ()) (return' (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_0 <- [%#soption'25] (2: Int32.t) ] s1 | s1 = return' {_0} ] ] [ & _0: Int32.t = Any.any_l () ]
  
  predicate precondition (self: ()) (args: ()) = [%#soption'28] let () = args in closure0'pre self
  
  predicate postcondition_once (self: ()) (args: ()) (result: Int32.t) =
    [%#soption'28] let () = args in closure0'post'return' self result
  
  let rec get_or_insert_with (self_: MutBorrow.t t_Option) (f: ()) (return' (x: MutBorrow.t Int32.t)) =
    {[@expl:get_or_insert_with requires] [%#soption'26] self_.current = C_None -> precondition f ()}
    any
    [ return''0 (result: MutBorrow.t Int32.t) -> {[%#soption'27] match self_.current with
        | C_None -> postcondition_once f () result.current /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final)
        end}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 210 37 210 39] [@coma:extspec] (self: ()) (return' (x: Int32.t)) = bb0
    [ bb0 = {false} any ]
  
  predicate precondition'0 (self: ()) (args: ()) = [%#soption'29] let () = args in closure1'pre self
  
  predicate postcondition_once'0 (self: ()) (args: ()) (result: Int32.t) =
    [%#soption'29] let () = args in closure1'post'return' self result
  
  let rec get_or_insert_with'0 (self_: MutBorrow.t t_Option) (f: ()) (return' (x: MutBorrow.t Int32.t)) =
    {[@expl:get_or_insert_with requires] [%#soption'26] self_.current = C_None -> precondition'0 f ()}
    any
    [ return''0 (result: MutBorrow.t Int32.t) -> {[%#soption'27] match self_.current with
        | C_None -> postcondition_once'0 f () result.current /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final)
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_or_insert'0 [#"option.rs" 188 0 188 22] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_4 <- _ret ] [ &none <- _ret.final ] s3)
      | s3 = get_or_insert {_4} {[%#soption'0] (2: Int32.t)} (fun (_ret: MutBorrow.t Int32.t) -> [ &i1 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_6 <- i1.current = ([%#soption'1] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_6 = false} (! bb2) | br1 -> {_6} (! bb4) ] ]
    | bb4 = s0
      [ s0 = [ &i1 <- { i1 with current = ([%#soption'2] (3: Int32.t)) } ] s1
      | s1 = -{resolve'1 i1}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'3] (3: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_58 <- _const ] s3 ]
      | s3 = eq {none} {_58} (fun (_ret: bool) -> [ &_10 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb8) ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_16 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = get_or_insert {_16} {[%#soption'4] (4: Int32.t)} (fun (_ret: MutBorrow.t Int32.t) -> [ &i2 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_18 <- i2.current = ([%#soption'5] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb12) ] ]
    | bb12 = s0
      [ s0 = [ &i2 <- { i2 with current = ([%#soption'6] (5: Int32.t)) } ] s1
      | s1 = -{resolve'1 i2}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'7] (5: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_57 <- _const ] s3 ]
      | s3 = eq {some} {_57} (fun (_ret: bool) -> [ &_22 <- _ret ] s4)
      | s4 = bb13 ]
    | bb13 = any [ br0 -> {_22 = false} (! bb14) | br1 -> {_22} (! bb16) ]
    | bb16 = s0
      [ s0 = [ &_27 <- C_None ] s1
      | s1 = [ &none <- _27 ] s2
      | s2 = [ &_28 <- C_Some ([%#soption'8] (1: Int32.t)) ] s3
      | s3 = [ &some <- _28 ] s4
      | s4 = [ &_31 <- () ] s5
      | s5 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_30 <- _ret ] [ &none <- _ret.final ] s6)
      | s6 = get_or_insert_with {_30} {_31} (fun (_ret: MutBorrow.t Int32.t) -> [ &i1'0 <- _ret ] s7)
      | s7 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_33 <- i1'0.current = ([%#soption'9] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_33 = false} (! bb18) | br1 -> {_33} (! bb20) ] ]
    | bb20 = s0
      [ s0 = [ &i1'0 <- { i1'0 with current = ([%#soption'10] (3: Int32.t)) } ] s1
      | s1 = -{resolve'1 i1'0}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'11] (3: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_56 <- _const ] s3 ]
      | s3 = eq {none} {_56} (fun (_ret: bool) -> [ &_37 <- _ret ] s4)
      | s4 = bb21 ]
    | bb21 = any [ br0 -> {_37 = false} (! bb22) | br1 -> {_37} (! bb24) ]
    | bb24 = s0
      [ s0 = [ &_44 <- () ] s1
      | s1 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_43 <- _ret ] [ &some <- _ret.final ] s2)
      | s2 = get_or_insert_with'0 {_43} {_44} (fun (_ret: MutBorrow.t Int32.t) -> [ &i2'0 <- _ret ] s3)
      | s3 = bb25 ]
    | bb25 = s0
      [ s0 = [ &_46 <- i2'0.current = ([%#soption'12] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_46 = false} (! bb26) | br1 -> {_46} (! bb28) ] ]
    | bb28 = s0
      [ s0 = [ &i2'0 <- { i2'0 with current = ([%#soption'13] (5: Int32.t)) } ] s1
      | s1 = -{resolve'1 i2'0}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'14] (5: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_55 <- _const ] s3 ]
      | s3 = eq {some} {_55} (fun (_ret: bool) -> [ &_50 <- _ret ] s4)
      | s4 = bb29 ]
    | bb29 = any [ br0 -> {_50 = false} (! bb30) | br1 -> {_50} (! bb32) ]
    | bb32 = return''0 {_0}
    | bb30 = {[%#soption'15] false} any
    | bb26 = s0 [ s0 = -{resolve'1 i2'0}- s1 | s1 = {[%#soption'16] false} any ]
    | bb22 = {[%#soption'17] false} any
    | bb18 = s0 [ s0 = -{resolve'1 i1'0}- s1 | s1 = {[%#soption'18] false} any ]
    | bb14 = {[%#soption'19] false} any
    | bb10 = s0 [ s0 = -{resolve'1 i2}- s1 | s1 = {[%#soption'20] false} any ]
    | bb6 = {[%#soption'21] false} any
    | bb2 = s0 [ s0 = -{resolve'1 i1}- s1 | s1 = {[%#soption'22] false} any ] ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & i1: MutBorrow.t Int32.t = Any.any_l ()
    | & _4: MutBorrow.t t_Option = Any.any_l ()
    | & _6: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & i2: MutBorrow.t Int32.t = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _27: t_Option = Any.any_l ()
    | & _28: t_Option = Any.any_l ()
    | & i1'0: MutBorrow.t Int32.t = Any.any_l ()
    | & _30: MutBorrow.t t_Option = Any.any_l ()
    | & _31: () = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & i2'0: MutBorrow.t Int32.t = Any.any_l ()
    | & _43: MutBorrow.t t_Option = Any.any_l ()
    | & _44: () = Any.any_l ()
    | & _46: bool = Any.any_l ()
    | & _50: bool = Any.any_l ()
    | & _55: t_Option = Any.any_l ()
    | & _56: t_Option = Any.any_l ()
    | & _57: t_Option = Any.any_l ()
    | & _58: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__take [#"option.rs" 216 0 216 13]
  let%span soption = "option.rs" 218 37 218 38
  let%span soption'0 = "option.rs" 222 36 222 37
  let%span soption'1 = "option.rs" 223 12 223 26
  let%span soption'2 = "option.rs" 222 12 222 37
  let%span soption'3 = "option.rs" 221 12 221 26
  let%span soption'4 = "option.rs" 220 12 220 33
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 434 26 434 58
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 80 26 80 51
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 150 27 150 39
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 151 26 151 46
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  let rec take (self_: MutBorrow.t t_Option) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'5] result = self_.current /\ self_.final = C_None}
      (! return' {result}) ]
  
  let rec is_none (self_: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'6] result = (self_ = C_None)} (! return' {result}) ]
  
  let rec unwrap (self_: t_Option) (return' (x: Int32.t)) = {[@expl:unwrap requires] [%#soption'7] self_ <> C_None}
    any [ return''0 (result: Int32.t) -> {[%#soption'8] C_Some result = self_} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take'0 [#"option.rs" 216 0 216 13] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_7 <- _ret ] [ &none <- _ret.final ] s3)
      | s3 = take {_7} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s4)
      | s4 = bb1 ]
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0 [ s0 = is_none {none} (fun (_ret: bool) -> [ &_10 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb9) ]
    | bb9 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_17 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = take {_17} (fun (_ret: t_Option) -> [ &_16 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0 [ s0 = unwrap {_16} (fun (_ret: Int32.t) -> [ &_15 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = [ &_14 <- _15 = ([%#soption'0] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb12) | br1 -> {_14} (! bb14) ] ]
    | bb14 = s0 [ s0 = is_none {some} (fun (_ret: bool) -> [ &_20 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = any [ br0 -> {_20 = false} (! bb16) | br1 -> {_20} (! bb18) ]
    | bb18 = return''0 {_0}
    | bb16 = {[%#soption'1] false} any
    | bb12 = {[%#soption'2] false} any
    | bb7 = {[%#soption'3] false} any
    | bb3 = {[%#soption'4] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _7: MutBorrow.t t_Option = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: Int32.t = Any.any_l ()
    | & _16: t_Option = Any.any_l ()
    | & _17: MutBorrow.t t_Option = Any.any_l ()
    | & _20: bool = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__take_if [#"option.rs" 226 0 226 16]
  let%span soption = "option.rs" 228 37 228 38
  let%span soption'0 = "option.rs" 232 25 232 26
  let%span soption'1 = "option.rs" 238 19 238 20
  let%span soption'2 = "option.rs" 240 12 240 24
  let%span soption'3 = "option.rs" 234 8 238 21
  let%span soption'4 = "option.rs" 232 12 232 27
  let%span soption'5 = "option.rs" 231 12 231 45
  let%span soption'6 = "option.rs" 230 12 230 46
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 439 27 442 17
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 443 26 452 17
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'10 = "option.rs" 231 35 231 36
  let%span soption'11 = "option.rs" 235 28 235 29
  let%span soption'12 = "option.rs" 236 17 236 18
  let%span soption'13 = "option.rs" 230 25 230 28
  let%span soption'14 = "option.rs" 231 25 231 28
  let%span soption'15 = "option.rs" 234 21 234 24
  let%span soption'16 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  predicate resolve (self: MutBorrow.t Int32.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0: MutBorrow.t Int32.t) = resolve _0
  
  let rec closure0 [#"option.rs" 230 25 230 28] [@coma:extspec] (self: ()) (_0: MutBorrow.t Int32.t)
    (return' (x: bool)) = bb0
    [ bb0 = s0 [ s0 = -{resolve'0 _2}- s1 | s1 = {false} any ] ] [ & _2: MutBorrow.t Int32.t = _0 ]
  
  predicate inv (_0: MutBorrow.t Int32.t)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t Int32.t [inv x]. inv x = true
  
  predicate precondition (self: ()) (args: MutBorrow.t Int32.t) = [%#soption'13] let _0 = args in closure0'pre self _0
  
  predicate postcondition_once (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    [%#soption'13] let _0 = args in closure0'post'return' self _0 result
  
  let rec take_if (self_: MutBorrow.t t_Option) (predicate': ()) (return' (x: t_Option)) =
    {[@expl:take_if requires] [%#soption'7] match self_.current with
      | C_None -> true
      | C_Some t -> forall b: MutBorrow.t Int32.t. inv b /\ b.current = t -> precondition predicate' b
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'8] match self_.current with
        | C_None -> result = C_None /\ self_.final = C_None
        | C_Some cur -> exists b: MutBorrow.t Int32.t, res: bool. inv b
          /\ cur = b.current
          /\ postcondition_once predicate' b res
          /\ (if res then
            self_.final = C_None /\ result = C_Some (b.final)
          else
            self_.final = C_Some (b.final) /\ result = C_None
          )
        end}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option) : t_Option'0 = [%#soption'16] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'1 (self: t_Option) : t_Option'0 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'9] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec closure1 [#"option.rs" 231 25 231 28] [@coma:extspec] (self: ()) (x: MutBorrow.t Int32.t)
    (return' (x'0: bool)) = bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 x'0}- s1
      | s1 = [ &_0 <- x'0.current = ([%#soption'10] (2: Int32.t)) ] s2
      | s2 = return' {_0} ] ] [ & _0: bool = Any.any_l () | & x'0: MutBorrow.t Int32.t = x ]
  
  predicate precondition'0 (self: ()) (args: MutBorrow.t Int32.t) = [%#soption'14] let x = args in closure1'pre self x
  
  predicate postcondition_once'0 (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    [%#soption'14] let x = args in closure1'post'return' self x result
  
  let rec take_if'0 (self_: MutBorrow.t t_Option) (predicate': ()) (return' (x: t_Option)) =
    {[@expl:take_if requires] [%#soption'7] match self_.current with
      | C_None -> true
      | C_Some t -> forall b: MutBorrow.t Int32.t. inv b /\ b.current = t -> precondition'0 predicate' b
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'8] match self_.current with
        | C_None -> result = C_None /\ self_.final = C_None
        | C_Some cur -> exists b: MutBorrow.t Int32.t, res: bool. inv b
          /\ cur = b.current
          /\ postcondition_once'0 predicate' b res
          /\ (if res then
            self_.final = C_None /\ result = C_Some (b.final)
          else
            self_.final = C_Some (b.final) /\ result = C_None
          )
        end}
      (! return' {result}) ]
  
  let rec closure2 [#"option.rs" 234 21 234 24] [@coma:extspec] (self: ()) (x: MutBorrow.t Int32.t)
    (return' (x'0: bool)) = bb0
    [ bb0 = s0
      [ s0 = [ &res <- x'0.current = ([%#soption'11] (1: Int32.t)) ] s1
      | s1 = [ &x'0 <- { x'0 with current = ([%#soption'12] (3: Int32.t)) } ] s2
      | s2 = -{resolve'0 x'0}- s3
      | s3 = [ &_0 <- res ] s4
      | s4 = return' {_0} ] ]
    [ & _0: bool = Any.any_l () | & x'0: MutBorrow.t Int32.t = x | & res: bool = Any.any_l () ]
  
  predicate precondition'1 (self: ()) (args: MutBorrow.t Int32.t) = [%#soption'15] let x = args in closure2'pre self x
  
  predicate postcondition_once'1 (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    [%#soption'15] let x = args in closure2'post'return' self x result
  
  let rec take_if'1 (self_: MutBorrow.t t_Option) (predicate': ()) (return' (x: t_Option)) =
    {[@expl:take_if requires] [%#soption'7] match self_.current with
      | C_None -> true
      | C_Some t -> forall b: MutBorrow.t Int32.t. inv b /\ b.current = t -> precondition'1 predicate' b
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'8] match self_.current with
        | C_None -> result = C_None /\ self_.final = C_None
        | C_Some cur -> exists b: MutBorrow.t Int32.t, res: bool. inv b
          /\ cur = b.current
          /\ postcondition_once'1 predicate' b res
          /\ (if res then
            self_.final = C_None /\ result = C_Some (b.final)
          else
            self_.final = C_Some (b.final) /\ result = C_None
          )
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take_if'2 [#"option.rs" 226 0 226 16] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_7 <- _ret ] [ &none <- _ret.final ] s4)
      | s4 = take_if {_7} {_8} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_46 <- _const ] s1 ]
      | s1 = eq {_6} {_46} (fun (_ret: bool) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &_17 <- () ] s1
      | s1 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_16 <- _ret ] [ &some <- _ret.final ] s2)
      | s2 = take_if'0 {_16} {_17} (fun (_ret: t_Option) -> [ &_15 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_45 <- _const ] s1 ]
      | s1 = eq {_15} {_45} (fun (_ret: bool) -> [ &_13 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb10) ]
    | bb10 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'0] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_44 <- _const ] s1 ]
      | s1 = eq {some} {_44} (fun (_ret: bool) -> [ &_22 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb14) ]
    | bb14 = s0
      [ s0 = [ &_32 <- () ] s1
      | s1 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_31 <- _ret ] [ &some <- _ret.final ] s2)
      | s2 = take_if'1 {_31} {_32} (fun (_ret: t_Option) -> [ &_30 <- _ret ] s3)
      | s3 = bb15 ]
    | bb15 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'1] (3: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_43 <- _const ] s1 ]
      | s1 = eq {_30} {_43} (fun (_ret: bool) -> [ &_28 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = any [ br0 -> {_28 = false} (! bb17) | br1 -> {_28} (! bb19) ]
    | bb19 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_42 <- _const ] s1 ]
      | s1 = eq {some} {_42} (fun (_ret: bool) -> [ &_37 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = any [ br0 -> {_37 = false} (! bb21) | br1 -> {_37} (! bb23) ]
    | bb23 = return''0 {_0}
    | bb21 = {[%#soption'2] false} any
    | bb17 = {[%#soption'3] false} any
    | bb12 = {[%#soption'4] false} any
    | bb8 = {[%#soption'5] false} any
    | bb3 = {[%#soption'6] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _7: MutBorrow.t t_Option = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: t_Option = Any.any_l ()
    | & _31: MutBorrow.t t_Option = Any.any_l ()
    | & _32: () = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _42: t_Option = Any.any_l ()
    | & _43: t_Option = Any.any_l ()
    | & _44: t_Option = Any.any_l ()
    | & _45: t_Option = Any.any_l ()
    | & _46: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__copied_cloned [#"option.rs" 243 0 243 22]
  let%span soption = "option.rs" 245 37 245 38
  let%span soption'0 = "option.rs" 249 47 249 48
  let%span soption'1 = "option.rs" 251 47 251 48
  let%span soption'2 = "option.rs" 254 47 254 48
  let%span soption'3 = "option.rs" 256 47 256 48
  let%span soption'4 = "option.rs" 256 12 256 48
  let%span soption'5 = "option.rs" 255 12 255 44
  let%span soption'6 = "option.rs" 254 12 254 48
  let%span soption'7 = "option.rs" 253 12 253 44
  let%span soption'8 = "option.rs" 251 12 251 48
  let%span soption'9 = "option.rs" 250 12 250 44
  let%span soption'10 = "option.rs" 249 12 249 48
  let%span soption'11 = "option.rs" 248 12 248 44
  let%span soption'12 = "../../creusot-contracts/src/std/option.rs" 87 26 87 58
  let%span soption'13 = "../../creusot-contracts/src/std/option.rs" 89 20 89 89
  let%span soption'14 = "../../creusot-contracts/src/std/option.rs" 498 26 501 17
  let%span soption'15 = "../../creusot-contracts/src/std/option.rs" 80 26 80 51
  let%span soption'16 = "../../creusot-contracts/src/std/option.rs" 150 27 150 39
  let%span soption'17 = "../../creusot-contracts/src/std/option.rs" 151 26 151 46
  let%span soption'18 = "../../creusot-contracts/src/std/option.rs" 100 26 100 75
  let%span soption'19 = "../../creusot-contracts/src/std/option.rs" 102 20 103 100
  let%span soption'20 = "../../creusot-contracts/src/std/option.rs" 528 26 531 17
  let%span soption'21 = "../../creusot-contracts/src/std/option.rs" 511 26 515 17
  let%span soption'22 = "../../creusot-contracts/src/std/option.rs" 541 26 545 17
  let%span snum = "../../creusot-contracts/src/std/num.rs" 41 26 41 41
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 4 133 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 4 134 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 4 139 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 4 144 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 4 145 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 4 146 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  type t_Option'0 = C_None'0 | C_Some'0 Int32.t
  
  let rec as_ref (self_: t_Option) (return' (x: t_Option'0)) = any
    [ return''0 (result: t_Option'0) -> {[%#soption'12] self_ = C_None -> result = C_None'0}
      {[%#soption'13] self_ = C_None \/ (exists r: Int32.t. result = C_Some'0 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  let rec copied (self_: t_Option'0) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'14] match self_ with
        | C_None'0 -> result = C_None
        | C_Some'0 s -> result = C_Some s
        end}
      (! return' {result}) ]
  
  let rec is_none (self_: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'15] result = (self_ = C_None)} (! return' {result}) ]
  
  let rec unwrap (self_: t_Option) (return' (x: Int32.t)) = {[@expl:unwrap requires] [%#soption'16] self_ <> C_None}
    any [ return''0 (result: Int32.t) -> {[%#soption'17] C_Some result = self_} (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t Int32.t)
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'1)) = any
    [ return''0 (result: t_Option'1) -> {[%#soption'18] self_.current = C_None
      -> result = C_None'1 /\ self_.final = C_None}
      {[%#soption'19] self_.current = C_None
      \/ (exists r: MutBorrow.t Int32.t. result = C_Some'1 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec copied'0 (self_: t_Option'1) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'20] match self_ with
        | C_None'1 -> result = C_None
        | C_Some'1 s -> result = C_Some (s.current) /\ s.final = s.current
        end}
      (! return' {result}) ]
  
  type tuple = { _p0: t_Option'0; _p1: t_Option }
  
  predicate postcondition_once (self: ()) (args: Int32.t) (result: Int32.t) = let self_ = args in result = self_
  
  predicate resolve (_0: ()) = true
  
  predicate postcondition_mut (self: ()) (args: Int32.t) (result_state: ()) (result: Int32.t) =
    let self_ = args in result = self_
  
  function fn_mut_once (self: ()) (args: Int32.t) (res: Int32.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: Int32.t, res: Int32.t. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) = true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: Int32.t) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: Int32.t, res_state: (), res: Int32.t. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: Int32.t) (result: Int32.t) = let self_ = args in result = self_
  
  function fn_once (self: ()) (args: Int32.t) (res: Int32.t) : ()
  
  axiom fn_once_spec: forall self: (), args: Int32.t, res: Int32.t. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: Int32.t) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: Int32.t, res_state: (), res: Int32.t. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec clone' (self_: Int32.t) (return' (x: Int32.t)) = any
    [ return''0 (result: Int32.t) -> {[%#snum] result = self_} (! return' {result}) ]
  
  let rec cloned (self_: t_Option'0) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'21] match { _p0 = self_; _p1 = result } with
        | {_p0 = C_None'0; _p1 = C_None} -> true
        | {_p0 = C_Some'0 s; _p1 = C_Some r} -> postcondition () s r
        | _ -> false
        end}
      (! return' {result}) ]
  
  type tuple'0 = { _p0'0: t_Option'1; _p1'0: t_Option }
  
  let rec cloned'0 (self_: t_Option'1) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'22] match { _p0'0 = self_; _p1'0 = result } with
        | {_p0'0 = C_None'1; _p1'0 = C_None} -> true
        | {_p0'0 = C_Some'1 s; _p1'0 = C_Some r} -> postcondition () s.current r /\ s.final = s.current
        | _ -> false
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec copied_cloned [#"option.rs" 243 0 243 22] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &some <- C_Some ([%#soption] (1: Int32.t)) ] s2
      | s2 = as_ref {none} (fun (_ret: t_Option'0) -> [ &_7 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = copied {_7} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = is_none {_6} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb6) ]
    | bb6 = s0 [ s0 = as_ref {some} (fun (_ret: t_Option'0) -> [ &_14 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = copied {_14} (fun (_ret: t_Option) -> [ &_13 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = unwrap {_13} (fun (_ret: Int32.t) -> [ &_12 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_11 <- _12 = ([%#soption'0] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_11 = false} (! bb10) | br1 -> {_11} (! bb12) ] ]
    | bb12 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_22 <- _ret ] [ &none <- _ret.final ] s1)
      | s1 = as_mut {_22} (fun (_ret: t_Option'1) -> [ &_21 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0 [ s0 = copied'0 {_21} (fun (_ret: t_Option) -> [ &_20 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0 [ s0 = is_none {_20} (fun (_ret: bool) -> [ &_18 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = any [ br0 -> {_18 = false} (! bb16) | br1 -> {_18} (! bb18) ]
    | bb18 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_29 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = as_mut {_29} (fun (_ret: t_Option'1) -> [ &_28 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0 [ s0 = copied'0 {_28} (fun (_ret: t_Option) -> [ &_27 <- _ret ] s1) | s1 = bb20 ]
    | bb20 = s0 [ s0 = unwrap {_27} (fun (_ret: Int32.t) -> [ &_26 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = s0
      [ s0 = [ &_25 <- _26 = ([%#soption'1] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_25 = false} (! bb22) | br1 -> {_25} (! bb24) ] ]
    | bb24 = s0 [ s0 = as_ref {none} (fun (_ret: t_Option'0) -> [ &_35 <- _ret ] s1) | s1 = bb25 ]
    | bb25 = s0 [ s0 = cloned {_35} (fun (_ret: t_Option) -> [ &_34 <- _ret ] s1) | s1 = bb26 ]
    | bb26 = s0 [ s0 = is_none {_34} (fun (_ret: bool) -> [ &_32 <- _ret ] s1) | s1 = bb27 ]
    | bb27 = any [ br0 -> {_32 = false} (! bb28) | br1 -> {_32} (! bb30) ]
    | bb30 = s0 [ s0 = as_ref {some} (fun (_ret: t_Option'0) -> [ &_42 <- _ret ] s1) | s1 = bb31 ]
    | bb31 = s0 [ s0 = cloned {_42} (fun (_ret: t_Option) -> [ &_41 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0 [ s0 = unwrap {_41} (fun (_ret: Int32.t) -> [ &_40 <- _ret ] s1) | s1 = bb33 ]
    | bb33 = s0
      [ s0 = [ &_39 <- _40 = ([%#soption'2] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_39 = false} (! bb34) | br1 -> {_39} (! bb36) ] ]
    | bb36 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {none}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_50 <- _ret ] [ &none <- _ret.final ] s1)
      | s1 = as_mut {_50} (fun (_ret: t_Option'1) -> [ &_49 <- _ret ] s2)
      | s2 = bb37 ]
    | bb37 = s0 [ s0 = cloned'0 {_49} (fun (_ret: t_Option) -> [ &_48 <- _ret ] s1) | s1 = bb38 ]
    | bb38 = s0 [ s0 = is_none {_48} (fun (_ret: bool) -> [ &_46 <- _ret ] s1) | s1 = bb39 ]
    | bb39 = any [ br0 -> {_46 = false} (! bb40) | br1 -> {_46} (! bb42) ]
    | bb42 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option> {some}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_57 <- _ret ] [ &some <- _ret.final ] s1)
      | s1 = as_mut {_57} (fun (_ret: t_Option'1) -> [ &_56 <- _ret ] s2)
      | s2 = bb43 ]
    | bb43 = s0 [ s0 = cloned'0 {_56} (fun (_ret: t_Option) -> [ &_55 <- _ret ] s1) | s1 = bb44 ]
    | bb44 = s0 [ s0 = unwrap {_55} (fun (_ret: Int32.t) -> [ &_54 <- _ret ] s1) | s1 = bb45 ]
    | bb45 = s0
      [ s0 = [ &_53 <- _54 = ([%#soption'3] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_53 = false} (! bb46) | br1 -> {_53} (! bb48) ] ]
    | bb48 = return''0 {_0}
    | bb46 = {[%#soption'4] false} any
    | bb40 = {[%#soption'5] false} any
    | bb34 = {[%#soption'6] false} any
    | bb28 = {[%#soption'7] false} any
    | bb22 = {[%#soption'8] false} any
    | bb16 = {[%#soption'9] false} any
    | bb10 = {[%#soption'10] false} any
    | bb4 = {[%#soption'11] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some: t_Option = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _7: t_Option'0 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: Int32.t = Any.any_l ()
    | & _13: t_Option = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: t_Option = Any.any_l ()
    | & _21: t_Option'1 = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: Int32.t = Any.any_l ()
    | & _27: t_Option = Any.any_l ()
    | & _28: t_Option'1 = Any.any_l ()
    | & _29: MutBorrow.t t_Option = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _34: t_Option = Any.any_l ()
    | & _35: t_Option'0 = Any.any_l ()
    | & _39: bool = Any.any_l ()
    | & _40: Int32.t = Any.any_l ()
    | & _41: t_Option = Any.any_l ()
    | & _42: t_Option'0 = Any.any_l ()
    | & _46: bool = Any.any_l ()
    | & _48: t_Option = Any.any_l ()
    | & _49: t_Option'1 = Any.any_l ()
    | & _50: MutBorrow.t t_Option = Any.any_l ()
    | & _53: bool = Any.any_l ()
    | & _54: Int32.t = Any.any_l ()
    | & _55: t_Option = Any.any_l ()
    | & _56: t_Option'1 = Any.any_l ()
    | & _57: MutBorrow.t t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__zip_unzip [#"option.rs" 259 0 259 18]
  let%span soption = "option.rs" 262 37 262 38
  let%span soption'0 = "option.rs" 263 39 263 43
  let%span soption'1 = "option.rs" 268 45 268 46
  let%span soption'2 = "option.rs" 268 48 268 52
  let%span soption'3 = "option.rs" 271 49 271 50
  let%span soption'4 = "option.rs" 271 52 271 56
  let%span soption'5 = "option.rs" 277 33 277 34
  let%span soption'6 = "option.rs" 278 33 278 37
  let%span soption'7 = "option.rs" 278 12 278 38
  let%span soption'8 = "option.rs" 277 12 277 35
  let%span soption'9 = "option.rs" 276 12 276 32
  let%span soption'10 = "option.rs" 275 12 275 32
  let%span soption'11 = "option.rs" 268 12 268 54
  let%span soption'12 = "option.rs" 267 12 267 43
  let%span soption'13 = "option.rs" 266 12 266 43
  let%span soption'14 = "option.rs" 265 12 265 43
  let%span soption'15 = "../../creusot-contracts/src/std/option.rs" 469 26 473 17
  let%span soption'16 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'17 = "../../creusot-contracts/src/std/option.rs" 484 26 487 17
  let%span soption'18 = "../../creusot-contracts/src/std/option.rs" 787 8 790 9
  let%span soption'19 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 73 8 73 12
  let%span stuples = "../../creusot-contracts/src/std/tuples.rs" 21 28 21 57
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  type t_Option'0 = C_None'0 | C_Some'0 bool
  
  type tuple = { _p0: Int32.t; _p1: bool }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple
  
  type tuple'0 = { _p0'0: t_Option; _p1'0: t_Option'0 }
  
  predicate resolve (_0: bool) = true
  
  predicate resolve'0 (self: t_Option'0) =
    [%#soption'18] match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  predicate resolve'1 (_0: Int32.t) = true
  
  predicate resolve'2 (self: t_Option) =
    [%#soption'18] match self with
      | C_Some x -> resolve'1 x
      | C_None -> true
      end
  
  let rec zip (self_: t_Option) (other: t_Option'0) (return' (x: t_Option'1)) = any
    [ return''0 (result: t_Option'1) -> {[%#soption'15] match { _p0'0 = self_; _p1'0 = other } with
        | {_p0'0 = C_None} -> result = C_None'1 /\ resolve'0 other
        | {_p1'0 = C_None'0} -> result = C_None'1 /\ resolve'2 self_
        | {_p0'0 = C_Some t; _p1'0 = C_Some'0 u} -> result = C_Some'1 { _p0 = t; _p1 = u }
        end}
      (! return' {result}) ]
  
  type tuple'1 = { _p0'1: int; _p1'1: bool }
  
  type t_Option'2 = C_None'2 | C_Some'2 tuple'1
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  predicate deep_model'0 (self: bool) = [%#smodel'0] self
  
  function deep_model'1 (self: tuple) : tuple'1 = [%#stuples] { _p0'1 = deep_model self._p0;
                                                                _p1'1 = deep_model'0 self._p1 }
  
  function deep_model'2 (self: t_Option'1) : t_Option'2 = [%#soption'19] match self with
      | C_Some'1 t -> C_Some'2 (deep_model'1 t)
      | C_None'1 -> C_None'2
      end
  
  function deep_model'3 (self: t_Option'1) : t_Option'2 = [%#smodel] deep_model'2 self
  
  let rec eq (self_: t_Option'1) (rhs: t_Option'1) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'16] result = (deep_model'3 self_ = deep_model'3 rhs)}
      (! return' {result}) ]
  
  let rec unzip (self_: t_Option'1) (return' (x: tuple'0)) = any
    [ return''0 (result: tuple'0) -> {[%#soption'17] match self_ with
        | C_None'1 -> result = { _p0'0 = C_None; _p1'0 = C_None'0 }
        | C_Some'1 {_p0 = t; _p1 = u} -> result = { _p0'0 = C_Some t; _p1'0 = C_Some'0 u }
        end}
      (! return' {result}) ]
  
  type t_Option'3 = C_None'3 | C_Some'3 int
  
  function deep_model'4 (self: t_Option) : t_Option'3 = [%#soption'19] match self with
      | C_Some t -> C_Some'3 (deep_model t)
      | C_None -> C_None'3
      end
  
  function deep_model'5 (self: t_Option) : t_Option'3 = [%#smodel] deep_model'4 self
  
  let rec eq'0 (self_: t_Option) (rhs: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'16] result = (deep_model'5 self_ = deep_model'5 rhs)}
      (! return' {result}) ]
  
  function deep_model'6 (self: t_Option'0) : t_Option'0 = [%#soption'19] match self with
      | C_Some'0 t -> C_Some'0 (deep_model'0 t)
      | C_None'0 -> C_None'0
      end
  
  function deep_model'7 (self: t_Option'0) : t_Option'0 = [%#smodel] deep_model'6 self
  
  let rec eq'1 (self_: t_Option'0) (rhs: t_Option'0) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'16] result = (deep_model'7 self_ = deep_model'7 rhs)}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec zip_unzip [#"option.rs" 259 0 259 18] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none_int <- C_None ] s1
      | s1 = [ &none_bool <- C_None'0 ] s2
      | s2 = [ &some_int <- C_Some ([%#soption] (1: Int32.t)) ] s3
      | s3 = [ &some_bool <- C_Some'0 ([%#soption'0] true) ] s4
      | s4 = zip {none_int} {none_bool} (fun (_ret: t_Option'1) -> [ &_8 <- _ret ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None'1 ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option'1 = Any.any_l () | & _1: t_Option'1 = Any.any_l () ]
        [ _const_ret (_const: t_Option'1) -> [ &_80 <- _const ] s1 ]
      | s1 = eq {_8} {_80} (fun (_ret: bool) -> [ &_6 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_6 = false} (! bb3) | br1 -> {_6} (! bb5) ]
    | bb5 = s0 [ s0 = zip {none_int} {some_bool} (fun (_ret: t_Option'1) -> [ &_17 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None'1 ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option'1 = Any.any_l () | & _1: t_Option'1 = Any.any_l () ]
        [ _const_ret (_const: t_Option'1) -> [ &_79 <- _const ] s1 ]
      | s1 = eq {_17} {_79} (fun (_ret: bool) -> [ &_15 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = any [ br0 -> {_15 = false} (! bb8) | br1 -> {_15} (! bb10) ]
    | bb10 = s0 [ s0 = zip {some_int} {none_bool} (fun (_ret: t_Option'1) -> [ &_26 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None'1 ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option'1 = Any.any_l () | & _1: t_Option'1 = Any.any_l () ]
        [ _const_ret (_const: t_Option'1) -> [ &_78 <- _const ] s1 ]
      | s1 = eq {_26} {_78} (fun (_ret: bool) -> [ &_24 <- _ret ] s2)
      | s2 = bb12 ]
    | bb12 = any [ br0 -> {_24 = false} (! bb13) | br1 -> {_24} (! bb15) ]
    | bb15 = s0 [ s0 = zip {some_int} {some_bool} (fun (_ret: t_Option'1) -> [ &_35 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_2 <- { _p0 = ([%#soption'1] (1: Int32.t)); _p1 = ([%#soption'2] true) } ] s1'0
          | s1'0 = [ &_1 <- C_Some'1 _2 ] s2'0
          | s2'0 = [ &_0'0 <- _1 ] s3
          | s3 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option'1 = Any.any_l () | & _1: t_Option'1 = Any.any_l () | & _2: tuple = Any.any_l () ]
        [ _const_ret (_const: t_Option'1) -> [ &_77 <- _const ] s1 ]
      | s1 = eq {_35} {_77} (fun (_ret: bool) -> [ &_33 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = any [ br0 -> {_33 = false} (! bb18) | br1 -> {_33} (! bb20) ]
    | bb20 = s0
      [ s0 = [ &none_zipped <- C_None'1 ] s1
      | s1 = [ &_44 <- { _p0 = ([%#soption'3] (1: Int32.t)); _p1 = ([%#soption'4] true) } ] s2
      | s2 = [ &some_zipped <- C_Some'1 _44 ] s3
      | s3 = unzip {none_zipped} (fun (_ret: tuple'0) -> [ &none_unzip <- _ret ] s4)
      | s4 = bb21 ]
    | bb21 = s0 [ s0 = unzip {some_zipped} (fun (_ret: tuple'0) -> [ &some_unzip <- _ret ] s1) | s1 = bb22 ]
    | bb22 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_76 <- _const ] s1 ]
      | s1 = eq'0 {none_unzip._p0'0} {_76} (fun (_ret: bool) -> [ &_50 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = any [ br0 -> {_50 = false} (! bb24) | br1 -> {_50} (! bb26) ]
    | bb26 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None'0 ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option'0 = Any.any_l () | & _1: t_Option'0 = Any.any_l () ]
        [ _const_ret (_const: t_Option'0) -> [ &_75 <- _const ] s1 ]
      | s1 = eq'1 {none_unzip._p1'0} {_75} (fun (_ret: bool) -> [ &_56 <- _ret ] s2)
      | s2 = bb27 ]
    | bb27 = any [ br0 -> {_56 = false} (! bb28) | br1 -> {_56} (! bb30) ]
    | bb30 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some ([%#soption'5] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option = Any.any_l () | & _1: t_Option = Any.any_l () ]
        [ _const_ret (_const: t_Option) -> [ &_74 <- _const ] s1 ]
      | s1 = eq'0 {some_unzip._p0'0} {_74} (fun (_ret: bool) -> [ &_62 <- _ret ] s2)
      | s2 = bb31 ]
    | bb31 = any [ br0 -> {_62 = false} (! bb32) | br1 -> {_62} (! bb34) ]
    | bb34 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some'0 ([%#soption'6] true) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option'0 = Any.any_l () | & _1: t_Option'0 = Any.any_l () ]
        [ _const_ret (_const: t_Option'0) -> [ &_73 <- _const ] s1 ]
      | s1 = eq'1 {some_unzip._p1'0} {_73} (fun (_ret: bool) -> [ &_68 <- _ret ] s2)
      | s2 = bb35 ]
    | bb35 = any [ br0 -> {_68 = false} (! bb36) | br1 -> {_68} (! bb38) ]
    | bb38 = return''0 {_0}
    | bb36 = {[%#soption'7] false} any
    | bb32 = {[%#soption'8] false} any
    | bb28 = {[%#soption'9] false} any
    | bb24 = {[%#soption'10] false} any
    | bb18 = {[%#soption'11] false} any
    | bb13 = {[%#soption'12] false} any
    | bb8 = {[%#soption'13] false} any
    | bb3 = {[%#soption'14] false} any ]
    [ & _0: () = Any.any_l ()
    | & none_int: t_Option = Any.any_l ()
    | & none_bool: t_Option'0 = Any.any_l ()
    | & some_int: t_Option = Any.any_l ()
    | & some_bool: t_Option'0 = Any.any_l ()
    | & _6: bool = Any.any_l ()
    | & _8: t_Option'1 = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _17: t_Option'1 = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Option'1 = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _35: t_Option'1 = Any.any_l ()
    | & none_zipped: t_Option'1 = Any.any_l ()
    | & some_zipped: t_Option'1 = Any.any_l ()
    | & _44: tuple = Any.any_l ()
    | & none_unzip: tuple'0 = Any.any_l ()
    | & some_unzip: tuple'0 = Any.any_l ()
    | & _50: bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _62: bool = Any.any_l ()
    | & _68: bool = Any.any_l ()
    | & _73: t_Option'0 = Any.any_l ()
    | & _74: t_Option = Any.any_l ()
    | & _75: t_Option'0 = Any.any_l ()
    | & _76: t_Option = Any.any_l ()
    | & _77: t_Option'1 = Any.any_l ()
    | & _78: t_Option'1 = Any.any_l ()
    | & _79: t_Option'1 = Any.any_l ()
    | & _80: t_Option'1 = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__transpose [#"option.rs" 281 0 281 18]
  let%span soption = "option.rs" 283 53 283 54
  let%span soption'0 = "option.rs" 284 55 284 59
  let%span soption'1 = "option.rs" 287 49 287 50
  let%span soption'2 = "option.rs" 288 49 288 53
  let%span soption'3 = "option.rs" 288 12 288 53
  let%span soption'4 = "option.rs" 287 12 287 51
  let%span soption'5 = "option.rs" 286 12 286 45
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 558 26 562 17
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 25 18 25 67
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 15 8 18 9
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 36 8 36 28
  let%span sresult = "../../creusot-contracts/src/std/result.rs" 53 27 53 53
  let%span sresult'0 = "../../creusot-contracts/src/std/result.rs" 54 26 54 44
  let%span sresult'1 = "../../creusot-contracts/src/std/result.rs" 67 27 67 54
  let%span sresult'2 = "../../creusot-contracts/src/std/result.rs" 68 26 68 45
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Result = C_Ok Int32.t | C_Err bool
  
  type t_Option = C_None | C_Some t_Result
  
  type t_Option'0 = C_None'0 | C_Some'0 Int32.t
  
  type t_Result'0 = C_Ok'0 t_Option'0 | C_Err'0 bool
  
  let rec transpose (self_: t_Option) (return' (x: t_Result'0)) = any
    [ return''0 (result: t_Result'0) -> {[%#soption'6] match self_ with
        | C_None -> result = C_Ok'0 (C_None'0)
        | C_Some (C_Ok ok) -> result = C_Ok'0 (C_Some'0 ok)
        | C_Some (C_Err err) -> result = C_Err'0 err
        end}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Result'0) (return' (x: t_Option'0)) =
    {[@expl:unwrap requires] [%#sresult] exists t: t_Option'0. self_ = C_Ok'0 t}
    any [ return''0 (result: t_Option'0) -> {[%#sresult'0] C_Ok'0 result = self_} (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 int
  
  function deep_model (self: Int32.t) : int = [%#snum] Int32.to_int self
  
  function deep_model'0 (self: t_Option'0) : t_Option'1 = [%#soption'8] match self with
      | C_Some'0 t -> C_Some'1 (deep_model t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'1 (self: t_Option'0) : t_Option'1 = [%#smodel] deep_model'0 self
  
  let rec eq (self_: t_Option'0) (rhs: t_Option'0) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'7] result = (deep_model'1 self_ = deep_model'1 rhs)}
      (! return' {result}) ]
  
  let rec unwrap_err (self_: t_Result'0) (return' (x: bool)) =
    {[@expl:unwrap_err requires] [%#sresult'1] exists e: bool. self_ = C_Err'0 e}
    any [ return''0 (result: bool) -> {[%#sresult'2] C_Err'0 result = self_} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec transpose'0 [#"option.rs" 281 0 281 18] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- C_None ] s1
      | s1 = [ &_3 <- C_Ok ([%#soption] (1: Int32.t)) ] s2
      | s2 = [ &some_ok <- C_Some _3 ] s3
      | s3 = [ &_5 <- C_Err ([%#soption'0] true) ] s4
      | s4 = [ &some_err <- C_Some _5 ] s5
      | s5 = transpose {none} (fun (_ret: t_Result'0) -> [ &_10 <- _ret ] s6)
      | s6 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_10} (fun (_ret: t_Option'0) -> [ &_9 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- C_None'0 ] s1'0 | s1'0 = [ &_0'0 <- _1 ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: t_Option'0 = Any.any_l () | & _1: t_Option'0 = Any.any_l () ]
        [ _const_ret (_const: t_Option'0) -> [ &_31 <- _const ] s1 ]
      | s1 = eq {_9} {_31} (fun (_ret: bool) -> [ &_7 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = any [ br0 -> {_7 = false} (! bb4) | br1 -> {_7} (! bb6) ]
    | bb6 = s0 [ s0 = transpose {some_ok} (fun (_ret: t_Result'0) -> [ &_19 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = unwrap {_19} (fun (_ret: t_Option'0) -> [ &_18 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- C_Some'0 ([%#soption'1] (1: Int32.t)) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: t_Option'0 = Any.any_l () | & _1: t_Option'0 = Any.any_l () ]
        [ _const_ret (_const: t_Option'0) -> [ &_30 <- _const ] s1 ]
      | s1 = eq {_18} {_30} (fun (_ret: bool) -> [ &_16 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb12) ]
    | bb12 = s0 [ s0 = transpose {some_err} (fun (_ret: t_Result'0) -> [ &_27 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = unwrap_err {_27} (fun (_ret: bool) -> [ &_26 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = s0 [ s0 = [ &_25 <- _26 ] s1 | s1 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb17) ] ]
    | bb17 = return''0 {_0}
    | bb15 = {[%#soption'3] false} any
    | bb10 = {[%#soption'4] false} any
    | bb4 = {[%#soption'5] false} any ]
    [ & _0: () = Any.any_l ()
    | & none: t_Option = Any.any_l ()
    | & some_ok: t_Option = Any.any_l ()
    | & _3: t_Result = Any.any_l ()
    | & some_err: t_Option = Any.any_l ()
    | & _5: t_Result = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option'0 = Any.any_l ()
    | & _10: t_Result'0 = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: t_Option'0 = Any.any_l ()
    | & _19: t_Result'0 = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: t_Result'0 = Any.any_l ()
    | & _30: t_Option'0 = Any.any_l ()
    | & _31: t_Option'0 = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__flatten [#"option.rs" 291 0 291 16]
  let%span soption = "option.rs" 296 45 296 46
  let%span soption'0 = "option.rs" 297 38 297 39
  let%span soption'1 = "option.rs" 297 12 297 39
  let%span soption'2 = "option.rs" 295 12 295 35
  let%span soption'3 = "option.rs" 293 12 293 35
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 574 26 574 57
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 575 26 575 62
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 80 26 80 51
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 150 27 150 39
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 151 26 151 46
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some Int32.t
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  let rec flatten (self_: t_Option'0) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'4] self_ = C_None'0 -> result = C_None}
      {[%#soption'5] self_ = C_None'0 \/ self_ = C_Some'0 result}
      (! return' {result}) ]
  
  let rec is_none (self_: t_Option) (return' (x: bool)) = any
    [ return''0 (result: bool) -> {[%#soption'6] result = (self_ = C_None)} (! return' {result}) ]
  
  let rec unwrap (self_: t_Option) (return' (x: Int32.t)) = {[@expl:unwrap requires] [%#soption'7] self_ <> C_None}
    any [ return''0 (result: Int32.t) -> {[%#soption'8] C_Some result = self_} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec flatten'0 [#"option.rs" 291 0 291 16] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &opt <- C_None'0 ] s1 | s1 = flatten {opt} (fun (_ret: t_Option) -> [ &_5 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = is_none {_5} (fun (_ret: bool) -> [ &_3 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_3 = false} (! bb3) | br1 -> {_3} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &_9 <- C_None ] s1
      | s1 = [ &opt'0 <- C_Some'0 _9 ] s2
      | s2 = flatten {opt'0} (fun (_ret: t_Option) -> [ &_13 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = is_none {_13} (fun (_ret: bool) -> [ &_11 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = any [ br0 -> {_11 = false} (! bb8) | br1 -> {_11} (! bb10) ]
    | bb10 = s0
      [ s0 = [ &_17 <- C_Some ([%#soption] (1: Int32.t)) ] s1
      | s1 = [ &opt'1 <- C_Some'0 _17 ] s2
      | s2 = flatten {opt'1} (fun (_ret: t_Option) -> [ &_21 <- _ret ] s3)
      | s3 = bb11 ]
    | bb11 = s0 [ s0 = unwrap {_21} (fun (_ret: Int32.t) -> [ &_20 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = [ &_19 <- _20 = ([%#soption'0] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_19 = false} (! bb13) | br1 -> {_19} (! bb15) ] ]
    | bb15 = return''0 {_0}
    | bb13 = {[%#soption'1] false} any
    | bb8 = {[%#soption'2] false} any
    | bb3 = {[%#soption'3] false} any ]
    [ & _0: () = Any.any_l ()
    | & opt: t_Option'0 = Any.any_l ()
    | & _3: bool = Any.any_l ()
    | & _5: t_Option = Any.any_l ()
    | & opt'0: t_Option'0 = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: t_Option = Any.any_l ()
    | & opt'1: t_Option'0 = Any.any_l ()
    | & _17: t_Option = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _20: Int32.t = Any.any_l ()
    | & _21: t_Option = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_option__resolve [#"option.rs" 300 0 300 16]
  let%span soption = "option.rs" 302 16 302 17
  let%span soption'0 = "option.rs" 305 17 305 18
  let%span soption'1 = "option.rs" 308 16 308 17
  let%span soption'2 = "option.rs" 310 25 310 26
  let%span soption'3 = "option.rs" 311 17 311 18
  let%span soption'4 = "option.rs" 312 16 312 17
  let%span soption'5 = "option.rs" 313 16 313 17
  let%span soption'6 = "option.rs" 316 17 316 18
  let%span soption'7 = "option.rs" 316 27 316 28
  let%span soption'8 = "option.rs" 316 12 316 28
  let%span soption'9 = "option.rs" 319 16 319 17
  let%span soption'10 = "option.rs" 322 17 322 18
  let%span soption'11 = "option.rs" 324 16 324 17
  let%span soption'12 = "option.rs" 325 16 325 17
  let%span soption'13 = "option.rs" 329 17 329 18
  let%span soption'14 = "option.rs" 329 27 329 28
  let%span soption'15 = "option.rs" 329 12 329 28
  let%span soption'16 = "option.rs" 332 16 332 17
  let%span soption'17 = "option.rs" 333 16 333 17
  let%span soption'18 = "option.rs" 336 12 336 13
  let%span soption'19 = "option.rs" 337 17 337 18
  let%span soption'20 = "option.rs" 337 27 337 28
  let%span soption'21 = "option.rs" 337 12 337 28
  let%span soption'22 = "option.rs" 340 16 340 17
  let%span soption'23 = "option.rs" 341 16 341 17
  let%span soption'24 = "option.rs" 344 12 344 13
  let%span soption'25 = "option.rs" 345 17 345 18
  let%span soption'26 = "option.rs" 345 27 345 28
  let%span soption'27 = "option.rs" 345 12 345 28
  let%span soption'28 = "option.rs" 348 16 348 17
  let%span soption'29 = "option.rs" 351 17 351 18
  let%span soption'30 = "option.rs" 354 16 354 17
  let%span soption'31 = "option.rs" 357 17 357 18
  let%span soption'32 = "option.rs" 360 17 360 18
  let%span soption'33 = "option.rs" 360 12 360 18
  let%span soption'34 = "option.rs" 357 12 357 18
  let%span soption'35 = "option.rs" 351 12 351 18
  let%span soption'36 = "option.rs" 345 12 345 28
  let%span soption'37 = "option.rs" 337 12 337 28
  let%span soption'38 = "option.rs" 329 12 329 28
  let%span soption'39 = "option.rs" 322 12 322 18
  let%span soption'40 = "option.rs" 316 12 316 28
  let%span soption'41 = "option.rs" 311 12 311 18
  let%span soption'42 = "option.rs" 305 12 305 18
  let%span soption'43 = "option.rs" 304 12 304 37
  let%span soption'44 = "option.rs" 304 32 304 36
  let%span soption'45 = "../../creusot-contracts/src/std/option.rs" 63 27 66 17
  let%span soption'46 = "../../creusot-contracts/src/std/option.rs" 67 26 70 17
  let%span soption'47 = "../../creusot-contracts/src/std/option.rs" 305 26 305 75
  let%span soption'48 = "../../creusot-contracts/src/std/option.rs" 306 26 306 76
  let%span soption'49 = "../../creusot-contracts/src/std/option.rs" 352 26 352 57
  let%span soption'50 = "../../creusot-contracts/src/std/option.rs" 353 26 353 76
  let%span soption'51 = "option.rs" 321 27 321 32
  let%span soption'52 = "../../creusot-contracts/src/std/option.rs" 331 27 334 17
  let%span soption'53 = "../../creusot-contracts/src/std/option.rs" 335 26 341 17
  let%span soption'54 = "../../creusot-contracts/src/std/option.rs" 376 26 381 17
  let%span soption'55 = "../../creusot-contracts/src/std/option.rs" 390 26 393 17
  let%span soption'56 = "../../creusot-contracts/src/std/option.rs" 394 26 394 68
  let%span soption'57 = "../../creusot-contracts/src/std/option.rs" 404 26 407 17
  let%span soption'58 = "../../creusot-contracts/src/std/option.rs" 469 26 473 17
  let%span soption'59 = "../../creusot-contracts/src/std/option.rs" 528 26 531 17
  let%span soption'60 = "../../creusot-contracts/src/std/option.rs" 541 26 545 17
  let%span soption'61 = "option.rs" 304 28 304 31
  let%span soption'62 = "../../creusot-contracts/src/std/option.rs" 787 8 790 9
  let%span soption'63 = "option.rs" 321 23 321 26
  let%span snum = "../../creusot-contracts/src/std/num.rs" 41 26 41 41
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 4 133 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 4 134 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 4 139 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 4 144 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 4 145 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 4 146 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 52 20 52 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 38 8 38 42
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some (MutBorrow.t Int32.t)
  
  predicate resolve (self: MutBorrow.t Int32.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_0: MutBorrow.t Int32.t) = resolve _0
  
  let rec closure1 [#"option.rs" 304 28 304 31] [@coma:extspec] (self: ()) (_0: MutBorrow.t Int32.t)
    (return' (x: bool)) = bb0
    [ bb0 = s0 [ s0 = -{resolve'0 _2}- s1 | s1 = [ &_0'0 <- [%#soption'44] true ] s2 | s2 = return' {_0'0} ] ]
    [ & _0'0: bool = Any.any_l () | & _2: MutBorrow.t Int32.t = _0 ]
  
  predicate precondition (self: ()) (args: MutBorrow.t Int32.t) = [%#soption'61] let _0 = args in closure1'pre self _0
  
  predicate postcondition_once (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    [%#soption'61] let _0 = args in closure1'post'return' self _0 result
  
  let rec is_some_and (self_: t_Option) (f: ()) (return' (x: bool)) =
    {[@expl:is_some_and requires] [%#soption'45] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    any
    [ return''0 (result: bool) -> {[%#soption'46] match self_ with
        | C_None -> result = false
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 Int32.t
  
  predicate resolve'1 (_0: Int32.t) = true
  
  predicate resolve'2 (self: t_Option'0) =
    [%#soption'62] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  predicate resolve'3 (self: t_Option) =
    [%#soption'62] match self with
      | C_Some x -> resolve'0 x
      | C_None -> true
      end
  
  let rec and (self_: t_Option) (optb: t_Option'0) (return' (x: t_Option'0)) = any
    [ return''0 (result: t_Option'0) -> {[%#soption'47] self_ = C_None -> result = C_None'0 /\ resolve'2 optb}
      {[%#soption'48] self_ = C_None \/ result = optb /\ resolve'3 self_}
      (! return' {result}) ]
  
  let rec or (self_: t_Option) (optb: t_Option) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'49] self_ = C_None -> result = optb}
      {[%#soption'50] self_ = C_None \/ result = self_ /\ resolve'3 optb}
      (! return' {result}) ]
  
  predicate resolve'4 (_0: t_Option) = resolve'3 _0
  
  let rec closure0 [#"option.rs" 321 23 321 26] [@coma:extspec] (self: ()) (_0: MutBorrow.t Int32.t)
    (return' (x: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_0'0 <- [%#soption'51] false ] s1 | s1 = return' {_0'0} ] ] [ & _0'0: bool = Any.any_l () ]
  
  predicate precondition'0 (self: ()) (args: MutBorrow.t Int32.t) = [%#soption'63] let _0 = args in closure0'pre self _0
  
  predicate postcondition_once'0 (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    [%#soption'63] let _0 = args in closure0'post'return' self _0 result
  
  let rec filter (self_: t_Option) (predicate': ()) (return' (x: t_Option)) =
    {[@expl:filter requires] [%#soption'52] match self_ with
      | C_None -> true
      | C_Some t -> precondition'0 predicate' t
      end}
    any
    [ return''0 (result: t_Option) -> {[%#soption'53] match self_ with
        | C_None -> result = C_None
        | C_Some t -> match result with
          | C_None -> postcondition_once'0 predicate' t false /\ resolve'0 t
          | C_Some r -> postcondition_once'0 predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]
  
  type tuple = { _p0: t_Option; _p1: t_Option }
  
  let rec xor (self_: t_Option) (optb: t_Option) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#soption'54] match { _p0 = self_; _p1 = optb } with
        | {_p0 = C_None; _p1 = C_None} -> result = C_None
        | {_p0 = C_Some t1; _p1 = C_Some t2} -> result = C_None /\ resolve'0 t1 /\ resolve'0 t2
        | {_p0 = C_Some t; _p1 = C_None} -> result = C_Some t
        | {_p0 = C_None; _p1 = C_Some t} -> result = C_Some t
        end}
      (! return' {result}) ]
  
  let rec insert (self_: MutBorrow.t t_Option) (value: MutBorrow.t Int32.t)
    (return' (x: MutBorrow.t (MutBorrow.t Int32.t))) = any
    [ return''0 (result: MutBorrow.t (MutBorrow.t Int32.t)) -> {[%#soption'55] match self_.current with
        | C_Some t -> resolve'0 t
        | C_None -> true
        end}
      {[%#soption'56] result.current = value /\ self_.final = C_Some (result.final)}
      (! return' {result}) ]
  
  predicate resolve'5 (self: MutBorrow.t (MutBorrow.t Int32.t)) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 (_0: MutBorrow.t (MutBorrow.t Int32.t)) = resolve'5 _0
  
  let rec get_or_insert (self_: MutBorrow.t t_Option) (value: MutBorrow.t Int32.t)
    (return' (x: MutBorrow.t (MutBorrow.t Int32.t))) = any
    [ return''0 (result: MutBorrow.t (MutBorrow.t Int32.t)) -> {[%#soption'57] match self_.current with
        | C_None -> result.current = value /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final) /\ resolve'0 value
        end}
      (! return' {result}) ]
  
  type tuple'0 = { _p0'0: MutBorrow.t Int32.t; _p1'0: Int32.t }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple'0
  
  type tuple'1 = { _p0'1: t_Option; _p1'1: t_Option'0 }
  
  let rec zip (self_: t_Option) (other: t_Option'0) (return' (x: t_Option'1)) = any
    [ return''0 (result: t_Option'1) -> {[%#soption'58] match { _p0'1 = self_; _p1'1 = other } with
        | {_p0'1 = C_None} -> result = C_None'1 /\ resolve'2 other
        | {_p1'1 = C_None'0} -> result = C_None'1 /\ resolve'3 self_
        | {_p0'1 = C_Some t; _p1'1 = C_Some'0 u} -> result = C_Some'1 { _p0'0 = t; _p1'0 = u }
        end}
      (! return' {result}) ]
  
  predicate resolve'7 (self: tuple'0) = [%#sresolve'0] resolve'0 self._p0'0 /\ resolve'1 self._p1'0
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 (_0: tuple'0) = resolve'7 _0
  
  predicate resolve'9 (self: t_Option'1) =
    [%#soption'62] match self with
      | C_Some'1 x -> resolve'8 x
      | C_None'1 -> true
      end
  
  predicate resolve'10 (_0: t_Option'1) = resolve'9 _0
  
  let rec copied (self_: t_Option) (return' (x: t_Option'0)) = any
    [ return''0 (result: t_Option'0) -> {[%#soption'59] match self_ with
        | C_None -> result = C_None'0
        | C_Some s -> result = C_Some'0 (s.current) /\ s.final = s.current
        end}
      (! return' {result}) ]
  
  predicate postcondition_once'1 (self: ()) (args: Int32.t) (result: Int32.t) = let self_ = args in result = self_
  
  predicate resolve'11 (_0: ()) = true
  
  predicate postcondition_mut (self: ()) (args: Int32.t) (result_state: ()) (result: Int32.t) =
    let self_ = args in result = self_
  
  function fn_mut_once (self: ()) (args: Int32.t) (res: Int32.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: Int32.t, res: Int32.t. [%#sops'8] postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'11 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) = true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: Int32.t) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: Int32.t, res_state: (), res: Int32.t. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: Int32.t) (result: Int32.t) = let self_ = args in result = self_
  
  function fn_once (self: ()) (args: Int32.t) (res: Int32.t) : ()
  
  axiom fn_once_spec: forall self: (), args: Int32.t, res: Int32.t. [%#sops'0] postcondition_once'1 self args res
      = (postcondition self args res /\ resolve'11 self)
  
  function fn_mut (self: ()) (args: Int32.t) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: Int32.t, res_state: (), res: Int32.t. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec clone' (self_: Int32.t) (return' (x: Int32.t)) = any
    [ return''0 (result: Int32.t) -> {[%#snum] result = self_} (! return' {result}) ]
  
  let rec cloned (self_: t_Option) (return' (x: t_Option'0)) = any
    [ return''0 (result: t_Option'0) -> {[%#soption'60] match { _p0'1 = self_; _p1'1 = result } with
        | {_p0'1 = C_None; _p1'1 = C_None'0} -> true
        | {_p0'1 = C_Some s; _p1'1 = C_Some'0 r} -> postcondition () s.current r /\ s.final = s.current
        | _ -> false
        end}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec resolve'12 [#"option.rs" 300 0 300 16] (return' (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- [%#soption] (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_3 <- _ret ] [ &x <- _ret.final ] s2)
      | s2 = [ &opt <- C_Some _3 ] s3
      | s3 = [ &_7 <- () ] s4
      | s4 = is_some_and {opt} {_7} (fun (_ret: bool) -> [ &_5 <- _ret ] s5)
      | s5 = bb1 ]
    | bb1 = any [ br0 -> {_5 = false} (! bb2) | br1 -> {_5} (! bb4) ]
    | bb4 = s0
      [ s0 = [ &_10 <- x = ([%#soption'0] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_10 = false} (! bb5) | br1 -> {_10} (! bb7) ] ]
    | bb7 = s0
      [ s0 = [ &x'0 <- [%#soption'1] (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x'0}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_15 <- _ret ] [ &x'0 <- _ret.final ] s2)
      | s2 = [ &opt'0 <- C_Some _15 ] s3
      | s3 = [ &_18 <- C_Some'0 ([%#soption'2] (2: Int32.t)) ] s4
      | s4 = and {opt'0} {_18} (fun (_ret: t_Option'0) -> [ &_16 <- _ret ] s5)
      | s5 = bb8 ]
    | bb8 = s0
      [ s0 = [ &_20 <- x'0 = ([%#soption'3] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_20 = false} (! bb9) | br1 -> {_20} (! bb11) ] ]
    | bb11 = s0
      [ s0 = [ &x'1 <- [%#soption'4] (1: Int32.t) ] s1
      | s1 = [ &y <- [%#soption'5] (2: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x'1}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_26 <- _ret ] [ &x'1 <- _ret.final ] s3)
      | s3 = [ &opt'1 <- C_Some _26 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_29 <- _ret ] [ &y <- _ret.final ] s5)
      | s5 = [ &_28 <- C_Some _29 ] s6
      | s6 = or {_28} {opt'1} (fun (_ret: t_Option) -> [ &_27 <- _ret ] s7)
      | s7 = bb12 ]
    | bb12 = s0
      [ s0 = -{resolve'4 _27}- s1
      | s1 = [ &_33 <- x'1 = ([%#soption'6] (1: Int32.t)) ] s2
      | s2 = any [ br0 -> {_33 = false} (! bb14) | br1 -> {_33} (! bb13) ] ]
    | bb13 = s0 [ s0 = [ &_32 <- y = ([%#soption'7] (2: Int32.t)) ] s1 | s1 = bb15 ]
    | bb14 = s0 [ s0 = [ &_32 <- [%#soption'8] false ] s1 | s1 = bb15 ]
    | bb15 = any [ br0 -> {_32 = false} (! bb16) | br1 -> {_32} (! bb18) ]
    | bb18 = s0
      [ s0 = [ &x'2 <- [%#soption'9] (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x'2}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_39 <- _ret ] [ &x'2 <- _ret.final ] s2)
      | s2 = [ &opt'2 <- C_Some _39 ] s3
      | s3 = [ &_42 <- () ] s4
      | s4 = filter {opt'2} {_42} (fun (_ret: t_Option) -> [ &_40 <- _ret ] s5)
      | s5 = bb19 ]
    | bb19 = s0
      [ s0 = -{resolve'4 _40}- s1
      | s1 = [ &_44 <- x'2 = ([%#soption'10] (1: Int32.t)) ] s2
      | s2 = any [ br0 -> {_44 = false} (! bb20) | br1 -> {_44} (! bb22) ] ]
    | bb22 = s0
      [ s0 = [ &x'3 <- [%#soption'11] (1: Int32.t) ] s1
      | s1 = [ &y'0 <- [%#soption'12] (2: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x'3}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_50 <- _ret ] [ &x'3 <- _ret.final ] s3)
      | s3 = [ &optx <- C_Some _50 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y'0}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_52 <- _ret ] [ &y'0 <- _ret.final ] s5)
      | s5 = [ &opty <- C_Some _52 ] s6
      | s6 = xor {optx} {opty} (fun (_ret: t_Option) -> [ &_53 <- _ret ] s7)
      | s7 = bb23 ]
    | bb23 = s0
      [ s0 = -{resolve'4 _53}- s1
      | s1 = [ &_58 <- x'3 = ([%#soption'13] (1: Int32.t)) ] s2
      | s2 = any [ br0 -> {_58 = false} (! bb25) | br1 -> {_58} (! bb24) ] ]
    | bb24 = s0 [ s0 = [ &_57 <- y'0 = ([%#soption'14] (2: Int32.t)) ] s1 | s1 = bb26 ]
    | bb25 = s0 [ s0 = [ &_57 <- [%#soption'15] false ] s1 | s1 = bb26 ]
    | bb26 = any [ br0 -> {_57 = false} (! bb27) | br1 -> {_57} (! bb29) ]
    | bb29 = s0
      [ s0 = [ &x'4 <- [%#soption'16] (1: Int32.t) ] s1
      | s1 = [ &y'1 <- [%#soption'17] (2: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x'4}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_65 <- _ret ] [ &x'4 <- _ret.final ] s3)
      | s3 = [ &opt'3 <- C_Some _65 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y'1}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_69 <- _ret ] [ &y'1 <- _ret.final ] s5)
      | s5 = MutBorrow.borrow_mut <t_Option> {opt'3}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_67 <- _ret ] [ &opt'3 <- _ret.final ] s6)
      | s6 = MutBorrow.borrow_final <Int32.t> {_69.current} {MutBorrow.get_id _69}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_68 <- _ret ] [ &_69 <- { _69 with current = _ret.final } ] s7)
      | s7 = insert {_67} {_68} (fun (_ret: MutBorrow.t (MutBorrow.t Int32.t)) -> [ &bor <- _ret ] s8)
      | s8 = bb30 ]
    | bb30 = s0
      [ s0 = -{resolve'0 _69}- s1
      | s1 = [ &bor <- { bor with current = { bor.current with current = ([%#soption'18] (3: Int32.t)) } } ] s2
      | s2 = -{resolve'6 bor}- s3
      | s3 = -{resolve'4 opt'3}- s4
      | s4 = [ &_72 <- x'4 = ([%#soption'19] (1: Int32.t)) ] s5
      | s5 = any [ br0 -> {_72 = false} (! bb32) | br1 -> {_72} (! bb31) ] ]
    | bb31 = s0 [ s0 = [ &_71 <- y'1 = ([%#soption'20] (3: Int32.t)) ] s1 | s1 = bb33 ]
    | bb32 = s0 [ s0 = [ &_71 <- [%#soption'21] false ] s1 | s1 = bb33 ]
    | bb33 = any [ br0 -> {_71 = false} (! bb34) | br1 -> {_71} (! bb36) ]
    | bb36 = s0
      [ s0 = [ &x'5 <- [%#soption'22] (1: Int32.t) ] s1
      | s1 = [ &y'2 <- [%#soption'23] (2: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x'5}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_79 <- _ret ] [ &x'5 <- _ret.final ] s3)
      | s3 = [ &opt'4 <- C_Some _79 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y'2}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_83 <- _ret ] [ &y'2 <- _ret.final ] s5)
      | s5 = MutBorrow.borrow_mut <t_Option> {opt'4}
          (fun (_ret: MutBorrow.t t_Option) -> [ &_81 <- _ret ] [ &opt'4 <- _ret.final ] s6)
      | s6 = MutBorrow.borrow_final <Int32.t> {_83.current} {MutBorrow.get_id _83}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_82 <- _ret ] [ &_83 <- { _83 with current = _ret.final } ] s7)
      | s7 = get_or_insert {_81} {_82} (fun (_ret: MutBorrow.t (MutBorrow.t Int32.t)) -> [ &bor'0 <- _ret ] s8)
      | s8 = bb37 ]
    | bb37 = s0
      [ s0 = -{resolve'0 _83}- s1
      | s1 = [ &bor'0 <- { bor'0 with current = { bor'0.current with current = ([%#soption'24] (3: Int32.t)) } } ] s2
      | s2 = -{resolve'6 bor'0}- s3
      | s3 = -{resolve'4 opt'4}- s4
      | s4 = [ &_86 <- x'5 = ([%#soption'25] (3: Int32.t)) ] s5
      | s5 = any [ br0 -> {_86 = false} (! bb39) | br1 -> {_86} (! bb38) ] ]
    | bb38 = s0 [ s0 = [ &_85 <- y'2 = ([%#soption'26] (2: Int32.t)) ] s1 | s1 = bb40 ]
    | bb39 = s0 [ s0 = [ &_85 <- [%#soption'27] false ] s1 | s1 = bb40 ]
    | bb40 = any [ br0 -> {_85 = false} (! bb41) | br1 -> {_85} (! bb43) ]
    | bb43 = s0
      [ s0 = [ &x'6 <- [%#soption'28] (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x'6}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_92 <- _ret ] [ &x'6 <- _ret.final ] s2)
      | s2 = [ &opt'5 <- C_Some _92 ] s3
      | s3 = [ &_95 <- C_None'0 ] s4
      | s4 = zip {opt'5} {_95} (fun (_ret: t_Option'1) -> [ &_93 <- _ret ] s5)
      | s5 = bb44 ]
    | bb44 = s0
      [ s0 = -{resolve'10 _93}- s1
      | s1 = [ &_97 <- x'6 = ([%#soption'29] (1: Int32.t)) ] s2
      | s2 = any [ br0 -> {_97 = false} (! bb45) | br1 -> {_97} (! bb47) ] ]
    | bb47 = s0
      [ s0 = [ &x'7 <- [%#soption'30] (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x'7}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_102 <- _ret ] [ &x'7 <- _ret.final ] s2)
      | s2 = [ &opt'6 <- C_Some _102 ] s3
      | s3 = copied {opt'6} (fun (_ret: t_Option'0) -> [ &_103 <- _ret ] s4)
      | s4 = bb48 ]
    | bb48 = s0
      [ s0 = [ &_106 <- x'7 = ([%#soption'31] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_106 = false} (! bb49) | br1 -> {_106} (! bb51) ] ]
    | bb51 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {x'7}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_110 <- _ret ] [ &x'7 <- _ret.final ] s1)
      | s1 = [ &opt'7 <- C_Some _110 ] s2
      | s2 = cloned {opt'7} (fun (_ret: t_Option'0) -> [ &_111 <- _ret ] s3)
      | s3 = bb52 ]
    | bb52 = s0
      [ s0 = [ &_114 <- x'7 = ([%#soption'32] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_114 = false} (! bb53) | br1 -> {_114} (! bb55) ] ]
    | bb55 = return''0 {_0}
    | bb53 = {[%#soption'33] false} any
    | bb49 = {[%#soption'34] false} any
    | bb45 = {[%#soption'35] false} any
    | bb41 = {[%#soption'36] false} any
    | bb34 = {[%#soption'37] false} any
    | bb27 = {[%#soption'38] false} any
    | bb20 = {[%#soption'39] false} any
    | bb16 = {[%#soption'40] false} any
    | bb9 = {[%#soption'41] false} any
    | bb5 = {[%#soption'42] false} any
    | bb2 = {[%#soption'43] false} any ]
    [ & _0: () = Any.any_l ()
    | & x: Int32.t = Any.any_l ()
    | & opt: t_Option = Any.any_l ()
    | & _3: MutBorrow.t Int32.t = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: () = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & x'0: Int32.t = Any.any_l ()
    | & opt'0: t_Option = Any.any_l ()
    | & _15: MutBorrow.t Int32.t = Any.any_l ()
    | & _16: t_Option'0 = Any.any_l ()
    | & _18: t_Option'0 = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & x'1: Int32.t = Any.any_l ()
    | & y: Int32.t = Any.any_l ()
    | & opt'1: t_Option = Any.any_l ()
    | & _26: MutBorrow.t Int32.t = Any.any_l ()
    | & _27: t_Option = Any.any_l ()
    | & _28: t_Option = Any.any_l ()
    | & _29: MutBorrow.t Int32.t = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & x'2: Int32.t = Any.any_l ()
    | & opt'2: t_Option = Any.any_l ()
    | & _39: MutBorrow.t Int32.t = Any.any_l ()
    | & _40: t_Option = Any.any_l ()
    | & _42: () = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & x'3: Int32.t = Any.any_l ()
    | & y'0: Int32.t = Any.any_l ()
    | & optx: t_Option = Any.any_l ()
    | & _50: MutBorrow.t Int32.t = Any.any_l ()
    | & opty: t_Option = Any.any_l ()
    | & _52: MutBorrow.t Int32.t = Any.any_l ()
    | & _53: t_Option = Any.any_l ()
    | & _57: bool = Any.any_l ()
    | & _58: bool = Any.any_l ()
    | & x'4: Int32.t = Any.any_l ()
    | & y'1: Int32.t = Any.any_l ()
    | & opt'3: t_Option = Any.any_l ()
    | & _65: MutBorrow.t Int32.t = Any.any_l ()
    | & bor: MutBorrow.t (MutBorrow.t Int32.t) = Any.any_l ()
    | & _67: MutBorrow.t t_Option = Any.any_l ()
    | & _68: MutBorrow.t Int32.t = Any.any_l ()
    | & _69: MutBorrow.t Int32.t = Any.any_l ()
    | & _71: bool = Any.any_l ()
    | & _72: bool = Any.any_l ()
    | & x'5: Int32.t = Any.any_l ()
    | & y'2: Int32.t = Any.any_l ()
    | & opt'4: t_Option = Any.any_l ()
    | & _79: MutBorrow.t Int32.t = Any.any_l ()
    | & bor'0: MutBorrow.t (MutBorrow.t Int32.t) = Any.any_l ()
    | & _81: MutBorrow.t t_Option = Any.any_l ()
    | & _82: MutBorrow.t Int32.t = Any.any_l ()
    | & _83: MutBorrow.t Int32.t = Any.any_l ()
    | & _85: bool = Any.any_l ()
    | & _86: bool = Any.any_l ()
    | & x'6: Int32.t = Any.any_l ()
    | & opt'5: t_Option = Any.any_l ()
    | & _92: MutBorrow.t Int32.t = Any.any_l ()
    | & _93: t_Option'1 = Any.any_l ()
    | & _95: t_Option'0 = Any.any_l ()
    | & _97: bool = Any.any_l ()
    | & x'7: Int32.t = Any.any_l ()
    | & opt'6: t_Option = Any.any_l ()
    | & _102: MutBorrow.t Int32.t = Any.any_l ()
    | & _103: t_Option'0 = Any.any_l ()
    | & _106: bool = Any.any_l ()
    | & opt'7: t_Option = Any.any_l ()
    | & _110: MutBorrow.t Int32.t = Any.any_l ()
    | & _111: t_Option'0 = Any.any_l ()
    | & _114: bool = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
