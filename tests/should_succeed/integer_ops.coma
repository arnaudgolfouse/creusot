module M_test_bitwise_ops
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  use creusot.int.Int8BW
  use creusot.int.UInt16BW
  use creusot.int.Int16BW
  use creusot.int.UInt32BW
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.int.Int64BW
  use creusot.int.UInt128BW
  use creusot.int.Int128BW
  
  type tup2_ref_u8_ref_u8 = { f0: UInt8BW.t; f1: UInt8BW.t }
  
  type tup2_ref_i8_ref_i8 = { f0'0: Int8BW.t; f1'0: Int8BW.t }
  
  type tup2_ref_u16_ref_u16 = { f0'1: UInt16BW.t; f1'1: UInt16BW.t }
  
  type tup2_ref_i16_ref_i16 = { f0'2: Int16BW.t; f1'2: Int16BW.t }
  
  type tup2_ref_u32_ref_u32 = { f0'3: UInt32BW.t; f1'3: UInt32BW.t }
  
  type tup2_ref_i32_ref_i32 = { f0'4: Int32BW.t; f1'4: Int32BW.t }
  
  type tup2_ref_u64_ref_u64 = { f0'5: UInt64BW.t; f1'5: UInt64BW.t }
  
  type tup2_ref_i64_ref_i64 = { f0'6: Int64BW.t; f1'6: Int64BW.t }
  
  type tup2_ref_u128_ref_u128 = { f0'7: UInt128BW.t; f1'7: UInt128BW.t }
  
  type tup2_ref_i128_ref_i128 = { f0'8: Int128BW.t; f1'8: Int128BW.t }
  
  type tup2_ref_usize_ref_usize = { f0'9: UInt64BW.t; f1'9: UInt64BW.t }
  
  type tup2_ref_isize_ref_isize = { f0'10: Int64BW.t; f1'10: Int64BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_bitwise_ops (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt8BW.bw_and (240: UInt8BW.t) (60: UInt8BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt8BW.t) -> [ &_1012 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (48: UInt8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () ] [ _const_ret (_const: UInt8BW.t) -> [ &_1011 <- _const ] s2 ]
      | s2 = [ &_2 <- { f0 = _1012; f1 = _1011 } ] s3
      | s3 = [ &left_val <- _2.f0 ] s4
      | s4 = [ &right_val <- _2.f1 ] s5
      | s5 = [ &_9 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_9 = false} (! bb2) | br1 -> {_9} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int8BW.bw_and (113: Int8BW.t) (61: Int8BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_1010 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (49: Int8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () ] [ _const_ret (_const: Int8BW.t) -> [ &_1009 <- _const ] s2 ]
      | s2 = [ &_22 <- { f0'0 = _1010; f1'0 = _1009 } ] s3
      | s3 = [ &left_val'0 <- _22.f0'0 ] s4
      | s4 = [ &right_val'0 <- _22.f1'0 ] s5
      | s5 = [ &_29 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_29 = false} (! bb4) | br1 -> {_29} (! bb3) ] ]
    | bb3 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt16BW.bw_and (42225: UInt16BW.t) (21565: UInt16BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt16BW.t) -> [ &_1008 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1073: UInt16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () ] [ _const_ret (_const: UInt16BW.t) -> [ &_1007 <- _const ] s2 ]
      | s2 = [ &_42 <- { f0'1 = _1008; f1'1 = _1007 } ] s3
      | s3 = [ &left_val'1 <- _42.f0'1 ] s4
      | s4 = [ &right_val'1 <- _42.f1'1 ] s5
      | s5 = [ &_49 <- left_val'1 = right_val'1 ] s6
      | s6 = any [ br0 -> {_49 = false} (! bb6) | br1 -> {_49} (! bb5) ] ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int16BW.bw_and (13553: Int16BW.t) (21565: Int16BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ]
        [ _const_ret (_const: Int16BW.t) -> [ &_1006 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (5169: Int16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16BW.t = Any.any_l () ] [ _const_ret (_const: Int16BW.t) -> [ &_1005 <- _const ] s2 ]
      | s2 = [ &_62 <- { f0'2 = _1006; f1'2 = _1005 } ] s3
      | s3 = [ &left_val'2 <- _62.f0'2 ] s4
      | s4 = [ &right_val'2 <- _62.f1'2 ] s5
      | s5 = [ &_69 <- left_val'2 = right_val'2 ] s6
      | s6 = any [ br0 -> {_69 = false} (! bb8) | br1 -> {_69} (! bb7) ] ]
    | bb7 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt32BW.bw_and (3221225475: UInt32BW.t) (1073840130: UInt32BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt32BW.t) -> [ &_1004 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1073741826: UInt32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () ] [ _const_ret (_const: UInt32BW.t) -> [ &_1003 <- _const ] s2 ]
      | s2 = [ &_82 <- { f0'3 = _1004; f1'3 = _1003 } ] s3
      | s3 = [ &left_val'3 <- _82.f0'3 ] s4
      | s4 = [ &right_val'3 <- _82.f1'3 ] s5
      | s5 = [ &_89 <- left_val'3 = right_val'3 ] s6
      | s6 = any [ br0 -> {_89 = false} (! bb10) | br1 -> {_89} (! bb9) ] ]
    | bb9 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int32BW.bw_and (1073741839: Int32BW.t) (1073745665: Int32BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ]
        [ _const_ret (_const: Int32BW.t) -> [ &_1002 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1073741825: Int32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32BW.t = Any.any_l () ] [ _const_ret (_const: Int32BW.t) -> [ &_1001 <- _const ] s2 ]
      | s2 = [ &_102 <- { f0'4 = _1002; f1'4 = _1001 } ] s3
      | s3 = [ &left_val'4 <- _102.f0'4 ] s4
      | s4 = [ &right_val'4 <- _102.f1'4 ] s5
      | s5 = [ &_109 <- left_val'4 = right_val'4 ] s6
      | s6 = any [ br0 -> {_109 = false} (! bb12) | br1 -> {_109} (! bb11) ] ]
    | bb11 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt64BW.bw_and (13835321938072829955: UInt64BW.t) (9223838229784952833: UInt64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_1000 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (9223547958715219969: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_999 <- _const ] s2 ]
      | s2 = [ &_122 <- { f0'5 = _1000; f1'5 = _999 } ] s3
      | s3 = [ &left_val'5 <- _122.f0'5 ] s4
      | s4 = [ &right_val'5 <- _122.f1'5 ] s5
      | s5 = [ &_129 <- left_val'5 = right_val'5 ] s6
      | s6 = any [ br0 -> {_129 = false} (! bb14) | br1 -> {_129} (! bb13) ] ]
    | bb13 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int64BW.bw_and (4611686018437454224: Int64BW.t) (5226577450909599872: Int64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_998 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (4611686018436335744: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_997 <- _const ] s2 ]
      | s2 = [ &_142 <- { f0'6 = _998; f1'6 = _997 } ] s3
      | s3 = [ &left_val'6 <- _142.f0'6 ] s4
      | s4 = [ &right_val'6 <- _142.f1'6 ] s5
      | s5 = [ &_149 <- left_val'6 = right_val'6 ] s6
      | s6 = any [ br0 -> {_149 = false} (! bb16) | br1 -> {_149} (! bb15) ] ]
    | bb15 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 =
            [ &_1 <- UInt128BW.bw_and (4514840875923203424259: UInt128BW.t) (3108276842612989624321: UInt128BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_996 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (2960702599752243478529: UInt128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () ] [ _const_ret (_const: UInt128BW.t) -> [ &_995 <- _const ] s2 ]
      | s2 = [ &_162 <- { f0'7 = _996; f1'7 = _995 } ] s3
      | s3 = [ &left_val'7 <- _162.f0'7 ] s4
      | s4 = [ &right_val'7 <- _162.f1'7 ] s5
      | s5 = [ &_169 <- left_val'7 = right_val'7 ] s6
      | s6 = any [ br0 -> {_169 = false} (! bb18) | br1 -> {_169} (! bb17) ] ]
    | bb17 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int128BW.bw_and (4514840875923203424259: Int128BW.t) (3108276842612989624321: Int128BW.t) ]
            s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ]
        [ _const_ret (_const: Int128BW.t) -> [ &_994 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (2960702599752243478529: Int128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128BW.t = Any.any_l () ] [ _const_ret (_const: Int128BW.t) -> [ &_993 <- _const ] s2 ]
      | s2 = [ &_182 <- { f0'8 = _994; f1'8 = _993 } ] s3
      | s3 = [ &left_val'8 <- _182.f0'8 ] s4
      | s4 = [ &right_val'8 <- _182.f1'8 ] s5
      | s5 = [ &_189 <- left_val'8 = right_val'8 ] s6
      | s6 = any [ br0 -> {_189 = false} (! bb20) | br1 -> {_189} (! bb19) ] ]
    | bb19 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt64BW.bw_and (240: UInt64BW.t) (60: UInt64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_992 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (48: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_991 <- _const ] s2 ]
      | s2 = [ &_202 <- { f0'9 = _992; f1'9 = _991 } ] s3
      | s3 = [ &left_val'9 <- _202.f0'9 ] s4
      | s4 = [ &right_val'9 <- _202.f1'9 ] s5
      | s5 = [ &_209 <- left_val'9 = right_val'9 ] s6
      | s6 = any [ br0 -> {_209 = false} (! bb22) | br1 -> {_209} (! bb21) ] ]
    | bb21 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int64BW.bw_and (113: Int64BW.t) (61: Int64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_990 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (49: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_989 <- _const ] s2 ]
      | s2 = [ &_222 <- { f0'10 = _990; f1'10 = _989 } ] s3
      | s3 = [ &left_val'10 <- _222.f0'10 ] s4
      | s4 = [ &right_val'10 <- _222.f1'10 ] s5
      | s5 = [ &_229 <- left_val'10 = right_val'10 ] s6
      | s6 = any [ br0 -> {_229 = false} (! bb24) | br1 -> {_229} (! bb23) ] ]
    | bb23 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt8BW.bw_or (240: UInt8BW.t) (60: UInt8BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt8BW.t) -> [ &_988 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (252: UInt8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () ] [ _const_ret (_const: UInt8BW.t) -> [ &_987 <- _const ] s2 ]
      | s2 = [ &_242 <- { f0 = _988; f1 = _987 } ] s3
      | s3 = [ &left_val'11 <- _242.f0 ] s4
      | s4 = [ &right_val'11 <- _242.f1 ] s5
      | s5 = [ &_249 <- left_val'11 = right_val'11 ] s6
      | s6 = any [ br0 -> {_249 = false} (! bb26) | br1 -> {_249} (! bb25) ] ]
    | bb25 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int8BW.bw_or (113: Int8BW.t) (61: Int8BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_986 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (125: Int8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () ] [ _const_ret (_const: Int8BW.t) -> [ &_985 <- _const ] s2 ]
      | s2 = [ &_262 <- { f0'0 = _986; f1'0 = _985 } ] s3
      | s3 = [ &left_val'12 <- _262.f0'0 ] s4
      | s4 = [ &right_val'12 <- _262.f1'0 ] s5
      | s5 = [ &_269 <- left_val'12 = right_val'12 ] s6
      | s6 = any [ br0 -> {_269 = false} (! bb28) | br1 -> {_269} (! bb27) ] ]
    | bb27 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt16BW.bw_or (42225: UInt16BW.t) (21565: UInt16BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt16BW.t) -> [ &_984 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (62717: UInt16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () ] [ _const_ret (_const: UInt16BW.t) -> [ &_983 <- _const ] s2 ]
      | s2 = [ &_282 <- { f0'1 = _984; f1'1 = _983 } ] s3
      | s3 = [ &left_val'13 <- _282.f0'1 ] s4
      | s4 = [ &right_val'13 <- _282.f1'1 ] s5
      | s5 = [ &_289 <- left_val'13 = right_val'13 ] s6
      | s6 = any [ br0 -> {_289 = false} (! bb30) | br1 -> {_289} (! bb29) ] ]
    | bb29 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int16BW.bw_or (13553: Int16BW.t) (21565: Int16BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ]
        [ _const_ret (_const: Int16BW.t) -> [ &_982 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (29949: Int16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16BW.t = Any.any_l () ] [ _const_ret (_const: Int16BW.t) -> [ &_981 <- _const ] s2 ]
      | s2 = [ &_302 <- { f0'2 = _982; f1'2 = _981 } ] s3
      | s3 = [ &left_val'14 <- _302.f0'2 ] s4
      | s4 = [ &right_val'14 <- _302.f1'2 ] s5
      | s5 = [ &_309 <- left_val'14 = right_val'14 ] s6
      | s6 = any [ br0 -> {_309 = false} (! bb32) | br1 -> {_309} (! bb31) ] ]
    | bb31 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt32BW.bw_or (3221225475: UInt32BW.t) (1073840130: UInt32BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt32BW.t) -> [ &_980 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (3221323779: UInt32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () ] [ _const_ret (_const: UInt32BW.t) -> [ &_979 <- _const ] s2 ]
      | s2 = [ &_322 <- { f0'3 = _980; f1'3 = _979 } ] s3
      | s3 = [ &left_val'15 <- _322.f0'3 ] s4
      | s4 = [ &right_val'15 <- _322.f1'3 ] s5
      | s5 = [ &_329 <- left_val'15 = right_val'15 ] s6
      | s6 = any [ br0 -> {_329 = false} (! bb34) | br1 -> {_329} (! bb33) ] ]
    | bb33 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int32BW.bw_or (1073741839: Int32BW.t) (1073745665: Int32BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ]
        [ _const_ret (_const: Int32BW.t) -> [ &_978 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1073745679: Int32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32BW.t = Any.any_l () ] [ _const_ret (_const: Int32BW.t) -> [ &_977 <- _const ] s2 ]
      | s2 = [ &_342 <- { f0'4 = _978; f1'4 = _977 } ] s3
      | s3 = [ &left_val'16 <- _342.f0'4 ] s4
      | s4 = [ &right_val'16 <- _342.f1'4 ] s5
      | s5 = [ &_349 <- left_val'16 = right_val'16 ] s6
      | s6 = any [ br0 -> {_349 = false} (! bb36) | br1 -> {_349} (! bb35) ] ]
    | bb35 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt64BW.bw_or (13835321938072829955: UInt64BW.t) (9223838229784952833: UInt64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_976 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (13835612209142562819: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_975 <- _const ] s2 ]
      | s2 = [ &_362 <- { f0'5 = _976; f1'5 = _975 } ] s3
      | s3 = [ &left_val'17 <- _362.f0'5 ] s4
      | s4 = [ &right_val'17 <- _362.f1'5 ] s5
      | s5 = [ &_369 <- left_val'17 = right_val'17 ] s6
      | s6 = any [ br0 -> {_369 = false} (! bb38) | br1 -> {_369} (! bb37) ] ]
    | bb37 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int64BW.bw_or (4611686018437454224: Int64BW.t) (5226577450909599872: Int64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_974 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (5226577450910718352: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_973 <- _const ] s2 ]
      | s2 = [ &_382 <- { f0'6 = _974; f1'6 = _973 } ] s3
      | s3 = [ &left_val'18 <- _382.f0'6 ] s4
      | s4 = [ &right_val'18 <- _382.f1'6 ] s5
      | s5 = [ &_389 <- left_val'18 = right_val'18 ] s6
      | s6 = any [ br0 -> {_389 = false} (! bb40) | br1 -> {_389} (! bb39) ] ]
    | bb39 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 =
            [ &_1 <- UInt128BW.bw_or (4514840875923203424259: UInt128BW.t) (3108276842612989624321: UInt128BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_972 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (4662415118783949570051: UInt128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () ] [ _const_ret (_const: UInt128BW.t) -> [ &_971 <- _const ] s2 ]
      | s2 = [ &_402 <- { f0'7 = _972; f1'7 = _971 } ] s3
      | s3 = [ &left_val'19 <- _402.f0'7 ] s4
      | s4 = [ &right_val'19 <- _402.f1'7 ] s5
      | s5 = [ &_409 <- left_val'19 = right_val'19 ] s6
      | s6 = any [ br0 -> {_409 = false} (! bb42) | br1 -> {_409} (! bb41) ] ]
    | bb41 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int128BW.bw_or (4514840875923203424259: Int128BW.t) (3108276842612989624321: Int128BW.t) ]
            s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ]
        [ _const_ret (_const: Int128BW.t) -> [ &_970 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (4662415118783949570051: Int128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128BW.t = Any.any_l () ] [ _const_ret (_const: Int128BW.t) -> [ &_969 <- _const ] s2 ]
      | s2 = [ &_422 <- { f0'8 = _970; f1'8 = _969 } ] s3
      | s3 = [ &left_val'20 <- _422.f0'8 ] s4
      | s4 = [ &right_val'20 <- _422.f1'8 ] s5
      | s5 = [ &_429 <- left_val'20 = right_val'20 ] s6
      | s6 = any [ br0 -> {_429 = false} (! bb44) | br1 -> {_429} (! bb43) ] ]
    | bb43 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt64BW.bw_or (240: UInt64BW.t) (60: UInt64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_968 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (252: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_967 <- _const ] s2 ]
      | s2 = [ &_442 <- { f0'9 = _968; f1'9 = _967 } ] s3
      | s3 = [ &left_val'21 <- _442.f0'9 ] s4
      | s4 = [ &right_val'21 <- _442.f1'9 ] s5
      | s5 = [ &_449 <- left_val'21 = right_val'21 ] s6
      | s6 = any [ br0 -> {_449 = false} (! bb46) | br1 -> {_449} (! bb45) ] ]
    | bb45 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int64BW.bw_or (113: Int64BW.t) (61: Int64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_966 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (125: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_965 <- _const ] s2 ]
      | s2 = [ &_462 <- { f0'10 = _966; f1'10 = _965 } ] s3
      | s3 = [ &left_val'22 <- _462.f0'10 ] s4
      | s4 = [ &right_val'22 <- _462.f1'10 ] s5
      | s5 = [ &_469 <- left_val'22 = right_val'22 ] s6
      | s6 = any [ br0 -> {_469 = false} (! bb48) | br1 -> {_469} (! bb47) ] ]
    | bb47 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt8BW.bw_xor (240: UInt8BW.t) (60: UInt8BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt8BW.t) -> [ &_964 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (204: UInt8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () ] [ _const_ret (_const: UInt8BW.t) -> [ &_963 <- _const ] s2 ]
      | s2 = [ &_482 <- { f0 = _964; f1 = _963 } ] s3
      | s3 = [ &left_val'23 <- _482.f0 ] s4
      | s4 = [ &right_val'23 <- _482.f1 ] s5
      | s5 = [ &_489 <- left_val'23 = right_val'23 ] s6
      | s6 = any [ br0 -> {_489 = false} (! bb50) | br1 -> {_489} (! bb49) ] ]
    | bb49 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int8BW.bw_xor (113: Int8BW.t) (61: Int8BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_962 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (76: Int8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () ] [ _const_ret (_const: Int8BW.t) -> [ &_961 <- _const ] s2 ]
      | s2 = [ &_502 <- { f0'0 = _962; f1'0 = _961 } ] s3
      | s3 = [ &left_val'24 <- _502.f0'0 ] s4
      | s4 = [ &right_val'24 <- _502.f1'0 ] s5
      | s5 = [ &_509 <- left_val'24 = right_val'24 ] s6
      | s6 = any [ br0 -> {_509 = false} (! bb52) | br1 -> {_509} (! bb51) ] ]
    | bb51 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt16BW.bw_xor (42225: UInt16BW.t) (21565: UInt16BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt16BW.t) -> [ &_960 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (61644: UInt16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () ] [ _const_ret (_const: UInt16BW.t) -> [ &_959 <- _const ] s2 ]
      | s2 = [ &_522 <- { f0'1 = _960; f1'1 = _959 } ] s3
      | s3 = [ &left_val'25 <- _522.f0'1 ] s4
      | s4 = [ &right_val'25 <- _522.f1'1 ] s5
      | s5 = [ &_529 <- left_val'25 = right_val'25 ] s6
      | s6 = any [ br0 -> {_529 = false} (! bb54) | br1 -> {_529} (! bb53) ] ]
    | bb53 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int16BW.bw_xor (13553: Int16BW.t) (21565: Int16BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ]
        [ _const_ret (_const: Int16BW.t) -> [ &_958 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (24780: Int16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16BW.t = Any.any_l () ] [ _const_ret (_const: Int16BW.t) -> [ &_957 <- _const ] s2 ]
      | s2 = [ &_542 <- { f0'2 = _958; f1'2 = _957 } ] s3
      | s3 = [ &left_val'26 <- _542.f0'2 ] s4
      | s4 = [ &right_val'26 <- _542.f1'2 ] s5
      | s5 = [ &_549 <- left_val'26 = right_val'26 ] s6
      | s6 = any [ br0 -> {_549 = false} (! bb56) | br1 -> {_549} (! bb55) ] ]
    | bb55 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt32BW.bw_xor (3221225475: UInt32BW.t) (1073840130: UInt32BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt32BW.t) -> [ &_956 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (2147581953: UInt32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () ] [ _const_ret (_const: UInt32BW.t) -> [ &_955 <- _const ] s2 ]
      | s2 = [ &_562 <- { f0'3 = _956; f1'3 = _955 } ] s3
      | s3 = [ &left_val'27 <- _562.f0'3 ] s4
      | s4 = [ &right_val'27 <- _562.f1'3 ] s5
      | s5 = [ &_569 <- left_val'27 = right_val'27 ] s6
      | s6 = any [ br0 -> {_569 = false} (! bb58) | br1 -> {_569} (! bb57) ] ]
    | bb57 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int32BW.bw_xor (1073741839: Int32BW.t) (1073745665: Int32BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ]
        [ _const_ret (_const: Int32BW.t) -> [ &_954 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (3854: Int32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32BW.t = Any.any_l () ] [ _const_ret (_const: Int32BW.t) -> [ &_953 <- _const ] s2 ]
      | s2 = [ &_582 <- { f0'4 = _954; f1'4 = _953 } ] s3
      | s3 = [ &left_val'28 <- _582.f0'4 ] s4
      | s4 = [ &right_val'28 <- _582.f1'4 ] s5
      | s5 = [ &_589 <- left_val'28 = right_val'28 ] s6
      | s6 = any [ br0 -> {_589 = false} (! bb60) | br1 -> {_589} (! bb59) ] ]
    | bb59 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt64BW.bw_xor (13835321938072829955: UInt64BW.t) (9223838229784952833: UInt64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_952 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (4612064250427342850: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_951 <- _const ] s2 ]
      | s2 = [ &_602 <- { f0'5 = _952; f1'5 = _951 } ] s3
      | s3 = [ &left_val'29 <- _602.f0'5 ] s4
      | s4 = [ &right_val'29 <- _602.f1'5 ] s5
      | s5 = [ &_609 <- left_val'29 = right_val'29 ] s6
      | s6 = any [ br0 -> {_609 = false} (! bb62) | br1 -> {_609} (! bb61) ] ]
    | bb61 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int64BW.bw_xor (4611686018437454224: Int64BW.t) (5226577450909599872: Int64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_950 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (614891432474382608: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_949 <- _const ] s2 ]
      | s2 = [ &_622 <- { f0'6 = _950; f1'6 = _949 } ] s3
      | s3 = [ &left_val'30 <- _622.f0'6 ] s4
      | s4 = [ &right_val'30 <- _622.f1'6 ] s5
      | s5 = [ &_629 <- left_val'30 = right_val'30 ] s6
      | s6 = any [ br0 -> {_629 = false} (! bb64) | br1 -> {_629} (! bb63) ] ]
    | bb63 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 =
            [ &_1 <- UInt128BW.bw_xor (4514840875923203424259: UInt128BW.t) (3108276842612989624321: UInt128BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_948 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1701712519031706091522: UInt128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () ] [ _const_ret (_const: UInt128BW.t) -> [ &_947 <- _const ] s2 ]
      | s2 = [ &_642 <- { f0'7 = _948; f1'7 = _947 } ] s3
      | s3 = [ &left_val'31 <- _642.f0'7 ] s4
      | s4 = [ &right_val'31 <- _642.f1'7 ] s5
      | s5 = [ &_649 <- left_val'31 = right_val'31 ] s6
      | s6 = any [ br0 -> {_649 = false} (! bb66) | br1 -> {_649} (! bb65) ] ]
    | bb65 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int128BW.bw_xor (4514840875923203424259: Int128BW.t) (3108276842612989624321: Int128BW.t) ]
            s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ]
        [ _const_ret (_const: Int128BW.t) -> [ &_946 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1701712519031706091522: Int128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128BW.t = Any.any_l () ] [ _const_ret (_const: Int128BW.t) -> [ &_945 <- _const ] s2 ]
      | s2 = [ &_662 <- { f0'8 = _946; f1'8 = _945 } ] s3
      | s3 = [ &left_val'32 <- _662.f0'8 ] s4
      | s4 = [ &right_val'32 <- _662.f1'8 ] s5
      | s5 = [ &_669 <- left_val'32 = right_val'32 ] s6
      | s6 = any [ br0 -> {_669 = false} (! bb68) | br1 -> {_669} (! bb67) ] ]
    | bb67 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt64BW.bw_xor (240: UInt64BW.t) (60: UInt64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_944 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (204: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_943 <- _const ] s2 ]
      | s2 = [ &_682 <- { f0'9 = _944; f1'9 = _943 } ] s3
      | s3 = [ &left_val'33 <- _682.f0'9 ] s4
      | s4 = [ &right_val'33 <- _682.f1'9 ] s5
      | s5 = [ &_689 <- left_val'33 = right_val'33 ] s6
      | s6 = any [ br0 -> {_689 = false} (! bb70) | br1 -> {_689} (! bb69) ] ]
    | bb69 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int64BW.bw_xor (113: Int64BW.t) (61: Int64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_942 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (76: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_941 <- _const ] s2 ]
      | s2 = [ &_702 <- { f0'10 = _942; f1'10 = _941 } ] s3
      | s3 = [ &left_val'34 <- _702.f0'10 ] s4
      | s4 = [ &right_val'34 <- _702.f1'10 ] s5
      | s5 = [ &_709 <- left_val'34 = right_val'34 ] s6
      | s6 = any [ br0 -> {_709 = false} (! bb72) | br1 -> {_709} (! bb71) ] ]
    | bb71 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt8BW.bw_not (240: UInt8BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt8BW.t) -> [ &_940 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (15: UInt8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () ] [ _const_ret (_const: UInt8BW.t) -> [ &_939 <- _const ] s2 ]
      | s2 = [ &_722 <- { f0 = _940; f1 = _939 } ] s3
      | s3 = [ &left_val'35 <- _722.f0 ] s4
      | s4 = [ &right_val'35 <- _722.f1 ] s5
      | s5 = [ &_729 <- left_val'35 = right_val'35 ] s6
      | s6 = any [ br0 -> {_729 = false} (! bb74) | br1 -> {_729} (! bb73) ] ]
    | bb73 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int8BW.bw_not (113: Int8BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_938 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (142: Int8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () ] [ _const_ret (_const: Int8BW.t) -> [ &_937 <- _const ] s2 ]
      | s2 = [ &_742 <- { f0'0 = _938; f1'0 = _937 } ] s3
      | s3 = [ &left_val'36 <- _742.f0'0 ] s4
      | s4 = [ &right_val'36 <- _742.f1'0 ] s5
      | s5 = [ &_749 <- left_val'36 = right_val'36 ] s6
      | s6 = any [ br0 -> {_749 = false} (! bb76) | br1 -> {_749} (! bb75) ] ]
    | bb75 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt16BW.bw_not (42225: UInt16BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt16BW.t) -> [ &_936 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (23310: UInt16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () ] [ _const_ret (_const: UInt16BW.t) -> [ &_935 <- _const ] s2 ]
      | s2 = [ &_762 <- { f0'1 = _936; f1'1 = _935 } ] s3
      | s3 = [ &left_val'37 <- _762.f0'1 ] s4
      | s4 = [ &right_val'37 <- _762.f1'1 ] s5
      | s5 = [ &_769 <- left_val'37 = right_val'37 ] s6
      | s6 = any [ br0 -> {_769 = false} (! bb78) | br1 -> {_769} (! bb77) ] ]
    | bb77 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int16BW.bw_not (13553: Int16BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ]
        [ _const_ret (_const: Int16BW.t) -> [ &_934 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (51982: Int16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16BW.t = Any.any_l () ] [ _const_ret (_const: Int16BW.t) -> [ &_933 <- _const ] s2 ]
      | s2 = [ &_782 <- { f0'2 = _934; f1'2 = _933 } ] s3
      | s3 = [ &left_val'38 <- _782.f0'2 ] s4
      | s4 = [ &right_val'38 <- _782.f1'2 ] s5
      | s5 = [ &_789 <- left_val'38 = right_val'38 ] s6
      | s6 = any [ br0 -> {_789 = false} (! bb80) | br1 -> {_789} (! bb79) ] ]
    | bb79 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt32BW.bw_not (3221225475: UInt32BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt32BW.t) -> [ &_932 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1073741820: UInt32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () ] [ _const_ret (_const: UInt32BW.t) -> [ &_931 <- _const ] s2 ]
      | s2 = [ &_802 <- { f0'3 = _932; f1'3 = _931 } ] s3
      | s3 = [ &left_val'39 <- _802.f0'3 ] s4
      | s4 = [ &right_val'39 <- _802.f1'3 ] s5
      | s5 = [ &_809 <- left_val'39 = right_val'39 ] s6
      | s6 = any [ br0 -> {_809 = false} (! bb82) | br1 -> {_809} (! bb81) ] ]
    | bb81 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int32BW.bw_not (1073741839: Int32BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ]
        [ _const_ret (_const: Int32BW.t) -> [ &_930 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (3221225456: Int32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32BW.t = Any.any_l () ] [ _const_ret (_const: Int32BW.t) -> [ &_929 <- _const ] s2 ]
      | s2 = [ &_822 <- { f0'4 = _930; f1'4 = _929 } ] s3
      | s3 = [ &left_val'40 <- _822.f0'4 ] s4
      | s4 = [ &right_val'40 <- _822.f1'4 ] s5
      | s5 = [ &_829 <- left_val'40 = right_val'40 ] s6
      | s6 = any [ br0 -> {_829 = false} (! bb84) | br1 -> {_829} (! bb83) ] ]
    | bb83 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt64BW.bw_not (13835321938072829955: UInt64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_928 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (4611422135636721660: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_927 <- _const ] s2 ]
      | s2 = [ &_842 <- { f0'5 = _928; f1'5 = _927 } ] s3
      | s3 = [ &left_val'41 <- _842.f0'5 ] s4
      | s4 = [ &right_val'41 <- _842.f1'5 ] s5
      | s5 = [ &_849 <- left_val'41 = right_val'41 ] s6
      | s6 = any [ br0 -> {_849 = false} (! bb86) | br1 -> {_849} (! bb85) ] ]
    | bb85 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int64BW.bw_not (4611686018437454224: Int64BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_926 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (13835058055272097391: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_925 <- _const ] s2 ]
      | s2 = [ &_862 <- { f0'6 = _926; f1'6 = _925 } ] s3
      | s3 = [ &left_val'42 <- _862.f0'6 ] s4
      | s4 = [ &right_val'42 <- _862.f1'6 ] s5
      | s5 = [ &_869 <- left_val'42 = right_val'42 ] s6
      | s6 = any [ br0 -> {_869 = false} (! bb88) | br1 -> {_869} (! bb87) ] ]
    | bb87 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- UInt128BW.bw_not (4514840875923203424259: UInt128BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_924 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_0'0 <- (340282366920938458948533731508564787196: UInt128BW.t) ] s1'0
          | s1'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_923 <- _const ] s2 ]
      | s2 = [ &_882 <- { f0'7 = _924; f1'7 = _923 } ] s3
      | s3 = [ &left_val'43 <- _882.f0'7 ] s4
      | s4 = [ &right_val'43 <- _882.f1'7 ] s5
      | s5 = [ &_889 <- left_val'43 = right_val'43 ] s6
      | s6 = any [ br0 -> {_889 = false} (! bb90) | br1 -> {_889} (! bb89) ] ]
    | bb89 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Int128BW.bw_not (4514840875923203424259: Int128BW.t) ] s1'0
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ]
        [ _const_ret (_const: Int128BW.t) -> [ &_922 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_0'0 <- (340282366920938458948533731508564787196: Int128BW.t) ] s1'0
          | s1'0 = _const_ret {_0'0} ] ] [ & _0'0: Int128BW.t = Any.any_l () ]
        [ _const_ret (_const: Int128BW.t) -> [ &_921 <- _const ] s2 ]
      | s2 = [ &_902 <- { f0'8 = _922; f1'8 = _921 } ] s3
      | s3 = [ &left_val'44 <- _902.f0'8 ] s4
      | s4 = [ &right_val'44 <- _902.f1'8 ] s5
      | s5 = [ &_909 <- left_val'44 = right_val'44 ] s6
      | s6 = any [ br0 -> {_909 = false} (! bb92) | br1 -> {_909} (! bb91) ] ]
    | bb91 = return {_0}
    | bb92 = s0
      [ s0 = [ &kind'44 <- Eq ] s1
      | s1 = [ &_917 <- left_val'44 ] s2
      | s2 = [ &_919 <- right_val'44 ] s3
      | s3 = {false} any ]
    | bb90 = s0
      [ s0 = [ &kind'43 <- Eq ] s1
      | s1 = [ &_897 <- left_val'43 ] s2
      | s2 = [ &_899 <- right_val'43 ] s3
      | s3 = {false} any ]
    | bb88 = s0
      [ s0 = [ &kind'42 <- Eq ] s1
      | s1 = [ &_877 <- left_val'42 ] s2
      | s2 = [ &_879 <- right_val'42 ] s3
      | s3 = {false} any ]
    | bb86 = s0
      [ s0 = [ &kind'41 <- Eq ] s1
      | s1 = [ &_857 <- left_val'41 ] s2
      | s2 = [ &_859 <- right_val'41 ] s3
      | s3 = {false} any ]
    | bb84 = s0
      [ s0 = [ &kind'40 <- Eq ] s1
      | s1 = [ &_837 <- left_val'40 ] s2
      | s2 = [ &_839 <- right_val'40 ] s3
      | s3 = {false} any ]
    | bb82 = s0
      [ s0 = [ &kind'39 <- Eq ] s1
      | s1 = [ &_817 <- left_val'39 ] s2
      | s2 = [ &_819 <- right_val'39 ] s3
      | s3 = {false} any ]
    | bb80 = s0
      [ s0 = [ &kind'38 <- Eq ] s1
      | s1 = [ &_797 <- left_val'38 ] s2
      | s2 = [ &_799 <- right_val'38 ] s3
      | s3 = {false} any ]
    | bb78 = s0
      [ s0 = [ &kind'37 <- Eq ] s1
      | s1 = [ &_777 <- left_val'37 ] s2
      | s2 = [ &_779 <- right_val'37 ] s3
      | s3 = {false} any ]
    | bb76 = s0
      [ s0 = [ &kind'36 <- Eq ] s1
      | s1 = [ &_757 <- left_val'36 ] s2
      | s2 = [ &_759 <- right_val'36 ] s3
      | s3 = {false} any ]
    | bb74 = s0
      [ s0 = [ &kind'35 <- Eq ] s1
      | s1 = [ &_737 <- left_val'35 ] s2
      | s2 = [ &_739 <- right_val'35 ] s3
      | s3 = {false} any ]
    | bb72 = s0
      [ s0 = [ &kind'34 <- Eq ] s1
      | s1 = [ &_717 <- left_val'34 ] s2
      | s2 = [ &_719 <- right_val'34 ] s3
      | s3 = {false} any ]
    | bb70 = s0
      [ s0 = [ &kind'33 <- Eq ] s1
      | s1 = [ &_697 <- left_val'33 ] s2
      | s2 = [ &_699 <- right_val'33 ] s3
      | s3 = {false} any ]
    | bb68 = s0
      [ s0 = [ &kind'32 <- Eq ] s1
      | s1 = [ &_677 <- left_val'32 ] s2
      | s2 = [ &_679 <- right_val'32 ] s3
      | s3 = {false} any ]
    | bb66 = s0
      [ s0 = [ &kind'31 <- Eq ] s1
      | s1 = [ &_657 <- left_val'31 ] s2
      | s2 = [ &_659 <- right_val'31 ] s3
      | s3 = {false} any ]
    | bb64 = s0
      [ s0 = [ &kind'30 <- Eq ] s1
      | s1 = [ &_637 <- left_val'30 ] s2
      | s2 = [ &_639 <- right_val'30 ] s3
      | s3 = {false} any ]
    | bb62 = s0
      [ s0 = [ &kind'29 <- Eq ] s1
      | s1 = [ &_617 <- left_val'29 ] s2
      | s2 = [ &_619 <- right_val'29 ] s3
      | s3 = {false} any ]
    | bb60 = s0
      [ s0 = [ &kind'28 <- Eq ] s1
      | s1 = [ &_597 <- left_val'28 ] s2
      | s2 = [ &_599 <- right_val'28 ] s3
      | s3 = {false} any ]
    | bb58 = s0
      [ s0 = [ &kind'27 <- Eq ] s1
      | s1 = [ &_577 <- left_val'27 ] s2
      | s2 = [ &_579 <- right_val'27 ] s3
      | s3 = {false} any ]
    | bb56 = s0
      [ s0 = [ &kind'26 <- Eq ] s1
      | s1 = [ &_557 <- left_val'26 ] s2
      | s2 = [ &_559 <- right_val'26 ] s3
      | s3 = {false} any ]
    | bb54 = s0
      [ s0 = [ &kind'25 <- Eq ] s1
      | s1 = [ &_537 <- left_val'25 ] s2
      | s2 = [ &_539 <- right_val'25 ] s3
      | s3 = {false} any ]
    | bb52 = s0
      [ s0 = [ &kind'24 <- Eq ] s1
      | s1 = [ &_517 <- left_val'24 ] s2
      | s2 = [ &_519 <- right_val'24 ] s3
      | s3 = {false} any ]
    | bb50 = s0
      [ s0 = [ &kind'23 <- Eq ] s1
      | s1 = [ &_497 <- left_val'23 ] s2
      | s2 = [ &_499 <- right_val'23 ] s3
      | s3 = {false} any ]
    | bb48 = s0
      [ s0 = [ &kind'22 <- Eq ] s1
      | s1 = [ &_477 <- left_val'22 ] s2
      | s2 = [ &_479 <- right_val'22 ] s3
      | s3 = {false} any ]
    | bb46 = s0
      [ s0 = [ &kind'21 <- Eq ] s1
      | s1 = [ &_457 <- left_val'21 ] s2
      | s2 = [ &_459 <- right_val'21 ] s3
      | s3 = {false} any ]
    | bb44 = s0
      [ s0 = [ &kind'20 <- Eq ] s1
      | s1 = [ &_437 <- left_val'20 ] s2
      | s2 = [ &_439 <- right_val'20 ] s3
      | s3 = {false} any ]
    | bb42 = s0
      [ s0 = [ &kind'19 <- Eq ] s1
      | s1 = [ &_417 <- left_val'19 ] s2
      | s2 = [ &_419 <- right_val'19 ] s3
      | s3 = {false} any ]
    | bb40 = s0
      [ s0 = [ &kind'18 <- Eq ] s1
      | s1 = [ &_397 <- left_val'18 ] s2
      | s2 = [ &_399 <- right_val'18 ] s3
      | s3 = {false} any ]
    | bb38 = s0
      [ s0 = [ &kind'17 <- Eq ] s1
      | s1 = [ &_377 <- left_val'17 ] s2
      | s2 = [ &_379 <- right_val'17 ] s3
      | s3 = {false} any ]
    | bb36 = s0
      [ s0 = [ &kind'16 <- Eq ] s1
      | s1 = [ &_357 <- left_val'16 ] s2
      | s2 = [ &_359 <- right_val'16 ] s3
      | s3 = {false} any ]
    | bb34 = s0
      [ s0 = [ &kind'15 <- Eq ] s1
      | s1 = [ &_337 <- left_val'15 ] s2
      | s2 = [ &_339 <- right_val'15 ] s3
      | s3 = {false} any ]
    | bb32 = s0
      [ s0 = [ &kind'14 <- Eq ] s1
      | s1 = [ &_317 <- left_val'14 ] s2
      | s2 = [ &_319 <- right_val'14 ] s3
      | s3 = {false} any ]
    | bb30 = s0
      [ s0 = [ &kind'13 <- Eq ] s1
      | s1 = [ &_297 <- left_val'13 ] s2
      | s2 = [ &_299 <- right_val'13 ] s3
      | s3 = {false} any ]
    | bb28 = s0
      [ s0 = [ &kind'12 <- Eq ] s1
      | s1 = [ &_277 <- left_val'12 ] s2
      | s2 = [ &_279 <- right_val'12 ] s3
      | s3 = {false} any ]
    | bb26 = s0
      [ s0 = [ &kind'11 <- Eq ] s1
      | s1 = [ &_257 <- left_val'11 ] s2
      | s2 = [ &_259 <- right_val'11 ] s3
      | s3 = {false} any ]
    | bb24 = s0
      [ s0 = [ &kind'10 <- Eq ] s1
      | s1 = [ &_237 <- left_val'10 ] s2
      | s2 = [ &_239 <- right_val'10 ] s3
      | s3 = {false} any ]
    | bb22 = s0
      [ s0 = [ &kind'9 <- Eq ] s1
      | s1 = [ &_217 <- left_val'9 ] s2
      | s2 = [ &_219 <- right_val'9 ] s3
      | s3 = {false} any ]
    | bb20 = s0
      [ s0 = [ &kind'8 <- Eq ] s1
      | s1 = [ &_197 <- left_val'8 ] s2
      | s2 = [ &_199 <- right_val'8 ] s3
      | s3 = {false} any ]
    | bb18 = s0
      [ s0 = [ &kind'7 <- Eq ] s1
      | s1 = [ &_177 <- left_val'7 ] s2
      | s2 = [ &_179 <- right_val'7 ] s3
      | s3 = {false} any ]
    | bb16 = s0
      [ s0 = [ &kind'6 <- Eq ] s1
      | s1 = [ &_157 <- left_val'6 ] s2
      | s2 = [ &_159 <- right_val'6 ] s3
      | s3 = {false} any ]
    | bb14 = s0
      [ s0 = [ &kind'5 <- Eq ] s1
      | s1 = [ &_137 <- left_val'5 ] s2
      | s2 = [ &_139 <- right_val'5 ] s3
      | s3 = {false} any ]
    | bb12 = s0
      [ s0 = [ &kind'4 <- Eq ] s1
      | s1 = [ &_117 <- left_val'4 ] s2
      | s2 = [ &_119 <- right_val'4 ] s3
      | s3 = {false} any ]
    | bb10 = s0
      [ s0 = [ &kind'3 <- Eq ] s1
      | s1 = [ &_97 <- left_val'3 ] s2
      | s2 = [ &_99 <- right_val'3 ] s3
      | s3 = {false} any ]
    | bb8 = s0
      [ s0 = [ &kind'2 <- Eq ] s1
      | s1 = [ &_77 <- left_val'2 ] s2
      | s2 = [ &_79 <- right_val'2 ] s3
      | s3 = {false} any ]
    | bb6 = s0
      [ s0 = [ &kind'1 <- Eq ] s1
      | s1 = [ &_57 <- left_val'1 ] s2
      | s2 = [ &_59 <- right_val'1 ] s3
      | s3 = {false} any ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_37 <- left_val'0 ] s2
      | s2 = [ &_39 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_17 <- left_val ] s2 | s2 = [ &_19 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & _2: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val: UInt8BW.t = Any.any_l ()
    | & right_val: UInt8BW.t = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _17: UInt8BW.t = Any.any_l ()
    | & _19: UInt8BW.t = Any.any_l ()
    | & _22: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val'0: Int8BW.t = Any.any_l ()
    | & right_val'0: Int8BW.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _37: Int8BW.t = Any.any_l ()
    | & _39: Int8BW.t = Any.any_l ()
    | & _42: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val'1: UInt16BW.t = Any.any_l ()
    | & right_val'1: UInt16BW.t = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _57: UInt16BW.t = Any.any_l ()
    | & _59: UInt16BW.t = Any.any_l ()
    | & _62: tup2_ref_i16_ref_i16 = Any.any_l ()
    | & left_val'2: Int16BW.t = Any.any_l ()
    | & right_val'2: Int16BW.t = Any.any_l ()
    | & _69: bool = Any.any_l ()
    | & kind'2: t_AssertKind = Any.any_l ()
    | & _77: Int16BW.t = Any.any_l ()
    | & _79: Int16BW.t = Any.any_l ()
    | & _82: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val'3: UInt32BW.t = Any.any_l ()
    | & right_val'3: UInt32BW.t = Any.any_l ()
    | & _89: bool = Any.any_l ()
    | & kind'3: t_AssertKind = Any.any_l ()
    | & _97: UInt32BW.t = Any.any_l ()
    | & _99: UInt32BW.t = Any.any_l ()
    | & _102: tup2_ref_i32_ref_i32 = Any.any_l ()
    | & left_val'4: Int32BW.t = Any.any_l ()
    | & right_val'4: Int32BW.t = Any.any_l ()
    | & _109: bool = Any.any_l ()
    | & kind'4: t_AssertKind = Any.any_l ()
    | & _117: Int32BW.t = Any.any_l ()
    | & _119: Int32BW.t = Any.any_l ()
    | & _122: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val'5: UInt64BW.t = Any.any_l ()
    | & right_val'5: UInt64BW.t = Any.any_l ()
    | & _129: bool = Any.any_l ()
    | & kind'5: t_AssertKind = Any.any_l ()
    | & _137: UInt64BW.t = Any.any_l ()
    | & _139: UInt64BW.t = Any.any_l ()
    | & _142: tup2_ref_i64_ref_i64 = Any.any_l ()
    | & left_val'6: Int64BW.t = Any.any_l ()
    | & right_val'6: Int64BW.t = Any.any_l ()
    | & _149: bool = Any.any_l ()
    | & kind'6: t_AssertKind = Any.any_l ()
    | & _157: Int64BW.t = Any.any_l ()
    | & _159: Int64BW.t = Any.any_l ()
    | & _162: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val'7: UInt128BW.t = Any.any_l ()
    | & right_val'7: UInt128BW.t = Any.any_l ()
    | & _169: bool = Any.any_l ()
    | & kind'7: t_AssertKind = Any.any_l ()
    | & _177: UInt128BW.t = Any.any_l ()
    | & _179: UInt128BW.t = Any.any_l ()
    | & _182: tup2_ref_i128_ref_i128 = Any.any_l ()
    | & left_val'8: Int128BW.t = Any.any_l ()
    | & right_val'8: Int128BW.t = Any.any_l ()
    | & _189: bool = Any.any_l ()
    | & kind'8: t_AssertKind = Any.any_l ()
    | & _197: Int128BW.t = Any.any_l ()
    | & _199: Int128BW.t = Any.any_l ()
    | & _202: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val'9: UInt64BW.t = Any.any_l ()
    | & right_val'9: UInt64BW.t = Any.any_l ()
    | & _209: bool = Any.any_l ()
    | & kind'9: t_AssertKind = Any.any_l ()
    | & _217: UInt64BW.t = Any.any_l ()
    | & _219: UInt64BW.t = Any.any_l ()
    | & _222: tup2_ref_isize_ref_isize = Any.any_l ()
    | & left_val'10: Int64BW.t = Any.any_l ()
    | & right_val'10: Int64BW.t = Any.any_l ()
    | & _229: bool = Any.any_l ()
    | & kind'10: t_AssertKind = Any.any_l ()
    | & _237: Int64BW.t = Any.any_l ()
    | & _239: Int64BW.t = Any.any_l ()
    | & _242: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val'11: UInt8BW.t = Any.any_l ()
    | & right_val'11: UInt8BW.t = Any.any_l ()
    | & _249: bool = Any.any_l ()
    | & kind'11: t_AssertKind = Any.any_l ()
    | & _257: UInt8BW.t = Any.any_l ()
    | & _259: UInt8BW.t = Any.any_l ()
    | & _262: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val'12: Int8BW.t = Any.any_l ()
    | & right_val'12: Int8BW.t = Any.any_l ()
    | & _269: bool = Any.any_l ()
    | & kind'12: t_AssertKind = Any.any_l ()
    | & _277: Int8BW.t = Any.any_l ()
    | & _279: Int8BW.t = Any.any_l ()
    | & _282: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val'13: UInt16BW.t = Any.any_l ()
    | & right_val'13: UInt16BW.t = Any.any_l ()
    | & _289: bool = Any.any_l ()
    | & kind'13: t_AssertKind = Any.any_l ()
    | & _297: UInt16BW.t = Any.any_l ()
    | & _299: UInt16BW.t = Any.any_l ()
    | & _302: tup2_ref_i16_ref_i16 = Any.any_l ()
    | & left_val'14: Int16BW.t = Any.any_l ()
    | & right_val'14: Int16BW.t = Any.any_l ()
    | & _309: bool = Any.any_l ()
    | & kind'14: t_AssertKind = Any.any_l ()
    | & _317: Int16BW.t = Any.any_l ()
    | & _319: Int16BW.t = Any.any_l ()
    | & _322: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val'15: UInt32BW.t = Any.any_l ()
    | & right_val'15: UInt32BW.t = Any.any_l ()
    | & _329: bool = Any.any_l ()
    | & kind'15: t_AssertKind = Any.any_l ()
    | & _337: UInt32BW.t = Any.any_l ()
    | & _339: UInt32BW.t = Any.any_l ()
    | & _342: tup2_ref_i32_ref_i32 = Any.any_l ()
    | & left_val'16: Int32BW.t = Any.any_l ()
    | & right_val'16: Int32BW.t = Any.any_l ()
    | & _349: bool = Any.any_l ()
    | & kind'16: t_AssertKind = Any.any_l ()
    | & _357: Int32BW.t = Any.any_l ()
    | & _359: Int32BW.t = Any.any_l ()
    | & _362: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val'17: UInt64BW.t = Any.any_l ()
    | & right_val'17: UInt64BW.t = Any.any_l ()
    | & _369: bool = Any.any_l ()
    | & kind'17: t_AssertKind = Any.any_l ()
    | & _377: UInt64BW.t = Any.any_l ()
    | & _379: UInt64BW.t = Any.any_l ()
    | & _382: tup2_ref_i64_ref_i64 = Any.any_l ()
    | & left_val'18: Int64BW.t = Any.any_l ()
    | & right_val'18: Int64BW.t = Any.any_l ()
    | & _389: bool = Any.any_l ()
    | & kind'18: t_AssertKind = Any.any_l ()
    | & _397: Int64BW.t = Any.any_l ()
    | & _399: Int64BW.t = Any.any_l ()
    | & _402: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val'19: UInt128BW.t = Any.any_l ()
    | & right_val'19: UInt128BW.t = Any.any_l ()
    | & _409: bool = Any.any_l ()
    | & kind'19: t_AssertKind = Any.any_l ()
    | & _417: UInt128BW.t = Any.any_l ()
    | & _419: UInt128BW.t = Any.any_l ()
    | & _422: tup2_ref_i128_ref_i128 = Any.any_l ()
    | & left_val'20: Int128BW.t = Any.any_l ()
    | & right_val'20: Int128BW.t = Any.any_l ()
    | & _429: bool = Any.any_l ()
    | & kind'20: t_AssertKind = Any.any_l ()
    | & _437: Int128BW.t = Any.any_l ()
    | & _439: Int128BW.t = Any.any_l ()
    | & _442: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val'21: UInt64BW.t = Any.any_l ()
    | & right_val'21: UInt64BW.t = Any.any_l ()
    | & _449: bool = Any.any_l ()
    | & kind'21: t_AssertKind = Any.any_l ()
    | & _457: UInt64BW.t = Any.any_l ()
    | & _459: UInt64BW.t = Any.any_l ()
    | & _462: tup2_ref_isize_ref_isize = Any.any_l ()
    | & left_val'22: Int64BW.t = Any.any_l ()
    | & right_val'22: Int64BW.t = Any.any_l ()
    | & _469: bool = Any.any_l ()
    | & kind'22: t_AssertKind = Any.any_l ()
    | & _477: Int64BW.t = Any.any_l ()
    | & _479: Int64BW.t = Any.any_l ()
    | & _482: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val'23: UInt8BW.t = Any.any_l ()
    | & right_val'23: UInt8BW.t = Any.any_l ()
    | & _489: bool = Any.any_l ()
    | & kind'23: t_AssertKind = Any.any_l ()
    | & _497: UInt8BW.t = Any.any_l ()
    | & _499: UInt8BW.t = Any.any_l ()
    | & _502: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val'24: Int8BW.t = Any.any_l ()
    | & right_val'24: Int8BW.t = Any.any_l ()
    | & _509: bool = Any.any_l ()
    | & kind'24: t_AssertKind = Any.any_l ()
    | & _517: Int8BW.t = Any.any_l ()
    | & _519: Int8BW.t = Any.any_l ()
    | & _522: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val'25: UInt16BW.t = Any.any_l ()
    | & right_val'25: UInt16BW.t = Any.any_l ()
    | & _529: bool = Any.any_l ()
    | & kind'25: t_AssertKind = Any.any_l ()
    | & _537: UInt16BW.t = Any.any_l ()
    | & _539: UInt16BW.t = Any.any_l ()
    | & _542: tup2_ref_i16_ref_i16 = Any.any_l ()
    | & left_val'26: Int16BW.t = Any.any_l ()
    | & right_val'26: Int16BW.t = Any.any_l ()
    | & _549: bool = Any.any_l ()
    | & kind'26: t_AssertKind = Any.any_l ()
    | & _557: Int16BW.t = Any.any_l ()
    | & _559: Int16BW.t = Any.any_l ()
    | & _562: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val'27: UInt32BW.t = Any.any_l ()
    | & right_val'27: UInt32BW.t = Any.any_l ()
    | & _569: bool = Any.any_l ()
    | & kind'27: t_AssertKind = Any.any_l ()
    | & _577: UInt32BW.t = Any.any_l ()
    | & _579: UInt32BW.t = Any.any_l ()
    | & _582: tup2_ref_i32_ref_i32 = Any.any_l ()
    | & left_val'28: Int32BW.t = Any.any_l ()
    | & right_val'28: Int32BW.t = Any.any_l ()
    | & _589: bool = Any.any_l ()
    | & kind'28: t_AssertKind = Any.any_l ()
    | & _597: Int32BW.t = Any.any_l ()
    | & _599: Int32BW.t = Any.any_l ()
    | & _602: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val'29: UInt64BW.t = Any.any_l ()
    | & right_val'29: UInt64BW.t = Any.any_l ()
    | & _609: bool = Any.any_l ()
    | & kind'29: t_AssertKind = Any.any_l ()
    | & _617: UInt64BW.t = Any.any_l ()
    | & _619: UInt64BW.t = Any.any_l ()
    | & _622: tup2_ref_i64_ref_i64 = Any.any_l ()
    | & left_val'30: Int64BW.t = Any.any_l ()
    | & right_val'30: Int64BW.t = Any.any_l ()
    | & _629: bool = Any.any_l ()
    | & kind'30: t_AssertKind = Any.any_l ()
    | & _637: Int64BW.t = Any.any_l ()
    | & _639: Int64BW.t = Any.any_l ()
    | & _642: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val'31: UInt128BW.t = Any.any_l ()
    | & right_val'31: UInt128BW.t = Any.any_l ()
    | & _649: bool = Any.any_l ()
    | & kind'31: t_AssertKind = Any.any_l ()
    | & _657: UInt128BW.t = Any.any_l ()
    | & _659: UInt128BW.t = Any.any_l ()
    | & _662: tup2_ref_i128_ref_i128 = Any.any_l ()
    | & left_val'32: Int128BW.t = Any.any_l ()
    | & right_val'32: Int128BW.t = Any.any_l ()
    | & _669: bool = Any.any_l ()
    | & kind'32: t_AssertKind = Any.any_l ()
    | & _677: Int128BW.t = Any.any_l ()
    | & _679: Int128BW.t = Any.any_l ()
    | & _682: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val'33: UInt64BW.t = Any.any_l ()
    | & right_val'33: UInt64BW.t = Any.any_l ()
    | & _689: bool = Any.any_l ()
    | & kind'33: t_AssertKind = Any.any_l ()
    | & _697: UInt64BW.t = Any.any_l ()
    | & _699: UInt64BW.t = Any.any_l ()
    | & _702: tup2_ref_isize_ref_isize = Any.any_l ()
    | & left_val'34: Int64BW.t = Any.any_l ()
    | & right_val'34: Int64BW.t = Any.any_l ()
    | & _709: bool = Any.any_l ()
    | & kind'34: t_AssertKind = Any.any_l ()
    | & _717: Int64BW.t = Any.any_l ()
    | & _719: Int64BW.t = Any.any_l ()
    | & _722: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val'35: UInt8BW.t = Any.any_l ()
    | & right_val'35: UInt8BW.t = Any.any_l ()
    | & _729: bool = Any.any_l ()
    | & kind'35: t_AssertKind = Any.any_l ()
    | & _737: UInt8BW.t = Any.any_l ()
    | & _739: UInt8BW.t = Any.any_l ()
    | & _742: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val'36: Int8BW.t = Any.any_l ()
    | & right_val'36: Int8BW.t = Any.any_l ()
    | & _749: bool = Any.any_l ()
    | & kind'36: t_AssertKind = Any.any_l ()
    | & _757: Int8BW.t = Any.any_l ()
    | & _759: Int8BW.t = Any.any_l ()
    | & _762: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val'37: UInt16BW.t = Any.any_l ()
    | & right_val'37: UInt16BW.t = Any.any_l ()
    | & _769: bool = Any.any_l ()
    | & kind'37: t_AssertKind = Any.any_l ()
    | & _777: UInt16BW.t = Any.any_l ()
    | & _779: UInt16BW.t = Any.any_l ()
    | & _782: tup2_ref_i16_ref_i16 = Any.any_l ()
    | & left_val'38: Int16BW.t = Any.any_l ()
    | & right_val'38: Int16BW.t = Any.any_l ()
    | & _789: bool = Any.any_l ()
    | & kind'38: t_AssertKind = Any.any_l ()
    | & _797: Int16BW.t = Any.any_l ()
    | & _799: Int16BW.t = Any.any_l ()
    | & _802: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val'39: UInt32BW.t = Any.any_l ()
    | & right_val'39: UInt32BW.t = Any.any_l ()
    | & _809: bool = Any.any_l ()
    | & kind'39: t_AssertKind = Any.any_l ()
    | & _817: UInt32BW.t = Any.any_l ()
    | & _819: UInt32BW.t = Any.any_l ()
    | & _822: tup2_ref_i32_ref_i32 = Any.any_l ()
    | & left_val'40: Int32BW.t = Any.any_l ()
    | & right_val'40: Int32BW.t = Any.any_l ()
    | & _829: bool = Any.any_l ()
    | & kind'40: t_AssertKind = Any.any_l ()
    | & _837: Int32BW.t = Any.any_l ()
    | & _839: Int32BW.t = Any.any_l ()
    | & _842: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val'41: UInt64BW.t = Any.any_l ()
    | & right_val'41: UInt64BW.t = Any.any_l ()
    | & _849: bool = Any.any_l ()
    | & kind'41: t_AssertKind = Any.any_l ()
    | & _857: UInt64BW.t = Any.any_l ()
    | & _859: UInt64BW.t = Any.any_l ()
    | & _862: tup2_ref_i64_ref_i64 = Any.any_l ()
    | & left_val'42: Int64BW.t = Any.any_l ()
    | & right_val'42: Int64BW.t = Any.any_l ()
    | & _869: bool = Any.any_l ()
    | & kind'42: t_AssertKind = Any.any_l ()
    | & _877: Int64BW.t = Any.any_l ()
    | & _879: Int64BW.t = Any.any_l ()
    | & _882: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val'43: UInt128BW.t = Any.any_l ()
    | & right_val'43: UInt128BW.t = Any.any_l ()
    | & _889: bool = Any.any_l ()
    | & kind'43: t_AssertKind = Any.any_l ()
    | & _897: UInt128BW.t = Any.any_l ()
    | & _899: UInt128BW.t = Any.any_l ()
    | & _902: tup2_ref_i128_ref_i128 = Any.any_l ()
    | & left_val'44: Int128BW.t = Any.any_l ()
    | & right_val'44: Int128BW.t = Any.any_l ()
    | & _909: bool = Any.any_l ()
    | & kind'44: t_AssertKind = Any.any_l ()
    | & _917: Int128BW.t = Any.any_l ()
    | & _919: Int128BW.t = Any.any_l ()
    | & _921: Int128BW.t = Any.any_l ()
    | & _922: Int128BW.t = Any.any_l ()
    | & _923: UInt128BW.t = Any.any_l ()
    | & _924: UInt128BW.t = Any.any_l ()
    | & _925: Int64BW.t = Any.any_l ()
    | & _926: Int64BW.t = Any.any_l ()
    | & _927: UInt64BW.t = Any.any_l ()
    | & _928: UInt64BW.t = Any.any_l ()
    | & _929: Int32BW.t = Any.any_l ()
    | & _930: Int32BW.t = Any.any_l ()
    | & _931: UInt32BW.t = Any.any_l ()
    | & _932: UInt32BW.t = Any.any_l ()
    | & _933: Int16BW.t = Any.any_l ()
    | & _934: Int16BW.t = Any.any_l ()
    | & _935: UInt16BW.t = Any.any_l ()
    | & _936: UInt16BW.t = Any.any_l ()
    | & _937: Int8BW.t = Any.any_l ()
    | & _938: Int8BW.t = Any.any_l ()
    | & _939: UInt8BW.t = Any.any_l ()
    | & _940: UInt8BW.t = Any.any_l ()
    | & _941: Int64BW.t = Any.any_l ()
    | & _942: Int64BW.t = Any.any_l ()
    | & _943: UInt64BW.t = Any.any_l ()
    | & _944: UInt64BW.t = Any.any_l ()
    | & _945: Int128BW.t = Any.any_l ()
    | & _946: Int128BW.t = Any.any_l ()
    | & _947: UInt128BW.t = Any.any_l ()
    | & _948: UInt128BW.t = Any.any_l ()
    | & _949: Int64BW.t = Any.any_l ()
    | & _950: Int64BW.t = Any.any_l ()
    | & _951: UInt64BW.t = Any.any_l ()
    | & _952: UInt64BW.t = Any.any_l ()
    | & _953: Int32BW.t = Any.any_l ()
    | & _954: Int32BW.t = Any.any_l ()
    | & _955: UInt32BW.t = Any.any_l ()
    | & _956: UInt32BW.t = Any.any_l ()
    | & _957: Int16BW.t = Any.any_l ()
    | & _958: Int16BW.t = Any.any_l ()
    | & _959: UInt16BW.t = Any.any_l ()
    | & _960: UInt16BW.t = Any.any_l ()
    | & _961: Int8BW.t = Any.any_l ()
    | & _962: Int8BW.t = Any.any_l ()
    | & _963: UInt8BW.t = Any.any_l ()
    | & _964: UInt8BW.t = Any.any_l ()
    | & _965: Int64BW.t = Any.any_l ()
    | & _966: Int64BW.t = Any.any_l ()
    | & _967: UInt64BW.t = Any.any_l ()
    | & _968: UInt64BW.t = Any.any_l ()
    | & _969: Int128BW.t = Any.any_l ()
    | & _970: Int128BW.t = Any.any_l ()
    | & _971: UInt128BW.t = Any.any_l ()
    | & _972: UInt128BW.t = Any.any_l ()
    | & _973: Int64BW.t = Any.any_l ()
    | & _974: Int64BW.t = Any.any_l ()
    | & _975: UInt64BW.t = Any.any_l ()
    | & _976: UInt64BW.t = Any.any_l ()
    | & _977: Int32BW.t = Any.any_l ()
    | & _978: Int32BW.t = Any.any_l ()
    | & _979: UInt32BW.t = Any.any_l ()
    | & _980: UInt32BW.t = Any.any_l ()
    | & _981: Int16BW.t = Any.any_l ()
    | & _982: Int16BW.t = Any.any_l ()
    | & _983: UInt16BW.t = Any.any_l ()
    | & _984: UInt16BW.t = Any.any_l ()
    | & _985: Int8BW.t = Any.any_l ()
    | & _986: Int8BW.t = Any.any_l ()
    | & _987: UInt8BW.t = Any.any_l ()
    | & _988: UInt8BW.t = Any.any_l ()
    | & _989: Int64BW.t = Any.any_l ()
    | & _990: Int64BW.t = Any.any_l ()
    | & _991: UInt64BW.t = Any.any_l ()
    | & _992: UInt64BW.t = Any.any_l ()
    | & _993: Int128BW.t = Any.any_l ()
    | & _994: Int128BW.t = Any.any_l ()
    | & _995: UInt128BW.t = Any.any_l ()
    | & _996: UInt128BW.t = Any.any_l ()
    | & _997: Int64BW.t = Any.any_l ()
    | & _998: Int64BW.t = Any.any_l ()
    | & _999: UInt64BW.t = Any.any_l ()
    | & _1000: UInt64BW.t = Any.any_l ()
    | & _1001: Int32BW.t = Any.any_l ()
    | & _1002: Int32BW.t = Any.any_l ()
    | & _1003: UInt32BW.t = Any.any_l ()
    | & _1004: UInt32BW.t = Any.any_l ()
    | & _1005: Int16BW.t = Any.any_l ()
    | & _1006: Int16BW.t = Any.any_l ()
    | & _1007: UInt16BW.t = Any.any_l ()
    | & _1008: UInt16BW.t = Any.any_l ()
    | & _1009: Int8BW.t = Any.any_l ()
    | & _1010: Int8BW.t = Any.any_l ()
    | & _1011: UInt8BW.t = Any.any_l ()
    | & _1012: UInt8BW.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_shift_ops
  use creusot.int.Int32BW
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  use creusot.int.Int8BW
  use creusot.int.UInt16BW
  use creusot.int.UInt32BW
  use creusot.int.UInt64BW
  use creusot.int.UInt128BW
  
  type tup2_ref_u8_ref_u8 = { f0: UInt8BW.t; f1: UInt8BW.t }
  
  type tup2_ref_i8_ref_i8 = { f0'0: Int8BW.t; f1'0: Int8BW.t }
  
  type tup2_ref_u16_ref_u16 = { f0'1: UInt16BW.t; f1'1: UInt16BW.t }
  
  type tup2_ref_u32_ref_u32 = { f0'2: UInt32BW.t; f1'2: UInt32BW.t }
  
  type tup2_ref_u64_ref_u64 = { f0'3: UInt64BW.t; f1'3: UInt64BW.t }
  
  type tup2_ref_u128_ref_u128 = { f0'4: UInt128BW.t; f1'4: UInt128BW.t }
  
  type tup2_ref_usize_ref_usize = { f0'5: UInt64BW.t; f1'5: UInt64BW.t }
  
  constant const_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shift_ops (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt8BW.shl {(240: UInt8BW.t)} {Int32BW.to_int (2: Int32BW.t)}
              (fun (_ret: UInt8BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt8BW.t) -> [ &_309 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (192: UInt8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () ] [ _const_ret (_const: UInt8BW.t) -> [ &_308 <- _const ] s2 ]
      | s2 = [ &_2 <- { f0 = _309; f1 = _308 } ] s3
      | s3 = [ &left_val <- _2.f0 ] s4
      | s4 = [ &right_val <- _2.f1 ] s5
      | s5 = [ &_9 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_9 = false} (! bb2) | br1 -> {_9} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = Int8BW.shl {(105: Int8BW.t)} {Int32BW.to_int (3: Int32BW.t)}
              (fun (_ret: Int8BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_307 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (72: Int8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () ] [ _const_ret (_const: Int8BW.t) -> [ &_306 <- _const ] s2 ]
      | s2 = [ &_22 <- { f0'0 = _307; f1'0 = _306 } ] s3
      | s3 = [ &left_val'0 <- _22.f0'0 ] s4
      | s4 = [ &right_val'0 <- _22.f1'0 ] s5
      | s5 = [ &_29 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_29 = false} (! bb4) | br1 -> {_29} (! bb3) ] ]
    | bb3 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt16BW.shl {(65535: UInt16BW.t)} {Int32BW.to_int (3: Int32BW.t)}
              (fun (_ret: UInt16BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt16BW.t) -> [ &_305 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (65528: UInt16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () ] [ _const_ret (_const: UInt16BW.t) -> [ &_304 <- _const ] s2 ]
      | s2 = [ &_42 <- { f0'1 = _305; f1'1 = _304 } ] s3
      | s3 = [ &left_val'1 <- _42.f0'1 ] s4
      | s4 = [ &right_val'1 <- _42.f1'1 ] s5
      | s5 = [ &_49 <- left_val'1 = right_val'1 ] s6
      | s6 = any [ br0 -> {_49 = false} (! bb6) | br1 -> {_49} (! bb5) ] ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt32BW.shl {(3221225475: UInt32BW.t)} {Int32BW.to_int (2: Int32BW.t)}
              (fun (_ret: UInt32BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt32BW.t) -> [ &_303 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (12: UInt32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () ] [ _const_ret (_const: UInt32BW.t) -> [ &_302 <- _const ] s2 ]
      | s2 = [ &_62 <- { f0'2 = _303; f1'2 = _302 } ] s3
      | s3 = [ &left_val'2 <- _62.f0'2 ] s4
      | s4 = [ &right_val'2 <- _62.f1'2 ] s5
      | s5 = [ &_69 <- left_val'2 = right_val'2 ] s6
      | s6 = any [ br0 -> {_69 = false} (! bb8) | br1 -> {_69} (! bb7) ] ]
    | bb7 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt64BW.shl {(13835321938072829955: UInt64BW.t)} {Int32BW.to_int (4: Int32BW.t)}
              (fun (_ret: UInt64BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_301 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (4222124650659888: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_300 <- _const ] s2 ]
      | s2 = [ &_82 <- { f0'3 = _301; f1'3 = _300 } ] s3
      | s3 = [ &left_val'3 <- _82.f0'3 ] s4
      | s4 = [ &right_val'3 <- _82.f1'3 ] s5
      | s5 = [ &_89 <- left_val'3 = right_val'3 ] s6
      | s6 = any [ br0 -> {_89 = false} (! bb10) | br1 -> {_89} (! bb9) ] ]
    | bb9 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt128BW.shl {(4514840875923203424259: UInt128BW.t)} {Int32BW.to_int (3: Int32BW.t)}
              (fun (_ret: UInt128BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_299 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (36118727007385627394072: UInt128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () ] [ _const_ret (_const: UInt128BW.t) -> [ &_298 <- _const ] s2 ]
      | s2 = [ &_102 <- { f0'4 = _299; f1'4 = _298 } ] s3
      | s3 = [ &left_val'4 <- _102.f0'4 ] s4
      | s4 = [ &right_val'4 <- _102.f1'4 ] s5
      | s5 = [ &_109 <- left_val'4 = right_val'4 ] s6
      | s6 = any [ br0 -> {_109 = false} (! bb12) | br1 -> {_109} (! bb11) ] ]
    | bb11 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt64BW.shl {(240: UInt64BW.t)} {Int32BW.to_int (2: Int32BW.t)}
              (fun (_ret: UInt64BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_297 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (960: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_296 <- _const ] s2 ]
      | s2 = [ &_122 <- { f0'5 = _297; f1'5 = _296 } ] s3
      | s3 = [ &left_val'5 <- _122.f0'5 ] s4
      | s4 = [ &right_val'5 <- _122.f1'5 ] s5
      | s5 = [ &_129 <- left_val'5 = right_val'5 ] s6
      | s6 = any [ br0 -> {_129 = false} (! bb14) | br1 -> {_129} (! bb13) ] ]
    | bb13 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt8BW.shr {(240: UInt8BW.t)} {Int32BW.to_int (2: Int32BW.t)}
              (fun (_ret: UInt8BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt8BW.t) -> [ &_295 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (60: UInt8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () ] [ _const_ret (_const: UInt8BW.t) -> [ &_294 <- _const ] s2 ]
      | s2 = [ &_142 <- { f0 = _295; f1 = _294 } ] s3
      | s3 = [ &left_val'6 <- _142.f0 ] s4
      | s4 = [ &right_val'6 <- _142.f1 ] s5
      | s5 = [ &_149 <- left_val'6 = right_val'6 ] s6
      | s6 = any [ br0 -> {_149 = false} (! bb16) | br1 -> {_149} (! bb15) ] ]
    | bb15 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = Int8BW.of_BV256 {UInt8BW.to_BV256 (240: UInt8BW.t)}
              (fun (_ret_from: Int8BW.t) -> [ &_2'0 <- _ret_from ] s1'0)
          | s1'0 = Int8BW.shr {_2'0} {Int32BW.to_int (2: Int32BW.t)} (fun (_ret: Int8BW.t) -> [ &_1 <- _ret ] s2'0)
          | s2'0 = [ &_0'0 <- _1 ] s3'0
          | s3'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () | & _2'0: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_293 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = Int8BW.of_BV256 {UInt8BW.to_BV256 (252: UInt8BW.t)}
              (fun (_ret_from: Int8BW.t) -> [ &_1 <- _ret_from ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_292 <- _const ] s2 ]
      | s2 = [ &_162 <- { f0'0 = _293; f1'0 = _292 } ] s3
      | s3 = [ &left_val'7 <- _162.f0'0 ] s4
      | s4 = [ &right_val'7 <- _162.f1'0 ] s5
      | s5 = [ &_170 <- left_val'7 = right_val'7 ] s6
      | s6 = any [ br0 -> {_170 = false} (! bb18) | br1 -> {_170} (! bb17) ] ]
    | bb17 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt16BW.shr {(65535: UInt16BW.t)} {Int32BW.to_int (6: Int32BW.t)}
              (fun (_ret: UInt16BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt16BW.t) -> [ &_291 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1023: UInt16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () ] [ _const_ret (_const: UInt16BW.t) -> [ &_290 <- _const ] s2 ]
      | s2 = [ &_183 <- { f0'1 = _291; f1'1 = _290 } ] s3
      | s3 = [ &left_val'8 <- _183.f0'1 ] s4
      | s4 = [ &right_val'8 <- _183.f1'1 ] s5
      | s5 = [ &_190 <- left_val'8 = right_val'8 ] s6
      | s6 = any [ br0 -> {_190 = false} (! bb20) | br1 -> {_190} (! bb19) ] ]
    | bb19 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt32BW.shr {(3221225475: UInt32BW.t)} {Int32BW.to_int (14: Int32BW.t)}
              (fun (_ret: UInt32BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt32BW.t) -> [ &_289 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (196608: UInt32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () ] [ _const_ret (_const: UInt32BW.t) -> [ &_288 <- _const ] s2 ]
      | s2 = [ &_203 <- { f0'2 = _289; f1'2 = _288 } ] s3
      | s3 = [ &left_val'9 <- _203.f0'2 ] s4
      | s4 = [ &right_val'9 <- _203.f1'2 ] s5
      | s5 = [ &_210 <- left_val'9 = right_val'9 ] s6
      | s6 = any [ br0 -> {_210 = false} (! bb22) | br1 -> {_210} (! bb21) ] ]
    | bb21 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt64BW.shr {(13835321938072829955: UInt64BW.t)} {Int32BW.to_int (18: Int32BW.t)}
              (fun (_ret: UInt64BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_287 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (52777564766208: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_286 <- _const ] s2 ]
      | s2 = [ &_223 <- { f0'3 = _287; f1'3 = _286 } ] s3
      | s3 = [ &left_val'10 <- _223.f0'3 ] s4
      | s4 = [ &right_val'10 <- _223.f1'3 ] s5
      | s5 = [ &_230 <- left_val'10 = right_val'10 ] s6
      | s6 = any [ br0 -> {_230 = false} (! bb24) | br1 -> {_230} (! bb23) ] ]
    | bb23 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt128BW.shr {const_MAX} {Int32BW.to_int (110: Int32BW.t)}
              (fun (_ret: UInt128BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_285 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (262143: UInt128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () ] [ _const_ret (_const: UInt128BW.t) -> [ &_284 <- _const ] s2 ]
      | s2 = [ &_243 <- { f0'4 = _285; f1'4 = _284 } ] s3
      | s3 = [ &left_val'11 <- _243.f0'4 ] s4
      | s4 = [ &right_val'11 <- _243.f1'4 ] s5
      | s5 = [ &_250 <- left_val'11 = right_val'11 ] s6
      | s6 = any [ br0 -> {_250 = false} (! bb26) | br1 -> {_250} (! bb25) ] ]
    | bb25 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = UInt64BW.shr {(240: UInt64BW.t)} {Int32BW.to_int (2: Int32BW.t)}
              (fun (_ret: UInt64BW.t) -> [ &_1 <- _ret ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_283 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (60: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_282 <- _const ] s2 ]
      | s2 = [ &_263 <- { f0'5 = _283; f1'5 = _282 } ] s3
      | s3 = [ &left_val'12 <- _263.f0'5 ] s4
      | s4 = [ &right_val'12 <- _263.f1'5 ] s5
      | s5 = [ &_270 <- left_val'12 = right_val'12 ] s6
      | s6 = any [ br0 -> {_270 = false} (! bb28) | br1 -> {_270} (! bb27) ] ]
    | bb27 = return {_0}
    | bb28 = s0
      [ s0 = [ &kind'12 <- Eq ] s1
      | s1 = [ &_278 <- left_val'12 ] s2
      | s2 = [ &_280 <- right_val'12 ] s3
      | s3 = {false} any ]
    | bb26 = s0
      [ s0 = [ &kind'11 <- Eq ] s1
      | s1 = [ &_258 <- left_val'11 ] s2
      | s2 = [ &_260 <- right_val'11 ] s3
      | s3 = {false} any ]
    | bb24 = s0
      [ s0 = [ &kind'10 <- Eq ] s1
      | s1 = [ &_238 <- left_val'10 ] s2
      | s2 = [ &_240 <- right_val'10 ] s3
      | s3 = {false} any ]
    | bb22 = s0
      [ s0 = [ &kind'9 <- Eq ] s1
      | s1 = [ &_218 <- left_val'9 ] s2
      | s2 = [ &_220 <- right_val'9 ] s3
      | s3 = {false} any ]
    | bb20 = s0
      [ s0 = [ &kind'8 <- Eq ] s1
      | s1 = [ &_198 <- left_val'8 ] s2
      | s2 = [ &_200 <- right_val'8 ] s3
      | s3 = {false} any ]
    | bb18 = s0
      [ s0 = [ &kind'7 <- Eq ] s1
      | s1 = [ &_178 <- left_val'7 ] s2
      | s2 = [ &_180 <- right_val'7 ] s3
      | s3 = {false} any ]
    | bb16 = s0
      [ s0 = [ &kind'6 <- Eq ] s1
      | s1 = [ &_157 <- left_val'6 ] s2
      | s2 = [ &_159 <- right_val'6 ] s3
      | s3 = {false} any ]
    | bb14 = s0
      [ s0 = [ &kind'5 <- Eq ] s1
      | s1 = [ &_137 <- left_val'5 ] s2
      | s2 = [ &_139 <- right_val'5 ] s3
      | s3 = {false} any ]
    | bb12 = s0
      [ s0 = [ &kind'4 <- Eq ] s1
      | s1 = [ &_117 <- left_val'4 ] s2
      | s2 = [ &_119 <- right_val'4 ] s3
      | s3 = {false} any ]
    | bb10 = s0
      [ s0 = [ &kind'3 <- Eq ] s1
      | s1 = [ &_97 <- left_val'3 ] s2
      | s2 = [ &_99 <- right_val'3 ] s3
      | s3 = {false} any ]
    | bb8 = s0
      [ s0 = [ &kind'2 <- Eq ] s1
      | s1 = [ &_77 <- left_val'2 ] s2
      | s2 = [ &_79 <- right_val'2 ] s3
      | s3 = {false} any ]
    | bb6 = s0
      [ s0 = [ &kind'1 <- Eq ] s1
      | s1 = [ &_57 <- left_val'1 ] s2
      | s2 = [ &_59 <- right_val'1 ] s3
      | s3 = {false} any ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_37 <- left_val'0 ] s2
      | s2 = [ &_39 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_17 <- left_val ] s2 | s2 = [ &_19 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & _2: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val: UInt8BW.t = Any.any_l ()
    | & right_val: UInt8BW.t = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _17: UInt8BW.t = Any.any_l ()
    | & _19: UInt8BW.t = Any.any_l ()
    | & _22: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val'0: Int8BW.t = Any.any_l ()
    | & right_val'0: Int8BW.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _37: Int8BW.t = Any.any_l ()
    | & _39: Int8BW.t = Any.any_l ()
    | & _42: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val'1: UInt16BW.t = Any.any_l ()
    | & right_val'1: UInt16BW.t = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _57: UInt16BW.t = Any.any_l ()
    | & _59: UInt16BW.t = Any.any_l ()
    | & _62: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val'2: UInt32BW.t = Any.any_l ()
    | & right_val'2: UInt32BW.t = Any.any_l ()
    | & _69: bool = Any.any_l ()
    | & kind'2: t_AssertKind = Any.any_l ()
    | & _77: UInt32BW.t = Any.any_l ()
    | & _79: UInt32BW.t = Any.any_l ()
    | & _82: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val'3: UInt64BW.t = Any.any_l ()
    | & right_val'3: UInt64BW.t = Any.any_l ()
    | & _89: bool = Any.any_l ()
    | & kind'3: t_AssertKind = Any.any_l ()
    | & _97: UInt64BW.t = Any.any_l ()
    | & _99: UInt64BW.t = Any.any_l ()
    | & _102: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val'4: UInt128BW.t = Any.any_l ()
    | & right_val'4: UInt128BW.t = Any.any_l ()
    | & _109: bool = Any.any_l ()
    | & kind'4: t_AssertKind = Any.any_l ()
    | & _117: UInt128BW.t = Any.any_l ()
    | & _119: UInt128BW.t = Any.any_l ()
    | & _122: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val'5: UInt64BW.t = Any.any_l ()
    | & right_val'5: UInt64BW.t = Any.any_l ()
    | & _129: bool = Any.any_l ()
    | & kind'5: t_AssertKind = Any.any_l ()
    | & _137: UInt64BW.t = Any.any_l ()
    | & _139: UInt64BW.t = Any.any_l ()
    | & _142: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val'6: UInt8BW.t = Any.any_l ()
    | & right_val'6: UInt8BW.t = Any.any_l ()
    | & _149: bool = Any.any_l ()
    | & kind'6: t_AssertKind = Any.any_l ()
    | & _157: UInt8BW.t = Any.any_l ()
    | & _159: UInt8BW.t = Any.any_l ()
    | & _162: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val'7: Int8BW.t = Any.any_l ()
    | & right_val'7: Int8BW.t = Any.any_l ()
    | & _170: bool = Any.any_l ()
    | & kind'7: t_AssertKind = Any.any_l ()
    | & _178: Int8BW.t = Any.any_l ()
    | & _180: Int8BW.t = Any.any_l ()
    | & _183: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val'8: UInt16BW.t = Any.any_l ()
    | & right_val'8: UInt16BW.t = Any.any_l ()
    | & _190: bool = Any.any_l ()
    | & kind'8: t_AssertKind = Any.any_l ()
    | & _198: UInt16BW.t = Any.any_l ()
    | & _200: UInt16BW.t = Any.any_l ()
    | & _203: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val'9: UInt32BW.t = Any.any_l ()
    | & right_val'9: UInt32BW.t = Any.any_l ()
    | & _210: bool = Any.any_l ()
    | & kind'9: t_AssertKind = Any.any_l ()
    | & _218: UInt32BW.t = Any.any_l ()
    | & _220: UInt32BW.t = Any.any_l ()
    | & _223: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val'10: UInt64BW.t = Any.any_l ()
    | & right_val'10: UInt64BW.t = Any.any_l ()
    | & _230: bool = Any.any_l ()
    | & kind'10: t_AssertKind = Any.any_l ()
    | & _238: UInt64BW.t = Any.any_l ()
    | & _240: UInt64BW.t = Any.any_l ()
    | & _243: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val'11: UInt128BW.t = Any.any_l ()
    | & right_val'11: UInt128BW.t = Any.any_l ()
    | & _250: bool = Any.any_l ()
    | & kind'11: t_AssertKind = Any.any_l ()
    | & _258: UInt128BW.t = Any.any_l ()
    | & _260: UInt128BW.t = Any.any_l ()
    | & _263: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val'12: UInt64BW.t = Any.any_l ()
    | & right_val'12: UInt64BW.t = Any.any_l ()
    | & _270: bool = Any.any_l ()
    | & kind'12: t_AssertKind = Any.any_l ()
    | & _278: UInt64BW.t = Any.any_l ()
    | & _280: UInt64BW.t = Any.any_l ()
    | & _282: UInt64BW.t = Any.any_l ()
    | & _283: UInt64BW.t = Any.any_l ()
    | & _284: UInt128BW.t = Any.any_l ()
    | & _285: UInt128BW.t = Any.any_l ()
    | & _286: UInt64BW.t = Any.any_l ()
    | & _287: UInt64BW.t = Any.any_l ()
    | & _288: UInt32BW.t = Any.any_l ()
    | & _289: UInt32BW.t = Any.any_l ()
    | & _290: UInt16BW.t = Any.any_l ()
    | & _291: UInt16BW.t = Any.any_l ()
    | & _292: Int8BW.t = Any.any_l ()
    | & _293: Int8BW.t = Any.any_l ()
    | & _294: UInt8BW.t = Any.any_l ()
    | & _295: UInt8BW.t = Any.any_l ()
    | & _296: UInt64BW.t = Any.any_l ()
    | & _297: UInt64BW.t = Any.any_l ()
    | & _298: UInt128BW.t = Any.any_l ()
    | & _299: UInt128BW.t = Any.any_l ()
    | & _300: UInt64BW.t = Any.any_l ()
    | & _301: UInt64BW.t = Any.any_l ()
    | & _302: UInt32BW.t = Any.any_l ()
    | & _303: UInt32BW.t = Any.any_l ()
    | & _304: UInt16BW.t = Any.any_l ()
    | & _305: UInt16BW.t = Any.any_l ()
    | & _306: Int8BW.t = Any.any_l ()
    | & _307: Int8BW.t = Any.any_l ()
    | & _308: UInt8BW.t = Any.any_l ()
    | & _309: UInt8BW.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_u8__test_add
  use creusot.int.UInt8
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: UInt8.t) (r: UInt8.t) (return (x: UInt8.t)) = {[@expl:test_add requires] UInt8.t'int l
        + UInt8.t'int r
      >= UInt8.t'int const_MIN
    /\ UInt8.t'int l + UInt8.t'int r <= UInt8.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8.add {l} {r} (fun (_ret: UInt8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt8.t = Any.any_l () | & l: UInt8.t = l | & r: UInt8.t = r ])
    [ return (result: UInt8.t) -> {[@expl:test_add ensures] UInt8.t'int result = UInt8.t'int l + UInt8.t'int r}
      (! return {result}) ]
end
module M_u8__test_add_bw
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt8BW.t = (0: UInt8BW.t)
  
  constant const_MAX: UInt8BW.t = (255: UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: UInt8BW.t) (r: UInt8BW.t) (return (x: UInt8BW.t)) =
    {[@expl:test_add_bw requires] UInt8BW.t'int l + UInt8BW.t'int r >= UInt8BW.t'int const_MIN
    /\ UInt8BW.t'int l + UInt8BW.t'int r <= UInt8BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.add {l} {r} (fun (_ret: UInt8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt8BW.t = Any.any_l () | & l: UInt8BW.t = l | & r: UInt8BW.t = r ])
    [ return (result: UInt8BW.t) -> {[@expl:test_add_bw ensures] UInt8BW.t'int result
      = UInt8BW.t'int l + UInt8BW.t'int r}
      (! return {result}) ]
end
module M_u8__test_sub
  use creusot.int.UInt8
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: UInt8.t) (r: UInt8.t) (return (x: UInt8.t)) = {[@expl:test_sub requires] UInt8.t'int l
        - UInt8.t'int r
      >= UInt8.t'int const_MIN
    /\ UInt8.t'int l - UInt8.t'int r <= UInt8.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8.sub {l} {r} (fun (_ret: UInt8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt8.t = Any.any_l () | & l: UInt8.t = l | & r: UInt8.t = r ])
    [ return (result: UInt8.t) -> {[@expl:test_sub ensures] UInt8.t'int result = UInt8.t'int l - UInt8.t'int r}
      (! return {result}) ]
end
module M_u8__test_sub_bw
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt8BW.t = (0: UInt8BW.t)
  
  constant const_MAX: UInt8BW.t = (255: UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: UInt8BW.t) (r: UInt8BW.t) (return (x: UInt8BW.t)) =
    {[@expl:test_sub_bw requires] UInt8BW.t'int l - UInt8BW.t'int r >= UInt8BW.t'int const_MIN
    /\ UInt8BW.t'int l - UInt8BW.t'int r <= UInt8BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.sub {l} {r} (fun (_ret: UInt8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt8BW.t = Any.any_l () | & l: UInt8BW.t = l | & r: UInt8BW.t = r ])
    [ return (result: UInt8BW.t) -> {[@expl:test_sub_bw ensures] UInt8BW.t'int result
      = UInt8BW.t'int l - UInt8BW.t'int r}
      (! return {result}) ]
end
module M_u8__test_mul
  use creusot.int.UInt8
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: UInt8.t) (r: UInt8.t) (return (x: UInt8.t)) = {[@expl:test_mul requires] UInt8.t'int l
        * UInt8.t'int r
      >= UInt8.t'int const_MIN
    /\ UInt8.t'int l * UInt8.t'int r <= UInt8.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8.mul {l} {r} (fun (_ret: UInt8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt8.t = Any.any_l () | & l: UInt8.t = l | & r: UInt8.t = r ])
    [ return (result: UInt8.t) -> {[@expl:test_mul ensures] UInt8.t'int result = UInt8.t'int l * UInt8.t'int r}
      (! return {result}) ]
end
module M_u8__test_mul_bw
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt8BW.t = (0: UInt8BW.t)
  
  constant const_MAX: UInt8BW.t = (255: UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: UInt8BW.t) (r: UInt8BW.t) (return (x: UInt8BW.t)) =
    {[@expl:test_mul_bw requires] UInt8BW.t'int l * UInt8BW.t'int r >= UInt8BW.t'int const_MIN
    /\ UInt8BW.t'int l * UInt8BW.t'int r <= UInt8BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.mul {l} {r} (fun (_ret: UInt8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt8BW.t = Any.any_l () | & l: UInt8BW.t = l | & r: UInt8BW.t = r ])
    [ return (result: UInt8BW.t) -> {[@expl:test_mul_bw ensures] UInt8BW.t'int result
      = UInt8BW.t'int l * UInt8BW.t'int r}
      (! return {result}) ]
end
module M_u8__test_div
  use creusot.int.UInt8
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: UInt8.t) (r: UInt8.t) (return (x: UInt8.t)) = {[@expl:test_div requires #0] UInt8.t'int r <> 0}
    {[@expl:test_div requires #1] Int.div (UInt8.t'int l) (UInt8.t'int r) >= UInt8.t'int const_MIN
    /\ Int.div (UInt8.t'int l) (UInt8.t'int r) <= UInt8.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt8.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt8.div {l} {_7} (fun (_ret: UInt8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt8.t = Any.any_l ()
    | & l: UInt8.t = l
    | & r: UInt8.t = r
    | & _7: UInt8.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt8.t) -> {[@expl:test_div ensures] UInt8.t'int result
      = Int.div (UInt8.t'int l) (UInt8.t'int r)}
      (! return {result}) ]
end
module M_u8__test_div_bw
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt8BW.t = (0: UInt8BW.t)
  
  constant const_MAX: UInt8BW.t = (255: UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: UInt8BW.t) (r: UInt8BW.t) (return (x: UInt8BW.t)) =
    {[@expl:test_div_bw requires #0] UInt8BW.t'int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (UInt8BW.t'int l) (UInt8BW.t'int r) >= UInt8BW.t'int const_MIN
    /\ Int.div (UInt8BW.t'int l) (UInt8BW.t'int r) <= UInt8BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt8BW.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt8BW.div {l} {_7} (fun (_ret: UInt8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt8BW.t = Any.any_l ()
    | & l: UInt8BW.t = l
    | & r: UInt8BW.t = r
    | & _7: UInt8BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt8BW.t) -> {[@expl:test_div_bw ensures] UInt8BW.t'int result
      = Int.div (UInt8BW.t'int l) (UInt8BW.t'int r)}
      (! return {result}) ]
end
module M_u8__test_from_bool
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  type tup2_ref_u8_ref_u8 = { f0: UInt8.t; f1: UInt8.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt8.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8.t = Any.any_l () | & b: UInt8.t = Any.any_l () ]
        [ _const_ret (_const: UInt8.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt8.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8.t = Any.any_l () ] [ _const_ret (_const: UInt8.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt8.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8.t = Any.any_l () | & b: UInt8.t = Any.any_l () ]
        [ _const_ret (_const: UInt8.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt8.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8.t = Any.any_l () ] [ _const_ret (_const: UInt8.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt8.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt8.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val: UInt8.t = Any.any_l ()
    | & right_val: UInt8.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt8.t = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _24: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val'0: UInt8.t = Any.any_l ()
    | & right_val'0: UInt8.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt8.t = Any.any_l ()
    | & _41: UInt8.t = Any.any_l ()
    | & _44: UInt8.t = Any.any_l ()
    | & _45: UInt8.t = Any.any_l ()
    | & _46: UInt8.t = Any.any_l ()
    | & _47: UInt8.t = Any.any_l () ])
    [ return (result: UInt8.t) -> {[@expl:test_from_bool ensures] result = UInt8.of_bool b} (! return {result}) ]
end
module M_u8__test_from_bool_bw
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  
  type tup2_ref_u8_ref_u8 = { f0: UInt8BW.t; f1: UInt8BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: UInt8BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt8BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () | & b: UInt8BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt8BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () ] [ _const_ret (_const: UInt8BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt8BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () | & b: UInt8BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt8BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt8BW.t = Any.any_l () ] [ _const_ret (_const: UInt8BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt8BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt8BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val: UInt8BW.t = Any.any_l ()
    | & right_val: UInt8BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt8BW.t = Any.any_l ()
    | & _21: UInt8BW.t = Any.any_l ()
    | & _24: tup2_ref_u8_ref_u8 = Any.any_l ()
    | & left_val'0: UInt8BW.t = Any.any_l ()
    | & right_val'0: UInt8BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt8BW.t = Any.any_l ()
    | & _41: UInt8BW.t = Any.any_l ()
    | & _44: UInt8BW.t = Any.any_l ()
    | & _45: UInt8BW.t = Any.any_l ()
    | & _46: UInt8BW.t = Any.any_l ()
    | & _47: UInt8BW.t = Any.any_l () ])
    [ return (result: UInt8BW.t) -> {[@expl:test_from_bool_bw ensures] result = UInt8BW.of_bool b} (! return {result}) ]
end
module M_u8__test_shl
  use creusot.int.Int32
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: UInt8.t) (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt8.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt8.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt8.t = Any.any_l () | & n: UInt8.t = n ])
    [ return (result: UInt8.t) -> {[@expl:test_shl ensures #0] result = UInt8.lsl n (UInt8.t'int (3: UInt8.t))}
      {[@expl:test_shl ensures #1] result = UInt8.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u8__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: UInt8BW.t) (return (x: UInt8BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt8BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt8BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt8BW.t = Any.any_l () | & n: UInt8BW.t = n ])
    [ return (result: UInt8BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = UInt8BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      {[@expl:test_shl_bw ensures #1] result = UInt8BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u8__test_shr
  use creusot.int.Int32
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: UInt8.t) (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt8.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt8.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt8.t = Any.any_l () | & n: UInt8.t = n ])
    [ return (result: UInt8.t) -> {[@expl:test_shr ensures #0] result = UInt8.shr n (UInt8.t'int (3: UInt8.t))}
      {[@expl:test_shr ensures #1] result = UInt8.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u8__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: UInt8BW.t) (return (x: UInt8BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt8BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt8BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt8BW.t = Any.any_l () | & n: UInt8BW.t = n ])
    [ return (result: UInt8BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = UInt8BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      {[@expl:test_shr_bw ensures #1] result = UInt8BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u8__test_to_char
  use creusot.int.UInt8
  use creusot.prelude.Char
  use creusot.prelude.Any
  
  type tup2_ref_char_ref_char = { f0: Char.t; f1: Char.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_to_char (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = Char.of_int {UInt8.t'int (97: UInt8.t)} (fun (_ret_from: Char.t) -> [ &_1 <- _ret_from ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Char.t = Any.any_l () | & _1: Char.t = Any.any_l () ]
        [ _const_ret (_const: Char.t) -> [ &_23 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- Char.of_int 97 ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Char.t = Any.any_l () ] [ _const_ret (_const: Char.t) -> [ &_22 <- _const ] s2 ]
      | s2 = [ &_2 <- { f0 = _23; f1 = _22 } ] s3
      | s3 = [ &left_val <- _2.f0 ] s4
      | s4 = [ &right_val <- _2.f1 ] s5
      | s5 = [ &_10 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_10 = false} (! bb2) | br1 -> {_10} (! bb1) ] ]
    | bb1 = return {_0}
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_18 <- left_val ] s2 | s2 = [ &_20 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & _2: tup2_ref_char_ref_char = Any.any_l ()
    | & left_val: Char.t = Any.any_l ()
    | & right_val: Char.t = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _18: Char.t = Any.any_l ()
    | & _20: Char.t = Any.any_l ()
    | & _22: Char.t = Any.any_l ()
    | & _23: Char.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_u8__test_to_char_bw
  use creusot.int.UInt8BW
  use creusot.prelude.Char
  use creusot.prelude.Any
  
  type tup2_ref_char_ref_char = { f0: Char.t; f1: Char.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_to_char_bw (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = Char.of_BV256 {UInt8BW.to_BV256 (255: UInt8BW.t)}
              (fun (_ret_from: Char.t) -> [ &_1 <- _ret_from ] s1'0)
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ] [ & _0'0: Char.t = Any.any_l () | & _1: Char.t = Any.any_l () ]
        [ _const_ret (_const: Char.t) -> [ &_23 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- Char.of_int 255 ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Char.t = Any.any_l () ] [ _const_ret (_const: Char.t) -> [ &_22 <- _const ] s2 ]
      | s2 = [ &_2 <- { f0 = _23; f1 = _22 } ] s3
      | s3 = [ &left_val <- _2.f0 ] s4
      | s4 = [ &right_val <- _2.f1 ] s5
      | s5 = [ &_10 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_10 = false} (! bb2) | br1 -> {_10} (! bb1) ] ]
    | bb1 = return {_0}
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_18 <- left_val ] s2 | s2 = [ &_20 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & _2: tup2_ref_char_ref_char = Any.any_l ()
    | & left_val: Char.t = Any.any_l ()
    | & right_val: Char.t = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _18: Char.t = Any.any_l ()
    | & _20: Char.t = Any.any_l ()
    | & _22: Char.t = Any.any_l ()
    | & _23: Char.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_i8__test_add
  use creusot.int.Int8
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: Int8.t) (r: Int8.t) (return (x: Int8.t)) = {[@expl:test_add requires] Int8.to_int l
        + Int8.to_int r
      >= Int8.to_int const_MIN
    /\ Int8.to_int l + Int8.to_int r <= Int8.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int8.add {l} {r} (fun (_ret: Int8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l () | & l: Int8.t = l | & r: Int8.t = r ])
    [ return (result: Int8.t) -> {[@expl:test_add ensures] Int8.to_int result = Int8.to_int l + Int8.to_int r}
      (! return {result}) ]
end
module M_i8__test_add_bw
  use creusot.int.Int8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int8BW.t = (128: Int8BW.t)
  
  constant const_MAX: Int8BW.t = (127: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: Int8BW.t) (r: Int8BW.t) (return (x: Int8BW.t)) = {[@expl:test_add_bw requires] Int8BW.to_int l
        + Int8BW.to_int r
      >= Int8BW.to_int const_MIN
    /\ Int8BW.to_int l + Int8BW.to_int r <= Int8BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.add {l} {r} (fun (_ret: Int8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8BW.t = Any.any_l () | & l: Int8BW.t = l | & r: Int8BW.t = r ])
    [ return (result: Int8BW.t) -> {[@expl:test_add_bw ensures] Int8BW.to_int result
      = Int8BW.to_int l + Int8BW.to_int r}
      (! return {result}) ]
end
module M_i8__test_sub
  use creusot.int.Int8
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: Int8.t) (r: Int8.t) (return (x: Int8.t)) = {[@expl:test_sub requires] Int8.to_int l
        - Int8.to_int r
      >= Int8.to_int const_MIN
    /\ Int8.to_int l - Int8.to_int r <= Int8.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int8.sub {l} {r} (fun (_ret: Int8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l () | & l: Int8.t = l | & r: Int8.t = r ])
    [ return (result: Int8.t) -> {[@expl:test_sub ensures] Int8.to_int result = Int8.to_int l - Int8.to_int r}
      (! return {result}) ]
end
module M_i8__test_sub_bw
  use creusot.int.Int8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int8BW.t = (128: Int8BW.t)
  
  constant const_MAX: Int8BW.t = (127: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: Int8BW.t) (r: Int8BW.t) (return (x: Int8BW.t)) = {[@expl:test_sub_bw requires] Int8BW.to_int l
        - Int8BW.to_int r
      >= Int8BW.to_int const_MIN
    /\ Int8BW.to_int l - Int8BW.to_int r <= Int8BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.sub {l} {r} (fun (_ret: Int8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8BW.t = Any.any_l () | & l: Int8BW.t = l | & r: Int8BW.t = r ])
    [ return (result: Int8BW.t) -> {[@expl:test_sub_bw ensures] Int8BW.to_int result
      = Int8BW.to_int l - Int8BW.to_int r}
      (! return {result}) ]
end
module M_i8__test_mul
  use creusot.int.Int8
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: Int8.t) (r: Int8.t) (return (x: Int8.t)) = {[@expl:test_mul requires] Int8.to_int l
        * Int8.to_int r
      >= Int8.to_int const_MIN
    /\ Int8.to_int l * Int8.to_int r <= Int8.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int8.mul {l} {r} (fun (_ret: Int8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l () | & l: Int8.t = l | & r: Int8.t = r ])
    [ return (result: Int8.t) -> {[@expl:test_mul ensures] Int8.to_int result = Int8.to_int l * Int8.to_int r}
      (! return {result}) ]
end
module M_i8__test_mul_bw
  use creusot.int.Int8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int8BW.t = (128: Int8BW.t)
  
  constant const_MAX: Int8BW.t = (127: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: Int8BW.t) (r: Int8BW.t) (return (x: Int8BW.t)) = {[@expl:test_mul_bw requires] Int8BW.to_int l
        * Int8BW.to_int r
      >= Int8BW.to_int const_MIN
    /\ Int8BW.to_int l * Int8BW.to_int r <= Int8BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.mul {l} {r} (fun (_ret: Int8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8BW.t = Any.any_l () | & l: Int8BW.t = l | & r: Int8BW.t = r ])
    [ return (result: Int8BW.t) -> {[@expl:test_mul_bw ensures] Int8BW.to_int result
      = Int8BW.to_int l * Int8BW.to_int r}
      (! return {result}) ]
end
module M_i8__test_div
  use creusot.int.Int8
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: Int8.t) (r: Int8.t) (return (x: Int8.t)) = {[@expl:test_div requires #0] Int8.to_int r <> 0}
    {[@expl:test_div requires #1] Int.div (Int8.to_int l) (Int8.to_int r) >= Int8.to_int const_MIN
    /\ Int.div (Int8.to_int l) (Int8.to_int r) <= Int8.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int8.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (-1: Int8.t) ] s1
      | s1 = [ &_10 <- _6 = (-128: Int8.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int8.div {_6} {_7} (fun (_ret: Int8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l ()
    | & l: Int8.t = l
    | & r: Int8.t = r
    | & _6: Int8.t = Any.any_l ()
    | & _7: Int8.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int8.t) -> {[@expl:test_div ensures] Int8.to_int result = Int.div (Int8.to_int l) (Int8.to_int r)}
      (! return {result}) ]
end
module M_i8__test_div_bw
  use creusot.int.Int8BW
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int8BW.t = (128: Int8BW.t)
  
  constant const_MAX: Int8BW.t = (127: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: Int8BW.t) (r: Int8BW.t) (return (x: Int8BW.t)) =
    {[@expl:test_div_bw requires #0] Int8BW.to_int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (Int8BW.to_int l) (Int8BW.to_int r) >= Int8BW.to_int const_MIN
    /\ Int.div (Int8BW.to_int l) (Int8BW.to_int r) <= Int8BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int8BW.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (255: Int8BW.t) ] s1
      | s1 = [ &_10 <- _6 = (128: Int8BW.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int8BW.div {_6} {_7} (fun (_ret: Int8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8BW.t = Any.any_l ()
    | & l: Int8BW.t = l
    | & r: Int8BW.t = r
    | & _6: Int8BW.t = Any.any_l ()
    | & _7: Int8BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int8BW.t) -> {[@expl:test_div_bw ensures] Int8BW.to_int result
      = Int.div (Int8BW.to_int l) (Int8BW.to_int r)}
      (! return {result}) ]
end
module M_i8__test_from_bool
  use creusot.int.Int8
  use creusot.prelude.Any
  
  type tup2_ref_i8_ref_i8 = { f0: Int8.t; f1: Int8.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: Int8.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int8.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8.t = Any.any_l () | & b: Int8.t = Any.any_l () ]
        [ _const_ret (_const: Int8.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int8.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8.t = Any.any_l () ] [ _const_ret (_const: Int8.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int8.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8.t = Any.any_l () | & b: Int8.t = Any.any_l () ]
        [ _const_ret (_const: Int8.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int8.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8.t = Any.any_l () ] [ _const_ret (_const: Int8.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int8.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int8.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val: Int8.t = Any.any_l ()
    | & right_val: Int8.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int8.t = Any.any_l ()
    | & _21: Int8.t = Any.any_l ()
    | & _24: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val'0: Int8.t = Any.any_l ()
    | & right_val'0: Int8.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int8.t = Any.any_l ()
    | & _41: Int8.t = Any.any_l ()
    | & _44: Int8.t = Any.any_l ()
    | & _45: Int8.t = Any.any_l ()
    | & _46: Int8.t = Any.any_l ()
    | & _47: Int8.t = Any.any_l () ])
    [ return (result: Int8.t) -> {[@expl:test_from_bool ensures] result = Int8.of_bool b} (! return {result}) ]
end
module M_i8__test_from_bool_bw
  use creusot.int.Int8BW
  use creusot.prelude.Any
  
  type tup2_ref_i8_ref_i8 = { f0: Int8BW.t; f1: Int8BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: Int8BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int8BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () | & b: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () ] [ _const_ret (_const: Int8BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int8BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () | & b: Int8BW.t = Any.any_l () ]
        [ _const_ret (_const: Int8BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int8BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int8BW.t = Any.any_l () ] [ _const_ret (_const: Int8BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int8BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int8BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val: Int8BW.t = Any.any_l ()
    | & right_val: Int8BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int8BW.t = Any.any_l ()
    | & _21: Int8BW.t = Any.any_l ()
    | & _24: tup2_ref_i8_ref_i8 = Any.any_l ()
    | & left_val'0: Int8BW.t = Any.any_l ()
    | & right_val'0: Int8BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int8BW.t = Any.any_l ()
    | & _41: Int8BW.t = Any.any_l ()
    | & _44: Int8BW.t = Any.any_l ()
    | & _45: Int8BW.t = Any.any_l ()
    | & _46: Int8BW.t = Any.any_l ()
    | & _47: Int8BW.t = Any.any_l () ])
    [ return (result: Int8BW.t) -> {[@expl:test_from_bool_bw ensures] result = Int8BW.of_bool b} (! return {result}) ]
end
module M_i8__test_shl
  use creusot.int.Int32
  use creusot.int.Int8
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: Int8.t) (return (x: Int8.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int8.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l () | & n: Int8.t = n ])
    [ return (result: Int8.t) -> {[@expl:test_shl ensures #0] result = Int8.lsl n (Int8.t'int (3: Int8.t))}
      {[@expl:test_shl ensures #1] result = Int8.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i8__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.Int8BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: Int8BW.t) (return (x: Int8BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int8BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int8BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int8BW.t = Any.any_l () | & n: Int8BW.t = n ])
    [ return (result: Int8BW.t) -> {[@expl:test_shl_bw ensures #0] result = Int8BW.lsl n (Int8BW.t'int (3: Int8BW.t))}
      {[@expl:test_shl_bw ensures #1] result = Int8BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i8__test_shr
  use creusot.int.Int32
  use creusot.int.Int8
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: Int8.t) (return (x: Int8.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int8.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l () | & n: Int8.t = n ])
    [ return (result: Int8.t) -> {[@expl:test_shr ensures #0] result = Int8.shr n (Int8.t'int (3: Int8.t))}
      {[@expl:test_shr ensures #1] result = Int8.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i8__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.Int8BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: Int8BW.t) (return (x: Int8BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int8BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int8BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int8BW.t = Any.any_l () | & n: Int8BW.t = n ])
    [ return (result: Int8BW.t) -> {[@expl:test_shr_bw ensures #0] result = Int8BW.shr n (Int8BW.t'int (3: Int8BW.t))}
      {[@expl:test_shr_bw ensures #1] result = Int8BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i8__test_neg
  use creusot.int.Int8
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom eq_cmp_i8_spec: forall x: Int8.t, y: Int8.t. (x = y) = (cmp_log_i8 x y = Equal)
  
  function antisym2_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym2_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Greater -> cmp_log_i8 y x = Less
  
  function antisym1_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym1_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Less -> cmp_log_i8 y x = Greater
  
  function trans_i8 (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  axiom trans_i8_spec: forall x: Int8.t, y: Int8.t, z: Int8.t, o: t_Ordering. cmp_log_i8 x y = o
      -> cmp_log_i8 y z = o -> cmp_log_i8 x z = o
  
  function refl_i8 (x: Int8.t) : ()
  
  axiom refl_i8_spec: forall x: Int8.t. cmp_log_i8 x x = Equal
  
  function cmp_gt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_gt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.gt x y = (cmp_log_i8 x y = Greater)
  
  function cmp_ge_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_ge_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.ge x y = (cmp_log_i8 x y <> Less)
  
  function cmp_lt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_lt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.lt x y = (cmp_log_i8 x y = Less)
  
  function cmp_le_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_le_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.le x y = (cmp_log_i8 x y <> Greater)
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_neg (n: Int8.t) (return (x: Int8.t)) = {[@expl:test_neg requires] Int8.gt n const_MIN}
    (! bb0
    [ bb0 = s0 [ s0 = Int8.neg {n} (fun (_ret: Int8.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l () | & n: Int8.t = n ])
    [ return (result: Int8.t) -> {[@expl:test_neg ensures] result = Int8.neg n} (! return {result}) ]
end
module M_i8__test_neg_bw
  use creusot.int.Int8BW
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8BW.t) (o: Int8BW.t) : t_Ordering = if Int8BW.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom eq_cmp_i8_spec: forall x: Int8BW.t, y: Int8BW.t. (x = y) = (cmp_log_i8 x y = Equal)
  
  function antisym2_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom antisym2_i8_spec: forall x: Int8BW.t, y: Int8BW.t. cmp_log_i8 x y = Greater -> cmp_log_i8 y x = Less
  
  function antisym1_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom antisym1_i8_spec: forall x: Int8BW.t, y: Int8BW.t. cmp_log_i8 x y = Less -> cmp_log_i8 y x = Greater
  
  function trans_i8 (x: Int8BW.t) (y: Int8BW.t) (z: Int8BW.t) (o: t_Ordering) : ()
  
  axiom trans_i8_spec: forall x: Int8BW.t, y: Int8BW.t, z: Int8BW.t, o: t_Ordering. cmp_log_i8 x y = o
      -> cmp_log_i8 y z = o -> cmp_log_i8 x z = o
  
  function refl_i8 (x: Int8BW.t) : ()
  
  axiom refl_i8_spec: forall x: Int8BW.t. cmp_log_i8 x x = Equal
  
  function cmp_gt_log_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_gt_log_i8_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.gt x y = (cmp_log_i8 x y = Greater)
  
  function cmp_ge_log_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_ge_log_i8_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.ge x y = (cmp_log_i8 x y <> Less)
  
  function cmp_lt_log_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_lt_log_i8_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.lt x y = (cmp_log_i8 x y = Less)
  
  function cmp_le_log_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_le_log_i8_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.le x y = (cmp_log_i8 x y <> Greater)
  
  constant const_MIN: Int8BW.t = (128: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_neg_bw (n: Int8BW.t) (return (x: Int8BW.t)) = {[@expl:test_neg_bw requires] Int8BW.gt n const_MIN}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.neg {n} (fun (_ret: Int8BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int8BW.t = Any.any_l () | & n: Int8BW.t = n ])
    [ return (result: Int8BW.t) -> {[@expl:test_neg_bw ensures] result = Int8BW.neg n} (! return {result}) ]
end
module M_u16__test_add
  use creusot.int.UInt16
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt16.t = (0: UInt16.t)
  
  constant const_MAX: UInt16.t = (65535: UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: UInt16.t) (r: UInt16.t) (return (x: UInt16.t)) = {[@expl:test_add requires] UInt16.t'int l
        + UInt16.t'int r
      >= UInt16.t'int const_MIN
    /\ UInt16.t'int l + UInt16.t'int r <= UInt16.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.add {l} {r} (fun (_ret: UInt16.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt16.t = Any.any_l () | & l: UInt16.t = l | & r: UInt16.t = r ])
    [ return (result: UInt16.t) -> {[@expl:test_add ensures] UInt16.t'int result = UInt16.t'int l + UInt16.t'int r}
      (! return {result}) ]
end
module M_u16__test_add_bw
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt16BW.t = (0: UInt16BW.t)
  
  constant const_MAX: UInt16BW.t = (65535: UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: UInt16BW.t) (r: UInt16BW.t) (return (x: UInt16BW.t)) =
    {[@expl:test_add_bw requires] UInt16BW.t'int l + UInt16BW.t'int r >= UInt16BW.t'int const_MIN
    /\ UInt16BW.t'int l + UInt16BW.t'int r <= UInt16BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.add {l} {r} (fun (_ret: UInt16BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt16BW.t = Any.any_l () | & l: UInt16BW.t = l | & r: UInt16BW.t = r ])
    [ return (result: UInt16BW.t) -> {[@expl:test_add_bw ensures] UInt16BW.t'int result
      = UInt16BW.t'int l + UInt16BW.t'int r}
      (! return {result}) ]
end
module M_u16__test_sub
  use creusot.int.UInt16
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt16.t = (0: UInt16.t)
  
  constant const_MAX: UInt16.t = (65535: UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: UInt16.t) (r: UInt16.t) (return (x: UInt16.t)) = {[@expl:test_sub requires] UInt16.t'int l
        - UInt16.t'int r
      >= UInt16.t'int const_MIN
    /\ UInt16.t'int l - UInt16.t'int r <= UInt16.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.sub {l} {r} (fun (_ret: UInt16.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt16.t = Any.any_l () | & l: UInt16.t = l | & r: UInt16.t = r ])
    [ return (result: UInt16.t) -> {[@expl:test_sub ensures] UInt16.t'int result = UInt16.t'int l - UInt16.t'int r}
      (! return {result}) ]
end
module M_u16__test_sub_bw
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt16BW.t = (0: UInt16BW.t)
  
  constant const_MAX: UInt16BW.t = (65535: UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: UInt16BW.t) (r: UInt16BW.t) (return (x: UInt16BW.t)) =
    {[@expl:test_sub_bw requires] UInt16BW.t'int l - UInt16BW.t'int r >= UInt16BW.t'int const_MIN
    /\ UInt16BW.t'int l - UInt16BW.t'int r <= UInt16BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.sub {l} {r} (fun (_ret: UInt16BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt16BW.t = Any.any_l () | & l: UInt16BW.t = l | & r: UInt16BW.t = r ])
    [ return (result: UInt16BW.t) -> {[@expl:test_sub_bw ensures] UInt16BW.t'int result
      = UInt16BW.t'int l - UInt16BW.t'int r}
      (! return {result}) ]
end
module M_u16__test_mul
  use creusot.int.UInt16
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt16.t = (0: UInt16.t)
  
  constant const_MAX: UInt16.t = (65535: UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: UInt16.t) (r: UInt16.t) (return (x: UInt16.t)) = {[@expl:test_mul requires] UInt16.t'int l
        * UInt16.t'int r
      >= UInt16.t'int const_MIN
    /\ UInt16.t'int l * UInt16.t'int r <= UInt16.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.mul {l} {r} (fun (_ret: UInt16.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt16.t = Any.any_l () | & l: UInt16.t = l | & r: UInt16.t = r ])
    [ return (result: UInt16.t) -> {[@expl:test_mul ensures] UInt16.t'int result = UInt16.t'int l * UInt16.t'int r}
      (! return {result}) ]
end
module M_u16__test_mul_bw
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt16BW.t = (0: UInt16BW.t)
  
  constant const_MAX: UInt16BW.t = (65535: UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: UInt16BW.t) (r: UInt16BW.t) (return (x: UInt16BW.t)) =
    {[@expl:test_mul_bw requires] UInt16BW.t'int l * UInt16BW.t'int r >= UInt16BW.t'int const_MIN
    /\ UInt16BW.t'int l * UInt16BW.t'int r <= UInt16BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.mul {l} {r} (fun (_ret: UInt16BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt16BW.t = Any.any_l () | & l: UInt16BW.t = l | & r: UInt16BW.t = r ])
    [ return (result: UInt16BW.t) -> {[@expl:test_mul_bw ensures] UInt16BW.t'int result
      = UInt16BW.t'int l * UInt16BW.t'int r}
      (! return {result}) ]
end
module M_u16__test_div
  use creusot.int.UInt16
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt16.t = (0: UInt16.t)
  
  constant const_MAX: UInt16.t = (65535: UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: UInt16.t) (r: UInt16.t) (return (x: UInt16.t)) = {[@expl:test_div requires #0] UInt16.t'int r
    <> 0}
    {[@expl:test_div requires #1] Int.div (UInt16.t'int l) (UInt16.t'int r) >= UInt16.t'int const_MIN
    /\ Int.div (UInt16.t'int l) (UInt16.t'int r) <= UInt16.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt16.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt16.div {l} {_7} (fun (_ret: UInt16.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt16.t = Any.any_l ()
    | & l: UInt16.t = l
    | & r: UInt16.t = r
    | & _7: UInt16.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt16.t) -> {[@expl:test_div ensures] UInt16.t'int result
      = Int.div (UInt16.t'int l) (UInt16.t'int r)}
      (! return {result}) ]
end
module M_u16__test_div_bw
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt16BW.t = (0: UInt16BW.t)
  
  constant const_MAX: UInt16BW.t = (65535: UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: UInt16BW.t) (r: UInt16BW.t) (return (x: UInt16BW.t)) =
    {[@expl:test_div_bw requires #0] UInt16BW.t'int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (UInt16BW.t'int l) (UInt16BW.t'int r) >= UInt16BW.t'int const_MIN
    /\ Int.div (UInt16BW.t'int l) (UInt16BW.t'int r) <= UInt16BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt16BW.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt16BW.div {l} {_7} (fun (_ret: UInt16BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt16BW.t = Any.any_l ()
    | & l: UInt16BW.t = l
    | & r: UInt16BW.t = r
    | & _7: UInt16BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt16BW.t) -> {[@expl:test_div_bw ensures] UInt16BW.t'int result
      = Int.div (UInt16BW.t'int l) (UInt16BW.t'int r)}
      (! return {result}) ]
end
module M_u16__test_from_bool
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  type tup2_ref_u16_ref_u16 = { f0: UInt16.t; f1: UInt16.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt16.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16.t = Any.any_l () | & b: UInt16.t = Any.any_l () ]
        [ _const_ret (_const: UInt16.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt16.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16.t = Any.any_l () ] [ _const_ret (_const: UInt16.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt16.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16.t = Any.any_l () | & b: UInt16.t = Any.any_l () ]
        [ _const_ret (_const: UInt16.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt16.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16.t = Any.any_l () ] [ _const_ret (_const: UInt16.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt16.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt16.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val: UInt16.t = Any.any_l ()
    | & right_val: UInt16.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt16.t = Any.any_l ()
    | & _21: UInt16.t = Any.any_l ()
    | & _24: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val'0: UInt16.t = Any.any_l ()
    | & right_val'0: UInt16.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt16.t = Any.any_l ()
    | & _41: UInt16.t = Any.any_l ()
    | & _44: UInt16.t = Any.any_l ()
    | & _45: UInt16.t = Any.any_l ()
    | & _46: UInt16.t = Any.any_l ()
    | & _47: UInt16.t = Any.any_l () ])
    [ return (result: UInt16.t) -> {[@expl:test_from_bool ensures] result = UInt16.of_bool b} (! return {result}) ]
end
module M_u16__test_from_bool_bw
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  
  type tup2_ref_u16_ref_u16 = { f0: UInt16BW.t; f1: UInt16BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: UInt16BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt16BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () | & b: UInt16BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt16BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () ] [ _const_ret (_const: UInt16BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt16BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () | & b: UInt16BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt16BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt16BW.t = Any.any_l () ] [ _const_ret (_const: UInt16BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt16BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt16BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val: UInt16BW.t = Any.any_l ()
    | & right_val: UInt16BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt16BW.t = Any.any_l ()
    | & _21: UInt16BW.t = Any.any_l ()
    | & _24: tup2_ref_u16_ref_u16 = Any.any_l ()
    | & left_val'0: UInt16BW.t = Any.any_l ()
    | & right_val'0: UInt16BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt16BW.t = Any.any_l ()
    | & _41: UInt16BW.t = Any.any_l ()
    | & _44: UInt16BW.t = Any.any_l ()
    | & _45: UInt16BW.t = Any.any_l ()
    | & _46: UInt16BW.t = Any.any_l ()
    | & _47: UInt16BW.t = Any.any_l () ])
    [ return (result: UInt16BW.t) -> {[@expl:test_from_bool_bw ensures] result = UInt16BW.of_bool b}
      (! return {result}) ]
end
module M_u16__test_shl
  use creusot.int.Int32
  use creusot.int.UInt16
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: UInt16.t) (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt16.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt16.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt16.t = Any.any_l () | & n: UInt16.t = n ])
    [ return (result: UInt16.t) -> {[@expl:test_shl ensures #0] result = UInt16.lsl n (UInt16.t'int (3: UInt16.t))}
      {[@expl:test_shl ensures #1] result = UInt16.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u16__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: UInt16BW.t) (return (x: UInt16BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt16BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt16BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt16BW.t = Any.any_l () | & n: UInt16BW.t = n ])
    [ return (result: UInt16BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = UInt16BW.lsl n (UInt16BW.t'int (3: UInt16BW.t))}
      {[@expl:test_shl_bw ensures #1] result = UInt16BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u16__test_shr
  use creusot.int.Int32
  use creusot.int.UInt16
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: UInt16.t) (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt16.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt16.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt16.t = Any.any_l () | & n: UInt16.t = n ])
    [ return (result: UInt16.t) -> {[@expl:test_shr ensures #0] result = UInt16.shr n (UInt16.t'int (3: UInt16.t))}
      {[@expl:test_shr ensures #1] result = UInt16.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u16__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: UInt16BW.t) (return (x: UInt16BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt16BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt16BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt16BW.t = Any.any_l () | & n: UInt16BW.t = n ])
    [ return (result: UInt16BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = UInt16BW.shr n (UInt16BW.t'int (3: UInt16BW.t))}
      {[@expl:test_shr_bw ensures #1] result = UInt16BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i16__test_add
  use creusot.int.Int16
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int16.t = (-32768: Int16.t)
  
  constant const_MAX: Int16.t = (32767: Int16.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: Int16.t) (r: Int16.t) (return (x: Int16.t)) = {[@expl:test_add requires] Int16.to_int l
        + Int16.to_int r
      >= Int16.to_int const_MIN
    /\ Int16.to_int l + Int16.to_int r <= Int16.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int16.add {l} {r} (fun (_ret: Int16.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int16.t = Any.any_l () | & l: Int16.t = l | & r: Int16.t = r ])
    [ return (result: Int16.t) -> {[@expl:test_add ensures] Int16.to_int result = Int16.to_int l + Int16.to_int r}
      (! return {result}) ]
end
module M_i16__test_add_bw
  use creusot.int.Int16BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int16BW.t = (32768: Int16BW.t)
  
  constant const_MAX: Int16BW.t = (32767: Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: Int16BW.t) (r: Int16BW.t) (return (x: Int16BW.t)) =
    {[@expl:test_add_bw requires] Int16BW.to_int l + Int16BW.to_int r >= Int16BW.to_int const_MIN
    /\ Int16BW.to_int l + Int16BW.to_int r <= Int16BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.add {l} {r} (fun (_ret: Int16BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int16BW.t = Any.any_l () | & l: Int16BW.t = l | & r: Int16BW.t = r ])
    [ return (result: Int16BW.t) -> {[@expl:test_add_bw ensures] Int16BW.to_int result
      = Int16BW.to_int l + Int16BW.to_int r}
      (! return {result}) ]
end
module M_i16__test_sub
  use creusot.int.Int16
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int16.t = (-32768: Int16.t)
  
  constant const_MAX: Int16.t = (32767: Int16.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: Int16.t) (r: Int16.t) (return (x: Int16.t)) = {[@expl:test_sub requires] Int16.to_int l
        - Int16.to_int r
      >= Int16.to_int const_MIN
    /\ Int16.to_int l - Int16.to_int r <= Int16.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int16.sub {l} {r} (fun (_ret: Int16.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int16.t = Any.any_l () | & l: Int16.t = l | & r: Int16.t = r ])
    [ return (result: Int16.t) -> {[@expl:test_sub ensures] Int16.to_int result = Int16.to_int l - Int16.to_int r}
      (! return {result}) ]
end
module M_i16__test_sub_bw
  use creusot.int.Int16BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int16BW.t = (32768: Int16BW.t)
  
  constant const_MAX: Int16BW.t = (32767: Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: Int16BW.t) (r: Int16BW.t) (return (x: Int16BW.t)) =
    {[@expl:test_sub_bw requires] Int16BW.to_int l - Int16BW.to_int r >= Int16BW.to_int const_MIN
    /\ Int16BW.to_int l - Int16BW.to_int r <= Int16BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.sub {l} {r} (fun (_ret: Int16BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int16BW.t = Any.any_l () | & l: Int16BW.t = l | & r: Int16BW.t = r ])
    [ return (result: Int16BW.t) -> {[@expl:test_sub_bw ensures] Int16BW.to_int result
      = Int16BW.to_int l - Int16BW.to_int r}
      (! return {result}) ]
end
module M_i16__test_mul
  use creusot.int.Int16
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int16.t = (-32768: Int16.t)
  
  constant const_MAX: Int16.t = (32767: Int16.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: Int16.t) (r: Int16.t) (return (x: Int16.t)) = {[@expl:test_mul requires] Int16.to_int l
        * Int16.to_int r
      >= Int16.to_int const_MIN
    /\ Int16.to_int l * Int16.to_int r <= Int16.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int16.mul {l} {r} (fun (_ret: Int16.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int16.t = Any.any_l () | & l: Int16.t = l | & r: Int16.t = r ])
    [ return (result: Int16.t) -> {[@expl:test_mul ensures] Int16.to_int result = Int16.to_int l * Int16.to_int r}
      (! return {result}) ]
end
module M_i16__test_mul_bw
  use creusot.int.Int16BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int16BW.t = (32768: Int16BW.t)
  
  constant const_MAX: Int16BW.t = (32767: Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: Int16BW.t) (r: Int16BW.t) (return (x: Int16BW.t)) =
    {[@expl:test_mul_bw requires] Int16BW.to_int l * Int16BW.to_int r >= Int16BW.to_int const_MIN
    /\ Int16BW.to_int l * Int16BW.to_int r <= Int16BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.mul {l} {r} (fun (_ret: Int16BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int16BW.t = Any.any_l () | & l: Int16BW.t = l | & r: Int16BW.t = r ])
    [ return (result: Int16BW.t) -> {[@expl:test_mul_bw ensures] Int16BW.to_int result
      = Int16BW.to_int l * Int16BW.to_int r}
      (! return {result}) ]
end
module M_i16__test_div
  use creusot.int.Int16
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int16.t = (-32768: Int16.t)
  
  constant const_MAX: Int16.t = (32767: Int16.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: Int16.t) (r: Int16.t) (return (x: Int16.t)) = {[@expl:test_div requires #0] Int16.to_int r <> 0}
    {[@expl:test_div requires #1] Int.div (Int16.to_int l) (Int16.to_int r) >= Int16.to_int const_MIN
    /\ Int.div (Int16.to_int l) (Int16.to_int r) <= Int16.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int16.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (-1: Int16.t) ] s1
      | s1 = [ &_10 <- _6 = (-32768: Int16.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int16.div {_6} {_7} (fun (_ret: Int16.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int16.t = Any.any_l ()
    | & l: Int16.t = l
    | & r: Int16.t = r
    | & _6: Int16.t = Any.any_l ()
    | & _7: Int16.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int16.t) -> {[@expl:test_div ensures] Int16.to_int result
      = Int.div (Int16.to_int l) (Int16.to_int r)}
      (! return {result}) ]
end
module M_i16__test_div_bw
  use creusot.int.Int16BW
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int16BW.t = (32768: Int16BW.t)
  
  constant const_MAX: Int16BW.t = (32767: Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: Int16BW.t) (r: Int16BW.t) (return (x: Int16BW.t)) =
    {[@expl:test_div_bw requires #0] Int16BW.to_int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (Int16BW.to_int l) (Int16BW.to_int r) >= Int16BW.to_int const_MIN
    /\ Int.div (Int16BW.to_int l) (Int16BW.to_int r) <= Int16BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int16BW.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (65535: Int16BW.t) ] s1
      | s1 = [ &_10 <- _6 = (32768: Int16BW.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int16BW.div {_6} {_7} (fun (_ret: Int16BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int16BW.t = Any.any_l ()
    | & l: Int16BW.t = l
    | & r: Int16BW.t = r
    | & _6: Int16BW.t = Any.any_l ()
    | & _7: Int16BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int16BW.t) -> {[@expl:test_div_bw ensures] Int16BW.to_int result
      = Int.div (Int16BW.to_int l) (Int16BW.to_int r)}
      (! return {result}) ]
end
module M_i16__test_from_bool
  use creusot.int.Int16
  use creusot.prelude.Any
  
  type tup2_ref_i16_ref_i16 = { f0: Int16.t; f1: Int16.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: Int16.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int16.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16.t = Any.any_l () | & b: Int16.t = Any.any_l () ]
        [ _const_ret (_const: Int16.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int16.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16.t = Any.any_l () ] [ _const_ret (_const: Int16.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int16.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16.t = Any.any_l () | & b: Int16.t = Any.any_l () ]
        [ _const_ret (_const: Int16.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int16.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16.t = Any.any_l () ] [ _const_ret (_const: Int16.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int16.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int16.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i16_ref_i16 = Any.any_l ()
    | & left_val: Int16.t = Any.any_l ()
    | & right_val: Int16.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int16.t = Any.any_l ()
    | & _21: Int16.t = Any.any_l ()
    | & _24: tup2_ref_i16_ref_i16 = Any.any_l ()
    | & left_val'0: Int16.t = Any.any_l ()
    | & right_val'0: Int16.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int16.t = Any.any_l ()
    | & _41: Int16.t = Any.any_l ()
    | & _44: Int16.t = Any.any_l ()
    | & _45: Int16.t = Any.any_l ()
    | & _46: Int16.t = Any.any_l ()
    | & _47: Int16.t = Any.any_l () ])
    [ return (result: Int16.t) -> {[@expl:test_from_bool ensures] result = Int16.of_bool b} (! return {result}) ]
end
module M_i16__test_from_bool_bw
  use creusot.int.Int16BW
  use creusot.prelude.Any
  
  type tup2_ref_i16_ref_i16 = { f0: Int16BW.t; f1: Int16BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: Int16BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int16BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16BW.t = Any.any_l () | & b: Int16BW.t = Any.any_l () ]
        [ _const_ret (_const: Int16BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16BW.t = Any.any_l () ] [ _const_ret (_const: Int16BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int16BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16BW.t = Any.any_l () | & b: Int16BW.t = Any.any_l () ]
        [ _const_ret (_const: Int16BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int16BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int16BW.t = Any.any_l () ] [ _const_ret (_const: Int16BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int16BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int16BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i16_ref_i16 = Any.any_l ()
    | & left_val: Int16BW.t = Any.any_l ()
    | & right_val: Int16BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int16BW.t = Any.any_l ()
    | & _21: Int16BW.t = Any.any_l ()
    | & _24: tup2_ref_i16_ref_i16 = Any.any_l ()
    | & left_val'0: Int16BW.t = Any.any_l ()
    | & right_val'0: Int16BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int16BW.t = Any.any_l ()
    | & _41: Int16BW.t = Any.any_l ()
    | & _44: Int16BW.t = Any.any_l ()
    | & _45: Int16BW.t = Any.any_l ()
    | & _46: Int16BW.t = Any.any_l ()
    | & _47: Int16BW.t = Any.any_l () ])
    [ return (result: Int16BW.t) -> {[@expl:test_from_bool_bw ensures] result = Int16BW.of_bool b} (! return {result}) ]
end
module M_i16__test_shl
  use creusot.int.Int32
  use creusot.int.Int16
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: Int16.t) (return (x: Int16.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int16.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int16.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int16.t = Any.any_l () | & n: Int16.t = n ])
    [ return (result: Int16.t) -> {[@expl:test_shl ensures #0] result = Int16.lsl n (Int16.t'int (3: Int16.t))}
      {[@expl:test_shl ensures #1] result = Int16.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i16__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.Int16BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: Int16BW.t) (return (x: Int16BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int16BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int16BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int16BW.t = Any.any_l () | & n: Int16BW.t = n ])
    [ return (result: Int16BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = Int16BW.lsl n (Int16BW.t'int (3: Int16BW.t))}
      {[@expl:test_shl_bw ensures #1] result = Int16BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i16__test_shr
  use creusot.int.Int32
  use creusot.int.Int16
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: Int16.t) (return (x: Int16.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int16.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int16.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int16.t = Any.any_l () | & n: Int16.t = n ])
    [ return (result: Int16.t) -> {[@expl:test_shr ensures #0] result = Int16.shr n (Int16.t'int (3: Int16.t))}
      {[@expl:test_shr ensures #1] result = Int16.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i16__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.Int16BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: Int16BW.t) (return (x: Int16BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int16BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int16BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int16BW.t = Any.any_l () | & n: Int16BW.t = n ])
    [ return (result: Int16BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = Int16BW.shr n (Int16BW.t'int (3: Int16BW.t))}
      {[@expl:test_shr_bw ensures #1] result = Int16BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u32__test_add
  use creusot.int.UInt32
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt32.t = (0: UInt32.t)
  
  constant const_MAX: UInt32.t = (4294967295: UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: UInt32.t) (r: UInt32.t) (return (x: UInt32.t)) = {[@expl:test_add requires] UInt32.t'int l
        + UInt32.t'int r
      >= UInt32.t'int const_MIN
    /\ UInt32.t'int l + UInt32.t'int r <= UInt32.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.add {l} {r} (fun (_ret: UInt32.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l () | & l: UInt32.t = l | & r: UInt32.t = r ])
    [ return (result: UInt32.t) -> {[@expl:test_add ensures] UInt32.t'int result = UInt32.t'int l + UInt32.t'int r}
      (! return {result}) ]
end
module M_u32__test_add_bw
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt32BW.t = (0: UInt32BW.t)
  
  constant const_MAX: UInt32BW.t = (4294967295: UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: UInt32BW.t) (r: UInt32BW.t) (return (x: UInt32BW.t)) =
    {[@expl:test_add_bw requires] UInt32BW.t'int l + UInt32BW.t'int r >= UInt32BW.t'int const_MIN
    /\ UInt32BW.t'int l + UInt32BW.t'int r <= UInt32BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.add {l} {r} (fun (_ret: UInt32BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt32BW.t = Any.any_l () | & l: UInt32BW.t = l | & r: UInt32BW.t = r ])
    [ return (result: UInt32BW.t) -> {[@expl:test_add_bw ensures] UInt32BW.t'int result
      = UInt32BW.t'int l + UInt32BW.t'int r}
      (! return {result}) ]
end
module M_u32__test_sub
  use creusot.int.UInt32
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt32.t = (0: UInt32.t)
  
  constant const_MAX: UInt32.t = (4294967295: UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: UInt32.t) (r: UInt32.t) (return (x: UInt32.t)) = {[@expl:test_sub requires] UInt32.t'int l
        - UInt32.t'int r
      >= UInt32.t'int const_MIN
    /\ UInt32.t'int l - UInt32.t'int r <= UInt32.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.sub {l} {r} (fun (_ret: UInt32.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l () | & l: UInt32.t = l | & r: UInt32.t = r ])
    [ return (result: UInt32.t) -> {[@expl:test_sub ensures] UInt32.t'int result = UInt32.t'int l - UInt32.t'int r}
      (! return {result}) ]
end
module M_u32__test_sub_bw
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt32BW.t = (0: UInt32BW.t)
  
  constant const_MAX: UInt32BW.t = (4294967295: UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: UInt32BW.t) (r: UInt32BW.t) (return (x: UInt32BW.t)) =
    {[@expl:test_sub_bw requires] UInt32BW.t'int l - UInt32BW.t'int r >= UInt32BW.t'int const_MIN
    /\ UInt32BW.t'int l - UInt32BW.t'int r <= UInt32BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.sub {l} {r} (fun (_ret: UInt32BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt32BW.t = Any.any_l () | & l: UInt32BW.t = l | & r: UInt32BW.t = r ])
    [ return (result: UInt32BW.t) -> {[@expl:test_sub_bw ensures] UInt32BW.t'int result
      = UInt32BW.t'int l - UInt32BW.t'int r}
      (! return {result}) ]
end
module M_u32__test_mul
  use creusot.int.UInt32
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt32.t = (0: UInt32.t)
  
  constant const_MAX: UInt32.t = (4294967295: UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: UInt32.t) (r: UInt32.t) (return (x: UInt32.t)) = {[@expl:test_mul requires] UInt32.t'int l
        * UInt32.t'int r
      >= UInt32.t'int const_MIN
    /\ UInt32.t'int l * UInt32.t'int r <= UInt32.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.mul {l} {r} (fun (_ret: UInt32.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l () | & l: UInt32.t = l | & r: UInt32.t = r ])
    [ return (result: UInt32.t) -> {[@expl:test_mul ensures] UInt32.t'int result = UInt32.t'int l * UInt32.t'int r}
      (! return {result}) ]
end
module M_u32__test_mul_bw
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt32BW.t = (0: UInt32BW.t)
  
  constant const_MAX: UInt32BW.t = (4294967295: UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: UInt32BW.t) (r: UInt32BW.t) (return (x: UInt32BW.t)) =
    {[@expl:test_mul_bw requires] UInt32BW.t'int l * UInt32BW.t'int r >= UInt32BW.t'int const_MIN
    /\ UInt32BW.t'int l * UInt32BW.t'int r <= UInt32BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.mul {l} {r} (fun (_ret: UInt32BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt32BW.t = Any.any_l () | & l: UInt32BW.t = l | & r: UInt32BW.t = r ])
    [ return (result: UInt32BW.t) -> {[@expl:test_mul_bw ensures] UInt32BW.t'int result
      = UInt32BW.t'int l * UInt32BW.t'int r}
      (! return {result}) ]
end
module M_u32__test_div
  use creusot.int.UInt32
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt32.t = (0: UInt32.t)
  
  constant const_MAX: UInt32.t = (4294967295: UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: UInt32.t) (r: UInt32.t) (return (x: UInt32.t)) = {[@expl:test_div requires #0] UInt32.t'int r
    <> 0}
    {[@expl:test_div requires #1] Int.div (UInt32.t'int l) (UInt32.t'int r) >= UInt32.t'int const_MIN
    /\ Int.div (UInt32.t'int l) (UInt32.t'int r) <= UInt32.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt32.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt32.div {l} {_7} (fun (_ret: UInt32.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l ()
    | & l: UInt32.t = l
    | & r: UInt32.t = r
    | & _7: UInt32.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:test_div ensures] UInt32.t'int result
      = Int.div (UInt32.t'int l) (UInt32.t'int r)}
      (! return {result}) ]
end
module M_u32__test_div_bw
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt32BW.t = (0: UInt32BW.t)
  
  constant const_MAX: UInt32BW.t = (4294967295: UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: UInt32BW.t) (r: UInt32BW.t) (return (x: UInt32BW.t)) =
    {[@expl:test_div_bw requires #0] UInt32BW.t'int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (UInt32BW.t'int l) (UInt32BW.t'int r) >= UInt32BW.t'int const_MIN
    /\ Int.div (UInt32BW.t'int l) (UInt32BW.t'int r) <= UInt32BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt32BW.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt32BW.div {l} {_7} (fun (_ret: UInt32BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt32BW.t = Any.any_l ()
    | & l: UInt32BW.t = l
    | & r: UInt32BW.t = r
    | & _7: UInt32BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt32BW.t) -> {[@expl:test_div_bw ensures] UInt32BW.t'int result
      = Int.div (UInt32BW.t'int l) (UInt32BW.t'int r)}
      (! return {result}) ]
end
module M_u32__test_from_bool
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  type tup2_ref_u32_ref_u32 = { f0: UInt32.t; f1: UInt32.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt32.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32.t = Any.any_l () | & b: UInt32.t = Any.any_l () ]
        [ _const_ret (_const: UInt32.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32.t = Any.any_l () ] [ _const_ret (_const: UInt32.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt32.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32.t = Any.any_l () | & b: UInt32.t = Any.any_l () ]
        [ _const_ret (_const: UInt32.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32.t = Any.any_l () ] [ _const_ret (_const: UInt32.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt32.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt32.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val: UInt32.t = Any.any_l ()
    | & right_val: UInt32.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt32.t = Any.any_l ()
    | & _21: UInt32.t = Any.any_l ()
    | & _24: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val'0: UInt32.t = Any.any_l ()
    | & right_val'0: UInt32.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt32.t = Any.any_l ()
    | & _41: UInt32.t = Any.any_l ()
    | & _44: UInt32.t = Any.any_l ()
    | & _45: UInt32.t = Any.any_l ()
    | & _46: UInt32.t = Any.any_l ()
    | & _47: UInt32.t = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:test_from_bool ensures] result = UInt32.of_bool b} (! return {result}) ]
end
module M_u32__test_from_bool_bw
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  
  type tup2_ref_u32_ref_u32 = { f0: UInt32BW.t; f1: UInt32BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: UInt32BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt32BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () | & b: UInt32BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt32BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () ] [ _const_ret (_const: UInt32BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt32BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () | & b: UInt32BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt32BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt32BW.t = Any.any_l () ] [ _const_ret (_const: UInt32BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt32BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt32BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val: UInt32BW.t = Any.any_l ()
    | & right_val: UInt32BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt32BW.t = Any.any_l ()
    | & _21: UInt32BW.t = Any.any_l ()
    | & _24: tup2_ref_u32_ref_u32 = Any.any_l ()
    | & left_val'0: UInt32BW.t = Any.any_l ()
    | & right_val'0: UInt32BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt32BW.t = Any.any_l ()
    | & _41: UInt32BW.t = Any.any_l ()
    | & _44: UInt32BW.t = Any.any_l ()
    | & _45: UInt32BW.t = Any.any_l ()
    | & _46: UInt32BW.t = Any.any_l ()
    | & _47: UInt32BW.t = Any.any_l () ])
    [ return (result: UInt32BW.t) -> {[@expl:test_from_bool_bw ensures] result = UInt32BW.of_bool b}
      (! return {result}) ]
end
module M_u32__test_shl
  use creusot.int.Int32
  use creusot.int.UInt32
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: UInt32.t) (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt32.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt32.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt32.t = Any.any_l () | & n: UInt32.t = n ])
    [ return (result: UInt32.t) -> {[@expl:test_shl ensures #0] result = UInt32.lsl n (UInt32.t'int (3: UInt32.t))}
      {[@expl:test_shl ensures #1] result = UInt32.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u32__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: UInt32BW.t) (return (x: UInt32BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt32BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt32BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt32BW.t = Any.any_l () | & n: UInt32BW.t = n ])
    [ return (result: UInt32BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = UInt32BW.lsl n (UInt32BW.t'int (3: UInt32BW.t))}
      {[@expl:test_shl_bw ensures #1] result = UInt32BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u32__test_shr
  use creusot.int.Int32
  use creusot.int.UInt32
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: UInt32.t) (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt32.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt32.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt32.t = Any.any_l () | & n: UInt32.t = n ])
    [ return (result: UInt32.t) -> {[@expl:test_shr ensures #0] result = UInt32.shr n (UInt32.t'int (3: UInt32.t))}
      {[@expl:test_shr ensures #1] result = UInt32.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u32__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: UInt32BW.t) (return (x: UInt32BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt32BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt32BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt32BW.t = Any.any_l () | & n: UInt32BW.t = n ])
    [ return (result: UInt32BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = UInt32BW.shr n (UInt32BW.t'int (3: UInt32BW.t))}
      {[@expl:test_shr_bw ensures #1] result = UInt32BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i32__test_add
  use creusot.int.Int32
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int32.t = (-2147483648: Int32.t)
  
  constant const_MAX: Int32.t = (2147483647: Int32.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: Int32.t) (r: Int32.t) (return (x: Int32.t)) = {[@expl:test_add requires] Int32.to_int l
        + Int32.to_int r
      >= Int32.to_int const_MIN
    /\ Int32.to_int l + Int32.to_int r <= Int32.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int32.add {l} {r} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int32.t = Any.any_l () | & l: Int32.t = l | & r: Int32.t = r ])
    [ return (result: Int32.t) -> {[@expl:test_add ensures] Int32.to_int result = Int32.to_int l + Int32.to_int r}
      (! return {result}) ]
end
module M_i32__test_add_bw
  use creusot.int.Int32BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int32BW.t = (2147483648: Int32BW.t)
  
  constant const_MAX: Int32BW.t = (2147483647: Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: Int32BW.t) (r: Int32BW.t) (return (x: Int32BW.t)) =
    {[@expl:test_add_bw requires] Int32BW.to_int l + Int32BW.to_int r >= Int32BW.to_int const_MIN
    /\ Int32BW.to_int l + Int32BW.to_int r <= Int32BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.add {l} {r} (fun (_ret: Int32BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int32BW.t = Any.any_l () | & l: Int32BW.t = l | & r: Int32BW.t = r ])
    [ return (result: Int32BW.t) -> {[@expl:test_add_bw ensures] Int32BW.to_int result
      = Int32BW.to_int l + Int32BW.to_int r}
      (! return {result}) ]
end
module M_i32__test_sub
  use creusot.int.Int32
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int32.t = (-2147483648: Int32.t)
  
  constant const_MAX: Int32.t = (2147483647: Int32.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: Int32.t) (r: Int32.t) (return (x: Int32.t)) = {[@expl:test_sub requires] Int32.to_int l
        - Int32.to_int r
      >= Int32.to_int const_MIN
    /\ Int32.to_int l - Int32.to_int r <= Int32.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int32.sub {l} {r} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int32.t = Any.any_l () | & l: Int32.t = l | & r: Int32.t = r ])
    [ return (result: Int32.t) -> {[@expl:test_sub ensures] Int32.to_int result = Int32.to_int l - Int32.to_int r}
      (! return {result}) ]
end
module M_i32__test_sub_bw
  use creusot.int.Int32BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int32BW.t = (2147483648: Int32BW.t)
  
  constant const_MAX: Int32BW.t = (2147483647: Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: Int32BW.t) (r: Int32BW.t) (return (x: Int32BW.t)) =
    {[@expl:test_sub_bw requires] Int32BW.to_int l - Int32BW.to_int r >= Int32BW.to_int const_MIN
    /\ Int32BW.to_int l - Int32BW.to_int r <= Int32BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.sub {l} {r} (fun (_ret: Int32BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int32BW.t = Any.any_l () | & l: Int32BW.t = l | & r: Int32BW.t = r ])
    [ return (result: Int32BW.t) -> {[@expl:test_sub_bw ensures] Int32BW.to_int result
      = Int32BW.to_int l - Int32BW.to_int r}
      (! return {result}) ]
end
module M_i32__test_mul
  use creusot.int.Int32
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int32.t = (-2147483648: Int32.t)
  
  constant const_MAX: Int32.t = (2147483647: Int32.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: Int32.t) (r: Int32.t) (return (x: Int32.t)) = {[@expl:test_mul requires] Int32.to_int l
        * Int32.to_int r
      >= Int32.to_int const_MIN
    /\ Int32.to_int l * Int32.to_int r <= Int32.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int32.mul {l} {r} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int32.t = Any.any_l () | & l: Int32.t = l | & r: Int32.t = r ])
    [ return (result: Int32.t) -> {[@expl:test_mul ensures] Int32.to_int result = Int32.to_int l * Int32.to_int r}
      (! return {result}) ]
end
module M_i32__test_mul_bw
  use creusot.int.Int32BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int32BW.t = (2147483648: Int32BW.t)
  
  constant const_MAX: Int32BW.t = (2147483647: Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: Int32BW.t) (r: Int32BW.t) (return (x: Int32BW.t)) =
    {[@expl:test_mul_bw requires] Int32BW.to_int l * Int32BW.to_int r >= Int32BW.to_int const_MIN
    /\ Int32BW.to_int l * Int32BW.to_int r <= Int32BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.mul {l} {r} (fun (_ret: Int32BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int32BW.t = Any.any_l () | & l: Int32BW.t = l | & r: Int32BW.t = r ])
    [ return (result: Int32BW.t) -> {[@expl:test_mul_bw ensures] Int32BW.to_int result
      = Int32BW.to_int l * Int32BW.to_int r}
      (! return {result}) ]
end
module M_i32__test_div
  use creusot.int.Int32
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int32.t = (-2147483648: Int32.t)
  
  constant const_MAX: Int32.t = (2147483647: Int32.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: Int32.t) (r: Int32.t) (return (x: Int32.t)) = {[@expl:test_div requires #0] Int32.to_int r <> 0}
    {[@expl:test_div requires #1] Int.div (Int32.to_int l) (Int32.to_int r) >= Int32.to_int const_MIN
    /\ Int.div (Int32.to_int l) (Int32.to_int r) <= Int32.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int32.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (-1: Int32.t) ] s1
      | s1 = [ &_10 <- _6 = (-2147483648: Int32.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int32.div {_6} {_7} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int32.t = Any.any_l ()
    | & l: Int32.t = l
    | & r: Int32.t = r
    | & _6: Int32.t = Any.any_l ()
    | & _7: Int32.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int32.t) -> {[@expl:test_div ensures] Int32.to_int result
      = Int.div (Int32.to_int l) (Int32.to_int r)}
      (! return {result}) ]
end
module M_i32__test_div_bw
  use creusot.int.Int32BW
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int32BW.t = (2147483648: Int32BW.t)
  
  constant const_MAX: Int32BW.t = (2147483647: Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: Int32BW.t) (r: Int32BW.t) (return (x: Int32BW.t)) =
    {[@expl:test_div_bw requires #0] Int32BW.to_int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (Int32BW.to_int l) (Int32BW.to_int r) >= Int32BW.to_int const_MIN
    /\ Int.div (Int32BW.to_int l) (Int32BW.to_int r) <= Int32BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int32BW.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (4294967295: Int32BW.t) ] s1
      | s1 = [ &_10 <- _6 = (2147483648: Int32BW.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int32BW.div {_6} {_7} (fun (_ret: Int32BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int32BW.t = Any.any_l ()
    | & l: Int32BW.t = l
    | & r: Int32BW.t = r
    | & _6: Int32BW.t = Any.any_l ()
    | & _7: Int32BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int32BW.t) -> {[@expl:test_div_bw ensures] Int32BW.to_int result
      = Int.div (Int32BW.to_int l) (Int32BW.to_int r)}
      (! return {result}) ]
end
module M_i32__test_from_bool
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type tup2_ref_i32_ref_i32 = { f0: Int32.t; f1: Int32.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int32.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () | & b: Int32.t = Any.any_l () ]
        [ _const_ret (_const: Int32.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int32.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () | & b: Int32.t = Any.any_l () ]
        [ _const_ret (_const: Int32.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int32.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int32.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i32_ref_i32 = Any.any_l ()
    | & left_val: Int32.t = Any.any_l ()
    | & right_val: Int32.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int32.t = Any.any_l ()
    | & _21: Int32.t = Any.any_l ()
    | & _24: tup2_ref_i32_ref_i32 = Any.any_l ()
    | & left_val'0: Int32.t = Any.any_l ()
    | & right_val'0: Int32.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int32.t = Any.any_l ()
    | & _41: Int32.t = Any.any_l ()
    | & _44: Int32.t = Any.any_l ()
    | & _45: Int32.t = Any.any_l ()
    | & _46: Int32.t = Any.any_l ()
    | & _47: Int32.t = Any.any_l () ])
    [ return (result: Int32.t) -> {[@expl:test_from_bool ensures] result = Int32.of_bool b} (! return {result}) ]
end
module M_i32__test_from_bool_bw
  use creusot.int.Int32BW
  use creusot.prelude.Any
  
  type tup2_ref_i32_ref_i32 = { f0: Int32BW.t; f1: Int32BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: Int32BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int32BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32BW.t = Any.any_l () | & b: Int32BW.t = Any.any_l () ]
        [ _const_ret (_const: Int32BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32BW.t = Any.any_l () ] [ _const_ret (_const: Int32BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int32BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32BW.t = Any.any_l () | & b: Int32BW.t = Any.any_l () ]
        [ _const_ret (_const: Int32BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int32BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32BW.t = Any.any_l () ] [ _const_ret (_const: Int32BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int32BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int32BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i32_ref_i32 = Any.any_l ()
    | & left_val: Int32BW.t = Any.any_l ()
    | & right_val: Int32BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int32BW.t = Any.any_l ()
    | & _21: Int32BW.t = Any.any_l ()
    | & _24: tup2_ref_i32_ref_i32 = Any.any_l ()
    | & left_val'0: Int32BW.t = Any.any_l ()
    | & right_val'0: Int32BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int32BW.t = Any.any_l ()
    | & _41: Int32BW.t = Any.any_l ()
    | & _44: Int32BW.t = Any.any_l ()
    | & _45: Int32BW.t = Any.any_l ()
    | & _46: Int32BW.t = Any.any_l ()
    | & _47: Int32BW.t = Any.any_l () ])
    [ return (result: Int32BW.t) -> {[@expl:test_from_bool_bw ensures] result = Int32BW.of_bool b} (! return {result}) ]
end
module M_i32__test_shl
  use creusot.int.Int32
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: Int32.t) (return (x: Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int32.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int32.t = Any.any_l () | & n: Int32.t = n ])
    [ return (result: Int32.t) -> {[@expl:test_shl ensures #0] result = Int32.lsl n (Int32.t'int (3: Int32.t))}
      {[@expl:test_shl ensures #1] result = Int32.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i32__test_shl_bw
  use creusot.int.Int32BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: Int32BW.t) (return (x: Int32BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int32BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int32BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int32BW.t = Any.any_l () | & n: Int32BW.t = n ])
    [ return (result: Int32BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = Int32BW.lsl n (Int32BW.t'int (3: Int32BW.t))}
      {[@expl:test_shl_bw ensures #1] result = Int32BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i32__test_shr
  use creusot.int.Int32
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: Int32.t) (return (x: Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int32.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int32.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int32.t = Any.any_l () | & n: Int32.t = n ])
    [ return (result: Int32.t) -> {[@expl:test_shr ensures #0] result = Int32.shr n (Int32.t'int (3: Int32.t))}
      {[@expl:test_shr ensures #1] result = Int32.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i32__test_shr_bw
  use creusot.int.Int32BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: Int32BW.t) (return (x: Int32BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int32BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int32BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int32BW.t = Any.any_l () | & n: Int32BW.t = n ])
    [ return (result: Int32BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = Int32BW.shr n (Int32BW.t'int (3: Int32BW.t))}
      {[@expl:test_shr_bw ensures #1] result = Int32BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u64__test_add
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: UInt64.t) (r: UInt64.t) (return (x: UInt64.t)) = {[@expl:test_add requires] UInt64.t'int l
        + UInt64.t'int r
      >= UInt64.t'int const_MIN
    /\ UInt64.t'int l + UInt64.t'int r <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.add {l} {r} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & l: UInt64.t = l | & r: UInt64.t = r ])
    [ return (result: UInt64.t) -> {[@expl:test_add ensures] UInt64.t'int result = UInt64.t'int l + UInt64.t'int r}
      (! return {result}) ]
end
module M_u64__test_add_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant const_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: UInt64BW.t) (r: UInt64BW.t) (return (x: UInt64BW.t)) =
    {[@expl:test_add_bw requires] UInt64BW.t'int l + UInt64BW.t'int r >= UInt64BW.t'int const_MIN
    /\ UInt64BW.t'int l + UInt64BW.t'int r <= UInt64BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.add {l} {r} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l () | & l: UInt64BW.t = l | & r: UInt64BW.t = r ])
    [ return (result: UInt64BW.t) -> {[@expl:test_add_bw ensures] UInt64BW.t'int result
      = UInt64BW.t'int l + UInt64BW.t'int r}
      (! return {result}) ]
end
module M_u64__test_sub
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: UInt64.t) (r: UInt64.t) (return (x: UInt64.t)) = {[@expl:test_sub requires] UInt64.t'int l
        - UInt64.t'int r
      >= UInt64.t'int const_MIN
    /\ UInt64.t'int l - UInt64.t'int r <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.sub {l} {r} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & l: UInt64.t = l | & r: UInt64.t = r ])
    [ return (result: UInt64.t) -> {[@expl:test_sub ensures] UInt64.t'int result = UInt64.t'int l - UInt64.t'int r}
      (! return {result}) ]
end
module M_u64__test_sub_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant const_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: UInt64BW.t) (r: UInt64BW.t) (return (x: UInt64BW.t)) =
    {[@expl:test_sub_bw requires] UInt64BW.t'int l - UInt64BW.t'int r >= UInt64BW.t'int const_MIN
    /\ UInt64BW.t'int l - UInt64BW.t'int r <= UInt64BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.sub {l} {r} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l () | & l: UInt64BW.t = l | & r: UInt64BW.t = r ])
    [ return (result: UInt64BW.t) -> {[@expl:test_sub_bw ensures] UInt64BW.t'int result
      = UInt64BW.t'int l - UInt64BW.t'int r}
      (! return {result}) ]
end
module M_u64__test_mul
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: UInt64.t) (r: UInt64.t) (return (x: UInt64.t)) = {[@expl:test_mul requires] UInt64.t'int l
        * UInt64.t'int r
      >= UInt64.t'int const_MIN
    /\ UInt64.t'int l * UInt64.t'int r <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.mul {l} {r} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & l: UInt64.t = l | & r: UInt64.t = r ])
    [ return (result: UInt64.t) -> {[@expl:test_mul ensures] UInt64.t'int result = UInt64.t'int l * UInt64.t'int r}
      (! return {result}) ]
end
module M_u64__test_mul_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant const_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: UInt64BW.t) (r: UInt64BW.t) (return (x: UInt64BW.t)) =
    {[@expl:test_mul_bw requires] UInt64BW.t'int l * UInt64BW.t'int r >= UInt64BW.t'int const_MIN
    /\ UInt64BW.t'int l * UInt64BW.t'int r <= UInt64BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.mul {l} {r} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l () | & l: UInt64BW.t = l | & r: UInt64BW.t = r ])
    [ return (result: UInt64BW.t) -> {[@expl:test_mul_bw ensures] UInt64BW.t'int result
      = UInt64BW.t'int l * UInt64BW.t'int r}
      (! return {result}) ]
end
module M_u64__test_div
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: UInt64.t) (r: UInt64.t) (return (x: UInt64.t)) = {[@expl:test_div requires #0] UInt64.t'int r
    <> 0}
    {[@expl:test_div requires #1] Int.div (UInt64.t'int l) (UInt64.t'int r) >= UInt64.t'int const_MIN
    /\ Int.div (UInt64.t'int l) (UInt64.t'int r) <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt64.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt64.div {l} {_7} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & l: UInt64.t = l
    | & r: UInt64.t = r
    | & _7: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:test_div ensures] UInt64.t'int result
      = Int.div (UInt64.t'int l) (UInt64.t'int r)}
      (! return {result}) ]
end
module M_u64__test_div_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant const_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: UInt64BW.t) (r: UInt64BW.t) (return (x: UInt64BW.t)) =
    {[@expl:test_div_bw requires #0] UInt64BW.t'int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (UInt64BW.t'int l) (UInt64BW.t'int r) >= UInt64BW.t'int const_MIN
    /\ Int.div (UInt64BW.t'int l) (UInt64BW.t'int r) <= UInt64BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt64BW.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt64BW.div {l} {_7} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l ()
    | & l: UInt64BW.t = l
    | & r: UInt64BW.t = r
    | & _7: UInt64BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt64BW.t) -> {[@expl:test_div_bw ensures] UInt64BW.t'int result
      = Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)}
      (! return {result}) ]
end
module M_u64__test_from_bool
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type tup2_ref_u64_ref_u64 = { f0: UInt64.t; f1: UInt64.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt64.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () | & b: UInt64.t = Any.any_l () ]
        [ _const_ret (_const: UInt64.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt64.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () ] [ _const_ret (_const: UInt64.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt64.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () | & b: UInt64.t = Any.any_l () ]
        [ _const_ret (_const: UInt64.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt64.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () ] [ _const_ret (_const: UInt64.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt64.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val: UInt64.t = Any.any_l ()
    | & right_val: UInt64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt64.t = Any.any_l ()
    | & _21: UInt64.t = Any.any_l ()
    | & _24: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val'0: UInt64.t = Any.any_l ()
    | & right_val'0: UInt64.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt64.t = Any.any_l ()
    | & _41: UInt64.t = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _45: UInt64.t = Any.any_l ()
    | & _46: UInt64.t = Any.any_l ()
    | & _47: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:test_from_bool ensures] result = UInt64.of_bool b} (! return {result}) ]
end
module M_u64__test_from_bool_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  
  type tup2_ref_u64_ref_u64 = { f0: UInt64BW.t; f1: UInt64BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: UInt64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt64BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () | & b: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt64BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () | & b: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt64BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt64BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val: UInt64BW.t = Any.any_l ()
    | & right_val: UInt64BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: UInt64BW.t = Any.any_l ()
    | & _24: tup2_ref_u64_ref_u64 = Any.any_l ()
    | & left_val'0: UInt64BW.t = Any.any_l ()
    | & right_val'0: UInt64BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt64BW.t = Any.any_l ()
    | & _41: UInt64BW.t = Any.any_l ()
    | & _44: UInt64BW.t = Any.any_l ()
    | & _45: UInt64BW.t = Any.any_l ()
    | & _46: UInt64BW.t = Any.any_l ()
    | & _47: UInt64BW.t = Any.any_l () ])
    [ return (result: UInt64BW.t) -> {[@expl:test_from_bool_bw ensures] result = UInt64BW.of_bool b}
      (! return {result}) ]
end
module M_u64__test_shl
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt64.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () | & n: UInt64.t = n ])
    [ return (result: UInt64.t) -> {[@expl:test_shl ensures #0] result = UInt64.lsl n (UInt64.t'int (3: UInt64.t))}
      {[@expl:test_shl ensures #1] result = UInt64.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u64__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: UInt64BW.t) (return (x: UInt64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt64BW.t = Any.any_l () | & n: UInt64BW.t = n ])
    [ return (result: UInt64BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = UInt64BW.lsl n (UInt64BW.t'int (3: UInt64BW.t))}
      {[@expl:test_shl_bw ensures #1] result = UInt64BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u64__test_shr
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt64.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () | & n: UInt64.t = n ])
    [ return (result: UInt64.t) -> {[@expl:test_shr ensures #0] result = UInt64.shr n (UInt64.t'int (3: UInt64.t))}
      {[@expl:test_shr ensures #1] result = UInt64.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u64__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: UInt64BW.t) (return (x: UInt64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt64BW.t = Any.any_l () | & n: UInt64BW.t = n ])
    [ return (result: UInt64BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = UInt64BW.shr n (UInt64BW.t'int (3: UInt64BW.t))}
      {[@expl:test_shr_bw ensures #1] result = UInt64BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i64__test_add
  use creusot.int.Int64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: Int64.t) (r: Int64.t) (return (x: Int64.t)) = {[@expl:test_add requires] Int64.to_int l
        + Int64.to_int r
      >= Int64.to_int const_MIN
    /\ Int64.to_int l + Int64.to_int r <= Int64.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.add {l} {r} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & l: Int64.t = l | & r: Int64.t = r ])
    [ return (result: Int64.t) -> {[@expl:test_add ensures] Int64.to_int result = Int64.to_int l + Int64.to_int r}
      (! return {result}) ]
end
module M_i64__test_add_bw
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant const_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: Int64BW.t) (r: Int64BW.t) (return (x: Int64BW.t)) =
    {[@expl:test_add_bw requires] Int64BW.to_int l + Int64BW.to_int r >= Int64BW.to_int const_MIN
    /\ Int64BW.to_int l + Int64BW.to_int r <= Int64BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.add {l} {r} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l () | & l: Int64BW.t = l | & r: Int64BW.t = r ])
    [ return (result: Int64BW.t) -> {[@expl:test_add_bw ensures] Int64BW.to_int result
      = Int64BW.to_int l + Int64BW.to_int r}
      (! return {result}) ]
end
module M_i64__test_sub
  use creusot.int.Int64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: Int64.t) (r: Int64.t) (return (x: Int64.t)) = {[@expl:test_sub requires] Int64.to_int l
        - Int64.to_int r
      >= Int64.to_int const_MIN
    /\ Int64.to_int l - Int64.to_int r <= Int64.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.sub {l} {r} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & l: Int64.t = l | & r: Int64.t = r ])
    [ return (result: Int64.t) -> {[@expl:test_sub ensures] Int64.to_int result = Int64.to_int l - Int64.to_int r}
      (! return {result}) ]
end
module M_i64__test_sub_bw
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant const_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: Int64BW.t) (r: Int64BW.t) (return (x: Int64BW.t)) =
    {[@expl:test_sub_bw requires] Int64BW.to_int l - Int64BW.to_int r >= Int64BW.to_int const_MIN
    /\ Int64BW.to_int l - Int64BW.to_int r <= Int64BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.sub {l} {r} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l () | & l: Int64BW.t = l | & r: Int64BW.t = r ])
    [ return (result: Int64BW.t) -> {[@expl:test_sub_bw ensures] Int64BW.to_int result
      = Int64BW.to_int l - Int64BW.to_int r}
      (! return {result}) ]
end
module M_i64__test_mul
  use creusot.int.Int64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: Int64.t) (r: Int64.t) (return (x: Int64.t)) = {[@expl:test_mul requires] Int64.to_int l
        * Int64.to_int r
      >= Int64.to_int const_MIN
    /\ Int64.to_int l * Int64.to_int r <= Int64.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.mul {l} {r} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & l: Int64.t = l | & r: Int64.t = r ])
    [ return (result: Int64.t) -> {[@expl:test_mul ensures] Int64.to_int result = Int64.to_int l * Int64.to_int r}
      (! return {result}) ]
end
module M_i64__test_mul_bw
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant const_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: Int64BW.t) (r: Int64BW.t) (return (x: Int64BW.t)) =
    {[@expl:test_mul_bw requires] Int64BW.to_int l * Int64BW.to_int r >= Int64BW.to_int const_MIN
    /\ Int64BW.to_int l * Int64BW.to_int r <= Int64BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.mul {l} {r} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l () | & l: Int64BW.t = l | & r: Int64BW.t = r ])
    [ return (result: Int64BW.t) -> {[@expl:test_mul_bw ensures] Int64BW.to_int result
      = Int64BW.to_int l * Int64BW.to_int r}
      (! return {result}) ]
end
module M_i64__test_div
  use creusot.int.Int64
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: Int64.t) (r: Int64.t) (return (x: Int64.t)) = {[@expl:test_div requires #0] Int64.to_int r <> 0}
    {[@expl:test_div requires #1] Int.div (Int64.to_int l) (Int64.to_int r) >= Int64.to_int const_MIN
    /\ Int.div (Int64.to_int l) (Int64.to_int r) <= Int64.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int64.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (-1: Int64.t) ] s1
      | s1 = [ &_10 <- _6 = (-9223372036854775808: Int64.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int64.div {_6} {_7} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l ()
    | & l: Int64.t = l
    | & r: Int64.t = r
    | & _6: Int64.t = Any.any_l ()
    | & _7: Int64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:test_div ensures] Int64.to_int result
      = Int.div (Int64.to_int l) (Int64.to_int r)}
      (! return {result}) ]
end
module M_i64__test_div_bw
  use creusot.int.Int64BW
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant const_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: Int64BW.t) (r: Int64BW.t) (return (x: Int64BW.t)) =
    {[@expl:test_div_bw requires #0] Int64BW.to_int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (Int64BW.to_int l) (Int64BW.to_int r) >= Int64BW.to_int const_MIN
    /\ Int.div (Int64BW.to_int l) (Int64BW.to_int r) <= Int64BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int64BW.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (18446744073709551615: Int64BW.t) ] s1
      | s1 = [ &_10 <- _6 = (9223372036854775808: Int64BW.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int64BW.div {_6} {_7} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l ()
    | & l: Int64BW.t = l
    | & r: Int64BW.t = r
    | & _6: Int64BW.t = Any.any_l ()
    | & _7: Int64BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int64BW.t) -> {[@expl:test_div_bw ensures] Int64BW.to_int result
      = Int.div (Int64BW.to_int l) (Int64BW.to_int r)}
      (! return {result}) ]
end
module M_i64__test_from_bool
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type tup2_ref_i64_ref_i64 = { f0: Int64.t; f1: Int64.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int64.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64.t = Any.any_l () | & b: Int64.t = Any.any_l () ]
        [ _const_ret (_const: Int64.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int64.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64.t = Any.any_l () ] [ _const_ret (_const: Int64.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int64.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64.t = Any.any_l () | & b: Int64.t = Any.any_l () ]
        [ _const_ret (_const: Int64.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int64.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64.t = Any.any_l () ] [ _const_ret (_const: Int64.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int64.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int64.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i64_ref_i64 = Any.any_l ()
    | & left_val: Int64.t = Any.any_l ()
    | & right_val: Int64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int64.t = Any.any_l ()
    | & _21: Int64.t = Any.any_l ()
    | & _24: tup2_ref_i64_ref_i64 = Any.any_l ()
    | & left_val'0: Int64.t = Any.any_l ()
    | & right_val'0: Int64.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int64.t = Any.any_l ()
    | & _41: Int64.t = Any.any_l ()
    | & _44: Int64.t = Any.any_l ()
    | & _45: Int64.t = Any.any_l ()
    | & _46: Int64.t = Any.any_l ()
    | & _47: Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:test_from_bool ensures] result = Int64.of_bool b} (! return {result}) ]
end
module M_i64__test_from_bool_bw
  use creusot.int.Int64BW
  use creusot.prelude.Any
  
  type tup2_ref_i64_ref_i64 = { f0: Int64BW.t; f1: Int64BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: Int64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int64BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () | & b: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int64BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () | & b: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int64BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int64BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i64_ref_i64 = Any.any_l ()
    | & left_val: Int64BW.t = Any.any_l ()
    | & right_val: Int64BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int64BW.t = Any.any_l ()
    | & _21: Int64BW.t = Any.any_l ()
    | & _24: tup2_ref_i64_ref_i64 = Any.any_l ()
    | & left_val'0: Int64BW.t = Any.any_l ()
    | & right_val'0: Int64BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int64BW.t = Any.any_l ()
    | & _41: Int64BW.t = Any.any_l ()
    | & _44: Int64BW.t = Any.any_l ()
    | & _45: Int64BW.t = Any.any_l ()
    | & _46: Int64BW.t = Any.any_l ()
    | & _47: Int64BW.t = Any.any_l () ])
    [ return (result: Int64BW.t) -> {[@expl:test_from_bool_bw ensures] result = Int64BW.of_bool b} (! return {result}) ]
end
module M_i64__test_shl
  use creusot.int.Int32
  use creusot.int.Int64
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int64.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int64.t = Any.any_l () | & n: Int64.t = n ])
    [ return (result: Int64.t) -> {[@expl:test_shl ensures #0] result = Int64.lsl n (Int64.t'int (3: Int64.t))}
      {[@expl:test_shl ensures #1] result = Int64.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i64__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: Int64BW.t) (return (x: Int64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int64BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int64BW.t = Any.any_l () | & n: Int64BW.t = n ])
    [ return (result: Int64BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = Int64BW.lsl n (Int64BW.t'int (3: Int64BW.t))}
      {[@expl:test_shl_bw ensures #1] result = Int64BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i64__test_shr
  use creusot.int.Int32
  use creusot.int.Int64
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int64.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int64.t = Any.any_l () | & n: Int64.t = n ])
    [ return (result: Int64.t) -> {[@expl:test_shr ensures #0] result = Int64.shr n (Int64.t'int (3: Int64.t))}
      {[@expl:test_shr ensures #1] result = Int64.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i64__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: Int64BW.t) (return (x: Int64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int64BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int64BW.t = Any.any_l () | & n: Int64BW.t = n ])
    [ return (result: Int64BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = Int64BW.shr n (Int64BW.t'int (3: Int64BW.t))}
      {[@expl:test_shr_bw ensures #1] result = Int64BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u128__test_add
  use creusot.int.UInt128
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt128.t = (0: UInt128.t)
  
  constant const_MAX: UInt128.t = (340282366920938463463374607431768211455: UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: UInt128.t) (r: UInt128.t) (return (x: UInt128.t)) = {[@expl:test_add requires] UInt128.t'int l
        + UInt128.t'int r
      >= UInt128.t'int const_MIN
    /\ UInt128.t'int l + UInt128.t'int r <= UInt128.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.add {l} {r} (fun (_ret: UInt128.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt128.t = Any.any_l () | & l: UInt128.t = l | & r: UInt128.t = r ])
    [ return (result: UInt128.t) -> {[@expl:test_add ensures] UInt128.t'int result = UInt128.t'int l + UInt128.t'int r}
      (! return {result}) ]
end
module M_u128__test_add_bw
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt128BW.t = (0: UInt128BW.t)
  
  constant const_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: UInt128BW.t) (r: UInt128BW.t) (return (x: UInt128BW.t)) =
    {[@expl:test_add_bw requires] UInt128BW.t'int l + UInt128BW.t'int r >= UInt128BW.t'int const_MIN
    /\ UInt128BW.t'int l + UInt128BW.t'int r <= UInt128BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128BW.add {l} {r} (fun (_ret: UInt128BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt128BW.t = Any.any_l () | & l: UInt128BW.t = l | & r: UInt128BW.t = r ])
    [ return (result: UInt128BW.t) -> {[@expl:test_add_bw ensures] UInt128BW.t'int result
      = UInt128BW.t'int l + UInt128BW.t'int r}
      (! return {result}) ]
end
module M_u128__test_sub
  use creusot.int.UInt128
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt128.t = (0: UInt128.t)
  
  constant const_MAX: UInt128.t = (340282366920938463463374607431768211455: UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: UInt128.t) (r: UInt128.t) (return (x: UInt128.t)) = {[@expl:test_sub requires] UInt128.t'int l
        - UInt128.t'int r
      >= UInt128.t'int const_MIN
    /\ UInt128.t'int l - UInt128.t'int r <= UInt128.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.sub {l} {r} (fun (_ret: UInt128.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt128.t = Any.any_l () | & l: UInt128.t = l | & r: UInt128.t = r ])
    [ return (result: UInt128.t) -> {[@expl:test_sub ensures] UInt128.t'int result = UInt128.t'int l - UInt128.t'int r}
      (! return {result}) ]
end
module M_u128__test_sub_bw
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt128BW.t = (0: UInt128BW.t)
  
  constant const_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: UInt128BW.t) (r: UInt128BW.t) (return (x: UInt128BW.t)) =
    {[@expl:test_sub_bw requires] UInt128BW.t'int l - UInt128BW.t'int r >= UInt128BW.t'int const_MIN
    /\ UInt128BW.t'int l - UInt128BW.t'int r <= UInt128BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128BW.sub {l} {r} (fun (_ret: UInt128BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt128BW.t = Any.any_l () | & l: UInt128BW.t = l | & r: UInt128BW.t = r ])
    [ return (result: UInt128BW.t) -> {[@expl:test_sub_bw ensures] UInt128BW.t'int result
      = UInt128BW.t'int l - UInt128BW.t'int r}
      (! return {result}) ]
end
module M_u128__test_mul
  use creusot.int.UInt128
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt128.t = (0: UInt128.t)
  
  constant const_MAX: UInt128.t = (340282366920938463463374607431768211455: UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: UInt128.t) (r: UInt128.t) (return (x: UInt128.t)) = {[@expl:test_mul requires] UInt128.t'int l
        * UInt128.t'int r
      >= UInt128.t'int const_MIN
    /\ UInt128.t'int l * UInt128.t'int r <= UInt128.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.mul {l} {r} (fun (_ret: UInt128.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt128.t = Any.any_l () | & l: UInt128.t = l | & r: UInt128.t = r ])
    [ return (result: UInt128.t) -> {[@expl:test_mul ensures] UInt128.t'int result = UInt128.t'int l * UInt128.t'int r}
      (! return {result}) ]
end
module M_u128__test_mul_bw
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt128BW.t = (0: UInt128BW.t)
  
  constant const_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: UInt128BW.t) (r: UInt128BW.t) (return (x: UInt128BW.t)) =
    {[@expl:test_mul_bw requires] UInt128BW.t'int l * UInt128BW.t'int r >= UInt128BW.t'int const_MIN
    /\ UInt128BW.t'int l * UInt128BW.t'int r <= UInt128BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128BW.mul {l} {r} (fun (_ret: UInt128BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt128BW.t = Any.any_l () | & l: UInt128BW.t = l | & r: UInt128BW.t = r ])
    [ return (result: UInt128BW.t) -> {[@expl:test_mul_bw ensures] UInt128BW.t'int result
      = UInt128BW.t'int l * UInt128BW.t'int r}
      (! return {result}) ]
end
module M_u128__test_div
  use creusot.int.UInt128
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt128.t = (0: UInt128.t)
  
  constant const_MAX: UInt128.t = (340282366920938463463374607431768211455: UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: UInt128.t) (r: UInt128.t) (return (x: UInt128.t)) = {[@expl:test_div requires #0] UInt128.t'int r
    <> 0}
    {[@expl:test_div requires #1] Int.div (UInt128.t'int l) (UInt128.t'int r) >= UInt128.t'int const_MIN
    /\ Int.div (UInt128.t'int l) (UInt128.t'int r) <= UInt128.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt128.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt128.div {l} {_7} (fun (_ret: UInt128.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt128.t = Any.any_l ()
    | & l: UInt128.t = l
    | & r: UInt128.t = r
    | & _7: UInt128.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt128.t) -> {[@expl:test_div ensures] UInt128.t'int result
      = Int.div (UInt128.t'int l) (UInt128.t'int r)}
      (! return {result}) ]
end
module M_u128__test_div_bw
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt128BW.t = (0: UInt128BW.t)
  
  constant const_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: UInt128BW.t) (r: UInt128BW.t) (return (x: UInt128BW.t)) =
    {[@expl:test_div_bw requires #0] UInt128BW.t'int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (UInt128BW.t'int l) (UInt128BW.t'int r) >= UInt128BW.t'int const_MIN
    /\ Int.div (UInt128BW.t'int l) (UInt128BW.t'int r) <= UInt128BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt128BW.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt128BW.div {l} {_7} (fun (_ret: UInt128BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt128BW.t = Any.any_l ()
    | & l: UInt128BW.t = l
    | & r: UInt128BW.t = r
    | & _7: UInt128BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt128BW.t) -> {[@expl:test_div_bw ensures] UInt128BW.t'int result
      = Int.div (UInt128BW.t'int l) (UInt128BW.t'int r)}
      (! return {result}) ]
end
module M_u128__test_from_bool
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type tup2_ref_u128_ref_u128 = { f0: UInt128.t; f1: UInt128.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt128.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128.t = Any.any_l () | & b: UInt128.t = Any.any_l () ]
        [ _const_ret (_const: UInt128.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt128.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128.t = Any.any_l () ] [ _const_ret (_const: UInt128.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt128.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128.t = Any.any_l () | & b: UInt128.t = Any.any_l () ]
        [ _const_ret (_const: UInt128.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt128.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128.t = Any.any_l () ] [ _const_ret (_const: UInt128.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt128.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt128.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val: UInt128.t = Any.any_l ()
    | & right_val: UInt128.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt128.t = Any.any_l ()
    | & _21: UInt128.t = Any.any_l ()
    | & _24: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val'0: UInt128.t = Any.any_l ()
    | & right_val'0: UInt128.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt128.t = Any.any_l ()
    | & _41: UInt128.t = Any.any_l ()
    | & _44: UInt128.t = Any.any_l ()
    | & _45: UInt128.t = Any.any_l ()
    | & _46: UInt128.t = Any.any_l ()
    | & _47: UInt128.t = Any.any_l () ])
    [ return (result: UInt128.t) -> {[@expl:test_from_bool ensures] result = UInt128.of_bool b} (! return {result}) ]
end
module M_u128__test_from_bool_bw
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  
  type tup2_ref_u128_ref_u128 = { f0: UInt128BW.t; f1: UInt128BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: UInt128BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt128BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () | & b: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () ] [ _const_ret (_const: UInt128BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt128BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () | & b: UInt128BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt128BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt128BW.t = Any.any_l () ] [ _const_ret (_const: UInt128BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt128BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt128BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val: UInt128BW.t = Any.any_l ()
    | & right_val: UInt128BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt128BW.t = Any.any_l ()
    | & _21: UInt128BW.t = Any.any_l ()
    | & _24: tup2_ref_u128_ref_u128 = Any.any_l ()
    | & left_val'0: UInt128BW.t = Any.any_l ()
    | & right_val'0: UInt128BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt128BW.t = Any.any_l ()
    | & _41: UInt128BW.t = Any.any_l ()
    | & _44: UInt128BW.t = Any.any_l ()
    | & _45: UInt128BW.t = Any.any_l ()
    | & _46: UInt128BW.t = Any.any_l ()
    | & _47: UInt128BW.t = Any.any_l () ])
    [ return (result: UInt128BW.t) -> {[@expl:test_from_bool_bw ensures] result = UInt128BW.of_bool b}
      (! return {result}) ]
end
module M_u128__test_shl
  use creusot.int.Int32
  use creusot.int.UInt128
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: UInt128.t) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt128.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt128.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt128.t = Any.any_l () | & n: UInt128.t = n ])
    [ return (result: UInt128.t) -> {[@expl:test_shl ensures #0] result = UInt128.lsl n (UInt128.t'int (3: UInt128.t))}
      {[@expl:test_shl ensures #1] result = UInt128.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u128__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: UInt128BW.t) (return (x: UInt128BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt128BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt128BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt128BW.t = Any.any_l () | & n: UInt128BW.t = n ])
    [ return (result: UInt128BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = UInt128BW.lsl n (UInt128BW.t'int (3: UInt128BW.t))}
      {[@expl:test_shl_bw ensures #1] result = UInt128BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_u128__test_shr
  use creusot.int.Int32
  use creusot.int.UInt128
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: UInt128.t) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt128.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt128.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt128.t = Any.any_l () | & n: UInt128.t = n ])
    [ return (result: UInt128.t) -> {[@expl:test_shr ensures #0] result = UInt128.shr n (UInt128.t'int (3: UInt128.t))}
      {[@expl:test_shr ensures #1] result = UInt128.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_u128__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: UInt128BW.t) (return (x: UInt128BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt128BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt128BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt128BW.t = Any.any_l () | & n: UInt128BW.t = n ])
    [ return (result: UInt128BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = UInt128BW.shr n (UInt128BW.t'int (3: UInt128BW.t))}
      {[@expl:test_shr_bw ensures #1] result = UInt128BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i128__test_add
  use creusot.int.Int128
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  constant const_MAX: Int128.t = (170141183460469231731687303715884105727: Int128.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: Int128.t) (r: Int128.t) (return (x: Int128.t)) = {[@expl:test_add requires] Int128.to_int l
        + Int128.to_int r
      >= Int128.to_int const_MIN
    /\ Int128.to_int l + Int128.to_int r <= Int128.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.add {l} {r} (fun (_ret: Int128.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int128.t = Any.any_l () | & l: Int128.t = l | & r: Int128.t = r ])
    [ return (result: Int128.t) -> {[@expl:test_add ensures] Int128.to_int result = Int128.to_int l + Int128.to_int r}
      (! return {result}) ]
end
module M_i128__test_add_bw
  use creusot.int.Int128BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int128BW.t = (170141183460469231731687303715884105728: Int128BW.t)
  
  constant const_MAX: Int128BW.t = (170141183460469231731687303715884105727: Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: Int128BW.t) (r: Int128BW.t) (return (x: Int128BW.t)) =
    {[@expl:test_add_bw requires] Int128BW.to_int l + Int128BW.to_int r >= Int128BW.to_int const_MIN
    /\ Int128BW.to_int l + Int128BW.to_int r <= Int128BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.add {l} {r} (fun (_ret: Int128BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int128BW.t = Any.any_l () | & l: Int128BW.t = l | & r: Int128BW.t = r ])
    [ return (result: Int128BW.t) -> {[@expl:test_add_bw ensures] Int128BW.to_int result
      = Int128BW.to_int l + Int128BW.to_int r}
      (! return {result}) ]
end
module M_i128__test_sub
  use creusot.int.Int128
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  constant const_MAX: Int128.t = (170141183460469231731687303715884105727: Int128.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: Int128.t) (r: Int128.t) (return (x: Int128.t)) = {[@expl:test_sub requires] Int128.to_int l
        - Int128.to_int r
      >= Int128.to_int const_MIN
    /\ Int128.to_int l - Int128.to_int r <= Int128.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.sub {l} {r} (fun (_ret: Int128.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int128.t = Any.any_l () | & l: Int128.t = l | & r: Int128.t = r ])
    [ return (result: Int128.t) -> {[@expl:test_sub ensures] Int128.to_int result = Int128.to_int l - Int128.to_int r}
      (! return {result}) ]
end
module M_i128__test_sub_bw
  use creusot.int.Int128BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int128BW.t = (170141183460469231731687303715884105728: Int128BW.t)
  
  constant const_MAX: Int128BW.t = (170141183460469231731687303715884105727: Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: Int128BW.t) (r: Int128BW.t) (return (x: Int128BW.t)) =
    {[@expl:test_sub_bw requires] Int128BW.to_int l - Int128BW.to_int r >= Int128BW.to_int const_MIN
    /\ Int128BW.to_int l - Int128BW.to_int r <= Int128BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.sub {l} {r} (fun (_ret: Int128BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int128BW.t = Any.any_l () | & l: Int128BW.t = l | & r: Int128BW.t = r ])
    [ return (result: Int128BW.t) -> {[@expl:test_sub_bw ensures] Int128BW.to_int result
      = Int128BW.to_int l - Int128BW.to_int r}
      (! return {result}) ]
end
module M_i128__test_mul
  use creusot.int.Int128
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  constant const_MAX: Int128.t = (170141183460469231731687303715884105727: Int128.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: Int128.t) (r: Int128.t) (return (x: Int128.t)) = {[@expl:test_mul requires] Int128.to_int l
        * Int128.to_int r
      >= Int128.to_int const_MIN
    /\ Int128.to_int l * Int128.to_int r <= Int128.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.mul {l} {r} (fun (_ret: Int128.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int128.t = Any.any_l () | & l: Int128.t = l | & r: Int128.t = r ])
    [ return (result: Int128.t) -> {[@expl:test_mul ensures] Int128.to_int result = Int128.to_int l * Int128.to_int r}
      (! return {result}) ]
end
module M_i128__test_mul_bw
  use creusot.int.Int128BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int128BW.t = (170141183460469231731687303715884105728: Int128BW.t)
  
  constant const_MAX: Int128BW.t = (170141183460469231731687303715884105727: Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: Int128BW.t) (r: Int128BW.t) (return (x: Int128BW.t)) =
    {[@expl:test_mul_bw requires] Int128BW.to_int l * Int128BW.to_int r >= Int128BW.to_int const_MIN
    /\ Int128BW.to_int l * Int128BW.to_int r <= Int128BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.mul {l} {r} (fun (_ret: Int128BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int128BW.t = Any.any_l () | & l: Int128BW.t = l | & r: Int128BW.t = r ])
    [ return (result: Int128BW.t) -> {[@expl:test_mul_bw ensures] Int128BW.to_int result
      = Int128BW.to_int l * Int128BW.to_int r}
      (! return {result}) ]
end
module M_i128__test_div
  use creusot.int.Int128
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  constant const_MAX: Int128.t = (170141183460469231731687303715884105727: Int128.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: Int128.t) (r: Int128.t) (return (x: Int128.t)) = {[@expl:test_div requires #0] Int128.to_int r
    <> 0}
    {[@expl:test_div requires #1] Int.div (Int128.to_int l) (Int128.to_int r) >= Int128.to_int const_MIN
    /\ Int.div (Int128.to_int l) (Int128.to_int r) <= Int128.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int128.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (-1: Int128.t) ] s1
      | s1 = [ &_10 <- _6 = (-170141183460469231731687303715884105728: Int128.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int128.div {_6} {_7} (fun (_ret: Int128.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int128.t = Any.any_l ()
    | & l: Int128.t = l
    | & r: Int128.t = r
    | & _6: Int128.t = Any.any_l ()
    | & _7: Int128.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int128.t) -> {[@expl:test_div ensures] Int128.to_int result
      = Int.div (Int128.to_int l) (Int128.to_int r)}
      (! return {result}) ]
end
module M_i128__test_div_bw
  use creusot.int.Int128BW
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int128BW.t = (170141183460469231731687303715884105728: Int128BW.t)
  
  constant const_MAX: Int128BW.t = (170141183460469231731687303715884105727: Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: Int128BW.t) (r: Int128BW.t) (return (x: Int128BW.t)) =
    {[@expl:test_div_bw requires #0] Int128BW.to_int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (Int128BW.to_int l) (Int128BW.to_int r) >= Int128BW.to_int const_MIN
    /\ Int.div (Int128BW.to_int l) (Int128BW.to_int r) <= Int128BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int128BW.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (340282366920938463463374607431768211455: Int128BW.t) ] s1
      | s1 = [ &_10 <- _6 = (170141183460469231731687303715884105728: Int128BW.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int128BW.div {_6} {_7} (fun (_ret: Int128BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int128BW.t = Any.any_l ()
    | & l: Int128BW.t = l
    | & r: Int128BW.t = r
    | & _6: Int128BW.t = Any.any_l ()
    | & _7: Int128BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int128BW.t) -> {[@expl:test_div_bw ensures] Int128BW.to_int result
      = Int.div (Int128BW.to_int l) (Int128BW.to_int r)}
      (! return {result}) ]
end
module M_i128__test_from_bool
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type tup2_ref_i128_ref_i128 = { f0: Int128.t; f1: Int128.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int128.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128.t = Any.any_l () | & b: Int128.t = Any.any_l () ]
        [ _const_ret (_const: Int128.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int128.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128.t = Any.any_l () ] [ _const_ret (_const: Int128.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int128.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128.t = Any.any_l () | & b: Int128.t = Any.any_l () ]
        [ _const_ret (_const: Int128.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int128.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128.t = Any.any_l () ] [ _const_ret (_const: Int128.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int128.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int128.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i128_ref_i128 = Any.any_l ()
    | & left_val: Int128.t = Any.any_l ()
    | & right_val: Int128.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int128.t = Any.any_l ()
    | & _21: Int128.t = Any.any_l ()
    | & _24: tup2_ref_i128_ref_i128 = Any.any_l ()
    | & left_val'0: Int128.t = Any.any_l ()
    | & right_val'0: Int128.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int128.t = Any.any_l ()
    | & _41: Int128.t = Any.any_l ()
    | & _44: Int128.t = Any.any_l ()
    | & _45: Int128.t = Any.any_l ()
    | & _46: Int128.t = Any.any_l ()
    | & _47: Int128.t = Any.any_l () ])
    [ return (result: Int128.t) -> {[@expl:test_from_bool ensures] result = Int128.of_bool b} (! return {result}) ]
end
module M_i128__test_from_bool_bw
  use creusot.int.Int128BW
  use creusot.prelude.Any
  
  type tup2_ref_i128_ref_i128 = { f0: Int128BW.t; f1: Int128BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: Int128BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int128BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128BW.t = Any.any_l () | & b: Int128BW.t = Any.any_l () ]
        [ _const_ret (_const: Int128BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128BW.t = Any.any_l () ] [ _const_ret (_const: Int128BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int128BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128BW.t = Any.any_l () | & b: Int128BW.t = Any.any_l () ]
        [ _const_ret (_const: Int128BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int128BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int128BW.t = Any.any_l () ] [ _const_ret (_const: Int128BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int128BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int128BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_i128_ref_i128 = Any.any_l ()
    | & left_val: Int128BW.t = Any.any_l ()
    | & right_val: Int128BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int128BW.t = Any.any_l ()
    | & _21: Int128BW.t = Any.any_l ()
    | & _24: tup2_ref_i128_ref_i128 = Any.any_l ()
    | & left_val'0: Int128BW.t = Any.any_l ()
    | & right_val'0: Int128BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int128BW.t = Any.any_l ()
    | & _41: Int128BW.t = Any.any_l ()
    | & _44: Int128BW.t = Any.any_l ()
    | & _45: Int128BW.t = Any.any_l ()
    | & _46: Int128BW.t = Any.any_l ()
    | & _47: Int128BW.t = Any.any_l () ])
    [ return (result: Int128BW.t) -> {[@expl:test_from_bool_bw ensures] result = Int128BW.of_bool b}
      (! return {result}) ]
end
module M_i128__test_shl
  use creusot.int.Int32
  use creusot.int.Int128
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: Int128.t) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int128.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int128.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int128.t = Any.any_l () | & n: Int128.t = n ])
    [ return (result: Int128.t) -> {[@expl:test_shl ensures #0] result = Int128.lsl n (Int128.t'int (3: Int128.t))}
      {[@expl:test_shl ensures #1] result = Int128.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i128__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.Int128BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: Int128BW.t) (return (x: Int128BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int128BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int128BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int128BW.t = Any.any_l () | & n: Int128BW.t = n ])
    [ return (result: Int128BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = Int128BW.lsl n (Int128BW.t'int (3: Int128BW.t))}
      {[@expl:test_shl_bw ensures #1] result = Int128BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_i128__test_shr
  use creusot.int.Int32
  use creusot.int.Int128
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: Int128.t) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int128.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int128.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int128.t = Any.any_l () | & n: Int128.t = n ])
    [ return (result: Int128.t) -> {[@expl:test_shr ensures #0] result = Int128.shr n (Int128.t'int (3: Int128.t))}
      {[@expl:test_shr ensures #1] result = Int128.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_i128__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.Int128BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: Int128BW.t) (return (x: Int128BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int128BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int128BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int128BW.t = Any.any_l () | & n: Int128BW.t = n ])
    [ return (result: Int128BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = Int128BW.shr n (Int128BW.t'int (3: Int128BW.t))}
      {[@expl:test_shr_bw ensures #1] result = Int128BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_usize__test_add
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: UInt64.t) (r: UInt64.t) (return (x: UInt64.t)) = {[@expl:test_add requires] UInt64.t'int l
        + UInt64.t'int r
      >= UInt64.t'int const_MIN
    /\ UInt64.t'int l + UInt64.t'int r <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.add {l} {r} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & l: UInt64.t = l | & r: UInt64.t = r ])
    [ return (result: UInt64.t) -> {[@expl:test_add ensures] UInt64.t'int result = UInt64.t'int l + UInt64.t'int r}
      (! return {result}) ]
end
module M_usize__test_add_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant const_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: UInt64BW.t) (r: UInt64BW.t) (return (x: UInt64BW.t)) =
    {[@expl:test_add_bw requires] UInt64BW.t'int l + UInt64BW.t'int r >= UInt64BW.t'int const_MIN
    /\ UInt64BW.t'int l + UInt64BW.t'int r <= UInt64BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.add {l} {r} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l () | & l: UInt64BW.t = l | & r: UInt64BW.t = r ])
    [ return (result: UInt64BW.t) -> {[@expl:test_add_bw ensures] UInt64BW.t'int result
      = UInt64BW.t'int l + UInt64BW.t'int r}
      (! return {result}) ]
end
module M_usize__test_sub
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: UInt64.t) (r: UInt64.t) (return (x: UInt64.t)) = {[@expl:test_sub requires] UInt64.t'int l
        - UInt64.t'int r
      >= UInt64.t'int const_MIN
    /\ UInt64.t'int l - UInt64.t'int r <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.sub {l} {r} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & l: UInt64.t = l | & r: UInt64.t = r ])
    [ return (result: UInt64.t) -> {[@expl:test_sub ensures] UInt64.t'int result = UInt64.t'int l - UInt64.t'int r}
      (! return {result}) ]
end
module M_usize__test_sub_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant const_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: UInt64BW.t) (r: UInt64BW.t) (return (x: UInt64BW.t)) =
    {[@expl:test_sub_bw requires] UInt64BW.t'int l - UInt64BW.t'int r >= UInt64BW.t'int const_MIN
    /\ UInt64BW.t'int l - UInt64BW.t'int r <= UInt64BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.sub {l} {r} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l () | & l: UInt64BW.t = l | & r: UInt64BW.t = r ])
    [ return (result: UInt64BW.t) -> {[@expl:test_sub_bw ensures] UInt64BW.t'int result
      = UInt64BW.t'int l - UInt64BW.t'int r}
      (! return {result}) ]
end
module M_usize__test_mul
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: UInt64.t) (r: UInt64.t) (return (x: UInt64.t)) = {[@expl:test_mul requires] UInt64.t'int l
        * UInt64.t'int r
      >= UInt64.t'int const_MIN
    /\ UInt64.t'int l * UInt64.t'int r <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.mul {l} {r} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & l: UInt64.t = l | & r: UInt64.t = r ])
    [ return (result: UInt64.t) -> {[@expl:test_mul ensures] UInt64.t'int result = UInt64.t'int l * UInt64.t'int r}
      (! return {result}) ]
end
module M_usize__test_mul_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant const_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: UInt64BW.t) (r: UInt64BW.t) (return (x: UInt64BW.t)) =
    {[@expl:test_mul_bw requires] UInt64BW.t'int l * UInt64BW.t'int r >= UInt64BW.t'int const_MIN
    /\ UInt64BW.t'int l * UInt64BW.t'int r <= UInt64BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.mul {l} {r} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l () | & l: UInt64BW.t = l | & r: UInt64BW.t = r ])
    [ return (result: UInt64BW.t) -> {[@expl:test_mul_bw ensures] UInt64BW.t'int result
      = UInt64BW.t'int l * UInt64BW.t'int r}
      (! return {result}) ]
end
module M_usize__test_div
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: UInt64.t) (r: UInt64.t) (return (x: UInt64.t)) = {[@expl:test_div requires #0] UInt64.t'int r
    <> 0}
    {[@expl:test_div requires #1] Int.div (UInt64.t'int l) (UInt64.t'int r) >= UInt64.t'int const_MIN
    /\ Int.div (UInt64.t'int l) (UInt64.t'int r) <= UInt64.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt64.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt64.div {l} {_7} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & l: UInt64.t = l
    | & r: UInt64.t = r
    | & _7: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:test_div ensures] UInt64.t'int result
      = Int.div (UInt64.t'int l) (UInt64.t'int r)}
      (! return {result}) ]
end
module M_usize__test_div_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant const_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: UInt64BW.t) (r: UInt64BW.t) (return (x: UInt64BW.t)) =
    {[@expl:test_div_bw requires #0] UInt64BW.t'int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (UInt64BW.t'int l) (UInt64BW.t'int r) >= UInt64BW.t'int const_MIN
    /\ Int.div (UInt64BW.t'int l) (UInt64BW.t'int r) <= UInt64BW.t'int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- r ] s1
      | s1 = [ &_8 <- _7 = (0: UInt64BW.t) ] s2
      | s2 = {[@expl:division by zero] not _8} s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = UInt64BW.div {l} {_7} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l ()
    | & l: UInt64BW.t = l
    | & r: UInt64BW.t = r
    | & _7: UInt64BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ])
    [ return (result: UInt64BW.t) -> {[@expl:test_div_bw ensures] UInt64BW.t'int result
      = Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)}
      (! return {result}) ]
end
module M_usize__test_from_bool
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type tup2_ref_usize_ref_usize = { f0: UInt64.t; f1: UInt64.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt64.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () | & b: UInt64.t = Any.any_l () ]
        [ _const_ret (_const: UInt64.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt64.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () ] [ _const_ret (_const: UInt64.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt64.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () | & b: UInt64.t = Any.any_l () ]
        [ _const_ret (_const: UInt64.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt64.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64.t = Any.any_l () ] [ _const_ret (_const: UInt64.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt64.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val: UInt64.t = Any.any_l ()
    | & right_val: UInt64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt64.t = Any.any_l ()
    | & _21: UInt64.t = Any.any_l ()
    | & _24: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val'0: UInt64.t = Any.any_l ()
    | & right_val'0: UInt64.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt64.t = Any.any_l ()
    | & _41: UInt64.t = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _45: UInt64.t = Any.any_l ()
    | & _46: UInt64.t = Any.any_l ()
    | & _47: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:test_from_bool ensures] result = UInt64.of_bool b} (! return {result}) ]
end
module M_usize__test_from_bool_bw
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  
  type tup2_ref_usize_ref_usize = { f0: UInt64BW.t; f1: UInt64BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: UInt64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt64BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () | & b: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- UInt64BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () | & b: UInt64BW.t = Any.any_l () ]
        [ _const_ret (_const: UInt64BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: UInt64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: UInt64BW.t = Any.any_l () ] [ _const_ret (_const: UInt64BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- UInt64BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: UInt64BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val: UInt64BW.t = Any.any_l ()
    | & right_val: UInt64BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: UInt64BW.t = Any.any_l ()
    | & _24: tup2_ref_usize_ref_usize = Any.any_l ()
    | & left_val'0: UInt64BW.t = Any.any_l ()
    | & right_val'0: UInt64BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt64BW.t = Any.any_l ()
    | & _41: UInt64BW.t = Any.any_l ()
    | & _44: UInt64BW.t = Any.any_l ()
    | & _45: UInt64BW.t = Any.any_l ()
    | & _46: UInt64BW.t = Any.any_l ()
    | & _47: UInt64BW.t = Any.any_l () ])
    [ return (result: UInt64BW.t) -> {[@expl:test_from_bool_bw ensures] result = UInt64BW.of_bool b}
      (! return {result}) ]
end
module M_usize__test_shl
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt64.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () | & n: UInt64.t = n ])
    [ return (result: UInt64.t) -> {[@expl:test_shl ensures #0] result = UInt64.lsl n (UInt64.t'int (3: UInt64.t))}
      {[@expl:test_shl ensures #1] result = UInt64.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_usize__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: UInt64BW.t) (return (x: UInt64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt64BW.t = Any.any_l () | & n: UInt64BW.t = n ])
    [ return (result: UInt64BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = UInt64BW.lsl n (UInt64BW.t'int (3: UInt64BW.t))}
      {[@expl:test_shl_bw ensures #1] result = UInt64BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_usize__test_shr
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt64.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () | & n: UInt64.t = n ])
    [ return (result: UInt64.t) -> {[@expl:test_shr ensures #0] result = UInt64.shr n (UInt64.t'int (3: UInt64.t))}
      {[@expl:test_shr ensures #1] result = UInt64.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_usize__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: UInt64BW.t) (return (x: UInt64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt64BW.t = Any.any_l () | & n: UInt64BW.t = n ])
    [ return (result: UInt64BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = UInt64BW.shr n (UInt64BW.t'int (3: UInt64BW.t))}
      {[@expl:test_shr_bw ensures #1] result = UInt64BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_isize__test_add
  use creusot.int.Int64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add (l: Int64.t) (r: Int64.t) (return (x: Int64.t)) = {[@expl:test_add requires] Int64.to_int l
        + Int64.to_int r
      >= Int64.to_int const_MIN
    /\ Int64.to_int l + Int64.to_int r <= Int64.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.add {l} {r} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & l: Int64.t = l | & r: Int64.t = r ])
    [ return (result: Int64.t) -> {[@expl:test_add ensures] Int64.to_int result = Int64.to_int l + Int64.to_int r}
      (! return {result}) ]
end
module M_isize__test_add_bw
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant const_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_add_bw (l: Int64BW.t) (r: Int64BW.t) (return (x: Int64BW.t)) =
    {[@expl:test_add_bw requires] Int64BW.to_int l + Int64BW.to_int r >= Int64BW.to_int const_MIN
    /\ Int64BW.to_int l + Int64BW.to_int r <= Int64BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.add {l} {r} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l () | & l: Int64BW.t = l | & r: Int64BW.t = r ])
    [ return (result: Int64BW.t) -> {[@expl:test_add_bw ensures] Int64BW.to_int result
      = Int64BW.to_int l + Int64BW.to_int r}
      (! return {result}) ]
end
module M_isize__test_sub
  use creusot.int.Int64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub (l: Int64.t) (r: Int64.t) (return (x: Int64.t)) = {[@expl:test_sub requires] Int64.to_int l
        - Int64.to_int r
      >= Int64.to_int const_MIN
    /\ Int64.to_int l - Int64.to_int r <= Int64.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.sub {l} {r} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & l: Int64.t = l | & r: Int64.t = r ])
    [ return (result: Int64.t) -> {[@expl:test_sub ensures] Int64.to_int result = Int64.to_int l - Int64.to_int r}
      (! return {result}) ]
end
module M_isize__test_sub_bw
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant const_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_sub_bw (l: Int64BW.t) (r: Int64BW.t) (return (x: Int64BW.t)) =
    {[@expl:test_sub_bw requires] Int64BW.to_int l - Int64BW.to_int r >= Int64BW.to_int const_MIN
    /\ Int64BW.to_int l - Int64BW.to_int r <= Int64BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.sub {l} {r} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l () | & l: Int64BW.t = l | & r: Int64BW.t = r ])
    [ return (result: Int64BW.t) -> {[@expl:test_sub_bw ensures] Int64BW.to_int result
      = Int64BW.to_int l - Int64BW.to_int r}
      (! return {result}) ]
end
module M_isize__test_mul
  use creusot.int.Int64
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul (l: Int64.t) (r: Int64.t) (return (x: Int64.t)) = {[@expl:test_mul requires] Int64.to_int l
        * Int64.to_int r
      >= Int64.to_int const_MIN
    /\ Int64.to_int l * Int64.to_int r <= Int64.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.mul {l} {r} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & l: Int64.t = l | & r: Int64.t = r ])
    [ return (result: Int64.t) -> {[@expl:test_mul ensures] Int64.to_int result = Int64.to_int l * Int64.to_int r}
      (! return {result}) ]
end
module M_isize__test_mul_bw
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant const_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_mul_bw (l: Int64BW.t) (r: Int64BW.t) (return (x: Int64BW.t)) =
    {[@expl:test_mul_bw requires] Int64BW.to_int l * Int64BW.to_int r >= Int64BW.to_int const_MIN
    /\ Int64BW.to_int l * Int64BW.to_int r <= Int64BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.mul {l} {r} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l () | & l: Int64BW.t = l | & r: Int64BW.t = r ])
    [ return (result: Int64BW.t) -> {[@expl:test_mul_bw ensures] Int64BW.to_int result
      = Int64BW.to_int l * Int64BW.to_int r}
      (! return {result}) ]
end
module M_isize__test_div
  use creusot.int.Int64
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div (l: Int64.t) (r: Int64.t) (return (x: Int64.t)) = {[@expl:test_div requires #0] Int64.to_int r <> 0}
    {[@expl:test_div requires #1] Int.div (Int64.to_int l) (Int64.to_int r) >= Int64.to_int const_MIN
    /\ Int.div (Int64.to_int l) (Int64.to_int r) <= Int64.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int64.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (-1: Int64.t) ] s1
      | s1 = [ &_10 <- _6 = (-9223372036854775808: Int64.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int64.div {_6} {_7} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l ()
    | & l: Int64.t = l
    | & r: Int64.t = r
    | & _6: Int64.t = Any.any_l ()
    | & _7: Int64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:test_div ensures] Int64.to_int result
      = Int.div (Int64.to_int l) (Int64.to_int r)}
      (! return {result}) ]
end
module M_isize__test_div_bw
  use creusot.int.Int64BW
  use creusot.prelude.Bool
  use creusot.prelude.Any
  use mach.int.Int
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant const_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_div_bw (l: Int64BW.t) (r: Int64BW.t) (return (x: Int64BW.t)) =
    {[@expl:test_div_bw requires #0] Int64BW.to_int r <> 0}
    {[@expl:test_div_bw requires #1] Int.div (Int64BW.to_int l) (Int64BW.to_int r) >= Int64BW.to_int const_MIN
    /\ Int.div (Int64BW.to_int l) (Int64BW.to_int r) <= Int64BW.to_int const_MAX}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- l ] s1
      | s1 = [ &_7 <- r ] s2
      | s2 = [ &_8 <- _7 = (0: Int64BW.t) ] s3
      | s3 = {[@expl:division by zero] not _8} s4
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- _7 = (18446744073709551615: Int64BW.t) ] s1
      | s1 = [ &_10 <- _6 = (9223372036854775808: Int64BW.t) ] s2
      | s2 = [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] not _11} s4
      | s4 = bb2 ]
    | bb2 = s0 [ s0 = Int64BW.div {_6} {_7} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1) | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l ()
    | & l: Int64BW.t = l
    | & r: Int64BW.t = r
    | & _6: Int64BW.t = Any.any_l ()
    | & _7: Int64BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ])
    [ return (result: Int64BW.t) -> {[@expl:test_div_bw ensures] Int64BW.to_int result
      = Int.div (Int64BW.to_int l) (Int64BW.to_int r)}
      (! return {result}) ]
end
module M_isize__test_from_bool
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type tup2_ref_isize_ref_isize = { f0: Int64.t; f1: Int64.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool (b: bool) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int64.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64.t = Any.any_l () | & b: Int64.t = Any.any_l () ]
        [ _const_ret (_const: Int64.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int64.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64.t = Any.any_l () ] [ _const_ret (_const: Int64.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int64.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64.t = Any.any_l () | & b: Int64.t = Any.any_l () ]
        [ _const_ret (_const: Int64.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int64.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64.t = Any.any_l () ] [ _const_ret (_const: Int64.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int64.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int64.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_isize_ref_isize = Any.any_l ()
    | & left_val: Int64.t = Any.any_l ()
    | & right_val: Int64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int64.t = Any.any_l ()
    | & _21: Int64.t = Any.any_l ()
    | & _24: tup2_ref_isize_ref_isize = Any.any_l ()
    | & left_val'0: Int64.t = Any.any_l ()
    | & right_val'0: Int64.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int64.t = Any.any_l ()
    | & _41: Int64.t = Any.any_l ()
    | & _44: Int64.t = Any.any_l ()
    | & _45: Int64.t = Any.any_l ()
    | & _46: Int64.t = Any.any_l ()
    | & _47: Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:test_from_bool ensures] result = Int64.of_bool b} (! return {result}) ]
end
module M_isize__test_from_bool_bw
  use creusot.int.Int64BW
  use creusot.prelude.Any
  
  type tup2_ref_isize_ref_isize = { f0: Int64BW.t; f1: Int64BW.t }
  
  type t_AssertKind = Eq | Ne | Match
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_from_bool_bw (b: bool) (return (x: Int64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int64BW.of_bool true ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () | & b: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_47 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_46 <- _const ] s2 ]
      | s2 = [ &_4 <- { f0 = _47; f1 = _46 } ] s3
      | s3 = [ &left_val <- _4.f0 ] s4
      | s4 = [ &right_val <- _4.f1 ] s5
      | s5 = [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ] ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &b <- Int64BW.of_bool false ] s1'0 | s1'0 = [ &_0'0 <- b ] s2'0 | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () | & b: Int64BW.t = Any.any_l () ]
        [ _const_ret (_const: Int64BW.t) -> [ &_45 <- _const ] s1 ]
      | s1 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (0: Int64BW.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int64BW.t = Any.any_l () ] [ _const_ret (_const: Int64BW.t) -> [ &_44 <- _const ] s2 ]
      | s2 = [ &_24 <- { f0 = _45; f1 = _44 } ] s3
      | s3 = [ &left_val'0 <- _24.f0 ] s4
      | s4 = [ &right_val'0 <- _24.f1 ] s5
      | s5 = [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ] ]
    | bb3 = s0 [ s0 = [ &_0 <- Int64BW.of_bool b ] s1 | s1 = return {_0} ]
    | bb4 = s0
      [ s0 = [ &kind'0 <- Eq ] s1
      | s1 = [ &_39 <- left_val'0 ] s2
      | s2 = [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    | bb2 = s0
      [ s0 = [ &kind <- Eq ] s1 | s1 = [ &_19 <- left_val ] s2 | s2 = [ &_21 <- right_val ] s3 | s3 = {false} any ] ]
    [ & _0: Int64BW.t = Any.any_l ()
    | & b: bool = b
    | & _4: tup2_ref_isize_ref_isize = Any.any_l ()
    | & left_val: Int64BW.t = Any.any_l ()
    | & right_val: Int64BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int64BW.t = Any.any_l ()
    | & _21: Int64BW.t = Any.any_l ()
    | & _24: tup2_ref_isize_ref_isize = Any.any_l ()
    | & left_val'0: Int64BW.t = Any.any_l ()
    | & right_val'0: Int64BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int64BW.t = Any.any_l ()
    | & _41: Int64BW.t = Any.any_l ()
    | & _44: Int64BW.t = Any.any_l ()
    | & _45: Int64BW.t = Any.any_l ()
    | & _46: Int64BW.t = Any.any_l ()
    | & _47: Int64BW.t = Any.any_l () ])
    [ return (result: Int64BW.t) -> {[@expl:test_from_bool_bw ensures] result = Int64BW.of_bool b} (! return {result}) ]
end
module M_isize__test_shl
  use creusot.int.Int32
  use creusot.int.Int64
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl (n: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int64.shl {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int64.t = Any.any_l () | & n: Int64.t = n ])
    [ return (result: Int64.t) -> {[@expl:test_shl ensures #0] result = Int64.lsl n (Int64.t'int (3: Int64.t))}
      {[@expl:test_shl ensures #1] result = Int64.lsl n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_isize__test_shl_bw
  use creusot.int.Int32BW
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shl_bw (n: Int64BW.t) (return (x: Int64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int64BW.shl {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int64BW.t = Any.any_l () | & n: Int64BW.t = n ])
    [ return (result: Int64BW.t) -> {[@expl:test_shl_bw ensures #0] result
      = Int64BW.lsl n (Int64BW.t'int (3: Int64BW.t))}
      {[@expl:test_shl_bw ensures #1] result = Int64BW.lsl n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
module M_isize__test_shr
  use creusot.int.Int32
  use creusot.int.Int64
  use creusot.prelude.Any
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr (n: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int64.shr {n} {Int32.to_int (3: Int32.t)} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int64.t = Any.any_l () | & n: Int64.t = n ])
    [ return (result: Int64.t) -> {[@expl:test_shr ensures #0] result = Int64.shr n (Int64.t'int (3: Int64.t))}
      {[@expl:test_shr ensures #1] result = Int64.shr n (UInt8.t'int (3: UInt8.t))}
      (! return {result}) ]
end
module M_isize__test_shr_bw
  use creusot.int.Int32BW
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use creusot.int.UInt8BW
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_shr_bw (n: Int64BW.t) (return (x: Int64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int64BW.shr {n} {Int32BW.to_int (3: Int32BW.t)} (fun (_ret: Int64BW.t) -> [ &_0 <- _ret ] s1)
      | s1 = return {_0} ] ] [ & _0: Int64BW.t = Any.any_l () | & n: Int64BW.t = n ])
    [ return (result: Int64BW.t) -> {[@expl:test_shr_bw ensures #0] result
      = Int64BW.shr n (Int64BW.t'int (3: Int64BW.t))}
      {[@expl:test_shr_bw ensures #1] result = Int64BW.shr n (UInt8BW.t'int (3: UInt8BW.t))}
      (! return {result}) ]
end
