module M_integer_ops__test_bitwise_ops [#"integer_ops.rs" 5 0 5 25]
  let%span sinteger_ops = "integer_ops.rs" 7 31 7 44
  let%span sinteger_ops'0 = "integer_ops.rs" 7 15 7 28
  let%span sinteger_ops'1 = "integer_ops.rs" 7 46 7 59
  let%span sinteger_ops'2 = "integer_ops.rs" 8 31 8 44
  let%span sinteger_ops'3 = "integer_ops.rs" 8 15 8 28
  let%span sinteger_ops'4 = "integer_ops.rs" 8 46 8 59
  let%span sinteger_ops'5 = "integer_ops.rs" 9 42 9 66
  let%span sinteger_ops'6 = "integer_ops.rs" 9 15 9 39
  let%span sinteger_ops'7 = "integer_ops.rs" 9 68 9 92
  let%span sinteger_ops'8 = "integer_ops.rs" 10 42 10 66
  let%span sinteger_ops'9 = "integer_ops.rs" 10 15 10 39
  let%span sinteger_ops'10 = "integer_ops.rs" 10 68 10 92
  let%span sinteger_ops'11 = "integer_ops.rs" 11 31 11 44
  let%span sinteger_ops'12 = "integer_ops.rs" 11 15 11 28
  let%span sinteger_ops'13 = "integer_ops.rs" 11 46 11 59
  let%span sinteger_ops'14 = "integer_ops.rs" 12 31 12 44
  let%span sinteger_ops'15 = "integer_ops.rs" 12 15 12 28
  let%span sinteger_ops'16 = "integer_ops.rs" 12 46 12 59
  let%span sinteger_ops'17 = "integer_ops.rs" 13 39 13 60
  let%span sinteger_ops'18 = "integer_ops.rs" 13 15 13 36
  let%span sinteger_ops'19 = "integer_ops.rs" 13 62 13 83
  let%span sinteger_ops'20 = "integer_ops.rs" 14 39 14 60
  let%span sinteger_ops'21 = "integer_ops.rs" 14 15 14 36
  let%span sinteger_ops'22 = "integer_ops.rs" 14 62 14 83
  let%span sinteger_ops'23 = "integer_ops.rs" 15 42 15 66
  let%span sinteger_ops'24 = "integer_ops.rs" 15 15 15 39
  let%span sinteger_ops'25 = "integer_ops.rs" 15 68 15 92
  let%span sinteger_ops'26 = "integer_ops.rs" 16 42 16 66
  let%span sinteger_ops'27 = "integer_ops.rs" 16 15 16 39
  let%span sinteger_ops'28 = "integer_ops.rs" 16 68 16 92
  let%span sinteger_ops'29 = "integer_ops.rs" 17 34 17 50
  let%span sinteger_ops'30 = "integer_ops.rs" 17 15 17 31
  let%span sinteger_ops'31 = "integer_ops.rs" 17 52 17 68
  let%span sinteger_ops'32 = "integer_ops.rs" 18 34 18 50
  let%span sinteger_ops'33 = "integer_ops.rs" 18 15 18 31
  let%span sinteger_ops'34 = "integer_ops.rs" 18 52 18 68
  let%span sinteger_ops'35 = "integer_ops.rs" 21 31 21 44
  let%span sinteger_ops'36 = "integer_ops.rs" 21 15 21 28
  let%span sinteger_ops'37 = "integer_ops.rs" 21 46 21 59
  let%span sinteger_ops'38 = "integer_ops.rs" 22 31 22 44
  let%span sinteger_ops'39 = "integer_ops.rs" 22 15 22 28
  let%span sinteger_ops'40 = "integer_ops.rs" 22 46 22 59
  let%span sinteger_ops'41 = "integer_ops.rs" 23 42 23 66
  let%span sinteger_ops'42 = "integer_ops.rs" 23 15 23 39
  let%span sinteger_ops'43 = "integer_ops.rs" 23 68 23 92
  let%span sinteger_ops'44 = "integer_ops.rs" 24 42 24 66
  let%span sinteger_ops'45 = "integer_ops.rs" 24 15 24 39
  let%span sinteger_ops'46 = "integer_ops.rs" 24 68 24 92
  let%span sinteger_ops'47 = "integer_ops.rs" 25 31 25 44
  let%span sinteger_ops'48 = "integer_ops.rs" 25 15 25 28
  let%span sinteger_ops'49 = "integer_ops.rs" 25 46 25 59
  let%span sinteger_ops'50 = "integer_ops.rs" 26 31 26 44
  let%span sinteger_ops'51 = "integer_ops.rs" 26 15 26 28
  let%span sinteger_ops'52 = "integer_ops.rs" 26 46 26 59
  let%span sinteger_ops'53 = "integer_ops.rs" 27 39 27 60
  let%span sinteger_ops'54 = "integer_ops.rs" 27 15 27 36
  let%span sinteger_ops'55 = "integer_ops.rs" 27 62 27 83
  let%span sinteger_ops'56 = "integer_ops.rs" 28 39 28 60
  let%span sinteger_ops'57 = "integer_ops.rs" 28 15 28 36
  let%span sinteger_ops'58 = "integer_ops.rs" 28 62 28 83
  let%span sinteger_ops'59 = "integer_ops.rs" 29 42 29 66
  let%span sinteger_ops'60 = "integer_ops.rs" 29 15 29 39
  let%span sinteger_ops'61 = "integer_ops.rs" 29 68 29 92
  let%span sinteger_ops'62 = "integer_ops.rs" 30 42 30 66
  let%span sinteger_ops'63 = "integer_ops.rs" 30 15 30 39
  let%span sinteger_ops'64 = "integer_ops.rs" 30 68 30 92
  let%span sinteger_ops'65 = "integer_ops.rs" 31 34 31 50
  let%span sinteger_ops'66 = "integer_ops.rs" 31 15 31 31
  let%span sinteger_ops'67 = "integer_ops.rs" 31 52 31 68
  let%span sinteger_ops'68 = "integer_ops.rs" 32 34 32 50
  let%span sinteger_ops'69 = "integer_ops.rs" 32 15 32 31
  let%span sinteger_ops'70 = "integer_ops.rs" 32 52 32 68
  let%span sinteger_ops'71 = "integer_ops.rs" 35 31 35 44
  let%span sinteger_ops'72 = "integer_ops.rs" 35 15 35 28
  let%span sinteger_ops'73 = "integer_ops.rs" 35 46 35 59
  let%span sinteger_ops'74 = "integer_ops.rs" 36 31 36 44
  let%span sinteger_ops'75 = "integer_ops.rs" 36 15 36 28
  let%span sinteger_ops'76 = "integer_ops.rs" 36 46 36 59
  let%span sinteger_ops'77 = "integer_ops.rs" 37 42 37 66
  let%span sinteger_ops'78 = "integer_ops.rs" 37 15 37 39
  let%span sinteger_ops'79 = "integer_ops.rs" 37 68 37 92
  let%span sinteger_ops'80 = "integer_ops.rs" 38 42 38 66
  let%span sinteger_ops'81 = "integer_ops.rs" 38 15 38 39
  let%span sinteger_ops'82 = "integer_ops.rs" 38 68 38 92
  let%span sinteger_ops'83 = "integer_ops.rs" 39 31 39 44
  let%span sinteger_ops'84 = "integer_ops.rs" 39 15 39 28
  let%span sinteger_ops'85 = "integer_ops.rs" 39 46 39 59
  let%span sinteger_ops'86 = "integer_ops.rs" 40 31 40 44
  let%span sinteger_ops'87 = "integer_ops.rs" 40 15 40 28
  let%span sinteger_ops'88 = "integer_ops.rs" 40 46 40 54
  let%span sinteger_ops'89 = "integer_ops.rs" 41 39 41 60
  let%span sinteger_ops'90 = "integer_ops.rs" 41 15 41 36
  let%span sinteger_ops'91 = "integer_ops.rs" 41 62 41 83
  let%span sinteger_ops'92 = "integer_ops.rs" 42 39 42 60
  let%span sinteger_ops'93 = "integer_ops.rs" 42 15 42 36
  let%span sinteger_ops'94 = "integer_ops.rs" 42 62 42 82
  let%span sinteger_ops'95 = "integer_ops.rs" 43 42 43 66
  let%span sinteger_ops'96 = "integer_ops.rs" 43 15 43 39
  let%span sinteger_ops'97 = "integer_ops.rs" 43 68 43 92
  let%span sinteger_ops'98 = "integer_ops.rs" 44 42 44 66
  let%span sinteger_ops'99 = "integer_ops.rs" 44 15 44 39
  let%span sinteger_ops'100 = "integer_ops.rs" 44 68 44 92
  let%span sinteger_ops'101 = "integer_ops.rs" 45 34 45 50
  let%span sinteger_ops'102 = "integer_ops.rs" 45 15 45 31
  let%span sinteger_ops'103 = "integer_ops.rs" 45 52 45 68
  let%span sinteger_ops'104 = "integer_ops.rs" 46 34 46 50
  let%span sinteger_ops'105 = "integer_ops.rs" 46 15 46 31
  let%span sinteger_ops'106 = "integer_ops.rs" 46 52 46 68
  let%span sinteger_ops'107 = "integer_ops.rs" 49 16 49 29
  let%span sinteger_ops'108 = "integer_ops.rs" 49 31 49 44
  let%span sinteger_ops'109 = "integer_ops.rs" 50 16 50 29
  let%span sinteger_ops'110 = "integer_ops.rs" 50 31 50 37
  let%span sinteger_ops'111 = "integer_ops.rs" 51 16 51 40
  let%span sinteger_ops'112 = "integer_ops.rs" 51 42 51 66
  let%span sinteger_ops'113 = "integer_ops.rs" 52 16 52 40
  let%span sinteger_ops'114 = "integer_ops.rs" 52 42 52 51
  let%span sinteger_ops'115 = "integer_ops.rs" 53 16 53 29
  let%span sinteger_ops'116 = "integer_ops.rs" 53 31 53 44
  let%span sinteger_ops'117 = "integer_ops.rs" 54 16 54 29
  let%span sinteger_ops'118 = "integer_ops.rs" 54 31 54 45
  let%span sinteger_ops'119 = "integer_ops.rs" 55 16 55 37
  let%span sinteger_ops'120 = "integer_ops.rs" 55 39 55 60
  let%span sinteger_ops'121 = "integer_ops.rs" 56 16 56 37
  let%span sinteger_ops'122 = "integer_ops.rs" 56 39 56 62
  let%span sinteger_ops'123 = "integer_ops.rs" 57 16 57 40
  let%span sinteger_ops'124 = "integer_ops.rs" 57 42 57 80
  let%span sinteger_ops'125 = "integer_ops.rs" 58 16 58 40
  let%span sinteger_ops'126 = "integer_ops.rs" 58 42 58 69
  
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  use creusot.int.Int8BW
  use creusot.int.UInt16BW
  use creusot.int.Int16BW
  use creusot.int.UInt32BW
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.int.Int64BW
  use creusot.int.UInt128BW
  use creusot.int.Int128BW
  
  let rec promoted91__test_bitwise_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.bw_and ([%#sinteger_ops'0] (240: UInt8BW.t)) ([%#sinteger_ops] (60: UInt8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ] 
    [ return''0 (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted90__test_bitwise_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (48: UInt8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8BW.t = Any.any_l () ]  [ return''0 (result:UInt8BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt8BW.t; _p1: UInt8BW.t }
  
  let rec promoted89__test_bitwise_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.bw_and ([%#sinteger_ops'3] (113: Int8BW.t)) ([%#sinteger_ops'2] (61: Int8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted88__test_bitwise_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'4] (49: Int8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8BW.t = Any.any_l () ]  [ return''0 (result:Int8BW.t)-> return' {result} ] 
  
  type tuple'0  =
    { _p0'0: Int8BW.t; _p1'0: Int8BW.t }
  
  let rec promoted87__test_bitwise_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt16BW.bw_and ([%#sinteger_ops'6] (42225: UInt16BW.t)) ([%#sinteger_ops'5] (21565: UInt16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ] 
    [ return''0 (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted86__test_bitwise_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'7] (1073: UInt16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16BW.t = Any.any_l () ]  [ return''0 (result:UInt16BW.t)-> return' {result} ] 
  
  type tuple'1  =
    { _p0'1: UInt16BW.t; _p1'1: UInt16BW.t }
  
  let rec promoted85__test_bitwise_ops (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16BW.bw_and ([%#sinteger_ops'9] (13553: Int16BW.t)) ([%#sinteger_ops'8] (21565: Int16BW.t)) ] 
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ] 
    [ return''0 (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted84__test_bitwise_ops (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'10] (5169: Int16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int16BW.t = Any.any_l () ]  [ return''0 (result:Int16BW.t)-> return' {result} ] 
  
  type tuple'2  =
    { _p0'2: Int16BW.t; _p1'2: Int16BW.t }
  
  let rec promoted83__test_bitwise_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt32BW.bw_and ([%#sinteger_ops'12] (3221225475: UInt32BW.t)) ([%#sinteger_ops'11] (1073840130: UInt32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ] 
    [ return''0 (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted82__test_bitwise_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'13] (1073741826: UInt32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32BW.t = Any.any_l () ]  [ return''0 (result:UInt32BW.t)-> return' {result} ] 
  
  type tuple'3  =
    { _p0'3: UInt32BW.t; _p1'3: UInt32BW.t }
  
  let rec promoted81__test_bitwise_ops (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int32BW.bw_and ([%#sinteger_ops'15] (1073741839: Int32BW.t)) ([%#sinteger_ops'14] (1073745665: Int32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ] 
    [ return''0 (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted80__test_bitwise_ops (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'16] (1073741825: Int32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32BW.t = Any.any_l () ]  [ return''0 (result:Int32BW.t)-> return' {result} ] 
  
  type tuple'4  =
    { _p0'4: Int32BW.t; _p1'4: Int32BW.t }
  
  let rec promoted79__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt64BW.bw_and ([%#sinteger_ops'18] (13835321938072829955: UInt64BW.t)) ([%#sinteger_ops'17] (9223838229784952833: UInt64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted78__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'19] (9223547958715219969: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type tuple'5  =
    { _p0'5: UInt64BW.t; _p1'5: UInt64BW.t }
  
  let rec promoted77__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int64BW.bw_and ([%#sinteger_ops'21] (4611686018437454224: Int64BW.t)) ([%#sinteger_ops'20] (5226577450909599872: Int64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted76__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'22] (4611686018436335744: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  type tuple'6  =
    { _p0'6: Int64BW.t; _p1'6: Int64BW.t }
  
  let rec promoted75__test_bitwise_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt128BW.bw_and ([%#sinteger_ops'24] (4514840875923203424259: UInt128BW.t)) ([%#sinteger_ops'23] (3108276842612989624321: UInt128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ] 
    [ return''0 (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted74__test_bitwise_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops'25] (2960702599752243478529: UInt128BW.t) ] s1 | s1 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () ]  [ return''0 (result:UInt128BW.t)-> return' {result} ] 
  
  type tuple'7  =
    { _p0'7: UInt128BW.t; _p1'7: UInt128BW.t }
  
  let rec promoted73__test_bitwise_ops (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int128BW.bw_and ([%#sinteger_ops'27] (4514840875923203424259: Int128BW.t)) ([%#sinteger_ops'26] (3108276842612989624321: Int128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ] 
    [ return''0 (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted72__test_bitwise_ops (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'28] (2960702599752243478529: Int128BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int128BW.t = Any.any_l () ]  [ return''0 (result:Int128BW.t)-> return' {result} ] 
  
  type tuple'8  =
    { _p0'8: Int128BW.t; _p1'8: Int128BW.t }
  
  let rec promoted71__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.bw_and ([%#sinteger_ops'30] (240: UInt64BW.t)) ([%#sinteger_ops'29] (60: UInt64BW.t)) ] 
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted70__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'31] (48: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type tuple'9  =
    { _p0'9: UInt64BW.t; _p1'9: UInt64BW.t }
  
  let rec promoted69__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.bw_and ([%#sinteger_ops'33] (113: Int64BW.t)) ([%#sinteger_ops'32] (61: Int64BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted68__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'34] (49: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  type tuple'10  =
    { _p0'10: Int64BW.t; _p1'10: Int64BW.t }
  
  let rec promoted67__test_bitwise_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.bw_or ([%#sinteger_ops'36] (240: UInt8BW.t)) ([%#sinteger_ops'35] (60: UInt8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ] 
    [ return''0 (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted66__test_bitwise_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'37] (252: UInt8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8BW.t = Any.any_l () ]  [ return''0 (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted65__test_bitwise_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.bw_or ([%#sinteger_ops'39] (113: Int8BW.t)) ([%#sinteger_ops'38] (61: Int8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted64__test_bitwise_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'40] (125: Int8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8BW.t = Any.any_l () ]  [ return''0 (result:Int8BW.t)-> return' {result} ] 
  
  let rec promoted63__test_bitwise_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt16BW.bw_or ([%#sinteger_ops'42] (42225: UInt16BW.t)) ([%#sinteger_ops'41] (21565: UInt16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ] 
    [ return''0 (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted62__test_bitwise_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'43] (62717: UInt16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16BW.t = Any.any_l () ]  [ return''0 (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted61__test_bitwise_ops (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int16BW.bw_or ([%#sinteger_ops'45] (13553: Int16BW.t)) ([%#sinteger_ops'44] (21565: Int16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ] 
    [ return''0 (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted60__test_bitwise_ops (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'46] (29949: Int16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int16BW.t = Any.any_l () ]  [ return''0 (result:Int16BW.t)-> return' {result} ] 
  
  let rec promoted59__test_bitwise_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt32BW.bw_or ([%#sinteger_ops'48] (3221225475: UInt32BW.t)) ([%#sinteger_ops'47] (1073840130: UInt32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ] 
    [ return''0 (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted58__test_bitwise_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'49] (3221323779: UInt32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32BW.t = Any.any_l () ]  [ return''0 (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted57__test_bitwise_ops (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int32BW.bw_or ([%#sinteger_ops'51] (1073741839: Int32BW.t)) ([%#sinteger_ops'50] (1073745665: Int32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ] 
    [ return''0 (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted56__test_bitwise_ops (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'52] (1073745679: Int32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32BW.t = Any.any_l () ]  [ return''0 (result:Int32BW.t)-> return' {result} ] 
  
  let rec promoted55__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt64BW.bw_or ([%#sinteger_ops'54] (13835321938072829955: UInt64BW.t)) ([%#sinteger_ops'53] (9223838229784952833: UInt64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted54__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'55] (13835612209142562819: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted53__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int64BW.bw_or ([%#sinteger_ops'57] (4611686018437454224: Int64BW.t)) ([%#sinteger_ops'56] (5226577450909599872: Int64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted52__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'58] (5226577450910718352: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted51__test_bitwise_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt128BW.bw_or ([%#sinteger_ops'60] (4514840875923203424259: UInt128BW.t)) ([%#sinteger_ops'59] (3108276842612989624321: UInt128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ] 
    [ return''0 (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted50__test_bitwise_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops'61] (4662415118783949570051: UInt128BW.t) ] s1 | s1 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () ]  [ return''0 (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted49__test_bitwise_ops (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int128BW.bw_or ([%#sinteger_ops'63] (4514840875923203424259: Int128BW.t)) ([%#sinteger_ops'62] (3108276842612989624321: Int128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ] 
    [ return''0 (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted48__test_bitwise_ops (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'64] (4662415118783949570051: Int128BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int128BW.t = Any.any_l () ]  [ return''0 (result:Int128BW.t)-> return' {result} ] 
  
  let rec promoted47__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.bw_or ([%#sinteger_ops'66] (240: UInt64BW.t)) ([%#sinteger_ops'65] (60: UInt64BW.t)) ] 
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted46__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'67] (252: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted45__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.bw_or ([%#sinteger_ops'69] (113: Int64BW.t)) ([%#sinteger_ops'68] (61: Int64BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted44__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'70] (125: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted43__test_bitwise_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.bw_xor ([%#sinteger_ops'72] (240: UInt8BW.t)) ([%#sinteger_ops'71] (60: UInt8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ] 
    [ return''0 (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted42__test_bitwise_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'73] (204: UInt8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8BW.t = Any.any_l () ]  [ return''0 (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted41__test_bitwise_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.bw_xor ([%#sinteger_ops'75] (113: Int8BW.t)) ([%#sinteger_ops'74] (61: Int8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted40__test_bitwise_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'76] (76: Int8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8BW.t = Any.any_l () ]  [ return''0 (result:Int8BW.t)-> return' {result} ] 
  
  let rec promoted39__test_bitwise_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt16BW.bw_xor ([%#sinteger_ops'78] (42225: UInt16BW.t)) ([%#sinteger_ops'77] (21565: UInt16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ] 
    [ return''0 (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted38__test_bitwise_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'79] (61644: UInt16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16BW.t = Any.any_l () ]  [ return''0 (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted37__test_bitwise_ops (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int16BW.bw_xor ([%#sinteger_ops'81] (13553: Int16BW.t)) ([%#sinteger_ops'80] (21565: Int16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ] 
    [ return''0 (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted36__test_bitwise_ops (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'82] (24780: Int16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int16BW.t = Any.any_l () ]  [ return''0 (result:Int16BW.t)-> return' {result} ] 
  
  let rec promoted35__test_bitwise_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt32BW.bw_xor ([%#sinteger_ops'84] (3221225475: UInt32BW.t)) ([%#sinteger_ops'83] (1073840130: UInt32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ] 
    [ return''0 (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted34__test_bitwise_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'85] (2147581953: UInt32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32BW.t = Any.any_l () ]  [ return''0 (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted33__test_bitwise_ops (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int32BW.bw_xor ([%#sinteger_ops'87] (1073741839: Int32BW.t)) ([%#sinteger_ops'86] (1073745665: Int32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ] 
    [ return''0 (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted32__test_bitwise_ops (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'88] (3854: Int32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32BW.t = Any.any_l () ]  [ return''0 (result:Int32BW.t)-> return' {result} ] 
  
  let rec promoted31__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt64BW.bw_xor ([%#sinteger_ops'90] (13835321938072829955: UInt64BW.t)) ([%#sinteger_ops'89] (9223838229784952833: UInt64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted30__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'91] (4612064250427342850: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted29__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int64BW.bw_xor ([%#sinteger_ops'93] (4611686018437454224: Int64BW.t)) ([%#sinteger_ops'92] (5226577450909599872: Int64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted28__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'94] (614891432474382608: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted27__test_bitwise_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt128BW.bw_xor ([%#sinteger_ops'96] (4514840875923203424259: UInt128BW.t)) ([%#sinteger_ops'95] (3108276842612989624321: UInt128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ] 
    [ return''0 (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted26__test_bitwise_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops'97] (1701712519031706091522: UInt128BW.t) ] s1 | s1 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () ]  [ return''0 (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted25__test_bitwise_ops (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int128BW.bw_xor ([%#sinteger_ops'99] (4514840875923203424259: Int128BW.t)) ([%#sinteger_ops'98] (3108276842612989624321: Int128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ] 
    [ return''0 (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted24__test_bitwise_ops (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops'100] (1701712519031706091522: Int128BW.t) ] s1 | s1 = return''0 {_0} ]
     ]
     [ & _0: Int128BW.t = Any.any_l () ]  [ return''0 (result:Int128BW.t)-> return' {result} ] 
  
  let rec promoted23__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt64BW.bw_xor ([%#sinteger_ops'102] (240: UInt64BW.t)) ([%#sinteger_ops'101] (60: UInt64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted22__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'103] (204: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted21__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.bw_xor ([%#sinteger_ops'105] (113: Int64BW.t)) ([%#sinteger_ops'104] (61: Int64BW.t)) ] 
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted20__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'106] (76: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted19__test_bitwise_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.bw_not ([%#sinteger_ops'107] (240: UInt8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ] 
    [ return''0 (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted18__test_bitwise_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'108] (15: UInt8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8BW.t = Any.any_l () ]  [ return''0 (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted17__test_bitwise_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.bw_not ([%#sinteger_ops'109] (113: Int8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted16__test_bitwise_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'110] (142: Int8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8BW.t = Any.any_l () ]  [ return''0 (result:Int8BW.t)-> return' {result} ] 
  
  let rec promoted15__test_bitwise_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16BW.bw_not ([%#sinteger_ops'111] (42225: UInt16BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ] 
    [ return''0 (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted14__test_bitwise_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'112] (23310: UInt16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16BW.t = Any.any_l () ]  [ return''0 (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted13__test_bitwise_ops (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16BW.bw_not ([%#sinteger_ops'113] (13553: Int16BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ] 
    [ return''0 (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted12__test_bitwise_ops (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'114] (51982: Int16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int16BW.t = Any.any_l () ]  [ return''0 (result:Int16BW.t)-> return' {result} ] 
  
  let rec promoted11__test_bitwise_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32BW.bw_not ([%#sinteger_ops'115] (3221225475: UInt32BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ] 
    [ return''0 (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted10__test_bitwise_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'116] (1073741820: UInt32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32BW.t = Any.any_l () ]  [ return''0 (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted9__test_bitwise_ops (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32BW.bw_not ([%#sinteger_ops'117] (1073741839: Int32BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ] 
    [ return''0 (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted8__test_bitwise_ops (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'118] (3221225456: Int32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32BW.t = Any.any_l () ]  [ return''0 (result:Int32BW.t)-> return' {result} ] 
  
  let rec promoted7__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.bw_not ([%#sinteger_ops'119] (13835321938072829955: UInt64BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted6__test_bitwise_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'120] (4611422135636721660: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted5__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.bw_not ([%#sinteger_ops'121] (4611686018437454224: Int64BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted4__test_bitwise_ops (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'122] (13835058055272097391: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted3__test_bitwise_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128BW.bw_not ([%#sinteger_ops'123] (4514840875923203424259: UInt128BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ] 
    [ return''0 (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_bitwise_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops'124] (340282366920938458948533731508564787196: UInt128BW.t) ] s1
      | s1 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () ]  [ return''0 (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted1__test_bitwise_ops (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128BW.bw_not ([%#sinteger_ops'125] (4514840875923203424259: Int128BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ] 
    [ return''0 (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_bitwise_ops (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops'126] (340282366920938458948533731508564787196: Int128BW.t) ] s1
      | s1 = return''0 {_0} ]
     ]
     [ & _0: Int128BW.t = Any.any_l () ]  [ return''0 (result:Int128BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_bitwise_ops[#"integer_ops.rs" 5 0 5 25] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted91__test_bitwise_ops (fun (pr91:UInt8BW.t) ->  [ &_1012 <- pr91 ] s1)
      | s1 = promoted90__test_bitwise_ops (fun (pr90:UInt8BW.t) ->  [ &_1011 <- pr90 ] s2)
      | s2 =  [ &_2 <- { _p0 = _1012; _p1 = _1011 } ] s3
      | s3 =  [ &left_val <- _2._p0 ] s4
      | s4 =  [ &right_val <- _2._p1 ] s5
      | s5 =  [ &_9 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_9 = false} (! bb2) | br1 -> {_9} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted89__test_bitwise_ops (fun (pr89:Int8BW.t) ->  [ &_1010 <- pr89 ] s1)
      | s1 = promoted88__test_bitwise_ops (fun (pr88:Int8BW.t) ->  [ &_1009 <- pr88 ] s2)
      | s2 =  [ &_22 <- { _p0'0 = _1010; _p1'0 = _1009 } ] s3
      | s3 =  [ &left_val'0 <- _22._p0'0 ] s4
      | s4 =  [ &right_val'0 <- _22._p1'0 ] s5
      | s5 =  [ &_29 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_29 = false} (! bb4) | br1 -> {_29} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = promoted87__test_bitwise_ops (fun (pr87:UInt16BW.t) ->  [ &_1008 <- pr87 ] s1)
      | s1 = promoted86__test_bitwise_ops (fun (pr86:UInt16BW.t) ->  [ &_1007 <- pr86 ] s2)
      | s2 =  [ &_42 <- { _p0'1 = _1008; _p1'1 = _1007 } ] s3
      | s3 =  [ &left_val'1 <- _42._p0'1 ] s4
      | s4 =  [ &right_val'1 <- _42._p1'1 ] s5
      | s5 =  [ &_49 <- left_val'1 = right_val'1 ] s6
      | s6 = any [ br0 -> {_49 = false} (! bb6) | br1 -> {_49} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = promoted85__test_bitwise_ops (fun (pr85:Int16BW.t) ->  [ &_1006 <- pr85 ] s1)
      | s1 = promoted84__test_bitwise_ops (fun (pr84:Int16BW.t) ->  [ &_1005 <- pr84 ] s2)
      | s2 =  [ &_62 <- { _p0'2 = _1006; _p1'2 = _1005 } ] s3
      | s3 =  [ &left_val'2 <- _62._p0'2 ] s4
      | s4 =  [ &right_val'2 <- _62._p1'2 ] s5
      | s5 =  [ &_69 <- left_val'2 = right_val'2 ] s6
      | s6 = any [ br0 -> {_69 = false} (! bb8) | br1 -> {_69} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = promoted83__test_bitwise_ops (fun (pr83:UInt32BW.t) ->  [ &_1004 <- pr83 ] s1)
      | s1 = promoted82__test_bitwise_ops (fun (pr82:UInt32BW.t) ->  [ &_1003 <- pr82 ] s2)
      | s2 =  [ &_82 <- { _p0'3 = _1004; _p1'3 = _1003 } ] s3
      | s3 =  [ &left_val'3 <- _82._p0'3 ] s4
      | s4 =  [ &right_val'3 <- _82._p1'3 ] s5
      | s5 =  [ &_89 <- left_val'3 = right_val'3 ] s6
      | s6 = any [ br0 -> {_89 = false} (! bb10) | br1 -> {_89} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = promoted81__test_bitwise_ops (fun (pr81:Int32BW.t) ->  [ &_1002 <- pr81 ] s1)
      | s1 = promoted80__test_bitwise_ops (fun (pr80:Int32BW.t) ->  [ &_1001 <- pr80 ] s2)
      | s2 =  [ &_102 <- { _p0'4 = _1002; _p1'4 = _1001 } ] s3
      | s3 =  [ &left_val'4 <- _102._p0'4 ] s4
      | s4 =  [ &right_val'4 <- _102._p1'4 ] s5
      | s5 =  [ &_109 <- left_val'4 = right_val'4 ] s6
      | s6 = any [ br0 -> {_109 = false} (! bb12) | br1 -> {_109} (! bb11) ]  ]
    
    | bb11 = s0
      [ s0 = promoted79__test_bitwise_ops (fun (pr79:UInt64BW.t) ->  [ &_1000 <- pr79 ] s1)
      | s1 = promoted78__test_bitwise_ops (fun (pr78:UInt64BW.t) ->  [ &_999 <- pr78 ] s2)
      | s2 =  [ &_122 <- { _p0'5 = _1000; _p1'5 = _999 } ] s3
      | s3 =  [ &left_val'5 <- _122._p0'5 ] s4
      | s4 =  [ &right_val'5 <- _122._p1'5 ] s5
      | s5 =  [ &_129 <- left_val'5 = right_val'5 ] s6
      | s6 = any [ br0 -> {_129 = false} (! bb14) | br1 -> {_129} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = promoted77__test_bitwise_ops (fun (pr77:Int64BW.t) ->  [ &_998 <- pr77 ] s1)
      | s1 = promoted76__test_bitwise_ops (fun (pr76:Int64BW.t) ->  [ &_997 <- pr76 ] s2)
      | s2 =  [ &_142 <- { _p0'6 = _998; _p1'6 = _997 } ] s3
      | s3 =  [ &left_val'6 <- _142._p0'6 ] s4
      | s4 =  [ &right_val'6 <- _142._p1'6 ] s5
      | s5 =  [ &_149 <- left_val'6 = right_val'6 ] s6
      | s6 = any [ br0 -> {_149 = false} (! bb16) | br1 -> {_149} (! bb15) ]  ]
    
    | bb15 = s0
      [ s0 = promoted75__test_bitwise_ops (fun (pr75:UInt128BW.t) ->  [ &_996 <- pr75 ] s1)
      | s1 = promoted74__test_bitwise_ops (fun (pr74:UInt128BW.t) ->  [ &_995 <- pr74 ] s2)
      | s2 =  [ &_162 <- { _p0'7 = _996; _p1'7 = _995 } ] s3
      | s3 =  [ &left_val'7 <- _162._p0'7 ] s4
      | s4 =  [ &right_val'7 <- _162._p1'7 ] s5
      | s5 =  [ &_169 <- left_val'7 = right_val'7 ] s6
      | s6 = any [ br0 -> {_169 = false} (! bb18) | br1 -> {_169} (! bb17) ]  ]
    
    | bb17 = s0
      [ s0 = promoted73__test_bitwise_ops (fun (pr73:Int128BW.t) ->  [ &_994 <- pr73 ] s1)
      | s1 = promoted72__test_bitwise_ops (fun (pr72:Int128BW.t) ->  [ &_993 <- pr72 ] s2)
      | s2 =  [ &_182 <- { _p0'8 = _994; _p1'8 = _993 } ] s3
      | s3 =  [ &left_val'8 <- _182._p0'8 ] s4
      | s4 =  [ &right_val'8 <- _182._p1'8 ] s5
      | s5 =  [ &_189 <- left_val'8 = right_val'8 ] s6
      | s6 = any [ br0 -> {_189 = false} (! bb20) | br1 -> {_189} (! bb19) ]  ]
    
    | bb19 = s0
      [ s0 = promoted71__test_bitwise_ops (fun (pr71:UInt64BW.t) ->  [ &_992 <- pr71 ] s1)
      | s1 = promoted70__test_bitwise_ops (fun (pr70:UInt64BW.t) ->  [ &_991 <- pr70 ] s2)
      | s2 =  [ &_202 <- { _p0'9 = _992; _p1'9 = _991 } ] s3
      | s3 =  [ &left_val'9 <- _202._p0'9 ] s4
      | s4 =  [ &right_val'9 <- _202._p1'9 ] s5
      | s5 =  [ &_209 <- left_val'9 = right_val'9 ] s6
      | s6 = any [ br0 -> {_209 = false} (! bb22) | br1 -> {_209} (! bb21) ]  ]
    
    | bb21 = s0
      [ s0 = promoted69__test_bitwise_ops (fun (pr69:Int64BW.t) ->  [ &_990 <- pr69 ] s1)
      | s1 = promoted68__test_bitwise_ops (fun (pr68:Int64BW.t) ->  [ &_989 <- pr68 ] s2)
      | s2 =  [ &_222 <- { _p0'10 = _990; _p1'10 = _989 } ] s3
      | s3 =  [ &left_val'10 <- _222._p0'10 ] s4
      | s4 =  [ &right_val'10 <- _222._p1'10 ] s5
      | s5 =  [ &_229 <- left_val'10 = right_val'10 ] s6
      | s6 = any [ br0 -> {_229 = false} (! bb24) | br1 -> {_229} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = promoted67__test_bitwise_ops (fun (pr67:UInt8BW.t) ->  [ &_988 <- pr67 ] s1)
      | s1 = promoted66__test_bitwise_ops (fun (pr66:UInt8BW.t) ->  [ &_987 <- pr66 ] s2)
      | s2 =  [ &_242 <- { _p0 = _988; _p1 = _987 } ] s3
      | s3 =  [ &left_val'11 <- _242._p0 ] s4
      | s4 =  [ &right_val'11 <- _242._p1 ] s5
      | s5 =  [ &_249 <- left_val'11 = right_val'11 ] s6
      | s6 = any [ br0 -> {_249 = false} (! bb26) | br1 -> {_249} (! bb25) ]  ]
    
    | bb25 = s0
      [ s0 = promoted65__test_bitwise_ops (fun (pr65:Int8BW.t) ->  [ &_986 <- pr65 ] s1)
      | s1 = promoted64__test_bitwise_ops (fun (pr64:Int8BW.t) ->  [ &_985 <- pr64 ] s2)
      | s2 =  [ &_262 <- { _p0'0 = _986; _p1'0 = _985 } ] s3
      | s3 =  [ &left_val'12 <- _262._p0'0 ] s4
      | s4 =  [ &right_val'12 <- _262._p1'0 ] s5
      | s5 =  [ &_269 <- left_val'12 = right_val'12 ] s6
      | s6 = any [ br0 -> {_269 = false} (! bb28) | br1 -> {_269} (! bb27) ]  ]
    
    | bb27 = s0
      [ s0 = promoted63__test_bitwise_ops (fun (pr63:UInt16BW.t) ->  [ &_984 <- pr63 ] s1)
      | s1 = promoted62__test_bitwise_ops (fun (pr62:UInt16BW.t) ->  [ &_983 <- pr62 ] s2)
      | s2 =  [ &_282 <- { _p0'1 = _984; _p1'1 = _983 } ] s3
      | s3 =  [ &left_val'13 <- _282._p0'1 ] s4
      | s4 =  [ &right_val'13 <- _282._p1'1 ] s5
      | s5 =  [ &_289 <- left_val'13 = right_val'13 ] s6
      | s6 = any [ br0 -> {_289 = false} (! bb30) | br1 -> {_289} (! bb29) ]  ]
    
    | bb29 = s0
      [ s0 = promoted61__test_bitwise_ops (fun (pr61:Int16BW.t) ->  [ &_982 <- pr61 ] s1)
      | s1 = promoted60__test_bitwise_ops (fun (pr60:Int16BW.t) ->  [ &_981 <- pr60 ] s2)
      | s2 =  [ &_302 <- { _p0'2 = _982; _p1'2 = _981 } ] s3
      | s3 =  [ &left_val'14 <- _302._p0'2 ] s4
      | s4 =  [ &right_val'14 <- _302._p1'2 ] s5
      | s5 =  [ &_309 <- left_val'14 = right_val'14 ] s6
      | s6 = any [ br0 -> {_309 = false} (! bb32) | br1 -> {_309} (! bb31) ]  ]
    
    | bb31 = s0
      [ s0 = promoted59__test_bitwise_ops (fun (pr59:UInt32BW.t) ->  [ &_980 <- pr59 ] s1)
      | s1 = promoted58__test_bitwise_ops (fun (pr58:UInt32BW.t) ->  [ &_979 <- pr58 ] s2)
      | s2 =  [ &_322 <- { _p0'3 = _980; _p1'3 = _979 } ] s3
      | s3 =  [ &left_val'15 <- _322._p0'3 ] s4
      | s4 =  [ &right_val'15 <- _322._p1'3 ] s5
      | s5 =  [ &_329 <- left_val'15 = right_val'15 ] s6
      | s6 = any [ br0 -> {_329 = false} (! bb34) | br1 -> {_329} (! bb33) ]  ]
    
    | bb33 = s0
      [ s0 = promoted57__test_bitwise_ops (fun (pr57:Int32BW.t) ->  [ &_978 <- pr57 ] s1)
      | s1 = promoted56__test_bitwise_ops (fun (pr56:Int32BW.t) ->  [ &_977 <- pr56 ] s2)
      | s2 =  [ &_342 <- { _p0'4 = _978; _p1'4 = _977 } ] s3
      | s3 =  [ &left_val'16 <- _342._p0'4 ] s4
      | s4 =  [ &right_val'16 <- _342._p1'4 ] s5
      | s5 =  [ &_349 <- left_val'16 = right_val'16 ] s6
      | s6 = any [ br0 -> {_349 = false} (! bb36) | br1 -> {_349} (! bb35) ]  ]
    
    | bb35 = s0
      [ s0 = promoted55__test_bitwise_ops (fun (pr55:UInt64BW.t) ->  [ &_976 <- pr55 ] s1)
      | s1 = promoted54__test_bitwise_ops (fun (pr54:UInt64BW.t) ->  [ &_975 <- pr54 ] s2)
      | s2 =  [ &_362 <- { _p0'5 = _976; _p1'5 = _975 } ] s3
      | s3 =  [ &left_val'17 <- _362._p0'5 ] s4
      | s4 =  [ &right_val'17 <- _362._p1'5 ] s5
      | s5 =  [ &_369 <- left_val'17 = right_val'17 ] s6
      | s6 = any [ br0 -> {_369 = false} (! bb38) | br1 -> {_369} (! bb37) ]  ]
    
    | bb37 = s0
      [ s0 = promoted53__test_bitwise_ops (fun (pr53:Int64BW.t) ->  [ &_974 <- pr53 ] s1)
      | s1 = promoted52__test_bitwise_ops (fun (pr52:Int64BW.t) ->  [ &_973 <- pr52 ] s2)
      | s2 =  [ &_382 <- { _p0'6 = _974; _p1'6 = _973 } ] s3
      | s3 =  [ &left_val'18 <- _382._p0'6 ] s4
      | s4 =  [ &right_val'18 <- _382._p1'6 ] s5
      | s5 =  [ &_389 <- left_val'18 = right_val'18 ] s6
      | s6 = any [ br0 -> {_389 = false} (! bb40) | br1 -> {_389} (! bb39) ]  ]
    
    | bb39 = s0
      [ s0 = promoted51__test_bitwise_ops (fun (pr51:UInt128BW.t) ->  [ &_972 <- pr51 ] s1)
      | s1 = promoted50__test_bitwise_ops (fun (pr50:UInt128BW.t) ->  [ &_971 <- pr50 ] s2)
      | s2 =  [ &_402 <- { _p0'7 = _972; _p1'7 = _971 } ] s3
      | s3 =  [ &left_val'19 <- _402._p0'7 ] s4
      | s4 =  [ &right_val'19 <- _402._p1'7 ] s5
      | s5 =  [ &_409 <- left_val'19 = right_val'19 ] s6
      | s6 = any [ br0 -> {_409 = false} (! bb42) | br1 -> {_409} (! bb41) ]  ]
    
    | bb41 = s0
      [ s0 = promoted49__test_bitwise_ops (fun (pr49:Int128BW.t) ->  [ &_970 <- pr49 ] s1)
      | s1 = promoted48__test_bitwise_ops (fun (pr48:Int128BW.t) ->  [ &_969 <- pr48 ] s2)
      | s2 =  [ &_422 <- { _p0'8 = _970; _p1'8 = _969 } ] s3
      | s3 =  [ &left_val'20 <- _422._p0'8 ] s4
      | s4 =  [ &right_val'20 <- _422._p1'8 ] s5
      | s5 =  [ &_429 <- left_val'20 = right_val'20 ] s6
      | s6 = any [ br0 -> {_429 = false} (! bb44) | br1 -> {_429} (! bb43) ]  ]
    
    | bb43 = s0
      [ s0 = promoted47__test_bitwise_ops (fun (pr47:UInt64BW.t) ->  [ &_968 <- pr47 ] s1)
      | s1 = promoted46__test_bitwise_ops (fun (pr46:UInt64BW.t) ->  [ &_967 <- pr46 ] s2)
      | s2 =  [ &_442 <- { _p0'9 = _968; _p1'9 = _967 } ] s3
      | s3 =  [ &left_val'21 <- _442._p0'9 ] s4
      | s4 =  [ &right_val'21 <- _442._p1'9 ] s5
      | s5 =  [ &_449 <- left_val'21 = right_val'21 ] s6
      | s6 = any [ br0 -> {_449 = false} (! bb46) | br1 -> {_449} (! bb45) ]  ]
    
    | bb45 = s0
      [ s0 = promoted45__test_bitwise_ops (fun (pr45:Int64BW.t) ->  [ &_966 <- pr45 ] s1)
      | s1 = promoted44__test_bitwise_ops (fun (pr44:Int64BW.t) ->  [ &_965 <- pr44 ] s2)
      | s2 =  [ &_462 <- { _p0'10 = _966; _p1'10 = _965 } ] s3
      | s3 =  [ &left_val'22 <- _462._p0'10 ] s4
      | s4 =  [ &right_val'22 <- _462._p1'10 ] s5
      | s5 =  [ &_469 <- left_val'22 = right_val'22 ] s6
      | s6 = any [ br0 -> {_469 = false} (! bb48) | br1 -> {_469} (! bb47) ]  ]
    
    | bb47 = s0
      [ s0 = promoted43__test_bitwise_ops (fun (pr43:UInt8BW.t) ->  [ &_964 <- pr43 ] s1)
      | s1 = promoted42__test_bitwise_ops (fun (pr42:UInt8BW.t) ->  [ &_963 <- pr42 ] s2)
      | s2 =  [ &_482 <- { _p0 = _964; _p1 = _963 } ] s3
      | s3 =  [ &left_val'23 <- _482._p0 ] s4
      | s4 =  [ &right_val'23 <- _482._p1 ] s5
      | s5 =  [ &_489 <- left_val'23 = right_val'23 ] s6
      | s6 = any [ br0 -> {_489 = false} (! bb50) | br1 -> {_489} (! bb49) ]  ]
    
    | bb49 = s0
      [ s0 = promoted41__test_bitwise_ops (fun (pr41:Int8BW.t) ->  [ &_962 <- pr41 ] s1)
      | s1 = promoted40__test_bitwise_ops (fun (pr40:Int8BW.t) ->  [ &_961 <- pr40 ] s2)
      | s2 =  [ &_502 <- { _p0'0 = _962; _p1'0 = _961 } ] s3
      | s3 =  [ &left_val'24 <- _502._p0'0 ] s4
      | s4 =  [ &right_val'24 <- _502._p1'0 ] s5
      | s5 =  [ &_509 <- left_val'24 = right_val'24 ] s6
      | s6 = any [ br0 -> {_509 = false} (! bb52) | br1 -> {_509} (! bb51) ]  ]
    
    | bb51 = s0
      [ s0 = promoted39__test_bitwise_ops (fun (pr39:UInt16BW.t) ->  [ &_960 <- pr39 ] s1)
      | s1 = promoted38__test_bitwise_ops (fun (pr38:UInt16BW.t) ->  [ &_959 <- pr38 ] s2)
      | s2 =  [ &_522 <- { _p0'1 = _960; _p1'1 = _959 } ] s3
      | s3 =  [ &left_val'25 <- _522._p0'1 ] s4
      | s4 =  [ &right_val'25 <- _522._p1'1 ] s5
      | s5 =  [ &_529 <- left_val'25 = right_val'25 ] s6
      | s6 = any [ br0 -> {_529 = false} (! bb54) | br1 -> {_529} (! bb53) ]  ]
    
    | bb53 = s0
      [ s0 = promoted37__test_bitwise_ops (fun (pr37:Int16BW.t) ->  [ &_958 <- pr37 ] s1)
      | s1 = promoted36__test_bitwise_ops (fun (pr36:Int16BW.t) ->  [ &_957 <- pr36 ] s2)
      | s2 =  [ &_542 <- { _p0'2 = _958; _p1'2 = _957 } ] s3
      | s3 =  [ &left_val'26 <- _542._p0'2 ] s4
      | s4 =  [ &right_val'26 <- _542._p1'2 ] s5
      | s5 =  [ &_549 <- left_val'26 = right_val'26 ] s6
      | s6 = any [ br0 -> {_549 = false} (! bb56) | br1 -> {_549} (! bb55) ]  ]
    
    | bb55 = s0
      [ s0 = promoted35__test_bitwise_ops (fun (pr35:UInt32BW.t) ->  [ &_956 <- pr35 ] s1)
      | s1 = promoted34__test_bitwise_ops (fun (pr34:UInt32BW.t) ->  [ &_955 <- pr34 ] s2)
      | s2 =  [ &_562 <- { _p0'3 = _956; _p1'3 = _955 } ] s3
      | s3 =  [ &left_val'27 <- _562._p0'3 ] s4
      | s4 =  [ &right_val'27 <- _562._p1'3 ] s5
      | s5 =  [ &_569 <- left_val'27 = right_val'27 ] s6
      | s6 = any [ br0 -> {_569 = false} (! bb58) | br1 -> {_569} (! bb57) ]  ]
    
    | bb57 = s0
      [ s0 = promoted33__test_bitwise_ops (fun (pr33:Int32BW.t) ->  [ &_954 <- pr33 ] s1)
      | s1 = promoted32__test_bitwise_ops (fun (pr32:Int32BW.t) ->  [ &_953 <- pr32 ] s2)
      | s2 =  [ &_582 <- { _p0'4 = _954; _p1'4 = _953 } ] s3
      | s3 =  [ &left_val'28 <- _582._p0'4 ] s4
      | s4 =  [ &right_val'28 <- _582._p1'4 ] s5
      | s5 =  [ &_589 <- left_val'28 = right_val'28 ] s6
      | s6 = any [ br0 -> {_589 = false} (! bb60) | br1 -> {_589} (! bb59) ]  ]
    
    | bb59 = s0
      [ s0 = promoted31__test_bitwise_ops (fun (pr31:UInt64BW.t) ->  [ &_952 <- pr31 ] s1)
      | s1 = promoted30__test_bitwise_ops (fun (pr30:UInt64BW.t) ->  [ &_951 <- pr30 ] s2)
      | s2 =  [ &_602 <- { _p0'5 = _952; _p1'5 = _951 } ] s3
      | s3 =  [ &left_val'29 <- _602._p0'5 ] s4
      | s4 =  [ &right_val'29 <- _602._p1'5 ] s5
      | s5 =  [ &_609 <- left_val'29 = right_val'29 ] s6
      | s6 = any [ br0 -> {_609 = false} (! bb62) | br1 -> {_609} (! bb61) ]  ]
    
    | bb61 = s0
      [ s0 = promoted29__test_bitwise_ops (fun (pr29:Int64BW.t) ->  [ &_950 <- pr29 ] s1)
      | s1 = promoted28__test_bitwise_ops (fun (pr28:Int64BW.t) ->  [ &_949 <- pr28 ] s2)
      | s2 =  [ &_622 <- { _p0'6 = _950; _p1'6 = _949 } ] s3
      | s3 =  [ &left_val'30 <- _622._p0'6 ] s4
      | s4 =  [ &right_val'30 <- _622._p1'6 ] s5
      | s5 =  [ &_629 <- left_val'30 = right_val'30 ] s6
      | s6 = any [ br0 -> {_629 = false} (! bb64) | br1 -> {_629} (! bb63) ]  ]
    
    | bb63 = s0
      [ s0 = promoted27__test_bitwise_ops (fun (pr27:UInt128BW.t) ->  [ &_948 <- pr27 ] s1)
      | s1 = promoted26__test_bitwise_ops (fun (pr26:UInt128BW.t) ->  [ &_947 <- pr26 ] s2)
      | s2 =  [ &_642 <- { _p0'7 = _948; _p1'7 = _947 } ] s3
      | s3 =  [ &left_val'31 <- _642._p0'7 ] s4
      | s4 =  [ &right_val'31 <- _642._p1'7 ] s5
      | s5 =  [ &_649 <- left_val'31 = right_val'31 ] s6
      | s6 = any [ br0 -> {_649 = false} (! bb66) | br1 -> {_649} (! bb65) ]  ]
    
    | bb65 = s0
      [ s0 = promoted25__test_bitwise_ops (fun (pr25:Int128BW.t) ->  [ &_946 <- pr25 ] s1)
      | s1 = promoted24__test_bitwise_ops (fun (pr24:Int128BW.t) ->  [ &_945 <- pr24 ] s2)
      | s2 =  [ &_662 <- { _p0'8 = _946; _p1'8 = _945 } ] s3
      | s3 =  [ &left_val'32 <- _662._p0'8 ] s4
      | s4 =  [ &right_val'32 <- _662._p1'8 ] s5
      | s5 =  [ &_669 <- left_val'32 = right_val'32 ] s6
      | s6 = any [ br0 -> {_669 = false} (! bb68) | br1 -> {_669} (! bb67) ]  ]
    
    | bb67 = s0
      [ s0 = promoted23__test_bitwise_ops (fun (pr23:UInt64BW.t) ->  [ &_944 <- pr23 ] s1)
      | s1 = promoted22__test_bitwise_ops (fun (pr22:UInt64BW.t) ->  [ &_943 <- pr22 ] s2)
      | s2 =  [ &_682 <- { _p0'9 = _944; _p1'9 = _943 } ] s3
      | s3 =  [ &left_val'33 <- _682._p0'9 ] s4
      | s4 =  [ &right_val'33 <- _682._p1'9 ] s5
      | s5 =  [ &_689 <- left_val'33 = right_val'33 ] s6
      | s6 = any [ br0 -> {_689 = false} (! bb70) | br1 -> {_689} (! bb69) ]  ]
    
    | bb69 = s0
      [ s0 = promoted21__test_bitwise_ops (fun (pr21:Int64BW.t) ->  [ &_942 <- pr21 ] s1)
      | s1 = promoted20__test_bitwise_ops (fun (pr20:Int64BW.t) ->  [ &_941 <- pr20 ] s2)
      | s2 =  [ &_702 <- { _p0'10 = _942; _p1'10 = _941 } ] s3
      | s3 =  [ &left_val'34 <- _702._p0'10 ] s4
      | s4 =  [ &right_val'34 <- _702._p1'10 ] s5
      | s5 =  [ &_709 <- left_val'34 = right_val'34 ] s6
      | s6 = any [ br0 -> {_709 = false} (! bb72) | br1 -> {_709} (! bb71) ]  ]
    
    | bb71 = s0
      [ s0 = promoted19__test_bitwise_ops (fun (pr19:UInt8BW.t) ->  [ &_940 <- pr19 ] s1)
      | s1 = promoted18__test_bitwise_ops (fun (pr18:UInt8BW.t) ->  [ &_939 <- pr18 ] s2)
      | s2 =  [ &_722 <- { _p0 = _940; _p1 = _939 } ] s3
      | s3 =  [ &left_val'35 <- _722._p0 ] s4
      | s4 =  [ &right_val'35 <- _722._p1 ] s5
      | s5 =  [ &_729 <- left_val'35 = right_val'35 ] s6
      | s6 = any [ br0 -> {_729 = false} (! bb74) | br1 -> {_729} (! bb73) ]  ]
    
    | bb73 = s0
      [ s0 = promoted17__test_bitwise_ops (fun (pr17:Int8BW.t) ->  [ &_938 <- pr17 ] s1)
      | s1 = promoted16__test_bitwise_ops (fun (pr16:Int8BW.t) ->  [ &_937 <- pr16 ] s2)
      | s2 =  [ &_742 <- { _p0'0 = _938; _p1'0 = _937 } ] s3
      | s3 =  [ &left_val'36 <- _742._p0'0 ] s4
      | s4 =  [ &right_val'36 <- _742._p1'0 ] s5
      | s5 =  [ &_749 <- left_val'36 = right_val'36 ] s6
      | s6 = any [ br0 -> {_749 = false} (! bb76) | br1 -> {_749} (! bb75) ]  ]
    
    | bb75 = s0
      [ s0 = promoted15__test_bitwise_ops (fun (pr15:UInt16BW.t) ->  [ &_936 <- pr15 ] s1)
      | s1 = promoted14__test_bitwise_ops (fun (pr14:UInt16BW.t) ->  [ &_935 <- pr14 ] s2)
      | s2 =  [ &_762 <- { _p0'1 = _936; _p1'1 = _935 } ] s3
      | s3 =  [ &left_val'37 <- _762._p0'1 ] s4
      | s4 =  [ &right_val'37 <- _762._p1'1 ] s5
      | s5 =  [ &_769 <- left_val'37 = right_val'37 ] s6
      | s6 = any [ br0 -> {_769 = false} (! bb78) | br1 -> {_769} (! bb77) ]  ]
    
    | bb77 = s0
      [ s0 = promoted13__test_bitwise_ops (fun (pr13:Int16BW.t) ->  [ &_934 <- pr13 ] s1)
      | s1 = promoted12__test_bitwise_ops (fun (pr12:Int16BW.t) ->  [ &_933 <- pr12 ] s2)
      | s2 =  [ &_782 <- { _p0'2 = _934; _p1'2 = _933 } ] s3
      | s3 =  [ &left_val'38 <- _782._p0'2 ] s4
      | s4 =  [ &right_val'38 <- _782._p1'2 ] s5
      | s5 =  [ &_789 <- left_val'38 = right_val'38 ] s6
      | s6 = any [ br0 -> {_789 = false} (! bb80) | br1 -> {_789} (! bb79) ]  ]
    
    | bb79 = s0
      [ s0 = promoted11__test_bitwise_ops (fun (pr11:UInt32BW.t) ->  [ &_932 <- pr11 ] s1)
      | s1 = promoted10__test_bitwise_ops (fun (pr10:UInt32BW.t) ->  [ &_931 <- pr10 ] s2)
      | s2 =  [ &_802 <- { _p0'3 = _932; _p1'3 = _931 } ] s3
      | s3 =  [ &left_val'39 <- _802._p0'3 ] s4
      | s4 =  [ &right_val'39 <- _802._p1'3 ] s5
      | s5 =  [ &_809 <- left_val'39 = right_val'39 ] s6
      | s6 = any [ br0 -> {_809 = false} (! bb82) | br1 -> {_809} (! bb81) ]  ]
    
    | bb81 = s0
      [ s0 = promoted9__test_bitwise_ops (fun (pr9:Int32BW.t) ->  [ &_930 <- pr9 ] s1)
      | s1 = promoted8__test_bitwise_ops (fun (pr8:Int32BW.t) ->  [ &_929 <- pr8 ] s2)
      | s2 =  [ &_822 <- { _p0'4 = _930; _p1'4 = _929 } ] s3
      | s3 =  [ &left_val'40 <- _822._p0'4 ] s4
      | s4 =  [ &right_val'40 <- _822._p1'4 ] s5
      | s5 =  [ &_829 <- left_val'40 = right_val'40 ] s6
      | s6 = any [ br0 -> {_829 = false} (! bb84) | br1 -> {_829} (! bb83) ]  ]
    
    | bb83 = s0
      [ s0 = promoted7__test_bitwise_ops (fun (pr7:UInt64BW.t) ->  [ &_928 <- pr7 ] s1)
      | s1 = promoted6__test_bitwise_ops (fun (pr6:UInt64BW.t) ->  [ &_927 <- pr6 ] s2)
      | s2 =  [ &_842 <- { _p0'5 = _928; _p1'5 = _927 } ] s3
      | s3 =  [ &left_val'41 <- _842._p0'5 ] s4
      | s4 =  [ &right_val'41 <- _842._p1'5 ] s5
      | s5 =  [ &_849 <- left_val'41 = right_val'41 ] s6
      | s6 = any [ br0 -> {_849 = false} (! bb86) | br1 -> {_849} (! bb85) ]  ]
    
    | bb85 = s0
      [ s0 = promoted5__test_bitwise_ops (fun (pr5:Int64BW.t) ->  [ &_926 <- pr5 ] s1)
      | s1 = promoted4__test_bitwise_ops (fun (pr4:Int64BW.t) ->  [ &_925 <- pr4 ] s2)
      | s2 =  [ &_862 <- { _p0'6 = _926; _p1'6 = _925 } ] s3
      | s3 =  [ &left_val'42 <- _862._p0'6 ] s4
      | s4 =  [ &right_val'42 <- _862._p1'6 ] s5
      | s5 =  [ &_869 <- left_val'42 = right_val'42 ] s6
      | s6 = any [ br0 -> {_869 = false} (! bb88) | br1 -> {_869} (! bb87) ]  ]
    
    | bb87 = s0
      [ s0 = promoted3__test_bitwise_ops (fun (pr3:UInt128BW.t) ->  [ &_924 <- pr3 ] s1)
      | s1 = promoted2__test_bitwise_ops (fun (pr2:UInt128BW.t) ->  [ &_923 <- pr2 ] s2)
      | s2 =  [ &_882 <- { _p0'7 = _924; _p1'7 = _923 } ] s3
      | s3 =  [ &left_val'43 <- _882._p0'7 ] s4
      | s4 =  [ &right_val'43 <- _882._p1'7 ] s5
      | s5 =  [ &_889 <- left_val'43 = right_val'43 ] s6
      | s6 = any [ br0 -> {_889 = false} (! bb90) | br1 -> {_889} (! bb89) ]  ]
    
    | bb89 = s0
      [ s0 = promoted1__test_bitwise_ops (fun (pr1:Int128BW.t) ->  [ &_922 <- pr1 ] s1)
      | s1 = promoted0__test_bitwise_ops (fun (pr0:Int128BW.t) ->  [ &_921 <- pr0 ] s2)
      | s2 =  [ &_902 <- { _p0'8 = _922; _p1'8 = _921 } ] s3
      | s3 =  [ &left_val'44 <- _902._p0'8 ] s4
      | s4 =  [ &right_val'44 <- _902._p1'8 ] s5
      | s5 =  [ &_909 <- left_val'44 = right_val'44 ] s6
      | s6 = any [ br0 -> {_909 = false} (! bb92) | br1 -> {_909} (! bb91) ]  ]
    
    | bb91 = return''0 {_0}
    | bb92 = s0
      [ s0 =  [ &kind'44 <- C_Eq ] s1
      | s1 =  [ &_917 <- left_val'44 ] s2
      | s2 =  [ &_919 <- right_val'44 ] s3
      | s3 = {false} any ]
    
    | bb90 = s0
      [ s0 =  [ &kind'43 <- C_Eq ] s1
      | s1 =  [ &_897 <- left_val'43 ] s2
      | s2 =  [ &_899 <- right_val'43 ] s3
      | s3 = {false} any ]
    
    | bb88 = s0
      [ s0 =  [ &kind'42 <- C_Eq ] s1
      | s1 =  [ &_877 <- left_val'42 ] s2
      | s2 =  [ &_879 <- right_val'42 ] s3
      | s3 = {false} any ]
    
    | bb86 = s0
      [ s0 =  [ &kind'41 <- C_Eq ] s1
      | s1 =  [ &_857 <- left_val'41 ] s2
      | s2 =  [ &_859 <- right_val'41 ] s3
      | s3 = {false} any ]
    
    | bb84 = s0
      [ s0 =  [ &kind'40 <- C_Eq ] s1
      | s1 =  [ &_837 <- left_val'40 ] s2
      | s2 =  [ &_839 <- right_val'40 ] s3
      | s3 = {false} any ]
    
    | bb82 = s0
      [ s0 =  [ &kind'39 <- C_Eq ] s1
      | s1 =  [ &_817 <- left_val'39 ] s2
      | s2 =  [ &_819 <- right_val'39 ] s3
      | s3 = {false} any ]
    
    | bb80 = s0
      [ s0 =  [ &kind'38 <- C_Eq ] s1
      | s1 =  [ &_797 <- left_val'38 ] s2
      | s2 =  [ &_799 <- right_val'38 ] s3
      | s3 = {false} any ]
    
    | bb78 = s0
      [ s0 =  [ &kind'37 <- C_Eq ] s1
      | s1 =  [ &_777 <- left_val'37 ] s2
      | s2 =  [ &_779 <- right_val'37 ] s3
      | s3 = {false} any ]
    
    | bb76 = s0
      [ s0 =  [ &kind'36 <- C_Eq ] s1
      | s1 =  [ &_757 <- left_val'36 ] s2
      | s2 =  [ &_759 <- right_val'36 ] s3
      | s3 = {false} any ]
    
    | bb74 = s0
      [ s0 =  [ &kind'35 <- C_Eq ] s1
      | s1 =  [ &_737 <- left_val'35 ] s2
      | s2 =  [ &_739 <- right_val'35 ] s3
      | s3 = {false} any ]
    
    | bb72 = s0
      [ s0 =  [ &kind'34 <- C_Eq ] s1
      | s1 =  [ &_717 <- left_val'34 ] s2
      | s2 =  [ &_719 <- right_val'34 ] s3
      | s3 = {false} any ]
    
    | bb70 = s0
      [ s0 =  [ &kind'33 <- C_Eq ] s1
      | s1 =  [ &_697 <- left_val'33 ] s2
      | s2 =  [ &_699 <- right_val'33 ] s3
      | s3 = {false} any ]
    
    | bb68 = s0
      [ s0 =  [ &kind'32 <- C_Eq ] s1
      | s1 =  [ &_677 <- left_val'32 ] s2
      | s2 =  [ &_679 <- right_val'32 ] s3
      | s3 = {false} any ]
    
    | bb66 = s0
      [ s0 =  [ &kind'31 <- C_Eq ] s1
      | s1 =  [ &_657 <- left_val'31 ] s2
      | s2 =  [ &_659 <- right_val'31 ] s3
      | s3 = {false} any ]
    
    | bb64 = s0
      [ s0 =  [ &kind'30 <- C_Eq ] s1
      | s1 =  [ &_637 <- left_val'30 ] s2
      | s2 =  [ &_639 <- right_val'30 ] s3
      | s3 = {false} any ]
    
    | bb62 = s0
      [ s0 =  [ &kind'29 <- C_Eq ] s1
      | s1 =  [ &_617 <- left_val'29 ] s2
      | s2 =  [ &_619 <- right_val'29 ] s3
      | s3 = {false} any ]
    
    | bb60 = s0
      [ s0 =  [ &kind'28 <- C_Eq ] s1
      | s1 =  [ &_597 <- left_val'28 ] s2
      | s2 =  [ &_599 <- right_val'28 ] s3
      | s3 = {false} any ]
    
    | bb58 = s0
      [ s0 =  [ &kind'27 <- C_Eq ] s1
      | s1 =  [ &_577 <- left_val'27 ] s2
      | s2 =  [ &_579 <- right_val'27 ] s3
      | s3 = {false} any ]
    
    | bb56 = s0
      [ s0 =  [ &kind'26 <- C_Eq ] s1
      | s1 =  [ &_557 <- left_val'26 ] s2
      | s2 =  [ &_559 <- right_val'26 ] s3
      | s3 = {false} any ]
    
    | bb54 = s0
      [ s0 =  [ &kind'25 <- C_Eq ] s1
      | s1 =  [ &_537 <- left_val'25 ] s2
      | s2 =  [ &_539 <- right_val'25 ] s3
      | s3 = {false} any ]
    
    | bb52 = s0
      [ s0 =  [ &kind'24 <- C_Eq ] s1
      | s1 =  [ &_517 <- left_val'24 ] s2
      | s2 =  [ &_519 <- right_val'24 ] s3
      | s3 = {false} any ]
    
    | bb50 = s0
      [ s0 =  [ &kind'23 <- C_Eq ] s1
      | s1 =  [ &_497 <- left_val'23 ] s2
      | s2 =  [ &_499 <- right_val'23 ] s3
      | s3 = {false} any ]
    
    | bb48 = s0
      [ s0 =  [ &kind'22 <- C_Eq ] s1
      | s1 =  [ &_477 <- left_val'22 ] s2
      | s2 =  [ &_479 <- right_val'22 ] s3
      | s3 = {false} any ]
    
    | bb46 = s0
      [ s0 =  [ &kind'21 <- C_Eq ] s1
      | s1 =  [ &_457 <- left_val'21 ] s2
      | s2 =  [ &_459 <- right_val'21 ] s3
      | s3 = {false} any ]
    
    | bb44 = s0
      [ s0 =  [ &kind'20 <- C_Eq ] s1
      | s1 =  [ &_437 <- left_val'20 ] s2
      | s2 =  [ &_439 <- right_val'20 ] s3
      | s3 = {false} any ]
    
    | bb42 = s0
      [ s0 =  [ &kind'19 <- C_Eq ] s1
      | s1 =  [ &_417 <- left_val'19 ] s2
      | s2 =  [ &_419 <- right_val'19 ] s3
      | s3 = {false} any ]
    
    | bb40 = s0
      [ s0 =  [ &kind'18 <- C_Eq ] s1
      | s1 =  [ &_397 <- left_val'18 ] s2
      | s2 =  [ &_399 <- right_val'18 ] s3
      | s3 = {false} any ]
    
    | bb38 = s0
      [ s0 =  [ &kind'17 <- C_Eq ] s1
      | s1 =  [ &_377 <- left_val'17 ] s2
      | s2 =  [ &_379 <- right_val'17 ] s3
      | s3 = {false} any ]
    
    | bb36 = s0
      [ s0 =  [ &kind'16 <- C_Eq ] s1
      | s1 =  [ &_357 <- left_val'16 ] s2
      | s2 =  [ &_359 <- right_val'16 ] s3
      | s3 = {false} any ]
    
    | bb34 = s0
      [ s0 =  [ &kind'15 <- C_Eq ] s1
      | s1 =  [ &_337 <- left_val'15 ] s2
      | s2 =  [ &_339 <- right_val'15 ] s3
      | s3 = {false} any ]
    
    | bb32 = s0
      [ s0 =  [ &kind'14 <- C_Eq ] s1
      | s1 =  [ &_317 <- left_val'14 ] s2
      | s2 =  [ &_319 <- right_val'14 ] s3
      | s3 = {false} any ]
    
    | bb30 = s0
      [ s0 =  [ &kind'13 <- C_Eq ] s1
      | s1 =  [ &_297 <- left_val'13 ] s2
      | s2 =  [ &_299 <- right_val'13 ] s3
      | s3 = {false} any ]
    
    | bb28 = s0
      [ s0 =  [ &kind'12 <- C_Eq ] s1
      | s1 =  [ &_277 <- left_val'12 ] s2
      | s2 =  [ &_279 <- right_val'12 ] s3
      | s3 = {false} any ]
    
    | bb26 = s0
      [ s0 =  [ &kind'11 <- C_Eq ] s1
      | s1 =  [ &_257 <- left_val'11 ] s2
      | s2 =  [ &_259 <- right_val'11 ] s3
      | s3 = {false} any ]
    
    | bb24 = s0
      [ s0 =  [ &kind'10 <- C_Eq ] s1
      | s1 =  [ &_237 <- left_val'10 ] s2
      | s2 =  [ &_239 <- right_val'10 ] s3
      | s3 = {false} any ]
    
    | bb22 = s0
      [ s0 =  [ &kind'9 <- C_Eq ] s1
      | s1 =  [ &_217 <- left_val'9 ] s2
      | s2 =  [ &_219 <- right_val'9 ] s3
      | s3 = {false} any ]
    
    | bb20 = s0
      [ s0 =  [ &kind'8 <- C_Eq ] s1
      | s1 =  [ &_197 <- left_val'8 ] s2
      | s2 =  [ &_199 <- right_val'8 ] s3
      | s3 = {false} any ]
    
    | bb18 = s0
      [ s0 =  [ &kind'7 <- C_Eq ] s1
      | s1 =  [ &_177 <- left_val'7 ] s2
      | s2 =  [ &_179 <- right_val'7 ] s3
      | s3 = {false} any ]
    
    | bb16 = s0
      [ s0 =  [ &kind'6 <- C_Eq ] s1
      | s1 =  [ &_157 <- left_val'6 ] s2
      | s2 =  [ &_159 <- right_val'6 ] s3
      | s3 = {false} any ]
    
    | bb14 = s0
      [ s0 =  [ &kind'5 <- C_Eq ] s1
      | s1 =  [ &_137 <- left_val'5 ] s2
      | s2 =  [ &_139 <- right_val'5 ] s3
      | s3 = {false} any ]
    
    | bb12 = s0
      [ s0 =  [ &kind'4 <- C_Eq ] s1
      | s1 =  [ &_117 <- left_val'4 ] s2
      | s2 =  [ &_119 <- right_val'4 ] s3
      | s3 = {false} any ]
    
    | bb10 = s0
      [ s0 =  [ &kind'3 <- C_Eq ] s1
      | s1 =  [ &_97 <- left_val'3 ] s2
      | s2 =  [ &_99 <- right_val'3 ] s3
      | s3 = {false} any ]
    
    | bb8 = s0
      [ s0 =  [ &kind'2 <- C_Eq ] s1
      | s1 =  [ &_77 <- left_val'2 ] s2
      | s2 =  [ &_79 <- right_val'2 ] s3
      | s3 = {false} any ]
    
    | bb6 = s0
      [ s0 =  [ &kind'1 <- C_Eq ] s1
      | s1 =  [ &_57 <- left_val'1 ] s2
      | s2 =  [ &_59 <- right_val'1 ] s3
      | s3 = {false} any ]
    
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_37 <- left_val'0 ] s2
      | s2 =  [ &_39 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_17 <- left_val ] s2 | s2 =  [ &_19 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: tuple = Any.any_l ()
    | & left_val: UInt8BW.t = Any.any_l ()
    | & right_val: UInt8BW.t = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _17: UInt8BW.t = Any.any_l ()
    | & _19: UInt8BW.t = Any.any_l ()
    | & _22: tuple'0 = Any.any_l ()
    | & left_val'0: Int8BW.t = Any.any_l ()
    | & right_val'0: Int8BW.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _37: Int8BW.t = Any.any_l ()
    | & _39: Int8BW.t = Any.any_l ()
    | & _42: tuple'1 = Any.any_l ()
    | & left_val'1: UInt16BW.t = Any.any_l ()
    | & right_val'1: UInt16BW.t = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _57: UInt16BW.t = Any.any_l ()
    | & _59: UInt16BW.t = Any.any_l ()
    | & _62: tuple'2 = Any.any_l ()
    | & left_val'2: Int16BW.t = Any.any_l ()
    | & right_val'2: Int16BW.t = Any.any_l ()
    | & _69: bool = Any.any_l ()
    | & kind'2: t_AssertKind = Any.any_l ()
    | & _77: Int16BW.t = Any.any_l ()
    | & _79: Int16BW.t = Any.any_l ()
    | & _82: tuple'3 = Any.any_l ()
    | & left_val'3: UInt32BW.t = Any.any_l ()
    | & right_val'3: UInt32BW.t = Any.any_l ()
    | & _89: bool = Any.any_l ()
    | & kind'3: t_AssertKind = Any.any_l ()
    | & _97: UInt32BW.t = Any.any_l ()
    | & _99: UInt32BW.t = Any.any_l ()
    | & _102: tuple'4 = Any.any_l ()
    | & left_val'4: Int32BW.t = Any.any_l ()
    | & right_val'4: Int32BW.t = Any.any_l ()
    | & _109: bool = Any.any_l ()
    | & kind'4: t_AssertKind = Any.any_l ()
    | & _117: Int32BW.t = Any.any_l ()
    | & _119: Int32BW.t = Any.any_l ()
    | & _122: tuple'5 = Any.any_l ()
    | & left_val'5: UInt64BW.t = Any.any_l ()
    | & right_val'5: UInt64BW.t = Any.any_l ()
    | & _129: bool = Any.any_l ()
    | & kind'5: t_AssertKind = Any.any_l ()
    | & _137: UInt64BW.t = Any.any_l ()
    | & _139: UInt64BW.t = Any.any_l ()
    | & _142: tuple'6 = Any.any_l ()
    | & left_val'6: Int64BW.t = Any.any_l ()
    | & right_val'6: Int64BW.t = Any.any_l ()
    | & _149: bool = Any.any_l ()
    | & kind'6: t_AssertKind = Any.any_l ()
    | & _157: Int64BW.t = Any.any_l ()
    | & _159: Int64BW.t = Any.any_l ()
    | & _162: tuple'7 = Any.any_l ()
    | & left_val'7: UInt128BW.t = Any.any_l ()
    | & right_val'7: UInt128BW.t = Any.any_l ()
    | & _169: bool = Any.any_l ()
    | & kind'7: t_AssertKind = Any.any_l ()
    | & _177: UInt128BW.t = Any.any_l ()
    | & _179: UInt128BW.t = Any.any_l ()
    | & _182: tuple'8 = Any.any_l ()
    | & left_val'8: Int128BW.t = Any.any_l ()
    | & right_val'8: Int128BW.t = Any.any_l ()
    | & _189: bool = Any.any_l ()
    | & kind'8: t_AssertKind = Any.any_l ()
    | & _197: Int128BW.t = Any.any_l ()
    | & _199: Int128BW.t = Any.any_l ()
    | & _202: tuple'9 = Any.any_l ()
    | & left_val'9: UInt64BW.t = Any.any_l ()
    | & right_val'9: UInt64BW.t = Any.any_l ()
    | & _209: bool = Any.any_l ()
    | & kind'9: t_AssertKind = Any.any_l ()
    | & _217: UInt64BW.t = Any.any_l ()
    | & _219: UInt64BW.t = Any.any_l ()
    | & _222: tuple'10 = Any.any_l ()
    | & left_val'10: Int64BW.t = Any.any_l ()
    | & right_val'10: Int64BW.t = Any.any_l ()
    | & _229: bool = Any.any_l ()
    | & kind'10: t_AssertKind = Any.any_l ()
    | & _237: Int64BW.t = Any.any_l ()
    | & _239: Int64BW.t = Any.any_l ()
    | & _242: tuple = Any.any_l ()
    | & left_val'11: UInt8BW.t = Any.any_l ()
    | & right_val'11: UInt8BW.t = Any.any_l ()
    | & _249: bool = Any.any_l ()
    | & kind'11: t_AssertKind = Any.any_l ()
    | & _257: UInt8BW.t = Any.any_l ()
    | & _259: UInt8BW.t = Any.any_l ()
    | & _262: tuple'0 = Any.any_l ()
    | & left_val'12: Int8BW.t = Any.any_l ()
    | & right_val'12: Int8BW.t = Any.any_l ()
    | & _269: bool = Any.any_l ()
    | & kind'12: t_AssertKind = Any.any_l ()
    | & _277: Int8BW.t = Any.any_l ()
    | & _279: Int8BW.t = Any.any_l ()
    | & _282: tuple'1 = Any.any_l ()
    | & left_val'13: UInt16BW.t = Any.any_l ()
    | & right_val'13: UInt16BW.t = Any.any_l ()
    | & _289: bool = Any.any_l ()
    | & kind'13: t_AssertKind = Any.any_l ()
    | & _297: UInt16BW.t = Any.any_l ()
    | & _299: UInt16BW.t = Any.any_l ()
    | & _302: tuple'2 = Any.any_l ()
    | & left_val'14: Int16BW.t = Any.any_l ()
    | & right_val'14: Int16BW.t = Any.any_l ()
    | & _309: bool = Any.any_l ()
    | & kind'14: t_AssertKind = Any.any_l ()
    | & _317: Int16BW.t = Any.any_l ()
    | & _319: Int16BW.t = Any.any_l ()
    | & _322: tuple'3 = Any.any_l ()
    | & left_val'15: UInt32BW.t = Any.any_l ()
    | & right_val'15: UInt32BW.t = Any.any_l ()
    | & _329: bool = Any.any_l ()
    | & kind'15: t_AssertKind = Any.any_l ()
    | & _337: UInt32BW.t = Any.any_l ()
    | & _339: UInt32BW.t = Any.any_l ()
    | & _342: tuple'4 = Any.any_l ()
    | & left_val'16: Int32BW.t = Any.any_l ()
    | & right_val'16: Int32BW.t = Any.any_l ()
    | & _349: bool = Any.any_l ()
    | & kind'16: t_AssertKind = Any.any_l ()
    | & _357: Int32BW.t = Any.any_l ()
    | & _359: Int32BW.t = Any.any_l ()
    | & _362: tuple'5 = Any.any_l ()
    | & left_val'17: UInt64BW.t = Any.any_l ()
    | & right_val'17: UInt64BW.t = Any.any_l ()
    | & _369: bool = Any.any_l ()
    | & kind'17: t_AssertKind = Any.any_l ()
    | & _377: UInt64BW.t = Any.any_l ()
    | & _379: UInt64BW.t = Any.any_l ()
    | & _382: tuple'6 = Any.any_l ()
    | & left_val'18: Int64BW.t = Any.any_l ()
    | & right_val'18: Int64BW.t = Any.any_l ()
    | & _389: bool = Any.any_l ()
    | & kind'18: t_AssertKind = Any.any_l ()
    | & _397: Int64BW.t = Any.any_l ()
    | & _399: Int64BW.t = Any.any_l ()
    | & _402: tuple'7 = Any.any_l ()
    | & left_val'19: UInt128BW.t = Any.any_l ()
    | & right_val'19: UInt128BW.t = Any.any_l ()
    | & _409: bool = Any.any_l ()
    | & kind'19: t_AssertKind = Any.any_l ()
    | & _417: UInt128BW.t = Any.any_l ()
    | & _419: UInt128BW.t = Any.any_l ()
    | & _422: tuple'8 = Any.any_l ()
    | & left_val'20: Int128BW.t = Any.any_l ()
    | & right_val'20: Int128BW.t = Any.any_l ()
    | & _429: bool = Any.any_l ()
    | & kind'20: t_AssertKind = Any.any_l ()
    | & _437: Int128BW.t = Any.any_l ()
    | & _439: Int128BW.t = Any.any_l ()
    | & _442: tuple'9 = Any.any_l ()
    | & left_val'21: UInt64BW.t = Any.any_l ()
    | & right_val'21: UInt64BW.t = Any.any_l ()
    | & _449: bool = Any.any_l ()
    | & kind'21: t_AssertKind = Any.any_l ()
    | & _457: UInt64BW.t = Any.any_l ()
    | & _459: UInt64BW.t = Any.any_l ()
    | & _462: tuple'10 = Any.any_l ()
    | & left_val'22: Int64BW.t = Any.any_l ()
    | & right_val'22: Int64BW.t = Any.any_l ()
    | & _469: bool = Any.any_l ()
    | & kind'22: t_AssertKind = Any.any_l ()
    | & _477: Int64BW.t = Any.any_l ()
    | & _479: Int64BW.t = Any.any_l ()
    | & _482: tuple = Any.any_l ()
    | & left_val'23: UInt8BW.t = Any.any_l ()
    | & right_val'23: UInt8BW.t = Any.any_l ()
    | & _489: bool = Any.any_l ()
    | & kind'23: t_AssertKind = Any.any_l ()
    | & _497: UInt8BW.t = Any.any_l ()
    | & _499: UInt8BW.t = Any.any_l ()
    | & _502: tuple'0 = Any.any_l ()
    | & left_val'24: Int8BW.t = Any.any_l ()
    | & right_val'24: Int8BW.t = Any.any_l ()
    | & _509: bool = Any.any_l ()
    | & kind'24: t_AssertKind = Any.any_l ()
    | & _517: Int8BW.t = Any.any_l ()
    | & _519: Int8BW.t = Any.any_l ()
    | & _522: tuple'1 = Any.any_l ()
    | & left_val'25: UInt16BW.t = Any.any_l ()
    | & right_val'25: UInt16BW.t = Any.any_l ()
    | & _529: bool = Any.any_l ()
    | & kind'25: t_AssertKind = Any.any_l ()
    | & _537: UInt16BW.t = Any.any_l ()
    | & _539: UInt16BW.t = Any.any_l ()
    | & _542: tuple'2 = Any.any_l ()
    | & left_val'26: Int16BW.t = Any.any_l ()
    | & right_val'26: Int16BW.t = Any.any_l ()
    | & _549: bool = Any.any_l ()
    | & kind'26: t_AssertKind = Any.any_l ()
    | & _557: Int16BW.t = Any.any_l ()
    | & _559: Int16BW.t = Any.any_l ()
    | & _562: tuple'3 = Any.any_l ()
    | & left_val'27: UInt32BW.t = Any.any_l ()
    | & right_val'27: UInt32BW.t = Any.any_l ()
    | & _569: bool = Any.any_l ()
    | & kind'27: t_AssertKind = Any.any_l ()
    | & _577: UInt32BW.t = Any.any_l ()
    | & _579: UInt32BW.t = Any.any_l ()
    | & _582: tuple'4 = Any.any_l ()
    | & left_val'28: Int32BW.t = Any.any_l ()
    | & right_val'28: Int32BW.t = Any.any_l ()
    | & _589: bool = Any.any_l ()
    | & kind'28: t_AssertKind = Any.any_l ()
    | & _597: Int32BW.t = Any.any_l ()
    | & _599: Int32BW.t = Any.any_l ()
    | & _602: tuple'5 = Any.any_l ()
    | & left_val'29: UInt64BW.t = Any.any_l ()
    | & right_val'29: UInt64BW.t = Any.any_l ()
    | & _609: bool = Any.any_l ()
    | & kind'29: t_AssertKind = Any.any_l ()
    | & _617: UInt64BW.t = Any.any_l ()
    | & _619: UInt64BW.t = Any.any_l ()
    | & _622: tuple'6 = Any.any_l ()
    | & left_val'30: Int64BW.t = Any.any_l ()
    | & right_val'30: Int64BW.t = Any.any_l ()
    | & _629: bool = Any.any_l ()
    | & kind'30: t_AssertKind = Any.any_l ()
    | & _637: Int64BW.t = Any.any_l ()
    | & _639: Int64BW.t = Any.any_l ()
    | & _642: tuple'7 = Any.any_l ()
    | & left_val'31: UInt128BW.t = Any.any_l ()
    | & right_val'31: UInt128BW.t = Any.any_l ()
    | & _649: bool = Any.any_l ()
    | & kind'31: t_AssertKind = Any.any_l ()
    | & _657: UInt128BW.t = Any.any_l ()
    | & _659: UInt128BW.t = Any.any_l ()
    | & _662: tuple'8 = Any.any_l ()
    | & left_val'32: Int128BW.t = Any.any_l ()
    | & right_val'32: Int128BW.t = Any.any_l ()
    | & _669: bool = Any.any_l ()
    | & kind'32: t_AssertKind = Any.any_l ()
    | & _677: Int128BW.t = Any.any_l ()
    | & _679: Int128BW.t = Any.any_l ()
    | & _682: tuple'9 = Any.any_l ()
    | & left_val'33: UInt64BW.t = Any.any_l ()
    | & right_val'33: UInt64BW.t = Any.any_l ()
    | & _689: bool = Any.any_l ()
    | & kind'33: t_AssertKind = Any.any_l ()
    | & _697: UInt64BW.t = Any.any_l ()
    | & _699: UInt64BW.t = Any.any_l ()
    | & _702: tuple'10 = Any.any_l ()
    | & left_val'34: Int64BW.t = Any.any_l ()
    | & right_val'34: Int64BW.t = Any.any_l ()
    | & _709: bool = Any.any_l ()
    | & kind'34: t_AssertKind = Any.any_l ()
    | & _717: Int64BW.t = Any.any_l ()
    | & _719: Int64BW.t = Any.any_l ()
    | & _722: tuple = Any.any_l ()
    | & left_val'35: UInt8BW.t = Any.any_l ()
    | & right_val'35: UInt8BW.t = Any.any_l ()
    | & _729: bool = Any.any_l ()
    | & kind'35: t_AssertKind = Any.any_l ()
    | & _737: UInt8BW.t = Any.any_l ()
    | & _739: UInt8BW.t = Any.any_l ()
    | & _742: tuple'0 = Any.any_l ()
    | & left_val'36: Int8BW.t = Any.any_l ()
    | & right_val'36: Int8BW.t = Any.any_l ()
    | & _749: bool = Any.any_l ()
    | & kind'36: t_AssertKind = Any.any_l ()
    | & _757: Int8BW.t = Any.any_l ()
    | & _759: Int8BW.t = Any.any_l ()
    | & _762: tuple'1 = Any.any_l ()
    | & left_val'37: UInt16BW.t = Any.any_l ()
    | & right_val'37: UInt16BW.t = Any.any_l ()
    | & _769: bool = Any.any_l ()
    | & kind'37: t_AssertKind = Any.any_l ()
    | & _777: UInt16BW.t = Any.any_l ()
    | & _779: UInt16BW.t = Any.any_l ()
    | & _782: tuple'2 = Any.any_l ()
    | & left_val'38: Int16BW.t = Any.any_l ()
    | & right_val'38: Int16BW.t = Any.any_l ()
    | & _789: bool = Any.any_l ()
    | & kind'38: t_AssertKind = Any.any_l ()
    | & _797: Int16BW.t = Any.any_l ()
    | & _799: Int16BW.t = Any.any_l ()
    | & _802: tuple'3 = Any.any_l ()
    | & left_val'39: UInt32BW.t = Any.any_l ()
    | & right_val'39: UInt32BW.t = Any.any_l ()
    | & _809: bool = Any.any_l ()
    | & kind'39: t_AssertKind = Any.any_l ()
    | & _817: UInt32BW.t = Any.any_l ()
    | & _819: UInt32BW.t = Any.any_l ()
    | & _822: tuple'4 = Any.any_l ()
    | & left_val'40: Int32BW.t = Any.any_l ()
    | & right_val'40: Int32BW.t = Any.any_l ()
    | & _829: bool = Any.any_l ()
    | & kind'40: t_AssertKind = Any.any_l ()
    | & _837: Int32BW.t = Any.any_l ()
    | & _839: Int32BW.t = Any.any_l ()
    | & _842: tuple'5 = Any.any_l ()
    | & left_val'41: UInt64BW.t = Any.any_l ()
    | & right_val'41: UInt64BW.t = Any.any_l ()
    | & _849: bool = Any.any_l ()
    | & kind'41: t_AssertKind = Any.any_l ()
    | & _857: UInt64BW.t = Any.any_l ()
    | & _859: UInt64BW.t = Any.any_l ()
    | & _862: tuple'6 = Any.any_l ()
    | & left_val'42: Int64BW.t = Any.any_l ()
    | & right_val'42: Int64BW.t = Any.any_l ()
    | & _869: bool = Any.any_l ()
    | & kind'42: t_AssertKind = Any.any_l ()
    | & _877: Int64BW.t = Any.any_l ()
    | & _879: Int64BW.t = Any.any_l ()
    | & _882: tuple'7 = Any.any_l ()
    | & left_val'43: UInt128BW.t = Any.any_l ()
    | & right_val'43: UInt128BW.t = Any.any_l ()
    | & _889: bool = Any.any_l ()
    | & kind'43: t_AssertKind = Any.any_l ()
    | & _897: UInt128BW.t = Any.any_l ()
    | & _899: UInt128BW.t = Any.any_l ()
    | & _902: tuple'8 = Any.any_l ()
    | & left_val'44: Int128BW.t = Any.any_l ()
    | & right_val'44: Int128BW.t = Any.any_l ()
    | & _909: bool = Any.any_l ()
    | & kind'44: t_AssertKind = Any.any_l ()
    | & _917: Int128BW.t = Any.any_l ()
    | & _919: Int128BW.t = Any.any_l ()
    | & _921: Int128BW.t = Any.any_l ()
    | & _922: Int128BW.t = Any.any_l ()
    | & _923: UInt128BW.t = Any.any_l ()
    | & _924: UInt128BW.t = Any.any_l ()
    | & _925: Int64BW.t = Any.any_l ()
    | & _926: Int64BW.t = Any.any_l ()
    | & _927: UInt64BW.t = Any.any_l ()
    | & _928: UInt64BW.t = Any.any_l ()
    | & _929: Int32BW.t = Any.any_l ()
    | & _930: Int32BW.t = Any.any_l ()
    | & _931: UInt32BW.t = Any.any_l ()
    | & _932: UInt32BW.t = Any.any_l ()
    | & _933: Int16BW.t = Any.any_l ()
    | & _934: Int16BW.t = Any.any_l ()
    | & _935: UInt16BW.t = Any.any_l ()
    | & _936: UInt16BW.t = Any.any_l ()
    | & _937: Int8BW.t = Any.any_l ()
    | & _938: Int8BW.t = Any.any_l ()
    | & _939: UInt8BW.t = Any.any_l ()
    | & _940: UInt8BW.t = Any.any_l ()
    | & _941: Int64BW.t = Any.any_l ()
    | & _942: Int64BW.t = Any.any_l ()
    | & _943: UInt64BW.t = Any.any_l ()
    | & _944: UInt64BW.t = Any.any_l ()
    | & _945: Int128BW.t = Any.any_l ()
    | & _946: Int128BW.t = Any.any_l ()
    | & _947: UInt128BW.t = Any.any_l ()
    | & _948: UInt128BW.t = Any.any_l ()
    | & _949: Int64BW.t = Any.any_l ()
    | & _950: Int64BW.t = Any.any_l ()
    | & _951: UInt64BW.t = Any.any_l ()
    | & _952: UInt64BW.t = Any.any_l ()
    | & _953: Int32BW.t = Any.any_l ()
    | & _954: Int32BW.t = Any.any_l ()
    | & _955: UInt32BW.t = Any.any_l ()
    | & _956: UInt32BW.t = Any.any_l ()
    | & _957: Int16BW.t = Any.any_l ()
    | & _958: Int16BW.t = Any.any_l ()
    | & _959: UInt16BW.t = Any.any_l ()
    | & _960: UInt16BW.t = Any.any_l ()
    | & _961: Int8BW.t = Any.any_l ()
    | & _962: Int8BW.t = Any.any_l ()
    | & _963: UInt8BW.t = Any.any_l ()
    | & _964: UInt8BW.t = Any.any_l ()
    | & _965: Int64BW.t = Any.any_l ()
    | & _966: Int64BW.t = Any.any_l ()
    | & _967: UInt64BW.t = Any.any_l ()
    | & _968: UInt64BW.t = Any.any_l ()
    | & _969: Int128BW.t = Any.any_l ()
    | & _970: Int128BW.t = Any.any_l ()
    | & _971: UInt128BW.t = Any.any_l ()
    | & _972: UInt128BW.t = Any.any_l ()
    | & _973: Int64BW.t = Any.any_l ()
    | & _974: Int64BW.t = Any.any_l ()
    | & _975: UInt64BW.t = Any.any_l ()
    | & _976: UInt64BW.t = Any.any_l ()
    | & _977: Int32BW.t = Any.any_l ()
    | & _978: Int32BW.t = Any.any_l ()
    | & _979: UInt32BW.t = Any.any_l ()
    | & _980: UInt32BW.t = Any.any_l ()
    | & _981: Int16BW.t = Any.any_l ()
    | & _982: Int16BW.t = Any.any_l ()
    | & _983: UInt16BW.t = Any.any_l ()
    | & _984: UInt16BW.t = Any.any_l ()
    | & _985: Int8BW.t = Any.any_l ()
    | & _986: Int8BW.t = Any.any_l ()
    | & _987: UInt8BW.t = Any.any_l ()
    | & _988: UInt8BW.t = Any.any_l ()
    | & _989: Int64BW.t = Any.any_l ()
    | & _990: Int64BW.t = Any.any_l ()
    | & _991: UInt64BW.t = Any.any_l ()
    | & _992: UInt64BW.t = Any.any_l ()
    | & _993: Int128BW.t = Any.any_l ()
    | & _994: Int128BW.t = Any.any_l ()
    | & _995: UInt128BW.t = Any.any_l ()
    | & _996: UInt128BW.t = Any.any_l ()
    | & _997: Int64BW.t = Any.any_l ()
    | & _998: Int64BW.t = Any.any_l ()
    | & _999: UInt64BW.t = Any.any_l ()
    | & _1000: UInt64BW.t = Any.any_l ()
    | & _1001: Int32BW.t = Any.any_l ()
    | & _1002: Int32BW.t = Any.any_l ()
    | & _1003: UInt32BW.t = Any.any_l ()
    | & _1004: UInt32BW.t = Any.any_l ()
    | & _1005: Int16BW.t = Any.any_l ()
    | & _1006: Int16BW.t = Any.any_l ()
    | & _1007: UInt16BW.t = Any.any_l ()
    | & _1008: UInt16BW.t = Any.any_l ()
    | & _1009: Int8BW.t = Any.any_l ()
    | & _1010: Int8BW.t = Any.any_l ()
    | & _1011: UInt8BW.t = Any.any_l ()
    | & _1012: UInt8BW.t = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_integer_ops__test_shift_ops [#"integer_ops.rs" 62 0 62 23]
  let%span sinteger_ops = "integer_ops.rs" 64 32 64 33
  let%span sinteger_ops'0 = "integer_ops.rs" 64 15 64 28
  let%span sinteger_ops'1 = "integer_ops.rs" 64 35 64 48
  let%span sinteger_ops'2 = "integer_ops.rs" 65 32 65 33
  let%span sinteger_ops'3 = "integer_ops.rs" 65 15 65 28
  let%span sinteger_ops'4 = "integer_ops.rs" 65 35 65 48
  let%span sinteger_ops'5 = "integer_ops.rs" 66 43 66 44
  let%span sinteger_ops'6 = "integer_ops.rs" 66 15 66 39
  let%span sinteger_ops'7 = "integer_ops.rs" 66 46 66 70
  let%span sinteger_ops'8 = "integer_ops.rs" 67 32 67 33
  let%span sinteger_ops'9 = "integer_ops.rs" 67 15 67 28
  let%span sinteger_ops'10 = "integer_ops.rs" 67 35 67 41
  let%span sinteger_ops'11 = "integer_ops.rs" 68 40 68 41
  let%span sinteger_ops'12 = "integer_ops.rs" 68 15 68 36
  let%span sinteger_ops'13 = "integer_ops.rs" 68 43 68 58
  let%span sinteger_ops'14 = "integer_ops.rs" 69 43 69 44
  let%span sinteger_ops'15 = "integer_ops.rs" 69 15 69 39
  let%span sinteger_ops'16 = "integer_ops.rs" 69 46 69 67
  let%span sinteger_ops'17 = "integer_ops.rs" 70 35 70 36
  let%span sinteger_ops'18 = "integer_ops.rs" 70 15 70 31
  let%span sinteger_ops'19 = "integer_ops.rs" 70 38 70 57
  let%span sinteger_ops'20 = "integer_ops.rs" 73 32 73 33
  let%span sinteger_ops'21 = "integer_ops.rs" 73 15 73 28
  let%span sinteger_ops'22 = "integer_ops.rs" 73 35 73 48
  let%span sinteger_ops'23 = "integer_ops.rs" 74 15 74 28
  let%span sinteger_ops'24 = "integer_ops.rs" 74 38 74 39
  let%span sinteger_ops'25 = "integer_ops.rs" 74 41 74 54
  let%span sinteger_ops'26 = "integer_ops.rs" 75 43 75 44
  let%span sinteger_ops'27 = "integer_ops.rs" 75 15 75 39
  let%span sinteger_ops'28 = "integer_ops.rs" 75 46 75 70
  let%span sinteger_ops'29 = "integer_ops.rs" 76 32 76 34
  let%span sinteger_ops'30 = "integer_ops.rs" 76 15 76 28
  let%span sinteger_ops'31 = "integer_ops.rs" 76 36 76 43
  let%span sinteger_ops'32 = "integer_ops.rs" 77 40 77 42
  let%span sinteger_ops'33 = "integer_ops.rs" 77 15 77 36
  let%span sinteger_ops'34 = "integer_ops.rs" 77 44 77 58
  let%span sinteger_ops'35 = "integer_ops.rs" 78 28 78 31
  let%span sinteger_ops'36 = "integer_ops.rs" 78 15 78 24
  let%span sinteger_ops'37 = "integer_ops.rs" 78 33 78 40
  let%span sinteger_ops'38 = "integer_ops.rs" 79 35 79 36
  let%span sinteger_ops'39 = "integer_ops.rs" 79 15 79 31
  let%span sinteger_ops'40 = "integer_ops.rs" 79 38 79 54
  
  use creusot.int.UInt8BW
  use creusot.int.Int32BW
  use creusot.prelude.Any
  use creusot.int.Int8BW
  use creusot.int.UInt16BW
  use creusot.int.UInt32BW
  use creusot.int.UInt64BW
  use creusot.int.UInt128BW
  
  let rec promoted27__test_shift_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt8BW.shl {[%#sinteger_ops'0] (240: UInt8BW.t)} {Int32BW.to_int ([%#sinteger_ops] (2: Int32BW.t))}
          (fun (_ret:UInt8BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ] 
    [ return''0 (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted26__test_shift_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (192: UInt8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8BW.t = Any.any_l () ]  [ return''0 (result:UInt8BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt8BW.t; _p1: UInt8BW.t }
  
  let rec promoted25__test_shift_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 = Int8BW.shl {[%#sinteger_ops'3] (105: Int8BW.t)} {Int32BW.to_int ([%#sinteger_ops'2] (3: Int32BW.t))}
          (fun (_ret:Int8BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted24__test_shift_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'4] (72: Int8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8BW.t = Any.any_l () ]  [ return''0 (result:Int8BW.t)-> return' {result} ] 
  
  type tuple'0  =
    { _p0'0: Int8BW.t; _p1'0: Int8BW.t }
  
  let rec promoted23__test_shift_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt16BW.shl {[%#sinteger_ops'6] (65535: UInt16BW.t)} {Int32BW.to_int ([%#sinteger_ops'5] (3: Int32BW.t))}
          (fun (_ret:UInt16BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ] 
    [ return''0 (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted22__test_shift_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'7] (65528: UInt16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16BW.t = Any.any_l () ]  [ return''0 (result:UInt16BW.t)-> return' {result} ] 
  
  type tuple'1  =
    { _p0'1: UInt16BW.t; _p1'1: UInt16BW.t }
  
  let rec promoted21__test_shift_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt32BW.shl
          {[%#sinteger_ops'9] (3221225475: UInt32BW.t)}
          {Int32BW.to_int ([%#sinteger_ops'8] (2: Int32BW.t))}
          (fun (_ret:UInt32BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ] 
    [ return''0 (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted20__test_shift_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'10] (12: UInt32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32BW.t = Any.any_l () ]  [ return''0 (result:UInt32BW.t)-> return' {result} ] 
  
  type tuple'2  =
    { _p0'2: UInt32BW.t; _p1'2: UInt32BW.t }
  
  let rec promoted19__test_shift_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shl
          {[%#sinteger_ops'12] (13835321938072829955: UInt64BW.t)}
          {Int32BW.to_int ([%#sinteger_ops'11] (4: Int32BW.t))}
          (fun (_ret:UInt64BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted18__test_shift_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'13] (4222124650659888: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type tuple'3  =
    { _p0'3: UInt64BW.t; _p1'3: UInt64BW.t }
  
  let rec promoted17__test_shift_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt128BW.shl
          {[%#sinteger_ops'15] (4514840875923203424259: UInt128BW.t)}
          {Int32BW.to_int ([%#sinteger_ops'14] (3: Int32BW.t))}
          (fun (_ret:UInt128BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ] 
    [ return''0 (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted16__test_shift_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops'16] (36118727007385627394072: UInt128BW.t) ] s1 | s1 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () ]  [ return''0 (result:UInt128BW.t)-> return' {result} ] 
  
  type tuple'4  =
    { _p0'4: UInt128BW.t; _p1'4: UInt128BW.t }
  
  let rec promoted15__test_shift_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shl {[%#sinteger_ops'18] (240: UInt64BW.t)} {Int32BW.to_int ([%#sinteger_ops'17] (2: Int32BW.t))}
          (fun (_ret:UInt64BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted14__test_shift_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'19] (960: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type tuple'5  =
    { _p0'5: UInt64BW.t; _p1'5: UInt64BW.t }
  
  let rec promoted13__test_shift_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt8BW.shr {[%#sinteger_ops'21] (240: UInt8BW.t)} {Int32BW.to_int ([%#sinteger_ops'20] (2: Int32BW.t))}
          (fun (_ret:UInt8BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ] 
    [ return''0 (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted12__test_shift_ops (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'22] (60: UInt8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8BW.t = Any.any_l () ]  [ return''0 (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted11__test_shift_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 = Int8BW.of_BV256 {UInt8BW.to_BV256 ([%#sinteger_ops'23] (240: UInt8BW.t))}
          (fun (_ret_from:Int8BW.t) ->  [ &_2 <- _ret_from ] s1)
      | s1 = Int8BW.shr {_2} {Int32BW.to_int ([%#sinteger_ops'24] (2: Int32BW.t))}
          (fun (_ret:Int8BW.t) ->  [ &_1 <- _ret ] s2)
      | s2 =  [ &_0 <- _1 ] s3
      | s3 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () | & _2: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted10__test_shift_ops (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 = Int8BW.of_BV256 {UInt8BW.to_BV256 ([%#sinteger_ops'25] (252: UInt8BW.t))}
          (fun (_ret_from:Int8BW.t) ->  [ &_1 <- _ret_from ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted9__test_shift_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt16BW.shr
          {[%#sinteger_ops'27] (65535: UInt16BW.t)}
          {Int32BW.to_int ([%#sinteger_ops'26] (6: Int32BW.t))}
          (fun (_ret:UInt16BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ] 
    [ return''0 (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted8__test_shift_ops (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'28] (1023: UInt16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16BW.t = Any.any_l () ]  [ return''0 (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted7__test_shift_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt32BW.shr
          {[%#sinteger_ops'30] (3221225475: UInt32BW.t)}
          {Int32BW.to_int ([%#sinteger_ops'29] (14: Int32BW.t))}
          (fun (_ret:UInt32BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ] 
    [ return''0 (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted6__test_shift_ops (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'31] (196608: UInt32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32BW.t = Any.any_l () ]  [ return''0 (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted5__test_shift_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shr
          {[%#sinteger_ops'33] (13835321938072829955: UInt64BW.t)}
          {Int32BW.to_int ([%#sinteger_ops'32] (18: Int32BW.t))}
          (fun (_ret:UInt64BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted4__test_shift_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'34] (52777564766208: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted3__test_shift_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt128BW.shr
          {[%#sinteger_ops'36] (340282366920938463463374607431768211455: UInt128BW.t)}
          {Int32BW.to_int ([%#sinteger_ops'35] (110: Int32BW.t))}
          (fun (_ret:UInt128BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ] 
    [ return''0 (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_shift_ops (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'37] (262143: UInt128BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt128BW.t = Any.any_l () ]  [ return''0 (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted1__test_shift_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shr {[%#sinteger_ops'39] (240: UInt64BW.t)} {Int32BW.to_int ([%#sinteger_ops'38] (2: Int32BW.t))}
          (fun (_ret:UInt64BW.t) ->  [ &_1 <- _ret ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_shift_ops (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'40] (60: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_shift_ops[#"integer_ops.rs" 62 0 62 23] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted27__test_shift_ops (fun (pr27:UInt8BW.t) ->  [ &_309 <- pr27 ] s1)
      | s1 = promoted26__test_shift_ops (fun (pr26:UInt8BW.t) ->  [ &_308 <- pr26 ] s2)
      | s2 =  [ &_2 <- { _p0 = _309; _p1 = _308 } ] s3
      | s3 =  [ &left_val <- _2._p0 ] s4
      | s4 =  [ &right_val <- _2._p1 ] s5
      | s5 =  [ &_9 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_9 = false} (! bb2) | br1 -> {_9} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted25__test_shift_ops (fun (pr25:Int8BW.t) ->  [ &_307 <- pr25 ] s1)
      | s1 = promoted24__test_shift_ops (fun (pr24:Int8BW.t) ->  [ &_306 <- pr24 ] s2)
      | s2 =  [ &_22 <- { _p0'0 = _307; _p1'0 = _306 } ] s3
      | s3 =  [ &left_val'0 <- _22._p0'0 ] s4
      | s4 =  [ &right_val'0 <- _22._p1'0 ] s5
      | s5 =  [ &_29 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_29 = false} (! bb4) | br1 -> {_29} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = promoted23__test_shift_ops (fun (pr23:UInt16BW.t) ->  [ &_305 <- pr23 ] s1)
      | s1 = promoted22__test_shift_ops (fun (pr22:UInt16BW.t) ->  [ &_304 <- pr22 ] s2)
      | s2 =  [ &_42 <- { _p0'1 = _305; _p1'1 = _304 } ] s3
      | s3 =  [ &left_val'1 <- _42._p0'1 ] s4
      | s4 =  [ &right_val'1 <- _42._p1'1 ] s5
      | s5 =  [ &_49 <- left_val'1 = right_val'1 ] s6
      | s6 = any [ br0 -> {_49 = false} (! bb6) | br1 -> {_49} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = promoted21__test_shift_ops (fun (pr21:UInt32BW.t) ->  [ &_303 <- pr21 ] s1)
      | s1 = promoted20__test_shift_ops (fun (pr20:UInt32BW.t) ->  [ &_302 <- pr20 ] s2)
      | s2 =  [ &_62 <- { _p0'2 = _303; _p1'2 = _302 } ] s3
      | s3 =  [ &left_val'2 <- _62._p0'2 ] s4
      | s4 =  [ &right_val'2 <- _62._p1'2 ] s5
      | s5 =  [ &_69 <- left_val'2 = right_val'2 ] s6
      | s6 = any [ br0 -> {_69 = false} (! bb8) | br1 -> {_69} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = promoted19__test_shift_ops (fun (pr19:UInt64BW.t) ->  [ &_301 <- pr19 ] s1)
      | s1 = promoted18__test_shift_ops (fun (pr18:UInt64BW.t) ->  [ &_300 <- pr18 ] s2)
      | s2 =  [ &_82 <- { _p0'3 = _301; _p1'3 = _300 } ] s3
      | s3 =  [ &left_val'3 <- _82._p0'3 ] s4
      | s4 =  [ &right_val'3 <- _82._p1'3 ] s5
      | s5 =  [ &_89 <- left_val'3 = right_val'3 ] s6
      | s6 = any [ br0 -> {_89 = false} (! bb10) | br1 -> {_89} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = promoted17__test_shift_ops (fun (pr17:UInt128BW.t) ->  [ &_299 <- pr17 ] s1)
      | s1 = promoted16__test_shift_ops (fun (pr16:UInt128BW.t) ->  [ &_298 <- pr16 ] s2)
      | s2 =  [ &_102 <- { _p0'4 = _299; _p1'4 = _298 } ] s3
      | s3 =  [ &left_val'4 <- _102._p0'4 ] s4
      | s4 =  [ &right_val'4 <- _102._p1'4 ] s5
      | s5 =  [ &_109 <- left_val'4 = right_val'4 ] s6
      | s6 = any [ br0 -> {_109 = false} (! bb12) | br1 -> {_109} (! bb11) ]  ]
    
    | bb11 = s0
      [ s0 = promoted15__test_shift_ops (fun (pr15:UInt64BW.t) ->  [ &_297 <- pr15 ] s1)
      | s1 = promoted14__test_shift_ops (fun (pr14:UInt64BW.t) ->  [ &_296 <- pr14 ] s2)
      | s2 =  [ &_122 <- { _p0'5 = _297; _p1'5 = _296 } ] s3
      | s3 =  [ &left_val'5 <- _122._p0'5 ] s4
      | s4 =  [ &right_val'5 <- _122._p1'5 ] s5
      | s5 =  [ &_129 <- left_val'5 = right_val'5 ] s6
      | s6 = any [ br0 -> {_129 = false} (! bb14) | br1 -> {_129} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = promoted13__test_shift_ops (fun (pr13:UInt8BW.t) ->  [ &_295 <- pr13 ] s1)
      | s1 = promoted12__test_shift_ops (fun (pr12:UInt8BW.t) ->  [ &_294 <- pr12 ] s2)
      | s2 =  [ &_142 <- { _p0 = _295; _p1 = _294 } ] s3
      | s3 =  [ &left_val'6 <- _142._p0 ] s4
      | s4 =  [ &right_val'6 <- _142._p1 ] s5
      | s5 =  [ &_149 <- left_val'6 = right_val'6 ] s6
      | s6 = any [ br0 -> {_149 = false} (! bb16) | br1 -> {_149} (! bb15) ]  ]
    
    | bb15 = s0
      [ s0 = promoted11__test_shift_ops (fun (pr11:Int8BW.t) ->  [ &_293 <- pr11 ] s1)
      | s1 = promoted10__test_shift_ops (fun (pr10:Int8BW.t) ->  [ &_292 <- pr10 ] s2)
      | s2 =  [ &_162 <- { _p0'0 = _293; _p1'0 = _292 } ] s3
      | s3 =  [ &left_val'7 <- _162._p0'0 ] s4
      | s4 =  [ &right_val'7 <- _162._p1'0 ] s5
      | s5 =  [ &_170 <- left_val'7 = right_val'7 ] s6
      | s6 = any [ br0 -> {_170 = false} (! bb18) | br1 -> {_170} (! bb17) ]  ]
    
    | bb17 = s0
      [ s0 = promoted9__test_shift_ops (fun (pr9:UInt16BW.t) ->  [ &_291 <- pr9 ] s1)
      | s1 = promoted8__test_shift_ops (fun (pr8:UInt16BW.t) ->  [ &_290 <- pr8 ] s2)
      | s2 =  [ &_183 <- { _p0'1 = _291; _p1'1 = _290 } ] s3
      | s3 =  [ &left_val'8 <- _183._p0'1 ] s4
      | s4 =  [ &right_val'8 <- _183._p1'1 ] s5
      | s5 =  [ &_190 <- left_val'8 = right_val'8 ] s6
      | s6 = any [ br0 -> {_190 = false} (! bb20) | br1 -> {_190} (! bb19) ]  ]
    
    | bb19 = s0
      [ s0 = promoted7__test_shift_ops (fun (pr7:UInt32BW.t) ->  [ &_289 <- pr7 ] s1)
      | s1 = promoted6__test_shift_ops (fun (pr6:UInt32BW.t) ->  [ &_288 <- pr6 ] s2)
      | s2 =  [ &_203 <- { _p0'2 = _289; _p1'2 = _288 } ] s3
      | s3 =  [ &left_val'9 <- _203._p0'2 ] s4
      | s4 =  [ &right_val'9 <- _203._p1'2 ] s5
      | s5 =  [ &_210 <- left_val'9 = right_val'9 ] s6
      | s6 = any [ br0 -> {_210 = false} (! bb22) | br1 -> {_210} (! bb21) ]  ]
    
    | bb21 = s0
      [ s0 = promoted5__test_shift_ops (fun (pr5:UInt64BW.t) ->  [ &_287 <- pr5 ] s1)
      | s1 = promoted4__test_shift_ops (fun (pr4:UInt64BW.t) ->  [ &_286 <- pr4 ] s2)
      | s2 =  [ &_223 <- { _p0'3 = _287; _p1'3 = _286 } ] s3
      | s3 =  [ &left_val'10 <- _223._p0'3 ] s4
      | s4 =  [ &right_val'10 <- _223._p1'3 ] s5
      | s5 =  [ &_230 <- left_val'10 = right_val'10 ] s6
      | s6 = any [ br0 -> {_230 = false} (! bb24) | br1 -> {_230} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = promoted3__test_shift_ops (fun (pr3:UInt128BW.t) ->  [ &_285 <- pr3 ] s1)
      | s1 = promoted2__test_shift_ops (fun (pr2:UInt128BW.t) ->  [ &_284 <- pr2 ] s2)
      | s2 =  [ &_243 <- { _p0'4 = _285; _p1'4 = _284 } ] s3
      | s3 =  [ &left_val'11 <- _243._p0'4 ] s4
      | s4 =  [ &right_val'11 <- _243._p1'4 ] s5
      | s5 =  [ &_250 <- left_val'11 = right_val'11 ] s6
      | s6 = any [ br0 -> {_250 = false} (! bb26) | br1 -> {_250} (! bb25) ]  ]
    
    | bb25 = s0
      [ s0 = promoted1__test_shift_ops (fun (pr1:UInt64BW.t) ->  [ &_283 <- pr1 ] s1)
      | s1 = promoted0__test_shift_ops (fun (pr0:UInt64BW.t) ->  [ &_282 <- pr0 ] s2)
      | s2 =  [ &_263 <- { _p0'5 = _283; _p1'5 = _282 } ] s3
      | s3 =  [ &left_val'12 <- _263._p0'5 ] s4
      | s4 =  [ &right_val'12 <- _263._p1'5 ] s5
      | s5 =  [ &_270 <- left_val'12 = right_val'12 ] s6
      | s6 = any [ br0 -> {_270 = false} (! bb28) | br1 -> {_270} (! bb27) ]  ]
    
    | bb27 = return''0 {_0}
    | bb28 = s0
      [ s0 =  [ &kind'12 <- C_Eq ] s1
      | s1 =  [ &_278 <- left_val'12 ] s2
      | s2 =  [ &_280 <- right_val'12 ] s3
      | s3 = {false} any ]
    
    | bb26 = s0
      [ s0 =  [ &kind'11 <- C_Eq ] s1
      | s1 =  [ &_258 <- left_val'11 ] s2
      | s2 =  [ &_260 <- right_val'11 ] s3
      | s3 = {false} any ]
    
    | bb24 = s0
      [ s0 =  [ &kind'10 <- C_Eq ] s1
      | s1 =  [ &_238 <- left_val'10 ] s2
      | s2 =  [ &_240 <- right_val'10 ] s3
      | s3 = {false} any ]
    
    | bb22 = s0
      [ s0 =  [ &kind'9 <- C_Eq ] s1
      | s1 =  [ &_218 <- left_val'9 ] s2
      | s2 =  [ &_220 <- right_val'9 ] s3
      | s3 = {false} any ]
    
    | bb20 = s0
      [ s0 =  [ &kind'8 <- C_Eq ] s1
      | s1 =  [ &_198 <- left_val'8 ] s2
      | s2 =  [ &_200 <- right_val'8 ] s3
      | s3 = {false} any ]
    
    | bb18 = s0
      [ s0 =  [ &kind'7 <- C_Eq ] s1
      | s1 =  [ &_178 <- left_val'7 ] s2
      | s2 =  [ &_180 <- right_val'7 ] s3
      | s3 = {false} any ]
    
    | bb16 = s0
      [ s0 =  [ &kind'6 <- C_Eq ] s1
      | s1 =  [ &_157 <- left_val'6 ] s2
      | s2 =  [ &_159 <- right_val'6 ] s3
      | s3 = {false} any ]
    
    | bb14 = s0
      [ s0 =  [ &kind'5 <- C_Eq ] s1
      | s1 =  [ &_137 <- left_val'5 ] s2
      | s2 =  [ &_139 <- right_val'5 ] s3
      | s3 = {false} any ]
    
    | bb12 = s0
      [ s0 =  [ &kind'4 <- C_Eq ] s1
      | s1 =  [ &_117 <- left_val'4 ] s2
      | s2 =  [ &_119 <- right_val'4 ] s3
      | s3 = {false} any ]
    
    | bb10 = s0
      [ s0 =  [ &kind'3 <- C_Eq ] s1
      | s1 =  [ &_97 <- left_val'3 ] s2
      | s2 =  [ &_99 <- right_val'3 ] s3
      | s3 = {false} any ]
    
    | bb8 = s0
      [ s0 =  [ &kind'2 <- C_Eq ] s1
      | s1 =  [ &_77 <- left_val'2 ] s2
      | s2 =  [ &_79 <- right_val'2 ] s3
      | s3 = {false} any ]
    
    | bb6 = s0
      [ s0 =  [ &kind'1 <- C_Eq ] s1
      | s1 =  [ &_57 <- left_val'1 ] s2
      | s2 =  [ &_59 <- right_val'1 ] s3
      | s3 = {false} any ]
    
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_37 <- left_val'0 ] s2
      | s2 =  [ &_39 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_17 <- left_val ] s2 | s2 =  [ &_19 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: tuple = Any.any_l ()
    | & left_val: UInt8BW.t = Any.any_l ()
    | & right_val: UInt8BW.t = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _17: UInt8BW.t = Any.any_l ()
    | & _19: UInt8BW.t = Any.any_l ()
    | & _22: tuple'0 = Any.any_l ()
    | & left_val'0: Int8BW.t = Any.any_l ()
    | & right_val'0: Int8BW.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _37: Int8BW.t = Any.any_l ()
    | & _39: Int8BW.t = Any.any_l ()
    | & _42: tuple'1 = Any.any_l ()
    | & left_val'1: UInt16BW.t = Any.any_l ()
    | & right_val'1: UInt16BW.t = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & kind'1: t_AssertKind = Any.any_l ()
    | & _57: UInt16BW.t = Any.any_l ()
    | & _59: UInt16BW.t = Any.any_l ()
    | & _62: tuple'2 = Any.any_l ()
    | & left_val'2: UInt32BW.t = Any.any_l ()
    | & right_val'2: UInt32BW.t = Any.any_l ()
    | & _69: bool = Any.any_l ()
    | & kind'2: t_AssertKind = Any.any_l ()
    | & _77: UInt32BW.t = Any.any_l ()
    | & _79: UInt32BW.t = Any.any_l ()
    | & _82: tuple'3 = Any.any_l ()
    | & left_val'3: UInt64BW.t = Any.any_l ()
    | & right_val'3: UInt64BW.t = Any.any_l ()
    | & _89: bool = Any.any_l ()
    | & kind'3: t_AssertKind = Any.any_l ()
    | & _97: UInt64BW.t = Any.any_l ()
    | & _99: UInt64BW.t = Any.any_l ()
    | & _102: tuple'4 = Any.any_l ()
    | & left_val'4: UInt128BW.t = Any.any_l ()
    | & right_val'4: UInt128BW.t = Any.any_l ()
    | & _109: bool = Any.any_l ()
    | & kind'4: t_AssertKind = Any.any_l ()
    | & _117: UInt128BW.t = Any.any_l ()
    | & _119: UInt128BW.t = Any.any_l ()
    | & _122: tuple'5 = Any.any_l ()
    | & left_val'5: UInt64BW.t = Any.any_l ()
    | & right_val'5: UInt64BW.t = Any.any_l ()
    | & _129: bool = Any.any_l ()
    | & kind'5: t_AssertKind = Any.any_l ()
    | & _137: UInt64BW.t = Any.any_l ()
    | & _139: UInt64BW.t = Any.any_l ()
    | & _142: tuple = Any.any_l ()
    | & left_val'6: UInt8BW.t = Any.any_l ()
    | & right_val'6: UInt8BW.t = Any.any_l ()
    | & _149: bool = Any.any_l ()
    | & kind'6: t_AssertKind = Any.any_l ()
    | & _157: UInt8BW.t = Any.any_l ()
    | & _159: UInt8BW.t = Any.any_l ()
    | & _162: tuple'0 = Any.any_l ()
    | & left_val'7: Int8BW.t = Any.any_l ()
    | & right_val'7: Int8BW.t = Any.any_l ()
    | & _170: bool = Any.any_l ()
    | & kind'7: t_AssertKind = Any.any_l ()
    | & _178: Int8BW.t = Any.any_l ()
    | & _180: Int8BW.t = Any.any_l ()
    | & _183: tuple'1 = Any.any_l ()
    | & left_val'8: UInt16BW.t = Any.any_l ()
    | & right_val'8: UInt16BW.t = Any.any_l ()
    | & _190: bool = Any.any_l ()
    | & kind'8: t_AssertKind = Any.any_l ()
    | & _198: UInt16BW.t = Any.any_l ()
    | & _200: UInt16BW.t = Any.any_l ()
    | & _203: tuple'2 = Any.any_l ()
    | & left_val'9: UInt32BW.t = Any.any_l ()
    | & right_val'9: UInt32BW.t = Any.any_l ()
    | & _210: bool = Any.any_l ()
    | & kind'9: t_AssertKind = Any.any_l ()
    | & _218: UInt32BW.t = Any.any_l ()
    | & _220: UInt32BW.t = Any.any_l ()
    | & _223: tuple'3 = Any.any_l ()
    | & left_val'10: UInt64BW.t = Any.any_l ()
    | & right_val'10: UInt64BW.t = Any.any_l ()
    | & _230: bool = Any.any_l ()
    | & kind'10: t_AssertKind = Any.any_l ()
    | & _238: UInt64BW.t = Any.any_l ()
    | & _240: UInt64BW.t = Any.any_l ()
    | & _243: tuple'4 = Any.any_l ()
    | & left_val'11: UInt128BW.t = Any.any_l ()
    | & right_val'11: UInt128BW.t = Any.any_l ()
    | & _250: bool = Any.any_l ()
    | & kind'11: t_AssertKind = Any.any_l ()
    | & _258: UInt128BW.t = Any.any_l ()
    | & _260: UInt128BW.t = Any.any_l ()
    | & _263: tuple'5 = Any.any_l ()
    | & left_val'12: UInt64BW.t = Any.any_l ()
    | & right_val'12: UInt64BW.t = Any.any_l ()
    | & _270: bool = Any.any_l ()
    | & kind'12: t_AssertKind = Any.any_l ()
    | & _278: UInt64BW.t = Any.any_l ()
    | & _280: UInt64BW.t = Any.any_l ()
    | & _282: UInt64BW.t = Any.any_l ()
    | & _283: UInt64BW.t = Any.any_l ()
    | & _284: UInt128BW.t = Any.any_l ()
    | & _285: UInt128BW.t = Any.any_l ()
    | & _286: UInt64BW.t = Any.any_l ()
    | & _287: UInt64BW.t = Any.any_l ()
    | & _288: UInt32BW.t = Any.any_l ()
    | & _289: UInt32BW.t = Any.any_l ()
    | & _290: UInt16BW.t = Any.any_l ()
    | & _291: UInt16BW.t = Any.any_l ()
    | & _292: Int8BW.t = Any.any_l ()
    | & _293: Int8BW.t = Any.any_l ()
    | & _294: UInt8BW.t = Any.any_l ()
    | & _295: UInt8BW.t = Any.any_l ()
    | & _296: UInt64BW.t = Any.any_l ()
    | & _297: UInt64BW.t = Any.any_l ()
    | & _298: UInt128BW.t = Any.any_l ()
    | & _299: UInt128BW.t = Any.any_l ()
    | & _300: UInt64BW.t = Any.any_l ()
    | & _301: UInt64BW.t = Any.any_l ()
    | & _302: UInt32BW.t = Any.any_l ()
    | & _303: UInt32BW.t = Any.any_l ()
    | & _304: UInt16BW.t = Any.any_l ()
    | & _305: UInt16BW.t = Any.any_l ()
    | & _306: Int8BW.t = Any.any_l ()
    | & _307: Int8BW.t = Any.any_l ()
    | & _308: UInt8BW.t = Any.any_l ()
    | & _309: UInt8BW.t = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_integer_ops__u8__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:UInt8.t) (r:UInt8.t) (return'  (x:UInt8.t))= {[@expl:test_add requires] [%#sinteger_ops] UInt8.t'int l
    + UInt8.t'int r
    >= UInt8.t'int (v_MIN: UInt8.t)
    /\ UInt8.t'int l + UInt8.t'int r <= UInt8.t'int (v_MAX: UInt8.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8.add {l'0} {r'0} (fun (_ret:UInt8.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt8.t = Any.any_l () | & l'0: UInt8.t = l | & r'0: UInt8.t = r ] 
    [ return''0 (result:UInt8.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] UInt8.t'int result
      = UInt8.t'int l + UInt8.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt8BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt8BW.t = (0: UInt8BW.t)
  
  constant v_MAX: UInt8BW.t = (255: UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:UInt8BW.t) (r:UInt8BW.t) (return'  (x:UInt8BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] UInt8BW.t'int l
    + UInt8BW.t'int r
    >= UInt8BW.t'int (v_MIN: UInt8BW.t)
    /\ UInt8BW.t'int l + UInt8BW.t'int r <= UInt8BW.t'int (v_MAX: UInt8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.add {l'0} {r'0} (fun (_ret:UInt8BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt8BW.t = Any.any_l () | & l'0: UInt8BW.t = l | & r'0: UInt8BW.t = r ] 
    [ return''0 (result:UInt8BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] UInt8BW.t'int result
      = UInt8BW.t'int l + UInt8BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:UInt8.t) (r:UInt8.t) (return'  (x:UInt8.t))= {[@expl:test_sub requires] [%#sinteger_ops] UInt8.t'int l
    - UInt8.t'int r
    >= UInt8.t'int (v_MIN: UInt8.t)
    /\ UInt8.t'int l - UInt8.t'int r <= UInt8.t'int (v_MAX: UInt8.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8.sub {l'0} {r'0} (fun (_ret:UInt8.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt8.t = Any.any_l () | & l'0: UInt8.t = l | & r'0: UInt8.t = r ] 
    [ return''0 (result:UInt8.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] UInt8.t'int result
      = UInt8.t'int l - UInt8.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt8BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt8BW.t = (0: UInt8BW.t)
  
  constant v_MAX: UInt8BW.t = (255: UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:UInt8BW.t) (r:UInt8BW.t) (return'  (x:UInt8BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] UInt8BW.t'int l
    - UInt8BW.t'int r
    >= UInt8BW.t'int (v_MIN: UInt8BW.t)
    /\ UInt8BW.t'int l - UInt8BW.t'int r <= UInt8BW.t'int (v_MAX: UInt8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.sub {l'0} {r'0} (fun (_ret:UInt8BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt8BW.t = Any.any_l () | & l'0: UInt8BW.t = l | & r'0: UInt8BW.t = r ] 
    [ return''0 (result:UInt8BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] UInt8BW.t'int result
      = UInt8BW.t'int l - UInt8BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:UInt8.t) (r:UInt8.t) (return'  (x:UInt8.t))= {[@expl:test_mul requires] [%#sinteger_ops] UInt8.t'int l
    * UInt8.t'int r
    >= UInt8.t'int (v_MIN: UInt8.t)
    /\ UInt8.t'int l * UInt8.t'int r <= UInt8.t'int (v_MAX: UInt8.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8.mul {l'0} {r'0} (fun (_ret:UInt8.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt8.t = Any.any_l () | & l'0: UInt8.t = l | & r'0: UInt8.t = r ] 
    [ return''0 (result:UInt8.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] UInt8.t'int result
      = UInt8.t'int l * UInt8.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt8BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt8BW.t = (0: UInt8BW.t)
  
  constant v_MAX: UInt8BW.t = (255: UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:UInt8BW.t) (r:UInt8BW.t) (return'  (x:UInt8BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] UInt8BW.t'int l
    * UInt8BW.t'int r
    >= UInt8BW.t'int (v_MIN: UInt8BW.t)
    /\ UInt8BW.t'int l * UInt8BW.t'int r <= UInt8BW.t'int (v_MAX: UInt8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.mul {l'0} {r'0} (fun (_ret:UInt8BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt8BW.t = Any.any_l () | & l'0: UInt8BW.t = l | & r'0: UInt8BW.t = r ] 
    [ return''0 (result:UInt8BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] UInt8BW.t'int result
      = UInt8BW.t'int l * UInt8BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:UInt8.t) (r:UInt8.t) (return'  (x:UInt8.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] UInt8.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (UInt8.t'int l) (UInt8.t'int r)
    >= UInt8.t'int (v_MIN: UInt8.t)
    /\ Int.div (UInt8.t'int l) (UInt8.t'int r) <= UInt8.t'int (v_MAX: UInt8.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt8.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt8.div {l'0} {_7} (fun (_ret:UInt8.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt8.t = Any.any_l ()
    | & l'0: UInt8.t = l
    | & r'0: UInt8.t = r
    | & _7: UInt8.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt8.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] UInt8.t'int result
      = Int.div (UInt8.t'int l) (UInt8.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt8BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt8BW.t = (0: UInt8BW.t)
  
  constant v_MAX: UInt8BW.t = (255: UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:UInt8BW.t) (r:UInt8BW.t) (return'  (x:UInt8BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] UInt8BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (UInt8BW.t'int l) (UInt8BW.t'int r)
    >= UInt8BW.t'int (v_MIN: UInt8BW.t)
    /\ Int.div (UInt8BW.t'int l) (UInt8BW.t'int r) <= UInt8BW.t'int (v_MAX: UInt8BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt8BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt8BW.div {l'0} {_7} (fun (_ret:UInt8BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt8BW.t = Any.any_l ()
    | & l'0: UInt8BW.t = l
    | & r'0: UInt8BW.t = r
    | & _7: UInt8BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt8BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] UInt8BW.t'int result
      = Int.div (UInt8BW.t'int l) (UInt8BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:UInt8.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8.t = Any.any_l () | & _1: UInt8.t = Any.any_l () ]  [ return''0 (result:UInt8.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool (return'  (x:UInt8.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt8.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8.t = Any.any_l () ]  [ return''0 (result:UInt8.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt8.t; _p1: UInt8.t }
  
  let rec promoted1__test_from_bool (return'  (x:UInt8.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8.t = Any.any_l () | & _1: UInt8.t = Any.any_l () ]  [ return''0 (result:UInt8.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool (return'  (x:UInt8.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt8.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8.t = Any.any_l () ]  [ return''0 (result:UInt8.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:UInt8.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:UInt8.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:UInt8.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:UInt8.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:UInt8.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt8.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt8.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt8.t = Any.any_l ()
    | & right_val: UInt8.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt8.t = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt8.t = Any.any_l ()
    | & right_val'0: UInt8.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt8.t = Any.any_l ()
    | & _41: UInt8.t = Any.any_l ()
    | & _44: UInt8.t = Any.any_l ()
    | & _45: UInt8.t = Any.any_l ()
    | & _46: UInt8.t = Any.any_l ()
    | & _47: UInt8.t = Any.any_l () ]
    
    [ return''0 (result:UInt8.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = UInt8.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ] 
    [ return''0 (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8BW.t = Any.any_l () ]  [ return''0 (result:UInt8BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt8BW.t; _p1: UInt8BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt8BW.t = Any.any_l () | & _1: UInt8BW.t = Any.any_l () ] 
    [ return''0 (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt8BW.t = Any.any_l () ]  [ return''0 (result:UInt8BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:UInt8BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:UInt8BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:UInt8BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:UInt8BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:UInt8BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt8BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt8BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt8BW.t = Any.any_l ()
    | & right_val: UInt8BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt8BW.t = Any.any_l ()
    | & _21: UInt8BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt8BW.t = Any.any_l ()
    | & right_val'0: UInt8BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt8BW.t = Any.any_l ()
    | & _41: UInt8BW.t = Any.any_l ()
    | & _44: UInt8BW.t = Any.any_l ()
    | & _45: UInt8BW.t = Any.any_l ()
    | & _46: UInt8BW.t = Any.any_l ()
    | & _47: UInt8BW.t = Any.any_l () ]
    
    [ return''0 (result:UInt8BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = UInt8BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:UInt8.t) (return'  (x:UInt8.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt8.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))} (fun (_ret:UInt8.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt8.t = Any.any_l () | & n'0: UInt8.t = n ] 
    [ return''0 (result:UInt8.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = UInt8.lsl_bv n (3: UInt8.t)}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:UInt8BW.t) (return'  (x:UInt8BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt8BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:UInt8BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt8BW.t = Any.any_l () | & n'0: UInt8BW.t = n ] 
    [ return''0 (result:UInt8BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = UInt8BW.lsl_bv n (3: UInt8BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_to_char [#"integer_ops.rs" 183 4 183 25]
  let%span sinteger_ops = "integer_ops.rs" 184 20 184 24
  let%span sinteger_ops'0 = "integer_ops.rs" 184 41 184 44
  
  use creusot.prelude.Char
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  let rec promoted1__test_to_char (return'  (x:Char.t))= bb0
    [ bb0 = s0
      [ s0 = Char.of_int {UInt8.t'int ([%#sinteger_ops] (97: UInt8.t))}
          (fun (_ret_from:Char.t) ->  [ &_1 <- _ret_from ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Char.t = Any.any_l () | & _1: Char.t = Any.any_l () ]  [ return''0 (result:Char.t)-> return' {result} ] 
  
  let rec promoted0__test_to_char (return'  (x:Char.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'0] Char.of_int 97 ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Char.t = Any.any_l () ]  [ return''0 (result:Char.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Char.t; _p1: Char.t }
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_to_char[#"integer_ops.rs" 183 4 183 25] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted1__test_to_char (fun (pr1:Char.t) ->  [ &_23 <- pr1 ] s1)
      | s1 = promoted0__test_to_char (fun (pr0:Char.t) ->  [ &_22 <- pr0 ] s2)
      | s2 =  [ &_2 <- { _p0 = _23; _p1 = _22 } ] s3
      | s3 =  [ &left_val <- _2._p0 ] s4
      | s4 =  [ &right_val <- _2._p1 ] s5
      | s5 =  [ &_10 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_10 = false} (! bb2) | br1 -> {_10} (! bb1) ]  ]
    
    | bb1 = return''0 {_0}
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_18 <- left_val ] s2 | s2 =  [ &_20 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: tuple = Any.any_l ()
    | & left_val: Char.t = Any.any_l ()
    | & right_val: Char.t = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _18: Char.t = Any.any_l ()
    | & _20: Char.t = Any.any_l ()
    | & _22: Char.t = Any.any_l ()
    | & _23: Char.t = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_integer_ops__u8__test_to_char_bw [#"integer_ops.rs" 189 4 189 28]
  let%span sinteger_ops = "integer_ops.rs" 190 20 190 24
  let%span sinteger_ops'0 = "integer_ops.rs" 190 41 190 44
  
  use creusot.prelude.Char
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  
  let rec promoted1__test_to_char_bw (return'  (x:Char.t))= bb0
    [ bb0 = s0
      [ s0 = Char.of_BV256 {UInt8BW.to_BV256 ([%#sinteger_ops] (255: UInt8BW.t))}
          (fun (_ret_from:Char.t) ->  [ &_1 <- _ret_from ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Char.t = Any.any_l () | & _1: Char.t = Any.any_l () ]  [ return''0 (result:Char.t)-> return' {result} ] 
  
  let rec promoted0__test_to_char_bw (return'  (x:Char.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'0] Char.of_int 255 ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Char.t = Any.any_l () ]  [ return''0 (result:Char.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Char.t; _p1: Char.t }
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_to_char_bw[#"integer_ops.rs" 189 4 189 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted1__test_to_char_bw (fun (pr1:Char.t) ->  [ &_23 <- pr1 ] s1)
      | s1 = promoted0__test_to_char_bw (fun (pr0:Char.t) ->  [ &_22 <- pr0 ] s2)
      | s2 =  [ &_2 <- { _p0 = _23; _p1 = _22 } ] s3
      | s3 =  [ &left_val <- _2._p0 ] s4
      | s4 =  [ &right_val <- _2._p1 ] s5
      | s5 =  [ &_10 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_10 = false} (! bb2) | br1 -> {_10} (! bb1) ]  ]
    
    | bb1 = return''0 {_0}
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_18 <- left_val ] s2 | s2 =  [ &_20 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: tuple = Any.any_l ()
    | & left_val: Char.t = Any.any_l ()
    | & right_val: Char.t = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _18: Char.t = Any.any_l ()
    | & _20: Char.t = Any.any_l ()
    | & _22: Char.t = Any.any_l ()
    | & _23: Char.t = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_integer_ops__i8__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:Int8.t) (r:Int8.t) (return'  (x:Int8.t))= {[@expl:test_add requires] [%#sinteger_ops] Int8.to_int l
    + Int8.to_int r
    >= Int8.to_int (v_MIN: Int8.t)
    /\ Int8.to_int l + Int8.to_int r <= Int8.to_int (v_MAX: Int8.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8.add {l'0} {r'0} (fun (_ret:Int8.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int8.t = Any.any_l () | & l'0: Int8.t = l | & r'0: Int8.t = r ] 
    [ return''0 (result:Int8.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] Int8.to_int result
      = Int8.to_int l + Int8.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int8BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int8BW.t = (128: Int8BW.t)
  
  constant v_MAX: Int8BW.t = (127: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:Int8BW.t) (r:Int8BW.t) (return'  (x:Int8BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] Int8BW.to_int l
    + Int8BW.to_int r
    >= Int8BW.to_int (v_MIN: Int8BW.t)
    /\ Int8BW.to_int l + Int8BW.to_int r <= Int8BW.to_int (v_MAX: Int8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.add {l'0} {r'0} (fun (_ret:Int8BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int8BW.t = Any.any_l () | & l'0: Int8BW.t = l | & r'0: Int8BW.t = r ] 
    [ return''0 (result:Int8BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] Int8BW.to_int result
      = Int8BW.to_int l + Int8BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:Int8.t) (r:Int8.t) (return'  (x:Int8.t))= {[@expl:test_sub requires] [%#sinteger_ops] Int8.to_int l
    - Int8.to_int r
    >= Int8.to_int (v_MIN: Int8.t)
    /\ Int8.to_int l - Int8.to_int r <= Int8.to_int (v_MAX: Int8.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8.sub {l'0} {r'0} (fun (_ret:Int8.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int8.t = Any.any_l () | & l'0: Int8.t = l | & r'0: Int8.t = r ] 
    [ return''0 (result:Int8.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] Int8.to_int result
      = Int8.to_int l - Int8.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int8BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int8BW.t = (128: Int8BW.t)
  
  constant v_MAX: Int8BW.t = (127: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:Int8BW.t) (r:Int8BW.t) (return'  (x:Int8BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] Int8BW.to_int l
    - Int8BW.to_int r
    >= Int8BW.to_int (v_MIN: Int8BW.t)
    /\ Int8BW.to_int l - Int8BW.to_int r <= Int8BW.to_int (v_MAX: Int8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.sub {l'0} {r'0} (fun (_ret:Int8BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int8BW.t = Any.any_l () | & l'0: Int8BW.t = l | & r'0: Int8BW.t = r ] 
    [ return''0 (result:Int8BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] Int8BW.to_int result
      = Int8BW.to_int l - Int8BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:Int8.t) (r:Int8.t) (return'  (x:Int8.t))= {[@expl:test_mul requires] [%#sinteger_ops] Int8.to_int l
    * Int8.to_int r
    >= Int8.to_int (v_MIN: Int8.t)
    /\ Int8.to_int l * Int8.to_int r <= Int8.to_int (v_MAX: Int8.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8.mul {l'0} {r'0} (fun (_ret:Int8.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int8.t = Any.any_l () | & l'0: Int8.t = l | & r'0: Int8.t = r ] 
    [ return''0 (result:Int8.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] Int8.to_int result
      = Int8.to_int l * Int8.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int8BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int8BW.t = (128: Int8BW.t)
  
  constant v_MAX: Int8BW.t = (127: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:Int8BW.t) (r:Int8BW.t) (return'  (x:Int8BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] Int8BW.to_int l
    * Int8BW.to_int r
    >= Int8BW.to_int (v_MIN: Int8BW.t)
    /\ Int8BW.to_int l * Int8BW.to_int r <= Int8BW.to_int (v_MAX: Int8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.mul {l'0} {r'0} (fun (_ret:Int8BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int8BW.t = Any.any_l () | & l'0: Int8BW.t = l | & r'0: Int8BW.t = r ] 
    [ return''0 (result:Int8BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] Int8BW.to_int result
      = Int8BW.to_int l * Int8BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int8
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:Int8.t) (r:Int8.t) (return'  (x:Int8.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] Int8.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (Int8.to_int l) (Int8.to_int r)
    >= Int8.to_int (v_MIN: Int8.t)
    /\ Int.div (Int8.to_int l) (Int8.to_int r) <= Int8.to_int (v_MAX: Int8.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int8.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (-1: Int8.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (-128: Int8.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int8.div {_6} {_7} (fun (_ret:Int8.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int8.t = Any.any_l ()
    | & l'0: Int8.t = l
    | & r'0: Int8.t = r
    | & _6: Int8.t = Any.any_l ()
    | & _7: Int8.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int8.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] Int8.to_int result
      = Int.div (Int8.to_int l) (Int8.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int8BW
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int8BW.t = (128: Int8BW.t)
  
  constant v_MAX: Int8BW.t = (127: Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:Int8BW.t) (r:Int8BW.t) (return'  (x:Int8BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] Int8BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (Int8BW.to_int l) (Int8BW.to_int r)
    >= Int8BW.to_int (v_MIN: Int8BW.t)
    /\ Int.div (Int8BW.to_int l) (Int8BW.to_int r) <= Int8BW.to_int (v_MAX: Int8BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int8BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (255: Int8BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (128: Int8BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int8BW.div {_6} {_7} (fun (_ret:Int8BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int8BW.t = Any.any_l ()
    | & l'0: Int8BW.t = l
    | & r'0: Int8BW.t = r
    | & _6: Int8BW.t = Any.any_l ()
    | & _7: Int8BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int8BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] Int8BW.to_int result
      = Int.div (Int8BW.to_int l) (Int8BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:Int8.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8.t = Any.any_l () | & _1: Int8.t = Any.any_l () ]  [ return''0 (result:Int8.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool (return'  (x:Int8.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int8.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8.t = Any.any_l () ]  [ return''0 (result:Int8.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int8.t; _p1: Int8.t }
  
  let rec promoted1__test_from_bool (return'  (x:Int8.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8.t = Any.any_l () | & _1: Int8.t = Any.any_l () ]  [ return''0 (result:Int8.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool (return'  (x:Int8.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int8.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8.t = Any.any_l () ]  [ return''0 (result:Int8.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:Int8.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:Int8.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:Int8.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:Int8.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:Int8.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int8.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int8.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int8.t = Any.any_l ()
    | & right_val: Int8.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int8.t = Any.any_l ()
    | & _21: Int8.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int8.t = Any.any_l ()
    | & right_val'0: Int8.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int8.t = Any.any_l ()
    | & _41: Int8.t = Any.any_l ()
    | & _44: Int8.t = Any.any_l ()
    | & _45: Int8.t = Any.any_l ()
    | & _46: Int8.t = Any.any_l ()
    | & _47: Int8.t = Any.any_l () ]
    
    [ return''0 (result:Int8.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = Int8.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int8BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8BW.t = Any.any_l () ]  [ return''0 (result:Int8BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int8BW.t; _p1: Int8BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int8BW.t = Any.any_l () | & _1: Int8BW.t = Any.any_l () ] 
    [ return''0 (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int8BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int8BW.t = Any.any_l () ]  [ return''0 (result:Int8BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:Int8BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:Int8BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:Int8BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:Int8BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:Int8BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int8BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int8BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int8BW.t = Any.any_l ()
    | & right_val: Int8BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int8BW.t = Any.any_l ()
    | & _21: Int8BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int8BW.t = Any.any_l ()
    | & right_val'0: Int8BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int8BW.t = Any.any_l ()
    | & _41: Int8BW.t = Any.any_l ()
    | & _44: Int8BW.t = Any.any_l ()
    | & _45: Int8BW.t = Any.any_l ()
    | & _46: Int8BW.t = Any.any_l ()
    | & _47: Int8BW.t = Any.any_l () ]
    
    [ return''0 (result:Int8BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = Int8BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:Int8.t) (return'  (x:Int8.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int8.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))} (fun (_ret:Int8.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int8.t = Any.any_l () | & n'0: Int8.t = n ] 
    [ return''0 (result:Int8.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = Int8.lsl_bv n (3: Int8.t)}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.Int8BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:Int8BW.t) (return'  (x:Int8BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int8BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:Int8BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int8BW.t = Any.any_l () | & n'0: Int8BW.t = n ] 
    [ return''0 (result:Int8BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = Int8BW.lsl_bv n (3: Int8BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt16.t = (0: UInt16.t)
  
  constant v_MAX: UInt16.t = (65535: UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:UInt16.t) (r:UInt16.t) (return'  (x:UInt16.t))= {[@expl:test_add requires] [%#sinteger_ops] UInt16.t'int l
    + UInt16.t'int r
    >= UInt16.t'int (v_MIN: UInt16.t)
    /\ UInt16.t'int l + UInt16.t'int r <= UInt16.t'int (v_MAX: UInt16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.add {l'0} {r'0} (fun (_ret:UInt16.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt16.t = Any.any_l () | & l'0: UInt16.t = l | & r'0: UInt16.t = r ] 
    [ return''0 (result:UInt16.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] UInt16.t'int result
      = UInt16.t'int l + UInt16.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt16BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt16BW.t = (0: UInt16BW.t)
  
  constant v_MAX: UInt16BW.t = (65535: UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:UInt16BW.t) (r:UInt16BW.t) (return'  (x:UInt16BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] UInt16BW.t'int l
    + UInt16BW.t'int r
    >= UInt16BW.t'int (v_MIN: UInt16BW.t)
    /\ UInt16BW.t'int l + UInt16BW.t'int r <= UInt16BW.t'int (v_MAX: UInt16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.add {l'0} {r'0} (fun (_ret:UInt16BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt16BW.t = Any.any_l () | & l'0: UInt16BW.t = l | & r'0: UInt16BW.t = r ] 
    [ return''0 (result:UInt16BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] UInt16BW.t'int result
      = UInt16BW.t'int l + UInt16BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt16.t = (0: UInt16.t)
  
  constant v_MAX: UInt16.t = (65535: UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:UInt16.t) (r:UInt16.t) (return'  (x:UInt16.t))= {[@expl:test_sub requires] [%#sinteger_ops] UInt16.t'int l
    - UInt16.t'int r
    >= UInt16.t'int (v_MIN: UInt16.t)
    /\ UInt16.t'int l - UInt16.t'int r <= UInt16.t'int (v_MAX: UInt16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.sub {l'0} {r'0} (fun (_ret:UInt16.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt16.t = Any.any_l () | & l'0: UInt16.t = l | & r'0: UInt16.t = r ] 
    [ return''0 (result:UInt16.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] UInt16.t'int result
      = UInt16.t'int l - UInt16.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt16BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt16BW.t = (0: UInt16BW.t)
  
  constant v_MAX: UInt16BW.t = (65535: UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:UInt16BW.t) (r:UInt16BW.t) (return'  (x:UInt16BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] UInt16BW.t'int l
    - UInt16BW.t'int r
    >= UInt16BW.t'int (v_MIN: UInt16BW.t)
    /\ UInt16BW.t'int l - UInt16BW.t'int r <= UInt16BW.t'int (v_MAX: UInt16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.sub {l'0} {r'0} (fun (_ret:UInt16BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt16BW.t = Any.any_l () | & l'0: UInt16BW.t = l | & r'0: UInt16BW.t = r ] 
    [ return''0 (result:UInt16BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] UInt16BW.t'int result
      = UInt16BW.t'int l - UInt16BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt16.t = (0: UInt16.t)
  
  constant v_MAX: UInt16.t = (65535: UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:UInt16.t) (r:UInt16.t) (return'  (x:UInt16.t))= {[@expl:test_mul requires] [%#sinteger_ops] UInt16.t'int l
    * UInt16.t'int r
    >= UInt16.t'int (v_MIN: UInt16.t)
    /\ UInt16.t'int l * UInt16.t'int r <= UInt16.t'int (v_MAX: UInt16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.mul {l'0} {r'0} (fun (_ret:UInt16.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt16.t = Any.any_l () | & l'0: UInt16.t = l | & r'0: UInt16.t = r ] 
    [ return''0 (result:UInt16.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] UInt16.t'int result
      = UInt16.t'int l * UInt16.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt16BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt16BW.t = (0: UInt16BW.t)
  
  constant v_MAX: UInt16BW.t = (65535: UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:UInt16BW.t) (r:UInt16BW.t) (return'  (x:UInt16BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] UInt16BW.t'int l
    * UInt16BW.t'int r
    >= UInt16BW.t'int (v_MIN: UInt16BW.t)
    /\ UInt16BW.t'int l * UInt16BW.t'int r <= UInt16BW.t'int (v_MAX: UInt16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.mul {l'0} {r'0} (fun (_ret:UInt16BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt16BW.t = Any.any_l () | & l'0: UInt16BW.t = l | & r'0: UInt16BW.t = r ] 
    [ return''0 (result:UInt16BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] UInt16BW.t'int result
      = UInt16BW.t'int l * UInt16BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt16.t = (0: UInt16.t)
  
  constant v_MAX: UInt16.t = (65535: UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:UInt16.t) (r:UInt16.t) (return'  (x:UInt16.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] UInt16.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (UInt16.t'int l) (UInt16.t'int r)
    >= UInt16.t'int (v_MIN: UInt16.t)
    /\ Int.div (UInt16.t'int l) (UInt16.t'int r) <= UInt16.t'int (v_MAX: UInt16.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt16.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt16.div {l'0} {_7} (fun (_ret:UInt16.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt16.t = Any.any_l ()
    | & l'0: UInt16.t = l
    | & r'0: UInt16.t = r
    | & _7: UInt16.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt16.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] UInt16.t'int result
      = Int.div (UInt16.t'int l) (UInt16.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt16BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt16BW.t = (0: UInt16BW.t)
  
  constant v_MAX: UInt16BW.t = (65535: UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:UInt16BW.t) (r:UInt16BW.t) (return'  (x:UInt16BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] UInt16BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (UInt16BW.t'int l) (UInt16BW.t'int r)
    >= UInt16BW.t'int (v_MIN: UInt16BW.t)
    /\ Int.div (UInt16BW.t'int l) (UInt16BW.t'int r) <= UInt16BW.t'int (v_MAX: UInt16BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt16BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt16BW.div {l'0} {_7} (fun (_ret:UInt16BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt16BW.t = Any.any_l ()
    | & l'0: UInt16BW.t = l
    | & r'0: UInt16BW.t = r
    | & _7: UInt16BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt16BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] UInt16BW.t'int result
      = Int.div (UInt16BW.t'int l) (UInt16BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:UInt16.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16.t = Any.any_l () | & _1: UInt16.t = Any.any_l () ] 
    [ return''0 (result:UInt16.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool (return'  (x:UInt16.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt16.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16.t = Any.any_l () ]  [ return''0 (result:UInt16.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt16.t; _p1: UInt16.t }
  
  let rec promoted1__test_from_bool (return'  (x:UInt16.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16.t = Any.any_l () | & _1: UInt16.t = Any.any_l () ] 
    [ return''0 (result:UInt16.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool (return'  (x:UInt16.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt16.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16.t = Any.any_l () ]  [ return''0 (result:UInt16.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:UInt16.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:UInt16.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:UInt16.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:UInt16.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:UInt16.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt16.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt16.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt16.t = Any.any_l ()
    | & right_val: UInt16.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt16.t = Any.any_l ()
    | & _21: UInt16.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt16.t = Any.any_l ()
    | & right_val'0: UInt16.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt16.t = Any.any_l ()
    | & _41: UInt16.t = Any.any_l ()
    | & _44: UInt16.t = Any.any_l ()
    | & _45: UInt16.t = Any.any_l ()
    | & _46: UInt16.t = Any.any_l ()
    | & _47: UInt16.t = Any.any_l () ]
    
    [ return''0 (result:UInt16.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = UInt16.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ] 
    [ return''0 (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16BW.t = Any.any_l () ]  [ return''0 (result:UInt16BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt16BW.t; _p1: UInt16BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt16BW.t = Any.any_l () | & _1: UInt16BW.t = Any.any_l () ] 
    [ return''0 (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt16BW.t = Any.any_l () ]  [ return''0 (result:UInt16BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:UInt16BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:UInt16BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:UInt16BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:UInt16BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:UInt16BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt16BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt16BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt16BW.t = Any.any_l ()
    | & right_val: UInt16BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt16BW.t = Any.any_l ()
    | & _21: UInt16BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt16BW.t = Any.any_l ()
    | & right_val'0: UInt16BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt16BW.t = Any.any_l ()
    | & _41: UInt16BW.t = Any.any_l ()
    | & _44: UInt16BW.t = Any.any_l ()
    | & _45: UInt16BW.t = Any.any_l ()
    | & _46: UInt16BW.t = Any.any_l ()
    | & _47: UInt16BW.t = Any.any_l () ]
    
    [ return''0 (result:UInt16BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = UInt16BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:UInt16.t) (return'  (x:UInt16.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt16.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))}
          (fun (_ret:UInt16.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt16.t = Any.any_l () | & n'0: UInt16.t = n ] 
    [ return''0 (result:UInt16.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = UInt16.lsl_bv n (3: UInt16.t)}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:UInt16BW.t) (return'  (x:UInt16BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt16BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:UInt16BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt16BW.t = Any.any_l () | & n'0: UInt16BW.t = n ] 
    [ return''0 (result:UInt16BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = UInt16BW.lsl_bv n (3: UInt16BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int16.t = (-32768: Int16.t)
  
  constant v_MAX: Int16.t = (32767: Int16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:Int16.t) (r:Int16.t) (return'  (x:Int16.t))= {[@expl:test_add requires] [%#sinteger_ops] Int16.to_int l
    + Int16.to_int r
    >= Int16.to_int (v_MIN: Int16.t)
    /\ Int16.to_int l + Int16.to_int r <= Int16.to_int (v_MAX: Int16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16.add {l'0} {r'0} (fun (_ret:Int16.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int16.t = Any.any_l () | & l'0: Int16.t = l | & r'0: Int16.t = r ] 
    [ return''0 (result:Int16.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] Int16.to_int result
      = Int16.to_int l + Int16.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int16BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int16BW.t = (32768: Int16BW.t)
  
  constant v_MAX: Int16BW.t = (32767: Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:Int16BW.t) (r:Int16BW.t) (return'  (x:Int16BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] Int16BW.to_int l
    + Int16BW.to_int r
    >= Int16BW.to_int (v_MIN: Int16BW.t)
    /\ Int16BW.to_int l + Int16BW.to_int r <= Int16BW.to_int (v_MAX: Int16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.add {l'0} {r'0} (fun (_ret:Int16BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int16BW.t = Any.any_l () | & l'0: Int16BW.t = l | & r'0: Int16BW.t = r ] 
    [ return''0 (result:Int16BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] Int16BW.to_int result
      = Int16BW.to_int l + Int16BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int16.t = (-32768: Int16.t)
  
  constant v_MAX: Int16.t = (32767: Int16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:Int16.t) (r:Int16.t) (return'  (x:Int16.t))= {[@expl:test_sub requires] [%#sinteger_ops] Int16.to_int l
    - Int16.to_int r
    >= Int16.to_int (v_MIN: Int16.t)
    /\ Int16.to_int l - Int16.to_int r <= Int16.to_int (v_MAX: Int16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16.sub {l'0} {r'0} (fun (_ret:Int16.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int16.t = Any.any_l () | & l'0: Int16.t = l | & r'0: Int16.t = r ] 
    [ return''0 (result:Int16.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] Int16.to_int result
      = Int16.to_int l - Int16.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int16BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int16BW.t = (32768: Int16BW.t)
  
  constant v_MAX: Int16BW.t = (32767: Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:Int16BW.t) (r:Int16BW.t) (return'  (x:Int16BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] Int16BW.to_int l
    - Int16BW.to_int r
    >= Int16BW.to_int (v_MIN: Int16BW.t)
    /\ Int16BW.to_int l - Int16BW.to_int r <= Int16BW.to_int (v_MAX: Int16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.sub {l'0} {r'0} (fun (_ret:Int16BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int16BW.t = Any.any_l () | & l'0: Int16BW.t = l | & r'0: Int16BW.t = r ] 
    [ return''0 (result:Int16BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] Int16BW.to_int result
      = Int16BW.to_int l - Int16BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int16.t = (-32768: Int16.t)
  
  constant v_MAX: Int16.t = (32767: Int16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:Int16.t) (r:Int16.t) (return'  (x:Int16.t))= {[@expl:test_mul requires] [%#sinteger_ops] Int16.to_int l
    * Int16.to_int r
    >= Int16.to_int (v_MIN: Int16.t)
    /\ Int16.to_int l * Int16.to_int r <= Int16.to_int (v_MAX: Int16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16.mul {l'0} {r'0} (fun (_ret:Int16.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int16.t = Any.any_l () | & l'0: Int16.t = l | & r'0: Int16.t = r ] 
    [ return''0 (result:Int16.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] Int16.to_int result
      = Int16.to_int l * Int16.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int16BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int16BW.t = (32768: Int16BW.t)
  
  constant v_MAX: Int16BW.t = (32767: Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:Int16BW.t) (r:Int16BW.t) (return'  (x:Int16BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] Int16BW.to_int l
    * Int16BW.to_int r
    >= Int16BW.to_int (v_MIN: Int16BW.t)
    /\ Int16BW.to_int l * Int16BW.to_int r <= Int16BW.to_int (v_MAX: Int16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.mul {l'0} {r'0} (fun (_ret:Int16BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int16BW.t = Any.any_l () | & l'0: Int16BW.t = l | & r'0: Int16BW.t = r ] 
    [ return''0 (result:Int16BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] Int16BW.to_int result
      = Int16BW.to_int l * Int16BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int16
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int16.t = (-32768: Int16.t)
  
  constant v_MAX: Int16.t = (32767: Int16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:Int16.t) (r:Int16.t) (return'  (x:Int16.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] Int16.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (Int16.to_int l) (Int16.to_int r)
    >= Int16.to_int (v_MIN: Int16.t)
    /\ Int.div (Int16.to_int l) (Int16.to_int r) <= Int16.to_int (v_MAX: Int16.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int16.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (-1: Int16.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (-32768: Int16.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int16.div {_6} {_7} (fun (_ret:Int16.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int16.t = Any.any_l ()
    | & l'0: Int16.t = l
    | & r'0: Int16.t = r
    | & _6: Int16.t = Any.any_l ()
    | & _7: Int16.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int16.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] Int16.to_int result
      = Int.div (Int16.to_int l) (Int16.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int16BW
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int16BW.t = (32768: Int16BW.t)
  
  constant v_MAX: Int16BW.t = (32767: Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:Int16BW.t) (r:Int16BW.t) (return'  (x:Int16BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] Int16BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (Int16BW.to_int l) (Int16BW.to_int r)
    >= Int16BW.to_int (v_MIN: Int16BW.t)
    /\ Int.div (Int16BW.to_int l) (Int16BW.to_int r) <= Int16BW.to_int (v_MAX: Int16BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int16BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (65535: Int16BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (32768: Int16BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int16BW.div {_6} {_7} (fun (_ret:Int16BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int16BW.t = Any.any_l ()
    | & l'0: Int16BW.t = l
    | & r'0: Int16BW.t = r
    | & _6: Int16BW.t = Any.any_l ()
    | & _7: Int16BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int16BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] Int16BW.to_int result
      = Int.div (Int16BW.to_int l) (Int16BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:Int16.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int16.t = Any.any_l () | & _1: Int16.t = Any.any_l () ]  [ return''0 (result:Int16.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool (return'  (x:Int16.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int16.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int16.t = Any.any_l () ]  [ return''0 (result:Int16.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int16.t; _p1: Int16.t }
  
  let rec promoted1__test_from_bool (return'  (x:Int16.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int16.t = Any.any_l () | & _1: Int16.t = Any.any_l () ]  [ return''0 (result:Int16.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool (return'  (x:Int16.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int16.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int16.t = Any.any_l () ]  [ return''0 (result:Int16.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:Int16.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:Int16.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:Int16.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:Int16.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:Int16.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int16.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int16.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int16.t = Any.any_l ()
    | & right_val: Int16.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int16.t = Any.any_l ()
    | & _21: Int16.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int16.t = Any.any_l ()
    | & right_val'0: Int16.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int16.t = Any.any_l ()
    | & _41: Int16.t = Any.any_l ()
    | & _44: Int16.t = Any.any_l ()
    | & _45: Int16.t = Any.any_l ()
    | & _46: Int16.t = Any.any_l ()
    | & _47: Int16.t = Any.any_l () ]
    
    [ return''0 (result:Int16.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = Int16.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int16BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ] 
    [ return''0 (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int16BW.t = Any.any_l () ]  [ return''0 (result:Int16BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int16BW.t; _p1: Int16BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int16BW.t = Any.any_l () | & _1: Int16BW.t = Any.any_l () ] 
    [ return''0 (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int16BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int16BW.t = Any.any_l () ]  [ return''0 (result:Int16BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:Int16BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:Int16BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:Int16BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:Int16BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:Int16BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int16BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int16BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int16BW.t = Any.any_l ()
    | & right_val: Int16BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int16BW.t = Any.any_l ()
    | & _21: Int16BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int16BW.t = Any.any_l ()
    | & right_val'0: Int16BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int16BW.t = Any.any_l ()
    | & _41: Int16BW.t = Any.any_l ()
    | & _44: Int16BW.t = Any.any_l ()
    | & _45: Int16BW.t = Any.any_l ()
    | & _46: Int16BW.t = Any.any_l ()
    | & _47: Int16BW.t = Any.any_l () ]
    
    [ return''0 (result:Int16BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = Int16BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:Int16.t) (return'  (x:Int16.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int16.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))} (fun (_ret:Int16.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int16.t = Any.any_l () | & n'0: Int16.t = n ] 
    [ return''0 (result:Int16.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = Int16.lsl_bv n (3: Int16.t)}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.Int16BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:Int16BW.t) (return'  (x:Int16BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int16BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:Int16BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int16BW.t = Any.any_l () | & n'0: Int16BW.t = n ] 
    [ return''0 (result:Int16BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = Int16BW.lsl_bv n (3: Int16BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt32.t = (0: UInt32.t)
  
  constant v_MAX: UInt32.t = (4294967295: UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:UInt32.t) (r:UInt32.t) (return'  (x:UInt32.t))= {[@expl:test_add requires] [%#sinteger_ops] UInt32.t'int l
    + UInt32.t'int r
    >= UInt32.t'int (v_MIN: UInt32.t)
    /\ UInt32.t'int l + UInt32.t'int r <= UInt32.t'int (v_MAX: UInt32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.add {l'0} {r'0} (fun (_ret:UInt32.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt32.t = Any.any_l () | & l'0: UInt32.t = l | & r'0: UInt32.t = r ] 
    [ return''0 (result:UInt32.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] UInt32.t'int result
      = UInt32.t'int l + UInt32.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt32BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt32BW.t = (0: UInt32BW.t)
  
  constant v_MAX: UInt32BW.t = (4294967295: UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:UInt32BW.t) (r:UInt32BW.t) (return'  (x:UInt32BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] UInt32BW.t'int l
    + UInt32BW.t'int r
    >= UInt32BW.t'int (v_MIN: UInt32BW.t)
    /\ UInt32BW.t'int l + UInt32BW.t'int r <= UInt32BW.t'int (v_MAX: UInt32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.add {l'0} {r'0} (fun (_ret:UInt32BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt32BW.t = Any.any_l () | & l'0: UInt32BW.t = l | & r'0: UInt32BW.t = r ] 
    [ return''0 (result:UInt32BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] UInt32BW.t'int result
      = UInt32BW.t'int l + UInt32BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt32.t = (0: UInt32.t)
  
  constant v_MAX: UInt32.t = (4294967295: UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:UInt32.t) (r:UInt32.t) (return'  (x:UInt32.t))= {[@expl:test_sub requires] [%#sinteger_ops] UInt32.t'int l
    - UInt32.t'int r
    >= UInt32.t'int (v_MIN: UInt32.t)
    /\ UInt32.t'int l - UInt32.t'int r <= UInt32.t'int (v_MAX: UInt32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.sub {l'0} {r'0} (fun (_ret:UInt32.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt32.t = Any.any_l () | & l'0: UInt32.t = l | & r'0: UInt32.t = r ] 
    [ return''0 (result:UInt32.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] UInt32.t'int result
      = UInt32.t'int l - UInt32.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt32BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt32BW.t = (0: UInt32BW.t)
  
  constant v_MAX: UInt32BW.t = (4294967295: UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:UInt32BW.t) (r:UInt32BW.t) (return'  (x:UInt32BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] UInt32BW.t'int l
    - UInt32BW.t'int r
    >= UInt32BW.t'int (v_MIN: UInt32BW.t)
    /\ UInt32BW.t'int l - UInt32BW.t'int r <= UInt32BW.t'int (v_MAX: UInt32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.sub {l'0} {r'0} (fun (_ret:UInt32BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt32BW.t = Any.any_l () | & l'0: UInt32BW.t = l | & r'0: UInt32BW.t = r ] 
    [ return''0 (result:UInt32BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] UInt32BW.t'int result
      = UInt32BW.t'int l - UInt32BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt32.t = (0: UInt32.t)
  
  constant v_MAX: UInt32.t = (4294967295: UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:UInt32.t) (r:UInt32.t) (return'  (x:UInt32.t))= {[@expl:test_mul requires] [%#sinteger_ops] UInt32.t'int l
    * UInt32.t'int r
    >= UInt32.t'int (v_MIN: UInt32.t)
    /\ UInt32.t'int l * UInt32.t'int r <= UInt32.t'int (v_MAX: UInt32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.mul {l'0} {r'0} (fun (_ret:UInt32.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt32.t = Any.any_l () | & l'0: UInt32.t = l | & r'0: UInt32.t = r ] 
    [ return''0 (result:UInt32.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] UInt32.t'int result
      = UInt32.t'int l * UInt32.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt32BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt32BW.t = (0: UInt32BW.t)
  
  constant v_MAX: UInt32BW.t = (4294967295: UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:UInt32BW.t) (r:UInt32BW.t) (return'  (x:UInt32BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] UInt32BW.t'int l
    * UInt32BW.t'int r
    >= UInt32BW.t'int (v_MIN: UInt32BW.t)
    /\ UInt32BW.t'int l * UInt32BW.t'int r <= UInt32BW.t'int (v_MAX: UInt32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.mul {l'0} {r'0} (fun (_ret:UInt32BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt32BW.t = Any.any_l () | & l'0: UInt32BW.t = l | & r'0: UInt32BW.t = r ] 
    [ return''0 (result:UInt32BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] UInt32BW.t'int result
      = UInt32BW.t'int l * UInt32BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt32.t = (0: UInt32.t)
  
  constant v_MAX: UInt32.t = (4294967295: UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:UInt32.t) (r:UInt32.t) (return'  (x:UInt32.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] UInt32.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (UInt32.t'int l) (UInt32.t'int r)
    >= UInt32.t'int (v_MIN: UInt32.t)
    /\ Int.div (UInt32.t'int l) (UInt32.t'int r) <= UInt32.t'int (v_MAX: UInt32.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt32.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt32.div {l'0} {_7} (fun (_ret:UInt32.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt32.t = Any.any_l ()
    | & l'0: UInt32.t = l
    | & r'0: UInt32.t = r
    | & _7: UInt32.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt32.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] UInt32.t'int result
      = Int.div (UInt32.t'int l) (UInt32.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt32BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt32BW.t = (0: UInt32BW.t)
  
  constant v_MAX: UInt32BW.t = (4294967295: UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:UInt32BW.t) (r:UInt32BW.t) (return'  (x:UInt32BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] UInt32BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (UInt32BW.t'int l) (UInt32BW.t'int r)
    >= UInt32BW.t'int (v_MIN: UInt32BW.t)
    /\ Int.div (UInt32BW.t'int l) (UInt32BW.t'int r) <= UInt32BW.t'int (v_MAX: UInt32BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt32BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt32BW.div {l'0} {_7} (fun (_ret:UInt32BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt32BW.t = Any.any_l ()
    | & l'0: UInt32BW.t = l
    | & r'0: UInt32BW.t = r
    | & _7: UInt32BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt32BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] UInt32BW.t'int result
      = Int.div (UInt32BW.t'int l) (UInt32BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:UInt32.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32.t = Any.any_l () | & _1: UInt32.t = Any.any_l () ] 
    [ return''0 (result:UInt32.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool (return'  (x:UInt32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32.t = Any.any_l () ]  [ return''0 (result:UInt32.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt32.t; _p1: UInt32.t }
  
  let rec promoted1__test_from_bool (return'  (x:UInt32.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32.t = Any.any_l () | & _1: UInt32.t = Any.any_l () ] 
    [ return''0 (result:UInt32.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool (return'  (x:UInt32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32.t = Any.any_l () ]  [ return''0 (result:UInt32.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:UInt32.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:UInt32.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:UInt32.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:UInt32.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:UInt32.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt32.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt32.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt32.t = Any.any_l ()
    | & right_val: UInt32.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt32.t = Any.any_l ()
    | & _21: UInt32.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt32.t = Any.any_l ()
    | & right_val'0: UInt32.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt32.t = Any.any_l ()
    | & _41: UInt32.t = Any.any_l ()
    | & _44: UInt32.t = Any.any_l ()
    | & _45: UInt32.t = Any.any_l ()
    | & _46: UInt32.t = Any.any_l ()
    | & _47: UInt32.t = Any.any_l () ]
    
    [ return''0 (result:UInt32.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = UInt32.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ] 
    [ return''0 (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32BW.t = Any.any_l () ]  [ return''0 (result:UInt32BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt32BW.t; _p1: UInt32BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt32BW.t = Any.any_l () | & _1: UInt32BW.t = Any.any_l () ] 
    [ return''0 (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt32BW.t = Any.any_l () ]  [ return''0 (result:UInt32BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:UInt32BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:UInt32BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:UInt32BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:UInt32BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:UInt32BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt32BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt32BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt32BW.t = Any.any_l ()
    | & right_val: UInt32BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt32BW.t = Any.any_l ()
    | & _21: UInt32BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt32BW.t = Any.any_l ()
    | & right_val'0: UInt32BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt32BW.t = Any.any_l ()
    | & _41: UInt32BW.t = Any.any_l ()
    | & _44: UInt32BW.t = Any.any_l ()
    | & _45: UInt32BW.t = Any.any_l ()
    | & _46: UInt32BW.t = Any.any_l ()
    | & _47: UInt32BW.t = Any.any_l () ]
    
    [ return''0 (result:UInt32BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = UInt32BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:UInt32.t) (return'  (x:UInt32.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt32.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))}
          (fun (_ret:UInt32.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt32.t = Any.any_l () | & n'0: UInt32.t = n ] 
    [ return''0 (result:UInt32.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = UInt32.lsl_bv n (3: UInt32.t)}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:UInt32BW.t) (return'  (x:UInt32BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt32BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:UInt32BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt32BW.t = Any.any_l () | & n'0: UInt32BW.t = n ] 
    [ return''0 (result:UInt32BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = UInt32BW.lsl_bv n (3: UInt32BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int32.t = (-2147483648: Int32.t)
  
  constant v_MAX: Int32.t = (2147483647: Int32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:Int32.t) (r:Int32.t) (return'  (x:Int32.t))= {[@expl:test_add requires] [%#sinteger_ops] Int32.to_int l
    + Int32.to_int r
    >= Int32.to_int (v_MIN: Int32.t)
    /\ Int32.to_int l + Int32.to_int r <= Int32.to_int (v_MAX: Int32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32.add {l'0} {r'0} (fun (_ret:Int32.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int32.t = Any.any_l () | & l'0: Int32.t = l | & r'0: Int32.t = r ] 
    [ return''0 (result:Int32.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] Int32.to_int result
      = Int32.to_int l + Int32.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int32BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int32BW.t = (2147483648: Int32BW.t)
  
  constant v_MAX: Int32BW.t = (2147483647: Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:Int32BW.t) (r:Int32BW.t) (return'  (x:Int32BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] Int32BW.to_int l
    + Int32BW.to_int r
    >= Int32BW.to_int (v_MIN: Int32BW.t)
    /\ Int32BW.to_int l + Int32BW.to_int r <= Int32BW.to_int (v_MAX: Int32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.add {l'0} {r'0} (fun (_ret:Int32BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int32BW.t = Any.any_l () | & l'0: Int32BW.t = l | & r'0: Int32BW.t = r ] 
    [ return''0 (result:Int32BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] Int32BW.to_int result
      = Int32BW.to_int l + Int32BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int32.t = (-2147483648: Int32.t)
  
  constant v_MAX: Int32.t = (2147483647: Int32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:Int32.t) (r:Int32.t) (return'  (x:Int32.t))= {[@expl:test_sub requires] [%#sinteger_ops] Int32.to_int l
    - Int32.to_int r
    >= Int32.to_int (v_MIN: Int32.t)
    /\ Int32.to_int l - Int32.to_int r <= Int32.to_int (v_MAX: Int32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32.sub {l'0} {r'0} (fun (_ret:Int32.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int32.t = Any.any_l () | & l'0: Int32.t = l | & r'0: Int32.t = r ] 
    [ return''0 (result:Int32.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] Int32.to_int result
      = Int32.to_int l - Int32.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int32BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int32BW.t = (2147483648: Int32BW.t)
  
  constant v_MAX: Int32BW.t = (2147483647: Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:Int32BW.t) (r:Int32BW.t) (return'  (x:Int32BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] Int32BW.to_int l
    - Int32BW.to_int r
    >= Int32BW.to_int (v_MIN: Int32BW.t)
    /\ Int32BW.to_int l - Int32BW.to_int r <= Int32BW.to_int (v_MAX: Int32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.sub {l'0} {r'0} (fun (_ret:Int32BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int32BW.t = Any.any_l () | & l'0: Int32BW.t = l | & r'0: Int32BW.t = r ] 
    [ return''0 (result:Int32BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] Int32BW.to_int result
      = Int32BW.to_int l - Int32BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int32.t = (-2147483648: Int32.t)
  
  constant v_MAX: Int32.t = (2147483647: Int32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:Int32.t) (r:Int32.t) (return'  (x:Int32.t))= {[@expl:test_mul requires] [%#sinteger_ops] Int32.to_int l
    * Int32.to_int r
    >= Int32.to_int (v_MIN: Int32.t)
    /\ Int32.to_int l * Int32.to_int r <= Int32.to_int (v_MAX: Int32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32.mul {l'0} {r'0} (fun (_ret:Int32.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int32.t = Any.any_l () | & l'0: Int32.t = l | & r'0: Int32.t = r ] 
    [ return''0 (result:Int32.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] Int32.to_int result
      = Int32.to_int l * Int32.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int32BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int32BW.t = (2147483648: Int32BW.t)
  
  constant v_MAX: Int32BW.t = (2147483647: Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:Int32BW.t) (r:Int32BW.t) (return'  (x:Int32BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] Int32BW.to_int l
    * Int32BW.to_int r
    >= Int32BW.to_int (v_MIN: Int32BW.t)
    /\ Int32BW.to_int l * Int32BW.to_int r <= Int32BW.to_int (v_MAX: Int32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.mul {l'0} {r'0} (fun (_ret:Int32BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int32BW.t = Any.any_l () | & l'0: Int32BW.t = l | & r'0: Int32BW.t = r ] 
    [ return''0 (result:Int32BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] Int32BW.to_int result
      = Int32BW.to_int l * Int32BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int32
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int32.t = (-2147483648: Int32.t)
  
  constant v_MAX: Int32.t = (2147483647: Int32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:Int32.t) (r:Int32.t) (return'  (x:Int32.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] Int32.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (Int32.to_int l) (Int32.to_int r)
    >= Int32.to_int (v_MIN: Int32.t)
    /\ Int.div (Int32.to_int l) (Int32.to_int r) <= Int32.to_int (v_MAX: Int32.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int32.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (-1: Int32.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (-2147483648: Int32.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int32.div {_6} {_7} (fun (_ret:Int32.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int32.t = Any.any_l ()
    | & l'0: Int32.t = l
    | & r'0: Int32.t = r
    | & _6: Int32.t = Any.any_l ()
    | & _7: Int32.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int32.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] Int32.to_int result
      = Int.div (Int32.to_int l) (Int32.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int32BW
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int32BW.t = (2147483648: Int32BW.t)
  
  constant v_MAX: Int32BW.t = (2147483647: Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:Int32BW.t) (r:Int32BW.t) (return'  (x:Int32BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] Int32BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (Int32BW.to_int l) (Int32BW.to_int r)
    >= Int32BW.to_int (v_MIN: Int32BW.t)
    /\ Int.div (Int32BW.to_int l) (Int32BW.to_int r) <= Int32BW.to_int (v_MAX: Int32BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int32BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (4294967295: Int32BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (2147483648: Int32BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int32BW.div {_6} {_7} (fun (_ret:Int32BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int32BW.t = Any.any_l ()
    | & l'0: Int32BW.t = l
    | & r'0: Int32BW.t = r
    | & _6: Int32BW.t = Any.any_l ()
    | & _7: Int32BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int32BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] Int32BW.to_int result
      = Int.div (Int32BW.to_int l) (Int32BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:Int32.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int32.t = Any.any_l () | & _1: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int32.t; _p1: Int32.t }
  
  let rec promoted1__test_from_bool (return'  (x:Int32.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int32.t = Any.any_l () | & _1: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:Int32.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:Int32.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:Int32.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:Int32.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:Int32.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int32.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int32.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int32.t = Any.any_l ()
    | & right_val: Int32.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int32.t = Any.any_l ()
    | & _21: Int32.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int32.t = Any.any_l ()
    | & right_val'0: Int32.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int32.t = Any.any_l ()
    | & _41: Int32.t = Any.any_l ()
    | & _44: Int32.t = Any.any_l ()
    | & _45: Int32.t = Any.any_l ()
    | & _46: Int32.t = Any.any_l ()
    | & _47: Int32.t = Any.any_l () ]
    
    [ return''0 (result:Int32.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = Int32.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int32BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ] 
    [ return''0 (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32BW.t = Any.any_l () ]  [ return''0 (result:Int32BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int32BW.t; _p1: Int32BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int32BW.t = Any.any_l () | & _1: Int32BW.t = Any.any_l () ] 
    [ return''0 (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int32BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32BW.t = Any.any_l () ]  [ return''0 (result:Int32BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:Int32BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:Int32BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:Int32BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:Int32BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:Int32BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int32BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int32BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int32BW.t = Any.any_l ()
    | & right_val: Int32BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int32BW.t = Any.any_l ()
    | & _21: Int32BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int32BW.t = Any.any_l ()
    | & right_val'0: Int32BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int32BW.t = Any.any_l ()
    | & _41: Int32BW.t = Any.any_l ()
    | & _44: Int32BW.t = Any.any_l ()
    | & _45: Int32BW.t = Any.any_l ()
    | & _46: Int32BW.t = Any.any_l ()
    | & _47: Int32BW.t = Any.any_l () ]
    
    [ return''0 (result:Int32BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = Int32BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:Int32.t) (return'  (x:Int32.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int32.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))} (fun (_ret:Int32.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int32.t = Any.any_l () | & n'0: Int32.t = n ] 
    [ return''0 (result:Int32.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = Int32.lsl_bv n (3: Int32.t)}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:Int32BW.t) (return'  (x:Int32BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int32BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:Int32BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int32BW.t = Any.any_l () | & n'0: Int32BW.t = n ] 
    [ return''0 (result:Int32BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = Int32BW.lsl_bv n (3: Int32BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64.t = (0: UInt64.t)
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:UInt64.t) (r:UInt64.t) (return'  (x:UInt64.t))= {[@expl:test_add requires] [%#sinteger_ops] UInt64.t'int l
    + UInt64.t'int r
    >= UInt64.t'int (v_MIN: UInt64.t)
    /\ UInt64.t'int l + UInt64.t'int r <= UInt64.t'int (v_MAX: UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.add {l'0} {r'0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & l'0: UInt64.t = l | & r'0: UInt64.t = r ] 
    [ return''0 (result:UInt64.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] UInt64.t'int result
      = UInt64.t'int l + UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant v_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (x:UInt64BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] UInt64BW.t'int l
    + UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN: UInt64BW.t)
    /\ UInt64BW.t'int l + UInt64BW.t'int r <= UInt64BW.t'int (v_MAX: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.add {l'0} {r'0} (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64BW.t = Any.any_l () | & l'0: UInt64BW.t = l | & r'0: UInt64BW.t = r ] 
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] UInt64BW.t'int result
      = UInt64BW.t'int l + UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64.t = (0: UInt64.t)
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:UInt64.t) (r:UInt64.t) (return'  (x:UInt64.t))= {[@expl:test_sub requires] [%#sinteger_ops] UInt64.t'int l
    - UInt64.t'int r
    >= UInt64.t'int (v_MIN: UInt64.t)
    /\ UInt64.t'int l - UInt64.t'int r <= UInt64.t'int (v_MAX: UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.sub {l'0} {r'0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & l'0: UInt64.t = l | & r'0: UInt64.t = r ] 
    [ return''0 (result:UInt64.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] UInt64.t'int result
      = UInt64.t'int l - UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant v_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (x:UInt64BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] UInt64BW.t'int l
    - UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN: UInt64BW.t)
    /\ UInt64BW.t'int l - UInt64BW.t'int r <= UInt64BW.t'int (v_MAX: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.sub {l'0} {r'0} (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64BW.t = Any.any_l () | & l'0: UInt64BW.t = l | & r'0: UInt64BW.t = r ] 
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] UInt64BW.t'int result
      = UInt64BW.t'int l - UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64.t = (0: UInt64.t)
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:UInt64.t) (r:UInt64.t) (return'  (x:UInt64.t))= {[@expl:test_mul requires] [%#sinteger_ops] UInt64.t'int l
    * UInt64.t'int r
    >= UInt64.t'int (v_MIN: UInt64.t)
    /\ UInt64.t'int l * UInt64.t'int r <= UInt64.t'int (v_MAX: UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.mul {l'0} {r'0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & l'0: UInt64.t = l | & r'0: UInt64.t = r ] 
    [ return''0 (result:UInt64.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] UInt64.t'int result
      = UInt64.t'int l * UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant v_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (x:UInt64BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] UInt64BW.t'int l
    * UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN: UInt64BW.t)
    /\ UInt64BW.t'int l * UInt64BW.t'int r <= UInt64BW.t'int (v_MAX: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.mul {l'0} {r'0} (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64BW.t = Any.any_l () | & l'0: UInt64BW.t = l | & r'0: UInt64BW.t = r ] 
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] UInt64BW.t'int result
      = UInt64BW.t'int l * UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64.t = (0: UInt64.t)
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:UInt64.t) (r:UInt64.t) (return'  (x:UInt64.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] UInt64.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (UInt64.t'int l) (UInt64.t'int r)
    >= UInt64.t'int (v_MIN: UInt64.t)
    /\ Int.div (UInt64.t'int l) (UInt64.t'int r) <= UInt64.t'int (v_MAX: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt64.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt64.div {l'0} {_7} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & l'0: UInt64.t = l
    | & r'0: UInt64.t = r
    | & _7: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] UInt64.t'int result
      = Int.div (UInt64.t'int l) (UInt64.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant v_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (x:UInt64BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] UInt64BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)
    >= UInt64BW.t'int (v_MIN: UInt64BW.t)
    /\ Int.div (UInt64BW.t'int l) (UInt64BW.t'int r) <= UInt64BW.t'int (v_MAX: UInt64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt64BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt64BW.div {l'0} {_7} (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt64BW.t = Any.any_l ()
    | & l'0: UInt64BW.t = l
    | & r'0: UInt64BW.t = r
    | & _7: UInt64BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] UInt64BW.t'int result
      = Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64.t = Any.any_l () | & _1: UInt64.t = Any.any_l () ] 
    [ return''0 (result:UInt64.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool (return'  (x:UInt64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt64.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64.t = Any.any_l () ]  [ return''0 (result:UInt64.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  let rec promoted1__test_from_bool (return'  (x:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64.t = Any.any_l () | & _1: UInt64.t = Any.any_l () ] 
    [ return''0 (result:UInt64.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool (return'  (x:UInt64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt64.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64.t = Any.any_l () ]  [ return''0 (result:UInt64.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:UInt64.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:UInt64.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:UInt64.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:UInt64.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt64.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt64.t = Any.any_l ()
    | & right_val: UInt64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt64.t = Any.any_l ()
    | & _21: UInt64.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt64.t = Any.any_l ()
    | & right_val'0: UInt64.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt64.t = Any.any_l ()
    | & _41: UInt64.t = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _45: UInt64.t = Any.any_l ()
    | & _46: UInt64.t = Any.any_l ()
    | & _47: UInt64.t = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = UInt64.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt64BW.t; _p1: UInt64BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:UInt64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:UInt64BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:UInt64BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:UInt64BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:UInt64BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt64BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt64BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt64BW.t = Any.any_l ()
    | & right_val: UInt64BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: UInt64BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt64BW.t = Any.any_l ()
    | & right_val'0: UInt64BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt64BW.t = Any.any_l ()
    | & _41: UInt64BW.t = Any.any_l ()
    | & _44: UInt64BW.t = Any.any_l ()
    | & _45: UInt64BW.t = Any.any_l ()
    | & _46: UInt64BW.t = Any.any_l ()
    | & _47: UInt64BW.t = Any.any_l () ]
    
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = UInt64BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:UInt64.t) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt64.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))}
          (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt64.t = Any.any_l () | & n'0: UInt64.t = n ] 
    [ return''0 (result:UInt64.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = UInt64.lsl_bv n (3: UInt64.t)}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:UInt64BW.t) (return'  (x:UInt64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt64BW.t = Any.any_l () | & n'0: UInt64BW.t = n ] 
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = UInt64BW.lsl_bv n (3: UInt64BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant v_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:Int64.t) (r:Int64.t) (return'  (x:Int64.t))= {[@expl:test_add requires] [%#sinteger_ops] Int64.to_int l
    + Int64.to_int r
    >= Int64.to_int (v_MIN: Int64.t)
    /\ Int64.to_int l + Int64.to_int r <= Int64.to_int (v_MAX: Int64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.add {l'0} {r'0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & l'0: Int64.t = l | & r'0: Int64.t = r ] 
    [ return''0 (result:Int64.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] Int64.to_int result
      = Int64.to_int l + Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant v_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (x:Int64BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] Int64BW.to_int l
    + Int64BW.to_int r
    >= Int64BW.to_int (v_MIN: Int64BW.t)
    /\ Int64BW.to_int l + Int64BW.to_int r <= Int64BW.to_int (v_MAX: Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.add {l'0} {r'0} (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64BW.t = Any.any_l () | & l'0: Int64BW.t = l | & r'0: Int64BW.t = r ] 
    [ return''0 (result:Int64BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] Int64BW.to_int result
      = Int64BW.to_int l + Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant v_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:Int64.t) (r:Int64.t) (return'  (x:Int64.t))= {[@expl:test_sub requires] [%#sinteger_ops] Int64.to_int l
    - Int64.to_int r
    >= Int64.to_int (v_MIN: Int64.t)
    /\ Int64.to_int l - Int64.to_int r <= Int64.to_int (v_MAX: Int64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.sub {l'0} {r'0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & l'0: Int64.t = l | & r'0: Int64.t = r ] 
    [ return''0 (result:Int64.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] Int64.to_int result
      = Int64.to_int l - Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant v_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (x:Int64BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] Int64BW.to_int l
    - Int64BW.to_int r
    >= Int64BW.to_int (v_MIN: Int64BW.t)
    /\ Int64BW.to_int l - Int64BW.to_int r <= Int64BW.to_int (v_MAX: Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.sub {l'0} {r'0} (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64BW.t = Any.any_l () | & l'0: Int64BW.t = l | & r'0: Int64BW.t = r ] 
    [ return''0 (result:Int64BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] Int64BW.to_int result
      = Int64BW.to_int l - Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant v_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:Int64.t) (r:Int64.t) (return'  (x:Int64.t))= {[@expl:test_mul requires] [%#sinteger_ops] Int64.to_int l
    * Int64.to_int r
    >= Int64.to_int (v_MIN: Int64.t)
    /\ Int64.to_int l * Int64.to_int r <= Int64.to_int (v_MAX: Int64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.mul {l'0} {r'0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & l'0: Int64.t = l | & r'0: Int64.t = r ] 
    [ return''0 (result:Int64.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] Int64.to_int result
      = Int64.to_int l * Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant v_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (x:Int64BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] Int64BW.to_int l
    * Int64BW.to_int r
    >= Int64BW.to_int (v_MIN: Int64BW.t)
    /\ Int64BW.to_int l * Int64BW.to_int r <= Int64BW.to_int (v_MAX: Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.mul {l'0} {r'0} (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64BW.t = Any.any_l () | & l'0: Int64BW.t = l | & r'0: Int64BW.t = r ] 
    [ return''0 (result:Int64BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] Int64BW.to_int result
      = Int64BW.to_int l * Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int64
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant v_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:Int64.t) (r:Int64.t) (return'  (x:Int64.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] Int64.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (Int64.to_int l) (Int64.to_int r)
    >= Int64.to_int (v_MIN: Int64.t)
    /\ Int.div (Int64.to_int l) (Int64.to_int r) <= Int64.to_int (v_MAX: Int64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int64.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (-1: Int64.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (-9223372036854775808: Int64.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int64.div {_6} {_7} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int64.t = Any.any_l ()
    | & l'0: Int64.t = l
    | & r'0: Int64.t = r
    | & _6: Int64.t = Any.any_l ()
    | & _7: Int64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int64.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] Int64.to_int result
      = Int.div (Int64.to_int l) (Int64.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int64BW
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant v_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (x:Int64BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] Int64BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (Int64BW.to_int l) (Int64BW.to_int r)
    >= Int64BW.to_int (v_MIN: Int64BW.t)
    /\ Int.div (Int64BW.to_int l) (Int64BW.to_int r) <= Int64BW.to_int (v_MAX: Int64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int64BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (18446744073709551615: Int64BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (9223372036854775808: Int64BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int64BW.div {_6} {_7} (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int64BW.t = Any.any_l ()
    | & l'0: Int64BW.t = l
    | & r'0: Int64BW.t = r
    | & _6: Int64BW.t = Any.any_l ()
    | & _7: Int64BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int64BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] Int64BW.to_int result
      = Int.div (Int64BW.to_int l) (Int64BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:Int64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64.t = Any.any_l () | & _1: Int64.t = Any.any_l () ]  [ return''0 (result:Int64.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool (return'  (x:Int64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int64.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64.t = Any.any_l () ]  [ return''0 (result:Int64.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int64.t; _p1: Int64.t }
  
  let rec promoted1__test_from_bool (return'  (x:Int64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64.t = Any.any_l () | & _1: Int64.t = Any.any_l () ]  [ return''0 (result:Int64.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool (return'  (x:Int64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int64.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64.t = Any.any_l () ]  [ return''0 (result:Int64.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:Int64.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:Int64.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:Int64.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:Int64.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int64.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int64.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int64.t = Any.any_l ()
    | & right_val: Int64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int64.t = Any.any_l ()
    | & _21: Int64.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int64.t = Any.any_l ()
    | & right_val'0: Int64.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int64.t = Any.any_l ()
    | & _41: Int64.t = Any.any_l ()
    | & _44: Int64.t = Any.any_l ()
    | & _45: Int64.t = Any.any_l ()
    | & _46: Int64.t = Any.any_l ()
    | & _47: Int64.t = Any.any_l () ]
    
    [ return''0 (result:Int64.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = Int64.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int64BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int64BW.t; _p1: Int64BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:Int64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:Int64BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:Int64BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:Int64BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:Int64BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int64BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int64BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int64BW.t = Any.any_l ()
    | & right_val: Int64BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int64BW.t = Any.any_l ()
    | & _21: Int64BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int64BW.t = Any.any_l ()
    | & right_val'0: Int64BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int64BW.t = Any.any_l ()
    | & _41: Int64BW.t = Any.any_l ()
    | & _44: Int64BW.t = Any.any_l ()
    | & _45: Int64BW.t = Any.any_l ()
    | & _46: Int64BW.t = Any.any_l ()
    | & _47: Int64BW.t = Any.any_l () ]
    
    [ return''0 (result:Int64BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = Int64BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:Int64.t) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int64.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int64.t = Any.any_l () | & n'0: Int64.t = n ] 
    [ return''0 (result:Int64.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = Int64.lsl_bv n (3: Int64.t)}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.Int64BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:Int64BW.t) (return'  (x:Int64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int64BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int64BW.t = Any.any_l () | & n'0: Int64BW.t = n ] 
    [ return''0 (result:Int64BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = Int64BW.lsl_bv n (3: Int64BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt128.t = (0: UInt128.t)
  
  constant v_MAX: UInt128.t = (340282366920938463463374607431768211455: UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:UInt128.t) (r:UInt128.t) (return'  (x:UInt128.t))= {[@expl:test_add requires] [%#sinteger_ops] UInt128.t'int l
    + UInt128.t'int r
    >= UInt128.t'int (v_MIN: UInt128.t)
    /\ UInt128.t'int l + UInt128.t'int r <= UInt128.t'int (v_MAX: UInt128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.add {l'0} {r'0} (fun (_ret:UInt128.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt128.t = Any.any_l () | & l'0: UInt128.t = l | & r'0: UInt128.t = r ] 
    [ return''0 (result:UInt128.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] UInt128.t'int result
      = UInt128.t'int l + UInt128.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt128BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt128BW.t = (0: UInt128BW.t)
  
  constant v_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:UInt128BW.t) (r:UInt128BW.t) (return'  (x:UInt128BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] UInt128BW.t'int l
    + UInt128BW.t'int r
    >= UInt128BW.t'int (v_MIN: UInt128BW.t)
    /\ UInt128BW.t'int l + UInt128BW.t'int r <= UInt128BW.t'int (v_MAX: UInt128BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt128BW.add {l'0} {r'0} (fun (_ret:UInt128BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt128BW.t = Any.any_l () | & l'0: UInt128BW.t = l | & r'0: UInt128BW.t = r ] 
    [ return''0 (result:UInt128BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] UInt128BW.t'int result
      = UInt128BW.t'int l + UInt128BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt128.t = (0: UInt128.t)
  
  constant v_MAX: UInt128.t = (340282366920938463463374607431768211455: UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:UInt128.t) (r:UInt128.t) (return'  (x:UInt128.t))= {[@expl:test_sub requires] [%#sinteger_ops] UInt128.t'int l
    - UInt128.t'int r
    >= UInt128.t'int (v_MIN: UInt128.t)
    /\ UInt128.t'int l - UInt128.t'int r <= UInt128.t'int (v_MAX: UInt128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.sub {l'0} {r'0} (fun (_ret:UInt128.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt128.t = Any.any_l () | & l'0: UInt128.t = l | & r'0: UInt128.t = r ] 
    [ return''0 (result:UInt128.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] UInt128.t'int result
      = UInt128.t'int l - UInt128.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt128BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt128BW.t = (0: UInt128BW.t)
  
  constant v_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:UInt128BW.t) (r:UInt128BW.t) (return'  (x:UInt128BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] UInt128BW.t'int l
    - UInt128BW.t'int r
    >= UInt128BW.t'int (v_MIN: UInt128BW.t)
    /\ UInt128BW.t'int l - UInt128BW.t'int r <= UInt128BW.t'int (v_MAX: UInt128BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt128BW.sub {l'0} {r'0} (fun (_ret:UInt128BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt128BW.t = Any.any_l () | & l'0: UInt128BW.t = l | & r'0: UInt128BW.t = r ] 
    [ return''0 (result:UInt128BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] UInt128BW.t'int result
      = UInt128BW.t'int l - UInt128BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt128.t = (0: UInt128.t)
  
  constant v_MAX: UInt128.t = (340282366920938463463374607431768211455: UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:UInt128.t) (r:UInt128.t) (return'  (x:UInt128.t))= {[@expl:test_mul requires] [%#sinteger_ops] UInt128.t'int l
    * UInt128.t'int r
    >= UInt128.t'int (v_MIN: UInt128.t)
    /\ UInt128.t'int l * UInt128.t'int r <= UInt128.t'int (v_MAX: UInt128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.mul {l'0} {r'0} (fun (_ret:UInt128.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt128.t = Any.any_l () | & l'0: UInt128.t = l | & r'0: UInt128.t = r ] 
    [ return''0 (result:UInt128.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] UInt128.t'int result
      = UInt128.t'int l * UInt128.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt128BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt128BW.t = (0: UInt128BW.t)
  
  constant v_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:UInt128BW.t) (r:UInt128BW.t) (return'  (x:UInt128BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] UInt128BW.t'int l
    * UInt128BW.t'int r
    >= UInt128BW.t'int (v_MIN: UInt128BW.t)
    /\ UInt128BW.t'int l * UInt128BW.t'int r <= UInt128BW.t'int (v_MAX: UInt128BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt128BW.mul {l'0} {r'0} (fun (_ret:UInt128BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt128BW.t = Any.any_l () | & l'0: UInt128BW.t = l | & r'0: UInt128BW.t = r ] 
    [ return''0 (result:UInt128BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] UInt128BW.t'int result
      = UInt128BW.t'int l * UInt128BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt128.t = (0: UInt128.t)
  
  constant v_MAX: UInt128.t = (340282366920938463463374607431768211455: UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:UInt128.t) (r:UInt128.t) (return'  (x:UInt128.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] UInt128.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (UInt128.t'int l) (UInt128.t'int r)
    >= UInt128.t'int (v_MIN: UInt128.t)
    /\ Int.div (UInt128.t'int l) (UInt128.t'int r) <= UInt128.t'int (v_MAX: UInt128.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt128.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt128.div {l'0} {_7} (fun (_ret:UInt128.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt128.t = Any.any_l ()
    | & l'0: UInt128.t = l
    | & r'0: UInt128.t = r
    | & _7: UInt128.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt128.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] UInt128.t'int result
      = Int.div (UInt128.t'int l) (UInt128.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt128BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt128BW.t = (0: UInt128BW.t)
  
  constant v_MAX: UInt128BW.t = (340282366920938463463374607431768211455: UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:UInt128BW.t) (r:UInt128BW.t) (return'  (x:UInt128BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] UInt128BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (UInt128BW.t'int l) (UInt128BW.t'int r)
    >= UInt128BW.t'int (v_MIN: UInt128BW.t)
    /\ Int.div (UInt128BW.t'int l) (UInt128BW.t'int r) <= UInt128BW.t'int (v_MAX: UInt128BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt128BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 = UInt128BW.div {l'0} {_7} (fun (_ret:UInt128BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]
     ]
    )
    [ & _0: UInt128BW.t = Any.any_l ()
    | & l'0: UInt128BW.t = l
    | & r'0: UInt128BW.t = r
    | & _7: UInt128BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt128BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] UInt128BW.t'int result
      = Int.div (UInt128BW.t'int l) (UInt128BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:UInt128.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128.t = Any.any_l () | & _1: UInt128.t = Any.any_l () ] 
    [ return''0 (result:UInt128.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool (return'  (x:UInt128.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt128.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt128.t = Any.any_l () ]  [ return''0 (result:UInt128.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt128.t; _p1: UInt128.t }
  
  let rec promoted1__test_from_bool (return'  (x:UInt128.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128.t = Any.any_l () | & _1: UInt128.t = Any.any_l () ] 
    [ return''0 (result:UInt128.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool (return'  (x:UInt128.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt128.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt128.t = Any.any_l () ]  [ return''0 (result:UInt128.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:UInt128.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:UInt128.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:UInt128.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:UInt128.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt128.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt128.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt128.t = Any.any_l ()
    | & right_val: UInt128.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt128.t = Any.any_l ()
    | & _21: UInt128.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt128.t = Any.any_l ()
    | & right_val'0: UInt128.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt128.t = Any.any_l ()
    | & _41: UInt128.t = Any.any_l ()
    | & _44: UInt128.t = Any.any_l ()
    | & _45: UInt128.t = Any.any_l ()
    | & _46: UInt128.t = Any.any_l ()
    | & _47: UInt128.t = Any.any_l () ]
    
    [ return''0 (result:UInt128.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = UInt128.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ] 
    [ return''0 (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt128BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt128BW.t = Any.any_l () ]  [ return''0 (result:UInt128BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt128BW.t; _p1: UInt128BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128BW.of_bool ([%#sinteger_ops'2] false) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt128BW.t = Any.any_l () | & _1: UInt128BW.t = Any.any_l () ] 
    [ return''0 (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt128BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt128BW.t = Any.any_l () ]  [ return''0 (result:UInt128BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:UInt128BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:UInt128BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:UInt128BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:UInt128BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:UInt128BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt128BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt128BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt128BW.t = Any.any_l ()
    | & right_val: UInt128BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt128BW.t = Any.any_l ()
    | & _21: UInt128BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt128BW.t = Any.any_l ()
    | & right_val'0: UInt128BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt128BW.t = Any.any_l ()
    | & _41: UInt128BW.t = Any.any_l ()
    | & _44: UInt128BW.t = Any.any_l ()
    | & _45: UInt128BW.t = Any.any_l ()
    | & _46: UInt128BW.t = Any.any_l ()
    | & _47: UInt128BW.t = Any.any_l () ]
    
    [ return''0 (result:UInt128BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = UInt128BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:UInt128.t) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt128.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))}
          (fun (_ret:UInt128.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt128.t = Any.any_l () | & n'0: UInt128.t = n ] 
    [ return''0 (result:UInt128.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result
      = UInt128.lsl_bv n (3: UInt128.t)}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.UInt128BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:UInt128BW.t) (return'  (x:UInt128BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt128BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:UInt128BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt128BW.t = Any.any_l () | & n'0: UInt128BW.t = n ] 
    [ return''0 (result:UInt128BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = UInt128BW.lsl_bv n (3: UInt128BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  constant v_MAX: Int128.t = (170141183460469231731687303715884105727: Int128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:Int128.t) (r:Int128.t) (return'  (x:Int128.t))= {[@expl:test_add requires] [%#sinteger_ops] Int128.to_int l
    + Int128.to_int r
    >= Int128.to_int (v_MIN: Int128.t)
    /\ Int128.to_int l + Int128.to_int r <= Int128.to_int (v_MAX: Int128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.add {l'0} {r'0} (fun (_ret:Int128.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int128.t = Any.any_l () | & l'0: Int128.t = l | & r'0: Int128.t = r ] 
    [ return''0 (result:Int128.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] Int128.to_int result
      = Int128.to_int l + Int128.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int128BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int128BW.t = (170141183460469231731687303715884105728: Int128BW.t)
  
  constant v_MAX: Int128BW.t = (170141183460469231731687303715884105727: Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:Int128BW.t) (r:Int128BW.t) (return'  (x:Int128BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] Int128BW.to_int l
    + Int128BW.to_int r
    >= Int128BW.to_int (v_MIN: Int128BW.t)
    /\ Int128BW.to_int l + Int128BW.to_int r <= Int128BW.to_int (v_MAX: Int128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.add {l'0} {r'0} (fun (_ret:Int128BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int128BW.t = Any.any_l () | & l'0: Int128BW.t = l | & r'0: Int128BW.t = r ] 
    [ return''0 (result:Int128BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] Int128BW.to_int result
      = Int128BW.to_int l + Int128BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  constant v_MAX: Int128.t = (170141183460469231731687303715884105727: Int128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:Int128.t) (r:Int128.t) (return'  (x:Int128.t))= {[@expl:test_sub requires] [%#sinteger_ops] Int128.to_int l
    - Int128.to_int r
    >= Int128.to_int (v_MIN: Int128.t)
    /\ Int128.to_int l - Int128.to_int r <= Int128.to_int (v_MAX: Int128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.sub {l'0} {r'0} (fun (_ret:Int128.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int128.t = Any.any_l () | & l'0: Int128.t = l | & r'0: Int128.t = r ] 
    [ return''0 (result:Int128.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] Int128.to_int result
      = Int128.to_int l - Int128.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int128BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int128BW.t = (170141183460469231731687303715884105728: Int128BW.t)
  
  constant v_MAX: Int128BW.t = (170141183460469231731687303715884105727: Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:Int128BW.t) (r:Int128BW.t) (return'  (x:Int128BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] Int128BW.to_int l
    - Int128BW.to_int r
    >= Int128BW.to_int (v_MIN: Int128BW.t)
    /\ Int128BW.to_int l - Int128BW.to_int r <= Int128BW.to_int (v_MAX: Int128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.sub {l'0} {r'0} (fun (_ret:Int128BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int128BW.t = Any.any_l () | & l'0: Int128BW.t = l | & r'0: Int128BW.t = r ] 
    [ return''0 (result:Int128BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] Int128BW.to_int result
      = Int128BW.to_int l - Int128BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  constant v_MAX: Int128.t = (170141183460469231731687303715884105727: Int128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:Int128.t) (r:Int128.t) (return'  (x:Int128.t))= {[@expl:test_mul requires] [%#sinteger_ops] Int128.to_int l
    * Int128.to_int r
    >= Int128.to_int (v_MIN: Int128.t)
    /\ Int128.to_int l * Int128.to_int r <= Int128.to_int (v_MAX: Int128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.mul {l'0} {r'0} (fun (_ret:Int128.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int128.t = Any.any_l () | & l'0: Int128.t = l | & r'0: Int128.t = r ] 
    [ return''0 (result:Int128.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] Int128.to_int result
      = Int128.to_int l * Int128.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int128BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int128BW.t = (170141183460469231731687303715884105728: Int128BW.t)
  
  constant v_MAX: Int128BW.t = (170141183460469231731687303715884105727: Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:Int128BW.t) (r:Int128BW.t) (return'  (x:Int128BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] Int128BW.to_int l
    * Int128BW.to_int r
    >= Int128BW.to_int (v_MIN: Int128BW.t)
    /\ Int128BW.to_int l * Int128BW.to_int r <= Int128BW.to_int (v_MAX: Int128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.mul {l'0} {r'0} (fun (_ret:Int128BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int128BW.t = Any.any_l () | & l'0: Int128BW.t = l | & r'0: Int128BW.t = r ] 
    [ return''0 (result:Int128BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] Int128BW.to_int result
      = Int128BW.to_int l * Int128BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int128
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  constant v_MAX: Int128.t = (170141183460469231731687303715884105727: Int128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:Int128.t) (r:Int128.t) (return'  (x:Int128.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] Int128.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (Int128.to_int l) (Int128.to_int r)
    >= Int128.to_int (v_MIN: Int128.t)
    /\ Int.div (Int128.to_int l) (Int128.to_int r) <= Int128.to_int (v_MAX: Int128.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int128.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (-1: Int128.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (-170141183460469231731687303715884105728: Int128.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int128.div {_6} {_7} (fun (_ret:Int128.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int128.t = Any.any_l ()
    | & l'0: Int128.t = l
    | & r'0: Int128.t = r
    | & _6: Int128.t = Any.any_l ()
    | & _7: Int128.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int128.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] Int128.to_int result
      = Int.div (Int128.to_int l) (Int128.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int128BW
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int128BW.t = (170141183460469231731687303715884105728: Int128BW.t)
  
  constant v_MAX: Int128BW.t = (170141183460469231731687303715884105727: Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:Int128BW.t) (r:Int128BW.t) (return'  (x:Int128BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] Int128BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (Int128BW.to_int l) (Int128BW.to_int r)
    >= Int128BW.to_int (v_MIN: Int128BW.t)
    /\ Int.div (Int128BW.to_int l) (Int128BW.to_int r) <= Int128BW.to_int (v_MAX: Int128BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int128BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (340282366920938463463374607431768211455: Int128BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (170141183460469231731687303715884105728: Int128BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int128BW.div {_6} {_7} (fun (_ret:Int128BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int128BW.t = Any.any_l ()
    | & l'0: Int128BW.t = l
    | & r'0: Int128BW.t = r
    | & _6: Int128BW.t = Any.any_l ()
    | & _7: Int128BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int128BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] Int128BW.to_int result
      = Int.div (Int128BW.to_int l) (Int128BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:Int128.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int128.t = Any.any_l () | & _1: Int128.t = Any.any_l () ] 
    [ return''0 (result:Int128.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool (return'  (x:Int128.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int128.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int128.t = Any.any_l () ]  [ return''0 (result:Int128.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int128.t; _p1: Int128.t }
  
  let rec promoted1__test_from_bool (return'  (x:Int128.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int128.t = Any.any_l () | & _1: Int128.t = Any.any_l () ] 
    [ return''0 (result:Int128.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool (return'  (x:Int128.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int128.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int128.t = Any.any_l () ]  [ return''0 (result:Int128.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:Int128.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:Int128.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:Int128.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:Int128.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int128.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int128.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int128.t = Any.any_l ()
    | & right_val: Int128.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int128.t = Any.any_l ()
    | & _21: Int128.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int128.t = Any.any_l ()
    | & right_val'0: Int128.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int128.t = Any.any_l ()
    | & _41: Int128.t = Any.any_l ()
    | & _44: Int128.t = Any.any_l ()
    | & _45: Int128.t = Any.any_l ()
    | & _46: Int128.t = Any.any_l ()
    | & _47: Int128.t = Any.any_l () ]
    
    [ return''0 (result:Int128.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = Int128.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int128BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ] 
    [ return''0 (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int128BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int128BW.t = Any.any_l () ]  [ return''0 (result:Int128BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int128BW.t; _p1: Int128BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int128BW.t = Any.any_l () | & _1: Int128BW.t = Any.any_l () ] 
    [ return''0 (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int128BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int128BW.t = Any.any_l () ]  [ return''0 (result:Int128BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:Int128BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:Int128BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:Int128BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:Int128BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:Int128BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int128BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int128BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int128BW.t = Any.any_l ()
    | & right_val: Int128BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int128BW.t = Any.any_l ()
    | & _21: Int128BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int128BW.t = Any.any_l ()
    | & right_val'0: Int128BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int128BW.t = Any.any_l ()
    | & _41: Int128BW.t = Any.any_l ()
    | & _44: Int128BW.t = Any.any_l ()
    | & _45: Int128BW.t = Any.any_l ()
    | & _46: Int128BW.t = Any.any_l ()
    | & _47: Int128BW.t = Any.any_l () ]
    
    [ return''0 (result:Int128BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = Int128BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:Int128.t) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int128.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))}
          (fun (_ret:Int128.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int128.t = Any.any_l () | & n'0: Int128.t = n ] 
    [ return''0 (result:Int128.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = Int128.lsl_bv n (3: Int128.t)}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.Int128BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:Int128BW.t) (return'  (x:Int128BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int128BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:Int128BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int128BW.t = Any.any_l () | & n'0: Int128BW.t = n ] 
    [ return''0 (result:Int128BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = Int128BW.lsl_bv n (3: Int128BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64.t = (0: UInt64.t)
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:UInt64.t) (r:UInt64.t) (return'  (x:UInt64.t))= {[@expl:test_add requires] [%#sinteger_ops] UInt64.t'int l
    + UInt64.t'int r
    >= UInt64.t'int (v_MIN: UInt64.t)
    /\ UInt64.t'int l + UInt64.t'int r <= UInt64.t'int (v_MAX: UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.add {l'0} {r'0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & l'0: UInt64.t = l | & r'0: UInt64.t = r ] 
    [ return''0 (result:UInt64.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] UInt64.t'int result
      = UInt64.t'int l + UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant v_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (x:UInt64BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] UInt64BW.t'int l
    + UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN: UInt64BW.t)
    /\ UInt64BW.t'int l + UInt64BW.t'int r <= UInt64BW.t'int (v_MAX: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.add {l'0} {r'0} (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64BW.t = Any.any_l () | & l'0: UInt64BW.t = l | & r'0: UInt64BW.t = r ] 
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] UInt64BW.t'int result
      = UInt64BW.t'int l + UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64.t = (0: UInt64.t)
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:UInt64.t) (r:UInt64.t) (return'  (x:UInt64.t))= {[@expl:test_sub requires] [%#sinteger_ops] UInt64.t'int l
    - UInt64.t'int r
    >= UInt64.t'int (v_MIN: UInt64.t)
    /\ UInt64.t'int l - UInt64.t'int r <= UInt64.t'int (v_MAX: UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.sub {l'0} {r'0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & l'0: UInt64.t = l | & r'0: UInt64.t = r ] 
    [ return''0 (result:UInt64.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] UInt64.t'int result
      = UInt64.t'int l - UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant v_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (x:UInt64BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] UInt64BW.t'int l
    - UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN: UInt64BW.t)
    /\ UInt64BW.t'int l - UInt64BW.t'int r <= UInt64BW.t'int (v_MAX: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.sub {l'0} {r'0} (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64BW.t = Any.any_l () | & l'0: UInt64BW.t = l | & r'0: UInt64BW.t = r ] 
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] UInt64BW.t'int result
      = UInt64BW.t'int l - UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64.t = (0: UInt64.t)
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:UInt64.t) (r:UInt64.t) (return'  (x:UInt64.t))= {[@expl:test_mul requires] [%#sinteger_ops] UInt64.t'int l
    * UInt64.t'int r
    >= UInt64.t'int (v_MIN: UInt64.t)
    /\ UInt64.t'int l * UInt64.t'int r <= UInt64.t'int (v_MAX: UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.mul {l'0} {r'0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & l'0: UInt64.t = l | & r'0: UInt64.t = r ] 
    [ return''0 (result:UInt64.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] UInt64.t'int result
      = UInt64.t'int l * UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant v_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (x:UInt64BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] UInt64BW.t'int l
    * UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN: UInt64BW.t)
    /\ UInt64BW.t'int l * UInt64BW.t'int r <= UInt64BW.t'int (v_MAX: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.mul {l'0} {r'0} (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64BW.t = Any.any_l () | & l'0: UInt64BW.t = l | & r'0: UInt64BW.t = r ] 
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] UInt64BW.t'int result
      = UInt64BW.t'int l * UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64.t = (0: UInt64.t)
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:UInt64.t) (r:UInt64.t) (return'  (x:UInt64.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] UInt64.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (UInt64.t'int l) (UInt64.t'int r)
    >= UInt64.t'int (v_MIN: UInt64.t)
    /\ Int.div (UInt64.t'int l) (UInt64.t'int r) <= UInt64.t'int (v_MAX: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt64.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt64.div {l'0} {_7} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & l'0: UInt64.t = l
    | & r'0: UInt64.t = r
    | & _7: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] UInt64.t'int result
      = Int.div (UInt64.t'int l) (UInt64.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: UInt64BW.t = (0: UInt64BW.t)
  
  constant v_MAX: UInt64BW.t = (18446744073709551615: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (x:UInt64BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] UInt64BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)
    >= UInt64BW.t'int (v_MIN: UInt64BW.t)
    /\ Int.div (UInt64BW.t'int l) (UInt64BW.t'int r) <= UInt64BW.t'int (v_MAX: UInt64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r'0 ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: UInt64BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt64BW.div {l'0} {_7} (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt64BW.t = Any.any_l ()
    | & l'0: UInt64BW.t = l
    | & r'0: UInt64BW.t = r
    | & _7: UInt64BW.t = Any.any_l ()
    | & _8: bool = Any.any_l () ]
    
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] UInt64BW.t'int result
      = Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64.t = Any.any_l () | & _1: UInt64.t = Any.any_l () ] 
    [ return''0 (result:UInt64.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool (return'  (x:UInt64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt64.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64.t = Any.any_l () ]  [ return''0 (result:UInt64.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  let rec promoted1__test_from_bool (return'  (x:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64.t = Any.any_l () | & _1: UInt64.t = Any.any_l () ] 
    [ return''0 (result:UInt64.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool (return'  (x:UInt64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt64.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64.t = Any.any_l () ]  [ return''0 (result:UInt64.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:UInt64.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:UInt64.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:UInt64.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:UInt64.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt64.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt64.t = Any.any_l ()
    | & right_val: UInt64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt64.t = Any.any_l ()
    | & _21: UInt64.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt64.t = Any.any_l ()
    | & right_val'0: UInt64.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt64.t = Any.any_l ()
    | & _41: UInt64.t = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _45: UInt64.t = Any.any_l ()
    | & _46: UInt64.t = Any.any_l ()
    | & _47: UInt64.t = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = UInt64.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: UInt64BW.t; _p1: UInt64BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: UInt64BW.t = Any.any_l () | & _1: UInt64BW.t = Any.any_l () ] 
    [ return''0 (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: UInt64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64BW.t = Any.any_l () ]  [ return''0 (result:UInt64BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:UInt64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:UInt64BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:UInt64BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:UInt64BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:UInt64BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt64BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: UInt64BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: UInt64BW.t = Any.any_l ()
    | & right_val: UInt64BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: UInt64BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: UInt64BW.t = Any.any_l ()
    | & right_val'0: UInt64BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: UInt64BW.t = Any.any_l ()
    | & _41: UInt64BW.t = Any.any_l ()
    | & _44: UInt64BW.t = Any.any_l ()
    | & _45: UInt64BW.t = Any.any_l ()
    | & _46: UInt64BW.t = Any.any_l ()
    | & _47: UInt64BW.t = Any.any_l () ]
    
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = UInt64BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:UInt64.t) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt64.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))}
          (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt64.t = Any.any_l () | & n'0: UInt64.t = n ] 
    [ return''0 (result:UInt64.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = UInt64.lsl_bv n (3: UInt64.t)}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:UInt64BW.t) (return'  (x:UInt64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:UInt64BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt64BW.t = Any.any_l () | & n'0: UInt64BW.t = n ] 
    [ return''0 (result:UInt64BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = UInt64BW.lsl_bv n (3: UInt64BW.t)}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops'0 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant v_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add[#"integer_ops.rs" 84 30 87 11] (l:Int64.t) (r:Int64.t) (return'  (x:Int64.t))= {[@expl:test_add requires] [%#sinteger_ops] Int64.to_int l
    + Int64.to_int r
    >= Int64.to_int (v_MIN: Int64.t)
    /\ Int64.to_int l + Int64.to_int r <= Int64.to_int (v_MAX: Int64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.add {l'0} {r'0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & l'0: Int64.t = l | & r'0: Int64.t = r ] 
    [ return''0 (result:Int64.t)-> {[@expl:test_add ensures] [%#sinteger_ops'0] Int64.to_int result
      = Int64.to_int l + Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops'0 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant v_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw[#"integer_ops.rs" 84 30 95 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (x:Int64BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops] Int64BW.to_int l
    + Int64BW.to_int r
    >= Int64BW.to_int (v_MIN: Int64BW.t)
    /\ Int64BW.to_int l + Int64BW.to_int r <= Int64BW.to_int (v_MAX: Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.add {l'0} {r'0} (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64BW.t = Any.any_l () | & l'0: Int64BW.t = l | & r'0: Int64BW.t = r ] 
    [ return''0 (result:Int64BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops'0] Int64BW.to_int result
      = Int64BW.to_int l + Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops'0 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant v_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub[#"integer_ops.rs" 84 30 102 11] (l:Int64.t) (r:Int64.t) (return'  (x:Int64.t))= {[@expl:test_sub requires] [%#sinteger_ops] Int64.to_int l
    - Int64.to_int r
    >= Int64.to_int (v_MIN: Int64.t)
    /\ Int64.to_int l - Int64.to_int r <= Int64.to_int (v_MAX: Int64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.sub {l'0} {r'0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & l'0: Int64.t = l | & r'0: Int64.t = r ] 
    [ return''0 (result:Int64.t)-> {[@expl:test_sub ensures] [%#sinteger_ops'0] Int64.to_int result
      = Int64.to_int l - Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops'0 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant v_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw[#"integer_ops.rs" 84 30 110 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (x:Int64BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops] Int64BW.to_int l
    - Int64BW.to_int r
    >= Int64BW.to_int (v_MIN: Int64BW.t)
    /\ Int64BW.to_int l - Int64BW.to_int r <= Int64BW.to_int (v_MAX: Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.sub {l'0} {r'0} (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64BW.t = Any.any_l () | & l'0: Int64BW.t = l | & r'0: Int64BW.t = r ] 
    [ return''0 (result:Int64BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops'0] Int64BW.to_int result
      = Int64BW.to_int l - Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops'0 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant v_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul[#"integer_ops.rs" 84 30 117 11] (l:Int64.t) (r:Int64.t) (return'  (x:Int64.t))= {[@expl:test_mul requires] [%#sinteger_ops] Int64.to_int l
    * Int64.to_int r
    >= Int64.to_int (v_MIN: Int64.t)
    /\ Int64.to_int l * Int64.to_int r <= Int64.to_int (v_MAX: Int64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64.mul {l'0} {r'0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & l'0: Int64.t = l | & r'0: Int64.t = r ] 
    [ return''0 (result:Int64.t)-> {[@expl:test_mul ensures] [%#sinteger_ops'0] Int64.to_int result
      = Int64.to_int l * Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops'0 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int64BW
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant v_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw[#"integer_ops.rs" 84 30 125 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (x:Int64BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops] Int64BW.to_int l
    * Int64BW.to_int r
    >= Int64BW.to_int (v_MIN: Int64BW.t)
    /\ Int64BW.to_int l * Int64BW.to_int r <= Int64BW.to_int (v_MAX: Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.mul {l'0} {r'0} (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64BW.t = Any.any_l () | & l'0: Int64BW.t = l | & r'0: Int64BW.t = r ] 
    [ return''0 (result:Int64BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops'0] Int64BW.to_int result
      = Int64BW.to_int l * Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops'0 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops'1 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops'2 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int64
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  constant v_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div[#"integer_ops.rs" 84 30 133 11] (l:Int64.t) (r:Int64.t) (return'  (x:Int64.t))= {[@expl:test_div requires #0] [%#sinteger_ops'0] Int64.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops'1] Int.div (Int64.to_int l) (Int64.to_int r)
    >= Int64.to_int (v_MIN: Int64.t)
    /\ Int.div (Int64.to_int l) (Int64.to_int r) <= Int64.to_int (v_MAX: Int64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int64.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (-1: Int64.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (-9223372036854775808: Int64.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int64.div {_6} {_7} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int64.t = Any.any_l ()
    | & l'0: Int64.t = l
    | & r'0: Int64.t = r
    | & _6: Int64.t = Any.any_l ()
    | & _7: Int64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int64.t)-> {[@expl:test_div ensures] [%#sinteger_ops'2] Int64.to_int result
      = Int.div (Int64.to_int l) (Int64.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops'0 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops'1 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops'2 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int64BW
  use creusot.prelude.Bool
  use mach.int.Int
  use creusot.prelude.Any
  
  constant v_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  constant v_MAX: Int64BW.t = (9223372036854775807: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw[#"integer_ops.rs" 84 30 142 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (x:Int64BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops'0] Int64BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops'1] Int.div (Int64BW.to_int l) (Int64BW.to_int r)
    >= Int64BW.to_int (v_MIN: Int64BW.t)
    /\ Int.div (Int64BW.to_int l) (Int64BW.to_int r) <= Int64BW.to_int (v_MAX: Int64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l'0 ] s1
      | s1 =  [ &_7 <- r'0 ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops] (0: Int64BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops] (18446744073709551615: Int64BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops] (9223372036854775808: Int64BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int64BW.div {_6} {_7} (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Int64BW.t = Any.any_l ()
    | & l'0: Int64BW.t = l
    | & r'0: Int64BW.t = r
    | & _6: Int64BW.t = Any.any_l ()
    | & _7: Int64BW.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l () ]
    
    [ return''0 (result:Int64BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops'2] Int64BW.to_int result
      = Int.div (Int64BW.to_int l) (Int64BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops'0 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops'1 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops'2 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops'3 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool (return'  (x:Int64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64.t = Any.any_l () | & _1: Int64.t = Any.any_l () ]  [ return''0 (result:Int64.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool (return'  (x:Int64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int64.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64.t = Any.any_l () ]  [ return''0 (result:Int64.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int64.t; _p1: Int64.t }
  
  let rec promoted1__test_from_bool (return'  (x:Int64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64.t = Any.any_l () | & _1: Int64.t = Any.any_l () ]  [ return''0 (result:Int64.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool (return'  (x:Int64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int64.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64.t = Any.any_l () ]  [ return''0 (result:Int64.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool (fun (pr3:Int64.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool (fun (pr2:Int64.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool (fun (pr1:Int64.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool (fun (pr0:Int64.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int64.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int64.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int64.t = Any.any_l ()
    | & right_val: Int64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int64.t = Any.any_l ()
    | & _21: Int64.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int64.t = Any.any_l ()
    | & right_val'0: Int64.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int64.t = Any.any_l ()
    | & _41: Int64.t = Any.any_l ()
    | & _44: Int64.t = Any.any_l ()
    | & _45: Int64.t = Any.any_l ()
    | & _46: Int64.t = Any.any_l ()
    | & _47: Int64.t = Any.any_l () ]
    
    [ return''0 (result:Int64.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops] result = Int64.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops'0 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops'1 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops'2 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops'3 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int64BW
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.of_bool ([%#sinteger_ops'0] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'1] (1: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: Int64BW.t; _p1: Int64BW.t }
  
  let rec promoted1__test_from_bool_bw (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.of_bool ([%#sinteger_ops'2] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0: Int64BW.t = Any.any_l () | & _1: Int64BW.t = Any.any_l () ] 
    [ return''0 (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw (return'  (x:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops'3] (0: Int64BW.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int64BW.t = Any.any_l () ]  [ return''0 (result:Int64BW.t)-> return' {result} ] 
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (x:Int64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw (fun (pr3:Int64BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw (fun (pr2:Int64BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- { _p0 = _47; _p1 = _46 } ] s3
      | s3 =  [ &left_val <- _4._p0 ] s4
      | s4 =  [ &right_val <- _4._p1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw (fun (pr1:Int64BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw (fun (pr0:Int64BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- { _p0 = _45; _p1 = _44 } ] s3
      | s3 =  [ &left_val'0 <- _24._p0 ] s4
      | s4 =  [ &right_val'0 <- _24._p1 ] s5
      | s5 =  [ &_31 <- left_val'0 = right_val'0 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int64BW.of_bool b'0 ] s1 | s1 = return''0 {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_39 <- left_val'0 ] s2
      | s2 =  [ &_41 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_19 <- left_val ] s2 | s2 =  [ &_21 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0: Int64BW.t = Any.any_l ()
    | & b'0: bool = b
    | & _4: tuple = Any.any_l ()
    | & left_val: Int64BW.t = Any.any_l ()
    | & right_val: Int64BW.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & kind: t_AssertKind = Any.any_l ()
    | & _19: Int64BW.t = Any.any_l ()
    | & _21: Int64BW.t = Any.any_l ()
    | & _24: tuple = Any.any_l ()
    | & left_val'0: Int64BW.t = Any.any_l ()
    | & right_val'0: Int64BW.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & kind'0: t_AssertKind = Any.any_l ()
    | & _39: Int64BW.t = Any.any_l ()
    | & _41: Int64BW.t = Any.any_l ()
    | & _44: Int64BW.t = Any.any_l ()
    | & _45: Int64BW.t = Any.any_l ()
    | & _46: Int64BW.t = Any.any_l ()
    | & _47: Int64BW.t = Any.any_l () ]
    
    [ return''0 (result:Int64BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops] result = Int64BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_shl [#"integer_ops.rs" 84 30 165 11]
  let%span sinteger_ops = "integer_ops.rs" 166 17 166 18
  let%span sinteger_ops'0 = "integer_ops.rs" 163 18 163 39
  
  use creusot.int.Int32
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl[#"integer_ops.rs" 84 30 165 11] (n:Int64.t) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int64.shl {n'0} {Int32.to_int ([%#sinteger_ops] (3: Int32.t))} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int64.t = Any.any_l () | & n'0: Int64.t = n ] 
    [ return''0 (result:Int64.t)-> {[@expl:test_shl ensures] [%#sinteger_ops'0] result = Int64.lsl_bv n (3: Int64.t)}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_shl_bw [#"integer_ops.rs" 84 30 172 11]
  let%span sinteger_ops = "integer_ops.rs" 173 17 173 18
  let%span sinteger_ops'0 = "integer_ops.rs" 169 18 169 39
  
  use creusot.int.Int32BW
  use creusot.int.Int64BW
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec test_shl_bw[#"integer_ops.rs" 84 30 172 11] (n:Int64BW.t) (return'  (x:Int64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int64BW.shl {n'0} {Int32BW.to_int ([%#sinteger_ops] (3: Int32BW.t))}
          (fun (_ret:Int64BW.t) ->  [ &_0 <- _ret ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int64BW.t = Any.any_l () | & n'0: Int64BW.t = n ] 
    [ return''0 (result:Int64BW.t)-> {[@expl:test_shl_bw ensures] [%#sinteger_ops'0] result
      = Int64BW.lsl_bv n (3: Int64BW.t)}
      (! return' {result}) ]

end
