module M_default__qyi3915135727482750158__default (* <Unit as creusot_contracts::Default> *)
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- () ] s1 | s1 = return {_0} ] ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:default ensures] true} (! return {result}) ]
end
module M_default__qyi13740418467561183253__default (* <Tuple as creusot_contracts::Default> *)
  use creusot.int.Int32
  use creusot.int.Int64
  use creusot.prelude.Any
  
  let rec default (return (x: Int32.t)) = any
    [ return' (result: Int32.t) -> {result = (0: Int32.t)} (! return {result}) ]
  
  let rec default'0 (return (x: Int64.t)) = any
    [ return' (result: Int64.t) -> {result = (0: Int64.t)} (! return {result}) ]
  
  type t_Tuple = { t_Tuple__0: Int32.t; t_Tuple__1: Int64.t }
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: Int32.t. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: Int32.t. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate postcondition_once'0 [@inline:trivial] (self: ()) (args: ()) (result: Int64.t) =
    let () = args in result = (0: Int64.t)
  
  meta "rewrite_def" predicate postcondition_once'0
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: Int64.t) =
    let () = args in result = (0: Int64.t)
  
  meta "rewrite_def" predicate postcondition_mut'0
  
  function fn_mut_once'0 (self: ()) (args: ()) (res: Int64.t) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: (), res: Int64.t. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: ()) (res_state: ()) (res: Int64.t) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: (), res_state: (), res: Int64.t. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 [@inline:trivial] (self: ()) (args: ()) (result: Int64.t) =
    let () = args in result = (0: Int64.t)
  
  meta "rewrite_def" predicate postcondition'0
  
  function fn_once'0 (self: ()) (args: ()) (res: Int64.t) : ()
  
  axiom fn_once_spec'0: forall self: (), args: (), res: Int64.t. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: ()) (res_state: ()) (res: Int64.t) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: (), res_state: (), res: Int64.t. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default'1 (return (x: t_Tuple)) = (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret: Int32.t) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = default'0 (fun (_ret: Int64.t) -> [ &_3 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- { t_Tuple__0 = _2; t_Tuple__1 = _3 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Tuple = Any.any_l () | & _2: Int32.t = Any.any_l () | & _3: Int64.t = Any.any_l () ])
    [ return (result: t_Tuple) -> {[@expl:default ensures] true
      /\ postcondition () () result.t_Tuple__0 /\ postcondition'0 () () result.t_Tuple__1}
      (! return {result}) ]
end
module M_default__qyi8078909456326062290__default (* <Named<T> as creusot_contracts::Default> *)
  use creusot.int.Int32
  use creusot.prelude.Any
  
  let rec default (return (x: Int32.t)) = any
    [ return' (result: Int32.t) -> {result = (0: Int32.t)} (! return {result}) ]
  
  type t_T
  
  predicate precondition (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true) -> precondition () args
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let () = args in inv res)
  
  let rec default'0 (return (x: t_T)) = {[@expl:default requires] precondition () ()}
    any [ return' (result: t_T) -> {postcondition_once () () result} (! return {result}) ]
  
  type t_Named = { t_Named__x: Int32.t; t_Named__y: t_T }
  
  predicate inv'0 (_1: t_Named)
  
  axiom inv_axiom [@rewrite]: forall x: t_Named [inv'0 x]. inv'0 x
      = match x with
        | {t_Named__x = x'0; t_Named__y = y} -> inv y
        end
  
  predicate postcondition_once'0 [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_once'0
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: Int32.t. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: Int32.t. postcondition_once'0 self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let () = args in inv res)
  
  function fn_mut_once'0 (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition'0 () args res]. postcondition'0 () args res
      -> (let () = args in inv res)
  
  function fn_once'0 (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec'0: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: (), res_state: (), res: t_T. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default'1 (return (x: t_Named)) = (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret: Int32.t) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = default'0 (fun (_ret: t_T) -> [ &_3 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- { t_Named__x = _2; t_Named__y = _3 } ] s1 | s1 = bb3 ]
    | bb3 = return {_0} ] [ & _0: t_Named = Any.any_l () | & _2: Int32.t = Any.any_l () | & _3: t_T = Any.any_l () ])
    [ return (result: t_Named) -> {[@expl:default result type invariant] inv'0 result}
      {[@expl:default ensures] true /\ postcondition () () result.t_Named__x /\ postcondition'0 () () result.t_Named__y}
      (! return {result}) ]
end
module M_default__qyi4734115080308954550__default (* <EUnit as creusot_contracts::Default> *)
  use creusot.prelude.Any
  
  type t_EUnit = C_X | C_Y
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default (return (x: t_EUnit)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- C_Y ] s1 | s1 = return {_0} ] ] [ & _0: t_EUnit = Any.any_l () ])
    [ return (result: t_EUnit) -> {[@expl:default ensures] match result with
        | C_Y -> true
        | _ -> false
        end}
      (! return {result}) ]
end
module M_default__qyi14004758275928035824__default (* <ETuple as creusot_contracts::Default> *)
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec default (return (x: Int32.t)) = any
    [ return' (result: Int32.t) -> {result = (0: Int32.t)} (! return {result}) ]
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_ETuple = C_A Int32.t Int32.t | C_B t_Vec
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: Int32.t. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: Int32.t. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default'0 (return (x: t_ETuple)) = (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret: Int32.t) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = default (fun (_ret: Int32.t) -> [ &_3 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- C_A _2 _3 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_ETuple = Any.any_l () | & _2: Int32.t = Any.any_l () | & _3: Int32.t = Any.any_l () ])
    [ return (result: t_ETuple) -> {[@expl:default ensures] match result with
        | C_A x0 x1 -> true /\ postcondition () () x0 /\ postcondition () () x1
        | _ -> false
        end}
      (! return {result}) ]
end
module M_default__qyi4220271428403486757__default (* <ENamed<T, U> as creusot_contracts::Default> *)
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true) -> precondition () args
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let () = args in inv res)
  
  let rec default (return (x: t_T)) = {[@expl:default requires] precondition () ()}
    any [ return' (result: t_T) -> {postcondition_once () () result} (! return {result}) ]
  
  type t_U
  
  predicate precondition'0 (self: ()) (args: ())
  
  axiom precondition_fndef'0: forall args: () [precondition'0 () args]. (let () = args in true)
      -> precondition'0 () args
  
  predicate inv'0 (_1: t_U)
  
  predicate postcondition_once'0 (self: ()) (args: ()) (result: t_U)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_U [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let () = args in inv'0 res)
  
  let rec default'0 (return (x: t_U)) = {[@expl:default requires] precondition'0 () ()}
    any [ return' (result: t_U) -> {postcondition_once'0 () () result} (! return {result}) ]
  
  type t_ENamed = C_A t_T t_U | C_B
  
  predicate inv'1 (_1: t_ENamed)
  
  axiom inv_axiom [@rewrite]: forall x: t_ENamed [inv'1 x]. inv'1 x
      = match x with
        | C_A x'0 y -> inv x'0 /\ inv'0 y
        | C_B -> true
        end
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let () = args in inv res)
  
  function fn_mut_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'2: forall args: (), res: t_T [postcondition () args res]. postcondition () args res
      -> (let () = args in inv res)
  
  function fn_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: ()) (result_state: ()) (result: t_U)
  
  axiom postcondition_fndef'3:
    forall args: (), res: t_U [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let () = args in inv'0 res)
  
  function fn_mut_once'0 (self: ()) (args: ()) (res: t_U) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: (), res: t_U. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: ()) (res_state: ()) (res: t_U) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: (), res_state: (), res: t_U. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: ()) (result: t_U)
  
  axiom postcondition_fndef'4: forall args: (), res: t_U [postcondition'0 () args res]. postcondition'0 () args res
      -> (let () = args in inv'0 res)
  
  function fn_once'0 (self: ()) (args: ()) (res: t_U) : ()
  
  axiom fn_once_spec'0: forall self: (), args: (), res: t_U. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: ()) (res_state: ()) (res: t_U) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: (), res_state: (), res: t_U. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default'1 (return (x: t_ENamed)) = (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret: t_T) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = default'0 (fun (_ret: t_U) -> [ &_3 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- C_A _2 _3 ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ] [ & _0: t_ENamed = Any.any_l () | & _2: t_T = Any.any_l () | & _3: t_U = Any.any_l () ])
    [ return (result: t_ENamed) -> {[@expl:default result type invariant] inv'1 result}
      {[@expl:default ensures] match result with
        | C_A x y -> true /\ postcondition () () x /\ postcondition'0 () () y
        | _ -> false
        end}
      (! return {result}) ]
end
module M_default__qyi8078909456326062290__default__refines (* <Named<T> as creusot_contracts::Default> *)
  use creusot.int.Int32
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: Int32.t. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: Int32.t. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return (x: Int32.t)) = any
    [ return' (result: Int32.t) -> {result = (0: Int32.t)} (! return {result}) ]
  
  type t_T
  
  type t_Named = { t_Named__x: Int32.t; t_Named__y: t_T }
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once'0 (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let () = args in inv res)
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let () = args in inv res)
  
  function fn_mut_once'0 (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: (), res: t_T. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition'0 () args res]. postcondition'0 () args res
      -> (let () = args in inv res)
  
  function fn_once'0 (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec'0: forall self: (), args: (), res: t_T. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: (), res_state: (), res: t_T. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  predicate precondition (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true) -> precondition () args
  
  let rec default'0 (return (x: t_T)) = {[@expl:default requires] precondition () ()}
    any [ return' (result: t_T) -> {postcondition_once'0 () () result} (! return {result}) ]
  
  predicate inv'0 (_1: t_Named)
  
  axiom inv_axiom [@rewrite]: forall x: t_Named [inv'0 x]. inv'0 x
      = match x with
        | {t_Named__x = x'0; t_Named__y = y} -> inv y
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_Named. true
        /\ postcondition () () result.t_Named__x /\ postcondition'0 () () result.t_Named__y /\ inv'0 result
      -> inv'0 result
end
module M_default__qyi4220271428403486757__default__refines (* <ENamed<T, U> as creusot_contracts::Default> *)
  type t_T
  
  type t_U
  
  type t_ENamed = C_A t_T t_U | C_B
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let () = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let () = args in inv res)
  
  function fn_mut_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition () args res]. postcondition () args res
      -> (let () = args in inv res)
  
  function fn_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate precondition (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true) -> precondition () args
  
  let rec default (return (x: t_T)) = {[@expl:default requires] precondition () ()}
    any [ return' (result: t_T) -> {postcondition_once () () result} (! return {result}) ]
  
  predicate inv'0 (_1: t_U)
  
  predicate postcondition_once'0 (self: ()) (args: ()) (result: t_U)
  
  axiom postcondition_fndef'2:
    forall args: (), res: t_U [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let () = args in inv'0 res)
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: ()) (result_state: ()) (result: t_U)
  
  axiom postcondition_fndef'3:
    forall args: (), res: t_U [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let () = args in inv'0 res)
  
  function fn_mut_once'0 (self: ()) (args: ()) (res: t_U) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: (), res: t_U. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: ()) (res_state: ()) (res: t_U) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: (), res_state: (), res: t_U. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: ()) (result: t_U)
  
  axiom postcondition_fndef'4: forall args: (), res: t_U [postcondition'0 () args res]. postcondition'0 () args res
      -> (let () = args in inv'0 res)
  
  function fn_once'0 (self: ()) (args: ()) (res: t_U) : ()
  
  axiom fn_once_spec'0: forall self: (), args: (), res: t_U. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: ()) (res_state: ()) (res: t_U) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: (), res_state: (), res: t_U. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  predicate precondition'0 (self: ()) (args: ())
  
  axiom precondition_fndef'0: forall args: () [precondition'0 () args]. (let () = args in true)
      -> precondition'0 () args
  
  let rec default'0 (return (x: t_U)) = {[@expl:default requires] precondition'0 () ()}
    any [ return' (result: t_U) -> {postcondition_once'0 () () result} (! return {result}) ]
  
  predicate inv'1 (_1: t_ENamed)
  
  axiom inv_axiom [@rewrite]: forall x: t_ENamed [inv'1 x]. inv'1 x
      = match x with
        | C_A x'0 y -> inv x'0 /\ inv'0 y
        | C_B -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_ENamed. match result with
            | C_A x y -> true /\ postcondition () () x /\ postcondition'0 () () y
            | _ -> false
            end
        /\ inv'1 result -> inv'1 result
end
