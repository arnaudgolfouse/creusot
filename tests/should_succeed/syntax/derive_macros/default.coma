module M_default__qyi3915135727482750158__default [#"default.rs" 4 9 4 16] (* <Unit as creusot_contracts::Default> *)
  let%span sdefault = "default.rs" 4 9 4 16
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec default[#"default.rs" 4 9 4 16] (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- () ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:default ensures] [%#sdefault] true} (! return' {result}) ]

end
module M_default__qyi13740418467561183253__default [#"default.rs" 7 9 7 16] (* <Tuple as creusot_contracts::Default> *)
  let%span sdefault = "default.rs" 7 9 7 16
  let%span snum = "../../../../creusot-contracts/src/std/num.rs" 30 26 30 41
  let%span snum'0 = "../../../../creusot-contracts/src/std/num.rs" 30 26 30 41
  let%span sops = "../../../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.int.Int32
  use creusot.int.Int64
  use creusot.prelude.Any
  
  let rec default (return'  (x:Int32.t))= any
    [ return''0 (result:Int32.t)-> {[%#snum] result = (0 : Int32.t)} (! return' {result}) ]
  
  
  let rec default'0 (return'  (x:Int64.t))= any
    [ return''0 (result:Int64.t)-> {[%#snum'0] result = (0 : Int64.t)} (! return' {result}) ]
  
  
  type t_Tuple  =
    { t_Tuple__0: Int32.t; t_Tuple__1: Int64.t }
  
  predicate postcondition_once (self : ()) (args : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  predicate resolve (_0 : ()) =
    true
  
  predicate postcondition_mut (self : ()) (args : ()) (result_state : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  function fn_mut_once (self : ()) (args : ()) (res : Int32.t) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : Int32.t . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self : ()) (args : ()) (res_state : ()) (res : Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : Int32.t . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self : ()) (args : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  function fn_once (self : ()) (args : ()) (res : Int32.t) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : Int32.t . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self : ()) (args : ()) (res_state : ()) (res : Int32.t) : ()
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : Int32.t . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : Int64.t) =
    let () = args in result = (0 : Int64.t)
  
  predicate resolve'0 (_0 : ()) =
    true
  
  predicate postcondition_mut'0 (self : ()) (args : ()) (result_state : ()) (result : Int64.t) =
    let () = args in result = (0 : Int64.t)
  
  function fn_mut_once'0 (self : ()) (args : ()) (res : Int64.t) : ()
  
  axiom fn_mut_once_spec'0 : forall self : (), args : (), res : Int64.t . [%#sops'8] postcondition_once'0 self args res
  = (exists res_state : () . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans'0 (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec'0 : forall self : (), b : (), c : () . ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self : ()) : ()
  
  axiom hist_inv_refl_spec'0 : forall self : () . [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self : ()) (args : ()) (res_state : ()) (res : Int64.t) : ()
  
  axiom postcondition_mut_hist_inv_spec'0 : forall self : (), args : (), res_state : (), res : Int64.t . ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec'0 : forall self : (), res_state : () . [%#sops'1] hist_inv'0 self res_state
  = (self = res_state)
  
  predicate postcondition'0 (self : ()) (args : ()) (result : Int64.t) =
    let () = args in result = (0 : Int64.t)
  
  function fn_once'0 (self : ()) (args : ()) (res : Int64.t) : ()
  
  axiom fn_once_spec'0 : forall self : (), args : (), res : Int64.t . [%#sops'0] postcondition_once'0 self args res
  = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self : ()) (args : ()) (res_state : ()) (res : Int64.t) : ()
  
  axiom fn_mut_spec'0 : forall self : (), args : (), res_state : (), res : Int64.t . [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec default'1[#"default.rs" 7 9 7 16] (return'  (x:t_Tuple))= (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:Int32.t) ->  [ &_2 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = default'0 (fun (_ret:Int64.t) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_0 <- { t_Tuple__0 = _2; t_Tuple__1 = _3 } ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : t_Tuple = Any.any_l () | & _2 : Int32.t = Any.any_l () | & _3 : Int64.t = Any.any_l () ] 
    [ return''0 (result:t_Tuple)-> {[@expl:default ensures] [%#sdefault] true
      /\ postcondition () () result.t_Tuple__0 /\ postcondition'0 () () result.t_Tuple__1}
      (! return' {result}) ]

end
module M_default__qyi8078909456326062290__default [#"default.rs" 10 9 10 16] (* <Named<T> as creusot_contracts::Default> *)
  let%span sdefault = "default.rs" 10 9 10 16
  let%span snum = "../../../../creusot-contracts/src/std/num.rs" 30 26 30 41
  let%span sops = "../../../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  let rec default (return'  (x:Int32.t))= any
    [ return''0 (result:Int32.t)-> {[%#snum] result = (0 : Int32.t)} (! return' {result}) ]
  
  
  type t_T
  
  predicate precondition (self : ()) (args : ())
  
  axiom precondition_fndef : forall args : () [precondition () args] . (let () = args in true)  -> precondition () args
  
  predicate inv (_0 : t_T)
  
  predicate postcondition_once (self : ()) (args : ()) (result : t_T)
  
  axiom postcondition_fndef : forall args : (), res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default'0 (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  type t_Named  =
    { t_Named__x: Int32.t; t_Named__y: t_T }
  
  predicate inv'0 (_0 : t_Named)
  
  axiom inv_axiom [@rewrite] : forall x : t_Named [inv'0 x] . inv'0 x
  = match x with
    | {t_Named__x = x'0 ; t_Named__y = y} -> inv y
    end
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  predicate resolve (_0 : ()) =
    true
  
  predicate postcondition_mut (self : ()) (args : ()) (result_state : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  function fn_mut_once (self : ()) (args : ()) (res : Int32.t) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : Int32.t . [%#sops'8] postcondition_once'0 self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self : ()) (args : ()) (res_state : ()) (res : Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : Int32.t . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self : ()) (args : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  function fn_once (self : ()) (args : ()) (res : Int32.t) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : Int32.t . [%#sops'0] postcondition_once'0 self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self : ()) (args : ()) (res_state : ()) (res : Int32.t) : ()
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : Int32.t . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate resolve'0 (_0 : ()) =
    true
  
  predicate postcondition_mut'0 (self : ()) (args : ()) (result_state : ()) (result : t_T)
  
  axiom postcondition_fndef'0 : forall args : (), res : t_T [postcondition_mut'0 () args () res] . postcondition_mut'0 () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once'0 (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_mut_once_spec'0 : forall self : (), args : (), res : t_T . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans'0 (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec'0 : forall self : (), b : (), c : () . ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self : ()) : ()
  
  axiom hist_inv_refl_spec'0 : forall self : () . [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'0 : forall self : (), args : (), res_state : (), res : t_T . ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec'0 : forall self : (), res_state : () . [%#sops'1] hist_inv'0 self res_state
  = (self = res_state)
  
  predicate postcondition'0 (self : ()) (args : ()) (result : t_T)
  
  axiom postcondition_fndef'1 : forall args : (), res : t_T [postcondition'0 () args res] . postcondition'0 () args res
   -> (let () = args in inv res)
  
  function fn_once'0 (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_once_spec'0 : forall self : (), args : (), res : t_T . [%#sops'0] postcondition_once self args res
  = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  axiom fn_mut_spec'0 : forall self : (), args : (), res_state : (), res : t_T . [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec default'1[#"default.rs" 10 9 10 16] (return'  (x:t_Named))= (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:Int32.t) ->  [ &_2 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = default'0 (fun (_ret:t_T) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_0 <- { t_Named__x = _2; t_Named__y = _3 } ] s1 | s1 = bb3 ] 
    | bb3 = return''0 {_0} ]
    ) [ & _0 : t_Named = Any.any_l () | & _2 : Int32.t = Any.any_l () | & _3 : t_T = Any.any_l () ] 
    [ return''0 (result:t_Named)-> {[@expl:default result type invariant] [%#sdefault] inv'0 result}
      {[@expl:default ensures] [%#sdefault] true
      /\ postcondition () () result.t_Named__x /\ postcondition'0 () () result.t_Named__y}
      (! return' {result}) ]

end
module M_default__qyi4734115080308954550__default [#"default.rs" 16 9 16 16] (* <EUnit as creusot_contracts::Default> *)
  let%span sdefault = "default.rs" 16 9 16 16
  
  use creusot.prelude.Any
  
  type t_EUnit  =
    | C_X
    | C_Y
  
  meta "compute_max_steps" 1000000
  
  let rec default[#"default.rs" 16 9 16 16] (return'  (x:t_EUnit))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- C_Y ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : t_EUnit = Any.any_l () ] 
    [ return''0 (result:t_EUnit)-> {[@expl:default ensures] [%#sdefault] match result with
        | C_Y -> true
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_default__qyi14004758275928035824__default [#"default.rs" 23 9 23 16] (* <ETuple as creusot_contracts::Default> *)
  let%span sdefault = "default.rs" 23 9 23 16
  let%span snum = "../../../../creusot-contracts/src/std/num.rs" 30 26 30 41
  let%span sops = "../../../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec default (return'  (x:Int32.t))= any
    [ return''0 (result:Int32.t)-> {[%#snum] result = (0 : Int32.t)} (! return' {result}) ]
  
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_ETuple  =
    | C_A Int32.t Int32.t
    | C_B t_Vec
  
  predicate postcondition_once (self : ()) (args : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  predicate resolve (_0 : ()) =
    true
  
  predicate postcondition_mut (self : ()) (args : ()) (result_state : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  function fn_mut_once (self : ()) (args : ()) (res : Int32.t) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : Int32.t . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self : ()) (args : ()) (res_state : ()) (res : Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : Int32.t . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self : ()) (args : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  function fn_once (self : ()) (args : ()) (res : Int32.t) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : Int32.t . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self : ()) (args : ()) (res_state : ()) (res : Int32.t) : ()
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : Int32.t . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec default'0[#"default.rs" 23 9 23 16] (return'  (x:t_ETuple))= (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:Int32.t) ->  [ &_2 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = default (fun (_ret:Int32.t) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_0 <- C_A _2 _3 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : t_ETuple = Any.any_l () | & _2 : Int32.t = Any.any_l () | & _3 : Int32.t = Any.any_l () ] 
    [ return''0 (result:t_ETuple)-> {[@expl:default ensures] [%#sdefault] match result with
        | C_A x0 x1 -> true /\ postcondition () () x0 /\ postcondition () () x1
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_default__qyi4220271428403486757__default [#"default.rs" 32 9 32 16] (* <ENamed<T, U> as creusot_contracts::Default> *)
  let%span sdefault = "default.rs" 32 9 32 16
  let%span sops = "../../../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition (self : ()) (args : ())
  
  axiom precondition_fndef : forall args : () [precondition () args] . (let () = args in true)  -> precondition () args
  
  predicate inv (_0 : t_T)
  
  predicate postcondition_once (self : ()) (args : ()) (result : t_T)
  
  axiom postcondition_fndef : forall args : (), res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  type t_U
  
  predicate precondition'0 (self : ()) (args : ())
  
  axiom precondition_fndef'0 : forall args : () [precondition'0 () args] . (let () = args in true)
   -> precondition'0 () args
  
  predicate inv'0 (_0 : t_U)
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : t_U)
  
  axiom postcondition_fndef'0 : forall args : (), res : t_U [postcondition_once'0 () args res] . postcondition_once'0 () args res
   -> (let () = args in inv'0 res)
  
  let rec default'0 (return'  (x:t_U))= {[@expl:default requires] precondition'0 () ()}
    any [ return''0 (result:t_U)-> {postcondition_once'0 () () result} (! return' {result}) ] 
  
  type t_ENamed  =
    | C_A t_T t_U
    | C_B
  
  predicate inv'1 (_0 : t_ENamed)
  
  axiom inv_axiom [@rewrite] : forall x : t_ENamed [inv'1 x] . inv'1 x
  = match x with
    | C_A x'0 y -> inv x'0 /\ inv'0 y
    | C_B -> true
    end
  
  predicate resolve (_0 : ()) =
    true
  
  predicate postcondition_mut (self : ()) (args : ()) (result_state : ()) (result : t_T)
  
  axiom postcondition_fndef'1 : forall args : (), res : t_T [postcondition_mut () args () res] . postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : t_T . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : t_T . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self : ()) (args : ()) (result : t_T)
  
  axiom postcondition_fndef'2 : forall args : (), res : t_T [postcondition () args res] . postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : t_T . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : t_T . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate resolve'0 (_0 : ()) =
    true
  
  predicate postcondition_mut'0 (self : ()) (args : ()) (result_state : ()) (result : t_U)
  
  axiom postcondition_fndef'3 : forall args : (), res : t_U [postcondition_mut'0 () args () res] . postcondition_mut'0 () args () res
   -> (let () = args in inv'0 res)
  
  function fn_mut_once'0 (self : ()) (args : ()) (res : t_U) : ()
  
  axiom fn_mut_once_spec'0 : forall self : (), args : (), res : t_U . [%#sops'8] postcondition_once'0 self args res
  = (exists res_state : () . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans'0 (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec'0 : forall self : (), b : (), c : () . ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self : ()) : ()
  
  axiom hist_inv_refl_spec'0 : forall self : () . [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self : ()) (args : ()) (res_state : ()) (res : t_U) : ()
  
  axiom postcondition_mut_hist_inv_spec'0 : forall self : (), args : (), res_state : (), res : t_U . ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec'0 : forall self : (), res_state : () . [%#sops'1] hist_inv'0 self res_state
  = (self = res_state)
  
  predicate postcondition'0 (self : ()) (args : ()) (result : t_U)
  
  axiom postcondition_fndef'4 : forall args : (), res : t_U [postcondition'0 () args res] . postcondition'0 () args res
   -> (let () = args in inv'0 res)
  
  function fn_once'0 (self : ()) (args : ()) (res : t_U) : ()
  
  axiom fn_once_spec'0 : forall self : (), args : (), res : t_U . [%#sops'0] postcondition_once'0 self args res
  = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self : ()) (args : ()) (res_state : ()) (res : t_U) : ()
  
  axiom fn_mut_spec'0 : forall self : (), args : (), res_state : (), res : t_U . [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec default'1[#"default.rs" 32 9 32 16] (return'  (x:t_ENamed))= (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_2 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = default'0 (fun (_ret:t_U) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_0 <- C_A _2 _3 ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    ) [ & _0 : t_ENamed = Any.any_l () | & _2 : t_T = Any.any_l () | & _3 : t_U = Any.any_l () ] 
    [ return''0 (result:t_ENamed)-> {[@expl:default result type invariant] [%#sdefault] inv'1 result}
      {[@expl:default ensures] [%#sdefault] match result with
        | C_A x y -> true /\ postcondition () () x /\ postcondition'0 () () y
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_default__qyi8078909456326062290__default__refines [#"default.rs" 10 9 10 16] (* <Named<T> as creusot_contracts::Default> *)
  let%span sdefault = "default.rs" 10 9 10 16
  let%span snum = "../../../../creusot-contracts/src/std/num.rs" 30 26 30 41
  let%span sops = "../../../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.int.Int32
  
  predicate postcondition_once (self : ()) (args : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  predicate resolve (_0 : ()) =
    true
  
  predicate postcondition_mut (self : ()) (args : ()) (result_state : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  function fn_mut_once (self : ()) (args : ()) (res : Int32.t) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : Int32.t . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self : ()) (args : ()) (res_state : ()) (res : Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : Int32.t . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self : ()) (args : ()) (result : Int32.t) =
    let () = args in result = (0 : Int32.t)
  
  function fn_once (self : ()) (args : ()) (res : Int32.t) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : Int32.t . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self : ()) (args : ()) (res_state : ()) (res : Int32.t) : ()
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : Int32.t . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  let rec default (return'  (x:Int32.t))= any
    [ return''0 (result:Int32.t)-> {[%#snum] result = (0 : Int32.t)} (! return' {result}) ]
  
  
  type t_T
  
  type t_Named  =
    { t_Named__x: Int32.t; t_Named__y: t_T }
  
  predicate inv (_0 : t_T)
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : t_T)
  
  axiom postcondition_fndef : forall args : (), res : t_T [postcondition_once'0 () args res] . postcondition_once'0 () args res
   -> (let () = args in inv res)
  
  predicate resolve'0 (_0 : ()) =
    true
  
  predicate postcondition_mut'0 (self : ()) (args : ()) (result_state : ()) (result : t_T)
  
  axiom postcondition_fndef'0 : forall args : (), res : t_T [postcondition_mut'0 () args () res] . postcondition_mut'0 () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once'0 (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_mut_once_spec'0 : forall self : (), args : (), res : t_T . [%#sops'8] postcondition_once'0 self args res
  = (exists res_state : () . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans'0 (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec'0 : forall self : (), b : (), c : () . ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self : ()) : ()
  
  axiom hist_inv_refl_spec'0 : forall self : () . [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec'0 : forall self : (), args : (), res_state : (), res : t_T . ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec'0 : forall self : (), res_state : () . [%#sops'1] hist_inv'0 self res_state
  = (self = res_state)
  
  predicate postcondition'0 (self : ()) (args : ()) (result : t_T)
  
  axiom postcondition_fndef'1 : forall args : (), res : t_T [postcondition'0 () args res] . postcondition'0 () args res
   -> (let () = args in inv res)
  
  function fn_once'0 (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_once_spec'0 : forall self : (), args : (), res : t_T . [%#sops'0] postcondition_once'0 self args res
  = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  axiom fn_mut_spec'0 : forall self : (), args : (), res_state : (), res : t_T . [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  predicate precondition (self : ()) (args : ())
  
  axiom precondition_fndef : forall args : () [precondition () args] . (let () = args in true)  -> precondition () args
  
  let rec default'0 (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once'0 () () result} (! return' {result}) ] 
  
  predicate inv'0 (_0 : t_Named)
  
  axiom inv_axiom [@rewrite] : forall x : t_Named [inv'0 x] . inv'0 x
  = match x with
    | {t_Named__x = x'0 ; t_Named__y = y} -> inv y
    end
  
  goal refines : [%#sdefault] forall result : t_Named . true
  /\ postcondition () () result.t_Named__x /\ postcondition'0 () () result.t_Named__y /\ inv'0 result  -> inv'0 result
end
module M_default__qyi4220271428403486757__default__refines [#"default.rs" 32 9 32 16] (* <ENamed<T, U> as creusot_contracts::Default> *)
  let%span sdefault = "default.rs" 32 9 32 16
  let%span sops = "../../../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  type t_T
  
  type t_U
  
  type t_ENamed  =
    | C_A t_T t_U
    | C_B
  
  predicate inv (_0 : t_T)
  
  predicate postcondition_once (self : ()) (args : ()) (result : t_T)
  
  axiom postcondition_fndef : forall args : (), res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let () = args in inv res)
  
  predicate resolve (_0 : ()) =
    true
  
  predicate postcondition_mut (self : ()) (args : ()) (result_state : ()) (result : t_T)
  
  axiom postcondition_fndef'0 : forall args : (), res : t_T [postcondition_mut () args () res] . postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : t_T . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : t_T . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self : ()) (args : ()) (result : t_T)
  
  axiom postcondition_fndef'1 : forall args : (), res : t_T [postcondition () args res] . postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : t_T . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : t_T . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate precondition (self : ()) (args : ())
  
  axiom precondition_fndef : forall args : () [precondition () args] . (let () = args in true)  -> precondition () args
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  predicate inv'0 (_0 : t_U)
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : t_U)
  
  axiom postcondition_fndef'2 : forall args : (), res : t_U [postcondition_once'0 () args res] . postcondition_once'0 () args res
   -> (let () = args in inv'0 res)
  
  predicate resolve'0 (_0 : ()) =
    true
  
  predicate postcondition_mut'0 (self : ()) (args : ()) (result_state : ()) (result : t_U)
  
  axiom postcondition_fndef'3 : forall args : (), res : t_U [postcondition_mut'0 () args () res] . postcondition_mut'0 () args () res
   -> (let () = args in inv'0 res)
  
  function fn_mut_once'0 (self : ()) (args : ()) (res : t_U) : ()
  
  axiom fn_mut_once_spec'0 : forall self : (), args : (), res : t_U . [%#sops'8] postcondition_once'0 self args res
  = (exists res_state : () . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans'0 (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec'0 : forall self : (), b : (), c : () . ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self : ()) : ()
  
  axiom hist_inv_refl_spec'0 : forall self : () . [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self : ()) (args : ()) (res_state : ()) (res : t_U) : ()
  
  axiom postcondition_mut_hist_inv_spec'0 : forall self : (), args : (), res_state : (), res : t_U . ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec'0 : forall self : (), res_state : () . [%#sops'1] hist_inv'0 self res_state
  = (self = res_state)
  
  predicate postcondition'0 (self : ()) (args : ()) (result : t_U)
  
  axiom postcondition_fndef'4 : forall args : (), res : t_U [postcondition'0 () args res] . postcondition'0 () args res
   -> (let () = args in inv'0 res)
  
  function fn_once'0 (self : ()) (args : ()) (res : t_U) : ()
  
  axiom fn_once_spec'0 : forall self : (), args : (), res : t_U . [%#sops'0] postcondition_once'0 self args res
  = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self : ()) (args : ()) (res_state : ()) (res : t_U) : ()
  
  axiom fn_mut_spec'0 : forall self : (), args : (), res_state : (), res : t_U . [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  predicate precondition'0 (self : ()) (args : ())
  
  axiom precondition_fndef'0 : forall args : () [precondition'0 () args] . (let () = args in true)
   -> precondition'0 () args
  
  let rec default'0 (return'  (x:t_U))= {[@expl:default requires] precondition'0 () ()}
    any [ return''0 (result:t_U)-> {postcondition_once'0 () () result} (! return' {result}) ] 
  
  predicate inv'1 (_0 : t_ENamed)
  
  axiom inv_axiom [@rewrite] : forall x : t_ENamed [inv'1 x] . inv'1 x
  = match x with
    | C_A x'0 y -> inv x'0 /\ inv'0 y
    | C_B -> true
    end
  
  goal refines : [%#sdefault] forall result : t_ENamed . match result with
    | C_A x y -> true /\ postcondition () () x /\ postcondition'0 () () y
    | _ -> false
    end
  /\ inv'1 result  -> inv'1 result
end
