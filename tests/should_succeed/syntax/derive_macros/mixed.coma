module M_mixed__qyi2592445413368279263__clone (* <Product<A, B> as creusot_contracts::Clone> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Product = { t_Product__a: t_A; t_Product__b: t_B }
  
  predicate inv (_1: t_A)
  
  predicate invariant' [@inline:trivial] (self: t_A) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: t_A)
  
  axiom inv_axiom [@rewrite]: forall x: t_A [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition (self: ()) (args: t_A)
  
  axiom precondition_fndef: forall args: t_A [precondition () args]. (let self_ = args in inv'0 self_)
      -> precondition () args
  
  predicate postcondition_once (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef: forall args: t_A, res: t_A [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  let rec clone' (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_A) -> {postcondition_once () self_ result} (! return {result}) ]
  
  predicate inv'1 (_1: t_B)
  
  predicate invariant''0 [@inline:trivial] (self: t_B) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_B)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_B [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition'0 (self: ()) (args: t_B)
  
  axiom precondition_fndef'0: forall args: t_B [precondition'0 () args]. (let self_ = args in inv'2 self_)
      -> precondition'0 () args
  
  predicate postcondition_once'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'0:
    forall args: t_B, res: t_B [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let self_ = args in inv'1 res)
  
  let rec clone''0 (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition'0 () self_}
    any [ return (result: t_B) -> {postcondition_once'0 () self_ result} (! return {result}) ]
  
  predicate inv'3 (_1: t_Product)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Product [inv'3 x]. inv'3 x = (inv x.t_Product__a /\ inv'1 x.t_Product__b)
  
  predicate invariant''1 [@inline:trivial] (self: t_Product) = inv'3 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: t_Product)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Product [inv'4 x]. inv'4 x = invariant''1 x
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'2: forall args: t_A, res: t_A [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let self_ = args in inv'1 res)
  
  function fn_mut_once'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4: forall args: t_B, res: t_B [postcondition'0 () args res]. postcondition'0 () args res
      -> (let self_ = args in inv'1 res)
  
  function fn_once'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''1 (self: t_Product) (return (x: t_Product)) = {[@expl:clone 'self' type invariant] inv'4 self}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_5 <- self.t_Product__a ] s1 | s1 = clone' {_5} (fun (_ret: t_A) -> [ &_3 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_8 <- self.t_Product__b ] s1 | s1 = clone''0 {_8} (fun (_ret: t_B) -> [ &_6 <- _ret ] s2) | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- { t_Product__a = _3; t_Product__b = _6 } ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_Product = Any.any_l ()
    | & self: t_Product = self
    | & _3: t_A = Any.any_l ()
    | & _5: t_A = Any.any_l ()
    | & _6: t_B = Any.any_l ()
    | & _8: t_B = Any.any_l () ])
    [ return (result: t_Product) -> {[@expl:clone result type invariant] inv'3 result}
      {[@expl:clone ensures] postcondition () self.t_Product__a result.t_Product__a
      /\ postcondition'0 () self.t_Product__b result.t_Product__b}
      (! return {result}) ]
end
module M_mixed__qyi15378480724732772077__eq (* <Product<A, B> as creusot_contracts::PartialEq> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Product = { t_Product__a: t_A; t_Product__b: t_B }
  
  type tuple = { f0: t_A; f1: t_A }
  
  predicate inv (_1: t_A)
  
  predicate invariant' [@inline:trivial] (self: t_A) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: t_A)
  
  axiom inv_axiom [@rewrite]: forall x: t_A [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'0 rhs
        /\ inv'0 self_) -> precondition () args
  
  type t_DeepModelTy
  
  function deep_model (self: t_A) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_A) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate postcondition_once (self: ()) (args: tuple) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = (deep_model'0 self_ = deep_model'0 rhs))
  
  let rec eq (self_: t_A) (rhs: t_A) (return (x: bool)) = {[@expl:eq requires] precondition () { f0 = self_; f1 = rhs }}
    any [ return (result: bool) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  type tuple'0 = { f0'0: t_B; f1'0: t_B }
  
  predicate inv'1 (_1: t_B)
  
  predicate invariant''0 [@inline:trivial] (self: t_B) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_B)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_B [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition'0 (self: ()) (args: tuple'0)
  
  axiom precondition_fndef'0:
    forall args: tuple'0 [precondition'0 () args]. (let {f0'0 = self_; f1'0 = rhs} = args in inv'2 rhs /\ inv'2 self_)
      -> precondition'0 () args
  
  type t_DeepModelTy'0
  
  function deep_model'1 (self: t_B) : t_DeepModelTy'0
  
  function deep_model'2 [@inline:trivial] (self: t_B) : t_DeepModelTy'0 = deep_model'1 self
  
  meta "rewrite_def" function deep_model'2
  
  predicate postcondition_once'0 (self: ()) (args: tuple'0) (result: bool)
  
  axiom postcondition_fndef'0:
    forall args: tuple'0, res: bool [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let {f0'0 = self_; f1'0 = rhs} = args in res = (deep_model'2 self_ = deep_model'2 rhs))
  
  let rec eq'0 (self_: t_B) (rhs: t_B) (return (x: bool)) = {[@expl:eq requires] precondition'0 () { f0'0 = self_;
                                                                                                     f1'0 = rhs }}
    any [ return (result: bool) -> {postcondition_once'0 () { f0'0 = self_; f1'0 = rhs } result} (! return {result}) ]
  
  predicate inv'3 (_1: t_Product)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Product [inv'3 x]. inv'3 x = (inv x.t_Product__a /\ inv'1 x.t_Product__b)
  
  predicate invariant''1 [@inline:trivial] (self: t_Product) = inv'3 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: t_Product)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Product [inv'4 x]. inv'4 x = invariant''1 x
  
  type t_Product'0 = { t_Product__a'0: t_DeepModelTy; t_Product__b'0: t_DeepModelTy'0 }
  
  function deep_model'3 (self: t_Product) : t_Product'0 = { t_Product__a'0 = deep_model self.t_Product__a;
                                                            t_Product__b'0 = deep_model'1 self.t_Product__b }
  
  function deep_model'4 [@inline:trivial] (self: t_Product) : t_Product'0 = deep_model'3 self
  
  meta "rewrite_def" function deep_model'4
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq'1 (self: t_Product) (rhs: t_Product) (return (x: bool)) = {[@expl:eq 'self' type invariant] inv'4 self}
    {[@expl:eq 'rhs' type invariant] inv'4 rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq {self.t_Product__a} {rhs.t_Product__a} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ]
    | bb2 = s0 [ s0 = eq'0 {self.t_Product__b} {rhs.t_Product__b} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb5 ]
    | bb3 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self: t_Product = self | & rhs: t_Product = rhs | & _4: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (deep_model'4 self = deep_model'4 rhs)}
      (! return {result}) ]
end
module M_mixed__qyi1267749258272586863__clone (* <Sum<A, B> as creusot_contracts::Clone> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Sum = C_A t_A | C_B t_B
  
  let rec v_B (input: t_Sum) (ret (b: t_B)) = any
    [ good (b: t_B) -> {C_B b = input} (! ret {b})
    | bad -> {forall b: t_B [C_B b: t_Sum]. C_B b <> input} (! {false} any) ]
  
  predicate inv (_1: t_B)
  
  predicate invariant' [@inline:trivial] (self: t_B) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: t_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_B [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition (self: ()) (args: t_B)
  
  axiom precondition_fndef: forall args: t_B [precondition () args]. (let self_ = args in inv'0 self_)
      -> precondition () args
  
  predicate postcondition_once (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef: forall args: t_B, res: t_B [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  let rec clone' (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_B) -> {postcondition_once () self_ result} (! return {result}) ]
  
  let rec v_A (input: t_Sum) (ret (field_0: t_A)) = any
    [ good (field_0: t_A) -> {C_A field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_A [C_A field_0: t_Sum]. C_A field_0 <> input} (! {false} any) ]
  
  predicate inv'1 (_1: t_A)
  
  predicate invariant''0 [@inline:trivial] (self: t_A) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_A)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_A [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition'0 (self: ()) (args: t_A)
  
  axiom precondition_fndef'0: forall args: t_A [precondition'0 () args]. (let self_ = args in inv'2 self_)
      -> precondition'0 () args
  
  predicate postcondition_once'0 (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let self_ = args in inv'1 res)
  
  let rec clone''0 (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition'0 () self_}
    any [ return (result: t_A) -> {postcondition_once'0 () self_ result} (! return {result}) ]
  
  predicate inv'3 (_1: t_Sum)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Sum [inv'3 x]. inv'3 x
      = match x with
        | C_A a_0 -> inv'1 a_0
        | C_B b -> inv b
        end
  
  predicate invariant''1 [@inline:trivial] (self: t_Sum) = inv'3 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: t_Sum)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Sum [inv'4 x]. inv'4 x = invariant''1 x
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv'1 res)
  
  function fn_mut_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'2: forall args: t_A, res: t_A [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv'1 res)
  
  function fn_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once'0 self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4: forall args: t_B, res: t_B [postcondition'0 () args res]. postcondition'0 () args res
      -> (let self_ = args in inv res)
  
  function fn_once'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''1 (self: t_Sum) (return (x: t_Sum)) = {[@expl:clone 'self' type invariant] inv'4 self}
    (! bb0
    [ bb0 = any [ br0 (x0: t_A) -> {self = C_A x0} (! bb4) | br1 (x0: t_B) -> {self = C_B x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_B {self} (fun (rb: t_B) -> [ &b_1 <- rb ] s1)
      | s1 = [ &_11 <- b_1 ] s2
      | s2 = clone' {_11} (fun (_ret: t_B) -> [ &_9 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = [ &_0 <- C_B _9 ] s1 | s1 = bb9 ]
    | bb4 = s0
      [ s0 = v_A {self} (fun (r0: t_A) -> [ &v0_1 <- r0 ] s1)
      | s1 = [ &_7 <- v0_1 ] s2
      | s2 = clone''0 {_7} (fun (_ret: t_A) -> [ &_5 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_A _5 ] s1 | s1 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: t_Sum = Any.any_l ()
    | & self: t_Sum = self
    | & v0_1: t_A = Any.any_l ()
    | & _5: t_A = Any.any_l ()
    | & _7: t_A = Any.any_l ()
    | & b_1: t_B = Any.any_l ()
    | & _9: t_B = Any.any_l ()
    | & _11: t_B = Any.any_l () ])
    [ return (result: t_Sum) -> {[@expl:clone result type invariant] inv'3 result}
      {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = C_A v0_1; f1 = C_A v0_r} -> postcondition () v0_1 v0_r
        | {f0 = C_B b_1; f1 = C_B b_r} -> postcondition'0 () b_1 b_r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_mixed__qyi16267973469411556781__eq (* <Sum<A, B> as creusot_contracts::PartialEq> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Sum = C_A t_A | C_B t_B
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  let rec v_B (input: t_Sum) (ret (b: t_B)) = any
    [ good (b: t_B) -> {C_B b = input} (! ret {b})
    | bad -> {forall b: t_B [C_B b: t_Sum]. C_B b <> input} (! {false} any) ]
  
  type tuple'0 = { f0'0: t_B; f1'0: t_B }
  
  predicate inv (_1: t_B)
  
  predicate invariant' [@inline:trivial] (self: t_B) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: t_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_B [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition (self: ()) (args: tuple'0)
  
  axiom precondition_fndef:
    forall args: tuple'0 [precondition () args]. (let {f0'0 = self_; f1'0 = rhs} = args in inv'0 rhs /\ inv'0 self_)
      -> precondition () args
  
  type t_DeepModelTy
  
  function deep_model (self: t_B) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_B) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate postcondition_once (self: ()) (args: tuple'0) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tuple'0, res: bool [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0'0 = self_; f1'0 = rhs} = args in res = (deep_model'0 self_ = deep_model'0 rhs))
  
  let rec eq (self_: t_B) (rhs: t_B) (return (x: bool)) = {[@expl:eq requires] precondition () { f0'0 = self_;
                                                                                                 f1'0 = rhs }}
    any [ return (result: bool) -> {postcondition_once () { f0'0 = self_; f1'0 = rhs } result} (! return {result}) ]
  
  let rec v_A (input: t_Sum) (ret (field_0: t_A)) = any
    [ good (field_0: t_A) -> {C_A field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_A [C_A field_0: t_Sum]. C_A field_0 <> input} (! {false} any) ]
  
  type tuple'1 = { f0'1: t_A; f1'1: t_A }
  
  predicate inv'1 (_1: t_A)
  
  predicate invariant''0 [@inline:trivial] (self: t_A) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_A)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_A [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition'0 (self: ()) (args: tuple'1)
  
  axiom precondition_fndef'0:
    forall args: tuple'1 [precondition'0 () args]. (let {f0'1 = self_; f1'1 = rhs} = args in inv'2 rhs /\ inv'2 self_)
      -> precondition'0 () args
  
  type t_DeepModelTy'0
  
  function deep_model'1 (self: t_A) : t_DeepModelTy'0
  
  function deep_model'2 [@inline:trivial] (self: t_A) : t_DeepModelTy'0 = deep_model'1 self
  
  meta "rewrite_def" function deep_model'2
  
  predicate postcondition_once'0 (self: ()) (args: tuple'1) (result: bool)
  
  axiom postcondition_fndef'0:
    forall args: tuple'1, res: bool [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let {f0'1 = self_; f1'1 = rhs} = args in res = (deep_model'2 self_ = deep_model'2 rhs))
  
  let rec eq'0 (self_: t_A) (rhs: t_A) (return (x: bool)) = {[@expl:eq requires] precondition'0 () { f0'1 = self_;
                                                                                                     f1'1 = rhs }}
    any [ return (result: bool) -> {postcondition_once'0 () { f0'1 = self_; f1'1 = rhs } result} (! return {result}) ]
  
  predicate inv'3 (_1: t_Sum)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Sum [inv'3 x]. inv'3 x
      = match x with
        | C_A a_0 -> inv'1 a_0
        | C_B b -> inv b
        end
  
  predicate invariant''1 [@inline:trivial] (self: t_Sum) = inv'3 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: t_Sum)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Sum [inv'4 x]. inv'4 x = invariant''1 x
  
  type t_Sum'0 = C_A'0 t_DeepModelTy'0 | C_B'0 t_DeepModelTy
  
  function deep_model'3 (self: t_Sum) : t_Sum'0 = match self with
      | C_A a -> C_A'0 (deep_model'1 a)
      | C_B b -> C_B'0 (deep_model b)
      end
  
  function deep_model'4 [@inline:trivial] (self: t_Sum) : t_Sum'0 = deep_model'3 self
  
  meta "rewrite_def" function deep_model'4
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq'1 (self: t_Sum) (rhs: t_Sum) (return (x: bool)) = {[@expl:eq 'self' type invariant] inv'4 self}
    {[@expl:eq 'rhs' type invariant] inv'4 rhs}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- { f0 = self; f1 = rhs } ] s1
      | s1 = any [ br0 (x0: t_A) -> {_4.f0 = C_A x0} (! bb2) | br1 (x0: t_B) -> {_4.f0 = C_B x0} (! bb4) ] ]
    | bb4 = any [ br0 (x0: t_A) -> {_4.f1 = C_A x0} (! bb1) | br1 (x0: t_B) -> {_4.f1 = C_B x0} (! bb6) ]
    | bb6 = s0
      [ s0 = v_B {_4.f0} (fun (rb: t_B) -> [ &b_1 <- rb ] s1)
      | s1 = v_B {_4.f1} (fun (rb: t_B) -> [ &b_2 <- rb ] s2)
      | s2 = eq {b_1} {b_2} (fun (_ret: bool) -> [ &_17 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = any [ br0 -> {_17 = false} (! bb14) | br1 -> {_17} (! bb13) ]
    | bb13 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb16 ]
    | bb14 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb16 ]
    | bb2 = any [ br0 (x0: t_A) -> {_4.f1 = C_A x0} (! bb7) | br1 (x0: t_B) -> {_4.f1 = C_B x0} (! bb1) ]
    | bb1 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb16 ]
    | bb7 = s0
      [ s0 = v_A {_4.f0} (fun (r0: t_A) -> [ &v0_1 <- r0 ] s1)
      | s1 = v_A {_4.f1} (fun (r0: t_A) -> [ &v0_2 <- r0 ] s2)
      | s2 = eq'0 {v0_1} {v0_2} (fun (_ret: bool) -> [ &_12 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = any [ br0 -> {_12 = false} (! bb10) | br1 -> {_12} (! bb9) ]
    | bb9 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb16 ]
    | bb10 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb16 ]
    | bb16 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_Sum = self
    | & rhs: t_Sum = rhs
    | & _4: tuple = Any.any_l ()
    | & v0_1: t_A = Any.any_l ()
    | & v0_2: t_A = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & b_1: t_B = Any.any_l ()
    | & b_2: t_B = Any.any_l ()
    | & _17: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (deep_model'4 self = deep_model'4 rhs)}
      (! return {result}) ]
end
module M_mixed__qyi8044263102292640215__resolve_coherence (* <Product2<'a, A> as creusot_contracts::Resolve> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use seq.Seq
  use creusot.int.UInt32
  use creusot.int.UInt64
  
  type t_A
  
  type t_Vec
  
  type t_Product2 = { t_Product2__a: MutBorrow.t t_A; t_Product2__b: bool; t_Product2__c: t_Vec }
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_A) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_A) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt32.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate resolve'1 [@inline:trivial] (_1: UInt32.t) = true
  
  meta "rewrite_def" predicate resolve'1
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : UInt32.t = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  predicate resolve'2 [@inline:trivial] (self: t_Vec) =
    forall i: int. 0 <= i /\ i < Seq.length (view self) -> resolve'1 (index_logic self i)
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_Vec) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  predicate structural_resolve (_1: t_Product2) = resolve'0 _1.t_Product2__a /\ resolve'3 _1.t_Product2__c
  
  predicate resolve'4 [@inline:trivial] (_1: bool) = true
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 (self: t_Product2) =
    resolve'0 self.t_Product2__a /\ resolve'4 self.t_Product2__b /\ resolve'3 self.t_Product2__c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Product2
  
  function resolve_coherence (self: t_Product2) : ()
  
  goal vc_resolve_coherence: structural_resolve self -> ([@expl:resolve_coherence ensures] resolve'5 self)
end
module M_mixed__qyi2899991615344599026__resolve_coherence (* <Sum2<A, B> as creusot_contracts::Resolve> *)
  type t_A
  
  type t_B
  
  type t_Sum2 = C_X t_A | C_Y bool t_B
  
  predicate resolve (_1: t_A)
  
  predicate resolve'0 (_1: t_B)
  
  predicate structural_resolve (_1: t_Sum2) =
    match _1 with
      | C_X x0 -> resolve x0
      | C_Y x0 x1 -> resolve'0 x1
      end
  
  predicate resolve'1 [@inline:trivial] (_1: bool) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (self: t_Sum2) =
    match self with
      | C_X v0_1 -> resolve v0_1
      | C_Y a_1 x_1 -> resolve'1 a_1 /\ resolve'0 x_1
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum2
  
  function resolve_coherence (self: t_Sum2) : ()
  
  goal vc_resolve_coherence: structural_resolve self -> ([@expl:resolve_coherence ensures] resolve'2 self)
end
module M_mixed__qyi2388806976216935010__clone (* <Sum2<A, B> as creusot_contracts::Clone> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Sum2 = C_X t_A | C_Y bool t_B
  
  let rec v_Y (input: t_Sum2) (ret (a: bool) (x: t_B)) = any
    [ good (a: bool) (x: t_B) -> {C_Y a x = input} (! ret {a} {x})
    | bad -> {forall a: bool, x: t_B [C_Y a x: t_Sum2]. C_Y a x <> input} (! {false} any) ]
  
  let rec clone' (self_: bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = self_} (! return {result}) ]
  
  predicate inv (_1: t_B)
  
  predicate invariant' [@inline:trivial] (self: t_B) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: t_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_B [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition (self: ()) (args: t_B)
  
  axiom precondition_fndef: forall args: t_B [precondition () args]. (let self_ = args in inv'0 self_)
      -> precondition () args
  
  predicate postcondition_once (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef: forall args: t_B, res: t_B [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  let rec clone''0 (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_B) -> {postcondition_once () self_ result} (! return {result}) ]
  
  let rec v_X (input: t_Sum2) (ret (field_0: t_A)) = any
    [ good (field_0: t_A) -> {C_X field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_A [C_X field_0: t_Sum2]. C_X field_0 <> input} (! {false} any) ]
  
  predicate inv'1 (_1: t_A)
  
  predicate invariant''0 [@inline:trivial] (self: t_A) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 (_1: t_A)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_A [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition'0 (self: ()) (args: t_A)
  
  axiom precondition_fndef'0: forall args: t_A [precondition'0 () args]. (let self_ = args in inv'2 self_)
      -> precondition'0 () args
  
  predicate postcondition_once'0 (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let self_ = args in inv'1 res)
  
  let rec clone''1 (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition'0 () self_}
    any [ return (result: t_A) -> {postcondition_once'0 () self_ result} (! return {result}) ]
  
  predicate inv'3 (_1: t_Sum2)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Sum2 [inv'3 x]. inv'3 x
      = match x with
        | C_X a_0 -> inv'1 a_0
        | C_Y a x'0 -> inv x'0
        end
  
  predicate invariant''1 [@inline:trivial] (self: t_Sum2) = inv'3 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: t_Sum2)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Sum2 [inv'4 x]. inv'4 x = invariant''1 x
  
  type tuple = { f0: t_Sum2; f1: t_Sum2 }
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv'1 res)
  
  function fn_mut_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'2: forall args: t_A, res: t_A [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv'1 res)
  
  function fn_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once'0 self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate postcondition_once'1 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once'1
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 [@inline:trivial] (self: ()) (args: bool) (result_state: ()) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut'0
  
  function fn_mut_once'0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: bool, res: bool. postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition'0
  
  function fn_once'0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_once_spec'0: forall self: (), args: bool, res: bool. postcondition_once'1 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  predicate resolve'1 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate postcondition_mut'1 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut'1 () args () res]. postcondition_mut'1 () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once'1 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_spec'1: forall self: (), args: t_B, res: t_B. postcondition_once self args res
      = (exists res_state: (). postcondition_mut'1 self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv'1 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'1
  
  function hist_inv_trans'1 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'1: forall self: (), b: (), c: (). hist_inv'1 self b -> hist_inv'1 b c -> hist_inv'1 self c
  
  function hist_inv_refl'1 (self: ()) : ()
  
  axiom hist_inv_refl_spec'1: forall self: (). hist_inv'1 self self
  
  function postcondition_mut_hist_inv'1 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec'1:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'1 self args res_state res
      -> hist_inv'1 self res_state
  
  function fn_hist_inv'1 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'1: forall self: (), res_state: (). hist_inv'1 self res_state = (self = res_state)
  
  predicate postcondition'1 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4: forall args: t_B, res: t_B [postcondition'1 () args res]. postcondition'1 () args res
      -> (let self_ = args in inv res)
  
  function fn_once'1 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_spec'1: forall self: (), args: t_B, res: t_B. postcondition_once self args res
      = (postcondition'1 self args res /\ resolve'1 self)
  
  function fn_mut'1 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_spec'1: forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'1 self args res_state res
      = (postcondition'1 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''2 (self: t_Sum2) (return (x: t_Sum2)) = {[@expl:clone 'self' type invariant] inv'4 self}
    (! bb0
    [ bb0 = any [ br0 (x0: t_A) -> {self = C_X x0} (! bb4) | br1 (x0: bool) (x1: t_B) -> {self = C_Y x0 x1} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Y {self} (fun (ra: bool) (rx: t_B) -> [ &a_1 <- ra ] s1)
      | s1 = v_Y {self} (fun (ra: bool) (rx: t_B) -> [ &x_1 <- rx ] s2)
      | s2 = [ &_12 <- a_1 ] s3
      | s3 = clone' {_12} (fun (_ret: bool) -> [ &_10 <- _ret ] s4)
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_15 <- x_1 ] s1 | s1 = clone''0 {_15} (fun (_ret: t_B) -> [ &_13 <- _ret ] s2) | s2 = bb8 ]
    | bb8 = s0 [ s0 = [ &_0 <- C_Y _10 _13 ] s1 | s1 = bb10 ]
    | bb4 = s0
      [ s0 = v_X {self} (fun (r0: t_A) -> [ &v0_1 <- r0 ] s1)
      | s1 = [ &_7 <- v0_1 ] s2
      | s2 = clone''1 {_7} (fun (_ret: t_A) -> [ &_5 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_X _5 ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Sum2 = Any.any_l ()
    | & self: t_Sum2 = self
    | & v0_1: t_A = Any.any_l ()
    | & _5: t_A = Any.any_l ()
    | & _7: t_A = Any.any_l ()
    | & a_1: bool = Any.any_l ()
    | & x_1: t_B = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: t_B = Any.any_l ()
    | & _15: t_B = Any.any_l () ])
    [ return (result: t_Sum2) -> {[@expl:clone result type invariant] inv'3 result}
      {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = C_X v0_1; f1 = C_X v0_r} -> postcondition () v0_1 v0_r
        | {f0 = C_Y a_1 x_1; f1 = C_Y a_r x_r} -> postcondition'0 () a_1 a_r /\ postcondition'1 () x_1 x_r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_mixed__qyi2592445413368279263__clone__refines (* <Product<A, B> as creusot_contracts::Clone> *)
  type t_A
  
  type t_B
  
  type t_Product = { t_Product__a: t_A; t_Product__b: t_B }
  
  predicate inv (_1: t_A)
  
  predicate inv'0 (_1: t_B)
  
  predicate inv'1 (_1: t_Product)
  
  axiom inv_axiom [@rewrite]: forall x: t_Product [inv'1 x]. inv'1 x = (inv x.t_Product__a /\ inv'0 x.t_Product__b)
  
  predicate invariant' [@inline:trivial] (self: t_Product) = inv'1 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 (_1: t_Product)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Product [inv'2 x]. inv'2 x = invariant' x
  
  predicate postcondition_once (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef: forall args: t_A, res: t_A [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'1: forall args: t_A, res: t_A [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate invariant''0 [@inline:trivial] (self: t_A) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'3 (_1: t_A)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_A [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate precondition (self: ()) (args: t_A)
  
  axiom precondition_fndef: forall args: t_A [precondition () args]. (let self_ = args in inv'3 self_)
      -> precondition () args
  
  let rec clone' (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_A) -> {postcondition_once () self_ result} (! return {result}) ]
  
  predicate postcondition_once'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'2:
    forall args: t_B, res: t_B [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let self_ = args in inv'0 res)
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let self_ = args in inv'0 res)
  
  function fn_mut_once'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4: forall args: t_B, res: t_B [postcondition'0 () args res]. postcondition'0 () args res
      -> (let self_ = args in inv'0 res)
  
  function fn_once'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  predicate invariant''1 [@inline:trivial] (self: t_B) = inv'0 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: t_B)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_B [inv'4 x]. inv'4 x = invariant''1 x
  
  predicate precondition'0 (self: ()) (args: t_B)
  
  axiom precondition_fndef'0: forall args: t_B [precondition'0 () args]. (let self_ = args in inv'4 self_)
      -> precondition'0 () args
  
  let rec clone''0 (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition'0 () self_}
    any [ return (result: t_B) -> {postcondition_once'0 () self_ result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Product. inv'2 self_
      -> inv'2 self_
      /\ (forall result: t_Product. postcondition () self_.t_Product__a result.t_Product__a
          /\ postcondition'0 () self_.t_Product__b result.t_Product__b /\ inv'1 result -> inv'1 result)
end
module M_mixed__qyi1267749258272586863__clone__refines (* <Sum<A, B> as creusot_contracts::Clone> *)
  type t_A
  
  type t_B
  
  type t_Sum = C_A t_A | C_B t_B
  
  predicate inv (_1: t_A)
  
  predicate inv'0 (_1: t_B)
  
  predicate inv'1 (_1: t_Sum)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum [inv'1 x]. inv'1 x
      = match x with
        | C_A a_0 -> inv a_0
        | C_B b -> inv'0 b
        end
  
  predicate invariant' [@inline:trivial] (self: t_Sum) = inv'1 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 (_1: t_Sum)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Sum [inv'2 x]. inv'2 x = invariant' x
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  predicate postcondition_once (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef: forall args: t_A, res: t_A [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'1: forall args: t_A, res: t_A [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate invariant''0 [@inline:trivial] (self: t_A) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'3 (_1: t_A)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_A [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate precondition (self: ()) (args: t_A)
  
  axiom precondition_fndef: forall args: t_A [precondition () args]. (let self_ = args in inv'3 self_)
      -> precondition () args
  
  let rec clone' (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_A) -> {postcondition_once () self_ result} (! return {result}) ]
  
  predicate postcondition_once'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'2:
    forall args: t_B, res: t_B [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let self_ = args in inv'0 res)
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let self_ = args in inv'0 res)
  
  function fn_mut_once'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4: forall args: t_B, res: t_B [postcondition'0 () args res]. postcondition'0 () args res
      -> (let self_ = args in inv'0 res)
  
  function fn_once'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  predicate invariant''1 [@inline:trivial] (self: t_B) = inv'0 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: t_B)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_B [inv'4 x]. inv'4 x = invariant''1 x
  
  predicate precondition'0 (self: ()) (args: t_B)
  
  axiom precondition_fndef'0: forall args: t_B [precondition'0 () args]. (let self_ = args in inv'4 self_)
      -> precondition'0 () args
  
  let rec clone''0 (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition'0 () self_}
    any [ return (result: t_B) -> {postcondition_once'0 () self_ result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Sum. inv'2 self_
      -> inv'2 self_
      /\ (forall result: t_Sum. match { f0 = self_; f1 = result } with
              | {f0 = C_A v0_1; f1 = C_A v0_r} -> postcondition () v0_1 v0_r
              | {f0 = C_B b_1; f1 = C_B b_r} -> postcondition'0 () b_1 b_r
              | _ -> false
              end
          /\ inv'1 result -> inv'1 result)
end
module M_mixed__qyi2388806976216935010__clone__refines (* <Sum2<A, B> as creusot_contracts::Clone> *)
  type t_A
  
  type t_B
  
  type t_Sum2 = C_X t_A | C_Y bool t_B
  
  predicate inv (_1: t_A)
  
  predicate inv'0 (_1: t_B)
  
  predicate inv'1 (_1: t_Sum2)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum2 [inv'1 x]. inv'1 x
      = match x with
        | C_X a_0 -> inv a_0
        | C_Y a x'0 -> inv'0 x'0
        end
  
  predicate invariant' [@inline:trivial] (self: t_Sum2) = inv'1 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 (_1: t_Sum2)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Sum2 [inv'2 x]. inv'2 x = invariant' x
  
  type tuple = { f0: t_Sum2; f1: t_Sum2 }
  
  predicate postcondition_once (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef: forall args: t_A, res: t_A [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'1: forall args: t_A, res: t_A [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_spec: forall self: (), args: t_A, res: t_A. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate invariant''0 [@inline:trivial] (self: t_A) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'3 (_1: t_A)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_A [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate precondition (self: ()) (args: t_A)
  
  axiom precondition_fndef: forall args: t_A [precondition () args]. (let self_ = args in inv'3 self_)
      -> precondition () args
  
  let rec clone' (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_A) -> {postcondition_once () self_ result} (! return {result}) ]
  
  predicate postcondition_once'0 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once'0
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 [@inline:trivial] (self: ()) (args: bool) (result_state: ()) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut'0
  
  function fn_mut_once'0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: bool, res: bool. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition'0
  
  function fn_once'0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_once_spec'0: forall self: (), args: bool, res: bool. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  let rec clone''0 (self_: bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = self_} (! return {result}) ]
  
  predicate postcondition_once'1 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'2:
    forall args: t_B, res: t_B [postcondition_once'1 () args res]. postcondition_once'1 () args res
      -> (let self_ = args in inv'0 res)
  
  predicate resolve'1 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate postcondition_mut'1 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut'1 () args () res]. postcondition_mut'1 () args () res
      -> (let self_ = args in inv'0 res)
  
  function fn_mut_once'1 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_spec'1: forall self: (), args: t_B, res: t_B. postcondition_once'1 self args res
      = (exists res_state: (). postcondition_mut'1 self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv'1 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'1
  
  function hist_inv_trans'1 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'1: forall self: (), b: (), c: (). hist_inv'1 self b -> hist_inv'1 b c -> hist_inv'1 self c
  
  function hist_inv_refl'1 (self: ()) : ()
  
  axiom hist_inv_refl_spec'1: forall self: (). hist_inv'1 self self
  
  function postcondition_mut_hist_inv'1 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec'1:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'1 self args res_state res
      -> hist_inv'1 self res_state
  
  function fn_hist_inv'1 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'1: forall self: (), res_state: (). hist_inv'1 self res_state = (self = res_state)
  
  predicate postcondition'1 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4: forall args: t_B, res: t_B [postcondition'1 () args res]. postcondition'1 () args res
      -> (let self_ = args in inv'0 res)
  
  function fn_once'1 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_spec'1: forall self: (), args: t_B, res: t_B. postcondition_once'1 self args res
      = (postcondition'1 self args res /\ resolve'1 self)
  
  function fn_mut'1 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_spec'1: forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut'1 self args res_state res
      = (postcondition'1 self args res /\ self = res_state)
  
  predicate invariant''1 [@inline:trivial] (self: t_B) = inv'0 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'4 (_1: t_B)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_B [inv'4 x]. inv'4 x = invariant''1 x
  
  predicate precondition'0 (self: ()) (args: t_B)
  
  axiom precondition_fndef'0: forall args: t_B [precondition'0 () args]. (let self_ = args in inv'4 self_)
      -> precondition'0 () args
  
  let rec clone''1 (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition'0 () self_}
    any [ return (result: t_B) -> {postcondition_once'1 () self_ result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Sum2. inv'2 self_
      -> inv'2 self_
      /\ (forall result: t_Sum2. match { f0 = self_; f1 = result } with
              | {f0 = C_X v0_1; f1 = C_X v0_r} -> postcondition () v0_1 v0_r
              | {f0 = C_Y a_1 x_1; f1 = C_Y a_r x_r} -> postcondition'0 () a_1 a_r /\ postcondition'1 () x_1 x_r
              | _ -> false
              end
          /\ inv'1 result -> inv'1 result)
end
module M_mixed__qyi15378480724732772077__eq__refines (* <Product<A, B> as creusot_contracts::PartialEq> *)
  type t_A
  
  type t_B
  
  type t_Product = { t_Product__a: t_A; t_Product__b: t_B }
  
  predicate inv (_1: t_A)
  
  predicate inv'0 (_1: t_B)
  
  predicate inv'1 (_1: t_Product)
  
  axiom inv_axiom [@rewrite]: forall x: t_Product [inv'1 x]. inv'1 x = (inv x.t_Product__a /\ inv'0 x.t_Product__b)
  
  predicate invariant' [@inline:trivial] (self: t_Product) = inv'1 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 (_1: t_Product)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Product [inv'2 x]. inv'2 x = invariant' x
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type t_Product'0 = { t_Product__a'0: t_DeepModelTy; t_Product__b'0: t_DeepModelTy'0 }
  
  function deep_model (self: t_A) : t_DeepModelTy
  
  function deep_model'0 (self: t_B) : t_DeepModelTy'0
  
  function deep_model'1 (self: t_Product) : t_Product'0 = { t_Product__a'0 = deep_model self.t_Product__a;
                                                            t_Product__b'0 = deep_model'0 self.t_Product__b }
  
  function deep_model'2 [@inline:trivial] (self: t_Product) : t_Product'0 = deep_model'1 self
  
  meta "rewrite_def" function deep_model'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Product. forall rhs: t_Product. inv'2 rhs /\ inv'2 self_
        -> inv'2 rhs
        /\ inv'2 self_
        /\ (forall result: bool. result = (deep_model'2 self_ = deep_model'2 rhs)
          -> result = (deep_model'2 self_ = deep_model'2 rhs))
end
module M_mixed__qyi16267973469411556781__eq__refines (* <Sum<A, B> as creusot_contracts::PartialEq> *)
  type t_A
  
  type t_B
  
  type t_Sum = C_A t_A | C_B t_B
  
  predicate inv (_1: t_A)
  
  predicate inv'0 (_1: t_B)
  
  predicate inv'1 (_1: t_Sum)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum [inv'1 x]. inv'1 x
      = match x with
        | C_A a_0 -> inv a_0
        | C_B b -> inv'0 b
        end
  
  predicate invariant' [@inline:trivial] (self: t_Sum) = inv'1 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 (_1: t_Sum)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Sum [inv'2 x]. inv'2 x = invariant' x
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type t_Sum'0 = C_A'0 t_DeepModelTy | C_B'0 t_DeepModelTy'0
  
  function deep_model (self: t_A) : t_DeepModelTy
  
  function deep_model'0 (self: t_B) : t_DeepModelTy'0
  
  function deep_model'1 (self: t_Sum) : t_Sum'0 = match self with
      | C_A a -> C_A'0 (deep_model a)
      | C_B b -> C_B'0 (deep_model'0 b)
      end
  
  function deep_model'2 [@inline:trivial] (self: t_Sum) : t_Sum'0 = deep_model'1 self
  
  meta "rewrite_def" function deep_model'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Sum. forall rhs: t_Sum. inv'2 rhs /\ inv'2 self_
        -> inv'2 rhs
        /\ inv'2 self_
        /\ (forall result: bool. result = (deep_model'2 self_ = deep_model'2 rhs)
          -> result = (deep_model'2 self_ = deep_model'2 rhs))
end
module M_mixed__qyi8044263102292640215__resolve_coherence__refines (* <Product2<'a, A> as creusot_contracts::Resolve> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use seq.Seq
  use creusot.int.UInt32
  use creusot.int.UInt64
  
  type t_A
  
  type t_Vec
  
  type t_Product2 = { t_Product2__a: MutBorrow.t t_A; t_Product2__b: bool; t_Product2__c: t_Vec }
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_A) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_A) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt32.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate resolve'1 [@inline:trivial] (_1: UInt32.t) = true
  
  meta "rewrite_def" predicate resolve'1
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : UInt32.t = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  predicate resolve'2 [@inline:trivial] (self: t_Vec) =
    forall i: int. 0 <= i /\ i < Seq.length (view self) -> resolve'1 (index_logic self i)
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_1: t_Vec) = resolve'2 _1
  
  meta "rewrite_def" predicate resolve'3
  
  predicate structural_resolve (_1: t_Product2) = resolve'0 _1.t_Product2__a /\ resolve'3 _1.t_Product2__c
  
  predicate inv (_1: t_A)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_A) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: MutBorrow.t t_A)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_A [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 (_1: t_Product2)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Product2 [inv'1 x]. inv'1 x = inv'0 x.t_Product2__a
  
  predicate resolve'4 [@inline:trivial] (_1: bool) = true
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 (self: t_Product2) =
    resolve'0 self.t_Product2__a /\ resolve'4 self.t_Product2__b /\ resolve'3 self.t_Product2__c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Product2. structural_resolve self /\ inv'1 self
      -> structural_resolve self /\ (forall result: (). resolve'5 self -> resolve'5 self)
end
module M_mixed__qyi2899991615344599026__resolve_coherence__refines (* <Sum2<A, B> as creusot_contracts::Resolve> *)
  type t_A
  
  type t_B
  
  type t_Sum2 = C_X t_A | C_Y bool t_B
  
  predicate resolve (_1: t_A)
  
  predicate resolve'0 (_1: t_B)
  
  predicate structural_resolve (_1: t_Sum2) =
    match _1 with
      | C_X x0 -> resolve x0
      | C_Y x0 x1 -> resolve'0 x1
      end
  
  predicate inv (_1: t_A)
  
  predicate inv'0 (_1: t_B)
  
  predicate inv'1 (_1: t_Sum2)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum2 [inv'1 x]. inv'1 x
      = match x with
        | C_X a_0 -> inv a_0
        | C_Y a x'0 -> inv'0 x'0
        end
  
  predicate resolve'1 [@inline:trivial] (_1: bool) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (self: t_Sum2) =
    match self with
      | C_X v0_1 -> resolve v0_1
      | C_Y a_1 x_1 -> resolve'1 a_1 /\ resolve'0 x_1
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum2. structural_resolve self /\ inv'1 self
      -> structural_resolve self /\ (forall result: (). resolve'2 self -> resolve'2 self)
end
