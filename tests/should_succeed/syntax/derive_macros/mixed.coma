module M_mixed__qyi2592445413368279263__clone [#"mixed.rs" 8 9 8 14] (* <Product<A, B> as creusot_contracts::Clone> *)
  let%span smixed = "mixed.rs" 8 9 8 14
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Product  =
    { t_Product__a: t_A; t_Product__b: t_B }
  
  predicate inv (_0 : t_A)
  
  predicate invariant' (self : t_A) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0 : t_A)
  
  axiom inv_axiom [@rewrite] : forall x : t_A [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition (self : ()) (args : t_A)
  
  axiom precondition_fndef : forall args : t_A [precondition () args] . (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once (self : ()) (args : t_A) (result : t_A)
  
  axiom postcondition_fndef : forall args : t_A, res : t_A [postcondition_once () args res] . postcondition_once () args res
   -> (let self_ = args in res = self_ /\ inv res)
  
  let rec clone' (self_:t_A) (return'  (x:t_A))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_A)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate inv'1 (_0 : t_B)
  
  predicate invariant''0 (self : t_B) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_B)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_B [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate precondition'0 (self : ()) (args : t_B)
  
  axiom precondition_fndef'0 : forall args : t_B [precondition'0 () args] . (let self_ = args in inv'2 self_)
   -> precondition'0 () args
  
  predicate postcondition_once'0 (self : ()) (args : t_B) (result : t_B)
  
  axiom postcondition_fndef'0 : forall args : t_B, res : t_B [postcondition_once'0 () args res] . postcondition_once'0 () args res
   -> (let self_ = args in res = self_ /\ inv'1 res)
  
  let rec clone''0 (self_:t_B) (return'  (x:t_B))= {[@expl:clone requires] precondition'0 () self_}
    any [ return''0 (result:t_B)-> {postcondition_once'0 () self_ result} (! return' {result}) ] 
  
  predicate inv'3 (_0 : t_Product)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Product [inv'3 x] . inv'3 x
  = match x with
    | {t_Product__a = a ; t_Product__b = b} -> inv a /\ inv'1 b
    end
  
  predicate invariant''1 (self : t_Product) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 (_0 : t_Product)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Product [inv'4 x] . inv'4 x = invariant''1 x
  
  meta "compute_max_steps" 1000000
  
  let rec clone''1[#"mixed.rs" 8 9 8 14] (self:t_Product) (return'  (x:t_Product))= {[@expl:clone 'self' type invariant] [%#smixed] inv'4 self}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- self'0.t_Product__a ] s1 | s1 = clone' {_5} (fun (_ret:t_A) ->  [ &_3 <- _ret ] s2) | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_8 <- self'0.t_Product__b ] s1
      | s1 = clone''0 {_8} (fun (_ret:t_B) ->  [ &_6 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 =  [ &_0 <- { t_Product__a = _3; t_Product__b = _6 } ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    )
    [ & _0 : t_Product = Any.any_l ()
    | & self'0 : t_Product = self
    | & _3 : t_A = Any.any_l ()
    | & _5 : t_A = Any.any_l ()
    | & _6 : t_B = Any.any_l ()
    | & _8 : t_B = Any.any_l () ]
    
    [ return''0 (result:t_Product)-> {[@expl:clone result type invariant] [%#smixed] inv'3 result}
      {[@expl:clone ensures] [%#smixed] result = self}
      (! return' {result}) ]

end
module M_mixed__qyi15378480724732772077__eq [#"mixed.rs" 8 16 8 25] (* <Product<A, B> as creusot_contracts::PartialEq> *)
  let%span smixed = "mixed.rs" 10 4 11 12
  let%span smixed'0 = "mixed.rs" 8 16 8 25
  let%span smixed'1 = "mixed.rs" 24 8 24 66
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span smodel = "../../../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Product  =
    { t_Product__a: t_A; t_Product__b: t_B }
  
  type tuple  =
    { _p0: t_A; _p1: t_A }
  
  predicate inv (_0 : t_A)
  
  predicate invariant' (self : t_A) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0 : t_A)
  
  axiom inv_axiom [@rewrite] : forall x : t_A [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function deep_model (self : t_A) : t_DeepModelTy
  
  function deep_model'0 (self : t_A) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once (self : ()) (args : tuple) (result : bool)
  
  axiom postcondition_fndef : forall args : tuple, res : bool [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = (deep_model'0 self_ = deep_model'0 rhs))
  
  let rec eq (self_:t_A) (rhs:t_A) (return'  (x:bool))= {[@expl:eq requires] precondition () { _p0 = self_; _p1 = rhs }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ] 
  
  type tuple'0  =
    { _p0'0: t_B; _p1'0: t_B }
  
  predicate inv'1 (_0 : t_B)
  
  predicate invariant''0 (self : t_B) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_B)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_B [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate precondition'0 (self : ()) (args : tuple'0)
  
  axiom precondition_fndef'0 : forall args : tuple'0 [precondition'0 () args] . (let {_p0'0 = self_ ; _p1'0 = rhs} = args in inv'2 rhs
  /\ inv'2 self_)  -> precondition'0 () args
  
  type t_DeepModelTy'0
  
  function deep_model'1 (self : t_B) : t_DeepModelTy'0
  
  function deep_model'2 (self : t_B) : t_DeepModelTy'0 =
    [%#smodel] deep_model'1 self
  
  predicate postcondition_once'0 (self : ()) (args : tuple'0) (result : bool)
  
  axiom postcondition_fndef'0 : forall args : tuple'0, res : bool [postcondition_once'0 () args res] . postcondition_once'0 () args res
   -> (let {_p0'0 = self_ ; _p1'0 = rhs} = args in res = (deep_model'2 self_ = deep_model'2 rhs))
  
  let rec eq'0 (self_:t_B) (rhs:t_B) (return'  (x:bool))= {[@expl:eq requires] precondition'0 () { _p0'0 = self_;
                                                                                                   _p1'0 = rhs }}
    any
    [ return''0 (result:bool)-> {postcondition_once'0 () { _p0'0 = self_; _p1'0 = rhs } result} (! return' {result}) ]
  
  
  predicate inv'3 (_0 : t_Product)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Product [inv'3 x] . inv'3 x
  = match x with
    | {t_Product__a = a ; t_Product__b = b} -> inv a /\ inv'1 b
    end
  
  predicate invariant''1 (self : t_Product) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 (_0 : t_Product)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Product [inv'4 x] . inv'4 x = invariant''1 x
  
  type t_Product'0  =
    { t_Product__a'0: t_DeepModelTy; t_Product__b'0: t_DeepModelTy'0 }
  
  function deep_model'3 [#"mixed.rs" 23 4 23 44] (self : t_Product) : t_Product'0 =
    [%#smixed'1] { t_Product__a'0 = deep_model self.t_Product__a; t_Product__b'0 = deep_model'1 self.t_Product__b }
  
  function deep_model'4 (self : t_Product) : t_Product'0 =
    [%#smodel] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec eq'1[#"mixed.rs" 8 16 8 25] (self:t_Product) (rhs:t_Product) (return'  (x:bool))= {[@expl:eq 'self' type invariant] [%#smixed'0] inv'4 self}
    {[@expl:eq 'rhs' type invariant] [%#smixed'0] inv'4 rhs}
    (! bb0
    [ bb0 = s0
      [ s0 = eq {self'0.t_Product__a} {rhs'0.t_Product__a} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ] 
    | bb2 = s0
      [ s0 = eq'0 {self'0.t_Product__b} {rhs'0.t_Product__b} (fun (_ret:bool) ->  [ &_0 <- _ret ] s1) | s1 = bb4 ]
    
    | bb4 = bb5
    | bb3 = s0 [ s0 =  [ &_0 <- [%#smixed] false ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self'0 : t_Product = self
    | & rhs'0 : t_Product = rhs
    | & _4 : bool = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:eq ensures] [%#smixed'0] result = (deep_model'4 self = deep_model'4 rhs)}
      (! return' {result}) ]

end
module M_mixed__qyi1267749258272586863__clone [#"mixed.rs" 28 9 28 14] (* <Sum<A, B> as creusot_contracts::Clone> *)
  let%span smixed = "mixed.rs" 28 9 28 14
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Sum  =
    | C_A t_A
    | C_B t_B
  
  let rec v_B (input:t_Sum) (ret  (field_0:t_B))= any
    [ good (field_0:t_B)-> {C_B field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_B [C_B field_0 : t_Sum] . C_B field_0 <> input} (! {false} any) ]
  
  
  predicate inv (_0 : t_B)
  
  predicate invariant' (self : t_B) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0 : t_B)
  
  axiom inv_axiom [@rewrite] : forall x : t_B [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition (self : ()) (args : t_B)
  
  axiom precondition_fndef : forall args : t_B [precondition () args] . (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once (self : ()) (args : t_B) (result : t_B)
  
  axiom postcondition_fndef : forall args : t_B, res : t_B [postcondition_once () args res] . postcondition_once () args res
   -> (let self_ = args in res = self_ /\ inv res)
  
  let rec clone' (self_:t_B) (return'  (x:t_B))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_B)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  let rec v_A (input:t_Sum) (ret  (field_0:t_A))= any
    [ good (field_0:t_A)-> {C_A field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_A [C_A field_0 : t_Sum] . C_A field_0 <> input} (! {false} any) ]
  
  
  predicate inv'1 (_0 : t_A)
  
  predicate invariant''0 (self : t_A) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_A)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_A [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate precondition'0 (self : ()) (args : t_A)
  
  axiom precondition_fndef'0 : forall args : t_A [precondition'0 () args] . (let self_ = args in inv'2 self_)
   -> precondition'0 () args
  
  predicate postcondition_once'0 (self : ()) (args : t_A) (result : t_A)
  
  axiom postcondition_fndef'0 : forall args : t_A, res : t_A [postcondition_once'0 () args res] . postcondition_once'0 () args res
   -> (let self_ = args in res = self_ /\ inv'1 res)
  
  let rec clone''0 (self_:t_A) (return'  (x:t_A))= {[@expl:clone requires] precondition'0 () self_}
    any [ return''0 (result:t_A)-> {postcondition_once'0 () self_ result} (! return' {result}) ] 
  
  predicate inv'3 (_0 : t_Sum)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Sum [inv'3 x] . inv'3 x
  = match x with
    | C_A a_0 -> inv'1 a_0
    | C_B a_0 -> inv a_0
    end
  
  predicate invariant''1 (self : t_Sum) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 (_0 : t_Sum)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Sum [inv'4 x] . inv'4 x = invariant''1 x
  
  meta "compute_max_steps" 1000000
  
  let rec clone''1[#"mixed.rs" 28 9 28 14] (self:t_Sum) (return'  (x:t_Sum))= {[@expl:clone 'self' type invariant] [%#smixed] inv'4 self}
    (! bb0
    [ bb0 = any [ br0 (x0:t_A)-> {self'0 = C_A x0} (! bb2) | br1 (x0:t_B)-> {self'0 = C_B x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_B {self'0} (fun (r0:t_B) ->  [ &v0_1'0 <- r0 ] s1)
      | s1 =  [ &_11 <- v0_1'0 ] s2
      | s2 = clone' {_11} (fun (_ret:t_B) ->  [ &_9 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &_0 <- C_B _9 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb2 = bb4
    | bb4 = s0
      [ s0 = v_A {self'0} (fun (r0:t_A) ->  [ &v0_1 <- r0 ] s1)
      | s1 =  [ &_7 <- v0_1 ] s2
      | s2 = clone''0 {_7} (fun (_ret:t_A) ->  [ &_5 <- _ret ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_0 <- C_A _5 ] s1 | s1 = bb6 ] 
    | bb6 = bb9
    | bb9 = return''0 {_0} ]
    )
    [ & _0 : t_Sum = Any.any_l ()
    | & self'0 : t_Sum = self
    | & v0_1 : t_A = Any.any_l ()
    | & _5 : t_A = Any.any_l ()
    | & _7 : t_A = Any.any_l ()
    | & v0_1'0 : t_B = Any.any_l ()
    | & _9 : t_B = Any.any_l ()
    | & _11 : t_B = Any.any_l () ]
    
    [ return''0 (result:t_Sum)-> {[@expl:clone result type invariant] [%#smixed] inv'3 result}
      {[@expl:clone ensures] [%#smixed] result = self}
      (! return' {result}) ]

end
module M_mixed__qyi16267973469411556781__eq [#"mixed.rs" 28 16 28 25] (* <Sum<A, B> as creusot_contracts::PartialEq> *)
  let%span smixed = "mixed.rs" 28 16 28 25
  let%span smixed'0 = "mixed.rs" 40 8 43 9
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span smodel = "../../../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Sum  =
    | C_A t_A
    | C_B t_B
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  let rec v_B (input:t_Sum) (ret  (field_0:t_B))= any
    [ good (field_0:t_B)-> {C_B field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_B [C_B field_0 : t_Sum] . C_B field_0 <> input} (! {false} any) ]
  
  
  type tuple'0  =
    { _p0'0: t_B; _p1'0: t_B }
  
  predicate inv (_0 : t_B)
  
  predicate invariant' (self : t_B) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0 : t_B)
  
  axiom inv_axiom [@rewrite] : forall x : t_B [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition (self : ()) (args : tuple'0)
  
  axiom precondition_fndef : forall args : tuple'0 [precondition () args] . (let {_p0'0 = self_ ; _p1'0 = rhs} = args in inv'0 rhs
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function deep_model (self : t_B) : t_DeepModelTy
  
  function deep_model'0 (self : t_B) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once (self : ()) (args : tuple'0) (result : bool)
  
  axiom postcondition_fndef : forall args : tuple'0, res : bool [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0'0 = self_ ; _p1'0 = rhs} = args in res = (deep_model'0 self_ = deep_model'0 rhs))
  
  let rec eq (self_:t_B) (rhs:t_B) (return'  (x:bool))= {[@expl:eq requires] precondition () { _p0'0 = self_;
                                                                                               _p1'0 = rhs }}
    any
    [ return''0 (result:bool)-> {postcondition_once () { _p0'0 = self_; _p1'0 = rhs } result} (! return' {result}) ]
  
  
  let rec v_A (input:t_Sum) (ret  (field_0:t_A))= any
    [ good (field_0:t_A)-> {C_A field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_A [C_A field_0 : t_Sum] . C_A field_0 <> input} (! {false} any) ]
  
  
  type tuple'1  =
    { _p0'1: t_A; _p1'1: t_A }
  
  predicate inv'1 (_0 : t_A)
  
  predicate invariant''0 (self : t_A) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_A)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_A [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate precondition'0 (self : ()) (args : tuple'1)
  
  axiom precondition_fndef'0 : forall args : tuple'1 [precondition'0 () args] . (let {_p0'1 = self_ ; _p1'1 = rhs} = args in inv'2 rhs
  /\ inv'2 self_)  -> precondition'0 () args
  
  type t_DeepModelTy'0
  
  function deep_model'1 (self : t_A) : t_DeepModelTy'0
  
  function deep_model'2 (self : t_A) : t_DeepModelTy'0 =
    [%#smodel] deep_model'1 self
  
  predicate postcondition_once'0 (self : ()) (args : tuple'1) (result : bool)
  
  axiom postcondition_fndef'0 : forall args : tuple'1, res : bool [postcondition_once'0 () args res] . postcondition_once'0 () args res
   -> (let {_p0'1 = self_ ; _p1'1 = rhs} = args in res = (deep_model'2 self_ = deep_model'2 rhs))
  
  let rec eq'0 (self_:t_A) (rhs:t_A) (return'  (x:bool))= {[@expl:eq requires] precondition'0 () { _p0'1 = self_;
                                                                                                   _p1'1 = rhs }}
    any
    [ return''0 (result:bool)-> {postcondition_once'0 () { _p0'1 = self_; _p1'1 = rhs } result} (! return' {result}) ]
  
  
  predicate inv'3 (_0 : t_Sum)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Sum [inv'3 x] . inv'3 x
  = match x with
    | C_A a_0 -> inv'1 a_0
    | C_B a_0 -> inv a_0
    end
  
  predicate invariant''1 (self : t_Sum) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 (_0 : t_Sum)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Sum [inv'4 x] . inv'4 x = invariant''1 x
  
  type t_Sum'0  =
    | C_A'0 t_DeepModelTy'0
    | C_B'0 t_DeepModelTy
  
  function deep_model'3 [#"mixed.rs" 39 4 39 44] (self : t_Sum) : t_Sum'0 =
    [%#smixed'0] match self with
      | C_A a -> C_A'0 (deep_model'1 a)
      | C_B b -> C_B'0 (deep_model b)
      end
  
  function deep_model'4 (self : t_Sum) : t_Sum'0 =
    [%#smodel] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec eq'1[#"mixed.rs" 28 16 28 25] (self:t_Sum) (rhs:t_Sum) (return'  (x:bool))= {[@expl:eq 'self' type invariant] [%#smixed] inv'4 self}
    {[@expl:eq 'rhs' type invariant] [%#smixed] inv'4 rhs}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- { _p0 = self'0; _p1 = rhs'0 } ] s1
      | s1 = any [ br0 (x0:t_A)-> {_4._p0 = C_A x0} (! bb2) | br1 (x0:t_B)-> {_4._p0 = C_B x0} (! bb4) ]  ]
    
    | bb4 = any [ br0 (x0:t_A)-> {_4._p1 = C_A x0} (! bb1) | br1 (x0:t_B)-> {_4._p1 = C_B x0} (! bb5) ] 
    | bb5 = bb6
    | bb6 = s0
      [ s0 = v_B {_4._p0} (fun (r0:t_B) ->  [ &v0_1'0 <- r0 ] s1)
      | s1 = v_B {_4._p1} (fun (r0:t_B) ->  [ &v0_2'0 <- r0 ] s2)
      | s2 = eq {v0_1'0} {v0_2'0} (fun (_ret:bool) ->  [ &_17 <- _ret ] s3)
      | s3 = bb12 ]
    
    | bb12 = any [ br0 -> {_17 = false} (! bb14) | br1 -> {_17} (! bb13) ] 
    | bb13 = s0 [ s0 =  [ &_0 <- [%#smixed] true ] s1 | s1 = bb15 ] 
    | bb14 = s0 [ s0 =  [ &_0 <- [%#smixed] false ] s1 | s1 = bb15 ] 
    | bb15 = bb16
    | bb2 = any [ br0 (x0:t_A)-> {_4._p1 = C_A x0} (! bb3) | br1 (x0:t_B)-> {_4._p1 = C_B x0} (! bb1) ] 
    | bb1 = s0 [ s0 =  [ &_0 <- [%#smixed] false ] s1 | s1 = bb16 ] 
    | bb3 = bb7
    | bb7 = s0
      [ s0 = v_A {_4._p0} (fun (r0:t_A) ->  [ &v0_1 <- r0 ] s1)
      | s1 = v_A {_4._p1} (fun (r0:t_A) ->  [ &v0_2 <- r0 ] s2)
      | s2 = eq'0 {v0_1} {v0_2} (fun (_ret:bool) ->  [ &_12 <- _ret ] s3)
      | s3 = bb8 ]
    
    | bb8 = any [ br0 -> {_12 = false} (! bb10) | br1 -> {_12} (! bb9) ] 
    | bb9 = s0 [ s0 =  [ &_0 <- [%#smixed] true ] s1 | s1 = bb11 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- [%#smixed] false ] s1 | s1 = bb11 ] 
    | bb11 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self'0 : t_Sum = self
    | & rhs'0 : t_Sum = rhs
    | & _4 : tuple = Any.any_l ()
    | & v0_1 : t_A = Any.any_l ()
    | & v0_2 : t_A = Any.any_l ()
    | & _12 : bool = Any.any_l ()
    | & v0_1'0 : t_B = Any.any_l ()
    | & v0_2'0 : t_B = Any.any_l ()
    | & _17 : bool = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:eq ensures] [%#smixed] result = (deep_model'4 self = deep_model'4 rhs)}
      (! return' {result}) ]

end
module M_mixed__qyi8044263102292640215__resolve_coherence [#"mixed.rs" 49 9 49 16] (* <Product2<'a, A> as creusot_contracts::Resolve> *)
  let%span smixed = "mixed.rs" 49 9 49 16
  let%span smixed'0 = "mixed.rs" 51 4 53 19
  let%span svec = "../../../../creusot-contracts/src/std/vec.rs" 46 20 46 83
  let%span svec'0 = "../../../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sresolve = "../../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sindex = "../../../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use seq.Seq
  use creusot.int.UInt32
  
  type t_A
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Product2  =
    { t_Product2__a: MutBorrow.t t_A; t_Product2__b: bool; t_Product2__c: t_Vec }
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view (self : t_Vec) : Seq.seq UInt32.t
  
  axiom view_spec : forall self : t_Vec . [%#svec'0] Seq.length (view self) <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate resolve (_0 : UInt32.t) =
    true
  
  function index_logic [@inline:trivial] (self : t_Vec) (ix : int) : UInt32.t =
    [%#sindex] Seq.get (view self) ix
  
  predicate resolve'0 (self : t_Vec) =
    [%#svec] forall i : int . 0 <= i /\ i < Seq.length (view self)  -> resolve (index_logic self i)
  
  predicate resolve'1 (_0 : t_Vec) =
    resolve'0 _0
  
  predicate resolve'2 (self : MutBorrow.t t_A) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'3 (_0 : MutBorrow.t t_A) =
    resolve'2 _0
  
  predicate structural_resolve (_0 : t_Product2) =
    match _0 with
      | {t_Product2__a = x0 ; t_Product2__b = x1 ; t_Product2__c = x2} -> resolve'1 x2 /\ resolve'3 x0
      end
  
  predicate resolve'4 (_0 : bool) =
    true
  
  predicate resolve'5 [#"mixed.rs" 49 9 49 16] (self : t_Product2) =
    [%#smixed'0] resolve'3 self.t_Product2__a /\ resolve'4 self.t_Product2__b /\ resolve'1 self.t_Product2__c
  
  constant self  : t_Product2
  
  function resolve_coherence [#"mixed.rs" 49 9 49 16] (self'0 : t_Product2) : ()
  
  goal vc_resolve_coherence : ([%#smixed] structural_resolve self)  -> ([%#smixed] resolve'5 self)
end
module M_mixed__qyi2899991615344599026__resolve_coherence [#"mixed.rs" 56 9 56 16] (* <Sum2<A, B> as creusot_contracts::Resolve> *)
  let%span smixed = "mixed.rs" 56 9 56 16
  
  type t_A
  
  type t_B
  
  type t_Sum2  =
    | C_X t_A
    | C_Y bool t_B
  
  predicate resolve (_0 : t_A)
  
  predicate resolve'0 (_0 : t_B)
  
  predicate structural_resolve (_0 : t_Sum2) =
    match _0 with
      | C_X x0 -> resolve x0
      | C_Y x0 x1 -> resolve'0 x1
      end
  
  predicate resolve'1 (_0 : bool) =
    true
  
  predicate resolve'2 [#"mixed.rs" 56 9 56 16] (self : t_Sum2) =
    [%#smixed] match self with
      | C_X v0_1 -> resolve v0_1
      | C_Y a_1 x_1 -> resolve'1 a_1 /\ resolve'0 x_1
      end
  
  constant self  : t_Sum2
  
  function resolve_coherence [#"mixed.rs" 56 9 56 16] (self'0 : t_Sum2) : ()
  
  goal vc_resolve_coherence : ([%#smixed] structural_resolve self)  -> ([%#smixed] resolve'2 self)
end
module M_mixed__qyi2592445413368279263__clone__refines [#"mixed.rs" 8 9 8 14] (* <Product<A, B> as creusot_contracts::Clone> *)
  let%span smixed = "mixed.rs" 8 9 8 14
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  type t_A
  
  type t_B
  
  type t_Product  =
    { t_Product__a: t_A; t_Product__b: t_B }
  
  predicate inv (_0 : t_A)
  
  predicate inv'0 (_0 : t_B)
  
  predicate inv'1 (_0 : t_Product)
  
  axiom inv_axiom [@rewrite] : forall x : t_Product [inv'1 x] . inv'1 x
  = match x with
    | {t_Product__a = a ; t_Product__b = b} -> inv a /\ inv'0 b
    end
  
  predicate invariant' (self : t_Product) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_Product)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Product [inv'2 x] . inv'2 x = invariant' x
  
  goal refines : [%#smixed] forall self_ : t_Product . inv'2 self_
   -> inv'2 self_ /\ (forall result : t_Product . result = self_ /\ inv'1 result  -> result = self_ /\ inv'1 result)
end
module M_mixed__qyi1267749258272586863__clone__refines [#"mixed.rs" 28 9 28 14] (* <Sum<A, B> as creusot_contracts::Clone> *)
  let%span smixed = "mixed.rs" 28 9 28 14
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  type t_A
  
  type t_B
  
  type t_Sum  =
    | C_A t_A
    | C_B t_B
  
  predicate inv (_0 : t_A)
  
  predicate inv'0 (_0 : t_B)
  
  predicate inv'1 (_0 : t_Sum)
  
  axiom inv_axiom [@rewrite] : forall x : t_Sum [inv'1 x] . inv'1 x
  = match x with
    | C_A a_0 -> inv a_0
    | C_B a_0 -> inv'0 a_0
    end
  
  predicate invariant' (self : t_Sum) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_Sum)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sum [inv'2 x] . inv'2 x = invariant' x
  
  goal refines : [%#smixed] forall self_ : t_Sum . inv'2 self_
   -> inv'2 self_ /\ (forall result : t_Sum . result = self_ /\ inv'1 result  -> result = self_ /\ inv'1 result)
end
module M_mixed__qyi15378480724732772077__eq__refines [#"mixed.rs" 8 16 8 25] (* <Product<A, B> as creusot_contracts::PartialEq> *)
  let%span smixed = "mixed.rs" 8 16 8 25
  let%span smixed'0 = "mixed.rs" 24 8 24 66
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span smodel = "../../../../creusot-contracts/src/model.rs" 45 8 45 28
  
  type t_A
  
  type t_B
  
  type t_Product  =
    { t_Product__a: t_A; t_Product__b: t_B }
  
  predicate inv (_0 : t_A)
  
  predicate inv'0 (_0 : t_B)
  
  predicate inv'1 (_0 : t_Product)
  
  axiom inv_axiom [@rewrite] : forall x : t_Product [inv'1 x] . inv'1 x
  = match x with
    | {t_Product__a = a ; t_Product__b = b} -> inv a /\ inv'0 b
    end
  
  predicate invariant' (self : t_Product) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_Product)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Product [inv'2 x] . inv'2 x = invariant' x
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type t_Product'0  =
    { t_Product__a'0: t_DeepModelTy; t_Product__b'0: t_DeepModelTy'0 }
  
  function deep_model (self : t_A) : t_DeepModelTy
  
  function deep_model'0 (self : t_B) : t_DeepModelTy'0
  
  function deep_model'1 [#"mixed.rs" 23 4 23 44] (self : t_Product) : t_Product'0 =
    [%#smixed'0] { t_Product__a'0 = deep_model self.t_Product__a; t_Product__b'0 = deep_model'0 self.t_Product__b }
  
  function deep_model'2 (self : t_Product) : t_Product'0 =
    [%#smodel] deep_model'1 self
  
  goal refines : [%#smixed] forall self_ : t_Product . forall rhs : t_Product . inv'2 rhs /\ inv'2 self_
   -> inv'2 rhs
  /\ inv'2 self_
  /\ (forall result : bool . result = (deep_model'2 self_ = deep_model'2 rhs)
   -> result = (deep_model'2 self_ = deep_model'2 rhs))
end
module M_mixed__qyi16267973469411556781__eq__refines [#"mixed.rs" 28 16 28 25] (* <Sum<A, B> as creusot_contracts::PartialEq> *)
  let%span smixed = "mixed.rs" 28 16 28 25
  let%span smixed'0 = "mixed.rs" 40 8 43 9
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span smodel = "../../../../creusot-contracts/src/model.rs" 45 8 45 28
  
  type t_A
  
  type t_B
  
  type t_Sum  =
    | C_A t_A
    | C_B t_B
  
  predicate inv (_0 : t_A)
  
  predicate inv'0 (_0 : t_B)
  
  predicate inv'1 (_0 : t_Sum)
  
  axiom inv_axiom [@rewrite] : forall x : t_Sum [inv'1 x] . inv'1 x
  = match x with
    | C_A a_0 -> inv a_0
    | C_B a_0 -> inv'0 a_0
    end
  
  predicate invariant' (self : t_Sum) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_Sum)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sum [inv'2 x] . inv'2 x = invariant' x
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type t_Sum'0  =
    | C_A'0 t_DeepModelTy
    | C_B'0 t_DeepModelTy'0
  
  function deep_model (self : t_A) : t_DeepModelTy
  
  function deep_model'0 (self : t_B) : t_DeepModelTy'0
  
  function deep_model'1 [#"mixed.rs" 39 4 39 44] (self : t_Sum) : t_Sum'0 =
    [%#smixed'0] match self with
      | C_A a -> C_A'0 (deep_model a)
      | C_B b -> C_B'0 (deep_model'0 b)
      end
  
  function deep_model'2 (self : t_Sum) : t_Sum'0 =
    [%#smodel] deep_model'1 self
  
  goal refines : [%#smixed] forall self_ : t_Sum . forall rhs : t_Sum . inv'2 rhs /\ inv'2 self_
   -> inv'2 rhs
  /\ inv'2 self_
  /\ (forall result : bool . result = (deep_model'2 self_ = deep_model'2 rhs)
   -> result = (deep_model'2 self_ = deep_model'2 rhs))
end
module M_mixed__qyi8044263102292640215__resolve_coherence__refines [#"mixed.rs" 49 9 49 16] (* <Product2<'a, A> as creusot_contracts::Resolve> *)
  let%span smixed = "mixed.rs" 49 9 49 16
  let%span smixed'0 = "mixed.rs" 51 4 53 19
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sinvariant'0 = "../../../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span svec = "../../../../creusot-contracts/src/std/vec.rs" 46 20 46 83
  let%span svec'0 = "../../../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sresolve = "../../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sindex = "../../../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use seq.Seq
  use creusot.int.UInt32
  
  type t_A
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Product2  =
    { t_Product2__a: MutBorrow.t t_A; t_Product2__b: bool; t_Product2__c: t_Vec }
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view (self : t_Vec) : Seq.seq UInt32.t
  
  axiom view_spec : forall self : t_Vec . [%#svec'0] Seq.length (view self) <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate resolve (_0 : UInt32.t) =
    true
  
  function index_logic [@inline:trivial] (self : t_Vec) (ix : int) : UInt32.t =
    [%#sindex] Seq.get (view self) ix
  
  predicate resolve'0 (self : t_Vec) =
    [%#svec] forall i : int . 0 <= i /\ i < Seq.length (view self)  -> resolve (index_logic self i)
  
  predicate resolve'1 (_0 : t_Vec) =
    resolve'0 _0
  
  predicate resolve'2 (self : MutBorrow.t t_A) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'3 (_0 : MutBorrow.t t_A) =
    resolve'2 _0
  
  predicate structural_resolve (_0 : t_Product2) =
    match _0 with
      | {t_Product2__a = x0 ; t_Product2__b = x1 ; t_Product2__c = x2} -> resolve'1 x2 /\ resolve'3 x0
      end
  
  predicate inv (_0 : t_A)
  
  predicate invariant' (self : MutBorrow.t t_A) =
    [%#sinvariant'0] inv self.current /\ inv self.final
  
  predicate inv'0 (_0 : MutBorrow.t t_A)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_A [inv'0 x] . inv'0 x = invariant' x
  
  predicate inv'1 (_0 : t_Product2)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Product2 [inv'1 x] . inv'1 x
  = match x with
    | {t_Product2__a = a ; t_Product2__b = b ; t_Product2__c = c} -> inv'0 a
    end
  
  predicate invariant''0 (self : t_Product2) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_Product2)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Product2 [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate resolve'4 (_0 : bool) =
    true
  
  predicate resolve'5 [#"mixed.rs" 49 9 49 16] (self : t_Product2) =
    [%#smixed'0] resolve'3 self.t_Product2__a /\ resolve'4 self.t_Product2__b /\ resolve'1 self.t_Product2__c
  
  goal refines : [%#smixed] forall self : t_Product2 . structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result : () . resolve'5 self  -> resolve'5 self)
end
module M_mixed__qyi2899991615344599026__resolve_coherence__refines [#"mixed.rs" 56 9 56 16] (* <Sum2<A, B> as creusot_contracts::Resolve> *)
  let%span smixed = "mixed.rs" 56 9 56 16
  let%span sinvariant = "../../../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  type t_A
  
  type t_B
  
  type t_Sum2  =
    | C_X t_A
    | C_Y bool t_B
  
  predicate resolve (_0 : t_A)
  
  predicate resolve'0 (_0 : t_B)
  
  predicate structural_resolve (_0 : t_Sum2) =
    match _0 with
      | C_X x0 -> resolve x0
      | C_Y x0 x1 -> resolve'0 x1
      end
  
  predicate inv (_0 : t_A)
  
  predicate inv'0 (_0 : t_B)
  
  predicate inv'1 (_0 : t_Sum2)
  
  axiom inv_axiom [@rewrite] : forall x : t_Sum2 [inv'1 x] . inv'1 x
  = match x with
    | C_X a_0 -> inv a_0
    | C_Y a x'0 -> inv'0 x'0
    end
  
  predicate invariant' (self : t_Sum2) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0 : t_Sum2)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sum2 [inv'2 x] . inv'2 x = invariant' x
  
  predicate resolve'1 (_0 : bool) =
    true
  
  predicate resolve'2 [#"mixed.rs" 56 9 56 16] (self : t_Sum2) =
    [%#smixed] match self with
      | C_X v0_1 -> resolve v0_1
      | C_Y a_1 x_1 -> resolve'1 a_1 /\ resolve'0 x_1
      end
  
  goal refines : [%#smixed] forall self : t_Sum2 . structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result : () . resolve'2 self  -> resolve'2 self)
end
