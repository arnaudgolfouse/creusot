module M_sum
  use seq.Seq
  use mach.int.Int
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant seq : Seq.seq int
  
  function sum (seq: Seq.seq int) : int
  
  goal vc_sum: if Seq.length seq = 0 then
      true
    else
      well_founded_relation_Int (Seq.length seq) (Seq.length (Seq.([..]) seq 0 (Seq.length seq - 1)))

end
module M_all_zero
  use seq.Seq
  use mach.int.Int
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant seq : Seq.seq int
  
  predicate all_zero (seq: Seq.seq int)
  
  goal vc_all_zero: if Seq.length seq = 0 then
      true
    else
      if Seq.get seq (Seq.length seq - 1) = 0 then
        well_founded_relation_Int (Seq.length seq) (Seq.length (Seq.([..]) seq 0 (Seq.length seq - 1)))
      else
        true
    

end
module M_stupid
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant i : int
  
  predicate stupid_T (x: t_T) (i: int)
  
  goal vc_stupid_T: if i <= 0 then true else if x = x then well_founded_relation_Int i 0 else true
end
