module M_06_logic_function_contracts__sum [#"06_logic_function_contracts.rs" 9 0 9 32]
  let%span s06_logic_function_contracts = "06_logic_function_contracts.rs" 8 0 8 21
  let%span s06_logic_function_contracts'0 = "06_logic_function_contracts.rs" 11 8 14 9
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use seq.Seq
  use mach.int.Int
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant seq : Seq.seq int
  
  function sum [#"06_logic_function_contracts.rs" 9 0 9 32] (seq'0: Seq.seq int) : int
  
  goal vc_sum: if Seq.length seq = 0 then
      true
    else
      well_founded_relation ([%#s06_logic_function_contracts] Seq.length seq) ([%#s06_logic_function_contracts] Seq.length (Seq.([..]) seq 0 (Seq.length seq
      - 1)))

end
module M_06_logic_function_contracts__all_zero [#"06_logic_function_contracts.rs" 20 0 20 38]
  let%span s06_logic_function_contracts = "06_logic_function_contracts.rs" 19 0 19 21
  let%span s06_logic_function_contracts'0 = "06_logic_function_contracts.rs" 22 8 25 9
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use seq.Seq
  use mach.int.Int
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant seq : Seq.seq int
  
  predicate all_zero [#"06_logic_function_contracts.rs" 20 0 20 38] (seq'0: Seq.seq int)
  
  goal vc_all_zero: if Seq.length seq = 0 then
      true
    else
      if Seq.get seq (Seq.length seq - 1) = 0 then
        well_founded_relation ([%#s06_logic_function_contracts] Seq.length seq) ([%#s06_logic_function_contracts] Seq.length (Seq.([..]) seq 0 (Seq.length seq
        - 1)))
      else
        true
    

end
module M_06_logic_function_contracts__stupid [#"06_logic_function_contracts.rs" 31 0 31 38]
  let%span s06_logic_function_contracts = "06_logic_function_contracts.rs" 30 10 30 11
  let%span s06_logic_function_contracts'0 = "06_logic_function_contracts.rs" 33 8 39 9
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant i : int
  
  predicate stupid [#"06_logic_function_contracts.rs" 31 0 31 38] (x'0: t_T) (i'0: int)
  
  goal vc_stupid: if i <= 0 then
      true
    else
      if x = x then
        well_founded_relation ([%#s06_logic_function_contracts] i) ([%#s06_logic_function_contracts] 0)
      else
        true
    

end
