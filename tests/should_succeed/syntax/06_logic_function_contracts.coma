module M_06_logic_function_contracts__sum
  use seq.Seq
  use mach.int.Int
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant seq : Seq.seq int
  
  function sum (seq'0: Seq.seq int) : int
  
  goal vc_sum: if Seq.length seq = 0 then
      true
    else
      well_founded_relation (Seq.length seq) (Seq.length (Seq.([..]) seq 0 (Seq.length seq - 1)))

end
module M_06_logic_function_contracts__all_zero
  use seq.Seq
  use mach.int.Int
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant seq : Seq.seq int
  
  predicate all_zero (seq'0: Seq.seq int)
  
  goal vc_all_zero: if Seq.length seq = 0 then
      true
    else
      if Seq.get seq (Seq.length seq - 1) = 0 then
        well_founded_relation (Seq.length seq) (Seq.length (Seq.([..]) seq 0 (Seq.length seq - 1)))
      else
        true
    

end
module M_06_logic_function_contracts__stupid
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant i : int
  
  predicate stupid (x'0: t_T) (i'0: int)
  
  goal vc_stupid: if i <= 0 then true else if x = x then well_founded_relation i 0 else true
end
