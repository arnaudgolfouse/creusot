module M_peek_bit_u8
  use creusot.int.UInt64
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_bit_u8 (x: UInt8.t) (left: UInt64.t) (return (x'0: bool)) =
    {[@expl:peek_bit_u8 requires] UInt64.lt left (8: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {(7: UInt64.t)} {left} (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1)
      | s1 = UInt8.shl {(1: UInt8.t)} {UInt64.t'int _5} (fun (_ret: UInt8.t) -> [ &mask <- _ret ] s2)
      | s2 = [ &_7 <- UInt8.bw_and x mask ] s3
      | s3 = [ &_0 <- _7 <> (0: UInt8.t) ] s4
      | s4 = return {_0} ] ]
    [ & _0: bool = Any.any_l ()
    | & x: UInt8.t = x
    | & left: UInt64.t = left
    | & mask: UInt8.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l ()
    | & _7: UInt8.t = Any.any_l () ]) [ return (result: bool) -> (! return {result}) ]
end
module M_peek_bit_array8
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_ref_u8 = None | Some UInt8.t
  
  predicate in_bounds_usize [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt8.t) =
    UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds_usize
  
  predicate has_value_usize [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt8.t) (out: UInt8.t) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value_usize
  
  let rec get_u8 (self_: Slice64.slice UInt8.t) (ix: UInt64.t) (return (x: t_Option_ref_u8)) = any
    [ return (result: t_Option_ref_u8) -> {in_bounds_usize ix (Slice64.view self_)
      -> (exists r: UInt8.t. result = Some r /\ has_value_usize ix (Slice64.view self_) r)}
      {in_bounds_usize ix (Slice64.view self_) \/ result = None}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_ref_u8) (ret (f0: UInt8.t)) = any
    [ good (f0: UInt8.t) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: UInt8.t [Some f0: t_Option_ref_u8]. Some f0 <> input} (! {false} any) ]
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  let rec peek_bit_u8 (x: UInt8.t) (left: UInt64.t) (return (x'0: bool)) =
    {[@expl:peek_bit_u8 requires] UInt64.lt left (8: UInt64.t)}
    any [ return (result: bool) -> (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_bit_array8 (addr: Slice64.slice UInt8.t) (left: UInt64.t) (return (x: bool)) =
    {[@expl:peek_bit_array8 requires] UInt64.t'int left < 8 * Seq.length (Slice64.view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- (8: UInt64.t) = (0: UInt64.t) ] s1 | s1 = {[@expl:division by zero] not _8} s2 | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.div {left} {(8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = get_u8 {addr} {_6} (fun (_ret: t_Option_ref_u8) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = None} (! bb5) | br1 (x0: UInt8.t) -> {_4 = Some x0} (! bb6) ]
    | bb6 = s0
      [ s0 = elim_Some {_4} (fun (r0: UInt8.t) -> [ &v <- r0 ] s1)
      | s1 = [ &_14 <- (8: UInt64.t) = (0: UInt64.t) ] s2
      | s2 = {[@expl:remainder by zero] not _14} s3
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = UInt64.rem {left} {(8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_12 <- _ret ] s1)
      | s1 = peek_bit_u8 {v} {_12} (fun (_ret: bool) -> [ &_0 <- _ret ] s2)
      | s2 = bb11 ]
    | bb5 = any [ br0 -> {false = false} (! bb9) | br1 -> {false} (! bb10) ]
    | bb10 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb11 ]
    | bb11 = return {_0}
    | bb9 = {false} any ]
    [ & _0: bool = Any.any_l ()
    | & addr: Slice64.slice UInt8.t = addr
    | & left: UInt64.t = left
    | & _4: t_Option_ref_u8 = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & v: UInt8.t = Any.any_l ()
    | & _12: UInt64.t = Any.any_l ()
    | & _14: bool = Any.any_l () ]) [ return (result: bool) -> (! return {result}) ]
end
module M_poke_bit_64
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_bit_64 (value: UInt64.t) (left: UInt64.t) (flag: bool) (return (x: UInt64.t)) =
    {[@expl:poke_bit_64 requires] UInt64.lt left (64: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {(63: UInt64.t)} {left} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = UInt64.shl {(1: UInt64.t)} {UInt64.t'int _6} (fun (_ret: UInt64.t) -> [ &mask <- _ret ] s2)
      | s2 = any [ br0 -> {flag = false} (! bb2) | br1 -> {flag} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- UInt64.bw_or value mask ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_14 <- UInt64.bw_not mask ] s1 | s1 = [ &_0 <- UInt64.bw_and value _14 ] s2 | s2 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l ()
    | & value: UInt64.t = value
    | & left: UInt64.t = left
    | & flag: bool = flag
    | & mask: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l () ]) [ return (result: UInt64.t) -> (! return {result}) ]
end
module M_peek
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  let rec len_u8 (self_: Slice64.slice UInt8.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {Seq.length (Slice64.view self_) = UInt64.t'int result} (! return {result}) ]
  
  let rec peek_bit_array8 (addr: Slice64.slice UInt8.t) (left: UInt64.t) (return (x: bool)) =
    {[@expl:peek_bit_array8 requires] UInt64.t'int left < 8 * Seq.length (Slice64.view addr)}
    any [ return (result: bool) -> (! return {result}) ]
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  let rec poke_bit_64 (value: UInt64.t) (left: UInt64.t) (flag: bool) (return (x: UInt64.t)) =
    {[@expl:poke_bit_64 requires] UInt64.lt left (64: UInt64.t)}
    any [ return (result: UInt64.t) -> (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t) (return (x: UInt64.t)) =
    {[@expl:peek requires #0] Seq.length (Slice64.view addr) < 10000000}
    {[@expl:peek requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (Slice64.view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.add {start} {length} (fun (_ret: UInt64.t) -> [ &_10 <- _ret ] s1)
      | s1 = len_u8 {addr} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.mul {(8: UInt64.t)} {_14} (fun (_ret: UInt64.t) -> [ &_13 <- _ret ] s1)
      | s1 = [ &_9 <- UInt64.gt _10 _13 ] s2
      | s2 = any [ br0 -> {_9 = false} (! bb3) | br1 -> {_9} (! bb2) ] ]
    | bb2 = {false} any
    | bb3 = s0 [ s0 = [ &retval <- (0: UInt64.t) ] s1 | s1 = [ &i <- (0: UInt64.t) ] s2 | s2 = bb5 ]
    | bb5 = bb5
      [ bb5 = (! s0
        [ s0 = [ &_21 <- UInt64.lt i length ] s1 | s1 = any [ br0 -> {_21 = false} (! bb9) | br1 -> {_21} (! bb6) ] ])
        [ bb6 = s0
          [ s0 = UInt64.add {start} {i} (fun (_ret: UInt64.t) -> [ &_26 <- _ret ] s1)
          | s1 = peek_bit_array8 {addr} {_26} (fun (_ret: bool) -> [ &flag <- _ret ] s2)
          | s2 = bb7 ]
        | bb7 = s0
          [ s0 = UInt64.sub {length} {i} (fun (_ret: UInt64.t) -> [ &_32 <- _ret ] s1)
          | s1 = UInt64.sub {(64: UInt64.t)} {_32} (fun (_ret: UInt64.t) -> [ &_31 <- _ret ] s2)
          | s2 = poke_bit_64 {retval} {_31} {flag} (fun (_ret: UInt64.t) -> [ &_29 <- _ret ] s3)
          | s3 = bb8 ]
        | bb8 = s0
          [ s0 = [ &retval <- _29 ] s1
          | s1 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s2)
          | s2 = bb5 ] ] ]
    | bb9 = s0 [ s0 = [ &_0 <- retval ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & start: UInt64.t = start
    | & length: UInt64.t = length
    | & addr: Slice64.slice UInt8.t = addr
    | & _9: bool = Any.any_l ()
    | & _10: UInt64.t = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & retval: UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & flag: bool = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & _29: UInt64.t = Any.any_l ()
    | & _31: UInt64.t = Any.any_l ()
    | & _32: UInt64.t = Any.any_l () ]) [ return (result: UInt64.t) -> (! return {result}) ]
end
module M_peek_64bit
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_64bit (value: UInt64.t) (left: UInt64.t) (return (x: bool)) =
    {[@expl:peek_64bit requires] UInt64.lt left (64: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {(63: UInt64.t)} {left} (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1)
      | s1 = UInt64.shl {(1: UInt64.t)} {UInt64.t'int _5} (fun (_ret: UInt64.t) -> [ &mask <- _ret ] s2)
      | s2 = [ &_7 <- UInt64.bw_and value mask ] s3
      | s3 = [ &_0 <- _7 <> (0: UInt64.t) ] s4
      | s4 = return {_0} ] ]
    [ & _0: bool = Any.any_l ()
    | & value: UInt64.t = value
    | & left: UInt64.t = left
    | & mask: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l ()
    | & _7: UInt64.t = Any.any_l () ]) [ return (result: bool) -> (! return {result}) ]
end
module M_poke_8bit
  use creusot.int.UInt64
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_8bit (byte: UInt8.t) (left: UInt64.t) (flag: bool) (return (x: UInt8.t)) =
    {[@expl:poke_8bit requires] UInt64.lt left (8: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {(7: UInt64.t)} {left} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = UInt8.shl {(1: UInt8.t)} {UInt64.t'int _6} (fun (_ret: UInt8.t) -> [ &mask <- _ret ] s2)
      | s2 = any [ br0 -> {flag = false} (! bb2) | br1 -> {flag} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- UInt8.bw_or byte mask ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_14 <- UInt8.bw_not mask ] s1 | s1 = [ &_0 <- UInt8.bw_and byte _14 ] s2 | s2 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: UInt8.t = Any.any_l ()
    | & byte: UInt8.t = byte
    | & left: UInt64.t = left
    | & flag: bool = flag
    | & mask: UInt8.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _14: UInt8.t = Any.any_l () ]) [ return (result: UInt8.t) -> (! return {result}) ]
end
module M_poke_8bit_array
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use seq.Seq
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  let rec poke_8bit (byte: UInt8.t) (left: UInt64.t) (flag: bool) (return (x: UInt8.t)) =
    {[@expl:poke_8bit requires] UInt64.lt left (8: UInt64.t)}
    any [ return (result: UInt8.t) -> (! return {result}) ]
  
  predicate resolve_ref_slice_u8 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice UInt8.t)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_slice_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_8bit_array (addr: MutBorrow.t (Slice64.slice UInt8.t)) (left: UInt64.t) (flag: bool) (return (x: ())) =
    {[@expl:poke_8bit_array requires] UInt64.t'int left < 8 * Seq.length (Slice64.view addr.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- (8: UInt64.t) = (0: UInt64.t) ] s1 | s1 = {[@expl:division by zero] not _8} s2 | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.div {left} {(8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s1)
      | s1 = [ &_11 <- (8: UInt64.t) = (0: UInt64.t) ] s2
      | s2 = {[@expl:remainder by zero] not _11} s3
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.rem {left} {(8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &k <- _ret ] s1)
      | s1 = [ &_14 <- i ] s2
      | s2 = Opaque.fresh_ptr
          (fun (_ptr: Opaque.ptr) -> -{Slice64.slice_ptr_len _ptr = Slice64.length addr.current}- [ &_15 <- _ptr ] s3)
      | s3 = [ &_16 <- Slice64.slice_ptr_len _15 ] s4
      | s4 = [ &_17 <- UInt64.lt _14 _16 ] s5
      | s5 = {[@expl:index in bounds] _17} s6
      | s6 = bb3 ]
    | bb3 = s0
      [ s0 = Slice64.get <UInt8.t> {addr.current} {_14}
          (fun (r: UInt8.t) -> poke_8bit {r} {k} {flag} (fun (_ret: UInt8.t) -> [ &_12 <- _ret ] s1))
      | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_20 <- i ] s1
      | s1 = Opaque.fresh_ptr
          (fun (_ptr: Opaque.ptr) -> -{Slice64.slice_ptr_len _ptr = Slice64.length addr.current}- [ &_21 <- _ptr ] s2)
      | s2 = [ &_22 <- Slice64.slice_ptr_len _21 ] s3
      | s3 = [ &_23 <- UInt64.lt _20 _22 ] s4
      | s4 = {[@expl:index in bounds] _23} s5
      | s5 = bb5 ]
    | bb5 = s0
      [ s0 = Slice64.set <UInt8.t> {addr.current} {_20} {_12}
          (fun (r: Slice64.slice UInt8.t) -> [ &addr <- { addr with current = r } ] s1)
      | s1 = -{resolve_ref_slice_u8 addr}- s2
      | s2 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & addr: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & left: UInt64.t = left
    | & flag: bool = flag
    | & i: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & k: UInt64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: UInt8.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _15: Opaque.ptr = Any.any_l ()
    | & _16: UInt64.t = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _20: UInt64.t = Any.any_l ()
    | & _21: Opaque.ptr = Any.any_l ()
    | & _22: UInt64.t = Any.any_l ()
    | & _23: bool = Any.any_l () ])
    [ return (result: ()) -> {[@expl:poke_8bit_array ensures] Seq.length (Slice64.view addr.final)
      = Seq.length (Slice64.view addr.current)}
      (! return {result}) ]
end
module M_poke
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use creusot.int.UInt64
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  let rec len_u8 (self_: Slice64.slice UInt8.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {Seq.length (Slice64.view self_) = UInt64.t'int result} (! return {result}) ]
  
  predicate resolve_ref_slice_u8 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice UInt8.t)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_slice_u8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  let rec peek_64bit (value: UInt64.t) (left: UInt64.t) (return (x: bool)) =
    {[@expl:peek_64bit requires] UInt64.lt left (64: UInt64.t)}
    any [ return (result: bool) -> (! return {result}) ]
  
  let rec poke_8bit_array (addr: MutBorrow.t (Slice64.slice UInt8.t)) (left: UInt64.t) (flag: bool) (return (x: ())) =
    {[@expl:poke_8bit_array requires] UInt64.t'int left < 8 * Seq.length (Slice64.view addr.current)}
    any
    [ return (result: ()) -> {Seq.length (Slice64.view addr.final) = Seq.length (Slice64.view addr.current)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t)
    (return (x: Int8.t)) = {[@expl:poke requires #0] Seq.length (Slice64.view addr.current) < 10000000}
    {[@expl:poke requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (Slice64.view addr.current)}
    (! bb0
    [ bb0 = s0 [ s0 = len_u8 {addr.current} (fun (_ret: UInt64.t) -> [ &ghost_len <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.add {start} {length} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s1)
      | s1 = len_u8 {addr.current} (fun (_ret: UInt64.t) -> [ &_18 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.mul {(8: UInt64.t)} {_18} (fun (_ret: UInt64.t) -> [ &_17 <- _ret ] s1)
      | s1 = [ &_13 <- UInt64.gt _14 _17 ] s2
      | s2 = any [ br0 -> {_13 = false} (! bb4) | br1 -> {_13} (! bb3) ] ]
    | bb3 = s0 [ s0 = -{resolve_ref_slice_u8 addr}- s1 | s1 = [ &_0 <- (-1: Int8.t) ] s2 | s2 = bb16 ]
    | bb4 = s0
      [ s0 = [ &_22 <- UInt64.lt length (64: UInt64.t) ] s1
      | s1 = any [ br0 -> {_22 = false} (! bb9) | br1 -> {_22} (! bb5) ] ]
    | bb5 = s0
      [ s0 = UInt64.shl {(1: UInt64.t)} {UInt64.t'int length} (fun (_ret: UInt64.t) -> [ &_26 <- _ret ] s1)
      | s1 = [ &_24 <- UInt64.ge value _26 ] s2
      | s2 = any [ br0 -> {_24 = false} (! bb9) | br1 -> {_24} (! bb7) ] ]
    | bb7 = s0 [ s0 = -{resolve_ref_slice_u8 addr}- s1 | s1 = [ &_0 <- (-2: Int8.t) ] s2 | s2 = bb16 ]
    | bb9 = s0
      [ s0 = UInt64.sub {(64: UInt64.t)} {length} (fun (_ret: UInt64.t) -> [ &lstart <- _ret ] s1)
      | s1 = [ &i <- (0: UInt64.t) ] s2
      | s2 = [ &old_10_0 <- addr ] s3
      | s3 = bb10 ]
    | bb10 = bb10
      [ bb10 = {[@expl:mut invariant] old_10_0.final = addr.final}
        {[@expl:loop invariant #0] UInt64.le i length}
        {[@expl:loop invariant #1] Seq.length (Slice64.view addr.current) = UInt64.t'int ghost_len}
        (! s0)
        [ s0 = bb11 ]
        [ bb11 = s0
          [ s0 = [ &_37 <- UInt64.lt i length ] s1
          | s1 = any [ br0 -> {_37 = false} (! bb15) | br1 -> {_37} (! bb12) ] ]
        | bb12 = s0
          [ s0 = {[@expl:assertion] UInt64.t'int i < UInt64.t'int length} s1
          | s1 = UInt64.add {lstart} {i} (fun (_ret: UInt64.t) -> [ &_44 <- _ret ] s2)
          | s2 = peek_64bit {value} {_44} (fun (_ret: bool) -> [ &flag <- _ret ] s3)
          | s3 = bb13 ]
        | bb13 = s0
          [ s0 = UInt64.add {start} {i} (fun (_ret: UInt64.t) -> [ &_49 <- _ret ] s1)
          | s1 = MutBorrow.borrow_mut <Slice64.slice UInt8.t> {addr.current}
              (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
                [ &_48 <- _ret ] [ &addr <- { addr with current = _ret.final } ] s2)
          | s2 = poke_8bit_array {_48} {_49} {flag} (fun (_ret: ()) -> [ &_47 <- _ret ] s3)
          | s3 = bb14 ]
        | bb14 = s0
          [ s0 = {[@expl:assertion] Seq.length (Slice64.view addr.current) = UInt64.t'int ghost_len} s1
          | s1 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s2)
          | s2 = bb10 ] ] ]
    | bb15 = s0 [ s0 = -{resolve_ref_slice_u8 addr}- s1 | s1 = [ &_0 <- (0: Int8.t) ] s2 | s2 = bb16 ]
    | bb16 = return {_0} ]
    [ & _0: Int8.t = Any.any_l ()
    | & start: UInt64.t = start
    | & length: UInt64.t = length
    | & addr: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value: UInt64.t = value
    | & ghost_len: UInt64.t = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _17: UInt64.t = Any.any_l ()
    | & _18: UInt64.t = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & lstart: UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & flag: bool = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _47: () = Any.any_l ()
    | & _48: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l ()
    | & _49: UInt64.t = Any.any_l ()
    | & old_10_0: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l () ])
    [ return (result: Int8.t) -> {[@expl:poke ensures] Seq.length (Slice64.view addr.final)
      = Seq.length (Slice64.view addr.current)}
      (! return {result}) ]
end
module M_peekthenpoke
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.int.Int8
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  let rec peek (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t) (return (x: UInt64.t)) =
    {[@expl:peek requires #0] Seq.length (Slice64.view addr) < 10000000}
    {[@expl:peek requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (Slice64.view addr)}
    any [ return (result: UInt64.t) -> (! return {result}) ]
  
  let rec poke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t)
    (return (x: Int8.t)) = {[@expl:poke requires #0] Seq.length (Slice64.view addr.current) < 10000000}
    {[@expl:poke requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (Slice64.view addr.current)}
    any
    [ return (result: Int8.t) -> {Seq.length (Slice64.view addr.final) = Seq.length (Slice64.view addr.current)}
      (! return {result}) ]
  
  predicate resolve_ref_slice_u8 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice UInt8.t)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_slice_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peekthenpoke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t))
    (return (x: Int8.t)) = {[@expl:peekthenpoke requires #0] Seq.length (Slice64.view addr.current) < 10000000}
    {[@expl:peekthenpoke requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:peekthenpoke requires #2] UInt64.t'int start + UInt64.t'int length
    <= 8 * Seq.length (Slice64.view addr.current)}
    (! bb0
    [ bb0 = s0 [ s0 = peek {start} {length} {addr.current} (fun (_ret: UInt64.t) -> [ &value <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt8.t> {addr.current} {MutBorrow.get_id addr}
          (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
            [ &_14 <- _ret ] [ &addr <- { addr with current = _ret.final } ] s1)
      | s1 = poke {start} {length} {_14} {value} (fun (_ret: Int8.t) -> [ &res <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = -{resolve_ref_slice_u8 addr}- s1 | s1 = [ &_0 <- res ] s2 | s2 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l ()
    | & start: UInt64.t = start
    | & length: UInt64.t = length
    | & addr: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value: UInt64.t = Any.any_l ()
    | & res: Int8.t = Any.any_l ()
    | & _14: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l () ]) [ return (result: Int8.t) -> (! return {result}) ]
end
module M_pokethenpeek
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use creusot.int.UInt64
  use creusot.int.Int8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  let rec poke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t)
    (return (x: Int8.t)) = {[@expl:poke requires #0] Seq.length (Slice64.view addr.current) < 10000000}
    {[@expl:poke requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (Slice64.view addr.current)}
    any
    [ return (result: Int8.t) -> {Seq.length (Slice64.view addr.final) = Seq.length (Slice64.view addr.current)}
      (! return {result}) ]
  
  predicate resolve_ref_slice_u8 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice UInt8.t)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_slice_u8
  
  let rec peek (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t) (return (x: UInt64.t)) =
    {[@expl:peek requires #0] Seq.length (Slice64.view addr) < 10000000}
    {[@expl:peek requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (Slice64.view addr)}
    any [ return (result: UInt64.t) -> (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec pokethenpeek (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t))
    (value: UInt64.t) (return (x: UInt64.t)) = {[@expl:pokethenpeek requires #0] Seq.length (Slice64.view addr.current)
    < 10000000}
    {[@expl:pokethenpeek requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:pokethenpeek requires #2] UInt64.t'int start + UInt64.t'int length
    <= 8 * Seq.length (Slice64.view addr.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt8.t> {addr.current} {MutBorrow.get_id addr}
          (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
            [ &_11 <- _ret ] [ &addr <- { addr with current = _ret.final } ] s1)
      | s1 = poke {start} {length} {_11} {value} (fun (_ret: Int8.t) -> [ &_res <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = -{resolve_ref_slice_u8 addr}- s1
      | s1 = peek {start} {length} {addr.current} (fun (_ret: UInt64.t) -> [ &peek_result <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- peek_result ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & start: UInt64.t = start
    | & length: UInt64.t = length
    | & addr: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value: UInt64.t = value
    | & _res: Int8.t = Any.any_l ()
    | & _11: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l ()
    | & peek_result: UInt64.t = Any.any_l () ]) [ return (result: UInt64.t) -> (! return {result}) ]
end
