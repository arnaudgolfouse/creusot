module M_bitwalker__peek_bit_u8
  use creusot.int.UInt64
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_bit_u8 (x: UInt8.t) (left: UInt64.t) (return' (x'0: bool)) =
    {[@expl:peek_bit_u8 requires] UInt64.lt left (8: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {(7: UInt64.t)} {left'0} (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1)
      | s1 = UInt8.shl {(1: UInt8.t)} {UInt64.t'int _5} (fun (_ret: UInt8.t) -> [ &mask <- _ret ] s2)
      | s2 = [ &_7 <- UInt8.bw_and x'0 mask ] s3
      | s3 = [ &_0 <- _7 <> (0: UInt8.t) ] s4
      | s4 = return''0 {_0} ] ]
    [ & _0: bool = Any.any_l ()
    | & x'0: UInt8.t = x
    | & left'0: UInt64.t = left
    | & mask: UInt8.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l ()
    | & _7: UInt8.t = Any.any_l () ]) [ return''0 (result: bool) -> (! return' {result}) ]
end
module M_bitwalker__peek_bit_array8
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some UInt8.t
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt8.t) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  function view [@inline:trivial] (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = Slice64.view self
  
  meta "rewrite_def" function view
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt8.t) (out: UInt8.t) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec get (self_: Slice64.slice UInt8.t) (ix: UInt64.t) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {in_bounds ix (view self_)
      -> (exists r: UInt8.t. result = C_Some r /\ has_value ix (view self_) r)}
      {in_bounds ix (view self_) \/ result = C_None}
      (! return' {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: UInt8.t)) = any
    [ good (field_0: UInt8.t) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: UInt8.t [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec peek_bit_u8 (x: UInt8.t) (left: UInt64.t) (return' (x'0: bool)) =
    {[@expl:peek_bit_u8 requires] UInt64.lt left (8: UInt64.t)}
    any [ return''0 (result: bool) -> (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_bit_array8 (addr: Slice64.slice UInt8.t) (left: UInt64.t) (return' (x: bool)) =
    {[@expl:peek_bit_array8 requires] UInt64.t'int left < 8 * Seq.length (view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- (8: UInt64.t) = (0: UInt64.t) ] s1 | s1 = {[@expl:division by zero] not _8} s2 | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.div {left'0} {(8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = get {addr'0} {_6} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = C_None} (! bb5) | br1 (x0: UInt8.t) -> {_4 = C_Some x0} (! bb6) ]
    | bb6 = s0
      [ s0 = v_Some {_4} (fun (r0: UInt8.t) -> [ &v <- r0 ] s1)
      | s1 = [ &_14 <- (8: UInt64.t) = (0: UInt64.t) ] s2
      | s2 = {[@expl:remainder by zero] not _14} s3
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = UInt64.rem {left'0} {(8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_12 <- _ret ] s1)
      | s1 = peek_bit_u8 {v} {_12} (fun (_ret: bool) -> [ &_0 <- _ret ] s2)
      | s2 = bb11 ]
    | bb5 = any [ br0 -> {false = false} (! bb9) | br1 -> {false} (! bb10) ]
    | bb10 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb11 ]
    | bb11 = return''0 {_0}
    | bb9 = {false} any ]
    [ & _0: bool = Any.any_l ()
    | & addr'0: Slice64.slice UInt8.t = addr
    | & left'0: UInt64.t = left
    | & _4: t_Option = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & v: UInt8.t = Any.any_l ()
    | & _12: UInt64.t = Any.any_l ()
    | & _14: bool = Any.any_l () ]) [ return''0 (result: bool) -> (! return' {result}) ]
end
module M_bitwalker__poke_bit_64
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_bit_64 (value: UInt64.t) (left: UInt64.t) (flag: bool) (return' (x: UInt64.t)) =
    {[@expl:poke_bit_64 requires] UInt64.lt left (64: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {(63: UInt64.t)} {left'0} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = UInt64.shl {(1: UInt64.t)} {UInt64.t'int _6} (fun (_ret: UInt64.t) -> [ &mask <- _ret ] s2)
      | s2 = any [ br0 -> {flag'0 = false} (! bb2) | br1 -> {flag'0} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- UInt64.bw_or value'0 mask ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_14 <- UInt64.bw_not mask ] s1 | s1 = [ &_0 <- UInt64.bw_and value'0 _14 ] s2 | s2 = bb3 ]
    | bb3 = return''0 {_0} ]
    [ & _0: UInt64.t = Any.any_l ()
    | & value'0: UInt64.t = value
    | & left'0: UInt64.t = left
    | & flag'0: bool = flag
    | & mask: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l () ]) [ return''0 (result: UInt64.t) -> (! return' {result}) ]
end
module M_bitwalker__peek
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  function view [@inline:trivial] (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = Slice64.view self
  
  meta "rewrite_def" function view
  
  let rec len (self_: Slice64.slice UInt8.t) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {Seq.length (view self_) = UInt64.t'int result} (! return' {result}) ]
  
  let rec peek_bit_array8 (addr: Slice64.slice UInt8.t) (left: UInt64.t) (return' (x: bool)) =
    {[@expl:peek_bit_array8 requires] UInt64.t'int left < 8 * Seq.length (view addr)}
    any [ return''0 (result: bool) -> (! return' {result}) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec poke_bit_64 (value: UInt64.t) (left: UInt64.t) (flag: bool) (return' (x: UInt64.t)) =
    {[@expl:poke_bit_64 requires] UInt64.lt left (64: UInt64.t)}
    any [ return''0 (result: UInt64.t) -> (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t) (return' (x: UInt64.t)) =
    {[@expl:peek requires #0] Seq.length (view addr) < 10000000}
    {[@expl:peek requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.add {start'0} {length'0} (fun (_ret: UInt64.t) -> [ &_10 <- _ret ] s1)
      | s1 = len {addr'0} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.mul {(8: UInt64.t)} {_14} (fun (_ret: UInt64.t) -> [ &_13 <- _ret ] s1)
      | s1 = [ &_9 <- UInt64.gt _10 _13 ] s2
      | s2 = any [ br0 -> {_9 = false} (! bb3) | br1 -> {_9} (! bb2) ] ]
    | bb2 = {false} any
    | bb3 = s0 [ s0 = [ &retval <- (0: UInt64.t) ] s1 | s1 = [ &i <- (0: UInt64.t) ] s2 | s2 = bb5 ]
    | bb5 = bb5'0
      [ bb5'0 = (! s0
        [ s0 = [ &_21 <- UInt64.lt i length'0 ] s1 | s1 = any [ br0 -> {_21 = false} (! bb9) | br1 -> {_21} (! bb6) ] ])
        [ bb6 = s0
          [ s0 = UInt64.add {start'0} {i} (fun (_ret: UInt64.t) -> [ &_26 <- _ret ] s1)
          | s1 = peek_bit_array8 {addr'0} {_26} (fun (_ret: bool) -> [ &flag <- _ret ] s2)
          | s2 = bb7 ]
        | bb7 = s0
          [ s0 = UInt64.sub {length'0} {i} (fun (_ret: UInt64.t) -> [ &_32 <- _ret ] s1)
          | s1 = UInt64.sub {(64: UInt64.t)} {_32} (fun (_ret: UInt64.t) -> [ &_31 <- _ret ] s2)
          | s2 = poke_bit_64 {retval} {_31} {flag} (fun (_ret: UInt64.t) -> [ &_29 <- _ret ] s3)
          | s3 = bb8 ]
        | bb8 = s0
          [ s0 = [ &retval <- _29 ] s1
          | s1 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s2)
          | s2 = bb5'0 ] ] ]
    | bb9 = s0 [ s0 = [ &_0 <- retval ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & start'0: UInt64.t = start
    | & length'0: UInt64.t = length
    | & addr'0: Slice64.slice UInt8.t = addr
    | & _9: bool = Any.any_l ()
    | & _10: UInt64.t = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & retval: UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & flag: bool = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & _29: UInt64.t = Any.any_l ()
    | & _31: UInt64.t = Any.any_l ()
    | & _32: UInt64.t = Any.any_l () ]) [ return''0 (result: UInt64.t) -> (! return' {result}) ]
end
module M_bitwalker__peek_64bit
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_64bit (value: UInt64.t) (left: UInt64.t) (return' (x: bool)) =
    {[@expl:peek_64bit requires] UInt64.lt left (64: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {(63: UInt64.t)} {left'0} (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1)
      | s1 = UInt64.shl {(1: UInt64.t)} {UInt64.t'int _5} (fun (_ret: UInt64.t) -> [ &mask <- _ret ] s2)
      | s2 = [ &_7 <- UInt64.bw_and value'0 mask ] s3
      | s3 = [ &_0 <- _7 <> (0: UInt64.t) ] s4
      | s4 = return''0 {_0} ] ]
    [ & _0: bool = Any.any_l ()
    | & value'0: UInt64.t = value
    | & left'0: UInt64.t = left
    | & mask: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l ()
    | & _7: UInt64.t = Any.any_l () ]) [ return''0 (result: bool) -> (! return' {result}) ]
end
module M_bitwalker__poke_8bit
  use creusot.int.UInt64
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_8bit (byte: UInt8.t) (left: UInt64.t) (flag: bool) (return' (x: UInt8.t)) =
    {[@expl:poke_8bit requires] UInt64.lt left (8: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {(7: UInt64.t)} {left'0} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = UInt8.shl {(1: UInt8.t)} {UInt64.t'int _6} (fun (_ret: UInt8.t) -> [ &mask <- _ret ] s2)
      | s2 = any [ br0 -> {flag'0 = false} (! bb2) | br1 -> {flag'0} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- UInt8.bw_or byte'0 mask ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_14 <- UInt8.bw_not mask ] s1 | s1 = [ &_0 <- UInt8.bw_and byte'0 _14 ] s2 | s2 = bb3 ]
    | bb3 = return''0 {_0} ]
    [ & _0: UInt8.t = Any.any_l ()
    | & byte'0: UInt8.t = byte
    | & left'0: UInt64.t = left
    | & flag'0: bool = flag
    | & mask: UInt8.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _14: UInt8.t = Any.any_l () ]) [ return''0 (result: UInt8.t) -> (! return' {result}) ]
end
module M_bitwalker__poke_8bit_array
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use seq.Seq
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec poke_8bit (byte: UInt8.t) (left: UInt64.t) (flag: bool) (return' (x: UInt8.t)) =
    {[@expl:poke_8bit requires] UInt64.lt left (8: UInt64.t)}
    any [ return''0 (result: UInt8.t) -> (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (Slice64.slice UInt8.t)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  function view [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t =
    Slice64.view self.current
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_8bit_array (addr: MutBorrow.t (Slice64.slice UInt8.t)) (left: UInt64.t) (flag: bool) (return' (x: ())) =
    {[@expl:poke_8bit_array requires] UInt64.t'int left < 8 * Seq.length (view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- (8: UInt64.t) = (0: UInt64.t) ] s1 | s1 = {[@expl:division by zero] not _8} s2 | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.div {left'0} {(8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s1)
      | s1 = [ &_11 <- (8: UInt64.t) = (0: UInt64.t) ] s2
      | s2 = {[@expl:remainder by zero] not _11} s3
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.rem {left'0} {(8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &k <- _ret ] s1)
      | s1 = [ &_14 <- i ] s2
      | s2 = Opaque.fresh_ptr
          (fun (_ptr: Opaque.ptr) -> -{Slice64.slice_ptr_len _ptr = Slice64.length addr'0.current}- [ &_15 <- _ptr ] s3)
      | s3 = [ &_16 <- Slice64.slice_ptr_len _15 ] s4
      | s4 = [ &_17 <- UInt64.lt _14 _16 ] s5
      | s5 = {[@expl:index in bounds] _17} s6
      | s6 = bb3 ]
    | bb3 = s0
      [ s0 = Slice64.get <UInt8.t> {addr'0.current} {_14}
          (fun (r: UInt8.t) -> poke_8bit {r} {k} {flag'0} (fun (_ret: UInt8.t) -> [ &_12 <- _ret ] s1))
      | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_20 <- i ] s1
      | s1 = Opaque.fresh_ptr
          (fun (_ptr: Opaque.ptr) -> -{Slice64.slice_ptr_len _ptr = Slice64.length addr'0.current}- [ &_21 <- _ptr ] s2)
      | s2 = [ &_22 <- Slice64.slice_ptr_len _21 ] s3
      | s3 = [ &_23 <- UInt64.lt _20 _22 ] s4
      | s4 = {[@expl:index in bounds] _23} s5
      | s5 = bb5 ]
    | bb5 = s0
      [ s0 = Slice64.set <UInt8.t> {addr'0.current} {_20} {_12}
          (fun (r: Slice64.slice UInt8.t) -> [ &addr'0 <- { addr'0 with current = r } ] s1)
      | s1 = -{resolve'0 addr'0}- s2
      | s2 = return''0 {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & addr'0: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & left'0: UInt64.t = left
    | & flag'0: bool = flag
    | & i: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & k: UInt64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: UInt8.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _15: Opaque.ptr = Any.any_l ()
    | & _16: UInt64.t = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _20: UInt64.t = Any.any_l ()
    | & _21: Opaque.ptr = Any.any_l ()
    | & _22: UInt64.t = Any.any_l ()
    | & _23: bool = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:poke_8bit_array ensures] Seq.length (Slice64.view addr.final)
      = Seq.length (view addr)}
      (! return' {result}) ]
end
module M_bitwalker__poke
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use creusot.int.UInt64
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  function view [@inline:trivial] (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = Slice64.view self
  
  meta "rewrite_def" function view
  
  let rec len (self_: Slice64.slice UInt8.t) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {Seq.length (view self_) = UInt64.t'int result} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (Slice64.slice UInt8.t)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  function view'0 [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t =
    Slice64.view self.current
  
  meta "rewrite_def" function view'0
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec peek_64bit (value: UInt64.t) (left: UInt64.t) (return' (x: bool)) =
    {[@expl:peek_64bit requires] UInt64.lt left (64: UInt64.t)}
    any [ return''0 (result: bool) -> (! return' {result}) ]
  
  let rec poke_8bit_array (addr: MutBorrow.t (Slice64.slice UInt8.t)) (left: UInt64.t) (flag: bool) (return' (x: ())) =
    {[@expl:poke_8bit_array requires] UInt64.t'int left < 8 * Seq.length (view'0 addr)}
    any
    [ return''0 (result: ()) -> {Seq.length (Slice64.view addr.final) = Seq.length (view'0 addr)} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t)
    (return' (x: Int8.t)) = {[@expl:poke requires #0] Seq.length (view'0 addr) < 10000000}
    {[@expl:poke requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0 [ s0 = len {addr'0.current} (fun (_ret: UInt64.t) -> [ &ghost_len <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.add {start'0} {length'0} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s1)
      | s1 = len {addr'0.current} (fun (_ret: UInt64.t) -> [ &_18 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.mul {(8: UInt64.t)} {_18} (fun (_ret: UInt64.t) -> [ &_17 <- _ret ] s1)
      | s1 = [ &_13 <- UInt64.gt _14 _17 ] s2
      | s2 = any [ br0 -> {_13 = false} (! bb4) | br1 -> {_13} (! bb3) ] ]
    | bb3 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- (-1: Int8.t) ] s2 | s2 = bb16 ]
    | bb4 = s0
      [ s0 = [ &_22 <- UInt64.lt length'0 (64: UInt64.t) ] s1
      | s1 = any [ br0 -> {_22 = false} (! bb9) | br1 -> {_22} (! bb5) ] ]
    | bb5 = s0
      [ s0 = UInt64.shl {(1: UInt64.t)} {UInt64.t'int length'0} (fun (_ret: UInt64.t) -> [ &_26 <- _ret ] s1)
      | s1 = [ &_24 <- UInt64.ge value'0 _26 ] s2
      | s2 = any [ br0 -> {_24 = false} (! bb9) | br1 -> {_24} (! bb7) ] ]
    | bb7 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- (-2: Int8.t) ] s2 | s2 = bb16 ]
    | bb9 = s0
      [ s0 = UInt64.sub {(64: UInt64.t)} {length'0} (fun (_ret: UInt64.t) -> [ &lstart <- _ret ] s1)
      | s1 = [ &i <- (0: UInt64.t) ] s2
      | s2 = [ &old_10_0 <- addr'0 ] s3
      | s3 = bb10 ]
    | bb10 = bb10'0
      [ bb10'0 = {[@expl:mut invariant] old_10_0.final = addr'0.final}
        {[@expl:loop invariant #0] UInt64.le i length'0}
        {[@expl:loop invariant #1] Seq.length (view'0 addr'0) = UInt64.t'int ghost_len}
        (! s0)
        [ s0 = bb11 ]
        [ bb11 = s0
          [ s0 = [ &_37 <- UInt64.lt i length'0 ] s1
          | s1 = any [ br0 -> {_37 = false} (! bb15) | br1 -> {_37} (! bb12) ] ]
        | bb12 = s0
          [ s0 = {[@expl:assertion] UInt64.t'int i < UInt64.t'int length'0} s1
          | s1 = UInt64.add {lstart} {i} (fun (_ret: UInt64.t) -> [ &_44 <- _ret ] s2)
          | s2 = peek_64bit {value'0} {_44} (fun (_ret: bool) -> [ &flag <- _ret ] s3)
          | s3 = bb13 ]
        | bb13 = s0
          [ s0 = UInt64.add {start'0} {i} (fun (_ret: UInt64.t) -> [ &_49 <- _ret ] s1)
          | s1 = MutBorrow.borrow_mut <Slice64.slice UInt8.t> {addr'0.current}
              (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
                [ &_48 <- _ret ] [ &addr'0 <- { addr'0 with current = _ret.final } ] s2)
          | s2 = poke_8bit_array {_48} {_49} {flag} (fun (_ret: ()) -> [ &_47 <- _ret ] s3)
          | s3 = bb14 ]
        | bb14 = s0
          [ s0 = {[@expl:assertion] Seq.length (view'0 addr'0) = UInt64.t'int ghost_len} s1
          | s1 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s2)
          | s2 = bb10'0 ] ] ]
    | bb15 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- (0: Int8.t) ] s2 | s2 = bb16 ]
    | bb16 = return''0 {_0} ]
    [ & _0: Int8.t = Any.any_l ()
    | & start'0: UInt64.t = start
    | & length'0: UInt64.t = length
    | & addr'0: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value'0: UInt64.t = value
    | & ghost_len: UInt64.t = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _17: UInt64.t = Any.any_l ()
    | & _18: UInt64.t = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & lstart: UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & flag: bool = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _47: () = Any.any_l ()
    | & _48: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l ()
    | & _49: UInt64.t = Any.any_l ()
    | & old_10_0: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l () ])
    [ return''0 (result: Int8.t) -> {[@expl:poke ensures] Seq.length (Slice64.view addr.final)
      = Seq.length (view'0 addr)}
      (! return' {result}) ]
end
module M_bitwalker__peekthenpoke
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.int.Int8
  use creusot.prelude.Any
  
  function view [@inline:trivial] (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = Slice64.view self
  
  meta "rewrite_def" function view
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec peek (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t) (return' (x: UInt64.t)) =
    {[@expl:peek requires #0] Seq.length (view addr) < 10000000}
    {[@expl:peek requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view addr)}
    any [ return''0 (result: UInt64.t) -> (! return' {result}) ]
  
  function view'0 [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t =
    Slice64.view self.current
  
  meta "rewrite_def" function view'0
  
  let rec poke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t)
    (return' (x: Int8.t)) = {[@expl:poke requires #0] Seq.length (view'0 addr) < 10000000}
    {[@expl:poke requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    any
    [ return''0 (result: Int8.t) -> {Seq.length (Slice64.view addr.final) = Seq.length (view'0 addr)}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (Slice64.slice UInt8.t)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peekthenpoke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t))
    (return' (x: Int8.t)) = {[@expl:peekthenpoke requires #0] Seq.length (view'0 addr) < 10000000}
    {[@expl:peekthenpoke requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:peekthenpoke requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = peek {start'0} {length'0} {addr'0.current} (fun (_ret: UInt64.t) -> [ &value <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt8.t> {addr'0.current} {MutBorrow.get_id addr'0}
          (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
            [ &_14 <- _ret ] [ &addr'0 <- { addr'0 with current = _ret.final } ] s1)
      | s1 = poke {start'0} {length'0} {_14} {value} (fun (_ret: Int8.t) -> [ &res <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- res ] s2 | s2 = return''0 {_0} ] ]
    [ & _0: Int8.t = Any.any_l ()
    | & start'0: UInt64.t = start
    | & length'0: UInt64.t = length
    | & addr'0: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value: UInt64.t = Any.any_l ()
    | & res: Int8.t = Any.any_l ()
    | & _14: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l () ])
    [ return''0 (result: Int8.t) -> (! return' {result}) ]
end
module M_bitwalker__pokethenpeek
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use creusot.int.UInt64
  use creusot.int.Int8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  function view [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t =
    Slice64.view self.current
  
  meta "rewrite_def" function view
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec poke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t)
    (return' (x: Int8.t)) = {[@expl:poke requires #0] Seq.length (view addr) < 10000000}
    {[@expl:poke requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view addr)}
    any
    [ return''0 (result: Int8.t) -> {Seq.length (Slice64.view addr.final) = Seq.length (view addr)}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (Slice64.slice UInt8.t)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  function view'0 [@inline:trivial] (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = Slice64.view self
  
  meta "rewrite_def" function view'0
  
  let rec peek (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t) (return' (x: UInt64.t)) =
    {[@expl:peek requires #0] Seq.length (view'0 addr) < 10000000}
    {[@expl:peek requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    any [ return''0 (result: UInt64.t) -> (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec pokethenpeek (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t))
    (value: UInt64.t) (return' (x: UInt64.t)) = {[@expl:pokethenpeek requires #0] Seq.length (view addr) < 10000000}
    {[@expl:pokethenpeek requires #1] UInt64.le length (64: UInt64.t)}
    {[@expl:pokethenpeek requires #2] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt8.t> {addr'0.current} {MutBorrow.get_id addr'0}
          (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
            [ &_11 <- _ret ] [ &addr'0 <- { addr'0 with current = _ret.final } ] s1)
      | s1 = poke {start'0} {length'0} {_11} {value'0} (fun (_ret: Int8.t) -> [ &_res <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = -{resolve'0 addr'0}- s1
      | s1 = peek {start'0} {length'0} {addr'0.current} (fun (_ret: UInt64.t) -> [ &peek_result <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- peek_result ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & start'0: UInt64.t = start
    | & length'0: UInt64.t = length
    | & addr'0: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value'0: UInt64.t = value
    | & _res: Int8.t = Any.any_l ()
    | & _11: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l ()
    | & peek_result: UInt64.t = Any.any_l () ]) [ return''0 (result: UInt64.t) -> (! return' {result}) ]
end
