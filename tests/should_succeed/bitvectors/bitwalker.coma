module M_bitwalker__peek_bit_u8 [#"bitwalker.rs" 9 0 9 42]
  let%span sbitwalker = "bitwalker.rs" 10 27 10 33
  let%span sbitwalker'0 = "bitwalker.rs" 10 19 10 22
  let%span sbitwalker'1 = "bitwalker.rs" 11 18 11 19
  let%span sbitwalker'2 = "bitwalker.rs" 8 11 8 24
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  
  use creusot.int.UInt64
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_bit_u8 [#"bitwalker.rs" 9 0 9 42] (x: UInt8.t) (left: UInt64.t) (return' (x'0: bool)) =
    {[@expl:peek_bit_u8 requires] [%#sbitwalker'2] UInt64.lt left (8: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {[%#sbitwalker] (7: UInt64.t)} {left'0} (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1)
      | s1 = UInt8.shl {[%#sbitwalker'0] (1: UInt8.t)} {UInt64.t'int _5} (fun (_ret: UInt8.t) -> [ &mask <- _ret ] s2)
      | s2 = [ &_7 <- UInt8.bw_and x'0 mask ] s3
      | s3 = [ &_0 <- _7 <> ([%#sbitwalker'1] (0: UInt8.t)) ] s4
      | s4 = return''0 {_0} ] ]
    [ & _0: bool = Any.any_l ()
    | & x'0: UInt8.t = x
    | & left'0: UInt64.t = left
    | & mask: UInt8.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l ()
    | & _7: UInt8.t = Any.any_l () ]) [ return''0 (result: bool) -> (! return' {result}) ]
end
module M_bitwalker__peek_bit_array8 [#"bitwalker.rs" 15 0 15 52]
  let%span sbitwalker = "bitwalker.rs" 16 26 16 27
  let%span sbitwalker'0 = "bitwalker.rs" 16 19 16 27
  let%span sbitwalker'1 = "bitwalker.rs" 17 42 17 43
  let%span sbitwalker'2 = "bitwalker.rs" 17 35 17 43
  let%span sbitwalker'3 = "bitwalker.rs" 19 20 19 25
  let%span sbitwalker'4 = "bitwalker.rs" 20 12 20 17
  let%span sbitwalker'5 = "bitwalker.rs" 19 20 19 25
  let%span sbitwalker'6 = "bitwalker.rs" 14 11 14 34
  let%span sbitwalker'7 = "bitwalker.rs" 8 11 8 24
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 259 18 259 96
  let%span sslice'0 = "../../../creusot-contracts/src/std/slice.rs" 260 8 260 57
  let%span sslice'1 = "../../../creusot-contracts/src/std/slice.rs" 110 20 110 37
  let%span sslice'2 = "../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  let%span smodel = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  
  use creusot.int.UInt64
  use creusot.int.UInt8
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option = C_None | C_Some UInt8.t
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt8.t) =
    [%#sslice'1] UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  function view (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = [%#smodel] Slice64.view self
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt8.t) (out: UInt8.t) =
    [%#sslice'2] Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec get (self_: Slice64.slice UInt8.t) (ix: UInt64.t) (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {[%#sslice] in_bounds ix (view self_)
      -> (exists r: UInt8.t. result = C_Some r /\ has_value ix (view self_) r)}
      {[%#sslice'0] in_bounds ix (view self_) \/ result = C_None}
      (! return' {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: UInt8.t)) = any
    [ good (field_0: UInt8.t) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: UInt8.t [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec peek_bit_u8 (x: UInt8.t) (left: UInt64.t) (return' (x'0: bool)) =
    {[@expl:peek_bit_u8 requires] [%#sbitwalker'7] UInt64.lt left (8: UInt64.t)}
    any [ return''0 (result: bool) -> (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_bit_array8 [#"bitwalker.rs" 15 0 15 52] (addr: Slice64.slice UInt8.t) (left: UInt64.t)
    (return' (x: bool)) = {[@expl:peek_bit_array8 requires] [%#sbitwalker'6] UInt64.t'int left
    < 8 * Seq.length (view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- ([%#sbitwalker] (8: UInt64.t)) = ([%#sbitwalker'0] (0: UInt64.t)) ] s1
      | s1 = {[@expl:division by zero] [%#sbitwalker'0] not _8} s2
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.div {left'0} {[%#sbitwalker] (8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = get {addr'0} {_6} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = C_None} (! bb5) | br1 (x0: UInt8.t) -> {_4 = C_Some x0} (! bb6) ]
    | bb6 = s0
      [ s0 = v_Some {_4} (fun (r0: UInt8.t) -> [ &v <- r0 ] s1)
      | s1 = [ &_14 <- ([%#sbitwalker'1] (8: UInt64.t)) = ([%#sbitwalker'2] (0: UInt64.t)) ] s2
      | s2 = {[@expl:remainder by zero] [%#sbitwalker'2] not _14} s3
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = UInt64.rem {left'0} {[%#sbitwalker'1] (8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &_12 <- _ret ] s1)
      | s1 = peek_bit_u8 {v} {_12} (fun (_ret: bool) -> [ &_0 <- _ret ] s2)
      | s2 = bb12 ]
    | bb5 = any [ br0 -> {([%#sbitwalker'3] false) = false} (! bb9) | br1 -> {[%#sbitwalker'3] false} (! bb11) ]
    | bb11 = s0 [ s0 = [ &_0 <- [%#sbitwalker'4] false ] s1 | s1 = bb12 ]
    | bb12 = return''0 {_0}
    | bb9 = {[%#sbitwalker'5] false} any ]
    [ & _0: bool = Any.any_l ()
    | & addr'0: Slice64.slice UInt8.t = addr
    | & left'0: UInt64.t = left
    | & _4: t_Option = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & v: UInt8.t = Any.any_l ()
    | & _12: UInt64.t = Any.any_l ()
    | & _14: bool = Any.any_l () ]) [ return''0 (result: bool) -> (! return' {result}) ]
end
module M_bitwalker__poke_bit_64 [#"bitwalker.rs" 28 0 28 58]
  let%span sbitwalker = "bitwalker.rs" 29 29 29 36
  let%span sbitwalker'0 = "bitwalker.rs" 29 20 29 24
  let%span sbitwalker'1 = "bitwalker.rs" 27 11 27 25
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_bit_64 [#"bitwalker.rs" 28 0 28 58] (value: UInt64.t) (left: UInt64.t) (flag: bool)
    (return' (x: UInt64.t)) = {[@expl:poke_bit_64 requires] [%#sbitwalker'1] UInt64.lt left (64: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {[%#sbitwalker] (63: UInt64.t)} {left'0} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = UInt64.shl {[%#sbitwalker'0] (1: UInt64.t)} {UInt64.t'int _6}
          (fun (_ret: UInt64.t) -> [ &mask <- _ret ] s2)
      | s2 = any [ br0 -> {flag'0 = false} (! bb2) | br1 -> {flag'0} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- UInt64.bw_or value'0 mask ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_14 <- UInt64.bw_not mask ] s1 | s1 = [ &_0 <- UInt64.bw_and value'0 _14 ] s2 | s2 = bb3 ]
    | bb3 = return''0 {_0} ]
    [ & _0: UInt64.t = Any.any_l ()
    | & value'0: UInt64.t = value
    | & left'0: UInt64.t = left
    | & flag'0: bool = flag
    | & mask: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l () ]) [ return''0 (result: UInt64.t) -> (! return' {result}) ]
end
module M_bitwalker__peek [#"bitwalker.rs" 44 0 44 56]
  let%span sbitwalker = "bitwalker.rs" 45 26 45 27
  let%span sbitwalker'0 = "bitwalker.rs" 48 26 48 27
  let%span sbitwalker'1 = "bitwalker.rs" 49 23 49 24
  let%span sbitwalker'2 = "bitwalker.rs" 52 37 52 44
  let%span sbitwalker'3 = "bitwalker.rs" 53 13 53 14
  let%span sbitwalker'4 = "bitwalker.rs" 41 11 41 33
  let%span sbitwalker'5 = "bitwalker.rs" 42 11 42 28
  let%span sbitwalker'6 = "bitwalker.rs" 43 11 43 46
  let%span sbitwalker'7 = "bitwalker.rs" 14 11 14 34
  let%span sbitwalker'8 = "bitwalker.rs" 27 11 27 25
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 250 18 250 40
  let%span smodel = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  function view (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = [%#smodel] Slice64.view self
  
  let rec len (self_: Slice64.slice UInt8.t) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#sslice] Seq.length (view self_) = UInt64.t'int result} (! return' {result}) ]
  
  let rec peek_bit_array8 (addr: Slice64.slice UInt8.t) (left: UInt64.t) (return' (x: bool)) =
    {[@expl:peek_bit_array8 requires] [%#sbitwalker'7] UInt64.t'int left < 8 * Seq.length (view addr)}
    any [ return''0 (result: bool) -> (! return' {result}) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec poke_bit_64 (value: UInt64.t) (left: UInt64.t) (flag: bool) (return' (x: UInt64.t)) =
    {[@expl:poke_bit_64 requires] [%#sbitwalker'8] UInt64.lt left (64: UInt64.t)}
    any [ return''0 (result: UInt64.t) -> (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek [#"bitwalker.rs" 44 0 44 56] (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t)
    (return' (x: UInt64.t)) = {[@expl:peek requires #0] [%#sbitwalker'4] Seq.length (view addr) < 10000000}
    {[@expl:peek requires #1] [%#sbitwalker'5] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] [%#sbitwalker'6] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.add {start'0} {length'0} (fun (_ret: UInt64.t) -> [ &_10 <- _ret ] s1)
      | s1 = len {addr'0} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.mul {[%#sbitwalker] (8: UInt64.t)} {_14} (fun (_ret: UInt64.t) -> [ &_13 <- _ret ] s1)
      | s1 = [ &_9 <- UInt64.gt _10 _13 ] s2
      | s2 = any [ br0 -> {_9 = false} (! bb3) | br1 -> {_9} (! bb2) ] ]
    | bb2 = {false} any
    | bb3 = s0
      [ s0 = [ &retval <- [%#sbitwalker'0] (0: UInt64.t) ] s1
      | s1 = [ &i <- [%#sbitwalker'1] (0: UInt64.t) ] s2
      | s2 = bb5 ]
    | bb5 = bb5'0
      [ bb5'0 = (! s0
        [ s0 = [ &_21 <- UInt64.lt i length'0 ] s1 | s1 = any [ br0 -> {_21 = false} (! bb9) | br1 -> {_21} (! bb6) ] ])
        [ bb6 = s0
          [ s0 = UInt64.add {start'0} {i} (fun (_ret: UInt64.t) -> [ &_26 <- _ret ] s1)
          | s1 = peek_bit_array8 {addr'0} {_26} (fun (_ret: bool) -> [ &flag <- _ret ] s2)
          | s2 = bb7 ]
        | bb7 = s0
          [ s0 = UInt64.sub {length'0} {i} (fun (_ret: UInt64.t) -> [ &_32 <- _ret ] s1)
          | s1 = UInt64.sub {[%#sbitwalker'2] (64: UInt64.t)} {_32} (fun (_ret: UInt64.t) -> [ &_31 <- _ret ] s2)
          | s2 = poke_bit_64 {retval} {_31} {flag} (fun (_ret: UInt64.t) -> [ &_29 <- _ret ] s3)
          | s3 = bb8 ]
        | bb8 = s0
          [ s0 = [ &retval <- _29 ] s1
          | s1 = UInt64.add {i} {[%#sbitwalker'3] (1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s2)
          | s2 = bb5'0 ] ] ]
    | bb9 = s0 [ s0 = [ &_0 <- retval ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & start'0: UInt64.t = start
    | & length'0: UInt64.t = length
    | & addr'0: Slice64.slice UInt8.t = addr
    | & _9: bool = Any.any_l ()
    | & _10: UInt64.t = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & retval: UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & flag: bool = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & _29: UInt64.t = Any.any_l ()
    | & _31: UInt64.t = Any.any_l ()
    | & _32: UInt64.t = Any.any_l () ]) [ return''0 (result: UInt64.t) -> (! return' {result}) ]
end
module M_bitwalker__peek_64bit [#"bitwalker.rs" 63 0 63 46]
  let%span sbitwalker = "bitwalker.rs" 64 29 64 36
  let%span sbitwalker'0 = "bitwalker.rs" 64 20 64 24
  let%span sbitwalker'1 = "bitwalker.rs" 65 22 65 23
  let%span sbitwalker'2 = "bitwalker.rs" 62 11 62 25
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peek_64bit [#"bitwalker.rs" 63 0 63 46] (value: UInt64.t) (left: UInt64.t) (return' (x: bool)) =
    {[@expl:peek_64bit requires] [%#sbitwalker'2] UInt64.lt left (64: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {[%#sbitwalker] (63: UInt64.t)} {left'0} (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1)
      | s1 = UInt64.shl {[%#sbitwalker'0] (1: UInt64.t)} {UInt64.t'int _5}
          (fun (_ret: UInt64.t) -> [ &mask <- _ret ] s2)
      | s2 = [ &_7 <- UInt64.bw_and value'0 mask ] s3
      | s3 = [ &_0 <- _7 <> ([%#sbitwalker'1] (0: UInt64.t)) ] s4
      | s4 = return''0 {_0} ] ]
    [ & _0: bool = Any.any_l ()
    | & value'0: UInt64.t = value
    | & left'0: UInt64.t = left
    | & mask: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l ()
    | & _7: UInt64.t = Any.any_l () ]) [ return''0 (result: bool) -> (! return' {result}) ]
end
module M_bitwalker__poke_8bit [#"bitwalker.rs" 69 0 69 53]
  let%span sbitwalker = "bitwalker.rs" 70 23 70 29
  let%span sbitwalker'0 = "bitwalker.rs" 70 15 70 18
  let%span sbitwalker'1 = "bitwalker.rs" 68 11 68 24
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  
  use creusot.int.UInt64
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_8bit [#"bitwalker.rs" 69 0 69 53] (byte: UInt8.t) (left: UInt64.t) (flag: bool) (return' (x: UInt8.t)) =
    {[@expl:poke_8bit requires] [%#sbitwalker'1] UInt64.lt left (8: UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {[%#sbitwalker] (7: UInt64.t)} {left'0} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1)
      | s1 = UInt8.shl {[%#sbitwalker'0] (1: UInt8.t)} {UInt64.t'int _6} (fun (_ret: UInt8.t) -> [ &mask <- _ret ] s2)
      | s2 = any [ br0 -> {flag'0 = false} (! bb2) | br1 -> {flag'0} (! bb1) ] ]
    | bb1 = s0 [ s0 = [ &_0 <- UInt8.bw_or byte'0 mask ] s1 | s1 = bb3 ]
    | bb2 = s0 [ s0 = [ &_14 <- UInt8.bw_not mask ] s1 | s1 = [ &_0 <- UInt8.bw_and byte'0 _14 ] s2 | s2 = bb3 ]
    | bb3 = return''0 {_0} ]
    [ & _0: UInt8.t = Any.any_l ()
    | & byte'0: UInt8.t = byte
    | & left'0: UInt64.t = left
    | & flag'0: bool = flag
    | & mask: UInt8.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _14: UInt8.t = Any.any_l () ]) [ return''0 (result: UInt8.t) -> (! return' {result}) ]
end
module M_bitwalker__poke_8bit_array [#"bitwalker.rs" 80 0 80 60]
  let%span sbitwalker = "bitwalker.rs" 81 26 81 27
  let%span sbitwalker'0 = "bitwalker.rs" 81 19 81 27
  let%span sbitwalker'1 = "bitwalker.rs" 82 26 82 27
  let%span sbitwalker'2 = "bitwalker.rs" 82 19 82 27
  let%span sbitwalker'3 = "bitwalker.rs" 83 24 83 31
  let%span sbitwalker'4 = "bitwalker.rs" 83 4 83 11
  let%span sbitwalker'5 = "bitwalker.rs" 78 11 78 34
  let%span sbitwalker'6 = "bitwalker.rs" 79 10 79 39
  let%span sbitwalker'7 = "bitwalker.rs" 68 11 68 24
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use seq.Seq
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec poke_8bit (byte: UInt8.t) (left: UInt64.t) (flag: bool) (return' (x: UInt8.t)) =
    {[@expl:poke_8bit requires] [%#sbitwalker'7] UInt64.lt left (8: UInt64.t)}
    any [ return''0 (result: UInt8.t) -> (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) =
    [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (Slice64.slice UInt8.t)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  function view (self: MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t = [%#smodel] Slice64.view self.current
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke_8bit_array [#"bitwalker.rs" 80 0 80 60] (addr: MutBorrow.t (Slice64.slice UInt8.t)) (left: UInt64.t)
    (flag: bool) (return' (x: ())) = {[@expl:poke_8bit_array requires] [%#sbitwalker'5] UInt64.t'int left
    < 8 * Seq.length (view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- ([%#sbitwalker] (8: UInt64.t)) = ([%#sbitwalker'0] (0: UInt64.t)) ] s1
      | s1 = {[@expl:division by zero] [%#sbitwalker'0] not _8} s2
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.div {left'0} {[%#sbitwalker] (8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s1)
      | s1 = [ &_11 <- ([%#sbitwalker'1] (8: UInt64.t)) = ([%#sbitwalker'2] (0: UInt64.t)) ] s2
      | s2 = {[@expl:remainder by zero] [%#sbitwalker'2] not _11} s3
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.rem {left'0} {[%#sbitwalker'1] (8: UInt64.t)} (fun (_ret: UInt64.t) -> [ &k <- _ret ] s1)
      | s1 = [ &_14 <- i ] s2
      | s2 = Opaque.fresh_ptr
          (fun (_ptr: Opaque.ptr) -> -{Slice64.slice_ptr_len _ptr = Slice64.length addr'0.current}- [ &_15 <- _ptr ] s3)
      | s3 = [ &_16 <- Slice64.slice_ptr_len _15 ] s4
      | s4 = [ &_17 <- UInt64.lt _14 _16 ] s5
      | s5 = {[@expl:index in bounds] [%#sbitwalker'3] _17} s6
      | s6 = bb3 ]
    | bb3 = s0
      [ s0 = Slice64.get <UInt8.t> {addr'0.current} {_14}
          (fun (r: UInt8.t) -> poke_8bit {r} {k} {flag'0} (fun (_ret: UInt8.t) -> [ &_12 <- _ret ] s1))
      | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_20 <- i ] s1
      | s1 = Opaque.fresh_ptr
          (fun (_ptr: Opaque.ptr) -> -{Slice64.slice_ptr_len _ptr = Slice64.length addr'0.current}- [ &_21 <- _ptr ] s2)
      | s2 = [ &_22 <- Slice64.slice_ptr_len _21 ] s3
      | s3 = [ &_23 <- UInt64.lt _20 _22 ] s4
      | s4 = {[@expl:index in bounds] [%#sbitwalker'4] _23} s5
      | s5 = bb5 ]
    | bb5 = s0
      [ s0 = Slice64.set <UInt8.t> {addr'0.current} {_20} {_12}
          (fun (r: Slice64.slice UInt8.t) -> [ &addr'0 <- { addr'0 with current = r } ] s1)
      | s1 = -{resolve'0 addr'0}- s2
      | s2 = return''0 {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & addr'0: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & left'0: UInt64.t = left
    | & flag'0: bool = flag
    | & i: UInt64.t = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & k: UInt64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: UInt8.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _15: Opaque.ptr = Any.any_l ()
    | & _16: UInt64.t = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _20: UInt64.t = Any.any_l ()
    | & _21: Opaque.ptr = Any.any_l ()
    | & _22: UInt64.t = Any.any_l ()
    | & _23: bool = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:poke_8bit_array ensures] [%#sbitwalker'6] Seq.length (Slice64.view addr.final)
      = Seq.length (view addr)}
      (! return' {result}) ]
end
module M_bitwalker__poke [#"bitwalker.rs" 90 0 90 71]
  let%span sbitwalker = "bitwalker.rs" 92 26 92 27
  let%span sbitwalker'0 = "bitwalker.rs" 93 15 93 17
  let%span sbitwalker'1 = "bitwalker.rs" 95 16 95 23
  let%span sbitwalker'2 = "bitwalker.rs" 95 37 95 41
  let%span sbitwalker'3 = "bitwalker.rs" 96 15 96 17
  let%span sbitwalker'4 = "bitwalker.rs" 98 24 98 26
  let%span sbitwalker'5 = "bitwalker.rs" 99 23 99 24
  let%span sbitwalker'6 = "bitwalker.rs" 101 16 101 41
  let%span sbitwalker'7 = "bitwalker.rs" 100 16 100 27
  let%span sbitwalker'8 = "bitwalker.rs" 103 22 103 34
  let%span sbitwalker'9 = "bitwalker.rs" 106 22 106 47
  let%span sbitwalker'10 = "bitwalker.rs" 107 13 107 14
  let%span sbitwalker'11 = "bitwalker.rs" 109 11 109 12
  let%span sbitwalker'12 = "bitwalker.rs" 86 11 86 33
  let%span sbitwalker'13 = "bitwalker.rs" 87 11 87 28
  let%span sbitwalker'14 = "bitwalker.rs" 88 11 88 46
  let%span sbitwalker'15 = "bitwalker.rs" 89 10 89 39
  let%span sbitwalker'16 = "bitwalker.rs" 62 11 62 25
  let%span sbitwalker'17 = "bitwalker.rs" 78 11 78 34
  let%span sbitwalker'18 = "bitwalker.rs" 79 10 79 39
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 250 18 250 40
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  function view (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = [%#smodel'0] Slice64.view self
  
  let rec len (self_: Slice64.slice UInt8.t) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#sslice] Seq.length (view self_) = UInt64.t'int result} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) =
    [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (Slice64.slice UInt8.t)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  function view'0 (self: MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t = [%#smodel] Slice64.view self.current
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec peek_64bit (value: UInt64.t) (left: UInt64.t) (return' (x: bool)) =
    {[@expl:peek_64bit requires] [%#sbitwalker'16] UInt64.lt left (64: UInt64.t)}
    any [ return''0 (result: bool) -> (! return' {result}) ]
  
  let rec poke_8bit_array (addr: MutBorrow.t (Slice64.slice UInt8.t)) (left: UInt64.t) (flag: bool) (return' (x: ())) =
    {[@expl:poke_8bit_array requires] [%#sbitwalker'17] UInt64.t'int left < 8 * Seq.length (view'0 addr)}
    any
    [ return''0 (result: ()) -> {[%#sbitwalker'18] Seq.length (Slice64.view addr.final) = Seq.length (view'0 addr)}
      (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec poke [#"bitwalker.rs" 90 0 90 71] (start: UInt64.t) (length: UInt64.t)
    (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t) (return' (x: Int8.t)) =
    {[@expl:poke requires #0] [%#sbitwalker'12] Seq.length (view'0 addr) < 10000000}
    {[@expl:poke requires #1] [%#sbitwalker'13] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] [%#sbitwalker'14] UInt64.t'int start + UInt64.t'int length
    <= 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0 [ s0 = len {addr'0.current} (fun (_ret: UInt64.t) -> [ &ghost_len <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = UInt64.add {start'0} {length'0} (fun (_ret: UInt64.t) -> [ &_14 <- _ret ] s1)
      | s1 = len {addr'0.current} (fun (_ret: UInt64.t) -> [ &_18 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = UInt64.mul {[%#sbitwalker] (8: UInt64.t)} {_18} (fun (_ret: UInt64.t) -> [ &_17 <- _ret ] s1)
      | s1 = [ &_13 <- UInt64.gt _14 _17 ] s2
      | s2 = any [ br0 -> {_13 = false} (! bb4) | br1 -> {_13} (! bb3) ] ]
    | bb3 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- [%#sbitwalker'0] (-1: Int8.t) ] s2 | s2 = bb16 ]
    | bb4 = s0
      [ s0 = [ &_22 <- UInt64.lt length'0 ([%#sbitwalker'1] (64: UInt64.t)) ] s1
      | s1 = any [ br0 -> {_22 = false} (! bb9) | br1 -> {_22} (! bb5) ] ]
    | bb5 = s0
      [ s0 = UInt64.shl {[%#sbitwalker'2] (1: UInt64.t)} {UInt64.t'int length'0}
          (fun (_ret: UInt64.t) -> [ &_26 <- _ret ] s1)
      | s1 = [ &_24 <- UInt64.ge value'0 _26 ] s2
      | s2 = any [ br0 -> {_24 = false} (! bb9) | br1 -> {_24} (! bb7) ] ]
    | bb7 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- [%#sbitwalker'3] (-2: Int8.t) ] s2 | s2 = bb16 ]
    | bb9 = s0
      [ s0 = UInt64.sub {[%#sbitwalker'4] (64: UInt64.t)} {length'0} (fun (_ret: UInt64.t) -> [ &lstart <- _ret ] s1)
      | s1 = [ &i <- [%#sbitwalker'5] (0: UInt64.t) ] s2
      | s2 = [ &old_10_0 <- addr'0 ] s3
      | s3 = bb10 ]
    | bb10 = bb10'0
      [ bb10'0 = {[@expl:mut invariant] old_10_0.final = addr'0.final}
        {[@expl:loop invariant #0] [%#sbitwalker'7] UInt64.le i length'0}
        {[@expl:loop invariant #1] [%#sbitwalker'6] Seq.length (view'0 addr'0) = UInt64.t'int ghost_len}
        (! s0)
        [ s0 = bb11 ]
        [ bb11 = s0
          [ s0 = [ &_37 <- UInt64.lt i length'0 ] s1
          | s1 = any [ br0 -> {_37 = false} (! bb15) | br1 -> {_37} (! bb12) ] ]
        | bb12 = s0
          [ s0 = {[@expl:assertion] [%#sbitwalker'8] UInt64.t'int i < UInt64.t'int length'0} s1
          | s1 = UInt64.add {lstart} {i} (fun (_ret: UInt64.t) -> [ &_44 <- _ret ] s2)
          | s2 = peek_64bit {value'0} {_44} (fun (_ret: bool) -> [ &flag <- _ret ] s3)
          | s3 = bb13 ]
        | bb13 = s0
          [ s0 = UInt64.add {start'0} {i} (fun (_ret: UInt64.t) -> [ &_49 <- _ret ] s1)
          | s1 = MutBorrow.borrow_mut <Slice64.slice UInt8.t> {addr'0.current}
              (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
                [ &_48 <- _ret ] [ &addr'0 <- { addr'0 with current = _ret.final } ] s2)
          | s2 = poke_8bit_array {_48} {_49} {flag} (fun (_ret: ()) -> [ &_47 <- _ret ] s3)
          | s3 = bb14 ]
        | bb14 = s0
          [ s0 = {[@expl:assertion] [%#sbitwalker'9] Seq.length (view'0 addr'0) = UInt64.t'int ghost_len} s1
          | s1 = UInt64.add {i} {[%#sbitwalker'10] (1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s2)
          | s2 = bb10'0 ] ] ]
    | bb15 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- [%#sbitwalker'11] (0: Int8.t) ] s2 | s2 = bb16 ]
    | bb16 = return''0 {_0} ]
    [ & _0: Int8.t = Any.any_l ()
    | & start'0: UInt64.t = start
    | & length'0: UInt64.t = length
    | & addr'0: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value'0: UInt64.t = value
    | & ghost_len: UInt64.t = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _17: UInt64.t = Any.any_l ()
    | & _18: UInt64.t = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & lstart: UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & flag: bool = Any.any_l ()
    | & _44: UInt64.t = Any.any_l ()
    | & _47: () = Any.any_l ()
    | & _48: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l ()
    | & _49: UInt64.t = Any.any_l ()
    | & old_10_0: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l () ])
    [ return''0 (result: Int8.t) -> {[@expl:poke ensures] [%#sbitwalker'15] Seq.length (Slice64.view addr.final)
      = Seq.length (view'0 addr)}
      (! return' {result}) ]
end
module M_bitwalker__peekthenpoke [#"bitwalker.rs" 119 0 119 67]
  let%span sbitwalker = "bitwalker.rs" 116 11 116 33
  let%span sbitwalker'0 = "bitwalker.rs" 117 11 117 28
  let%span sbitwalker'1 = "bitwalker.rs" 118 11 118 46
  let%span sbitwalker'2 = "bitwalker.rs" 41 11 41 33
  let%span sbitwalker'3 = "bitwalker.rs" 42 11 42 28
  let%span sbitwalker'4 = "bitwalker.rs" 43 11 43 46
  let%span sbitwalker'5 = "bitwalker.rs" 86 11 86 33
  let%span sbitwalker'6 = "bitwalker.rs" 87 11 87 28
  let%span sbitwalker'7 = "bitwalker.rs" 88 11 88 46
  let%span sbitwalker'8 = "bitwalker.rs" 89 10 89 39
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.int.Int8
  use creusot.prelude.Any
  
  function view (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = [%#smodel'0] Slice64.view self
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec peek (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t) (return' (x: UInt64.t)) =
    {[@expl:peek requires #0] [%#sbitwalker'2] Seq.length (view addr) < 10000000}
    {[@expl:peek requires #1] [%#sbitwalker'3] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] [%#sbitwalker'4] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view addr)}
    any [ return''0 (result: UInt64.t) -> (! return' {result}) ]
  
  function view'0 (self: MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t = [%#smodel] Slice64.view self.current
  
  let rec poke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t)
    (return' (x: Int8.t)) = {[@expl:poke requires #0] [%#sbitwalker'5] Seq.length (view'0 addr) < 10000000}
    {[@expl:poke requires #1] [%#sbitwalker'6] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] [%#sbitwalker'7] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    any
    [ return''0 (result: Int8.t) -> {[%#sbitwalker'8] Seq.length (Slice64.view addr.final) = Seq.length (view'0 addr)}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) =
    [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (Slice64.slice UInt8.t)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec peekthenpoke [#"bitwalker.rs" 119 0 119 67] (start: UInt64.t) (length: UInt64.t)
    (addr: MutBorrow.t (Slice64.slice UInt8.t)) (return' (x: Int8.t)) =
    {[@expl:peekthenpoke requires #0] [%#sbitwalker] Seq.length (view'0 addr) < 10000000}
    {[@expl:peekthenpoke requires #1] [%#sbitwalker'0] UInt64.le length (64: UInt64.t)}
    {[@expl:peekthenpoke requires #2] [%#sbitwalker'1] UInt64.t'int start + UInt64.t'int length
    <= 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = peek {start'0} {length'0} {addr'0.current} (fun (_ret: UInt64.t) -> [ &value <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt8.t> {addr'0.current} {MutBorrow.get_id addr'0}
          (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
            [ &_14 <- _ret ] [ &addr'0 <- { addr'0 with current = _ret.final } ] s1)
      | s1 = poke {start'0} {length'0} {_14} {value} (fun (_ret: Int8.t) -> [ &res <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- res ] s2 | s2 = return''0 {_0} ] ]
    [ & _0: Int8.t = Any.any_l ()
    | & start'0: UInt64.t = start
    | & length'0: UInt64.t = length
    | & addr'0: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value: UInt64.t = Any.any_l ()
    | & res: Int8.t = Any.any_l ()
    | & _14: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l () ])
    [ return''0 (result: Int8.t) -> (! return' {result}) ]
end
module M_bitwalker__pokethenpeek [#"bitwalker.rs" 133 0 133 84]
  let%span sbitwalker = "bitwalker.rs" 130 11 130 33
  let%span sbitwalker'0 = "bitwalker.rs" 131 11 131 28
  let%span sbitwalker'1 = "bitwalker.rs" 132 11 132 46
  let%span sbitwalker'2 = "bitwalker.rs" 86 11 86 33
  let%span sbitwalker'3 = "bitwalker.rs" 87 11 87 28
  let%span sbitwalker'4 = "bitwalker.rs" 88 11 88 46
  let%span sbitwalker'5 = "bitwalker.rs" 89 10 89 39
  let%span sbitwalker'6 = "bitwalker.rs" 41 11 41 33
  let%span sbitwalker'7 = "bitwalker.rs" 42 11 42 28
  let%span sbitwalker'8 = "bitwalker.rs" 43 11 43 46
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 211 16 217 17
  let%span smodel = "../../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 44 20 44 34
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use creusot.int.UInt8
  use creusot.int.Int8
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  function view (self: MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t = [%#smodel] Slice64.view self.current
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = [%#sord'12] if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec poke (start: UInt64.t) (length: UInt64.t) (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t)
    (return' (x: Int8.t)) = {[@expl:poke requires #0] [%#sbitwalker'2] Seq.length (view addr) < 10000000}
    {[@expl:poke requires #1] [%#sbitwalker'3] UInt64.le length (64: UInt64.t)}
    {[@expl:poke requires #2] [%#sbitwalker'4] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view addr)}
    any
    [ return''0 (result: Int8.t) -> {[%#sbitwalker'5] Seq.length (Slice64.view addr.final) = Seq.length (view addr)}
      (! return' {result}) ]
  
  function view'0 (self: Slice64.slice UInt8.t) : Seq.seq UInt8.t = [%#smodel'0] Slice64.view self
  
  let rec peek (start: UInt64.t) (length: UInt64.t) (addr: Slice64.slice UInt8.t) (return' (x: UInt64.t)) =
    {[@expl:peek requires #0] [%#sbitwalker'6] Seq.length (view'0 addr) < 10000000}
    {[@expl:peek requires #1] [%#sbitwalker'7] UInt64.le length (64: UInt64.t)}
    {[@expl:peek requires #2] [%#sbitwalker'8] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    any [ return''0 (result: UInt64.t) -> (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t (Slice64.slice UInt8.t)) =
    [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t (Slice64.slice UInt8.t)) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec pokethenpeek [#"bitwalker.rs" 133 0 133 84] (start: UInt64.t) (length: UInt64.t)
    (addr: MutBorrow.t (Slice64.slice UInt8.t)) (value: UInt64.t) (return' (x: UInt64.t)) =
    {[@expl:pokethenpeek requires #0] [%#sbitwalker] Seq.length (view addr) < 10000000}
    {[@expl:pokethenpeek requires #1] [%#sbitwalker'0] UInt64.le length (64: UInt64.t)}
    {[@expl:pokethenpeek requires #2] [%#sbitwalker'1] UInt64.t'int start + UInt64.t'int length
    <= 8 * Seq.length (view addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt8.t> {addr'0.current} {MutBorrow.get_id addr'0}
          (fun (_ret: MutBorrow.t (Slice64.slice UInt8.t)) ->
            [ &_11 <- _ret ] [ &addr'0 <- { addr'0 with current = _ret.final } ] s1)
      | s1 = poke {start'0} {length'0} {_11} {value'0} (fun (_ret: Int8.t) -> [ &_res <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = peek {start'0} {length'0} {addr'0.current} (fun (_ret: UInt64.t) -> [ &peek_result <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0 [ s0 = -{resolve'0 addr'0}- s1 | s1 = [ &_0 <- peek_result ] s2 | s2 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & start'0: UInt64.t = start
    | & length'0: UInt64.t = length
    | & addr'0: MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value'0: UInt64.t = value
    | & _res: Int8.t = Any.any_l ()
    | & _11: MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l ()
    | & peek_result: UInt64.t = Any.any_l () ]) [ return''0 (result: UInt64.t) -> (! return' {result}) ]
end
