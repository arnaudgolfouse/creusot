module M_popcount__count8
  use creusot.int.Int32BW
  use creusot.int.UInt8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  function count8_log (n: UInt8BW.t) : int = (if UInt8BW.bw_and n (1: UInt8BW.t) = (0: UInt8BW.t) then 0 else 1)
                + (if UInt8BW.bw_and n (2: UInt8BW.t) = (0: UInt8BW.t) then 0 else 1)
              + (if UInt8BW.bw_and n (4: UInt8BW.t) = (0: UInt8BW.t) then 0 else 1)
            + (if UInt8BW.bw_and n (8: UInt8BW.t) = (0: UInt8BW.t) then 0 else 1)
          + (if UInt8BW.bw_and n (16: UInt8BW.t) = (0: UInt8BW.t) then 0 else 1)
        + (if UInt8BW.bw_and n (32: UInt8BW.t) = (0: UInt8BW.t) then 0 else 1)
      + (if UInt8BW.bw_and n (64: UInt8BW.t) = (0: UInt8BW.t) then 0 else 1)
    + (if UInt8BW.bw_and n (128: UInt8BW.t) = (0: UInt8BW.t) then 0 else 1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec count8 (n: UInt8BW.t) (return (x: UInt8BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- n ] s1
      | s1 = UInt8BW.shr {x} {Int32BW.to_int (1: Int32BW.t)} (fun (_ret: UInt8BW.t) -> [ &_7 <- _ret ] s2)
      | s2 = [ &_6 <- UInt8BW.bw_and _7 (85: UInt8BW.t) ] s3
      | s3 = UInt8BW.sub {x} {_6} (fun (_ret: UInt8BW.t) -> [ &x <- _ret ] s4)
      | s4 = [ &_9 <- UInt8BW.bw_and x (51: UInt8BW.t) ] s5
      | s5 = UInt8BW.shr {x} {Int32BW.to_int (2: Int32BW.t)} (fun (_ret: UInt8BW.t) -> [ &_12 <- _ret ] s6)
      | s6 = [ &_11 <- UInt8BW.bw_and _12 (51: UInt8BW.t) ] s7
      | s7 = UInt8BW.add {_9} {_11} (fun (_ret: UInt8BW.t) -> [ &x <- _ret ] s8)
      | s8 = UInt8BW.shr {x} {Int32BW.to_int (4: Int32BW.t)} (fun (_ret: UInt8BW.t) -> [ &_16 <- _ret ] s9)
      | s9 = UInt8BW.add {x} {_16} (fun (_ret: UInt8BW.t) -> [ &_14 <- _ret ] s10)
      | s10 = [ &x <- UInt8BW.bw_and _14 (15: UInt8BW.t) ] s11
      | s11 = [ &_0 <- x ] s12
      | s12 = return {_0} ] ]
    [ & _0: UInt8BW.t = Any.any_l ()
    | & n: UInt8BW.t = n
    | & x: UInt8BW.t = Any.any_l ()
    | & _6: UInt8BW.t = Any.any_l ()
    | & _7: UInt8BW.t = Any.any_l ()
    | & _9: UInt8BW.t = Any.any_l ()
    | & _11: UInt8BW.t = Any.any_l ()
    | & _12: UInt8BW.t = Any.any_l ()
    | & _14: UInt8BW.t = Any.any_l ()
    | & _16: UInt8BW.t = Any.any_l () ])
    [ return (result: UInt8BW.t) -> {[@expl:count8 ensures #0] UInt8BW.t'int result <= 8}
      {[@expl:count8 ensures #1] UInt8BW.t'int result = count8_log n}
      (! return {result}) ]
end
module M_popcount__count16
  use creusot.int.Int32BW
  use creusot.int.UInt16BW
  use creusot.prelude.Any
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec count16 (n: UInt16BW.t) (return (x: UInt16BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- n ] s1
      | s1 = UInt16BW.shr {x} {Int32BW.to_int (1: Int32BW.t)} (fun (_ret: UInt16BW.t) -> [ &_6 <- _ret ] s2)
      | s2 = [ &_5 <- UInt16BW.bw_and _6 (21845: UInt16BW.t) ] s3
      | s3 = UInt16BW.sub {x} {_5} (fun (_ret: UInt16BW.t) -> [ &x <- _ret ] s4)
      | s4 = [ &_8 <- UInt16BW.bw_and x (13107: UInt16BW.t) ] s5
      | s5 = UInt16BW.shr {x} {Int32BW.to_int (2: Int32BW.t)} (fun (_ret: UInt16BW.t) -> [ &_11 <- _ret ] s6)
      | s6 = [ &_10 <- UInt16BW.bw_and _11 (13107: UInt16BW.t) ] s7
      | s7 = UInt16BW.add {_8} {_10} (fun (_ret: UInt16BW.t) -> [ &x <- _ret ] s8)
      | s8 = UInt16BW.shr {x} {Int32BW.to_int (4: Int32BW.t)} (fun (_ret: UInt16BW.t) -> [ &_15 <- _ret ] s9)
      | s9 = UInt16BW.add {x} {_15} (fun (_ret: UInt16BW.t) -> [ &_13 <- _ret ] s10)
      | s10 = [ &x <- UInt16BW.bw_and _13 (3855: UInt16BW.t) ] s11
      | s11 = UInt16BW.shr {x} {Int32BW.to_int (8: Int32BW.t)} (fun (_ret: UInt16BW.t) -> [ &_18 <- _ret ] s12)
      | s12 = UInt16BW.add {x} {_18} (fun (_ret: UInt16BW.t) -> [ &x <- _ret ] s13)
      | s13 = [ &_0 <- UInt16BW.bw_and x (31: UInt16BW.t) ] s14
      | s14 = return {_0} ] ]
    [ & _0: UInt16BW.t = Any.any_l ()
    | & n: UInt16BW.t = n
    | & x: UInt16BW.t = Any.any_l ()
    | & _5: UInt16BW.t = Any.any_l ()
    | & _6: UInt16BW.t = Any.any_l ()
    | & _8: UInt16BW.t = Any.any_l ()
    | & _10: UInt16BW.t = Any.any_l ()
    | & _11: UInt16BW.t = Any.any_l ()
    | & _13: UInt16BW.t = Any.any_l ()
    | & _15: UInt16BW.t = Any.any_l ()
    | & _18: UInt16BW.t = Any.any_l () ])
    [ return (result: UInt16BW.t) -> {[@expl:count16 ensures] UInt16BW.t'int result <= 16} (! return {result}) ]
end
module M_popcount__count32
  use creusot.int.Int32BW
  use creusot.int.UInt32BW
  use creusot.prelude.Any
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec count32 (n: UInt32BW.t) (return (x: UInt32BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- n ] s1
      | s1 = UInt32BW.shr {x} {Int32BW.to_int (1: Int32BW.t)} (fun (_ret: UInt32BW.t) -> [ &_6 <- _ret ] s2)
      | s2 = [ &_5 <- UInt32BW.bw_and _6 (1431655765: UInt32BW.t) ] s3
      | s3 = UInt32BW.sub {x} {_5} (fun (_ret: UInt32BW.t) -> [ &x <- _ret ] s4)
      | s4 = [ &_8 <- UInt32BW.bw_and x (858993459: UInt32BW.t) ] s5
      | s5 = UInt32BW.shr {x} {Int32BW.to_int (2: Int32BW.t)} (fun (_ret: UInt32BW.t) -> [ &_11 <- _ret ] s6)
      | s6 = [ &_10 <- UInt32BW.bw_and _11 (858993459: UInt32BW.t) ] s7
      | s7 = UInt32BW.add {_8} {_10} (fun (_ret: UInt32BW.t) -> [ &x <- _ret ] s8)
      | s8 = UInt32BW.shr {x} {Int32BW.to_int (4: Int32BW.t)} (fun (_ret: UInt32BW.t) -> [ &_15 <- _ret ] s9)
      | s9 = UInt32BW.add {x} {_15} (fun (_ret: UInt32BW.t) -> [ &_13 <- _ret ] s10)
      | s10 = [ &x <- UInt32BW.bw_and _13 (252645135: UInt32BW.t) ] s11
      | s11 = UInt32BW.shr {x} {Int32BW.to_int (8: Int32BW.t)} (fun (_ret: UInt32BW.t) -> [ &_18 <- _ret ] s12)
      | s12 = UInt32BW.add {x} {_18} (fun (_ret: UInt32BW.t) -> [ &x <- _ret ] s13)
      | s13 = UInt32BW.shr {x} {Int32BW.to_int (16: Int32BW.t)} (fun (_ret: UInt32BW.t) -> [ &_21 <- _ret ] s14)
      | s14 = UInt32BW.add {x} {_21} (fun (_ret: UInt32BW.t) -> [ &x <- _ret ] s15)
      | s15 = [ &_0 <- UInt32BW.bw_and x (63: UInt32BW.t) ] s16
      | s16 = return {_0} ] ]
    [ & _0: UInt32BW.t = Any.any_l ()
    | & n: UInt32BW.t = n
    | & x: UInt32BW.t = Any.any_l ()
    | & _5: UInt32BW.t = Any.any_l ()
    | & _6: UInt32BW.t = Any.any_l ()
    | & _8: UInt32BW.t = Any.any_l ()
    | & _10: UInt32BW.t = Any.any_l ()
    | & _11: UInt32BW.t = Any.any_l ()
    | & _13: UInt32BW.t = Any.any_l ()
    | & _15: UInt32BW.t = Any.any_l ()
    | & _18: UInt32BW.t = Any.any_l ()
    | & _21: UInt32BW.t = Any.any_l () ])
    [ return (result: UInt32BW.t) -> {[@expl:count32 ensures] UInt32BW.t'int result <= 32} (! return {result}) ]
end
module M_popcount__count64
  use creusot.int.Int32BW
  use creusot.int.UInt64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec count64 (n: UInt64BW.t) (return (x: UInt64BW.t)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- n ] s1
      | s1 = UInt64BW.shr {x} {Int32BW.to_int (1: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_6 <- _ret ] s2)
      | s2 = [ &_5 <- UInt64BW.bw_and _6 (6148914691236517205: UInt64BW.t) ] s3
      | s3 = UInt64BW.sub {x} {_5} (fun (_ret: UInt64BW.t) -> [ &x <- _ret ] s4)
      | s4 = [ &_8 <- UInt64BW.bw_and x (3689348814741910323: UInt64BW.t) ] s5
      | s5 = UInt64BW.shr {x} {Int32BW.to_int (2: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_11 <- _ret ] s6)
      | s6 = [ &_10 <- UInt64BW.bw_and _11 (3689348814741910323: UInt64BW.t) ] s7
      | s7 = UInt64BW.add {_8} {_10} (fun (_ret: UInt64BW.t) -> [ &x <- _ret ] s8)
      | s8 = UInt64BW.shr {x} {Int32BW.to_int (4: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_15 <- _ret ] s9)
      | s9 = UInt64BW.add {x} {_15} (fun (_ret: UInt64BW.t) -> [ &_13 <- _ret ] s10)
      | s10 = [ &x <- UInt64BW.bw_and _13 (1085102592571150095: UInt64BW.t) ] s11
      | s11 = UInt64BW.shr {x} {Int32BW.to_int (8: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_18 <- _ret ] s12)
      | s12 = UInt64BW.add {x} {_18} (fun (_ret: UInt64BW.t) -> [ &x <- _ret ] s13)
      | s13 = UInt64BW.shr {x} {Int32BW.to_int (16: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_21 <- _ret ] s14)
      | s14 = UInt64BW.add {x} {_21} (fun (_ret: UInt64BW.t) -> [ &x <- _ret ] s15)
      | s15 = UInt64BW.shr {x} {Int32BW.to_int (32: Int32BW.t)} (fun (_ret: UInt64BW.t) -> [ &_24 <- _ret ] s16)
      | s16 = UInt64BW.add {x} {_24} (fun (_ret: UInt64BW.t) -> [ &x <- _ret ] s17)
      | s17 = [ &_0 <- UInt64BW.bw_and x (127: UInt64BW.t) ] s18
      | s18 = return {_0} ] ]
    [ & _0: UInt64BW.t = Any.any_l ()
    | & n: UInt64BW.t = n
    | & x: UInt64BW.t = Any.any_l ()
    | & _5: UInt64BW.t = Any.any_l ()
    | & _6: UInt64BW.t = Any.any_l ()
    | & _8: UInt64BW.t = Any.any_l ()
    | & _10: UInt64BW.t = Any.any_l ()
    | & _11: UInt64BW.t = Any.any_l ()
    | & _13: UInt64BW.t = Any.any_l ()
    | & _15: UInt64BW.t = Any.any_l ()
    | & _18: UInt64BW.t = Any.any_l ()
    | & _21: UInt64BW.t = Any.any_l ()
    | & _24: UInt64BW.t = Any.any_l () ])
    [ return (result: UInt64BW.t) -> {[@expl:count64 ensures] UInt64BW.t'int result <= 64} (! return {result}) ]
end
