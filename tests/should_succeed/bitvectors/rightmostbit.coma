module M_rightmost_bit_8
  use creusot.int.Int8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  let rec wrapping_neg (self_: Int8BW.t) (return (x: Int8BW.t)) = any
    [ return (result: Int8BW.t) -> {result = Int8BW.neg self_} (! return {result}) ]
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8BW.t) (o: Int8BW.t) : t_Ordering = if Int8BW.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom eq_cmp_i8_spec: forall x: Int8BW.t, y: Int8BW.t. (x = y) = (cmp_log_i8 x y = Equal)
  
  function antisym2_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom antisym2_i8_spec: forall x: Int8BW.t, y: Int8BW.t. cmp_log_i8 x y = Greater -> cmp_log_i8 y x = Less
  
  function antisym1_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom antisym1_i8_spec: forall x: Int8BW.t, y: Int8BW.t. cmp_log_i8 x y = Less -> cmp_log_i8 y x = Greater
  
  function trans_i8 (x: Int8BW.t) (y: Int8BW.t) (z: Int8BW.t) (o: t_Ordering) : ()
  
  axiom trans_i8_spec: forall x: Int8BW.t, y: Int8BW.t, z: Int8BW.t, o: t_Ordering. cmp_log_i8 x y = o
      -> cmp_log_i8 y z = o -> cmp_log_i8 x z = o
  
  function refl_i8 (x: Int8BW.t) : ()
  
  axiom refl_i8_spec: forall x: Int8BW.t. cmp_log_i8 x x = Equal
  
  function cmp_gt_log_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_gt_log_i8_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.gt x y = (cmp_log_i8 x y = Greater)
  
  function cmp_ge_log_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_ge_log_i8_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.ge x y = (cmp_log_i8 x y <> Less)
  
  function cmp_lt_log_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_lt_log_i8_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.lt x y = (cmp_log_i8 x y = Less)
  
  function cmp_le_log_i8 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_le_log_i8_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.le x y = (cmp_log_i8 x y <> Greater)
  
  constant const_MIN: Int8BW.t = (128: Int8BW.t)
  
  function count8_log (n: Int8BW.t) : int = (if Int8BW.bw_and n (1: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
                + (if Int8BW.bw_and n (2: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
              + (if Int8BW.bw_and n (4: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
            + (if Int8BW.bw_and n (8: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
          + (if Int8BW.bw_and n (16: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
        + (if Int8BW.bw_and n (32: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
      + (if Int8BW.bw_and n (64: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
    + (if Int8BW.bw_and n const_MIN = (0: Int8BW.t) then 0 else 1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rightmost_bit_8 (x: Int8BW.t) (return (x'0: Int8BW.t)) = (! bb0
    [ bb0 = s0 [ s0 = wrapping_neg {x} (fun (_ret: Int8BW.t) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- Int8BW.bw_and x _8 ] s1 | s1 = return {_0} ] ]
    [ & _0: Int8BW.t = Any.any_l () | & x: Int8BW.t = x | & _8: Int8BW.t = Any.any_l () ])
    [ return (result: Int8BW.t) -> {[@expl:rightmost_bit_8 ensures #0] Int8BW.ge x (0: Int8BW.t)
      -> Int8BW.le (0: Int8BW.t) result /\ Int8BW.le result x}
      {[@expl:rightmost_bit_8 ensures #1] Int8BW.le x (0: Int8BW.t) /\ Int8BW.gt x const_MIN
      -> Int8BW.le (0: Int8BW.t) result /\ Int8BW.to_int result <= - Int8BW.to_int x}
      {[@expl:rightmost_bit_8 ensures #2] (x = const_MIN) = (result = const_MIN)}
      {[@expl:rightmost_bit_8 ensures #3] forall i: Int8BW.t. Int8BW.le (0: Int8BW.t) i /\ Int8BW.lt i result
        -> Int8BW.bw_and i x = (0: Int8BW.t)}
      {[@expl:rightmost_bit_8 ensures #4] x <> (0: Int8BW.t) -> count8_log result = 1}
      (! return {result}) ]
end
module M_rightmost_bit_64
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  let rec wrapping_neg (self_: Int64BW.t) (return (x: Int64BW.t)) = any
    [ return (result: Int64BW.t) -> {result = Int64BW.neg self_} (! return {result}) ]
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64BW.t) (o: Int64BW.t) : t_Ordering = if Int64BW.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i64 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom eq_cmp_i64_spec: forall x: Int64BW.t, y: Int64BW.t. (x = y) = (cmp_log_i64 x y = Equal)
  
  function antisym2_i64 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom antisym2_i64_spec: forall x: Int64BW.t, y: Int64BW.t. cmp_log_i64 x y = Greater -> cmp_log_i64 y x = Less
  
  function antisym1_i64 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom antisym1_i64_spec: forall x: Int64BW.t, y: Int64BW.t. cmp_log_i64 x y = Less -> cmp_log_i64 y x = Greater
  
  function trans_i64 (x: Int64BW.t) (y: Int64BW.t) (z: Int64BW.t) (o: t_Ordering) : ()
  
  axiom trans_i64_spec: forall x: Int64BW.t, y: Int64BW.t, z: Int64BW.t, o: t_Ordering. cmp_log_i64 x y = o
      -> cmp_log_i64 y z = o -> cmp_log_i64 x z = o
  
  function refl_i64 (x: Int64BW.t) : ()
  
  axiom refl_i64_spec: forall x: Int64BW.t. cmp_log_i64 x x = Equal
  
  function cmp_gt_log_i64 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom cmp_gt_log_i64_spec: forall x: Int64BW.t, y: Int64BW.t. Int64BW.gt x y = (cmp_log_i64 x y = Greater)
  
  function cmp_ge_log_i64 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom cmp_ge_log_i64_spec: forall x: Int64BW.t, y: Int64BW.t. Int64BW.ge x y = (cmp_log_i64 x y <> Less)
  
  function cmp_lt_log_i64 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom cmp_lt_log_i64_spec: forall x: Int64BW.t, y: Int64BW.t. Int64BW.lt x y = (cmp_log_i64 x y = Less)
  
  function cmp_le_log_i64 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom cmp_le_log_i64_spec: forall x: Int64BW.t, y: Int64BW.t. Int64BW.le x y = (cmp_log_i64 x y <> Greater)
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rightmost_bit_64 (x: Int64BW.t) (return (x'0: Int64BW.t)) = (! bb0
    [ bb0 = s0 [ s0 = wrapping_neg {x} (fun (_ret: Int64BW.t) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- Int64BW.bw_and x _7 ] s1 | s1 = return {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l () | & x: Int64BW.t = x | & _7: Int64BW.t = Any.any_l () ])
    [ return (result: Int64BW.t) -> {[@expl:rightmost_bit_64 ensures #0] Int64BW.ge x (0: Int64BW.t)
      -> Int64BW.le (0: Int64BW.t) result /\ Int64BW.le result x}
      {[@expl:rightmost_bit_64 ensures #1] Int64BW.le x (0: Int64BW.t) /\ Int64BW.gt x const_MIN
      -> Int64BW.le (0: Int64BW.t) result /\ Int64BW.to_int result <= - Int64BW.to_int x}
      {[@expl:rightmost_bit_64 ensures #2] (x = const_MIN) = (result = const_MIN)}
      {[@expl:rightmost_bit_64 ensures #3] forall i: Int64BW.t. Int64BW.le (0: Int64BW.t) i /\ Int64BW.lt i result
        -> Int64BW.bw_and i x = (0: Int64BW.t)}
      (! return {result}) ]
end
