module M_rightmostbit__rightmost_bit_8
  use creusot.int.Int8BW
  use creusot.prelude.Any
  use mach.int.Int
  
  let rec wrapping_neg (self_: Int8BW.t) (return' (x: Int8BW.t)) = any
    [ return''0 (result: Int8BW.t) -> {result = Int8BW.neg self_} (! return' {result}) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8BW.t) (o: Int8BW.t) : t_Ordering = if Int8BW.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom eq_cmp_spec: forall x: Int8BW.t, y: Int8BW.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom antisym2_spec: forall x: Int8BW.t, y: Int8BW.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom antisym1_spec: forall x: Int8BW.t, y: Int8BW.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int8BW.t) (y: Int8BW.t) (z: Int8BW.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int8BW.t, y: Int8BW.t, z: Int8BW.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int8BW.t) : ()
  
  axiom refl_spec: forall x: Int8BW.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int8BW.t) (y: Int8BW.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int8BW.t, y: Int8BW.t. Int8BW.le x y = (cmp_log x y <> C_Greater)
  
  constant const_MIN: Int8BW.t = (128: Int8BW.t)
  
  function count8_log (n: Int8BW.t) : int = (if Int8BW.bw_and n (1: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
                + (if Int8BW.bw_and n (2: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
              + (if Int8BW.bw_and n (4: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
            + (if Int8BW.bw_and n (8: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
          + (if Int8BW.bw_and n (16: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
        + (if Int8BW.bw_and n (32: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
      + (if Int8BW.bw_and n (64: Int8BW.t) = (0: Int8BW.t) then 0 else 1)
    + (if Int8BW.bw_and n const_MIN = (0: Int8BW.t) then 0 else 1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rightmost_bit_8 (x: Int8BW.t) (return' (x'0: Int8BW.t)) = (! bb0
    [ bb0 = s0 [ s0 = wrapping_neg {x'0} (fun (_ret: Int8BW.t) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- Int8BW.bw_and x'0 _8 ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: Int8BW.t = Any.any_l () | & x'0: Int8BW.t = x | & _8: Int8BW.t = Any.any_l () ])
    [ return''0 (result: Int8BW.t) -> {[@expl:rightmost_bit_8 ensures #0] Int8BW.ge x (0: Int8BW.t)
      -> Int8BW.le (0: Int8BW.t) result /\ Int8BW.le result x}
      {[@expl:rightmost_bit_8 ensures #1] Int8BW.le x (0: Int8BW.t) /\ Int8BW.gt x const_MIN
      -> Int8BW.le (0: Int8BW.t) result /\ Int8BW.to_int result <= - Int8BW.to_int x}
      {[@expl:rightmost_bit_8 ensures #2] (x = const_MIN) = (result = const_MIN)}
      {[@expl:rightmost_bit_8 ensures #3] forall i: Int8BW.t. Int8BW.le (0: Int8BW.t) i /\ Int8BW.lt i result
        -> Int8BW.bw_and i x = (0: Int8BW.t)}
      {[@expl:rightmost_bit_8 ensures #4] x <> (0: Int8BW.t) -> count8_log result = 1}
      (! return' {result}) ]
end
module M_rightmostbit__rightmost_bit_64
  use creusot.int.Int64BW
  use creusot.prelude.Any
  use mach.int.Int
  
  let rec wrapping_neg (self_: Int64BW.t) (return' (x: Int64BW.t)) = any
    [ return''0 (result: Int64BW.t) -> {result = Int64BW.neg self_} (! return' {result}) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64BW.t) (o: Int64BW.t) : t_Ordering = if Int64BW.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom eq_cmp_spec: forall x: Int64BW.t, y: Int64BW.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom antisym2_spec: forall x: Int64BW.t, y: Int64BW.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom antisym1_spec: forall x: Int64BW.t, y: Int64BW.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int64BW.t) (y: Int64BW.t) (z: Int64BW.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int64BW.t, y: Int64BW.t, z: Int64BW.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int64BW.t) : ()
  
  axiom refl_spec: forall x: Int64BW.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int64BW.t, y: Int64BW.t. Int64BW.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int64BW.t, y: Int64BW.t. Int64BW.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int64BW.t, y: Int64BW.t. Int64BW.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int64BW.t) (y: Int64BW.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int64BW.t, y: Int64BW.t. Int64BW.le x y = (cmp_log x y <> C_Greater)
  
  constant const_MIN: Int64BW.t = (9223372036854775808: Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rightmost_bit_64 (x: Int64BW.t) (return' (x'0: Int64BW.t)) = (! bb0
    [ bb0 = s0 [ s0 = wrapping_neg {x'0} (fun (_ret: Int64BW.t) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- Int64BW.bw_and x'0 _7 ] s1 | s1 = return''0 {_0} ] ]
    [ & _0: Int64BW.t = Any.any_l () | & x'0: Int64BW.t = x | & _7: Int64BW.t = Any.any_l () ])
    [ return''0 (result: Int64BW.t) -> {[@expl:rightmost_bit_64 ensures #0] Int64BW.ge x (0: Int64BW.t)
      -> Int64BW.le (0: Int64BW.t) result /\ Int64BW.le result x}
      {[@expl:rightmost_bit_64 ensures #1] Int64BW.le x (0: Int64BW.t) /\ Int64BW.gt x const_MIN
      -> Int64BW.le (0: Int64BW.t) result /\ Int64BW.to_int result <= - Int64BW.to_int x}
      {[@expl:rightmost_bit_64 ensures #2] (x = const_MIN) = (result = const_MIN)}
      {[@expl:rightmost_bit_64 ensures #3] forall i: Int64BW.t. Int64BW.le (0: Int64BW.t) i /\ Int64BW.lt i result
        -> Int64BW.bw_and i x = (0: Int64BW.t)}
      (! return' {result}) ]
end
