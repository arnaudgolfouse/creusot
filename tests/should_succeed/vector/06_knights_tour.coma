module M_06_knights_tour__qyi50474406909270761__clone (* <Point as creusot_contracts::Clone> *)
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Point = { t_Point__x: Int64.t; t_Point__y: Int64.t }
  
  let rec clone' (self_: Int64.t) (return (x: Int64.t)) = any
    [ return' (result: Int64.t) -> {result = self_} (! return {result}) ]
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: Int64.t) (result: Int64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: Int64.t) (result_state: ()) (result: Int64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: Int64.t) (res: Int64.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: Int64.t, res: Int64.t. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: Int64.t) (res_state: ()) (res: Int64.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: Int64.t, res_state: (), res: Int64.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: Int64.t) (result: Int64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: Int64.t) (res: Int64.t) : ()
  
  axiom fn_once_spec: forall self: (), args: Int64.t, res: Int64.t. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: Int64.t) (res_state: ()) (res: Int64.t) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: Int64.t, res_state: (), res: Int64.t. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''0 (self: t_Point) (return (x: t_Point)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_5 <- self.t_Point__x ] s1 | s1 = clone' {_5} (fun (_ret: Int64.t) -> [ &_3 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_8 <- self.t_Point__y ] s1 | s1 = clone' {_8} (fun (_ret: Int64.t) -> [ &_6 <- _ret ] s2) | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- { t_Point__x = _3; t_Point__y = _6 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Point = Any.any_l ()
    | & self: t_Point = self
    | & _3: Int64.t = Any.any_l ()
    | & _5: Int64.t = Any.any_l ()
    | & _6: Int64.t = Any.any_l ()
    | & _8: Int64.t = Any.any_l () ])
    [ return (result: t_Point) -> {[@expl:clone ensures] postcondition () self.t_Point__x result.t_Point__x
      /\ postcondition () self.t_Point__y result.t_Point__y}
      (! return {result}) ]
end
module M_06_knights_tour__qyi18370800917002056__mov (* Point *)
  use creusot.int.Int64
  use creusot.prelude.Any
  use mach.int.Int
  
  type tuple = { f0: Int64.t; f1: Int64.t }
  
  type t_Point = { t_Point__x: Int64.t; t_Point__y: Int64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec mov (self: t_Point) (p: tuple) (return (x: t_Point)) = {[@expl:mov requires #0] - 10000
      <= Int64.to_int self.t_Point__x
    /\ Int64.to_int self.t_Point__x <= 10000}
    {[@expl:mov requires #1] - 10000 <= Int64.to_int self.t_Point__y /\ Int64.to_int self.t_Point__y <= 10000}
    {[@expl:mov requires #2] - 10000 <= Int64.to_int p.f0 /\ Int64.to_int p.f0 <= 10000}
    {[@expl:mov requires #3] - 10000 <= Int64.to_int p.f1 /\ Int64.to_int p.f1 <= 10000}
    (! bb0
    [ bb0 = s0
      [ s0 = Int64.add {self.t_Point__x} {p.f0} (fun (_ret: Int64.t) -> [ &_9 <- _ret ] s1)
      | s1 = Int64.add {self.t_Point__y} {p.f1} (fun (_ret: Int64.t) -> [ &_12 <- _ret ] s2)
      | s2 = [ &_0 <- { t_Point__x = _9; t_Point__y = _12 } ] s3
      | s3 = return {_0} ] ]
    [ & _0: t_Point = Any.any_l ()
    | & self: t_Point = self
    | & p: tuple = p
    | & _9: Int64.t = Any.any_l ()
    | & _12: Int64.t = Any.any_l () ])
    [ return (result: t_Point) -> {[@expl:mov ensures #0] Int64.to_int result.t_Point__x
      = Int64.to_int self.t_Point__x + Int64.to_int p.f0}
      {[@expl:mov ensures #1] Int64.to_int result.t_Point__y = Int64.to_int self.t_Point__y + Int64.to_int p.f1}
      (! return {result}) ]
end
module M_06_knights_tour__qyi4580598960913230815__new (* Board *)
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Range = { t_Range__start: UInt64.t; t_Range__end: UInt64.t }
  
  type closure3 = { c0: UInt64.t }
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t closure3) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t closure3) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : UInt64.t = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  let rec from_elem (elem: UInt64.t) (n: UInt64.t) (return (x: t_Vec)) = any
    [ return' (result: t_Vec) -> {Seq.length (view result) = UInt64.t'int n}
      {forall i: int. 0 <= i /\ i < UInt64.t'int n -> index_logic result i = elem}
      (! return {result}) ]
  
  type tuple = { f0: UInt64.t; f1: Seq.seq UInt64.t }
  
  predicate postcondition_once [@inline:trivial] (self: closure3) (args: tuple) (result: t_Vec) =
    let {f0 = _0; f1 = _1} = args in Seq.length (view result) = UInt64.t'int self.c0
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve'1 [@inline:trivial] (_1: closure3) = true
  
  meta "rewrite_def" predicate resolve'1
  
  predicate hist_inv [@inline:trivial] (self: closure3) (result_state: closure3) = result_state.c0 = self.c0
  
  meta "rewrite_def" predicate hist_inv
  
  predicate postcondition_mut [@inline:trivial] (self: closure3) (args: tuple) (result_state: closure3) (result: t_Vec) =
    let {f0 = _0; f1 = _1} = args in Seq.length (view result) = UInt64.t'int result_state.c0
    /\ hist_inv self result_state
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: closure3) (args: tuple) (res: t_Vec) : ()
  
  axiom fn_mut_once_spec: forall self: closure3, args: tuple, res: t_Vec. postcondition_once self args res
      = (exists res_state: closure3. postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  function hist_inv_trans (self: closure3) (b: closure3) (c: closure3) : ()
  
  axiom hist_inv_trans_spec: forall self: closure3, b: closure3, c: closure3. hist_inv self b
      -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: closure3) : ()
  
  axiom hist_inv_refl_spec: forall self: closure3. hist_inv self self
  
  function postcondition_mut_hist_inv (self: closure3) (args: tuple) (res_state: closure3) (res: t_Vec) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: closure3, args: tuple, res_state: closure3, res: t_Vec. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  let rec closure3 (self: MutBorrow.t closure3) (_0: UInt64.t) (_1: Seq.seq UInt64.t) (return (x: t_Vec)) = (! bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 self}- s1
      | s1 = from_elem {(0: UInt64.t)} {self.current.c0} (fun (_ret: t_Vec) -> [ &res <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0'0 <- res ] s1 | s1 = bb3 ]
    | bb3 = return {_0'0} ]
    [ & _0'0: t_Vec = Any.any_l () | & self: MutBorrow.t closure3 = self | & res: t_Vec = Any.any_l () ])
    [ return (result: t_Vec) -> {[@expl:closure ensures] Seq.length (view result) = UInt64.t'int self.final.c0}
      {[@expl:closure hist_inv post] hist_inv self.current self.final}
      (! return {result}) ]
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  predicate produces (self: t_Range) (visited: Seq.seq UInt64.t) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  function produces_trans (a: t_Range) (ab: Seq.seq UInt64.t) (b: t_Range) (bc: Seq.seq UInt64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec:
    forall a: t_Range, ab: Seq.seq UInt64.t, b: t_Range, bc: Seq.seq UInt64.t, c: t_Range. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Range) : ()
  
  axiom produces_refl_spec: forall self: t_Range. produces self (Seq.empty: Seq.seq UInt64.t) self
  
  function produces_trans'0 (a: t_Range) (ab: Seq.seq UInt64.t) (b: t_Range) (bc: Seq.seq UInt64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_Range, ab: Seq.seq UInt64.t, b: t_Range, bc: Seq.seq UInt64.t, c: t_Range. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Range) : ()
  
  axiom produces_refl_spec'0: forall self: t_Range. produces self (Seq.empty: Seq.seq UInt64.t) self
  
  type t_MapInv = { t_MapInv__iter: t_Range; t_MapInv__func: closure3; t_MapInv__produced: Seq.seq UInt64.t }
  
  predicate precondition [@inline:trivial] (self: closure3) (args: tuple) = let {f0 = _0; f1 = _1} = args in true
  
  meta "rewrite_def" predicate precondition
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Range) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate completed (self: MutBorrow.t t_Range) =
    resolve'2 self /\ deep_model self.current.t_Range__start >= deep_model self.current.t_Range__end
  
  predicate next_precondition (iter: t_Range) (func: closure3) (produced: Seq.seq UInt64.t) =
    forall e: UInt64.t, i: t_Range. produces iter (Seq.singleton e) i -> precondition func { f0 = e; f1 = produced }
  
  predicate preservation (iter: t_Range) (func: closure3) =
    forall s: Seq.seq UInt64.t, e1: UInt64.t, e2: UInt64.t, f: MutBorrow.t closure3, b: t_Vec, i: t_Range. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current { f0 = e1; f1 = s }
      -> postcondition_mut f.current { f0 = e1; f1 = s } f.final b
      -> precondition f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize =
    forall iter: MutBorrow.t t_Range, func: closure3. completed iter
      -> next_precondition iter.final func (Seq.empty: Seq.seq UInt64.t) /\ preservation iter.final func
  
  predicate preservation_inv (iter: t_Range) (func: closure3) (produced: Seq.seq UInt64.t)
  
  axiom preservation_inv_spec: forall iter: t_Range, func: closure3, produced: Seq.seq UInt64.t. produced
        = (Seq.empty: Seq.seq UInt64.t) -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' (self: t_MapInv) =
    reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  predicate inv (_1: t_MapInv)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_MapInv__iter = iter; t_MapInv__func = func; t_MapInv__produced = produced} -> true
        end)
  
  let rec map_inv (self: t_Range) (func: closure3) (return (x: t_MapInv)) =
    {[@expl:map_inv requires #0] forall e: UInt64.t, i2: t_Range. produces self (Seq.singleton e) i2
      -> precondition func { f0 = e; f1 = Seq.empty: Seq.seq UInt64.t }}
    {[@expl:map_inv requires #1] reinitialize}
    {[@expl:map_inv requires #2] preservation self func}
    any
    [ return' (result: t_MapInv) -> {inv result}
      {result = { t_MapInv__iter = self; t_MapInv__func = func; t_MapInv__produced = Seq.empty: Seq.seq UInt64.t }}
      (! return {result}) ]
  
  type t_RawVec'0 = { t_RawVec__inner'0: t_RawVecInner; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0 = { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate resolve'3 [@inline:trivial] (_1: t_Range) = true
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_MapInv) =
    resolve'3 self.t_MapInv__iter /\ resolve'1 self.t_MapInv__func
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_1: t_MapInv) = resolve'4 _1
  
  meta "rewrite_def" predicate resolve'5
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq t_Vec) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t closure3). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq UInt64.t. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current { f0 = Seq.get s i;
                                                   f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  function produces_trans'1 (a: t_MapInv) (ab: Seq.seq t_Vec) (b: t_MapInv) (bc: Seq.seq t_Vec) (c: t_MapInv) : ()
  
  axiom produces_trans_spec'1:
    forall a: t_MapInv, ab: Seq.seq t_Vec, b: t_MapInv, bc: Seq.seq t_Vec, c: t_MapInv. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'1 (self: t_MapInv) : ()
  
  axiom produces_refl_spec'1: forall self: t_MapInv. produces'0 self (Seq.empty: Seq.seq t_Vec) self
  
  predicate completed'0 (self: MutBorrow.t t_MapInv) =
    self.final.t_MapInv__produced = (Seq.empty: Seq.seq UInt64.t)
    /\ completed (MutBorrow.borrow_logic self.current.t_MapInv__iter self.final.t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ self.current.t_MapInv__func = self.final.t_MapInv__func
  
  function view'0 (self: t_Vec'0) : Seq.seq t_Vec
  
  axiom view_spec'0: forall self: t_Vec'0. Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate from_iter_post (prod: Seq.seq t_Vec) (res: t_Vec'0) = prod = view'0 res
  
  let rec collect (self_: t_MapInv) (return (x: t_Vec'0)) = {[@expl:collect 'self_' type invariant] inv self_}
    any
    [ return' (result: t_Vec'0) -> {exists done': MutBorrow.t t_MapInv, prod: Seq.seq t_Vec. resolve'5 done'.final
        /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return {result}) ]
  
  type t_Board = { t_Board__size: UInt64.t; t_Board__field: t_Vec'0 }
  
  function index_logic'0 [@inline:trivial] (self: t_Vec'0) (ix: int) : t_Vec = Seq.get (view'0 self) ix
  
  meta "rewrite_def" function index_logic'0
  
  predicate wf (self: t_Board) =
    UInt64.t'int self.t_Board__size <= 1000
    /\ Seq.length (view'0 self.t_Board__field) = UInt64.t'int self.t_Board__size
    /\ (forall i: int. 0 <= i /\ i < UInt64.t'int self.t_Board__size
      -> Seq.length (view (index_logic'0 self.t_Board__field i)) = UInt64.t'int self.t_Board__size)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new (size: UInt64.t) (return (x: t_Board)) = {[@expl:new requires] UInt64.t'int size <= 1000}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- { t_Range__start = (0: UInt64.t); t_Range__end = size } ] s1
      | s1 = [ &_9 <- { c0 = size } ] s2
      | s2 = map_inv {_7} {_9} (fun (_ret: t_MapInv) -> [ &_6 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = collect {_6} (fun (_ret: t_Vec'0) -> [ &rows <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- { t_Board__size = size; t_Board__field = rows } ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_Board = Any.any_l ()
    | & size: UInt64.t = size
    | & rows: t_Vec'0 = Any.any_l ()
    | & _6: t_MapInv = Any.any_l ()
    | & _7: t_Range = Any.any_l ()
    | & _9: closure3 = Any.any_l () ])
    [ return (result: t_Board) -> {[@expl:new ensures #0] result.t_Board__size = size}
      {[@expl:new ensures #1] wf result}
      (! return {result}) ]
end
module M_06_knights_tour__qyi4580598960913230815__available (* Board *)
  use creusot.int.Int64
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Point = { t_Point__x: Int64.t; t_Point__y: Int64.t }
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Board = { t_Board__size: UInt64.t; t_Board__field: t_Vec }
  
  type t_RawVec'0 = { t_RawVec__inner'0: t_RawVecInner; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0 = { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec'0) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_Vec'0
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec'0) (out: t_Vec'0) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec index (self_: t_Vec) (ix: UInt64.t) (return (x: t_Vec'0)) = {[@expl:index requires] in_bounds ix (view self_)}
    any [ return' (result: t_Vec'0) -> {has_value ix (view self_) result} (! return {result}) ]
  
  predicate in_bounds'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds'0
  
  function view'0 (self: t_Vec'0) : Seq.seq UInt64.t
  
  axiom view_spec'0: forall self: t_Vec'0. Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate has_value'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value'0
  
  let rec index'0 (self_: t_Vec'0) (ix: UInt64.t) (return (x: UInt64.t)) =
    {[@expl:index requires] in_bounds'0 ix (view'0 self_)}
    any [ return' (result: UInt64.t) -> {has_value'0 ix (view'0 self_) result} (! return {result}) ]
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : t_Vec'0 = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  predicate wf (self: t_Board) =
    UInt64.t'int self.t_Board__size <= 1000
    /\ Seq.length (view self.t_Board__field) = UInt64.t'int self.t_Board__size
    /\ (forall i: int. 0 <= i /\ i < UInt64.t'int self.t_Board__size
      -> Seq.length (view'0 (index_logic self.t_Board__field i)) = UInt64.t'int self.t_Board__size)
  
  predicate in_bounds'1 (self: t_Board) (p: t_Point) =
    0 <= Int64.to_int p.t_Point__x
    /\ Int64.to_int p.t_Point__x < UInt64.t'int self.t_Board__size
    /\ 0 <= Int64.to_int p.t_Point__y /\ Int64.to_int p.t_Point__y < UInt64.t'int self.t_Board__size
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec available (self: t_Board) (p: t_Point) (return (x: bool)) = {[@expl:available requires] wf self}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_5 <- Int64.le (0: Int64.t) p.t_Point__x ] s1
      | s1 = any [ br0 -> {_5 = false} (! bb9) | br1 -> {_5} (! bb1) ] ]
    | bb1 = s0
      [ s0 = UInt64.of_int {Int64.to_int p.t_Point__x} (fun (_ret_from: UInt64.t) -> [ &_8 <- _ret_from ] s1)
      | s1 = [ &_7 <- UInt64.lt _8 self.t_Board__size ] s2
      | s2 = any [ br0 -> {_7 = false} (! bb9) | br1 -> {_7} (! bb2) ] ]
    | bb2 = s0
      [ s0 = [ &_11 <- Int64.le (0: Int64.t) p.t_Point__y ] s1
      | s1 = any [ br0 -> {_11 = false} (! bb9) | br1 -> {_11} (! bb3) ] ]
    | bb3 = s0
      [ s0 = UInt64.of_int {Int64.to_int p.t_Point__y} (fun (_ret_from: UInt64.t) -> [ &_14 <- _ret_from ] s1)
      | s1 = [ &_13 <- UInt64.lt _14 self.t_Board__size ] s2
      | s2 = any [ br0 -> {_13 = false} (! bb9) | br1 -> {_13} (! bb4) ] ]
    | bb4 = s0
      [ s0 = UInt64.of_int {Int64.to_int p.t_Point__x} (fun (_ret_from: UInt64.t) -> [ &_22 <- _ret_from ] s1)
      | s1 = index {self.t_Board__field} {_22} (fun (_ret: t_Vec'0) -> [ &_20 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = UInt64.of_int {Int64.to_int p.t_Point__y} (fun (_ret_from: UInt64.t) -> [ &_24 <- _ret_from ] s1)
      | s1 = index'0 {_20} {_24} (fun (_ret: UInt64.t) -> [ &_18 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0 [ s0 = [ &_0 <- _18 = (0: UInt64.t) ] s1 | s1 = bb12 ]
    | bb9 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_Board = self
    | & p: t_Point = p
    | & _5: bool = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: UInt64.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _18: UInt64.t = Any.any_l ()
    | & _20: t_Vec'0 = Any.any_l ()
    | & _22: UInt64.t = Any.any_l ()
    | & _24: UInt64.t = Any.any_l () ])
    [ return (result: bool) -> {[@expl:available ensures] result -> in_bounds'1 self p} (! return {result}) ]
end
module M_06_knights_tour__qyi4580598960913230815__count_degree (* Board *)
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type tuple = { f0: Int64.t; f1: Int64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq tuple
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : tuple = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  let rec moves (return (x: t_Vec)) = any
    [ return' (result: t_Vec) -> {Seq.length (view result) = 8}
      {forall i: int. 0 <= i /\ i < 8
        -> - 2 <= Int64.to_int (index_logic result i).f0
        /\ Int64.to_int (index_logic result i).f0 <= 2
        /\ - 2 <= Int64.to_int (index_logic result i).f1 /\ Int64.to_int (index_logic result i).f1 <= 2}
      (! return {result}) ]
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_ManuallyDrop = { t_ManuallyDrop__value: () }
  
  type t_IntoIter = {
    t_IntoIter__buf: t_NonNull'0;
    t_IntoIter__phantom: ();
    t_IntoIter__cap: UInt64.t;
    t_IntoIter__alloc: t_ManuallyDrop;
    t_IntoIter__ptr: t_NonNull'0;
    t_IntoIter__end: Opaque.ptr }
  
  function view'0 (self: t_IntoIter) : Seq.seq tuple
  
  let rec into_iter (self_: t_Vec) (return (x: t_IntoIter)) = any
    [ return' (result: t_IntoIter) -> {view self_ = view'0 result} (! return {result}) ]
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq tuple) (rhs: t_IntoIter) =
    view'0 self = Seq.(++) visited (view'0 rhs)
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq tuple) (b: t_IntoIter) (bc: Seq.seq tuple) (c: t_IntoIter) : () =
    ()
  
  axiom produces_trans_spec:
    forall a: t_IntoIter, ab: Seq.seq tuple, b: t_IntoIter, bc: Seq.seq tuple, c: t_IntoIter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_IntoIter) : () = ()
  
  axiom produces_refl_spec: forall self: t_IntoIter. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate inv (_1: t_IntoIter)
  
  axiom inv_axiom [@rewrite]: forall x: t_IntoIter [inv x]. inv x = true
  
  predicate inv'0 (_1: Seq.seq tuple)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq tuple [inv'0 x]. inv'0 x = true
  
  type t_Option = C_None | C_Some tuple
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_IntoIter) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_IntoIter) = resolve self /\ view'0 self.current = (Seq.empty: Seq.seq tuple)
  
  let rec next (self_: MutBorrow.t t_IntoIter) (return (x: t_Option)) = any
    [ return' (result: t_Option) -> {match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_IntoIter) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Point = { t_Point__x: Int64.t; t_Point__y: Int64.t }
  
  let rec mov (self: t_Point) (p: tuple) (return (x: t_Point)) = {[@expl:mov requires #0] - 10000
      <= Int64.to_int self.t_Point__x
    /\ Int64.to_int self.t_Point__x <= 10000}
    {[@expl:mov requires #1] - 10000 <= Int64.to_int self.t_Point__y /\ Int64.to_int self.t_Point__y <= 10000}
    {[@expl:mov requires #2] - 10000 <= Int64.to_int p.f0 /\ Int64.to_int p.f0 <= 10000}
    {[@expl:mov requires #3] - 10000 <= Int64.to_int p.f1 /\ Int64.to_int p.f1 <= 10000}
    any
    [ return' (result: t_Point) -> {Int64.to_int result.t_Point__x = Int64.to_int self.t_Point__x + Int64.to_int p.f0}
      {Int64.to_int result.t_Point__y = Int64.to_int self.t_Point__y + Int64.to_int p.f1}
      (! return {result}) ]
  
  type t_RawVec'0 = { t_RawVec__inner'0: t_RawVecInner; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0 = { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_Board = { t_Board__size: UInt64.t; t_Board__field: t_Vec'0 }
  
  type t_RawVec'1 = { t_RawVec__inner'1: t_RawVecInner; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1 = { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  function view'1 (self: t_Vec'0) : Seq.seq t_Vec'1
  
  axiom view_spec'0: forall self: t_Vec'0. Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  function view'2 (self: t_Vec'1) : Seq.seq UInt64.t
  
  axiom view_spec'1: forall self: t_Vec'1. Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  function index_logic'0 [@inline:trivial] (self: t_Vec'0) (ix: int) : t_Vec'1 = Seq.get (view'1 self) ix
  
  meta "rewrite_def" function index_logic'0
  
  predicate wf (self: t_Board) =
    UInt64.t'int self.t_Board__size <= 1000
    /\ Seq.length (view'1 self.t_Board__field) = UInt64.t'int self.t_Board__size
    /\ (forall i: int. 0 <= i /\ i < UInt64.t'int self.t_Board__size
      -> Seq.length (view'2 (index_logic'0 self.t_Board__field i)) = UInt64.t'int self.t_Board__size)
  
  predicate in_bounds (self: t_Board) (p: t_Point) =
    0 <= Int64.to_int p.t_Point__x
    /\ Int64.to_int p.t_Point__x < UInt64.t'int self.t_Board__size
    /\ 0 <= Int64.to_int p.t_Point__y /\ Int64.to_int p.t_Point__y < UInt64.t'int self.t_Board__size
  
  let rec available (self: t_Board) (p: t_Point) (return (x: bool)) = {[@expl:available requires] wf self}
    any [ return' (result: bool) -> {result -> in_bounds self p} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec count_degree (self: t_Board) (p: t_Point) (return (x: UInt64.t)) = {[@expl:count_degree requires #0] wf self}
    {[@expl:count_degree requires #1] in_bounds self p}
    (! bb0
    [ bb0 = s0 [ s0 = [ &count <- (0: UInt64.t) ] s1 | s1 = moves (fun (_ret: t_Vec) -> [ &_8 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = into_iter {_8} (fun (_ret: t_IntoIter) -> [ &iter <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq tuple ] s1 | s1 = bb5 ]
    | bb5 = bb5
      [ bb5 = {[@expl:for invariant] inv'0 produced}
        {[@expl:for invariant] inv iter}
        {[@expl:for invariant] produces iter_old produced iter}
        {[@expl:loop invariant] UInt64.t'int count <= Seq.length produced}
        (! s0)
        [ s0 = bb6 ]
        [ bb6 = s0
          [ s0 = MutBorrow.borrow_mut <t_IntoIter> {iter}
              (fun (_ret: MutBorrow.t t_IntoIter) -> [ &_21 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_IntoIter> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret: MutBorrow.t t_IntoIter) -> [ &_20 <- _ret ] [ &_21 <- { _21 with current = _ret.final } ] s2)
          | s2 = next {_20} (fun (_ret: t_Option) -> [ &_19 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve'0 _21}- s1
          | s1 = any [ br0 -> {_19 = C_None} (! bb18) | br1 (x0: tuple) -> {_19 = C_Some x0} (! bb11) ] ]
        | bb11 = s0
          [ s0 = v_Some {_19} (fun (r0: tuple) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_24 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb12 ]
        | bb12 = s0
          [ s0 = [ &produced <- _24 ] s1
          | s1 = [ &m <- __creusot_proc_iter_elem ] s2
          | s2 = [ &_30 <- m ] s3
          | s3 = mov {p} {_30} (fun (_ret: t_Point) -> [ &next'0 <- _ret ] s4)
          | s4 = bb13 ]
        | bb13 = s0 [ s0 = available {self} {next'0} (fun (_ret: bool) -> [ &_31 <- _ret ] s1) | s1 = bb14 ]
        | bb14 = any [ br0 -> {_31 = false} (! bb5) | br1 -> {_31} (! bb15) ]
        | bb15 = s0
          [ s0 = UInt64.add {count} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &count <- _ret ] s1) | s1 = bb5 ] ] ]
    | bb18 = s0 [ s0 = [ &_0 <- count ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self: t_Board = self
    | & p: t_Point = p
    | & count: UInt64.t = Any.any_l ()
    | & iter: t_IntoIter = Any.any_l ()
    | & _8: t_Vec = Any.any_l ()
    | & iter_old: t_IntoIter = Any.any_l ()
    | & produced: Seq.seq tuple = Any.any_l ()
    | & _19: t_Option = Any.any_l ()
    | & _20: MutBorrow.t t_IntoIter = Any.any_l ()
    | & _21: MutBorrow.t t_IntoIter = Any.any_l ()
    | & __creusot_proc_iter_elem: tuple = Any.any_l ()
    | & _24: Seq.seq tuple = Any.any_l ()
    | & m: tuple = Any.any_l ()
    | & next'0: t_Point = Any.any_l ()
    | & _30: tuple = Any.any_l ()
    | & _31: bool = Any.any_l () ]) [ return (result: UInt64.t) -> (! return {result}) ]
end
module M_06_knights_tour__qyi4580598960913230815__set (* Board *)
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use creusot.int.Int64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Board = { t_Board__size: UInt64.t; t_Board__field: t_Vec }
  
  type t_Point = { t_Point__x: Int64.t; t_Point__y: Int64.t }
  
  type t_RawVec'0 = { t_RawVec__inner'0: t_RawVecInner; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0 = { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec'0) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_Vec'0
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec'0) (out: t_Vec'0) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_Vec'0) (fin: Seq.seq t_Vec'0) =
    forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere
  
  let rec index_mut (self_: MutBorrow.t t_Vec) (ix: UInt64.t) (return (x: MutBorrow.t t_Vec'0)) =
    {[@expl:index_mut requires] in_bounds ix (view self_.current)}
    any
    [ return' (result: MutBorrow.t t_Vec'0) -> {has_value ix (view self_.current) result.current}
      {has_value ix (view self_.final) result.final}
      {resolve_elswhere ix (view self_.current) (view self_.final)}
      {Seq.length (view self_.final) = Seq.length (view self_.current)}
      (! return {result}) ]
  
  predicate in_bounds'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) = UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds'0
  
  function view'0 (self: t_Vec'0) : Seq.seq UInt64.t
  
  axiom view_spec'0: forall self: t_Vec'0. Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  predicate has_value'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value'0
  
  predicate resolve_elswhere'0 [@inline:trivial] (self: UInt64.t) (old': Seq.seq UInt64.t) (fin: Seq.seq UInt64.t) =
    forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere'0
  
  let rec index_mut'0 (self_: MutBorrow.t t_Vec'0) (ix: UInt64.t) (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] in_bounds'0 ix (view'0 self_.current)}
    any
    [ return' (result: MutBorrow.t UInt64.t) -> {has_value'0 ix (view'0 self_.current) result.current}
      {has_value'0 ix (view'0 self_.final) result.final}
      {resolve_elswhere'0 ix (view'0 self_.current) (view'0 self_.final)}
      {Seq.length (view'0 self_.final) = Seq.length (view'0 self_.current)}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t UInt64.t) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t UInt64.t) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Vec'0) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Vec'0) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Board) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_1: MutBorrow.t t_Board) = resolve'3 _1
  
  meta "rewrite_def" predicate resolve'4
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : t_Vec'0 = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  predicate wf (self: t_Board) =
    UInt64.t'int self.t_Board__size <= 1000
    /\ Seq.length (view self.t_Board__field) = UInt64.t'int self.t_Board__size
    /\ (forall i: int. 0 <= i /\ i < UInt64.t'int self.t_Board__size
      -> Seq.length (view'0 (index_logic self.t_Board__field i)) = UInt64.t'int self.t_Board__size)
  
  predicate in_bounds'1 (self: t_Board) (p: t_Point) =
    0 <= Int64.to_int p.t_Point__x
    /\ Int64.to_int p.t_Point__x < UInt64.t'int self.t_Board__size
    /\ 0 <= Int64.to_int p.t_Point__y /\ Int64.to_int p.t_Point__y < UInt64.t'int self.t_Board__size
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec set (self: MutBorrow.t t_Board) (p: t_Point) (v: UInt64.t) (return (x: ())) =
    {[@expl:set requires #0] wf self.current}
    {[@expl:set requires #1] in_bounds'1 self.current p}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_Vec> {self.current.t_Board__field}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_Vec) ->
            [ &_12 <- _ret ] [ &self <- { self with current = { self.current with t_Board__field = _ret.final } } ] s1)
      | s1 = UInt64.of_int {Int64.to_int p.t_Point__x} (fun (_ret_from: UInt64.t) -> [ &_13 <- _ret_from ] s2)
      | s2 = index_mut {_12} {_13} (fun (_ret: MutBorrow.t t_Vec'0) -> [ &_11 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <t_Vec'0> {_11.current} {MutBorrow.get_id _11}
          (fun (_ret: MutBorrow.t t_Vec'0) -> [ &_10 <- _ret ] [ &_11 <- { _11 with current = _ret.final } ] s1)
      | s1 = UInt64.of_int {Int64.to_int p.t_Point__y} (fun (_ret_from: UInt64.t) -> [ &_15 <- _ret_from ] s2)
      | s2 = index_mut'0 {_10} {_15} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_9 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_9 <- { _9 with current = v } ] s1
      | s1 = -{resolve'0 _9}- s2
      | s2 = -{resolve'2 _11}- s3
      | s3 = -{resolve'4 self}- s4
      | s4 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Board = self
    | & p: t_Point = p
    | & v: UInt64.t = v
    | & _9: MutBorrow.t UInt64.t = Any.any_l ()
    | & _10: MutBorrow.t t_Vec'0 = Any.any_l ()
    | & _11: MutBorrow.t t_Vec'0 = Any.any_l ()
    | & _12: MutBorrow.t t_Vec = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _15: UInt64.t = Any.any_l () ])
    [ return (result: ()) -> {[@expl:set ensures #0] wf self.final}
      {[@expl:set ensures #1] self.final.t_Board__size = self.current.t_Board__size}
      (! return {result}) ]
end
module M_06_knights_tour__min
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.slice.Slice64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Point = { t_Point__x: Int64.t; t_Point__y: Int64.t }
  
  type tuple = { f0: UInt64.t; f1: t_Point }
  
  type t_Option = C_None | C_Some tuple
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter = { t_Iter__ptr: t_NonNull'0; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq tuple
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 (self: t_Iter) : Slice64.slice tuple
  
  let rec into_iter (self_: t_Vec) (return (x: t_Iter)) = any
    [ return' (result: t_Iter) -> {view self_ = Slice64.view (view'0 result)} (! return {result}) ]
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : tuple = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [@inline:trivial] (self: Slice64.slice tuple) (ix: int) : tuple =
    Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic'0
  
  function to_ref_seq (self: Slice64.slice tuple) : Seq.seq tuple
  
  axiom to_ref_seq_spec: forall self: Slice64.slice tuple. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice tuple. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic'0 self i
  
  predicate produces (self: t_Iter) (visited: Seq.seq tuple) (tl: t_Iter) =
    to_ref_seq (view'0 self) = Seq.(++) visited (to_ref_seq (view'0 tl))
  
  function produces_trans (a: t_Iter) (ab: Seq.seq tuple) (b: t_Iter) (bc: Seq.seq tuple) (c: t_Iter) : () = ()
  
  axiom produces_trans_spec:
    forall a: t_Iter, ab: Seq.seq tuple, b: t_Iter, bc: Seq.seq tuple, c: t_Iter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Iter) : () = ()
  
  axiom produces_refl_spec: forall self: t_Iter. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate inv (_1: t_Iter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Iter [inv x]. inv x = true
  
  predicate inv'0 (_1: Seq.seq tuple)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq tuple [inv'0 x]. inv'0 x = true
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Iter) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_Iter) =
    resolve self /\ Slice64.view (view'0 self.current) = (Seq.empty: Seq.seq tuple)
  
  let rec next (self_: MutBorrow.t t_Iter) (return (x: t_Option)) = any
    [ return' (result: t_Option) -> {match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Iter) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec min (v: t_Vec) (return (x: t_Option)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &min'0 <- C_None ] s1 | s1 = into_iter {v} (fun (_ret: t_Iter) -> [ &iter <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq tuple ] s1 | s1 = bb4 ]
    | bb4 = bb4
      [ bb4 = {[@expl:for invariant] inv'0 produced}
        {[@expl:for invariant] inv iter}
        {[@expl:for invariant] produces iter_old produced iter}
        {[@expl:loop invariant] forall r: tuple. min'0 = C_Some r
          -> (exists i: int. 0 <= i /\ i < Seq.length (view v) /\ index_logic v i = r)}
        (! s0)
        [ s0 = bb5 ]
        [ bb5 = s0
          [ s0 = MutBorrow.borrow_mut <t_Iter> {iter}
              (fun (_ret: MutBorrow.t t_Iter) -> [ &_19 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Iter> {_19.current} {MutBorrow.get_id _19}
              (fun (_ret: MutBorrow.t t_Iter) -> [ &_18 <- _ret ] [ &_19 <- { _19 with current = _ret.final } ] s2)
          | s2 = next {_18} (fun (_ret: t_Option) -> [ &_17 <- _ret ] s3)
          | s3 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve'0 _19}- s1
          | s1 = any [ br0 -> {_17 = C_None} (! bb9) | br1 (x0: tuple) -> {_17 = C_Some x0} (! bb10) ] ]
        | bb10 = s0
          [ s0 = v_Some {_17} (fun (r0: tuple) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_22 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb11 ]
        | bb11 = s0
          [ s0 = [ &produced <- _22 ] s1
          | s1 = [ &x <- __creusot_proc_iter_elem ] s2
          | s2 = any [ br0 -> {min'0 = C_None} (! bb15) | br1 (x0: tuple) -> {min'0 = C_Some x0} (! bb14) ] ]
        | bb14 = s0
          [ s0 = v_Some {min'0} (fun (r0: tuple) -> [ &m <- r0 ] s1)
          | s1 = [ &_30 <- UInt64.lt x.f0 m.f0 ] s2
          | s2 = any [ br0 -> {_30 = false} (! bb4) | br1 -> {_30} (! bb16) ] ]
        | bb16 = s0 [ s0 = [ &_33 <- C_Some x ] s1 | s1 = [ &min'0 <- _33 ] s2 | s2 = bb4 ]
        | bb15 = s0 [ s0 = [ &_27 <- C_Some x ] s1 | s1 = [ &min'0 <- _27 ] s2 | s2 = bb4 ] ] ]
    | bb9 = s0 [ s0 = [ &_0 <- min'0 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Option = Any.any_l ()
    | & v: t_Vec = v
    | & min'0: t_Option = Any.any_l ()
    | & iter: t_Iter = Any.any_l ()
    | & iter_old: t_Iter = Any.any_l ()
    | & produced: Seq.seq tuple = Any.any_l ()
    | & _17: t_Option = Any.any_l ()
    | & _18: MutBorrow.t t_Iter = Any.any_l ()
    | & _19: MutBorrow.t t_Iter = Any.any_l ()
    | & __creusot_proc_iter_elem: tuple = Any.any_l ()
    | & _22: Seq.seq tuple = Any.any_l ()
    | & x: tuple = Any.any_l ()
    | & _27: t_Option = Any.any_l ()
    | & m: tuple = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _33: t_Option = Any.any_l () ])
    [ return (result: t_Option) -> {[@expl:min ensures] forall r: tuple. result = C_Some r
        -> (exists i: int. 0 <= i /\ i < Seq.length (view v) /\ index_logic v i = r)}
      (! return {result}) ]
end
module M_06_knights_tour__dumb_nonlinear_arith
  use creusot.int.UInt64
  use mach.int.Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : UInt64.t
  
  function dumb_nonlinear_arith (a: UInt64.t) : ()
  
  goal vc_dumb_nonlinear_arith: UInt64.t'int a <= 1000
    -> ([@expl:dumb_nonlinear_arith ensures] UInt64.t'int a * UInt64.t'int a <= 1000000)
end
module M_06_knights_tour__knights_tour
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  use creusot.int.Int64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Board = { t_Board__size: UInt64.t; t_Board__field: t_Vec }
  
  type t_RawVec'0 = { t_RawVec__inner'0: t_RawVecInner; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0 = { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_Vec'0
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 (self: t_Vec'0) : Seq.seq UInt64.t
  
  axiom view_spec'0: forall self: t_Vec'0. Seq.length (view'0 self) <= UInt64.t'int const_MAX
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : t_Vec'0 = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  predicate wf (self: t_Board) =
    UInt64.t'int self.t_Board__size <= 1000
    /\ Seq.length (view self.t_Board__field) = UInt64.t'int self.t_Board__size
    /\ (forall i: int. 0 <= i /\ i < UInt64.t'int self.t_Board__size
      -> Seq.length (view'0 (index_logic self.t_Board__field i)) = UInt64.t'int self.t_Board__size)
  
  let rec new (size: UInt64.t) (return (x: t_Board)) = {[@expl:new requires] UInt64.t'int size <= 1000}
    any [ return' (result: t_Board) -> {result.t_Board__size = size} {wf result} (! return {result}) ]
  
  type t_Point = { t_Point__x: Int64.t; t_Point__y: Int64.t }
  
  predicate in_bounds (self: t_Board) (p: t_Point) =
    0 <= Int64.to_int p.t_Point__x
    /\ Int64.to_int p.t_Point__x < UInt64.t'int self.t_Board__size
    /\ 0 <= Int64.to_int p.t_Point__y /\ Int64.to_int p.t_Point__y < UInt64.t'int self.t_Board__size
  
  let rec set (self: MutBorrow.t t_Board) (p: t_Point) (v: UInt64.t) (return (x: ())) =
    {[@expl:set requires #0] wf self.current}
    {[@expl:set requires #1] in_bounds self.current p}
    any
    [ return' (result: ()) -> {wf self.final}
      {self.final.t_Board__size = self.current.t_Board__size}
      (! return {result}) ]
  
  function dumb_nonlinear_arith (a: UInt64.t) : () = ()
  
  axiom dumb_nonlinear_arith_spec: forall a: UInt64.t. UInt64.t'int a <= 1000
      -> UInt64.t'int a * UInt64.t'int a <= 1000000
  
  type t_Range = { t_Range__start: UInt64.t; t_Range__end: UInt64.t }
  
  let rec into_iter (self_: t_Range) (return (x: t_Range)) = any
    [ return' (result: t_Range) -> {result = self_} (! return {result}) ]
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  predicate produces (self: t_Range) (visited: Seq.seq UInt64.t) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  function produces_trans (a: t_Range) (ab: Seq.seq UInt64.t) (b: t_Range) (bc: Seq.seq UInt64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec:
    forall a: t_Range, ab: Seq.seq UInt64.t, b: t_Range, bc: Seq.seq UInt64.t, c: t_Range. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_Range) : ()
  
  axiom produces_refl_spec: forall self: t_Range. produces self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate inv (_1: t_Range)
  
  axiom inv_axiom [@rewrite]: forall x: t_Range [inv x]. inv x = true
  
  predicate inv'0 (_1: Seq.seq UInt64.t)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq UInt64.t [inv'0 x]. inv'0 x = true
  
  type t_Option = C_None | C_Some UInt64.t
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Range) = self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate completed (self: MutBorrow.t t_Range) =
    resolve self /\ deep_model self.current.t_Range__start >= deep_model self.current.t_Range__end
  
  let rec next (self_: MutBorrow.t t_Range) (return (x: t_Option)) = any
    [ return' (result: t_Option) -> {match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Range) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  let rec v_Some (input: t_Option) (ret (field_0: UInt64.t)) = any
    [ good (field_0: UInt64.t) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: UInt64.t [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_RawVec'1 = { t_RawVec__inner'1: t_RawVecInner; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1 = { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  type tuple = { f0: UInt64.t; f1: t_Point }
  
  function view'1 (self: t_Vec'1) : Seq.seq tuple
  
  axiom view_spec'1: forall self: t_Vec'1. Seq.length (view'1 self) <= UInt64.t'int const_MAX
  
  let rec new'0 (return (x: t_Vec'1)) = any
    [ return' (result: t_Vec'1) -> {Seq.length (view'1 result) = 0} (! return {result}) ]
  
  type t_RawVec'2 = { t_RawVec__inner'2: t_RawVecInner; t_RawVec__qy95zmarker'2: () }
  
  type t_Vec'2 = { t_Vec__buf'2: t_RawVec'2; t_Vec__len'2: UInt64.t }
  
  type tuple'0 = { f0'0: Int64.t; f1'0: Int64.t }
  
  function view'2 (self: t_Vec'2) : Seq.seq tuple'0
  
  axiom view_spec'2: forall self: t_Vec'2. Seq.length (view'2 self) <= UInt64.t'int const_MAX
  
  function index_logic'0 [@inline:trivial] (self: t_Vec'2) (ix: int) : tuple'0 = Seq.get (view'2 self) ix
  
  meta "rewrite_def" function index_logic'0
  
  let rec moves (return (x: t_Vec'2)) = any
    [ return' (result: t_Vec'2) -> {Seq.length (view'2 result) = 8}
      {forall i: int. 0 <= i /\ i < 8
        -> - 2 <= Int64.to_int (index_logic'0 result i).f0'0
        /\ Int64.to_int (index_logic'0 result i).f0'0 <= 2
        /\ - 2 <= Int64.to_int (index_logic'0 result i).f1'0 /\ Int64.to_int (index_logic'0 result i).f1'0 <= 2}
      (! return {result}) ]
  
  type t_NonNull'0 = { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_ManuallyDrop = { t_ManuallyDrop__value: () }
  
  type t_IntoIter = {
    t_IntoIter__buf: t_NonNull'0;
    t_IntoIter__phantom: ();
    t_IntoIter__cap: UInt64.t;
    t_IntoIter__alloc: t_ManuallyDrop;
    t_IntoIter__ptr: t_NonNull'0;
    t_IntoIter__end: Opaque.ptr }
  
  function view'3 (self: t_IntoIter) : Seq.seq tuple'0
  
  let rec into_iter'0 (self_: t_Vec'2) (return (x: t_IntoIter)) = any
    [ return' (result: t_IntoIter) -> {view'2 self_ = view'3 result} (! return {result}) ]
  
  function index_logic'1 [@inline:trivial] (self: t_Vec'1) (ix: int) : tuple = Seq.get (view'1 self) ix
  
  meta "rewrite_def" function index_logic'1
  
  predicate produces'0 (self: t_IntoIter) (visited: Seq.seq tuple'0) (rhs: t_IntoIter) =
    view'3 self = Seq.(++) visited (view'3 rhs)
  
  function produces_trans'0 (a: t_IntoIter) (ab: Seq.seq tuple'0) (b: t_IntoIter) (bc: Seq.seq tuple'0) (c: t_IntoIter) : ()
   = ()
  
  axiom produces_trans_spec'0:
    forall a: t_IntoIter, ab: Seq.seq tuple'0, b: t_IntoIter, bc: Seq.seq tuple'0, c: t_IntoIter. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_IntoIter) : () = ()
  
  axiom produces_refl_spec'0: forall self: t_IntoIter. produces'0 self (Seq.empty: Seq.seq tuple'0) self
  
  predicate inv'1 (_1: t_IntoIter)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_IntoIter [inv'1 x]. inv'1 x = true
  
  predicate inv'2 (_1: Seq.seq tuple'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Seq.seq tuple'0 [inv'2 x]. inv'2 x = true
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_IntoIter) = self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate completed'0 (self: MutBorrow.t t_IntoIter) =
    resolve'1 self /\ view'3 self.current = (Seq.empty: Seq.seq tuple'0)
  
  let rec next'0 (self_: MutBorrow.t t_IntoIter) (return (x: t_Option'0)) = any
    [ return' (result: t_Option'0) -> {match result with
        | C_None'0 -> completed'0 self_
        | C_Some'0 v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return {result}) ]
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_IntoIter) = resolve'1 _1
  
  meta "rewrite_def" predicate resolve'2
  
  let rec v_Some'0 (input: t_Option'0) (ret (field_0: tuple'0)) = any
    [ good (field_0: tuple'0) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple'0 [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  let rec mov (self: t_Point) (p: tuple'0) (return (x: t_Point)) = {[@expl:mov requires #0] - 10000
      <= Int64.to_int self.t_Point__x
    /\ Int64.to_int self.t_Point__x <= 10000}
    {[@expl:mov requires #1] - 10000 <= Int64.to_int self.t_Point__y /\ Int64.to_int self.t_Point__y <= 10000}
    {[@expl:mov requires #2] - 10000 <= Int64.to_int p.f0'0 /\ Int64.to_int p.f0'0 <= 10000}
    {[@expl:mov requires #3] - 10000 <= Int64.to_int p.f1'0 /\ Int64.to_int p.f1'0 <= 10000}
    any
    [ return' (result: t_Point) -> {Int64.to_int result.t_Point__x = Int64.to_int self.t_Point__x + Int64.to_int p.f0'0}
      {Int64.to_int result.t_Point__y = Int64.to_int self.t_Point__y + Int64.to_int p.f1'0}
      (! return {result}) ]
  
  let rec available (self: t_Board) (p: t_Point) (return (x: bool)) = {[@expl:available requires] wf self}
    any [ return' (result: bool) -> {result -> in_bounds self p} (! return {result}) ]
  
  let rec count_degree (self: t_Board) (p: t_Point) (return (x: UInt64.t)) = {[@expl:count_degree requires #0] wf self}
    {[@expl:count_degree requires #1] in_bounds self p}
    any [ return' (result: UInt64.t) -> (! return {result}) ]
  
  let rec push (self_: MutBorrow.t t_Vec'1) (v: tuple) (return (x: ())) = any
    [ return' (result: ()) -> {view'1 self_.final = Seq.snoc (view'1 self_.current) v} (! return {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple
  
  let rec min (v: t_Vec'1) (return (x: t_Option'1)) = any
    [ return' (result: t_Option'1) -> {forall r: tuple. result = C_Some'1 r
        -> (exists i: int. 0 <= i /\ i < Seq.length (view'1 v) /\ index_logic'1 v i = r)}
      (! return {result}) ]
  
  let rec v_Some'1 (input: t_Option'1) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Some'1 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some'1 field_0: t_Option'1]. C_Some'1 field_0 <> input} (! {false} any) ]
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Board
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec knights_tour (size: UInt64.t) (x: UInt64.t) (y: UInt64.t) (return (x'0: t_Option'2)) =
    {[@expl:knights_tour requires #0] 0 < UInt64.t'int size /\ UInt64.t'int size <= 1000}
    {[@expl:knights_tour requires #1] UInt64.lt x size}
    {[@expl:knights_tour requires #2] UInt64.lt y size}
    (! bb0
    [ bb0 = s0 [ s0 = new {size} (fun (_ret: t_Board) -> [ &board <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = Int64.of_int {UInt64.t'int x} (fun (_ret_from: Int64.t) -> [ &_10 <- _ret_from ] s1)
      | s1 = Int64.of_int {UInt64.t'int y} (fun (_ret_from: Int64.t) -> [ &_12 <- _ret_from ] s2)
      | s2 = [ &p <- { t_Point__x = _10; t_Point__y = _12 } ] s3
      | s3 = MutBorrow.borrow_mut <t_Board> {board}
          (fun (_ret: MutBorrow.t t_Board) -> [ &_15 <- _ret ] [ &board <- _ret.final ] s4)
      | s4 = set {_15} {p} {(1: UInt64.t)} (fun (_ret: ()) -> [ &_14 <- _ret ] s5)
      | s5 = bb2 ]
    | bb2 = s0 [ s0 = [ &_17 <- dumb_nonlinear_arith size ] s1 | s1 = bb3 ]
    | bb3 = s0
      [ s0 = UInt64.mul {size} {size} (fun (_ret: UInt64.t) -> [ &_22 <- _ret ] s1)
      | s1 = [ &_21 <- { t_Range__start = (2: UInt64.t); t_Range__end = _22 } ] s2
      | s2 = into_iter {_21} (fun (_ret: t_Range) -> [ &iter <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = s0 [ s0 = [ &iter_old <- iter ] s1 | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq UInt64.t ] s1 | s1 = bb7 ]
    | bb7 = bb7
      [ bb7 = {[@expl:for invariant] inv'0 produced}
        {[@expl:for invariant] inv iter}
        {[@expl:for invariant] produces iter_old produced iter}
        {[@expl:loop invariant #0] board.t_Board__size = size}
        {[@expl:loop invariant #1] wf board}
        {[@expl:loop invariant #2] in_bounds board p}
        (! s0)
        [ s0 = bb8 ]
        [ bb8 = s0
          [ s0 = MutBorrow.borrow_mut <t_Range> {iter}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_39 <- _ret ] [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Range> {_39.current} {MutBorrow.get_id _39}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_38 <- _ret ] [ &_39 <- { _39 with current = _ret.final } ] s2)
          | s2 = next {_38} (fun (_ret: t_Option) -> [ &_37 <- _ret ] s3)
          | s3 = bb9 ]
        | bb9 = s0
          [ s0 = -{resolve'0 _39}- s1
          | s1 = any [ br0 -> {_37 = C_None} (! bb12) | br1 (x0: UInt64.t) -> {_37 = C_Some x0} (! bb13) ] ]
        | bb13 = s0
          [ s0 = v_Some {_37} (fun (r0: UInt64.t) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &_42 <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb14 ]
        | bb14 = s0
          [ s0 = [ &produced <- _42 ] s1
          | s1 = [ &step <- __creusot_proc_iter_elem ] s2
          | s2 = new'0 (fun (_ret: t_Vec'1) -> [ &candidates <- _ret ] s3)
          | s3 = bb15 ]
        | bb15 = s0 [ s0 = moves (fun (_ret: t_Vec'2) -> [ &_48 <- _ret ] s1) | s1 = bb16 ]
        | bb16 = s0 [ s0 = into_iter'0 {_48} (fun (_ret: t_IntoIter) -> [ &iter'0 <- _ret ] s1) | s1 = bb17 ]
        | bb17 = s0 [ s0 = [ &iter_old'0 <- iter'0 ] s1 | s1 = bb18 ]
        | bb18 = s0 [ s0 = [ &produced'0 <- Seq.empty: Seq.seq tuple'0 ] s1 | s1 = bb20 ]
        | bb20 = bb20
          [ bb20 = {[@expl:for invariant] inv'2 produced'0}
            {[@expl:for invariant] inv'1 iter'0}
            {[@expl:for invariant] produces'0 iter_old'0 produced'0 iter'0}
            {[@expl:loop invariant] forall i: int. 0 <= i /\ i < Seq.length (view'1 candidates)
              -> in_bounds board (index_logic'1 candidates i).f1}
            (! s0)
            [ s0 = bb21 ]
            [ bb21 = s0
              [ s0 = MutBorrow.borrow_mut <t_IntoIter> {iter'0}
                  (fun (_ret: MutBorrow.t t_IntoIter) -> [ &_60 <- _ret ] [ &iter'0 <- _ret.final ] s1)
              | s1 = MutBorrow.borrow_final <t_IntoIter> {_60.current} {MutBorrow.get_id _60}
                  (fun (_ret: MutBorrow.t t_IntoIter) ->
                    [ &_59 <- _ret ] [ &_60 <- { _60 with current = _ret.final } ] s2)
              | s2 = next'0 {_59} (fun (_ret: t_Option'0) -> [ &_58 <- _ret ] s3)
              | s3 = bb22 ]
            | bb22 = s0
              [ s0 = -{resolve'2 _60}- s1
              | s1 = any [ br0 -> {_58 = C_None'0} (! bb35) | br1 (x0: tuple'0) -> {_58 = C_Some'0 x0} (! bb26) ] ]
            | bb26 = s0
              [ s0 = v_Some'0 {_58} (fun (r0: tuple'0) -> [ &__creusot_proc_iter_elem'0 <- r0 ] s1)
              | s1 = [ &_63 <- Seq.(++) produced'0 (Seq.singleton __creusot_proc_iter_elem'0) ] s2
              | s2 = bb27 ]
            | bb27 = s0
              [ s0 = [ &produced'0 <- _63 ] s1
              | s1 = [ &m <- __creusot_proc_iter_elem'0 ] s2
              | s2 = {[@expl:assertion] forall r: Seq.seq tuple'0, a: Seq.seq tuple'0, b: Seq.seq tuple'0. r
                    = Seq.(++) a (Seq.(++) (Seq.singleton m) b) -> m = Seq.get r (Seq.length a)}
                s3
              | s3 = [ &_71 <- m ] s4
              | s4 = mov {p} {_71} (fun (_ret: t_Point) -> [ &adj <- _ret ] s5)
              | s5 = bb28 ]
            | bb28 = s0 [ s0 = available {board} {adj} (fun (_ret: bool) -> [ &_72 <- _ret ] s1) | s1 = bb29 ]
            | bb29 = any [ br0 -> {_72 = false} (! bb20) | br1 -> {_72} (! bb30) ]
            | bb30 = s0 [ s0 = count_degree {board} {adj} (fun (_ret: UInt64.t) -> [ &degree <- _ret ] s1) | s1 = bb31 ]
            | bb31 = s0
              [ s0 = [ &_80 <- { f0 = degree; f1 = adj } ] s1
              | s1 = MutBorrow.borrow_mut <t_Vec'1> {candidates}
                  (fun (_ret: MutBorrow.t t_Vec'1) -> [ &_79 <- _ret ] [ &candidates <- _ret.final ] s2)
              | s2 = push {_79} {_80} (fun (_ret: ()) -> [ &_78 <- _ret ] s3)
              | s3 = bb20 ] ] ]
        | bb35 = s0
          [ s0 = [ &_87 <- candidates ] s1
          | s1 = min {_87} (fun (_ret: t_Option'1) -> [ &_85 <- _ret ] s2)
          | s2 = bb36 ]
        | bb36 = any [ br0 -> {_85 = C_None'1} (! bb39) | br1 (x0: tuple) -> {_85 = C_Some'1 x0} (! bb40) ]
        | bb40 = s0
          [ s0 = v_Some'1 {_85} (fun (r0: tuple) -> [ &adj'0 <- r0.f1 ] s1)
          | s1 = [ &p <- adj'0 ] s2
          | s2 = MutBorrow.borrow_mut <t_Board> {board}
              (fun (_ret: MutBorrow.t t_Board) -> [ &_93 <- _ret ] [ &board <- _ret.final ] s3)
          | s3 = set {_93} {p} {step} (fun (_ret: ()) -> [ &_92 <- _ret ] s4)
          | s4 = bb7 ] ] ]
    | bb39 = s0 [ s0 = [ &_0 <- C_None'2 ] s1 | s1 = bb47 ]
    | bb12 = s0 [ s0 = [ &_0 <- C_Some'2 board ] s1 | s1 = bb47 ]
    | bb47 = return {_0} ]
    [ & _0: t_Option'2 = Any.any_l ()
    | & size: UInt64.t = size
    | & x: UInt64.t = x
    | & y: UInt64.t = y
    | & board: t_Board = Any.any_l ()
    | & p: t_Point = Any.any_l ()
    | & _10: Int64.t = Any.any_l ()
    | & _12: Int64.t = Any.any_l ()
    | & _14: () = Any.any_l ()
    | & _15: MutBorrow.t t_Board = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & iter: t_Range = Any.any_l ()
    | & _21: t_Range = Any.any_l ()
    | & _22: UInt64.t = Any.any_l ()
    | & iter_old: t_Range = Any.any_l ()
    | & produced: Seq.seq UInt64.t = Any.any_l ()
    | & _37: t_Option = Any.any_l ()
    | & _38: MutBorrow.t t_Range = Any.any_l ()
    | & _39: MutBorrow.t t_Range = Any.any_l ()
    | & __creusot_proc_iter_elem: UInt64.t = Any.any_l ()
    | & _42: Seq.seq UInt64.t = Any.any_l ()
    | & step: UInt64.t = Any.any_l ()
    | & candidates: t_Vec'1 = Any.any_l ()
    | & iter'0: t_IntoIter = Any.any_l ()
    | & _48: t_Vec'2 = Any.any_l ()
    | & iter_old'0: t_IntoIter = Any.any_l ()
    | & produced'0: Seq.seq tuple'0 = Any.any_l ()
    | & _58: t_Option'0 = Any.any_l ()
    | & _59: MutBorrow.t t_IntoIter = Any.any_l ()
    | & _60: MutBorrow.t t_IntoIter = Any.any_l ()
    | & __creusot_proc_iter_elem'0: tuple'0 = Any.any_l ()
    | & _63: Seq.seq tuple'0 = Any.any_l ()
    | & m: tuple'0 = Any.any_l ()
    | & adj: t_Point = Any.any_l ()
    | & _71: tuple'0 = Any.any_l ()
    | & _72: bool = Any.any_l ()
    | & degree: UInt64.t = Any.any_l ()
    | & _78: () = Any.any_l ()
    | & _79: MutBorrow.t t_Vec'1 = Any.any_l ()
    | & _80: tuple = Any.any_l ()
    | & _85: t_Option'1 = Any.any_l ()
    | & _87: t_Vec'1 = Any.any_l ()
    | & adj'0: t_Point = Any.any_l ()
    | & _92: () = Any.any_l ()
    | & _93: MutBorrow.t t_Board = Any.any_l () ]) [ return (result: t_Option'2) -> (! return {result}) ]
end
