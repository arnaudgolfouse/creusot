module M_test
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  type t_M_u32 = F UInt32.t | G UInt32.t
  
  let rec elim_G (input: t_M_u32) (ret (field2: UInt32.t)) = any
    [ good (field2: UInt32.t) -> {G field2 = input} (! ret {field2})
    | bad -> {forall field2: UInt32.t [G field2: t_M_u32]. G field2 <> input} (! {false} any) ]
  
  let rec elim_F (input: t_M_u32) (ret (field1: UInt32.t)) = any
    [ good (field1: UInt32.t) -> {F field1 = input} (! ret {field1})
    | bad -> {forall field1: UInt32.t [F field1: t_M_u32]. F field1 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test (o: t_M_u32) (return (x: bool)) = (! bb0
    [ bb0 = any [ br0 (x0: UInt32.t) -> {o = F x0} (! bb4) | br1 (x0: UInt32.t) -> {o = G x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_G {o} (fun (rfield2: UInt32.t) -> [ &field2 <- rfield2 ] s1)
      | s1 = [ &_0 <- field2 = (0: UInt32.t) ] s2
      | s2 = bb5 ]
    | bb4 = s0
      [ s0 = elim_F {o} (fun (rfield1: UInt32.t) -> [ &field1 <- rfield1 ] s1)
      | s1 = [ &_0 <- UInt32.gt field1 (0: UInt32.t) ] s2
      | s2 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & o: t_M_u32 = o
    | & field1: UInt32.t = Any.any_l ()
    | & field2: UInt32.t = Any.any_l () ]) [ return (result: bool) -> (! return {result}) ]
end
