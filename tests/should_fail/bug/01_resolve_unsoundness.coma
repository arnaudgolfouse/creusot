module M_01_resolve_unsoundness__make_vec_of_size
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq bool
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  let rec new (return' (x: t_Vec)) = any
    [ return''0 (result: t_Vec) -> {Seq.length (view result) = 0} (! return' {result}) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  let rec push (self_: MutBorrow.t t_Vec) (v: bool) (return' (x: ())) = any
    [ return''0 (result: ()) -> {view self_.final = Seq.snoc (view self_.current) v} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec make_vec_of_size (n: UInt64.t) (return' (x: t_Vec)) = (! bb0
    [ bb0 = s0 [ s0 = new (fun (_ret: t_Vec) -> [ &out <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &i <- (0: UInt64.t) ] s1 | s1 = bb2 ]
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:loop invariant] UInt64.le (0: UInt64.t) i /\ UInt64.le i n'0}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_10 <- UInt64.le i n'0 ] s1 | s1 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb4) ] ]
        | bb4 = s0
          [ s0 = MutBorrow.borrow_mut <t_Vec> {out}
              (fun (_ret: MutBorrow.t t_Vec) -> [ &_14 <- _ret ] [ &out <- _ret.final ] s1)
          | s1 = push {_14} {false} (fun (_ret: ()) -> [ &_13 <- _ret ] s2)
          | s2 = bb5 ]
        | bb5 = s0 [ s0 = UInt64.add {i} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &i <- _ret ] s1) | s1 = bb2'0 ] ] ]
    | bb6 = s0 [ s0 = [ &_0 <- out ] s1 | s1 = bb7 ]
    | bb7 = return''0 {_0} ]
    [ & _0: t_Vec = Any.any_l ()
    | & n'0: UInt64.t = n
    | & out: t_Vec = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & _14: MutBorrow.t t_Vec = Any.any_l () ])
    [ return''0 (result: t_Vec) -> {[@expl:make_vec_of_size ensures] Seq.length (view result) = UInt64.t'int n}
      (! return' {result}) ]
end
