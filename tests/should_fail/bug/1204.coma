module M_evil
  use mach.int.Int
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  function evil (x: int) : int
  
  goal vc_evil: false -> ([@expl:evil requires] false) /\ well_founded_relation_Int x (- x)
end
module M_wrong
  use mach.int.Int
  
  function evil (x: int) : int
  
  axiom evil_def: forall x: int. false -> evil x = evil (- x) + 1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function wrong : ()
  
  goal vc_wrong: ([@expl:evil requires] false)
    /\ ([@expl:evil requires] false)
    /\ evil 1 = evil (- 1) + 1
    && ([@expl:evil requires] false)
    /\ ([@expl:evil requires] false) /\ evil (- 1) = evil 1 + 1 && ([@expl:wrong ensures] false)
end
