module M_impl_MyTrait_for_unit__a (* <() as MyTrait> *)
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec a_unit (self: ()) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = return {_0} ] ] [ & _0: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:a ensures] result} (! return {result}) ]
end
module M_returns_iterator
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec returns_iterator (return (x: ())) = (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_main
  use creusot.prelude.Any
  
  type opaque
  
  predicate inv_opaque (_1: opaque)
  
  let rec returns_iterator (return (x: opaque)) = any
    [ return (result: opaque) -> {inv_opaque result} (! return {result}) ]
  
  predicate resolve_opaque (_1: opaque)
  
  predicate invariant_ref_opaque [@inline:trivial] (self: opaque) = inv_opaque self
  
  meta "rewrite_def" predicate invariant_ref_opaque
  
  predicate inv_ref_opaque [@inline:trivial] (_1: opaque) = invariant_ref_opaque _1
  
  meta "rewrite_def" predicate inv_ref_opaque
  
  predicate precondition_a (self: ()) (args: opaque)
  
  axiom precondition_fndef: forall args: opaque [precondition_a () args]. (let self = args in inv_ref_opaque self)
      -> precondition_a () args
  
  predicate postcondition_once_a (self: ()) (args: opaque) (result: bool)
  
  axiom postcondition_fndef:
    forall args: opaque, res: bool [postcondition_once_a () args res]. postcondition_once_a () args res
      -> (let self = args in true)
  
  let rec a_opaque (self: opaque) (return (x: bool)) = {[@expl:a requires] precondition_a () self}
    any [ return (result: bool) -> {postcondition_once_a () self result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec main (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = returns_iterator (fun (_ret: opaque) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_opaque _4} s1
      | s1 = -{resolve_opaque _4}- s2
      | s2 = a_opaque {_4} (fun (_ret: bool) -> [ &x <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0 [ s0 = {[@expl:assertion] x} s1 | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l () | & x: bool = Any.any_l () | & _4: opaque = Any.any_l () ])
    [ return (result: ()) -> {[@expl:main ensures] true} (! return {result}) ]
end
