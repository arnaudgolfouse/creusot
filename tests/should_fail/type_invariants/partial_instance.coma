module M_mk_s
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int32
  use creusot.prelude.Any
  
  predicate is_null_ptr_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  let rec null_T (return (x: Opaque.ptr)) = any
    [ return (result: Opaque.ptr) -> {is_null_ptr_T result} (! return {result}) ]
  
  type t_S_T = { f0: Int32.t; f1: Opaque.ptr }
  
  predicate inv_S_T (_1: t_S_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec mk_s_T (t: Int32.t) (return (x: t_S_T)) = (! bb0
    [ bb0 = s0 [ s0 = null_T (fun (_ret: Opaque.ptr) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { f0 = t; f1 = _5 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_S_T = Any.any_l () | & t: Int32.t = t | & _5: Opaque.ptr = Any.any_l () ])
    [ return (result: t_S_T) -> {[@expl:mk_s result type invariant] inv_S_T result}
      {[@expl:mk_s ensures] result.f0 = t}
      (! return {result}) ]
end
module M_evil
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_S_i32 = { f0: Int32.t; f1: Opaque.ptr }
  
  predicate invariant_S_i32 (self: t_S_i32) = Int32.to_int self.f0 = 0
  
  predicate inv_S_i32 (_1: t_S_i32)
  
  axiom inv_axiom [@rewrite]: forall x: t_S_i32 [inv_S_i32 x]. inv_S_i32 x = invariant_S_i32 x
  
  let rec mk_s_i32 (t: Int32.t) (return (x: t_S_i32)) = any
    [ return (result: t_S_i32) -> {inv_S_i32 result} {result.f0 = t} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec evil (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = mk_s_i32 {(1: Int32.t)} (fun (_ret: t_S_i32) -> [ &_s <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_S_i32 _s} s1 | s1 = {[@expl:assertion] false} s2 | s2 = return {_0} ] ]
    [ & _0: () = Any.any_l () | & _s: t_S_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
