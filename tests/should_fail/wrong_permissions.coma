module M_wrong_permissions__unknown_permcell_permission [#"wrong_permissions.rs" 9 0 9 88]
  let%span spermcell = "../../creusot-contracts/src/cell/permcell.rs" 166 15 166 37
  let%span spermcell'0 = "../../creusot-contracts/src/cell/permcell.rs" 167 14 167 30
  let%span spermcell'1 = "../../creusot-contracts/src/cell/permcell.rs" 34 4 34 26
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 100 8 100 22
  let%span smodel = "../../creusot-contracts/src/model.rs" 43 8 43 22
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_PermCell
  
  type t_PermCellOwn
  
  type t_Id
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function val' (self: t_PermCellOwn) : Int32.t
  
  function view [@inline:trivial] (self: t_PermCellOwn) : Int32.t = [%#spermcell'1] val' self
  
  meta "rewrite_def" function view
  
  function view'0 [@inline:trivial] (self: t_PermCellOwn) : Int32.t = [%#smodel] view self
  
  meta "rewrite_def" function view'0
  
  function view'1 [@inline:trivial] (self: t_PermCellOwn) : Int32.t = [%#sghost] view'0 self
  
  meta "rewrite_def" function view'1
  
  let rec borrow (self: t_PermCell) (perm: t_PermCellOwn) (return' (x: Int32.t)) =
    {[@expl:borrow requires] [%#spermcell] id self = id'0 perm}
    any [ return''0 (result: Int32.t) -> {[%#spermcell'0] result = view'1 perm} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec unknown_permcell_permission [#"wrong_permissions.rs" 9 0 9 88] (cell: t_PermCell) (perm: t_PermCellOwn)
    (return' (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = borrow {cell'0} {perm'0} (fun (_ret: Int32.t) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & cell'0: t_PermCell = cell
    | & perm'0: t_PermCellOwn = perm
    | & _3: Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_wrong_permissions__wrong_permcell_permission [#"wrong_permissions.rs" 13 0 13 34]
  let%span spermcell = "../../creusot-contracts/src/cell/permcell.rs" 96 14 96 44
  let%span spermcell'0 = "../../creusot-contracts/src/cell/permcell.rs" 97 14 97 35
  let%span spermcell'1 = "../../creusot-contracts/src/cell/permcell.rs" 166 15 166 37
  let%span spermcell'2 = "../../creusot-contracts/src/cell/permcell.rs" 167 14 167 30
  let%span spermcell'3 = "../../creusot-contracts/src/cell/permcell.rs" 34 4 34 26
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 139 14 139 32
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 100 8 100 22
  let%span smodel = "../../creusot-contracts/src/model.rs" 43 8 43 22
  let%span swrong_permissions = "wrong_permissions.rs" 14 34 14 38
  let%span swrong_permissions'0 = "wrong_permissions.rs" 15 34 15 38
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_PermCell
  
  type t_PermCellOwn
  
  type tuple = { _p0: t_PermCell; _p1: t_PermCellOwn }
  
  type t_Id
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function val' (self: t_PermCellOwn) : Int32.t
  
  function view [@inline:trivial] (self: t_PermCellOwn) : Int32.t = [%#spermcell'3] val' self
  
  meta "rewrite_def" function view
  
  let rec new (value: Int32.t) (return' (x: tuple)) = any
    [ return''0 (result: tuple) -> {[%#spermcell] id result._p0 = id'0 result._p1}
      {[%#spermcell'0] view result._p1 = value}
      (! return' {result}) ]
  
  let rec borrow (self: t_PermCellOwn) (return' (x: t_PermCellOwn)) = any
    [ return''0 (result: t_PermCellOwn) -> {[%#sghost] result = self} (! return' {result}) ]
  
  function view'0 [@inline:trivial] (self: t_PermCellOwn) : Int32.t = [%#smodel] view self
  
  meta "rewrite_def" function view'0
  
  function view'1 [@inline:trivial] (self: t_PermCellOwn) : Int32.t = [%#sghost'0] view'0 self
  
  meta "rewrite_def" function view'1
  
  let rec borrow'0 (self: t_PermCell) (perm: t_PermCellOwn) (return' (x: Int32.t)) =
    {[@expl:borrow requires] [%#spermcell'1] id self = id'0 perm}
    any [ return''0 (result: Int32.t) -> {[%#spermcell'2] result = view'1 perm} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec wrong_permcell_permission [#"wrong_permissions.rs" 13 0 13 34] (return' (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new {[%#swrong_permissions] (1: Int32.t)} (fun (_ret: tuple) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &cell <- _2._p0 ] s1
      | s1 = new {[%#swrong_permissions'0] (1: Int32.t)} (fun (_ret: tuple) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = [ &perm <- _4._p1 ] s1 | s1 = borrow {perm} (fun (_ret: t_PermCellOwn) -> [ &_7 <- _ret ] s2) | s2 = bb3 ]
    | bb3 = s0 [ s0 = borrow'0 {cell} {_7} (fun (_ret: Int32.t) -> [ &_5 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & cell: t_PermCell = Any.any_l ()
    | & _2: tuple = Any.any_l ()
    | & perm: t_PermCellOwn = Any.any_l ()
    | & _4: tuple = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _7: t_PermCellOwn = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_wrong_permissions__unknown_ptr_own_permission [#"wrong_permissions.rs" 21 0 21 77]
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span swrong_permissions = "wrong_permissions.rs" 21 51 21 55
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 136 40 136 43
  let%span sptr_own'0 = "../../creusot-contracts/src/ghost/ptr_own.rs" 132 15 132 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ghost/ptr_own.rs" 133 14 133 35
  let%span sptr_own'2 = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  
  use creusot.prelude.Opaque
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: Int32.t }
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate metadata_matches (_value: Int32.t) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : Int32.t
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant' [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own'2] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_0: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) = [%#sinvariant] inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_PtrOwn) = [%#sghost] inv'0 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'1 (_0: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''1 x
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return' (x: Int32.t)) =
    {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'1 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any [ return''0 (result: Int32.t) -> {[%#sptr_own'1] result = val' own} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec unknown_ptr_own_permission [#"wrong_permissions.rs" 21 0 21 77] (ptr'0: Opaque.ptr) (perm: t_PtrOwn)
    (return' (x: ())) = {[@expl:unknown_ptr_own_permission 'perm' type invariant] [%#swrong_permissions] inv'1 perm}
    (! bb0
    [ bb0 = s0 [ s0 = as_ref {ptr'1} {perm'0} (fun (_ret: Int32.t) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & ptr'1: Opaque.ptr = ptr'0
    | & perm'0: t_PtrOwn = perm
    | & _3: Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_wrong_permissions__wrong_ptr_own_permission [#"wrong_permissions.rs" 25 0 25 33]
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 140 19 140 23
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 140 4 140 37
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 139 14 139 32
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 118 8 118 18
  let%span swrong_permissions = "wrong_permissions.rs" 26 31 26 35
  let%span swrong_permissions'0 = "wrong_permissions.rs" 27 32 27 36
  let%span sptr_own = "../../creusot-contracts/src/ghost/ptr_own.rs" 55 4 55 52
  let%span sptr_own'0 = "../../creusot-contracts/src/ghost/ptr_own.rs" 54 14 54 64
  let%span sptr_own'1 = "../../creusot-contracts/src/ghost/ptr_own.rs" 136 40 136 43
  let%span sptr_own'2 = "../../creusot-contracts/src/ghost/ptr_own.rs" 132 15 132 31
  let%span sptr_own'3 = "../../creusot-contracts/src/ghost/ptr_own.rs" 133 14 133 35
  let%span sptr_own'4 = "../../creusot-contracts/src/ghost/ptr_own.rs" 44 4 44 26
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 99 14 99 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 101 8 101 35
  
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PtrOwn = { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: Int32.t }
  
  type tuple = { _p0: Opaque.ptr; _p1: t_PtrOwn }
  
  predicate is_null_logic (self: Opaque.ptr) = [%#sptr'0] Opaque.addr_logic_u64 self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self
      = (Opaque.addr_logic_u64 self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate metadata_matches (_value: Int32.t) (_metadata: ()) = true
  
  function val' (self: t_PtrOwn) : Int32.t
  
  function metadata_logic (_0: Opaque.ptr) : ()
  
  predicate invariant' [@inline:trivial] (self: t_PtrOwn) =
    [%#sptr_own'4] not is_null_logic (ptr self) /\ metadata_matches (val' self) (metadata_logic (ptr self))
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv (_0: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv x]. inv x
      = (invariant' x
      /\ match x with
        | {t_PtrOwn__ptr = ptr'0; t_PtrOwn__val = val''0} -> true
        end)
  
  predicate invariant''0 [@inline:trivial] (self: t_PtrOwn) = [%#sghost'2] inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate inv'1 (_0: tuple)
  
  axiom inv_axiom'1 [@rewrite]: forall x: tuple [inv'1 x]. inv'1 x = (let {_p0 = x0; _p1 = x1} = x in inv'0 x1)
  
  let rec new (v: Int32.t) (return' (x: tuple)) = any
    [ return''0 (result: tuple) -> {[%#sptr_own] inv'1 result}
      {[%#sptr_own'0] ptr result._p1 = result._p0 /\ val' result._p1 = v}
      (! return' {result}) ]
  
  predicate invariant''1 [@inline:trivial] (self: t_PtrOwn) = [%#sinvariant] inv'0 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_PtrOwn) = [%#sinvariant] inv self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: t_PtrOwn) = [%#sghost'2] inv'3 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''3 x
  
  let rec borrow (self: t_PtrOwn) (return' (x: t_PtrOwn)) = {[@expl:borrow 'self' type invariant] [%#sghost] inv'2 self}
    any
    [ return''0 (result: t_PtrOwn) -> {[%#sghost'0] inv'4 result} {[%#sghost'1] result = self} (! return' {result}) ]
  
  let rec as_ref (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return' (x: Int32.t)) =
    {[@expl:as_ref 'own' type invariant] [%#sptr_own'1] inv'4 own}
    {[@expl:as_ref requires] [%#sptr_own'2] ptr'0 = ptr own}
    any [ return''0 (result: Int32.t) -> {[%#sptr_own'3] result = val' own} (! return' {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec wrong_ptr_own_permission [#"wrong_permissions.rs" 25 0 25 33] (return' (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new {[%#swrong_permissions] (1: Int32.t)} (fun (_ret: tuple) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &ptr'0 <- _2._p0 ] s1
      | s1 = new {[%#swrong_permissions'0] (1: Int32.t)} (fun (_ret: tuple) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = [ &perm <- _4._p1 ] s1 | s1 = borrow {perm} (fun (_ret: t_PtrOwn) -> [ &_7 <- _ret ] s2) | s2 = bb3 ]
    | bb3 = s0 [ s0 = as_ref {ptr'0} {_7} (fun (_ret: Int32.t) -> [ &_5 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & ptr'0: Opaque.ptr = Any.any_l ()
    | & _2: tuple = Any.any_l ()
    | & perm: t_PtrOwn = Any.any_l ()
    | & _4: tuple = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _7: t_PtrOwn = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
