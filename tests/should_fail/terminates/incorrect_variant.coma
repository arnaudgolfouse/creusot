module M_incorrect_variant__incorrect_recursion
  use creusot.int.Int32
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_spec: forall x: Int32.t, y: Int32.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_spec: forall x: Int32.t, y: Int32.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int32.t) : ()
  
  axiom refl_spec: forall x: Int32.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec incorrect_recursion (x: Int32.t) (return (x'0: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_3 <- Int32.lt x (-10: Int32.t) ] s1 | s1 = any [ br0 -> {_3 = false} (! bb2) | br1 -> {_3} (! bb13) ] ]
    | bb2 = s0
      [ s0 = [ &_5 <- Int32.gt x (10: Int32.t) ] s1 | s1 = any [ br0 -> {_5 = false} (! bb5) | br1 -> {_5} (! bb13) ] ]
    | bb5 = s0
      [ s0 = [ &_9 <- x ] s1
      | s1 = [ &_10 <- (2: Int32.t) = (0: Int32.t) ] s2
      | s2 = {[@expl:remainder by zero] not _10} s3
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_11 <- (2: Int32.t) = (-1: Int32.t) ] s1
      | s1 = [ &_12 <- _9 = (-2147483648: Int32.t) ] s2
      | s2 = [ &_13 <- Bool.bw_and _11 _12 ] s3
      | s3 = {[@expl:Rem overflow] not _13} s4
      | s4 = bb7 ]
    | bb7 = s0
      [ s0 = Int32.rem {_9} {(2: Int32.t)} (fun (_ret: Int32.t) -> [ &_8 <- _ret ] s1)
      | s1 = [ &_7 <- _8 = (0: Int32.t) ] s2
      | s2 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ] ]
    | bb8 = s0
      [ s0 = Int32.add {x} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &_14 <- _ret ] s1)
      | s1 = incorrect_recursion {_14} (fun (_ret: ()) -> [ &_0 <- _ret ] s2)
      | s2 = bb13 ]
    | bb10 = s0
      [ s0 = Int32.sub {x} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &_16 <- _ret ] s1)
      | s1 = incorrect_recursion {_16} (fun (_ret: ()) -> [ &_0 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & x: Int32.t = x
    | & _3: bool = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: Int32.t = Any.any_l ()
    | & _9: Int32.t = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _16: Int32.t = Any.any_l () ]
    [ incorrect_recursion (x: Int32.t) (_ret (_r: ())) ->
    {[@expl:function variant] well_founded_relation function_variant x}
      incorrect_recursion {x} (_ret) ] [ function_variant: Int32.t = x ]) [ return (result: ()) -> (! return {result}) ]
end
module M_incorrect_variant__incorrect_recursion_logic
  use mach.int.Int
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  function incorrect_recursion_logic (x: int) : int
  
  goal vc_incorrect_recursion_logic: if x = 0 then
      [@expl:incorrect_recursion_logic ensures] 0 = 0
    else
      if Int.mod x 2 = 0 then
        well_founded_relation x (x + 1)
        /\ (incorrect_recursion_logic (x + 1) = 0
        -> ([@expl:incorrect_recursion_logic ensures] incorrect_recursion_logic (x + 1) = 0))
      else
        well_founded_relation x (x - 1)
        /\ (incorrect_recursion_logic (x - 1) = 0
        -> ([@expl:incorrect_recursion_logic ensures] incorrect_recursion_logic (x - 1) = 0))
    

end
module M_incorrect_variant__incorrect_loop_variant
  use creusot.int.Int32
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_spec: forall x: Int32.t, y: Int32.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_spec: forall x: Int32.t, y: Int32.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int32.t) : ()
  
  axiom refl_spec: forall x: Int32.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec incorrect_loop_variant (x: Int32.t) (return (x'0: ())) = (! bb0
    [ bb0 = bb1
    | bb1 = bb1invariant
      [ bb1 = {[@expl:loop variant] well_founded_relation variant_old_bb1 x} bb1invariant
      | bb1invariant = (! [ &variant_old_bb1 <- x ] s0
        [ s0 = bb2 ])
        [ bb2 = s0
          [ s0 = [ &_5 <- Int32.ge x (-10: Int32.t) ] s1
          | s1 = any [ br0 -> {_5 = false} (! bb12) | br1 -> {_5} (! bb3) ] ]
        | bb3 = s0
          [ s0 = [ &_7 <- Int32.le x (10: Int32.t) ] s1
          | s1 = any [ br0 -> {_7 = false} (! bb12) | br1 -> {_7} (! bb4) ] ]
        | bb4 = s0
          [ s0 = [ &_11 <- x ] s1
          | s1 = [ &_12 <- (2: Int32.t) = (0: Int32.t) ] s2
          | s2 = {[@expl:remainder by zero] not _12} s3
          | s3 = bb5 ]
        | bb5 = s0
          [ s0 = [ &_13 <- (2: Int32.t) = (-1: Int32.t) ] s1
          | s1 = [ &_14 <- _11 = (-2147483648: Int32.t) ] s2
          | s2 = [ &_15 <- Bool.bw_and _13 _14 ] s3
          | s3 = {[@expl:Rem overflow] not _15} s4
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = Int32.rem {_11} {(2: Int32.t)} (fun (_ret: Int32.t) -> [ &_10 <- _ret ] s1)
          | s1 = [ &_9 <- _10 = (0: Int32.t) ] s2
          | s2 = any [ br0 -> {_9 = false} (! bb8) | br1 -> {_9} (! bb7) ] ]
        | bb7 = s0 [ s0 = Int32.add {x} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &x <- _ret ] s1) | s1 = bb1 ]
        | bb8 = s0 [ s0 = Int32.sub {x} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &x <- _ret ] s1) | s1 = bb1 ] ] ]
    | bb12 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & x: Int32.t = x
    | & _5: bool = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: Int32.t = Any.any_l ()
    | & _11: Int32.t = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & variant_old_bb1: Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
