module M_incorrect_variant__incorrect_recursion [#"incorrect_variant.rs" 7 0 7 34]
  let%span sincorrect_variant = "incorrect_variant.rs" 8 11 8 14
  let%span sincorrect_variant'0 = "incorrect_variant.rs" 8 22 8 24
  let%span sincorrect_variant'1 = "incorrect_variant.rs" 9 18 9 19
  let%span sincorrect_variant'2 = "incorrect_variant.rs" 9 14 9 19
  let%span sincorrect_variant'3 = "incorrect_variant.rs" 9 23 9 24
  let%span sincorrect_variant'4 = "incorrect_variant.rs" 10 32 10 33
  let%span sincorrect_variant'5 = "incorrect_variant.rs" 12 32 12 33
  let%span sincorrect_variant'6 = "incorrect_variant.rs" 6 10 6 11
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 62 16 62 28
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 240 16 246 17
  
  use creusot.int.Int32
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = [%#sord'12] if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_spec: forall x: Int32.t, y: Int32.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_spec: forall x: Int32.t, y: Int32.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_spec: forall x: Int32.t, y: Int32.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: Int32.t) : ()
  
  axiom refl_spec: forall x: Int32.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int32.t, y: Int32.t. [%#sord'2] Int32.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int32.t, y: Int32.t. [%#sord'1] Int32.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int32.t, y: Int32.t. [%#sord'0] Int32.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int32.t, y: Int32.t. [%#sord] Int32.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int32.t) (other: Int32.t) =
    [%#swell_founded] Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec incorrect_recursion [#"incorrect_variant.rs" 7 0 7 34] (x: Int32.t) (return' (x'0: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_3 <- Int32.lt x'0 ([%#sincorrect_variant] (-10: Int32.t)) ] s1
      | s1 = any [ br0 -> {_3 = false} (! bb2) | br1 -> {_3} (! bb13) ] ]
    | bb2 = s0
      [ s0 = [ &_5 <- Int32.gt x'0 ([%#sincorrect_variant'0] (10: Int32.t)) ] s1
      | s1 = any [ br0 -> {_5 = false} (! bb5) | br1 -> {_5} (! bb13) ] ]
    | bb5 = s0
      [ s0 = [ &_9 <- x'0 ] s1
      | s1 = [ &_10 <- ([%#sincorrect_variant'1] (2: Int32.t)) = ([%#sincorrect_variant'2] (0: Int32.t)) ] s2
      | s2 = {[@expl:remainder by zero] [%#sincorrect_variant'2] not _10} s3
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_11 <- ([%#sincorrect_variant'1] (2: Int32.t)) = ([%#sincorrect_variant'2] (-1: Int32.t)) ] s1
      | s1 = [ &_12 <- _9 = ([%#sincorrect_variant'2] (-2147483648: Int32.t)) ] s2
      | s2 = [ &_13 <- Bool.bw_and _11 _12 ] s3
      | s3 = {[@expl:Rem overflow] [%#sincorrect_variant'2] not _13} s4
      | s4 = bb7 ]
    | bb7 = s0
      [ s0 = Int32.rem {_9} {[%#sincorrect_variant'1] (2: Int32.t)} (fun (_ret: Int32.t) -> [ &_8 <- _ret ] s1)
      | s1 = [ &_7 <- _8 = ([%#sincorrect_variant'3] (0: Int32.t)) ] s2
      | s2 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ] ]
    | bb8 = s0
      [ s0 = Int32.add {x'0} {[%#sincorrect_variant'4] (1: Int32.t)} (fun (_ret: Int32.t) -> [ &_14 <- _ret ] s1)
      | s1 = incorrect_recursion'0 {_14} (fun (_ret: ()) -> [ &_0 <- _ret ] s2)
      | s2 = bb13 ]
    | bb10 = s0
      [ s0 = Int32.sub {x'0} {[%#sincorrect_variant'5] (1: Int32.t)} (fun (_ret: Int32.t) -> [ &_16 <- _ret ] s1)
      | s1 = incorrect_recursion'0 {_16} (fun (_ret: ()) -> [ &_0 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & x'0: Int32.t = x
    | & _3: bool = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: Int32.t = Any.any_l ()
    | & _9: Int32.t = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _16: Int32.t = Any.any_l () ]
    [ incorrect_recursion'0 (x'0: Int32.t) (_ret (_r: ())) ->
    {[@expl:function variant] well_founded_relation function_variant x'0}
      incorrect_recursion {x'0} (_ret) ] [ function_variant: Int32.t = [%#sincorrect_variant'6] x ])
    [ return''0 (result: ()) -> (! return' {result}) ]
end
module M_incorrect_variant__incorrect_recursion_logic [#"incorrect_variant.rs" 19 0 19 47]
  let%span sincorrect_variant = "incorrect_variant.rs" 17 10 17 11
  let%span sincorrect_variant'0 = "incorrect_variant.rs" 18 10 18 21
  let%span sincorrect_variant'1 = "incorrect_variant.rs" 20 4 26 5
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use mach.int.Int
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) =
    [%#swell_founded] self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  function incorrect_recursion_logic [#"incorrect_variant.rs" 19 0 19 47] (x'0: int) : int
  
  goal vc_incorrect_recursion_logic: if x = 0 then
      [@expl:incorrect_recursion_logic ensures] [%#sincorrect_variant'0] 0 = 0
    else
      if Int.mod x 2 = 0 then
        well_founded_relation ([%#sincorrect_variant] x) ([%#sincorrect_variant] x + 1)
        /\ (([%#sincorrect_variant'0] incorrect_recursion_logic (x + 1) = 0)
        -> ([@expl:incorrect_recursion_logic ensures] [%#sincorrect_variant'0] incorrect_recursion_logic (x + 1) = 0))
      else
        well_founded_relation ([%#sincorrect_variant] x) ([%#sincorrect_variant] x - 1)
        /\ (([%#sincorrect_variant'0] incorrect_recursion_logic (x - 1) = 0)
        -> ([@expl:incorrect_recursion_logic ensures] [%#sincorrect_variant'0] incorrect_recursion_logic (x - 1) = 0))
    

end
module M_incorrect_variant__incorrect_loop_variant [#"incorrect_variant.rs" 30 0 30 41]
  let%span sincorrect_variant = "incorrect_variant.rs" 31 14 31 15
  let%span sincorrect_variant'0 = "incorrect_variant.rs" 32 15 32 18
  let%span sincorrect_variant'1 = "incorrect_variant.rs" 32 27 32 29
  let%span sincorrect_variant'2 = "incorrect_variant.rs" 33 15 33 16
  let%span sincorrect_variant'3 = "incorrect_variant.rs" 33 11 33 16
  let%span sincorrect_variant'4 = "incorrect_variant.rs" 33 20 33 21
  let%span sincorrect_variant'5 = "incorrect_variant.rs" 33 29 33 30
  let%span sincorrect_variant'6 = "incorrect_variant.rs" 33 45 33 46
  let%span swell_founded = "../../../creusot-contracts/src/logic/well_founded.rs" 62 16 62 28
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 124 39 124 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 128 39 128 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 132 39 132 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 136 39 136 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 140 39 140 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 144 40 144 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 145 40 145 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 146 39 146 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 150 40 150 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 151 39 151 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 160 39 160 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 240 16 246 17
  
  use creusot.int.Int32
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = [%#sord'12] if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_spec: forall x: Int32.t, y: Int32.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_spec: forall x: Int32.t, y: Int32.t. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_spec: forall x: Int32.t, y: Int32.t. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
      -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: Int32.t) : ()
  
  axiom refl_spec: forall x: Int32.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int32.t, y: Int32.t. [%#sord'2] Int32.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int32.t, y: Int32.t. [%#sord'1] Int32.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int32.t, y: Int32.t. [%#sord'0] Int32.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int32.t, y: Int32.t. [%#sord] Int32.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int32.t) (other: Int32.t) =
    [%#swell_founded] Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec incorrect_loop_variant [#"incorrect_variant.rs" 30 0 30 41] (x: Int32.t) (return' (x'0: ())) = (! bb0
    [ bb0 = bb1
    | bb1 = bb1invariant
      [ bb1'0 = {[@expl:loop variant] well_founded_relation variant_old_bb1 x'0} bb1invariant
      | bb1invariant = (! [ &variant_old_bb1 <- [%#sincorrect_variant] x'0 ] s0
        [ s0 = bb2 ])
        [ bb2 = s0
          [ s0 = [ &_5 <- Int32.ge x'0 ([%#sincorrect_variant'0] (-10: Int32.t)) ] s1
          | s1 = any [ br0 -> {_5 = false} (! bb12) | br1 -> {_5} (! bb3) ] ]
        | bb3 = s0
          [ s0 = [ &_7 <- Int32.le x'0 ([%#sincorrect_variant'1] (10: Int32.t)) ] s1
          | s1 = any [ br0 -> {_7 = false} (! bb12) | br1 -> {_7} (! bb4) ] ]
        | bb4 = s0
          [ s0 = [ &_11 <- x'0 ] s1
          | s1 = [ &_12 <- ([%#sincorrect_variant'2] (2: Int32.t)) = ([%#sincorrect_variant'3] (0: Int32.t)) ] s2
          | s2 = {[@expl:remainder by zero] [%#sincorrect_variant'3] not _12} s3
          | s3 = bb5 ]
        | bb5 = s0
          [ s0 = [ &_13 <- ([%#sincorrect_variant'2] (2: Int32.t)) = ([%#sincorrect_variant'3] (-1: Int32.t)) ] s1
          | s1 = [ &_14 <- _11 = ([%#sincorrect_variant'3] (-2147483648: Int32.t)) ] s2
          | s2 = [ &_15 <- Bool.bw_and _13 _14 ] s3
          | s3 = {[@expl:Rem overflow] [%#sincorrect_variant'3] not _15} s4
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = Int32.rem {_11} {[%#sincorrect_variant'2] (2: Int32.t)} (fun (_ret: Int32.t) -> [ &_10 <- _ret ] s1)
          | s1 = [ &_9 <- _10 = ([%#sincorrect_variant'4] (0: Int32.t)) ] s2
          | s2 = any [ br0 -> {_9 = false} (! bb8) | br1 -> {_9} (! bb7) ] ]
        | bb7 = s0
          [ s0 = Int32.add {x'0} {[%#sincorrect_variant'5] (1: Int32.t)} (fun (_ret: Int32.t) -> [ &x'0 <- _ret ] s1)
          | s1 = bb1'0 ]
        | bb8 = s0
          [ s0 = Int32.sub {x'0} {[%#sincorrect_variant'6] (1: Int32.t)} (fun (_ret: Int32.t) -> [ &x'0 <- _ret ] s1)
          | s1 = bb1'0 ] ] ]
    | bb12 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & x'0: Int32.t = x
    | & _5: bool = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: Int32.t = Any.any_l ()
    | & _11: Int32.t = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & variant_old_bb1: Int32.t = Any.any_l () ]) [ return''0 (result: ()) -> (! return' {result}) ]
end
