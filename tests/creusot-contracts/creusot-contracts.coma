module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 70 14 70 45
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 71 27 71 29
  let%span sarray'1 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self : t_IntoIter) (visited : Seq.seq t_T) (o : t_IntoIter)
  
   =
    [%#sarray'1] view self = Seq.(++) visited (view o)
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (self'0 : t_IntoIter) : ()
  
  goal vc_produces_refl : [%#sarray] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 75 15 75 32
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 76 15 76 32
  let%span sarray'1 = "../../creusot-contracts/src/std/array.rs" 77 14 77 42
  let%span sarray'2 = "../../creusot-contracts/src/std/array.rs" 78 91 78 93
  let%span sarray'3 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self : t_IntoIter) (visited : Seq.seq t_T) (o : t_IntoIter)
  
   =
    [%#sarray'3] view self = Seq.(++) visited (view o)
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (a'0 : t_IntoIter) (ab'0 : Seq.seq t_T) (b'0 : t_IntoIter) (bc'0 : Seq.seq t_T) (c'0 : t_IntoIter) : ()
  
  
  goal vc_produces_trans : ([%#sarray] produces a ab b)
   -> ([%#sarray'0] produces b bc c)  -> ([%#sarray'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 97 14 97 45
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 98 27 98 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self : t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple'0) (x : tuple'0) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'1
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view self) k = C_Some'0 v
     -> (exists k1 : t_K . deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  constant self  : t_IntoIter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (self'0 : t_IntoIter'0) : ()
  
  
  goal vc_produces_refl : [%#shash_map] produces self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 102 15 102 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 103 15 103 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 104 14 104 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 106 24 106 102
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 106 8 106 104
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self : t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple'0) (x : tuple'0) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'1
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view self) k = C_Some'0 v
     -> (exists k1 : t_K . deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq tuple'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq tuple'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (a'0 : t_IntoIter'0) (ab'0 : Seq.seq tuple'0) (b'0 : t_IntoIter'0) (bc'0 : Seq.seq tuple'0) (c'0 : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans : ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 149 14 149 45
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 150 27 150 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self : t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self : t_Iter'0) (visited : Seq.seq tuple) (o : t_Iter'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view self) k = C_Some v
     -> (exists k2 : t_K . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  constant self  : t_Iter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (self'0 : t_Iter'0) : ()
  
  
  goal vc_produces_refl : [%#shash_map] produces self (Seq.empty : Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 154 15 154 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 155 15 155 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 156 14 156 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 158 24 158 102
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 158 8 158 104
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self : t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self : t_Iter'0) (visited : Seq.seq tuple) (o : t_Iter'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view self) k = C_Some v
     -> (exists k2 : t_K . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Iter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (a'0 : t_Iter'0) (ab'0 : Seq.seq tuple) (b'0 : t_Iter'0) (bc'0 : Seq.seq tuple) (c'0 : t_Iter'0) : ()
  
  
  goal vc_produces_trans : ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 201 14 201 45
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 202 27 202 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self : t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self : t_IterMut'0) (visited : Seq.seq tuple) (o : t_IterMut'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : MutBorrow.t t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : MutBorrow.t t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view self) k = C_Some v
     -> (exists k1 : t_K . deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  constant self  : t_IterMut'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (self'0 : t_IterMut'0) : ()
  
  
  goal vc_produces_refl : [%#shash_map] produces self (Seq.empty : Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 206 15 206 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 207 15 207 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 208 14 208 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 210 24 210 102
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 210 8 210 104
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self : t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self : t_IterMut'0) (visited : Seq.seq tuple) (o : t_IterMut'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : MutBorrow.t t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : MutBorrow.t t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view self) k = C_Some v
     -> (exists k1 : t_K . deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_IterMut'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (a'0 : t_IterMut'0) (ab'0 : Seq.seq tuple) (b'0 : t_IterMut'0) (bc'0 : Seq.seq tuple) (c'0 : t_IterMut'0) : ()
  
  
  goal vc_produces_trans : ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 86 8 86 82
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 101 20 101 108
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 102 20 102 98
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_I
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/model.rs" 15 4 15 34] (self : t_I) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq'1] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_I) (visited : Seq.seq t_T) (end' : t_I)
  
   =
    [%#shash_set'5] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  function concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17]  : () =
    [%#sseq'0] ()
  
  axiom concat_contains_spec : [%#sseq] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function get [#"../../creusot-contracts/src/logic/seq.rs" 82 4 84 17] (self : Seq.seq t_T) (ix : int) : t_Option =
    [%#sseq'2] if 0 <= ix /\ ix < Seq.length self then C_Some (Seq.get self ix) else C_None
  
  constant a  : t_I
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_I
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_I
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a'0 : t_I) (ab'0 : Seq.seq t_T) (b'0 : t_I) (bc'0 : Seq.seq t_T) (c'0 : t_I) : ()
  
  
  goal vc_set_produces_trans : ([%#shash_set] set_produces a ab b)
   -> ([%#shash_set'0] set_produces b bc c)
   -> ([%#sseq] forall a'0 : Seq.seq t_T, b'0 : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a'0 b'0) x
  = contains'0 a'0 x
  \/ contains'0 b'0 x)
   -> (let _ = concat_contains in ([%#shash_set'2] forall i : int, x : t_T . Seq.length ab <= i
  /\ get (Seq.(++) ab bc) i = C_Some x  -> contains'0 bc x)
  && (let _ = () in let _ = () in ([%#shash_set'3] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in let _ = () in [%#shash_set'1] set_produces a (Seq.(++) ab bc) c)))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 120 14 120 45
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 121 27 121 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self : t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_IntoIter'1) (visited : Seq.seq t_T) (end' : t_IntoIter'1)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self : t_IntoIter'1) (visited : Seq.seq t_T) (o : t_IntoIter'1)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  constant self  : t_IntoIter'1
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (self'0 : t_IntoIter'1) : ()
  
  
  goal vc_produces_refl : [%#shash_set] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 125 15 125 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 126 15 126 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 127 14 127 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 129 8 129 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self : t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq'1] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_IntoIter'1) (visited : Seq.seq t_T) (end' : t_IntoIter'1)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self : t_IntoIter'1) (visited : Seq.seq t_T) (o : t_IntoIter'1)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  function concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17]  : () =
    [%#sseq'0] ()
  
  axiom concat_contains_spec : [%#sseq] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a : t_IntoIter'1) (ab : Seq.seq t_T) (b : t_IntoIter'1) (bc : Seq.seq t_T) (c : t_IntoIter'1) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec : forall a : t_IntoIter'1, ab : Seq.seq t_T, b : t_IntoIter'1, bc : Seq.seq t_T, c : t_IntoIter'1 . ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  constant a  : t_IntoIter'1
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter'1
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter'1
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (a'0 : t_IntoIter'1) (ab'0 : Seq.seq t_T) (b'0 : t_IntoIter'1) (bc'0 : Seq.seq t_T) (c'0 : t_IntoIter'1) : ()
  
  
  goal vc_produces_trans : ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 159 14 159 45
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 160 27 160 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self : t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Iter'1) (visited : Seq.seq t_T) (end' : t_Iter'1)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self : t_Iter'1) (visited : Seq.seq t_T) (o : t_Iter'1)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  constant self  : t_Iter'1
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (self'0 : t_Iter'1) : ()
  
  
  goal vc_produces_refl : [%#shash_set] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 164 15 164 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 165 15 165 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 166 14 166 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 168 8 168 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self : t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq'1] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Iter'1) (visited : Seq.seq t_T) (end' : t_Iter'1)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self : t_Iter'1) (visited : Seq.seq t_T) (o : t_Iter'1)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  function concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17]  : () =
    [%#sseq'0] ()
  
  axiom concat_contains_spec : [%#sseq] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a : t_Iter'1) (ab : Seq.seq t_T) (b : t_Iter'1) (bc : Seq.seq t_T) (c : t_Iter'1) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec : forall a : t_Iter'1, ab : Seq.seq t_T, b : t_Iter'1, bc : Seq.seq t_T, c : t_Iter'1 . ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  constant a  : t_Iter'1
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter'1
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter'1
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (a'0 : t_Iter'1) (ab'0 : Seq.seq t_T) (b'0 : t_Iter'1) (bc'0 : Seq.seq t_T) (c'0 : t_Iter'1) : ()
  
  
  goal vc_produces_trans : ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 217 14 217 45
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 218 27 218 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self : t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Intersection) (visited : Seq.seq t_T) (end' : t_Intersection)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self : t_Intersection) (visited : Seq.seq t_T) (o : t_Intersection)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  constant self  : t_Intersection
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (self'0 : t_Intersection) : ()
  
  
  goal vc_produces_refl : [%#shash_set] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 222 15 222 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 223 15 223 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 224 14 224 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 226 8 226 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self : t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq'1] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Intersection) (visited : Seq.seq t_T) (end' : t_Intersection)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self : t_Intersection) (visited : Seq.seq t_T) (o : t_Intersection)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  function concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17]  : () =
    [%#sseq'0] ()
  
  axiom concat_contains_spec : [%#sseq] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a : t_Intersection) (ab : Seq.seq t_T) (b : t_Intersection) (bc : Seq.seq t_T) (c : t_Intersection) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec : forall a : t_Intersection, ab : Seq.seq t_T, b : t_Intersection, bc : Seq.seq t_T, c : t_Intersection . ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  constant a  : t_Intersection
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Intersection
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Intersection
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (a'0 : t_Intersection) (ab'0 : Seq.seq t_T) (b'0 : t_Intersection) (bc'0 : Seq.seq t_T) (c'0 : t_Intersection) : ()
  
  
  goal vc_produces_trans : ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 245 14 245 45
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 246 27 246 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self : t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Difference) (visited : Seq.seq t_T) (end' : t_Difference)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self : t_Difference) (visited : Seq.seq t_T) (o : t_Difference)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  constant self  : t_Difference
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (self'0 : t_Difference) : ()
  
  
  goal vc_produces_refl : [%#shash_set] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 250 15 250 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 251 15 251 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 252 14 252 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 254 8 254 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self : t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq'1] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Difference) (visited : Seq.seq t_T) (end' : t_Difference)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self : t_Difference) (visited : Seq.seq t_T) (o : t_Difference)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  function concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17]  : () =
    [%#sseq'0] ()
  
  axiom concat_contains_spec : [%#sseq] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a : t_Difference) (ab : Seq.seq t_T) (b : t_Difference) (bc : Seq.seq t_T) (c : t_Difference) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec : forall a : t_Difference, ab : Seq.seq t_T, b : t_Difference, bc : Seq.seq t_T, c : t_Difference . ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  constant a  : t_Difference
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Difference
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Difference
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (a'0 : t_Difference) (ab'0 : Seq.seq t_T) (b'0 : t_Difference) (bc'0 : Seq.seq t_T) (c'0 : t_Difference) : ()
  
  
  goal vc_produces_trans : ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialEq_Rhs_ne_body [#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 17 16 17 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 18 29 18 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 17 26 17 75
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 11 16 11 17
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 12 29 12 32
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom [@rewrite] : forall x : t_Self_ [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_ [inv'1 x] . inv'1 x = invariant''0 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Rhs) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs [inv'3 x] . inv'3 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Rhs) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Rhs [inv'4 x] . inv'4 x = invariant''2 x
  
  type t_DeepModelTy
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs) : t_DeepModelTy
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'2 self
  
  function deep_model'4 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'3 self
  
  let rec eq (self_:t_Self_) (rhs:t_Rhs) (return'  (x:bool))= {[@expl:eq 'self_' type invariant] [%#scmp'2] inv'1 self_}
    {[@expl:eq 'rhs' type invariant] [%#scmp'3] inv'4 rhs}
    any
    [ return''0 (result:bool)-> {[%#scmp'4] result = (deep_model'1 self_ = deep_model'4 rhs)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialEq_Rhs_ne_body[#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18] (self_:t_Self_) (rhs:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'self_' type invariant] [%#scmp] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'rhs' type invariant] [%#scmp'0] inv'3 rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq {self_'0} {rhs'0} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- not _4 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : bool = Any.any_l () | & self_'0 : t_Self_ = self_ | & rhs'0 : t_Rhs = rhs | & _4 : bool = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <> deep_model'3 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 39 29 39 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 38 48 38 52
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 35 16 35 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 36 29 36 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  axiom inv_axiom [@rewrite] : forall x : t_Rhs [inv'0 x] . inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_ [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : t_Option)
  
  
  axiom postcondition_fndef : forall args : tuple, res : t_Option [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb8) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb4) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_'0 : t_Self_ = self_
    | & other'0 : t_Rhs = other
    | & _4 : t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body ensures] [%#scmp'3] result
      = lt_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_le_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 47 29 47 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 46 66 46 70
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 43 16 43 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 44 29 44 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 43 26 43 77
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  axiom inv_axiom [@rewrite] : forall x : t_Rhs [inv'0 x] . inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_ [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : t_Option)
  
  
  axiom postcondition_fndef : forall args : tuple, res : t_Option [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_le_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb8) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb4) | br1 -> {r0 = C_Equal} (! bb4) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_'0 : t_Self_ = self_
    | & other'0 : t_Rhs = other
    | & _4 : t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body ensures] [%#scmp'3] result
      = le_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 55 29 55 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 54 51 54 55
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 51 16 51 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 52 29 52 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 51 26 51 76
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  axiom inv_axiom [@rewrite] : forall x : t_Rhs [inv'0 x] . inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_ [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : t_Option)
  
  
  axiom postcondition_fndef : forall args : tuple, res : t_Option [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb8) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb4) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_'0 : t_Self_ = self_
    | & other'0 : t_Rhs = other
    | & _4 : t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body ensures] [%#scmp'3] result
      = gt_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 63 29 63 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 62 69 62 73
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 59 16 59 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 60 29 60 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 59 26 59 77
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rhs)
  
  axiom inv_axiom [@rewrite] : forall x : t_Rhs [inv'0 x] . inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_ [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : t_Option)
  
  
  axiom postcondition_fndef : forall args : tuple, res : t_Option [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb8) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb4) | br2 -> {r0 = C_Greater} (! bb4) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_'0 : t_Self_ = self_
    | & other'0 : t_Rhs = other
    | & _4 : t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body ensures] [%#scmp'3] result
      = ge_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_max_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 75 16 75 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 80 29 80 30
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 80 41 80 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 75 26 75 66
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 76 26 76 63
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 77 26 77 55
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 78 26 78 77
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 79 26 79 79
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom [@rewrite] : forall x : t_Self_ [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : bool)
  
  
  axiom postcondition_fndef : forall args : tuple, res : bool [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = le_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec le (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:le requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Self_)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_max_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18] (self_:t_Self_) (o:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_max_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_max_body 'o' type invariant] [%#scmp'0] inv o}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = le {self_'0} {o'0} (fun (_ret:bool) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_8 = false} (! bb8) | br1 -> {_8} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- o'0 ] s3
      | s3 = bb9 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv o'0} s1 | s1 = -{resolve o'0}- s2 | s2 =  [ &_0 <- self_'0 ] s3 | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0 : t_Self_ = Any.any_l () | & self_'0 : t_Self_ = self_ | & o'0 : t_Self_ = o | & _8 : bool = Any.any_l () ]
    
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_max_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #0] [%#scmp'2] ge_log (deep_model result) (deep_model self_)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #1] [%#scmp'3] ge_log (deep_model result) (deep_model o)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #2] [%#scmp'4] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #3] [%#scmp'5] le_log (deep_model self_) (deep_model o)
       -> result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #4] [%#scmp'6] lt_log (deep_model o) (deep_model self_)
       -> result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_min_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 84 16 84 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 89 29 89 30
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 89 41 89 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 84 26 84 66
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 85 26 85 63
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 86 26 86 55
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 87 26 87 79
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 88 26 88 77
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom [@rewrite] : forall x : t_Self_ [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : bool)
  
  
  axiom postcondition_fndef : forall args : tuple, res : bool [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = lt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec lt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:lt requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Self_)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_min_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18] (self_:t_Self_) (o:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_min_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_min_body 'o' type invariant] [%#scmp'0] inv o}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = lt {self_'0} {o'0} (fun (_ret:bool) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_8 = false} (! bb8) | br1 -> {_8} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv o'0} s1 | s1 = -{resolve o'0}- s2 | s2 =  [ &_0 <- self_'0 ] s3 | s3 = bb9 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- o'0 ] s3
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0 : t_Self_ = Any.any_l () | & self_'0 : t_Self_ = self_ | & o'0 : t_Self_ = o | & _8 : bool = Any.any_l () ]
    
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_min_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #0] [%#scmp'2] le_log (deep_model result) (deep_model self_)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #1] [%#scmp'3] le_log (deep_model result) (deep_model o)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #2] [%#scmp'4] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #3] [%#scmp'5] lt_log (deep_model self_) (deep_model o)
       -> result = self_}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #4] [%#scmp'6] le_log (deep_model o) (deep_model self_)
       -> result = o}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_clamp_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 93 16 93 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 102 31 102 34
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 102 42 102 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 93 27 93 63
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 102 56 102 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 94 26 94 65
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 95 26 95 65
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 96 26 96 74
  let%span scmp'7 = "../../creusot-contracts/src/std/cmp.rs" 97 26 101 41
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Self_)
  
  axiom inv_axiom [@rewrite] : forall x : t_Self_ [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : bool)
  
  
  axiom postcondition_fndef : forall args : tuple, res : bool [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = gt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec gt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:gt requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Self_)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef'0 : forall args : tuple [precondition'0 () args] . (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition'0 () args
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : bool)
  
  
  axiom postcondition_fndef'0 : forall args : tuple, res : bool [postcondition_once'0 () args res] . postcondition_once'0 () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = lt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec lt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:lt requires] precondition'0 () { _p0 = self_;
                                                                                                           _p1 = other }}
    any
    [ return''0 (result:bool)-> {postcondition_once'0 () { _p0 = self_; _p1 = other } result} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_clamp_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18] (self_:t_Self_) (min:t_Self_) (max:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_clamp_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'min' type invariant] [%#scmp'0] inv min}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'max' type invariant] [%#scmp'1] inv max}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body requires] [%#scmp'2] le_log (deep_model min) (deep_model max)}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = gt {self_'0} {max'0} (fun (_ret:bool) ->  [ &_9 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_9 = false} (! bb8) | br1 -> {_9} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv min'0} s1
      | s1 = -{resolve min'0}- s2
      | s2 = {[@expl:type invariant] inv self_'0} s3
      | s3 = -{resolve self_'0}- s4
      | s4 =  [ &_0 <- max'0 ] s5
      | s5 = bb13 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv max'0} s1
      | s1 = -{resolve max'0}- s2
      | s2 = lt {self_'0} {min'0} (fun (_ret:bool) ->  [ &_12 <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- min'0 ] s3
      | s3 = bb12 ]
    
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv min'0} s1
      | s1 = -{resolve min'0}- s2
      | s2 =  [ &_0 <- self_'0 ] s3
      | s3 = bb12 ]
    
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0 : t_Self_ = Any.any_l ()
    | & self_'0 : t_Self_ = self_
    | & min'0 : t_Self_ = min
    | & max'0 : t_Self_ = max
    | & _9 : bool = Any.any_l ()
    | & _12 : bool = Any.any_l () ]
    
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_clamp_body result type invariant] [%#scmp'3] inv result}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #0] [%#scmp'4] ge_log (deep_model result) (deep_model min)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #1] [%#scmp'5] le_log (deep_model result) (deep_model max)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #2] [%#scmp'6] result = self_ \/ result = min \/ result = max}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #3] [%#scmp'7] if gt_log (deep_model self_) (deep_model max) then
        result = max
      else
        if lt_log (deep_model self_) (deep_model min) then result = min else result = self_
      }
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_max_body [#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66]
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 112 22 112 24
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 112 29 112 31
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 112 39 112 40
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 107 22 107 60
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 108 22 108 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 109 22 109 50
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 110 22 110 73
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 111 22 111 72
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_T
  
  type tuple  =
    { _p0: t_T; _p1: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = o} = args in inv o
  /\ inv self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : t_T)
  
  
  axiom postcondition_fndef : forall args : tuple, res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = o} = args in (lt_log (deep_model o) (deep_model self_)  -> res = self_)
  /\ (le_log (deep_model self_) (deep_model o)  -> res = o)
  /\ (res = self_ \/ res = o)
  /\ ge_log (deep_model res) (deep_model o) /\ ge_log (deep_model res) (deep_model self_) /\ inv res)
  
  let rec max (self_:t_T) (o:t_T) (return'  (x:t_T))= {[@expl:max requires] precondition () { _p0 = self_; _p1 = o }}
    any [ return''0 (result:t_T)-> {postcondition_once () { _p0 = self_; _p1 = o } result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_max_body[#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66] (v1:t_T) (v2:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_cmp_max_body 'v1' type invariant] [%#scmp] inv v1}
    {[@expl:extern_spec_std_cmp_max_body 'v2' type invariant] [%#scmp'0] inv v2}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = max {v1'0} {v2'0} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return''0 {_0} ]
    ) [ & _0 : t_T = Any.any_l () | & v1'0 : t_T = v1 | & v2'0 : t_T = v2 ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_cmp_max_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_max_body ensures #0] [%#scmp'2] ge_log (deep_model result) (deep_model v1)}
      {[@expl:extern_spec_std_cmp_max_body ensures #1] [%#scmp'3] ge_log (deep_model result) (deep_model v2)}
      {[@expl:extern_spec_std_cmp_max_body ensures #2] [%#scmp'4] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #3] [%#scmp'5] le_log (deep_model v1) (deep_model v2)
       -> result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #4] [%#scmp'6] lt_log (deep_model v2) (deep_model v1)
       -> result = v1}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_min_body [#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66]
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 123 22 123 24
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 123 29 123 31
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 123 39 123 40
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 118 22 118 60
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 119 22 119 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 120 22 120 50
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 121 22 121 72
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 122 22 122 73
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_T
  
  type tuple  =
    { _p0: t_T; _p1: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : tuple)
  
  axiom precondition_fndef : forall args : tuple [precondition () args] . (let {_p0 = self_ ; _p1 = o} = args in inv o
  /\ inv self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy) (other : t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  axiom eq_cmp_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym2_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom antisym1_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy) (y : t_DeepModelTy) (z : t_DeepModelTy) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_DeepModelTy, y : t_DeepModelTy, z : t_DeepModelTy, o : t_Ordering . ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy) : ()
  
  axiom refl_spec : forall x : t_DeepModelTy . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'2] gt_log x y
  = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy) (o : t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy) (y : t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec : forall x : t_DeepModelTy, y : t_DeepModelTy . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : tuple) (result : t_T)
  
  
  axiom postcondition_fndef : forall args : tuple, res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = o} = args in (le_log (deep_model o) (deep_model self_)  -> res = o)
  /\ (lt_log (deep_model self_) (deep_model o)  -> res = self_)
  /\ (res = self_ \/ res = o)
  /\ le_log (deep_model res) (deep_model o) /\ le_log (deep_model res) (deep_model self_) /\ inv res)
  
  let rec min (self_:t_T) (o:t_T) (return'  (x:t_T))= {[@expl:min requires] precondition () { _p0 = self_; _p1 = o }}
    any [ return''0 (result:t_T)-> {postcondition_once () { _p0 = self_; _p1 = o } result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_min_body[#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66] (v1:t_T) (v2:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_cmp_min_body 'v1' type invariant] [%#scmp] inv v1}
    {[@expl:extern_spec_std_cmp_min_body 'v2' type invariant] [%#scmp'0] inv v2}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = min {v1'0} {v2'0} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return''0 {_0} ]
    ) [ & _0 : t_T = Any.any_l () | & v1'0 : t_T = v1 | & v2'0 : t_T = v2 ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_cmp_min_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_min_body ensures #0] [%#scmp'2] le_log (deep_model result) (deep_model v1)}
      {[@expl:extern_spec_std_cmp_min_body ensures #1] [%#scmp'3] le_log (deep_model result) (deep_model v2)}
      {[@expl:extern_spec_std_cmp_min_body ensures #2] [%#scmp'4] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_min_body ensures #3] [%#scmp'5] lt_log (deep_model v1) (deep_model v2)
       -> result = v1}
      {[@expl:extern_spec_std_cmp_min_body ensures #4] [%#scmp'6] le_log (deep_model v2) (deep_model v1)
       -> result = v2}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 155 14 155 64
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 156 36 156 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Reverse) (o : t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Greater
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (x'0 : t_Reverse) (y'0 : t_Reverse) : ()
  
  
  goal vc_cmp_le_log : [%#scmp] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 160 14 160 61
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 161 36 161 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Reverse) (o : t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Less
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (x'0 : t_Reverse) (y'0 : t_Reverse) : ()
  
  
  goal vc_cmp_lt_log : [%#scmp] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 165 14 165 61
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 166 36 166 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Reverse) (o : t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Less
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (x'0 : t_Reverse) (y'0 : t_Reverse) : ()
  
  
  goal vc_cmp_ge_log : [%#scmp] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 170 14 170 64
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 171 36 171 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Reverse) (o : t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Greater
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (x'0 : t_Reverse) (y'0 : t_Reverse) : ()
  
  
  goal vc_cmp_gt_log : [%#scmp] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 175 14 175 45
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 21 176 23
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  function refl'0 [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (x'0 : t_Reverse) : ()
  
  goal vc_refl : [%#scmp] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 180 15 180 32
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 181 15 181 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 14 182 31
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 183 53 183 55
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'3] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  constant z  : t_Reverse
  
  constant o  : t_Ordering
  
  function trans'0 [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (x'0 : t_Reverse) (y'0 : t_Reverse) (z'0 : t_Reverse) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#scmp] cmp_log'0 x y = o)  -> ([%#scmp'0] cmp_log'0 y z = o)  -> ([%#scmp'1] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1 [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 187 15 187 45
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 188 14 188 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 189 34 189 36
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'2] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function antisym1'0 [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (x'0 : t_Reverse) (y'0 : t_Reverse) : ()
  
  goal vc_antisym1 : ([%#scmp] cmp_log'0 x y = C_Less)  -> ([%#scmp'0] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2 [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 193 15 193 48
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 194 14 194 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 195 34 195 36
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'2] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function antisym2'0 [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (x'0 : t_Reverse) (y'0 : t_Reverse) : ()
  
  goal vc_antisym2 : ([%#scmp] cmp_log'0 x y = C_Greater)  -> ([%#scmp'0] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 199 14 199 59
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 200 32 200 34
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function eq_cmp'0 [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (x'0 : t_Reverse) (y'0 : t_Reverse) : ()
  
  goal vc_eq_cmp : [%#scmp] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl [#"../../creusot-contracts/src/std/deque.rs" 175 4 175 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 174 14 174 45
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 175 27 175 29
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 168 12 168 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 81 14 81 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 80
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'1] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'2] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 83 4 83 35] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec : forall self : Slice64.slice t_T . ([%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'0] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 152 4 152 33] (self : t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 166 4 166 65] (self : t_Iter'0) (visited : Seq.seq t_T) (tl : t_Iter'0)
  
   =
    [%#sdeque'1] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  constant self  : t_Iter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/deque.rs" 175 4 175 26] (self'0 : t_Iter'0) : ()
  
  goal vc_produces_refl : [%#sdeque] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans [#"../../creusot-contracts/src/std/deque.rs" 182 4 182 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 179 15 179 32
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 180 15 180 32
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 181 14 181 42
  let%span sdeque'2 = "../../creusot-contracts/src/std/deque.rs" 182 91 182 93
  let%span sdeque'3 = "../../creusot-contracts/src/std/deque.rs" 168 12 168 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 81 14 81 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 80
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'1] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'2] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 83 4 83 35] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec : forall self : Slice64.slice t_T . ([%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'0] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 152 4 152 33] (self : t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 166 4 166 65] (self : t_Iter'0) (visited : Seq.seq t_T) (tl : t_Iter'0)
  
   =
    [%#sdeque'3] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/deque.rs" 182 4 182 90] (a'0 : t_Iter'0) (ab'0 : Seq.seq t_T) (b'0 : t_Iter'0) (bc'0 : Seq.seq t_T) (c'0 : t_Iter'0) : ()
  
  
  goal vc_produces_trans : ([%#sdeque] produces a ab b)
   -> ([%#sdeque'0] produces b bc c)  -> ([%#sdeque'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_assert_unchecked_body [#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 7 23 7 27
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_assert_unchecked_body[#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1] (cond:bool) (return'  (x:()))= {[@expl:extern_spec_std_hint_assert_unchecked_body requires] [%#shint] cond}
    (! bb0 [ bb0 = return''0 {_0} ] ) [ & _0 : () = Any.any_l () ]  [ return''0 (result:())-> (! return' {result}) ] 
end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_black_box_body [#"../../creusot-contracts/src/std/hint.rs" 12 12 12 42]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 12 28 12 33
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 12 41 12 42
  let%span shint'1 = "../../creusot-contracts/src/std/hint.rs" 11 22 11 37
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_black_box_body[#"../../creusot-contracts/src/std/hint.rs" 12 12 12 42] (dummy:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_hint_black_box_body 'dummy' type invariant] [%#shint] inv dummy}
    (! bb0 [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- dummy'0 ] s1 | s1 = bb2 ]  | bb2 = return''0 {_0} ] )
    [ & _0 : t_T = Any.any_l () | & dummy'0 : t_T = dummy ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_hint_black_box_body result type invariant] [%#shint'0] inv result}
      {[@expl:extern_spec_std_hint_black_box_body ensures] [%#shint'1] result = dummy}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_spin_loop_body [#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 17 23 17 27
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 18 22 18 26
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_spin_loop_body[#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1] (return'  (x:()))= {[@expl:extern_spec_std_hint_spin_loop_body requires] [%#shint] true}
    (! bb0 [ bb0 = return''0 {_0} ] ) [ & _0 : () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_hint_spin_loop_body ensures] [%#shint'0] true}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_unreachable_unchecked_body [#"../../creusot-contracts/src/std/hint.rs" 23 12 23 50]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 80 8 80 13
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 22 23 22 28
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 23 49 23 50
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 79 4 79 30] (self : ()) =
    [%#sinvariant] false
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : ())
  
  axiom inv_axiom [@rewrite] : forall x : () [inv x] . inv x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_unreachable_unchecked_body[#"../../creusot-contracts/src/std/hint.rs" 23 12 23 50] (return'  (x:()))= {[@expl:extern_spec_std_hint_unreachable_unchecked_body requires] [%#shint] false}
    (! bb0 [ bb0 = {false} any ] )
    [ return''0 (result:())-> {[@expl:extern_spec_std_hint_unreachable_unchecked_body result type invariant] [%#shint'0] inv result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_must_use_body [#"../../creusot-contracts/src/std/hint.rs" 30 12 30 41]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 30 27 30 32
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 30 40 30 41
  let%span shint'1 = "../../creusot-contracts/src/std/hint.rs" 29 22 29 37
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_must_use_body[#"../../creusot-contracts/src/std/hint.rs" 30 12 30 41] (value:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_hint_must_use_body 'value' type invariant] [%#shint] inv value}
    (! bb0 [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- value'0 ] s1 | s1 = bb2 ]  | bb2 = return''0 {_0} ] )
    [ & _0 : t_T = Any.any_l () | & value'0 : t_T = value ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_hint_must_use_body result type invariant] [%#shint'0] inv result}
      {[@expl:extern_spec_std_hint_must_use_body ensures] [%#shint'1] result = value}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__io__extern_spec_std_ioqy95z_print_body [#"../../creusot-contracts/src/std/io.rs" 4 0 18 1]
  let%span sio = "../../creusot-contracts/src/std/io.rs" 9 22 9 26
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use creusot.prelude.Char
  use creusot.int.UInt32
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Alignment  =
    | C_Left
    | C_Right
    | C_Center
    | C_Unknown
  
  type t_Count  =
    | C_Is UInt64.t
    | C_Param UInt64.t
    | C_Implied
  
  type t_Placeholder  =
    { t_Placeholder__position: UInt64.t;
      t_Placeholder__fill: Char.t;
      t_Placeholder__align: t_Alignment;
      t_Placeholder__flags: UInt32.t;
      t_Placeholder__precision: t_Count;
      t_Placeholder__width: t_Count }
  
  type t_Option  =
    | C_None
    | C_Some (Slice64.slice t_Placeholder)
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_ArgumentType  =
    | C_Placeholder t_NonNull Opaque.ptr ()
    | C_Count UInt64.t
  
  type t_Argument  =
    { t_Argument__ty: t_ArgumentType }
  
  type t_Arguments  =
    { t_Arguments__pieces: Slice64.slice string;
      t_Arguments__fmt: t_Option;
      t_Arguments__args: Slice64.slice t_Argument }
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_ioqy95z_print_body[#"../../creusot-contracts/src/std/io.rs" 4 0 18 1] (args:t_Arguments) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0 : () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_io__print_body ensures] [%#sio] true} (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__io__extern_spec_std_ioqy95z_eprint_body [#"../../creusot-contracts/src/std/io.rs" 4 0 18 1]
  let%span sio = "../../creusot-contracts/src/std/io.rs" 14 22 14 26
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use creusot.prelude.Char
  use creusot.int.UInt32
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Alignment  =
    | C_Left
    | C_Right
    | C_Center
    | C_Unknown
  
  type t_Count  =
    | C_Is UInt64.t
    | C_Param UInt64.t
    | C_Implied
  
  type t_Placeholder  =
    { t_Placeholder__position: UInt64.t;
      t_Placeholder__fill: Char.t;
      t_Placeholder__align: t_Alignment;
      t_Placeholder__flags: UInt32.t;
      t_Placeholder__precision: t_Count;
      t_Placeholder__width: t_Count }
  
  type t_Option  =
    | C_None
    | C_Some (Slice64.slice t_Placeholder)
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_ArgumentType  =
    | C_Placeholder t_NonNull Opaque.ptr ()
    | C_Count UInt64.t
  
  type t_Argument  =
    { t_Argument__ty: t_ArgumentType }
  
  type t_Arguments  =
    { t_Arguments__pieces: Slice64.slice string;
      t_Arguments__fmt: t_Option;
      t_Arguments__args: Slice64.slice t_Argument }
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_ioqy95z_eprint_body[#"../../creusot-contracts/src/std/io.rs" 4 0 18 1] (args:t_Arguments) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0 : () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_io__eprint_body ensures] [%#sio] true} (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl [#"../../creusot-contracts/src/std/iter/cloned.rs" 57 4 57 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 56 14 56 45
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 57 27 57 29
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned'2 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_T) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_T) (b : t_I) (bc : Seq.seq t_T) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_T, b : t_I, bc : Seq.seq t_T, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Cloned)
  
  axiom inv_axiom [@rewrite] : forall x : t_Cloned [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned) : t_I
  
  axiom iter_spec : forall self : t_Cloned . [%#scloned'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned) (visited : Seq.seq t_T) (o : t_Cloned)
  
   =
    [%#scloned'1] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant self  : t_Cloned
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 57 4 57 26] (self'0 : t_Cloned) : ()
  
  goal vc_produces_refl : [%#scloned] produces'0 self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans [#"../../creusot-contracts/src/std/iter/cloned.rs" 63 4 63 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 60 15 60 32
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 61 15 61 32
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 62 14 62 42
  let%span scloned'2 = "../../creusot-contracts/src/std/iter/cloned.rs" 63 91 63 93
  let%span scloned'3 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned'4 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_T) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_T) (b : t_I) (bc : Seq.seq t_T) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_T, b : t_I, bc : Seq.seq t_T, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Cloned)
  
  axiom inv_axiom [@rewrite] : forall x : t_Cloned [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned) : t_I
  
  axiom iter_spec : forall self : t_Cloned . [%#scloned'4] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned) (visited : Seq.seq t_T) (o : t_Cloned)
  
   =
    [%#scloned'3] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant a  : t_Cloned
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Cloned
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Cloned
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 63 4 63 90] (a'0 : t_Cloned) (ab'0 : Seq.seq t_T) (b'0 : t_Cloned) (bc'0 : Seq.seq t_T) (c'0 : t_Cloned) : ()
  
  
  goal vc_produces_trans : ([%#scloned] produces'0 a ab b)
   -> ([%#scloned'0] produces'0 b bc c)  -> ([%#scloned'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl [#"../../creusot-contracts/src/std/iter/copied.rs" 57 4 57 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 56 14 56 45
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 57 27 57 29
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied'2 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_T) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_T) (b : t_I) (bc : Seq.seq t_T) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_T, b : t_I, bc : Seq.seq t_T, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Copied)
  
  axiom inv_axiom [@rewrite] : forall x : t_Copied [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied) : t_I
  
  axiom iter_spec : forall self : t_Copied . [%#scopied'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied) (visited : Seq.seq t_T) (o : t_Copied)
  
   =
    [%#scopied'1] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant self  : t_Copied
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 57 4 57 26] (self'0 : t_Copied) : ()
  
  goal vc_produces_refl : [%#scopied] produces'0 self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans [#"../../creusot-contracts/src/std/iter/copied.rs" 63 4 63 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 60 15 60 32
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 61 15 61 32
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 62 14 62 42
  let%span scopied'2 = "../../creusot-contracts/src/std/iter/copied.rs" 63 91 63 93
  let%span scopied'3 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied'4 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_T) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_T) (b : t_I) (bc : Seq.seq t_T) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_T, b : t_I, bc : Seq.seq t_T, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Copied)
  
  axiom inv_axiom [@rewrite] : forall x : t_Copied [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied) : t_I
  
  axiom iter_spec : forall self : t_Copied . [%#scopied'4] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied) (visited : Seq.seq t_T) (o : t_Copied)
  
   =
    [%#scopied'3] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant a  : t_Copied
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Copied
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Copied
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 63 4 63 90] (a'0 : t_Copied) (ab'0 : Seq.seq t_T) (b'0 : t_Copied) (bc'0 : Seq.seq t_T) (c'0 : t_Copied) : ()
  
  
  goal vc_produces_trans : ([%#scopied] produces'0 a ab b)
   -> ([%#scopied'0] produces'0 b bc c)  -> ([%#scopied'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 17 14 17 45
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 18 27 18 29
  let%span sempty'1 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty) (visited : Seq.seq t_T) (o : t_Empty)
  
   =
    [%#sempty'1] visited = (Seq.empty : Seq.seq t_T) /\ self = o
  
  constant self  : t_Empty
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (self'0 : t_Empty) : ()
  
  goal vc_produces_refl : [%#sempty] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 21 15 21 32
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 22 15 22 32
  let%span sempty'1 = "../../creusot-contracts/src/std/iter/empty.rs" 23 14 23 42
  let%span sempty'2 = "../../creusot-contracts/src/std/iter/empty.rs" 24 91 24 93
  let%span sempty'3 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty) (visited : Seq.seq t_T) (o : t_Empty)
  
   =
    [%#sempty'3] visited = (Seq.empty : Seq.seq t_T) /\ self = o
  
  constant a  : t_Empty
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Empty
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Empty
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (a'0 : t_Empty) (ab'0 : Seq.seq t_T) (b'0 : t_Empty) (bc'0 : Seq.seq t_T) (c'0 : t_Empty) : ()
  
  
  goal vc_produces_trans : ([%#sempty] produces a ab b)
   -> ([%#sempty'0] produces b bc c)  -> ([%#sempty'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl [#"../../creusot-contracts/src/std/iter/enumerate.rs" 81 4 81 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 80 14 80 45
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 81 27 81 29
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 71 12 75 113
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span senumerate'3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 44 12 48 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate) : t_I
  
  axiom iter_spec : forall self : t_Enumerate . [%#senumerate'2] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 42 4 42 30] (self : t_Enumerate) =
    [%#senumerate'3] (forall s : Seq.seq t_Item, i : t_I [produces (iter self) s i] . produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i : MutBorrow.t t_I . completed i  -> produces i.current (Seq.empty : Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite] : forall x : t_Enumerate [inv'0 x] . inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 69 4 69 64] (self : t_Enumerate) (visited : Seq.seq tuple) (o : t_Enumerate)
  
   =
    [%#senumerate'1] Seq.length visited = n o - n self
    /\ (exists s : Seq.seq t_Item . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  constant self  : t_Enumerate
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 81 4 81 26] (self'0 : t_Enumerate) : ()
  
  goal vc_produces_refl : [%#senumerate] produces'0 self (Seq.empty : Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans [#"../../creusot-contracts/src/std/iter/enumerate.rs" 87 4 87 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 84 15 84 32
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 85 15 85 32
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 86 14 86 42
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 87 91 87 93
  let%span senumerate'3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 71 12 75 113
  let%span senumerate'4 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span senumerate'5 = "../../creusot-contracts/src/std/iter/enumerate.rs" 44 12 48 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate) : t_I
  
  axiom iter_spec : forall self : t_Enumerate . [%#senumerate'4] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 42 4 42 30] (self : t_Enumerate) =
    [%#senumerate'5] (forall s : Seq.seq t_Item, i : t_I [produces (iter self) s i] . produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i : MutBorrow.t t_I . completed i  -> produces i.current (Seq.empty : Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite] : forall x : t_Enumerate [inv'0 x] . inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 69 4 69 64] (self : t_Enumerate) (visited : Seq.seq tuple) (o : t_Enumerate)
  
   =
    [%#senumerate'3] Seq.length visited = n o - n self
    /\ (exists s : Seq.seq t_Item . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  constant a  : t_Enumerate
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Enumerate
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Enumerate
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 87 4 87 90] (a'0 : t_Enumerate) (ab'0 : Seq.seq tuple) (b'0 : t_Enumerate) (bc'0 : Seq.seq tuple) (c'0 : t_Enumerate) : ()
  
  
  goal vc_produces_trans : ([%#senumerate] produces'0 a ab b)
   -> ([%#senumerate'0] produces'0 b bc c)  -> ([%#senumerate'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 102 14 102 45
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 103 27 103 29
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 143
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 124
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'4 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : bool) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : bool . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : bool . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self : t_Filter) =
    [%#sfilter'2] forall f : t_F, i : t_Item . precondition f i
    /\ (forall f'0 : t_F, g : t_F . hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1 : t_F, f2 : t_F, i'0 : t_Item . not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Filter)
  
  axiom inv_axiom [@rewrite] : forall x : t_Filter [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter) : t_F
  
  axiom func_spec : forall self : t_Filter . [%#sfilter'3] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter) : t_I
  
  axiom iter_spec : forall self : t_Filter . [%#sfilter'4] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self : t_Filter) (visited : Seq.seq t_Item) (succ : t_Filter)
  
   =
    [%#sfilter'1] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s : Seq.seq t_Item, f : Map.map int int . produces (iter self) s (iter succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  constant self  : t_Filter
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (self'0 : t_Filter) : ()
  
  goal vc_produces_refl : [%#sfilter] produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 106 15 106 32
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 107 15 107 32
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 108 14 108 42
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 109 91 109 93
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 143
  let%span sfilter'4 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 124
  let%span sfilter'5 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'6 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : bool) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : bool . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : bool . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self : t_Filter) =
    [%#sfilter'4] forall f : t_F, i : t_Item . precondition f i
    /\ (forall f'0 : t_F, g : t_F . hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1 : t_F, f2 : t_F, i'0 : t_Item . not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Filter)
  
  axiom inv_axiom [@rewrite] : forall x : t_Filter [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter) : t_F
  
  axiom func_spec : forall self : t_Filter . [%#sfilter'5] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter) : t_I
  
  axiom iter_spec : forall self : t_Filter . [%#sfilter'6] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self : t_Filter) (visited : Seq.seq t_Item) (succ : t_Filter)
  
   =
    [%#sfilter'3] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s : Seq.seq t_Item, f : Map.map int int . produces (iter self) s (iter succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  constant a  : t_Filter
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Filter
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Filter
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (a'0 : t_Filter) (ab'0 : Seq.seq t_Item) (b'0 : t_Filter) (bc'0 : Seq.seq t_Item) (c'0 : t_Filter) : ()
  
  
  goal vc_produces_trans : ([%#sfilter] produces'0 a ab b)
   -> ([%#sfilter'0] produces'0 b bc c)  -> ([%#sfilter'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 102 14 102 45
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 103 27 103 29
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 148
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 50
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 54
  let%span sfilter_map'7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 135
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f : t_F) =
    [%#sfilter_map'5] forall i : t_Item . precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : t_Option) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : t_Option . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : t_Option . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f : t_F) =
    [%#sfilter_map'6] forall g : t_F . hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1 : t_F) =
    [%#sfilter_map'7] forall f2 : t_F, i : t_Item . not ((exists b : t_B . postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap) : t_F
  
  axiom func_spec : forall self : t_FilterMap . [%#sfilter_map'3] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self : t_FilterMap) =
    [%#sfilter_map'2] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite] : forall x : t_FilterMap [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap) : t_I
  
  axiom iter_spec : forall self : t_FilterMap . [%#sfilter_map'4] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self : t_FilterMap) (visited : Seq.seq t_B) (succ : t_FilterMap)
  
   =
    [%#sfilter_map'1] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s : Seq.seq t_Item, f : Map.map int int . produces (iter self) s (iter succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  constant self  : t_FilterMap
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (self'0 : t_FilterMap) : ()
  
  
  goal vc_produces_refl : [%#sfilter_map] produces'0 self (Seq.empty : Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 106 15 106 32
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 107 15 107 32
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 108 14 108 42
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 109 91 109 93
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 148
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 50
  let%span sfilter_map'8 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 54
  let%span sfilter_map'9 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 135
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f : t_F) =
    [%#sfilter_map'7] forall i : t_Item . precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : t_Option) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : t_Option . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : t_Option . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f : t_F) =
    [%#sfilter_map'8] forall g : t_F . hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1 : t_F) =
    [%#sfilter_map'9] forall f2 : t_F, i : t_Item . not ((exists b : t_B . postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap) : t_F
  
  axiom func_spec : forall self : t_FilterMap . [%#sfilter_map'5] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self : t_FilterMap) =
    [%#sfilter_map'4] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite] : forall x : t_FilterMap [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap) : t_I
  
  axiom iter_spec : forall self : t_FilterMap . [%#sfilter_map'6] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self : t_FilterMap) (visited : Seq.seq t_B) (succ : t_FilterMap)
  
   =
    [%#sfilter_map'3] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s : Seq.seq t_Item, f : Map.map int int . produces (iter self) s (iter succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  constant a  : t_FilterMap
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_FilterMap
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_FilterMap
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (a'0 : t_FilterMap) (ab'0 : Seq.seq t_B) (b'0 : t_FilterMap) (bc'0 : Seq.seq t_B) (c'0 : t_FilterMap) : ()
  
  
  goal vc_produces_trans : ([%#sfilter_map] produces'0 a ab b)
   -> ([%#sfilter_map'0] produces'0 b bc c)  -> ([%#sfilter_map'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Fuse)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse [inv'1 x] . inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse) : t_Option
  
  axiom view_spec : forall self : t_Fuse . ([%#sfuse'2] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'3] forall other : t_Fuse . view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse) (prod : Seq.seq t_Item) (other : t_Fuse)
  
   =
    [%#sfuse'1] match view self with
      | C_None -> prod = (Seq.empty : Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  constant self  : t_Fuse
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self'0 : t_Fuse) : ()
  
  goal vc_produces_refl : [%#sfuse] produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Fuse)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse [inv'1 x] . inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse) : t_Option
  
  axiom view_spec : forall self : t_Fuse . ([%#sfuse'4] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'5] forall other : t_Fuse . view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse) (prod : Seq.seq t_Item) (other : t_Fuse)
  
   =
    [%#sfuse'3] match view self with
      | C_None -> prod = (Seq.empty : Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  constant a  : t_Fuse
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Fuse
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Fuse
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a'0 : t_Fuse) (ab'0 : Seq.seq t_Item) (b'0 : t_Fuse) (bc'0 : Seq.seq t_Item) (c'0 : t_Fuse) : ()
  
  
  goal vc_produces_trans : ([%#sfuse] produces'0 a ab b)
   -> ([%#sfuse'0] produces'0 b bc c)  -> ([%#sfuse'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 63 15 63 31
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 64 15 64 44
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 65 14 65 50
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 66 63 66 65
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse'6 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'7 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'8 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'9 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'10 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'11 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'12 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Fuse)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse [inv'1 x] . inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse) : t_Option
  
  axiom view_spec : forall self : t_Fuse . ([%#sfuse'11] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'12] forall other : t_Fuse . view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse) (prod : Seq.seq t_Item) (other : t_Fuse)
  
   =
    [%#sfuse'4] match view self with
      | C_None -> prod = (Seq.empty : Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a : t_Fuse) (ab : Seq.seq t_Item) (b : t_Fuse) (bc : Seq.seq t_Item) (c : t_Fuse) : ()
  
   =
    [%#sfuse'10] ()
  
  axiom produces_trans_spec'0 : forall a : t_Fuse, ab : Seq.seq t_Item, b : t_Fuse, bc : Seq.seq t_Item, c : t_Fuse . ([%#sfuse'7] produces'0 a ab b)
   -> ([%#sfuse'8] produces'0 b bc c)  -> ([%#sfuse'9] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self : t_Fuse) : () =
    [%#sfuse'6] ()
  
  axiom produces_refl_spec'0 : forall self : t_Fuse . [%#sfuse'5] produces'0 self (Seq.empty : Seq.seq t_Item) self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t t_Fuse) : t_Option =
    [%#smodel] view self.current
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : MutBorrow.t t_Fuse) =
    [%#sfuse'3] (view'0 self = C_None
    \/ (exists it : MutBorrow.t t_I . completed it /\ view'0 self = C_Some (it.current)))
    /\ view self.final = C_None
  
  constant self  : MutBorrow.t t_Fuse
  
  constant steps  : Seq.seq t_Item
  
  constant next  : t_Fuse
  
  function is_fused [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (self'0 : MutBorrow.t t_Fuse) (steps'0 : Seq.seq t_Item) (next'0 : t_Fuse) : ()
  
  
  goal vc_is_fused : ([%#sfuse] completed'0 self)
   -> ([%#sfuse'0] produces'0 self.final steps next)
   -> ([%#sfuse'1] steps = (Seq.empty : Seq.seq t_Item) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_refl [#"../../creusot-contracts/src/std/iter/map.rs" 79 4 79 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 78 14 78 45
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 79 27 79 29
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 62 12 73 75
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap'3 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Map)
  
  axiom inv_axiom [@rewrite] : forall x : t_Map [inv'1 x] . inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map) : t_F
  
  axiom func_spec : forall self : t_Map . [%#smap'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map) : t_I
  
  axiom iter_spec : forall self : t_Map . [%#smap'3] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 60 4 60 67] (self : t_Map) (visited : Seq.seq t_B) (succ : t_Map)
  
   =
    [%#smap'1] hist_inv (func self) (func succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item [produces (iter self) s (iter succ)] . Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  constant self  : t_Map
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map.rs" 79 4 79 26] (self'0 : t_Map) : ()
  
  goal vc_produces_refl : [%#smap] produces'0 self (Seq.empty : Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_trans [#"../../creusot-contracts/src/std/iter/map.rs" 85 4 85 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 82 15 82 32
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 83 15 83 32
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 84 14 84 42
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 85 91 85 93
  let%span smap'3 = "../../creusot-contracts/src/std/iter/map.rs" 62 12 73 75
  let%span smap'4 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap'5 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Map)
  
  axiom inv_axiom [@rewrite] : forall x : t_Map [inv'1 x] . inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map) : t_F
  
  axiom func_spec : forall self : t_Map . [%#smap'4] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map) : t_I
  
  axiom iter_spec : forall self : t_Map . [%#smap'5] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 60 4 60 67] (self : t_Map) (visited : Seq.seq t_B) (succ : t_Map)
  
   =
    [%#smap'3] hist_inv (func self) (func succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item [produces (iter self) s (iter succ)] . Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  constant a  : t_Map
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_Map
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_Map
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map.rs" 85 4 85 90] (a'0 : t_Map) (ab'0 : Seq.seq t_B) (b'0 : t_Map) (bc'0 : Seq.seq t_B) (c'0 : t_Map) : ()
  
  
  goal vc_produces_trans : ([%#smap] produces'0 a ab b)
   -> ([%#smap'0] produces'0 b bc c)  -> ([%#smap'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl [#"../../creusot-contracts/src/std/iter/map_inv.rs" 23 4 23 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 22 14 22 45
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 27 23 29
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 35 8 47 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : tuple) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : tuple) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : tuple) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : tuple, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : tuple) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : tuple, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 34 4 34 67] (self : t_MapInv) (visited : Seq.seq t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'1] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item . Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  constant self  : t_MapInv
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 23 4 23 26] (self'0 : t_MapInv) : ()
  
  goal vc_produces_refl : [%#smap_inv] produces'0 self (Seq.empty : Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans [#"../../creusot-contracts/src/std/iter/map_inv.rs" 29 4 29 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 26 15 26 32
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 27 15 27 32
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 14 28 42
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 91 29 93
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 35 8 47 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : tuple) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : tuple) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : tuple) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : tuple, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : tuple) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : tuple, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 34 4 34 67] (self : t_MapInv) (visited : Seq.seq t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'3] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item . Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  constant a  : t_MapInv
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_MapInv
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_MapInv
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 29 4 29 90] (a'0 : t_MapInv) (ab'0 : Seq.seq t_B) (b'0 : t_MapInv) (bc'0 : Seq.seq t_B) (c'0 : t_MapInv) : ()
  
  
  goal vc_produces_trans : ([%#smap_inv] produces'0 a ab b)
   -> ([%#smap_inv'0] produces'0 b bc c)  -> ([%#smap_inv'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence [#"../../creusot-contracts/src/std/iter/map_inv.rs" 61 4 61 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 59 15 59 39
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 60 14 60 31
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 61 32 61 34
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 55 8 55 50
  
  use seq.Seq
  
  type t_I
  
  type t_F
  
  type t_B
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_B }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_MapInv) =
    match _0 with
      | {t_MapInv__iter = x0 ; t_MapInv__func = x1 ; t_MapInv__produced = x2} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 54 4 54 28] (self : t_MapInv) =
    [%#smap_inv'2] resolve'0 self.t_MapInv__iter /\ resolve self.t_MapInv__func
  
  constant self  : t_MapInv
  
  function resolve_coherence [#"../../creusot-contracts/src/std/iter/map_inv.rs" 61 4 61 31] (self'0 : t_MapInv) : ()
  
  goal vc_resolve_coherence : ([%#smap_inv] structural_resolve self)  -> ([%#smap_inv'0] resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next [#"../../creusot-contracts/src/std/iter/map_inv.rs" 86 4 86 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 177 16 177 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 179 39 179 42
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 177 27 177 52
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 178 26 178 71
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'9 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 87 39 87 58
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 90 16 90 76
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 91 31 91 71
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 95 38 95 88
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 96 32 96 63
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 101 32 101 56
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 86 17 86 21
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 86 26 86 44
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 82 14 85 5
  let%span smap_inv'8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 159 15 159 31
  let%span smap_inv'9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 160 4 160 60
  let%span smap_inv'10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 161 15 161 30
  let%span smap_inv'11 = "../../creusot-contracts/src/std/iter/map_inv.rs" 162 15 162 64
  let%span smap_inv'12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 163 14 163 74
  let%span smap_inv'13 = "../../creusot-contracts/src/std/iter/map_inv.rs" 164 14 164 75
  let%span smap_inv'14 = "../../creusot-contracts/src/std/iter/map_inv.rs" 175 14 175 68
  let%span smap_inv'15 = "../../creusot-contracts/src/std/iter/map_inv.rs" 178 12 183 74
  let%span smap_inv'16 = "../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv'17 = "../../creusot-contracts/src/std/iter/map_inv.rs" 70 12 72 73
  let%span smap_inv'18 = "../../creusot-contracts/src/std/iter/map_inv.rs" 120 14 120 81
  let%span smap_inv'19 = "../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 128 88
  let%span smap_inv'20 = "../../creusot-contracts/src/std/iter/map_inv.rs" 113 12 115 63
  let%span smap_inv'21 = "../../creusot-contracts/src/std/iter/map_inv.rs" 35 8 47 9
  let%span smap_inv'22 = "../../creusot-contracts/src/std/iter/map_inv.rs" 22 14 22 45
  let%span smap_inv'23 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 27 23 29
  let%span smap_inv'24 = "../../creusot-contracts/src/std/iter/map_inv.rs" 26 15 26 32
  let%span smap_inv'25 = "../../creusot-contracts/src/std/iter/map_inv.rs" 27 15 27 32
  let%span smap_inv'26 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 14 28 42
  let%span smap_inv'27 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 91 29 93
  let%span smap_inv'28 = "../../creusot-contracts/src/std/iter/map_inv.rs" 149 12 152 47
  let%span smap_inv'29 = "../../creusot-contracts/src/std/iter/map_inv.rs" 136 12 141 71
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_I
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_Option  =
    | C_None
    | C_Some t_Item
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_I) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_I)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_I [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : MutBorrow.t t_I)
  
  axiom precondition_fndef : forall args : MutBorrow.t t_I [precondition () args] . (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Item)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : MutBorrow.t t_I) (result : t_Option)
  
  
  axiom postcondition_fndef : forall args : MutBorrow.t t_I, res : t_Option [postcondition_once () args res] . postcondition_once () args res
   -> (let self_ = args in match res with
    | C_None -> completed self_
    | C_Some v -> produces self_.current (Seq.singleton v) self_.final
    end
  /\ inv'2 res)
  
  let rec next (self_:MutBorrow.t t_I) (return'  (x:t_Option))= {[@expl:next requires] precondition () self_}
    any [ return''0 (result:t_Option)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Item))= any
    [ good (field_0:t_Item)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Item [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : tuple)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  type t_B
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_F) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_F)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_F [inv'4 x] . inv'4 x = invariant''0 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : tuple)
  
  axiom inv_axiom'2 [@rewrite] : forall x : tuple [inv'5 x] . inv'5 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'1 x0)
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_B)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : tuple) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : tuple) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : tuple) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : tuple, res : t_B . [%#sops'9] postcondition_once'0 self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'6] hist_inv self b)
   -> ([%#sops'7] hist_inv b c)  -> ([%#sops'8] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'5] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : tuple) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : tuple, res_state : t_F, res : t_B . ([%#sops'3] postcondition_mut self args res_state res)
   -> ([%#sops'4] hist_inv self res_state)
  
  let rec call_mut (self_:MutBorrow.t t_F) (arg:tuple) (return'  (x:t_B))= {[@expl:call_mut 'self_' type invariant] [%#sops] inv'4 self_}
    {[@expl:call_mut 'arg' type invariant] [%#sops'0] inv'5 arg}
    {[@expl:call_mut requires] [%#sops'1] precondition'0 self_.current arg}
    any
    [ return''0 (result:t_B)-> {inv'6 result}
      {[%#sops'2] postcondition_mut self_.current arg self_.final result}
      (! return' {result}) ]
  
  
  predicate next_precondition [#"../../creusot-contracts/src/std/iter/map_inv.rs" 111 4 111 78] (iter : t_I) (func : t_F) (produced : Seq.seq t_Item)
  
   =
    [%#smap_inv'20] forall e : t_Item, i : t_I . produces iter (Seq.singleton e) i
     -> precondition'0 func { _p0 = e; _p1 = produced }
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 134 4 134 49] (iter : t_I) (func : t_F) =
    [%#smap_inv'29] forall s : Seq.seq t_Item, e1 : t_Item, e2 : t_Item, f : MutBorrow.t t_F, b : t_B, i : t_I . hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition'0 f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  predicate reinitialize [#"../../creusot-contracts/src/std/iter/map_inv.rs" 147 4 147 33]  =
    [%#smap_inv'28] forall iter : MutBorrow.t t_I, func : t_F . completed iter
     -> next_precondition iter.final func (Seq.empty : Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 73] (iter : t_I) (func : t_F) (produced : Seq.seq t_Item)
  
   =
    [%#smap_inv'19] forall s : Seq.seq t_Item, e1 : t_Item, e2 : t_Item, f : MutBorrow.t t_F, b : t_B, i : t_I . hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _p0 = e1; _p1 = Seq.(++) produced s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
     -> precondition'0 f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec : forall iter : t_I, func : t_F, produced : Seq.seq t_Item . [%#smap_inv'18] produced
  = (Seq.empty : Seq.seq t_Item)  -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant''1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 68 4 68 30] (self : t_MapInv) =
    [%#smap_inv'17] reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  function produces_one_invariant [#"../../creusot-contracts/src/std/iter/map_inv.rs" 165 4 165 73] (self : t_MapInv) (e : t_Item) (r : t_B) (f : MutBorrow.t t_F) (iter : t_I) : ()
  
  
  axiom produces_one_invariant_spec : forall self : t_MapInv, e : t_Item, r : t_B, f : MutBorrow.t t_F, iter : t_I . ([%#smap_inv'8] invariant''1 self)
   -> ([%#smap_inv'9] produces self.t_MapInv__iter (Seq.singleton e) iter)
   -> ([%#smap_inv'10] f.current = self.t_MapInv__func)
   -> ([%#smap_inv'11] postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final r)
   -> ([%#smap_inv'12] preservation_inv iter f.final (Seq.snoc self.t_MapInv__produced e))
  && ([%#smap_inv'13] next_precondition iter f.final (Seq.snoc self.t_MapInv__produced e))
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 34 4 34 67] (self : t_MapInv) (visited : Seq.seq t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'21] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item . Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _p0 = Seq.get s i;
                                               _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 29 4 29 90] (a : t_MapInv) (ab : Seq.seq t_B) (b : t_MapInv) (bc : Seq.seq t_B) (c : t_MapInv) : ()
  
   =
    [%#smap_inv'27] ()
  
  axiom produces_trans_spec'0 : forall a : t_MapInv, ab : Seq.seq t_B, b : t_MapInv, bc : Seq.seq t_B, c : t_MapInv . ([%#smap_inv'24] produces'0 a ab b)
   -> ([%#smap_inv'25] produces'0 b bc c)  -> ([%#smap_inv'26] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 23 4 23 26] (self : t_MapInv) : () =
    [%#smap_inv'23] ()
  
  axiom produces_refl_spec'0 : forall self : t_MapInv . [%#smap_inv'22] produces'0 self (Seq.empty : Seq.seq t_B) self
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 176 4 176 57] (self : t_MapInv) (visited : t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'15] exists f : MutBorrow.t t_F, e : t_Item . f.current = self.t_MapInv__func
    /\ f.final = succ.t_MapInv__func
    /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
    /\ precondition'0 f.current { _p0 = e; _p1 = self.t_MapInv__produced }
    /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited
  
  axiom produces_one_spec : forall self : t_MapInv, visited : t_B, succ : t_MapInv . [%#smap_inv'14] produces_one self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_MapInv)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_MapInv [inv'7 x] . inv'7 x
  = (invariant''1 x
  /\ match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'3 func
    end)
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_MapInv) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_MapInv)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_MapInv [inv'8 x] . inv'8 x = invariant''2 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_MapInv) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_MapInv) =
    resolve'0 _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B
  
  predicate inv'9 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Option'0 [inv'9 x] . inv'9 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : MutBorrow.t t_MapInv) =
    [%#smap_inv'16] (self.final).t_MapInv__produced = (Seq.empty : Seq.seq t_Item)
    /\ completed (MutBorrow.borrow_logic (self.current).t_MapInv__iter (self.final).t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func = (self.final).t_MapInv__func
  
  meta "compute_max_steps" 1000000
  
  let rec next'0[#"../../creusot-contracts/src/std/iter/map_inv.rs" 86 4 86 44] (self:MutBorrow.t t_MapInv) (return'  (x:t_Option'0))= {[@expl:next 'self' type invariant] [%#smap_inv'5] inv'8 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#smap_inv] self'0.current ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv (self'0.current).t_MapInv__iter}
        MutBorrow.borrow_final
          <t_I>
          {(self'0.current).t_MapInv__iter}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_I) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__iter = _ret.final } } ] 
            s1)
      | s1 = next {_6} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_5 = C_None} (! bb5) | br1 (x0:t_Item)-> {_5 = C_Some x0} (! bb4) ] 
    | bb4 = bb6
    | bb6 = s0
      [ s0 = v_Some {_5} (fun (r0:t_Item) ->  [ &v <- r0 ] s1)
      | s1 = {[@expl:assertion] [%#smap_inv'0] precondition'0 (self'0.current).t_MapInv__func { _p0 = v;
                                                                                                _p1 = (self'0.current).t_MapInv__produced }}
        s2
      | s2 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &produced <- [%#smap_inv'1] Seq.snoc (self'0.current).t_MapInv__produced v ] s1 | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = {inv'3 (self'0.current).t_MapInv__func}
        MutBorrow.borrow_final
          <t_F>
          {(self'0.current).t_MapInv__func}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t t_F) ->
             [ &_14 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__func = _ret.final } } ] 
            s1)
      | s1 =  [ &_15 <- { _p0 = v; _p1 = (self'0.current).t_MapInv__produced } ] s2
      | s2 = call_mut {_14} {_15} (fun (_ret:t_B) ->  [ &r <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__produced = produced } } ] s1
      | s1 =  [ &_19 <- [%#smap_inv'2] let _ = () in () ] s2
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = {[@expl:assertion] [%#smap_inv'3] produces_one old_self r self'0.current} s1 | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'8 self'0} s1
      | s1 = -{resolve'1 self'0}- s2
      | s2 =  [ &_0 <- C_Some'0 r ] s3
      | s3 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb17
    | bb5 = s0 [ s0 =  [ &_24 <- [%#smap_inv'4] Seq.empty : Seq.seq t_Item ] s1 | s1 = bb16 ] 
    | bb16 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__produced = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv'8 self'0} s2
      | s2 = -{resolve'1 self'0}- s3
      | s3 =  [ &_0 <- C_None'0 ] s4
      | s4 = bb17 ]
    
    | bb17 = bb18
    | bb18 = return''0 {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self'0 : MutBorrow.t t_MapInv = self
    | & old_self : t_MapInv = Any.any_l ()
    | & _5 : t_Option = Any.any_l ()
    | & _6 : MutBorrow.t t_I = Any.any_l ()
    | & v : t_Item = Any.any_l ()
    | & produced : Seq.seq t_Item = Any.any_l ()
    | & r : t_B = Any.any_l ()
    | & _14 : MutBorrow.t t_F = Any.any_l ()
    | & _15 : tuple = Any.any_l ()
    | & _19 : () = Any.any_l ()
    | & _24 : Seq.seq t_Item = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:next result type invariant] [%#smap_inv'6] inv'9 result}
      {[@expl:next ensures] [%#smap_inv'7] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces_one self.current v self.final
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 73] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 120 14 120 81
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 128 88
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 136 12 141 71
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  type t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : tuple) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : tuple) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : tuple) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : tuple, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : tuple) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : tuple, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : tuple)
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 134 4 134 49] (iter : t_I) (func : t_F) =
    [%#smap_inv'1] forall s : Seq.seq t_Item, e1 : t_Item, e2 : t_Item, f : MutBorrow.t t_F, b : t_B, i : t_I . hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  constant iter  : t_I
  
  constant func  : t_F
  
  constant produced  : Seq.seq t_Item
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 73] (iter'0 : t_I) (func'0 : t_F) (produced'0 : Seq.seq t_Item)
  
  
  goal vc_preservation_inv : [%#smap_inv] produced = (Seq.empty : Seq.seq t_Item)
   -> ([%#smap_inv'0] forall s : Seq.seq t_Item, e1 : t_Item, e2 : t_Item, f : MutBorrow.t t_F, b : t_B, i : t_I . hist_inv func f.current
   -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
   -> precondition f.current { _p0 = e1; _p1 = Seq.(++) produced s }
   -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
   -> precondition f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 })
  = preservation iter func
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 176 4 176 57] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 175 14 175 68
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 178 12 183 74
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 35 8 47 9
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 22 14 22 45
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 27 23 29
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 26 15 26 32
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 27 15 27 32
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 14 28 42
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 91 29 93
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : tuple) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : tuple) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : tuple) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : tuple, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : tuple) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : tuple, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 34 4 34 67] (self : t_MapInv) (visited : Seq.seq t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'1] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item . Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 29 4 29 90] (a : t_MapInv) (ab : Seq.seq t_B) (b : t_MapInv) (bc : Seq.seq t_B) (c : t_MapInv) : ()
  
   =
    [%#smap_inv'7] ()
  
  axiom produces_trans_spec'0 : forall a : t_MapInv, ab : Seq.seq t_B, b : t_MapInv, bc : Seq.seq t_B, c : t_MapInv . ([%#smap_inv'4] produces'0 a ab b)
   -> ([%#smap_inv'5] produces'0 b bc c)  -> ([%#smap_inv'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 23 4 23 26] (self : t_MapInv) : () =
    [%#smap_inv'3] ()
  
  axiom produces_refl_spec'0 : forall self : t_MapInv . [%#smap_inv'2] produces'0 self (Seq.empty : Seq.seq t_B) self
  
  constant self  : t_MapInv
  
  constant visited  : t_B
  
  constant succ  : t_MapInv
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 176 4 176 57] (self'0 : t_MapInv) (visited'0 : t_B) (succ'0 : t_MapInv)
  
  
  goal vc_produces_one : [%#smap_inv] ([%#smap_inv'0] exists f : MutBorrow.t t_F, e : t_Item . f.current
  = self.t_MapInv__func
  /\ f.final = succ.t_MapInv__func
  /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
  /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
  /\ precondition f.current { _p0 = e; _p1 = self.t_MapInv__produced }
  /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited)
  = produces'0 self (Seq.singleton visited) succ
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 30 14 30 45
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 31 27 31 29
  let%span sonce'1 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once) (visited : Seq.seq t_T) (o : t_Once)
  
   =
    [%#sonce'1] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant self  : t_Once
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (self'0 : t_Once) : ()
  
  goal vc_produces_refl : [%#sonce] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 34 15 34 32
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 35 15 35 32
  let%span sonce'1 = "../../creusot-contracts/src/std/iter/once.rs" 36 14 36 42
  let%span sonce'2 = "../../creusot-contracts/src/std/iter/once.rs" 37 91 37 93
  let%span sonce'3 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once) (visited : Seq.seq t_T) (o : t_Once)
  
   =
    [%#sonce'3] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant a  : t_Once
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Once
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Once
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (a'0 : t_Once) (ab'0 : Seq.seq t_T) (b'0 : t_Once) (bc'0 : Seq.seq t_T) (c'0 : t_Once) : ()
  
  
  goal vc_produces_trans : ([%#sonce] produces a ab b)
   -> ([%#sonce'0] produces b bc c)  -> ([%#sonce'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 35 27 35 29
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range) (visited : Seq.seq t_Idx) (o : t_Range)
  
   =
    [%#srange'1] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  constant self  : t_Range
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (self'0 : t_Range) : ()
  
  goal vc_produces_refl : [%#srange] produces self (Seq.empty : Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 38 15 38 32
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 39 15 39 32
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 40 14 40 42
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 41 91 41 93
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range) (visited : Seq.seq t_Idx) (o : t_Range)
  
   =
    [%#srange'3] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  constant a  : t_Range
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_Range
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_Range
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (a'0 : t_Range) (ab'0 : Seq.seq t_Idx) (b'0 : t_Range) (bc'0 : Seq.seq t_Idx) (c'0 : t_Range) : ()
  
  
  goal vc_produces_trans : ([%#srange] produces a ab b)
   -> ([%#srange'0] produces b bc c)  -> ([%#srange'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 59 14 59 50
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 60 32 60 34
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self : t_Range) (visited : Seq.seq t_Idx) (o : t_Range)
  
   =
    [%#srange'1] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  constant self  : t_Range
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (self'0 : t_Range) : ()
  
  goal vc_produces_back_refl : [%#srange] produces_back self (Seq.empty : Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 63 15 63 37
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 64 15 64 37
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 65 14 65 47
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 66 96 66 98
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self : t_Range) (visited : Seq.seq t_Idx) (o : t_Range)
  
   =
    [%#srange'3] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  constant a  : t_Range
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_Range
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_Range
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (a'0 : t_Range) (ab'0 : Seq.seq t_Idx) (b'0 : t_Range) (bc'0 : Seq.seq t_Idx) (c'0 : t_Range) : ()
  
  
  goal vc_produces_back_trans : ([%#srange] produces_back a ab b)
   -> ([%#srange'0] produces_back b bc c)  -> ([%#srange'1] produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  constant r  : t_RangeInclusive
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r'0 : t_RangeInclusive) : int
  
  
  goal vc_range_inclusive_len : ([%#sops] not is_empty_log r  -> deep_model (start_log r) <= deep_model (end_log r))
   -> (if is_empty_log r then
    [%#srange] is_empty_log r = (0 = 0)
  else
    [%#srange] is_empty_log r = (deep_model (end_log r) - deep_model (start_log r) + 1 = 0)
  )
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 103 14 103 45
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 104 27 104 29
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r : t_RangeInclusive) : int
  
   =
    [%#srange'3] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec : forall r : t_RangeInclusive . [%#srange'2] is_empty_log r
  = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self : t_RangeInclusive) (visited : Seq.seq t_Idx) (o : t_RangeInclusive)
  
   =
    [%#srange'1] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  constant self  : t_RangeInclusive
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (self'0 : t_RangeInclusive) : ()
  
  
  goal vc_produces_refl : [%#srange] produces self (Seq.empty : Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 108 15 108 32
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 109 15 109 32
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 110 14 110 42
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 111 91 111 93
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'4 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'5 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r : t_RangeInclusive) : int
  
   =
    [%#srange'5] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec : forall r : t_RangeInclusive . [%#srange'4] is_empty_log r
  = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self : t_RangeInclusive) (visited : Seq.seq t_Idx) (o : t_RangeInclusive)
  
   =
    [%#srange'3] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  constant a  : t_RangeInclusive
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_RangeInclusive
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_RangeInclusive
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (a'0 : t_RangeInclusive) (ab'0 : Seq.seq t_Idx) (b'0 : t_RangeInclusive) (bc'0 : Seq.seq t_Idx) (c'0 : t_RangeInclusive) : ()
  
  
  goal vc_produces_trans : ([%#srange] produces a ab b)
   -> ([%#srange'0] produces b bc c)  -> ([%#srange'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 130 14 130 50
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 131 32 131 34
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r : t_RangeInclusive) : int
  
   =
    [%#srange'3] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec : forall r : t_RangeInclusive . [%#srange'2] is_empty_log r
  = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self : t_RangeInclusive) (visited : Seq.seq t_Idx) (o : t_RangeInclusive)
  
   =
    [%#srange'1] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  constant self  : t_RangeInclusive
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (self'0 : t_RangeInclusive) : ()
  
  
  goal vc_produces_back_refl : [%#srange] produces_back self (Seq.empty : Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 135 15 135 37
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 136 15 136 37
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 137 14 137 47
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 138 96 138 98
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'4 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'5 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r : t_RangeInclusive) : int
  
   =
    [%#srange'5] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec : forall r : t_RangeInclusive . [%#srange'4] is_empty_log r
  = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self : t_RangeInclusive) (visited : Seq.seq t_Idx) (o : t_RangeInclusive)
  
   =
    [%#srange'3] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  constant a  : t_RangeInclusive
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_RangeInclusive
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_RangeInclusive
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (a'0 : t_RangeInclusive) (ab'0 : Seq.seq t_Idx) (b'0 : t_RangeInclusive) (bc'0 : Seq.seq t_Idx) (c'0 : t_RangeInclusive) : ()
  
  
  goal vc_produces_back_trans : ([%#srange] produces_back a ab b)
   -> ([%#srange'0] produces_back b bc c)  -> ([%#srange'1] produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 30 14 30 45
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 31 27 31 29
  let%span srepeat'1 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat) (visited : Seq.seq t_T) (o : t_Repeat)
  
   =
    [%#srepeat'1] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view self)
  
  constant self  : t_Repeat
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (self'0 : t_Repeat) : ()
  
  goal vc_produces_refl : [%#srepeat] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 34 15 34 32
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 35 15 35 32
  let%span srepeat'1 = "../../creusot-contracts/src/std/iter/repeat.rs" 36 14 36 42
  let%span srepeat'2 = "../../creusot-contracts/src/std/iter/repeat.rs" 37 91 37 93
  let%span srepeat'3 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat) (visited : Seq.seq t_T) (o : t_Repeat)
  
   =
    [%#srepeat'3] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view self)
  
  constant a  : t_Repeat
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Repeat
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Repeat
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (a'0 : t_Repeat) (ab'0 : Seq.seq t_T) (b'0 : t_Repeat) (bc'0 : Seq.seq t_T) (c'0 : t_Repeat) : ()
  
  
  goal vc_produces_trans : ([%#srepeat] produces a ab b)
   -> ([%#srepeat'0] produces b bc c)  -> ([%#srepeat'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 78 14 78 50
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 82 15 82 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 83 15 83 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 84 14 84 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 46 14 46 45
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 47 27 47 29
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'2 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 75 4 75 70] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 85 4 85 96] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_back_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 79 4 79 32] (self : t_I) : ()
  
  axiom produces_back_refl_spec : forall self : t_I . [%#siter] produces_back self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rev)
  
  axiom inv_axiom [@rewrite] : forall x : t_Rev [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev) : t_I
  
  axiom iter_spec : forall self : t_Rev . [%#srev'2] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev) (visited : Seq.seq t_Item) (o : t_Rev)
  
   =
    [%#srev'1] produces_back (iter self) visited (iter o)
  
  constant self  : t_Rev
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (self'0 : t_Rev) : ()
  
  goal vc_produces_refl : [%#srev] produces self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 78 14 78 50
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 82 15 82 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 83 15 83 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 84 14 84 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 50 15 50 32
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 51 15 51 32
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 52 14 52 42
  let%span srev'2 = "../../creusot-contracts/src/std/iter/rev.rs" 53 91 53 93
  let%span srev'3 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'4 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 75 4 75 70] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 85 4 85 96] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_back_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 79 4 79 32] (self : t_I) : ()
  
  axiom produces_back_refl_spec : forall self : t_I . [%#siter] produces_back self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rev)
  
  axiom inv_axiom [@rewrite] : forall x : t_Rev [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev) : t_I
  
  axiom iter_spec : forall self : t_Rev . [%#srev'4] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev) (visited : Seq.seq t_Item) (o : t_Rev)
  
   =
    [%#srev'3] produces_back (iter self) visited (iter o)
  
  constant a  : t_Rev
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Rev
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Rev
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (a'0 : t_Rev) (ab'0 : Seq.seq t_Item) (b'0 : t_Rev) (bc'0 : Seq.seq t_Item) (c'0 : t_Rev) : ()
  
  
  goal vc_produces_trans : ([%#srev] produces a ab b)
   -> ([%#srev'0] produces b bc c)  -> ([%#srev'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl [#"../../creusot-contracts/src/std/iter/skip.rs" 73 4 73 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 72 14 72 45
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 73 27 73 29
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip'3 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip) : int
  
  axiom n_spec : forall self : t_Skip . [%#sskip'2] n self >= 0 /\ n self <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Skip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Skip [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip) : t_I
  
  axiom iter_spec : forall self : t_Skip . [%#sskip'3] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip) (visited : Seq.seq t_Item) (o : t_Skip)
  
   =
    [%#sskip'1] visited = (Seq.empty : Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item . Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  constant self  : t_Skip
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 73 4 73 26] (self'0 : t_Skip) : ()
  
  goal vc_produces_refl : [%#sskip] produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans [#"../../creusot-contracts/src/std/iter/skip.rs" 79 4 79 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 76 15 76 32
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 77 15 77 32
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 78 14 78 42
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 79 91 79 93
  let%span sskip'3 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip'4 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip'5 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip) : int
  
  axiom n_spec : forall self : t_Skip . [%#sskip'4] n self >= 0 /\ n self <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Skip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Skip [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip) : t_I
  
  axiom iter_spec : forall self : t_Skip . [%#sskip'5] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip) (visited : Seq.seq t_Item) (o : t_Skip)
  
   =
    [%#sskip'3] visited = (Seq.empty : Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item . Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  constant a  : t_Skip
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Skip
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Skip
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 79 4 79 90] (a'0 : t_Skip) (ab'0 : Seq.seq t_Item) (b'0 : t_Skip) (bc'0 : Seq.seq t_Item) (c'0 : t_Skip) : ()
  
  
  goal vc_produces_trans : ([%#sskip] produces'0 a ab b)
   -> ([%#sskip'0] produces'0 b bc c)  -> ([%#sskip'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl [#"../../creusot-contracts/src/std/iter/take.rs" 71 4 71 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 70 14 70 45
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 71 27 71 29
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake'3 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take) : int
  
  axiom n_spec : forall self : t_Take . [%#stake'2] n self >= 0 /\ n self <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Take)
  
  axiom inv_axiom [@rewrite] : forall x : t_Take [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take) : t_I
  
  axiom iter_spec : forall self : t_Take . [%#stake'3] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take) (visited : Seq.seq t_Item) (o : t_Take)
  
   =
    [%#stake'1] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  constant self  : t_Take
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/take.rs" 71 4 71 26] (self'0 : t_Take) : ()
  
  goal vc_produces_refl : [%#stake] produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans [#"../../creusot-contracts/src/std/iter/take.rs" 77 4 77 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 74 15 74 32
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 75 15 75 32
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 76 14 76 42
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 77 91 77 93
  let%span stake'3 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake'4 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake'5 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take) : int
  
  axiom n_spec : forall self : t_Take . [%#stake'4] n self >= 0 /\ n self <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Take)
  
  axiom inv_axiom [@rewrite] : forall x : t_Take [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take) : t_I
  
  axiom iter_spec : forall self : t_Take . [%#stake'5] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take) (visited : Seq.seq t_Item) (o : t_Take)
  
   =
    [%#stake'3] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  constant a  : t_Take
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Take
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Take
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/take.rs" 77 4 77 90] (a'0 : t_Take) (ab'0 : Seq.seq t_Item) (b'0 : t_Take) (bc'0 : Seq.seq t_Item) (c'0 : t_Take) : ()
  
  
  goal vc_produces_trans : ([%#stake] produces'0 a ab b)
   -> ([%#stake'0] produces'0 b bc c)  -> ([%#stake'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 54 14 54 45
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 55 27 55 29
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'3 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A) (visited : Seq.seq t_Item) (o : t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A) (ab : Seq.seq t_Item) (b : t_A) (bc : Seq.seq t_Item) (c : t_A) : ()
  
  
  axiom produces_trans_spec : forall a : t_A, ab : Seq.seq t_Item, b : t_A, bc : Seq.seq t_Item, c : t_A . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A) : ()
  
  axiom produces_refl_spec : forall self : t_A . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Zip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Zip [inv'1 x] . inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip) : t_A
  
  axiom itera_spec : forall self : t_Zip . [%#szip'2] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B) (visited : Seq.seq t_Item'0) (o : t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B) (ab : Seq.seq t_Item'0) (b : t_B) (bc : Seq.seq t_Item'0) (c : t_B) : ()
  
  
  axiom produces_trans_spec'0 : forall a : t_B, ab : Seq.seq t_Item'0, b : t_B, bc : Seq.seq t_Item'0, c : t_B . ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B) : ()
  
  axiom produces_refl_spec'0 : forall self : t_B . [%#siter] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip) : t_B
  
  axiom iterb_spec : forall self : t_Zip . [%#szip'3] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip) (visited : Seq.seq tuple) (o : t_Zip)
  
   =
    [%#szip'1] exists p1 : Seq.seq t_Item, p2 : Seq.seq t_Item'0 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  constant self  : t_Zip
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (self'0 : t_Zip) : ()
  
  goal vc_produces_refl : [%#szip] produces'1 self (Seq.empty : Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 58 15 58 32
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 59 15 59 32
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 60 14 60 42
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 61 91 61 93
  let%span szip'3 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'4 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'5 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A) (visited : Seq.seq t_Item) (o : t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A) (ab : Seq.seq t_Item) (b : t_A) (bc : Seq.seq t_Item) (c : t_A) : ()
  
  
  axiom produces_trans_spec : forall a : t_A, ab : Seq.seq t_Item, b : t_A, bc : Seq.seq t_Item, c : t_A . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A) : ()
  
  axiom produces_refl_spec : forall self : t_A . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Zip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Zip [inv'1 x] . inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip) : t_A
  
  axiom itera_spec : forall self : t_Zip . [%#szip'4] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B) (visited : Seq.seq t_Item'0) (o : t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B) (ab : Seq.seq t_Item'0) (b : t_B) (bc : Seq.seq t_Item'0) (c : t_B) : ()
  
  
  axiom produces_trans_spec'0 : forall a : t_B, ab : Seq.seq t_Item'0, b : t_B, bc : Seq.seq t_Item'0, c : t_B . ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B) : ()
  
  axiom produces_refl_spec'0 : forall self : t_B . [%#siter] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip) : t_B
  
  axiom iterb_spec : forall self : t_Zip . [%#szip'5] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip) (visited : Seq.seq tuple) (o : t_Zip)
  
   =
    [%#szip'3] exists p1 : Seq.seq t_Item, p2 : Seq.seq t_Item'0 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  constant a  : t_Zip
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Zip
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Zip
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (a'0 : t_Zip) (ab'0 : Seq.seq tuple) (b'0 : t_Zip) (bc'0 : Seq.seq tuple) (c'0 : t_Zip) : ()
  
  
  goal vc_produces_trans : ([%#szip] produces'1 a ab b)
   -> ([%#szip'0] produces'1 b bc c)  -> ([%#szip'1] produces'1 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl [#"../../creusot-contracts/src/std/iter.rs" 231 4 231 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 230 14 230 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 231 27 231 29
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 219 20 219 64
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'5 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'3] produces a ab b)
   -> ([%#siter'4] produces b bc c)  -> ([%#siter'5] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter'2] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 218 4 218 64] (self : MutBorrow.t t_I) (visited : Seq.seq t_Item) (o : MutBorrow.t t_I)
  
   =
    [%#siter'1] produces self.current visited o.current /\ self.final = o.final
  
  constant self  : MutBorrow.t t_I
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 231 4 231 26] (self'0 : MutBorrow.t t_I) : ()
  
  goal vc_produces_refl : [%#siter] produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans [#"../../creusot-contracts/src/std/iter.rs" 238 4 238 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 235 15 235 32
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 236 15 236 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 237 14 237 42
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 238 91 238 93
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 219 20 219 64
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'5] produces a ab b)
   -> ([%#siter'6] produces b bc c)  -> ([%#siter'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter'4] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 218 4 218 64] (self : MutBorrow.t t_I) (visited : Seq.seq t_Item) (o : MutBorrow.t t_I)
  
   =
    [%#siter'3] produces self.current visited o.current /\ self.final = o.final
  
  constant a  : MutBorrow.t t_I
  
  constant ab  : Seq.seq t_Item
  
  constant b  : MutBorrow.t t_I
  
  constant bc  : Seq.seq t_Item
  
  constant c  : MutBorrow.t t_I
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 238 4 238 90] (a'0 : MutBorrow.t t_I) (ab'0 : Seq.seq t_Item) (b'0 : MutBorrow.t t_I) (bc'0 : Seq.seq t_Item) (c'0 : MutBorrow.t t_I) : ()
  
  
  goal vc_produces_trans : ([%#siter] produces'0 a ab b)
   -> ([%#siter'0] produces'0 b bc c)  -> ([%#siter'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_replace_body [#"../../creusot-contracts/src/std/mem.rs" 10 12 10 52]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 10 51 10 52
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'6 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'7 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_T [inv'0 x] . inv'0 x = invariant' x
  
  let rec swap (x:MutBorrow.t t_T) (y:MutBorrow.t t_T) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'4] inv'0 x}
    {[@expl:swap 'y' type invariant] [%#smem'5] inv'0 y}
    any
    [ return''0 (result:())-> {[%#smem'6] x.final = y.current} {[%#smem'7] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_replace_body[#"../../creusot-contracts/src/std/mem.rs" 10 12 10 52] (dest:MutBorrow.t t_T) (src:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_mem_replace_body 'dest' type invariant] [%#smem] inv'0 dest}
    {[@expl:extern_spec_std_mem_replace_body 'src' type invariant] [%#smem'0] inv src}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 =  [ &src'1 <- src'0 ] s1
      | s1 = {inv src'1}
        MutBorrow.borrow_mut <t_T> {src'1}
          (fun (_ret:MutBorrow.t t_T) ->  [ &_9 <- _ret ] -{inv _ret.final}-  [ &src'1 <- _ret.final ] s2)
      | s2 = {inv dest'0.current}
        MutBorrow.borrow_final <t_T> {dest'0.current} {MutBorrow.get_id dest'0}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_7 <- _ret ] 
            -{inv _ret.final}-
             [ &dest'0 <- { dest'0 with current = _ret.final } ] 
            s3)
      | s3 = {inv _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv _ret.final}-
             [ &_9 <- { _9 with current = _ret.final } ] 
            s4)
      | s4 = swap {_7} {_8} (fun (_ret:()) ->  [ &_6 <- _ret ] s5)
      | s5 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 _9} s1
      | s1 = -{resolve'0 _9}- s2
      | s2 = {[@expl:type invariant] inv'0 dest'0} s3
      | s3 = -{resolve'0 dest'0}- s4
      | s4 =  [ &_0 <- src'1 ] s5
      | s5 = bb3 ]
    
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    )
    [ & _0 : t_T = Any.any_l ()
    | & dest'0 : MutBorrow.t t_T = dest
    | & src'0 : t_T = src
    | & src'1 : t_T = Any.any_l ()
    | & _6 : () = Any.any_l ()
    | & _7 : MutBorrow.t t_T = Any.any_l ()
    | & _8 : MutBorrow.t t_T = Any.any_l ()
    | & _9 : MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_mem_replace_body result type invariant] [%#smem'1] inv result}
      {[@expl:extern_spec_std_mem_replace_body ensures #0] [%#smem'2] dest.final = src}
      {[@expl:extern_spec_std_mem_replace_body ensures #1] [%#smem'3] result = dest.current}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_take_body [#"../../creusot-contracts/src/std/mem.rs" 23 12 23 50]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 153 14 153 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 158 14 158 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 23 49 23 50
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'6 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : ())
  
  axiom precondition_fndef : forall args : () [precondition () args] . (let () = args in true)  -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : ()) (result : t_T)
  
  
  axiom postcondition_fndef : forall args : (), res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_T [inv'0 x] . inv'0 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_T) (src:t_T) (return'  (x:t_T))= {[@expl:replace 'dest' type invariant] [%#smem'3] inv'0 dest}
    {[@expl:replace 'src' type invariant] [%#smem'4] inv src}
    any
    [ return''0 (result:t_T)-> {inv result}
      {[%#smem'5] dest.final = src}
      {[%#smem'6] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve _0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : ()) (args : ()) (result_state : ()) (result : t_T)
  
  
  axiom postcondition_fndef'0 : forall args : (), res : t_T [postcondition_mut () args () res] . postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : t_T . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : t_T . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 41] (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : ()) (args : ()) (result : t_T)
  
  
  axiom postcondition_fndef'1 : forall args : (), res : t_T [postcondition () args res] . postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 51] (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : t_T . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'1 self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 154 4 154 67] (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : t_T . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_take_body[#"../../creusot-contracts/src/std/mem.rs" 23 12 23 50] (dest:MutBorrow.t t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_mem_take_body 'dest' type invariant] [%#smem] inv'0 dest}
    (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv dest'0.current}
        MutBorrow.borrow_final <t_T> {dest'0.current} {MutBorrow.get_id dest'0}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_4 <- _ret ] 
            -{inv _ret.final}-
             [ &dest'0 <- { dest'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_4} {_5} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 dest'0} s1 | s1 = -{resolve'0 dest'0}- s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0 : t_T = Any.any_l ()
    | & dest'0 : MutBorrow.t t_T = dest
    | & _4 : MutBorrow.t t_T = Any.any_l ()
    | & _5 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_mem_take_body result type invariant] [%#smem'0] inv result}
      {[@expl:extern_spec_std_mem_take_body ensures #0] [%#smem'1] result = dest.current}
      {[@expl:extern_spec_std_mem_take_body ensures #1] [%#smem'2] postcondition () () dest.final}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_drop_body [#"../../creusot-contracts/src/std/mem.rs" 4 0 36 1]
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 29 23 29 25
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 28 22 28 34
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_drop_body[#"../../creusot-contracts/src/std/mem.rs" 4 0 36 1] (_x:t_T) (return'  (x:()))= {[@expl:extern_spec_std_mem_drop_body '_x' type invariant] [%#smem] inv _x}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv _x'0} s1 | s1 = -{resolve _x'0}- s2 | s2 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0 : () = Any.any_l () | & _x'0 : t_T = _x ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_mem_drop_body ensures] [%#smem'0] resolve _x}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_forget_body [#"../../creusot-contracts/src/std/mem.rs" 4 0 36 1]
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 33 25 33 26
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 32 22 32 33
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_forget_body[#"../../creusot-contracts/src/std/mem.rs" 4 0 36 1] (t:t_T) (return'  (x:()))= {[@expl:extern_spec_std_mem_forget_body 't' type invariant] [%#smem] inv t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv t'0} s1 | s1 = -{resolve t'0}- s2 | s2 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0 : () = Any.any_l () | & t'0 : t_T = t ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_mem_forget_body ensures] [%#smem'0] resolve t}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_Try_Option_T_from_output_body [#"../../creusot-contracts/src/std/ops.rs" 276 36 278 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 278 31 278 37
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 276 28 276 37
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 277 26 277 48
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_option_T_Try_Option_T_from_output_body[#"../../creusot-contracts/src/std/ops.rs" 276 36 278 18] (output:t_T) (return'  (x:t_Option))= {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body 'output' type invariant] [%#sops] inv output}
    (! bb0
    [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- C_Some output'0 ] s1 | s1 = bb2 ]  | bb2 = bb3 | bb3 = return''0 {_0} ]
    ) [ & _0 : t_Option = Any.any_l () | & output'0 : t_T = output ] 
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body result type invariant] [%#sops'0] inv'0 result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body ensures] [%#sops'1] result = C_Some output}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_Try_Option_T_branch_body [#"../../creusot-contracts/src/std/ops.rs" 286 16 286 69]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 282 16 282 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 286 35 286 69
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 282 26 285 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 ()
  
  type t_ControlFlow  =
    | C_Continue t_T
    | C_Break t_Option'0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : ())
  
  axiom inv_axiom'0 [@rewrite] : forall x : () [inv'1 x] . inv'1 x = false
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_ControlFlow)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_ControlFlow [inv'3 x] . inv'3 x
  = match x with
    | C_Continue a_0 -> inv a_0
    | C_Break a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_option_T_Try_Option_T_branch_body[#"../../creusot-contracts/src/std/ops.rs" 286 16 286 69] (self_:t_Option) (return'  (x:t_ControlFlow))= {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body 'self_' type invariant] [%#sops] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = bb5
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &v <- r0 ] s1) | s1 =  [ &_0 <- C_Continue v ] s2 | s2 = bb6 ]
    
    | bb6 = bb7
    | bb7 = bb8
    | bb4 = s0 [ s0 =  [ &_6 <- C_None'0 ] s1 | s1 =  [ &_0 <- C_Break _6 ] s2 | s2 = bb8 ] 
    | bb8 = bb9
    | bb9 = return''0 {_0} ]
    )
    [ & _0 : t_ControlFlow = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & v : t_T = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l () ]
    
    [ return''0 (result:t_ControlFlow)-> {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body result type invariant] [%#sops'0] inv'3 result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body ensures] [%#sops'1] match self_ with
        | C_Some v -> result = C_Continue v
        | C_None -> result = C_Break (C_None'0)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body [#"../../creusot-contracts/src/std/ops.rs" 294 65 296 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 296 33 296 41
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 294 57 294 66
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 295 26 295 40
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 ()
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : ())
  
  axiom inv_axiom [@rewrite] : forall x : () [inv x] . inv x = false
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body[#"../../creusot-contracts/src/std/ops.rs" 294 65 296 18] (residual:t_Option'0) (return'  (x:t_Option))= {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body 'residual' type invariant] [%#sops] inv'0 residual}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = return''0 {_0} ]  ] ) [ & _0 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body result type invariant] [%#sops'0] inv'2 result}
      {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body ensures] [%#sops'1] result
      = C_None}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_Try_Result_T_E_from_output_body [#"../../creusot-contracts/src/std/ops.rs" 306 42 308 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 308 31 308 37
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 306 31 306 43
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 307 26 307 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result)
  
  axiom inv_axiom [@rewrite] : forall x : t_Result [inv'1 x] . inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_from_output_body[#"../../creusot-contracts/src/std/ops.rs" 306 42 308 18] (output:t_T) (return'  (x:t_Result))= {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body 'output' type invariant] [%#sops] inv output}
    (! bb0
    [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- C_Ok output'0 ] s1 | s1 = bb2 ]  | bb2 = bb3 | bb3 = return''0 {_0} ]
    ) [ & _0 : t_Result = Any.any_l () | & output'0 : t_T = output ] 
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body result type invariant] [%#sops'0] inv'1 result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body ensures] [%#sops'1] result = C_Ok output}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_Try_Result_T_E_branch_body [#"../../creusot-contracts/src/std/ops.rs" 316 16 316 72]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 312 16 312 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 316 35 316 72
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 312 26 315 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_E [C_Err field_0 : t_Result] . C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_Result'0  =
    | C_Ok'0 ()
    | C_Err'0 t_E
  
  type t_ControlFlow  =
    | C_Continue t_T
    | C_Break t_Result'0
  
  let rec v_Ok (input:t_Result) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Ok field_0 : t_Result] . C_Ok field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result)
  
  axiom inv_axiom [@rewrite] : forall x : t_Result [inv'1 x] . inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : ())
  
  axiom inv_axiom'0 [@rewrite] : forall x : () [inv'2 x] . inv'2 x = false
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Result'0 [inv'3 x] . inv'3 x
  = match x with
    | C_Ok'0 a_0 -> inv'2 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_ControlFlow)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_ControlFlow [inv'4 x] . inv'4 x
  = match x with
    | C_Continue a_0 -> inv a_0
    | C_Break a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_branch_body[#"../../creusot-contracts/src/std/ops.rs" 316 16 316 72] (self_:t_Result) (return'  (x:t_ControlFlow))= {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body 'self_' type invariant] [%#sops] inv'1 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 (x0:t_T)-> {self_'0 = C_Ok x0} (! bb3) | br1 (x0:t_E)-> {self_'0 = C_Err x0} (! bb4) ] 
    | bb4 = s0 [ s0 = v_Err {self_'0} (fun (r0:t_E) ->  [ &e <- r0 ] s1) | s1 =  [ &_7 <- C_Err'0 e ] s2 | s2 = bb8 ] 
    | bb8 = s0 [ s0 =  [ &_0 <- C_Break _7 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb3 = bb5
    | bb5 = s0 [ s0 = v_Ok {self_'0} (fun (r0:t_T) ->  [ &v <- r0 ] s1) | s1 =  [ &_0 <- C_Continue v ] s2 | s2 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb11
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0 : t_ControlFlow = Any.any_l ()
    | & self_'0 : t_Result = self_
    | & v : t_T = Any.any_l ()
    | & e : t_E = Any.any_l ()
    | & _7 : t_Result'0 = Any.any_l () ]
    
    [ return''0 (result:t_ControlFlow)-> {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body result type invariant] [%#sops'0] inv'4 result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body ensures] [%#sops'1] match self_ with
        | C_Ok v -> result = C_Continue v
        | C_Err e -> result = C_Break (C_Err'0 e)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body [#"../../creusot-contracts/src/std/ops.rs" 324 86 329 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 329 33 329 41
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 324 75 324 87
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 325 26 328 17
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 153 14 153 114
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 158 14 158 101
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 61
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'9 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'10 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'11 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  
  use creusot.prelude.Any
  
  type t_E
  
  type t_Result  =
    | C_Ok ()
    | C_Err t_E
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_E [C_Err field_0 : t_Result] . C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_E)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : t_E)
  
  axiom precondition_fndef : forall args : t_E [precondition () args] . (let value = args in inv value)
   -> precondition () args
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : t_E) (result : t_F)
  
  
  axiom postcondition_fndef : forall args : t_E, res : t_F [postcondition_once () args res] . postcondition_once () args res
   -> (let value = args in inv'0 res)
  
  let rec from (value:t_E) (return'  (x:t_F))= {[@expl:from requires] precondition () value}
    any [ return''0 (result:t_F)-> {postcondition_once () value result} (! return' {result}) ] 
  
  type t_T
  
  type t_Result'0  =
    | C_Ok'0 t_T
    | C_Err'0 t_F
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : ())
  
  axiom inv_axiom [@rewrite] : forall x : () [inv'1 x] . inv'1 x = false
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Result [inv'2 x] . inv'2 x
  = match x with
    | C_Ok a_0 -> inv'1 a_0
    | C_Err a_0 -> inv a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Result'0 [inv'4 x] . inv'4 x
  = match x with
    | C_Ok'0 a_0 -> inv'3 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  type tuple  =
    { _p0: t_Result'0; _p1: t_Result }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : ()) (args : t_E) (result_state : ()) (result : t_F)
  
  
  axiom postcondition_fndef'0 : forall args : t_E, res : t_F [postcondition_mut () args () res] . postcondition_mut () args () res
   -> (let value = args in inv'0 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : ()) (args : t_E) (res : t_F) : ()
  
  
  axiom fn_mut_once_spec : forall self : (), args : t_E, res : t_F . [%#sops'11] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'8] hist_inv self b)
   -> ([%#sops'9] hist_inv b c)  -> ([%#sops'10] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'7] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : ()) (args : t_E) (res_state : ()) (res : t_F) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : t_E, res_state : (), res : t_F . ([%#sops'5] postcondition_mut self args res_state res)
   -> ([%#sops'6] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 41] (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'4] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : ()) (args : t_E) (result : t_F)
  
  
  axiom postcondition_fndef'1 : forall args : t_E, res : t_F [postcondition () args res] . postcondition () args res
   -> (let value = args in inv'0 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 51] (self : ()) (args : t_E) (res : t_F) : ()
  
  axiom fn_once_spec : forall self : (), args : t_E, res : t_F . [%#sops'3] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 154 4 154 67] (self : ()) (args : t_E) (res_state : ()) (res : t_F) : ()
  
  
  axiom fn_mut_spec : forall self : (), args : t_E, res_state : (), res : t_F . [%#sops'2] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body[#"../../creusot-contracts/src/std/ops.rs" 324 86 329 18] (residual:t_Result) (return'  (x:t_Result'0))= {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body 'residual' type invariant] [%#sops] inv'2 residual}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = v_Err {residual'0} (fun (r0:t_E) ->  [ &e <- r0 ] s1)
      | s1 = from {e} (fun (_ret:t_F) ->  [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 =  [ &_0 <- C_Err'0 _4 ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = return''0 {_0} ]
    )
    [ & _0 : t_Result'0 = Any.any_l ()
    | & residual'0 : t_Result = residual
    | & e : t_E = Any.any_l ()
    | & _4 : t_F = Any.any_l () ]
    
    [ return''0 (result:t_Result'0)-> {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body result type invariant] [%#sops'0] inv'4 result}
      {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body ensures] [%#sops'1] match { _p0 = result;
                                                                                                                                       _p1 = residual } with
        | {_p0 = C_Err'0 result'0 ; _p1 = C_Err residual'0} -> postcondition () residual'0 result'0
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_PartialEq_Option_T_eq_body [#"../../creusot-contracts/src/std/option.rs" 24 16 24 48]
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 11 16 11 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 12 29 12 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 28 29 28 34
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 26 40 26 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 22 16 22 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 24 29 24 32
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  let rec eq (self_:t_T) (rhs:t_T) (return'  (x:bool))= {[@expl:eq 'self_' type invariant] [%#scmp] inv'1 self_}
    {[@expl:eq 'rhs' type invariant] [%#scmp'0] inv'1 rhs}
    any
    [ return''0 (result:bool)-> {[%#scmp'1] result = (deep_model'1 self_ = deep_model'1 rhs)} (! return' {result}) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Option) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option [inv'3 x] . inv'3 x = invariant''1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_DeepModelTy
  
  function deep_model'2 [#"../../creusot-contracts/src/std/option.rs" 10 4 10 44] (self : t_Option) : t_Option'0 =
    [%#soption'4] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Option) : t_Option'0 =
    [%#smodel] deep_model'2 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_PartialEq_Option_T_eq_body[#"../../creusot-contracts/src/std/option.rs" 24 16 24 48] (self_:t_Option) (rhs:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body 'self_' type invariant] [%#soption'1] inv'3 self_}
    {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body 'rhs' type invariant] [%#soption'2] inv'3 rhs}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = rhs'0 } ] s1
      | s1 = any [ br0 -> {_4._p0 = C_None} (! bb2) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb4) ]  ]
    
    | bb4 = any [ br0 -> {_4._p1 = C_None} (! bb12) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb5) ] 
    | bb12 = bb1
    | bb5 = bb6
    | bb6 = s0
      [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &x <- r0 ] s1)
      | s1 = v_Some {_4._p1} (fun (r0:t_T) ->  [ &y <- r0 ] s2)
      | s2 = eq {x} {y} (fun (_ret:bool) ->  [ &_0 <- _ret ] s3)
      | s3 = bb8 ]
    
    | bb8 = bb9
    | bb2 = any [ br0 -> {_4._p1 = C_None} (! bb3) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb1) ] 
    | bb1 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb9 ] 
    | bb3 = bb7
    | bb7 = s0 [ s0 =  [ &_0 <- [%#soption'0] true ] s1 | s1 = bb9 ] 
    | bb9 = return''0 {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & rhs'0 : t_Option = rhs
    | & _4 : tuple = Any.any_l ()
    | & x : t_T = Any.any_l ()
    | & y : t_T = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body ensures] [%#soption'3] result
      = (deep_model'3 self_ = deep_model'3 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_some_body [#"../../creusot-contracts/src/std/option.rs" 42 16 42 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 45 35 45 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 44 32 44 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 40 16 40 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 41 26 41 51
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_some_body[#"../../creusot-contracts/src/std/option.rs" 42 16 42 41] (self_:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_some_body 'self_' type invariant] [%#soption'1] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [%#soption] true ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption'0] false ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self_'0 : t_Option = self_ ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_some_body ensures] [%#soption'2] result
      = (self_ <> C_None)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_some_and_body [#"../../creusot-contracts/src/std/option.rs" 57 16 57 71]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 173 35 173 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 59 32 59 37
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 49 16 49 17
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 57 37 57 38
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 49 27 52 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 53 26 56 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type impl_FnOnce_T_____bool
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : impl_FnOnce_T_____bool)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : impl_FnOnce_T_____bool) (args : t_T)
  
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : impl_FnOnce_T_____bool) (args : t_T) (result : bool)
  
  
  let rec call_once (self_:impl_FnOnce_T_____bool) (arg:t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : impl_FnOnce_T_____bool)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_some_and_body[#"../../creusot-contracts/src/std/option.rs" 57 16 57 71] (self_:t_Option) (f:impl_FnOnce_T_____bool) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'self_' type invariant] [%#soption'0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'f' type invariant] [%#soption'1] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body requires] [%#soption'2] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_8 <- t ] s2
      | s2 = call_once {f'0} {_8} (fun (_ret:bool) ->  [ &_0 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & f'0 : impl_FnOnce_T_____bool = f
    | & t : t_T = Any.any_l ()
    | & _8 : t_T = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body ensures] [%#soption'3] match self_ with
        | C_None -> result = false
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_none_body [#"../../creusot-contracts/src/std/option.rs" 66 16 66 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 69 35 69 40
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 68 32 68 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 64 16 64 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_none_body[#"../../creusot-contracts/src/std/option.rs" 66 16 66 41] (self_:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_none_body 'self_' type invariant] [%#soption'1] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption'0] true ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self_'0 : t_Option = self_ ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_none_body ensures] [%#soption'2] result
      = (self_ = C_None)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_ref_body [#"../../creusot-contracts/src/std/option.rs" 78 16 78 46]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 73 16 73 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 78 36 78 46
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 74 26 74 58
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 76 20 76 89
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_ref_body[#"../../creusot-contracts/src/std/option.rs" 78 16 78 46] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_as_ref_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- C_Some'0 t ] s2 | s2 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_'0 : t_Option = self_ | & t : t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_ref_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #0] [%#soption'1] self_ = C_None
       -> result = C_None'0}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #1] [%#soption'2] self_ = C_None
      \/ (exists r : t_T . result = C_Some'0 r /\ self_ = C_Some r)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_mut_body [#"../../creusot-contracts/src/std/option.rs" 91 16 91 54]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 85 16 85 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 91 40 91 54
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 86 26 86 75
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 88 20 89 100
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve _0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_Option) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_Option) =
    resolve'1 _0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_mut_body[#"../../creusot-contracts/src/std/option.rs" 91 16 91 54] (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_as_mut_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 =  [ &_0 <- C_Some'0 _6 ] s3
      | s3 = {[@expl:type invariant] inv'0 t} s4
      | s4 = -{resolve'0 t}- s5
      | s5 = bb5 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_'0 : MutBorrow.t t_Option = self_
    | & t : MutBorrow.t t_T = Any.any_l ()
    | & _6 : MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_mut_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #0] [%#soption'1] self_.current = C_None
       -> result = C_None'0 /\ self_.final = C_None}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #1] [%#soption'2] self_.current = C_None
      \/ (exists r : MutBorrow.t t_T . result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_slice_body [#"../../creusot-contracts/src/std/option.rs" 103 16 103 42]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 673 20 673 95
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 379 27 379 28
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 377 22 377 40
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 378 22 378 38
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 17 20 17 30
  let%span soption = "../../creusot-contracts/src/std/option.rs" 98 16 98 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 38 103 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 99 26 102 17
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T) =
    [%#sboxed] inv self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/logic/seq.rs" 672 4 672 30] (self : Seq.seq t_T) =
    [%#sseq] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T [inv'2 x] . inv'2 x = invariant''1 x
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'2] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'3] view self = Slice64.id self)
  
  predicate invariant''2 [#"../../creusot-contracts/src/std/slice.rs" 16 4 16 30] (self : Slice64.slice t_T) =
    [%#sslice'4] inv'2 (view self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Slice64.slice t_T)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Slice64.slice t_T [inv'3 x] . inv'3 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : Slice64.slice t_T) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Slice64.slice t_T)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Slice64.slice t_T [inv'4 x] . inv'4 x = invariant''3 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  let rec from_ref (s:t_T) (return'  (x:Slice64.slice t_T))= {[@expl:from_ref 's' type invariant] [%#sslice] inv'0 s}
    any
    [ return''0 (result:Slice64.slice t_T)-> {inv'4 result}
      {[%#sslice'0] Seq.length (view'0 result) = 1}
      {[%#sslice'1] Seq.get (view'0 result) 0 = s}
      (! return' {result}) ]
  
  
  let rec promoted0__extern_spec_std_option_T_Option_T_as_slice_body (return'  (x:Slice64.array t_T))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array t_T)-> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0 : Slice64.array t_T = Any.any_l () | & _1 : Slice64.array t_T = Any.any_l () ] 
    [ return''0 (result:Slice64.array t_T)-> return' {result} ]
  
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option [inv'5 x] . inv'5 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''4 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Option) =
    [%#sinvariant] inv'5 self
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Option [inv'6 x] . inv'6 x = invariant''4 x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_slice_body[#"../../creusot-contracts/src/std/option.rs" 103 16 103 42] (self_:t_Option) (return'  (x:Slice64.slice t_T))= {[@expl:extern_spec_std_option_T_Option_T_as_slice_body 'self_' type invariant] [%#soption] inv'6 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = from_ref {t} (fun (_ret:Slice64.slice t_T) ->  [ &_9 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_3 <- _9 ] s1 | s1 = bb6 ] 
    | bb2 = bb4
    | bb4 = s0
      [ s0 = promoted0__extern_spec_std_option_T_Option_T_as_slice_body 
          (fun (pr0:Slice64.array t_T) ->  [ &_11 <- pr0 ] s1)
      | s1 =  [ &_6 <- _11 ] s2
      | s2 =  [ &_3 <- _6 ] s3
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- _3 ] s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0 : Slice64.slice t_T = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & _3 : Slice64.slice t_T = Any.any_l ()
    | & _6 : Slice64.array t_T = Any.any_l ()
    | & t : t_T = Any.any_l ()
    | & _9 : Slice64.slice t_T = Any.any_l ()
    | & _11 : Slice64.array t_T = Any.any_l () ]
    
    [ return''0 (result:Slice64.slice t_T)-> {[@expl:extern_spec_std_option_T_Option_T_as_slice_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_slice_body ensures] [%#soption'1] match self_ with
        | C_None -> Seq.length (view'0 result) = 0
        | C_Some t -> Seq.length (view'0 result) = 1 /\ Seq.get (view'0 result) 0 = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_mut_slice_body [#"../../creusot-contracts/src/std/option.rs" 118 16 118 54]
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 10 20 10 30
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 673 20 673 95
  let%span smodel = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 386 27 386 28
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 382 22 382 40
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 383 22 383 38
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 384 22 384 43
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 385 22 385 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 17 20 17 30
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 110 16 110 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 118 46 118 54
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 111 26 117 17
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T) =
    [%#sboxed] inv self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/logic/seq.rs" 672 4 672 30] (self : Seq.seq t_T) =
    [%#sseq] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T [inv'2 x] . inv'2 x = invariant''1 x
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'4] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'5] view self = Slice64.id self)
  
  predicate invariant''2 [#"../../creusot-contracts/src/std/slice.rs" 16 4 16 30] (self : Slice64.slice t_T) =
    [%#sslice'6] inv'2 (view self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Slice64.slice t_T)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Slice64.slice t_T [inv'3 x] . inv'3 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t (Slice64.slice t_T))
  
   =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t (Slice64.slice t_T))
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t (Slice64.slice t_T) [inv'4 x] . inv'4 x = invariant''3 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  let rec from_mut (s:MutBorrow.t t_T) (return'  (x:MutBorrow.t (Slice64.slice t_T)))= {[@expl:from_mut 's' type invariant] [%#sslice] inv'0 s}
    any
    [ return''0 (result:MutBorrow.t (Slice64.slice t_T))-> {inv'4 result}
      {[%#sslice'0] Seq.length (view'0 result) = 1}
      {[%#sslice'1] Seq.get (view'0 result) 0 = s.current}
      {[%#sslice'2] Seq.length (view result.final) = 1}
      {[%#sslice'3] Seq.get (view result.final) 0 = s.final}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t (Slice64.slice t_T)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t (Slice64.slice t_T)) =
    resolve _0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve'1 _0
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option [inv'5 x] . inv'5 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''4 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_Option) =
    [%#sinvariant] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_Option)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_Option [inv'6 x] . inv'6 x = invariant''4 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_Option) =
    resolve'3 _0
  
  predicate invariant''5 [#"../../creusot-contracts/src/std/array.rs" 9 4 9 30] (self : Slice64.array t_T) =
    [%#sarray] inv'2 (Slice64.id self)
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Slice64.array t_T)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Slice64.array t_T [inv'7 x] . inv'7 x = invariant''5 x
  
  let rec promoted0__extern_spec_std_option_T_Option_T_as_mut_slice_body (return'  (x:MutBorrow.t (Slice64.array t_T)))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array t_T)-> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 = {inv'7 _1}
        MutBorrow.borrow_mut <Slice64.array t_T> {_1}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_0 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_1 <- _ret.final ] 
            s2)
      | s2 = return''0 {_0} ]
     ]
     [ & _0 : MutBorrow.t (Slice64.array t_T) = Any.any_l () | & _1 : Slice64.array t_T = Any.any_l () ] 
    [ return''0 (result:MutBorrow.t (Slice64.array t_T))-> return' {result} ]
  
  
  predicate invariant''6 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t (Slice64.array t_T))
  
   =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t (Slice64.array t_T))
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t (Slice64.array t_T) [inv'8 x] . inv'8 x = invariant''6 x
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t (Slice64.array t_T)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t (Slice64.array t_T)) =
    resolve'5 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_mut_slice_body[#"../../creusot-contracts/src/std/option.rs" 118 16 118 54] (self_:MutBorrow.t t_Option) (return'  (x:MutBorrow.t (Slice64.slice t_T)))= {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body 'self_' type invariant] [%#soption] inv'6 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_11 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 = from_mut {_11} (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->  [ &_10 <- _ret ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0
      [ s0 = {inv'3 _10.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_4 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_10 <- { _10 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'0 t} s4
      | s4 = -{resolve'2 t}- s5
      | s5 = bb6 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'6 self_'0} s1 | s1 = -{resolve'4 self_'0}- s2 | s2 = bb4 ] 
    | bb4 = s0
      [ s0 = promoted0__extern_spec_std_option_T_Option_T_as_mut_slice_body 
          (fun (pr0:MutBorrow.t (Slice64.array t_T)) ->  [ &_12 <- pr0 ] s1)
      | s1 = {inv'7 _12.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_7 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_12 <- { _12 with current = _ret.final } ] 
            s2)
      | s2 = {inv'7 _7.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_7.current} {MutBorrow.get_id _7}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_6 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_7 <- { _7 with current = _ret.final } ] 
            s3)
      | s3 =  [ &_4 <- _6 ] s4
      | s4 = {[@expl:type invariant] inv'8 _7} s5
      | s5 = -{resolve'6 _7}- s6
      | s6 = bb8 ]
    
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'8 _12} s1 | s1 = -{resolve'6 _12}- s2 | s2 = bb6 ] 
    | bb6 = s0
      [ s0 = {inv'3 _4.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_4.current} {MutBorrow.get_id _4}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_2 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_4 <- { _4 with current = _ret.final } ] 
            s1)
      | s1 = {inv'3 _2.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_0 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_2 <- { _2 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 _4} s3
      | s3 = -{resolve'0 _4}- s4
      | s4 = {[@expl:type invariant] inv'4 _2} s5
      | s5 = -{resolve'0 _2}- s6
      | s6 = {[@expl:type invariant] inv'6 self_'0} s7
      | s7 = -{resolve'4 self_'0}- s8
      | s8 = return''0 {_0} ]
     ]
    )
    [ & _0 : MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & self_'0 : MutBorrow.t t_Option = self_
    | & _2 : MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _4 : MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _6 : MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & _7 : MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & t : MutBorrow.t t_T = Any.any_l ()
    | & _10 : MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _11 : MutBorrow.t t_T = Any.any_l ()
    | & _12 : MutBorrow.t (Slice64.array t_T) = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t (Slice64.slice t_T))-> {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body ensures] [%#soption'1] match self_.current with
        | C_None -> Seq.length (view'0 result) = 0
        | C_Some _ -> exists b : MutBorrow.t t_T . self_.current = C_Some (b.current)
        /\ self_.final = C_Some (b.final)
        /\ Seq.get (view result.current) 0 = b.current
        /\ Seq.get (view result.final) 0 = b.final
        /\ Seq.length (view result.current) = 1 /\ Seq.length (view result.final) = 1
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_expect_body [#"../../creusot-contracts/src/std/option.rs" 128 16 128 47]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 125 16 125 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 126 27 126 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 128 46 128 47
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 127 26 127 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_expect_body[#"../../creusot-contracts/src/std/option.rs" 128 16 128 47] (self_:t_Option) (msg:string) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_expect_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_expect_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return''0 {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0 : t_T = Any.any_l () | & self_'0 : t_Option = self_ | & t : t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_expect_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_expect_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_body [#"../../creusot-contracts/src/std/option.rs" 138 16 138 36]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 135 16 135 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 138 35 138 36
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_body[#"../../creusot-contracts/src/std/option.rs" 138 16 138 36] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return''0 {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0 : t_T = Any.any_l () | & self_'0 : t_Option = self_ | & t : t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_body [#"../../creusot-contracts/src/std/option.rs" 148 16 148 51]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 145 16 145 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 148 35 148 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 148 50 148 51
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 146 26 146 60
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 147 26 147 85
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_body[#"../../creusot-contracts/src/std/option.rs" 148 16 148 51] (self_:t_Option) (default:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'default' type invariant] [%#soption'0] inv default}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- default'0 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = return''0 {_0} ]
    )
    [ & _0 : t_T = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & default'0 : t_T = default
    | & t : t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #0] [%#soption'2] self_ = C_None
       -> result = default}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #1] [%#soption'3] self_ = C_None
      \/ self_ = C_Some result /\ resolve default}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body [#"../../creusot-contracts/src/std/option.rs" 160 16 162 36]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 155 16 155 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 160 43 160 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 155 27 155 62
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 160 52 160 53
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 156 26 159 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : ()) (result : t_T)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_T))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_T)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body[#"../../creusot-contracts/src/std/option.rs" 160 16 162 36] (self_:t_Option) (f:t_F) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body requires] [%#soption'1] self_ = C_None
     -> precondition f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb8 ]
    
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once {f'0} {_7} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0 : t_T = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & f'0 : t_F = f
    | & _7 : () = Any.any_l ()
    | & t : t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body result type invariant] [%#soption'2] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_default_body [#"../../creusot-contracts/src/std/option.rs" 171 16 173 30]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 153 14 153 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 158 14 158 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span soption = "../../creusot-contracts/src/std/option.rs" 169 16 169 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 171 46 171 47
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 169 26 169 79
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 170 26 170 62
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : ())
  
  axiom precondition_fndef : forall args : () [precondition () args] . (let () = args in true)  -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : ()) (result : t_T)
  
  
  axiom postcondition_fndef : forall args : (), res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : ()) (args : ()) (result_state : ()) (result : t_T)
  
  
  axiom postcondition_fndef'0 : forall args : (), res : t_T [postcondition_mut () args () res] . postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : t_T . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : t_T . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 41] (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : ()) (args : ()) (result : t_T)
  
  
  axiom postcondition_fndef'1 : forall args : (), res : t_T [postcondition () args res] . postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 51] (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : t_T . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 154 4 154 67] (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : t_T . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_default_body[#"../../creusot-contracts/src/std/option.rs" 171 16 173 30] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body 'self_' type invariant] [%#soption] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = return''0 {_0} ]
    ) [ & _0 : t_T = Any.any_l () | & self_'0 : t_Option = self_ | & t : t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body result type invariant] [%#soption'0] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #0] [%#soption'1] self_ = C_None
       -> postcondition () () result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #1] [%#soption'2] self_ = C_None
      \/ self_ = C_Some result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_unchecked_body [#"../../creusot-contracts/src/std/option.rs" 183 16 183 53]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 180 16 180 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 181 27 181 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 183 52 183 53
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 182 26 182 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_unchecked_body[#"../../creusot-contracts/src/std/option.rs" 183 16 183 53] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return''0 {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0 : t_T = Any.any_l () | & self_'0 : t_Option = self_ | & t : t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_body [#"../../creusot-contracts/src/std/option.rs" 198 16 200 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 173 35 173 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 190 16 190 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 198 35 198 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 190 27 193 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 198 44 198 53
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 194 26 197 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_U)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_T) (result : t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'2 result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'3 x] . inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_body[#"../../creusot-contracts/src/std/option.rs" 198 16 200 37] (self_:t_Option) (f:t_F) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_map_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_map_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_9 <- t ] s2
      | s2 = call_once {f'0} {_9} (fun (_ret:t_U) ->  [ &_7 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'0 _7 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return''0 {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & f'0 : t_F = f
    | & t : t_T = Any.any_l ()
    | & _7 : t_U = Any.any_l ()
    | & _9 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_body result type invariant] [%#soption'2] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> exists r : t_U . result = C_Some'0 r /\ postcondition_once f t r
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_inspect_body [#"../../creusot-contracts/src/std/option.rs" 216 16 218 33]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 173 35 173 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 207 16 207 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 216 36 216 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 207 27 210 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 216 45 216 54
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 211 26 211 40
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 212 26 215 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T [inv'2 x] . inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_T) (result : ())
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:()))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:())-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option [inv'3 x] . inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_inspect_body[#"../../creusot-contracts/src/std/option.rs" 216 16 218 33] (self_:t_Option) (f:t_F) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = any [ br0 -> {self_'0 = C_None} (! bb5) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb6) ] 
    | bb6 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_12 <- t ] s2
      | s2 =  [ &_10 <- _12 ] s3
      | s3 = call_once {f'0} {_10} (fun (_ret:()) ->  [ &_8 <- _ret ] s4)
      | s4 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb5 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return''0 {_0} ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & f'0 : t_F = f
    | & t : t_T = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & _10 : t_T = Any.any_l ()
    | & _12 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_inspect_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #0] [%#soption'3] result = self_}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #1] [%#soption'4] match self_ with
        | C_None -> true
        | C_Some t -> postcondition_once f t ()
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_body [#"../../creusot-contracts/src/std/option.rs" 233 16 235 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 173 35 173 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 225 16 225 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 233 38 233 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 233 50 233 51
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 225 27 228 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 233 59 233 60
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 229 26 232 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_U
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_U)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_U)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'2 x] . inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_T) (result : t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:t_U)-> {inv result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'3 x] . inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_body[#"../../creusot-contracts/src/std/option.rs" 233 16 235 37] (self_:t_Option) (default:t_U) (f:t_F) (return'  (x:t_U))= {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'default' type invariant] [%#soption'0] inv default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'f' type invariant] [%#soption'1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body requires] [%#soption'2] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_9 <- t ] s4
      | s4 = call_once {f'0} {_9} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s5)
      | s5 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f'0} s1 | s1 = -{resolve'0 f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- default'0 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return''0 {_0} ]
    )
    [ & _0 : t_U = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & default'0 : t_U = default
    | & f'0 : t_F = f
    | & t : t_T = Any.any_l ()
    | & _9 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_U)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_body result type invariant] [%#soption'3] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_body ensures] [%#soption'4] match self_ with
        | C_None -> result = default
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_else_body [#"../../creusot-contracts/src/std/option.rs" 250 16 253 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 173 35 173 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 242 16 242 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 250 46 250 53
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 250 58 250 59
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 242 27 245 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 250 67 250 68
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 246 26 249 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_D
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_D)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_D)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_F
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'2 x] . inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_T)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_U)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_T) (result : t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'3 result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_D) (args : ())
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_D) (args : ()) (result : t_U)
  
  
  let rec call_once'0 (self_:t_D) (arg:()) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'1] precondition'0 self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'3 result} {[%#sops'2] postcondition_once'0 self_ arg result} (! return' {result}) ]
  
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'4 x] . inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body[#"../../creusot-contracts/src/std/option.rs" 250 16 253 37] (self_:t_Option) (default:t_D) (f:t_F) (return'  (x:t_U))= {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'default' type invariant] [%#soption'0] inv default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'f' type invariant] [%#soption'1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body requires] [%#soption'2] match self_ with
      | C_None -> precondition'0 default ()
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_11 <- t ] s4
      | s4 = call_once {f'0} {_11} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s5)
      | s5 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f'0} s1 | s1 = -{resolve'0 f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 = call_once'0 {default'0} {_8} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = return''0 {_0} ]
    )
    [ & _0 : t_U = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & default'0 : t_D = default
    | & f'0 : t_F = f
    | & _8 : () = Any.any_l ()
    | & t : t_T = Any.any_l ()
    | & _11 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_U)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body result type invariant] [%#soption'3] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body ensures] [%#soption'4] match self_ with
        | C_None -> postcondition_once'0 default () result
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_body [#"../../creusot-contracts/src/std/option.rs" 265 16 265 57]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 260 16 260 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 265 34 265 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 265 45 265 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 261 26 264 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_E
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_E)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_E)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Result [inv'2 x] . inv'2 x
  = match x with
    | C_Ok a_0 -> inv'0 a_0
    | C_Err a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_body[#"../../creusot-contracts/src/std/option.rs" 265 16 265 57] (self_:t_Option) (err:t_E) (return'  (x:t_Result))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'err' type invariant] [%#soption'0] inv err}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0 = C_None} (! bb3) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb4) ] 
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv err'0} s1
      | s1 = -{resolve err'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Ok t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb3 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- C_Err err'0 ] s1 | s1 = bb6 ] 
    | bb6 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0 : t_Result = Any.any_l () | & self_'0 : t_Option = self_ | & err'0 : t_E = err | & t : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_body result type invariant] [%#soption'1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_body ensures] [%#soption'2] match self_ with
        | C_None -> result = C_Err err
        | C_Some t -> result = C_Ok t /\ resolve err
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_else_body [#"../../creusot-contracts/src/std/option.rs" 277 16 279 36]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 272 16 272 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 277 42 277 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 272 27 272 64
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 277 53 277 65
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 273 26 276 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_E)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : ()) (result : t_E)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_E))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_E)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Result [inv'3 x] . inv'3 x
  = match x with
    | C_Ok a_0 -> inv'1 a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body[#"../../creusot-contracts/src/std/option.rs" 277 16 279 36] (self_:t_Option) (err:t_F) (return'  (x:t_Result))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'err' type invariant] [%#soption'0] inv err}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body requires] [%#soption'1] self_ = C_None
     -> precondition err ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv err'0} s1
      | s1 = -{resolve err'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Ok t ] s4
      | s4 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once {err'0} {_8} (fun (_ret:t_E) ->  [ &_6 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_Err _6 ] s1 | s1 = bb8 ] 
    | bb8 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return''0 {_0} ]
    )
    [ & _0 : t_Result = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & err'0 : t_F = err
    | & _6 : t_E = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & t : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> exists r : t_E . result = C_Err r /\ postcondition_once err () r
        | C_Some t -> result = C_Ok t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_body [#"../../creusot-contracts/src/std/option.rs" 289 16 289 61]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 286 16 286 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 289 32 289 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 289 52 289 61
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 287 26 287 75
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 288 26 288 76
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Option) =
    resolve'0 _0
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_U)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_U)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option'0) =
    [%#sresolve] match self with
      | C_Some'0 x -> resolve'2 x
      | C_None'0 -> true
      end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Option'0) =
    resolve'3 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_body[#"../../creusot-contracts/src/std/option.rs" 289 16 289 61] (self_:t_Option) (optb:t_Option'0) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_body 'optb' type invariant] [%#soption'0] inv'2 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_'0} s1
      | s1 = -{resolve'1 self_'0}- s2
      | s2 =  [ &_0 <- optb'0 ] s3
      | s3 = bb7 ]
    
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'2 optb'0} s1
      | s1 = -{resolve'4 optb'0}- s2
      | s2 = {[@expl:type invariant] inv'0 self_'0} s3
      | s3 = -{resolve'1 self_'0}- s4
      | s4 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = return''0 {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_'0 : t_Option = self_ | & optb'0 : t_Option'0 = optb ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_body result type invariant] [%#soption'1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #0] [%#soption'2] self_ = C_None
       -> result = C_None'0 /\ resolve'3 optb}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #1] [%#soption'3] self_ = C_None
      \/ result = optb /\ resolve'0 self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_then_body [#"../../creusot-contracts/src/std/option.rs" 304 16 306 45]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 173 35 173 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 296 16 296 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 304 40 304 41
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 296 27 299 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 304 49 304 58
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 300 26 303 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_U)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_T) (result : t_Option'0)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_Option'0))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_Option'0)-> {inv'3 result}
      {[%#sops'2] postcondition_once self_ arg result}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option [inv'4 x] . inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_then_body[#"../../creusot-contracts/src/std/option.rs" 304 16 306 45] (self_:t_Option) (f:t_F) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_8 <- t ] s2
      | s2 = call_once {f'0} {_8} (fun (_ret:t_Option'0) ->  [ &_0 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & f'0 : t_F = f
    | & t : t_T = Any.any_l ()
    | & _8 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_then_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_then_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_filter_body [#"../../creusot-contracts/src/std/option.rs" 324 16 326 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 173 35 173 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 313 16 313 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 324 35 324 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 313 27 316 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 324 52 324 61
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 317 26 323 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_P
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_P)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T [inv'2 x] . inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_P) (args : t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_P) (args : t_T) (result : bool)
  
  
  let rec call_once (self_:t_P) (arg:t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_P)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option [inv'3 x] . inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_filter_body[#"../../creusot-contracts/src/std/option.rs" 324 16 326 41] (self_:t_Option) (predicate':t_P) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_filter_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'predicate' type invariant] [%#soption'0] inv predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition predicate' t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_11 <- t ] s2
      | s2 =  [ &_9 <- _11 ] s3
      | s3 = call_once {predicate''0} {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s4)
      | s4 = bb7 ]
    
    | bb7 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ] 
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb9 ] 
    | bb9 = bb12
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve t}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv predicate''0} s1 | s1 = -{resolve'0 predicate''0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb14 ] 
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & predicate''0 : t_P = predicate'
    | & t : t_T = Any.any_l ()
    | & _7 : bool = Any.any_l ()
    | & _9 : t_T = Any.any_l ()
    | & _11 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_filter_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_filter_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None
        | C_Some t -> match result with
          | C_None -> postcondition_once predicate' t false /\ resolve t
          | C_Some r -> postcondition_once predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_body [#"../../creusot-contracts/src/std/option.rs" 336 16 336 57]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 333 16 333 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 336 28 336 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 336 48 336 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 334 26 334 57
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 335 26 335 76
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_body[#"../../creusot-contracts/src/std/option.rs" 336 16 336 57] (self_:t_Option) (optb:t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_or_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_body 'optb' type invariant] [%#soption'0] inv'0 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 optb'0} s1
      | s1 = -{resolve'1 optb'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Some t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- optb'0 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & optb'0 : t_Option = optb
    | & t : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_or_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #0] [%#soption'2] self_ = C_None  -> result = optb}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #1] [%#soption'3] self_ = C_None
      \/ result = self_ /\ resolve'0 optb}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_else_body [#"../../creusot-contracts/src/std/option.rs" 348 16 350 44]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 343 16 343 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 348 36 348 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 343 27 343 62
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 348 45 348 54
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 344 26 347 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : ()) (result : t_Option)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_Option))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_Option)-> {inv'1 result}
      {[%#sops'1] postcondition_once self_ arg result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_else_body[#"../../creusot-contracts/src/std/option.rs" 348 16 350 44] (self_:t_Option) (f:t_F) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body requires] [%#soption'1] self_ = C_None  -> precondition f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Some t ] s4
      | s4 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once {f'0} {_7} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = bb10
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & f'0 : t_F = f
    | & _7 : () = Any.any_l ()
    | & t : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_or_else_body result type invariant] [%#soption'2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = C_Some t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_xor_body [#"../../creusot-contracts/src/std/option.rs" 364 16 364 58]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 357 16 357 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 364 29 364 33
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 364 49 364 58
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 358 26 363 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_xor_body[#"../../creusot-contracts/src/std/option.rs" 364 16 364 58] (self_:t_Option) (optb:t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_xor_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_xor_body 'optb' type invariant] [%#soption'0] inv'0 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = optb'0 } ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = any [ br0 -> {_4._p0 = C_None} (! bb7) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 = any [ br0 -> {_4._p1 = C_None} (! bb6) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb25) ]  ]
    
    | bb25 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p0 = C_Some x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = bb4 ]
    
    | bb6 = bb10
    | bb10 = s0 [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 = bb11 ] 
    | bb7 = any [ br0 -> {_4._p1 = C_None} (! bb26) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb8) ] 
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = C_Some x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = C_Some x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb14 ] 
    | bb8 = bb9
    | bb9 = s0 [ s0 = v_Some {_4._p1} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = bb17
    | bb17 = return''0 {_0} ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & optb'0 : t_Option = optb
    | & _4 : tuple = Any.any_l ()
    | & t : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_xor_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_xor_body ensures] [%#soption'2] match { _p0 = self_; _p1 = optb } with
        | {_p0 = C_None ; _p1 = C_None} -> result = C_None
        | {_p0 = C_Some t1 ; _p1 = C_Some t2} -> result = C_None /\ resolve t1 /\ resolve t2
        | {_p0 = C_Some t ; _p1 = C_None} -> result = C_Some t
        | {_p0 = C_None ; _p1 = C_Some t} -> result = C_Some t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_insert_body [#"../../creusot-contracts/src/std/option.rs" 377 16 377 56]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 371 16 371 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 377 37 377 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 377 50 377 56
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 372 26 375 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 376 26 376 68
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T [inv'1 x] . inv'1 x = invariant' x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve'2 _0
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_Option) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_Option) =
    resolve'4 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_insert_body[#"../../creusot-contracts/src/std/option.rs" 377 16 377 56] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_insert_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_insert_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_6 <- C_Some value'0 ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _6 } ] s3
      | s3 = bb5 ]
    
    | bb5 = any [ br0 -> {self_'0.current = C_None} (! bb7) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb8) ] 
    | bb8 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &v <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv _ret.final}-
             [ &v <- { v with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 v} s3
      | s3 = -{resolve'3 v}- s4
      | s4 = {inv _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv _ret.final}-
             [ &_8 <- { _8 with current = _ret.final } ] 
            s5)
      | s5 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s6)
      | s6 = {[@expl:type invariant] inv'1 _8} s7
      | s7 = -{resolve'3 _8}- s8
      | s8 = {[@expl:type invariant] inv'1 _3} s9
      | s9 = -{resolve'3 _3}- s10
      | s10 = bb10 ]
    
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = return''0 {_0} ]
    
    | bb7 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = bb9 ] 
    | bb9 = {false} any ]
    )
    [ & _0 : MutBorrow.t t_T = Any.any_l ()
    | & self_'0 : MutBorrow.t t_Option = self_
    | & value'0 : t_T = value
    | & _3 : MutBorrow.t t_T = Any.any_l ()
    | & _6 : t_Option = Any.any_l ()
    | & _8 : MutBorrow.t t_T = Any.any_l ()
    | & v : MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_insert_body result type invariant] [%#soption'1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #0] [%#soption'2] match self_.current with
        | C_Some t -> resolve t
        | C_None -> true
        end}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #1] [%#soption'3] result.current = value
      /\ self_.final = C_Some (result.final)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_body [#"../../creusot-contracts/src/std/option.rs" 390 16 390 63]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 385 16 385 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 390 44 390 49
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 390 57 390 63
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 386 26 389 17
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T [inv'1 x] . inv'1 x = invariant' x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve'2 _0
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_Option) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_Option) =
    resolve'4 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_body[#"../../creusot-contracts/src/std/option.rs" 390 16 390 63] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0.current = C_None} (! bb3) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb4) ] 
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv value'0} s1 | s1 = -{resolve value'0}- s2 | s2 = bb10 ] 
    | bb3 = bb5
    | bb5 = s0 [ s0 =  [ &_7 <- C_Some value'0 ] s1 | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _7 } ] s3
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = any [ br0 -> {self_'0.current = C_None} (! bb12) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb13) ] 
    | bb13 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &v <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_9 <- _ret ] 
            -{inv _ret.final}-
             [ &v <- { v with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 v} s3
      | s3 = -{resolve'3 v}- s4
      | s4 = {inv _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv _ret.final}-
             [ &_9 <- { _9 with current = _ret.final } ] 
            s5)
      | s5 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s6)
      | s6 = {[@expl:type invariant] inv'1 _9} s7
      | s7 = -{resolve'3 _9}- s8
      | s8 = {[@expl:type invariant] inv'1 _3} s9
      | s9 = -{resolve'3 _3}- s10
      | s10 = bb15 ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = return''0 {_0} ]
    
    | bb12 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = bb14 ] 
    | bb14 = {false} any ]
    )
    [ & _0 : MutBorrow.t t_T = Any.any_l ()
    | & self_'0 : MutBorrow.t t_Option = self_
    | & value'0 : t_T = value
    | & _3 : MutBorrow.t t_T = Any.any_l ()
    | & _7 : t_Option = Any.any_l ()
    | & _9 : MutBorrow.t t_T = Any.any_l ()
    | & v : MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body result type invariant] [%#soption'1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body ensures] [%#soption'2] match self_.current with
        | C_None -> result.current = value /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final) /\ resolve value
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body [#"../../creusot-contracts/src/std/option.rs" 406 16 408 36]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 401 16 401 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 406 52 406 53
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 401 27 401 63
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 406 61 406 67
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 402 26 405 17
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 85 16 85 17
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 86 26 86 75
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 88 20 89 100
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 135 16 135 17
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_T [inv'1 x] . inv'1 x = invariant' x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve'0 _0
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : ())
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : ()) (result : t_T)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_T))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_T)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve'2 x
      | C_None -> true
      end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Option) =
    resolve'3 _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option [inv'3 x] . inv'3 x = invariant''0 x
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption'4] inv'3 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'4 result}
      {[%#soption'5] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'6] self_.current = C_None
      \/ (exists r : MutBorrow.t t_T . result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_T))= {[@expl:unwrap 'self_' type invariant] [%#soption'7] inv'4 self_}
    {[@expl:unwrap requires] [%#soption'8] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_T)-> {inv'1 result} {[%#soption'9] C_Some'0 result = self_} (! return' {result}) ]
  
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_Option) =
    resolve'5 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body[#"../../creusot-contracts/src/std/option.rs" 406 16 408 36] (self_:MutBorrow.t t_Option) (f:t_F) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body requires] [%#soption'1] self_.current = C_None
     -> precondition f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0.current = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv'0 r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv'0 _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s3))
      | s3 = {inv'0 t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'1 t} s5
      | s5 = -{resolve'1 t}- s6
      | s6 = bb14 ]
    
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once {f'0} {_12} (fun (_ret:t_T) ->  [ &_10 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_9 <- C_Some _10 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'2 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'4 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _9 } ] s3
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {inv'2 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_15 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = as_mut {_15} (fun (_ret:t_Option'0) ->  [ &_14 <- _ret ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap {_14} (fun (_ret:MutBorrow.t t_T) ->  [ &_13 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = {inv'0 _13.current}
        MutBorrow.borrow_final <t_T> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_13 <- { _13 with current = _ret.final } ] 
            s1)
      | s1 = {inv'0 _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_8 <- { _8 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 _13} s3
      | s3 = -{resolve'1 _13}- s4
      | s4 = {[@expl:type invariant] inv'1 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'0 _6.current}
        MutBorrow.borrow_final <t_T> {_6.current} {MutBorrow.get_id _6}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_6 <- { _6 with current = _ret.final } ] 
            s1)
      | s1 = {inv'0 _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'1 _6}- s4
      | s4 = {[@expl:type invariant] inv'1 _3} s5
      | s5 = -{resolve'1 _3}- s6
      | s6 = bb15 ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'3 self_'0} s1 | s1 = -{resolve'6 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0 : MutBorrow.t t_T = Any.any_l ()
    | & self_'0 : MutBorrow.t t_Option = self_
    | & f'0 : t_F = f
    | & _3 : MutBorrow.t t_T = Any.any_l ()
    | & _6 : MutBorrow.t t_T = Any.any_l ()
    | & _8 : MutBorrow.t t_T = Any.any_l ()
    | & _9 : t_Option = Any.any_l ()
    | & _10 : t_T = Any.any_l ()
    | & _12 : () = Any.any_l ()
    | & _13 : MutBorrow.t t_T = Any.any_l ()
    | & _14 : t_Option'0 = Any.any_l ()
    | & _15 : MutBorrow.t t_Option = Any.any_l ()
    | & t : MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body result type invariant] [%#soption'2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body ensures] [%#soption'3] match self_.current with
        | C_None -> postcondition_once f () result.current /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_body [#"../../creusot-contracts/src/std/option.rs" 417 16 417 47]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span soption = "../../creusot-contracts/src/std/option.rs" 415 16 415 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 417 38 417 47
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 416 26 416 58
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Option [inv'1 x] . inv'1 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_Option) (src:t_Option) (return'  (x:t_Option))= {[@expl:replace 'dest' type invariant] [%#smem] inv'1 dest}
    {[@expl:replace 'src' type invariant] [%#smem'0] inv'0 src}
    any
    [ return''0 (result:t_Option)-> {inv'0 result}
      {[%#smem'1] dest.final = src}
      {[%#smem'2] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_Option) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_body[#"../../creusot-contracts/src/std/option.rs" 417 16 417 47] (self_:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_take_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- C_None ] s1
      | s1 = {inv'0 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_3 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s2)
      | s2 = replace {_3} {_4} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'1 self_'0} s1 | s1 = -{resolve'0 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & self_'0 : MutBorrow.t t_Option = self_
    | & _3 : MutBorrow.t t_Option = Any.any_l ()
    | & _4 : t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_take_body result type invariant] [%#soption'0] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_body ensures] [%#soption'1] result = self_.current
      /\ self_.final = C_None}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_if_body [#"../../creusot-contracts/src/std/option.rs" 435 16 437 45]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 171 16 171 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 173 35 173 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 171 27 171 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 172 26 172 62
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 421 16 421 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 435 41 435 50
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 421 27 424 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 435 58 435 67
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 425 26 434 17
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 415 16 415 17
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 416 26 416 58
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_P
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_P)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_T [inv'1 x] . inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T [inv'2 x] . inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_P) (args : MutBorrow.t t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_P) (args : MutBorrow.t t_T) (result : bool)
  
  
  let rec call_once (self_:t_P) (arg:MutBorrow.t t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve _0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option [inv'3 x] . inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_Option) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_Option)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Option [inv'4 x] . inv'4 x = invariant''0 x
  
  let rec take (self_:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:take 'self_' type invariant] [%#soption'4] inv'4 self_}
    any
    [ return''0 (result:t_Option)-> {inv'3 result}
      {[%#soption'5] result = self_.current /\ self_.final = C_None}
      (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_Option) =
    resolve'1 _0
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_P)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_if_body[#"../../creusot-contracts/src/std/option.rs" 435 16 437 45] (self_:MutBorrow.t t_Option) (predicate':t_P) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'predicate' type invariant] [%#soption'0] inv'0 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body requires] [%#soption'1] match self_.current with
      | C_None -> true
      | C_Some t -> forall b : MutBorrow.t t_T . inv'1 b /\ b.current = t  -> precondition predicate' b
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0.current = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_mut <t_T> {r0}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_10 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 =  [ &_9 <- _10 ] s3
      | s3 = call_once {predicate''0} {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s4)
      | s4 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 = {inv'3 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_11 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = take {_11} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'4 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb12 ] 
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'4 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'0 predicate''0} s1
      | s1 = -{resolve'3 predicate''0}- s2
      | s2 = {[@expl:type invariant] inv'4 self_'0} s3
      | s3 = -{resolve'2 self_'0}- s4
      | s4 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb13 ] 
    | bb13 = bb14
    | bb14 = return''0 {_0} ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & self_'0 : MutBorrow.t t_Option = self_
    | & predicate''0 : t_P = predicate'
    | & t : MutBorrow.t t_T = Any.any_l ()
    | & _7 : bool = Any.any_l ()
    | & _9 : MutBorrow.t t_T = Any.any_l ()
    | & _10 : MutBorrow.t t_T = Any.any_l ()
    | & _11 : MutBorrow.t t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_take_if_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_if_body ensures] [%#soption'3] match self_.current with
        | C_None -> result = C_None /\ self_.final = C_None
        | C_Some cur -> exists b : MutBorrow.t t_T, res : bool . inv'1 b
        /\ cur = b.current
        /\ postcondition_once predicate' b res
        /\ (if res then
          self_.final = C_None /\ result = C_Some (b.final)
        else
          self_.final = C_Some (b.final) /\ result = C_None
        )
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_replace_body [#"../../creusot-contracts/src/std/option.rs" 446 16 446 60]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span soption = "../../creusot-contracts/src/std/option.rs" 444 16 444 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 446 38 446 43
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 446 51 446 60
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 445 26 445 65
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Option [inv'1 x] . inv'1 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_Option) (src:t_Option) (return'  (x:t_Option))= {[@expl:replace 'dest' type invariant] [%#smem] inv'1 dest}
    {[@expl:replace 'src' type invariant] [%#smem'0] inv'0 src}
    any
    [ return''0 (result:t_Option)-> {inv'0 result}
      {[%#smem'1] dest.final = src}
      {[%#smem'2] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_Option) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_replace_body[#"../../creusot-contracts/src/std/option.rs" 446 16 446 60] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_replace_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_replace_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_5 <- C_Some value'0 ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'0 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_4 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_4} {_5} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self_'0} s1 | s1 = -{resolve'0 self_'0}- s2 | s2 = bb4 ] 
    | bb4 = return''0 {_0} ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & self_'0 : MutBorrow.t t_Option = self_
    | & value'0 : t_T = value
    | & _4 : MutBorrow.t t_Option = Any.any_l ()
    | & _5 : t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_replace_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_replace_body ensures] [%#soption'2] result = self_.current
      /\ self_.final = C_Some value}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_zip_body [#"../../creusot-contracts/src/std/option.rs" 456 16 456 67]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 450 16 450 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 456 32 456 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 456 53 456 67
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 451 26 455 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_U)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_U)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option'0) =
    [%#sresolve] match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Option'0) =
    resolve'0 _0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  type tuple'0  =
    { _p0'0: t_T; _p1'0: t_U }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 tuple'0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_U))= any
    [ good (field_0:t_U)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_U [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : tuple'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : tuple'0 [inv'3 x] . inv'3 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv'1 x0 /\ inv x1)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'1 [inv'4 x] . inv'4 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'3 a_0
    end
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve'2 x
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_zip_body[#"../../creusot-contracts/src/std/option.rs" 456 16 456 67] (self_:t_Option) (other:t_Option'0) (return'  (x:t_Option'1))= {[@expl:extern_spec_std_option_T_Option_T_zip_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_zip_body 'other' type invariant] [%#soption'0] inv'0 other}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = other'0 } ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = any [ br0 -> {_4._p0 = C_None} (! bb26) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb5) ] 
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {_p0 = C_Some x} -> resolve'2 x
          | _ -> true
          end}-
        s4
      | s4 = bb4 ]
    
    | bb5 = any [ br0 -> {_4._p1 = C_None'0} (! bb27) | br1 (x0:t_U)-> {_4._p1 = C_Some'0 x0} (! bb6) ] 
    | bb27 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = C_Some'0 x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = C_Some'0 x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {_p0 = C_Some x} -> resolve'2 x
          | _ -> true
          end}-
        s4
      | s4 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb13 ] 
    | bb6 = bb7
    | bb7 = s0
      [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = v_Some'0 {_4._p1} (fun (r0:t_U) ->  [ &u <- r0 ] s2)
      | s2 =  [ &_11 <- { _p0'0 = t; _p1'0 = u } ] s3
      | s3 = bb8 ]
    
    | bb8 = bb9
    | bb9 = s0 [ s0 =  [ &_0 <- C_Some'1 _11 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0 : t_Option'1 = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & other'0 : t_Option'0 = other
    | & _4 : tuple = Any.any_l ()
    | & t : t_T = Any.any_l ()
    | & u : t_U = Any.any_l ()
    | & _11 : tuple'0 = Any.any_l () ]
    
    [ return''0 (result:t_Option'1)-> {[@expl:extern_spec_std_option_T_Option_T_zip_body result type invariant] [%#soption'1] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_zip_body ensures] [%#soption'2] match { _p0 = self_; _p1 = other } with
        | {_p0 = C_None} -> result = C_None'1 /\ resolve'0 other
        | {_p1 = C_None'0} -> result = C_None'1 /\ resolve'3 self_
        | {_p0 = C_Some t ; _p1 = C_Some'0 u} -> result = C_Some'1 { _p0'0 = t; _p1'0 = u }
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body [#"../../creusot-contracts/src/std/option.rs" 470 16 470 56]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 465 16 465 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 470 34 470 56
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 466 26 469 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  let rec v_Some (input:t_Option) (ret  (field_0:tuple))= any
    [ good (field_0:tuple)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : tuple [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_U)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : tuple)
  
  axiom inv_axiom [@rewrite] : forall x : tuple [inv'1 x] . inv'1 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'1 [inv'4 x] . inv'4 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'0 a_0
    end
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : tuple'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : tuple'0 [inv'5 x] . inv'5 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv'3 x0 /\ inv'4 x1)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body[#"../../creusot-contracts/src/std/option.rs" 470 16 470 56] (self_:t_Option) (return'  (x:tuple'0))= {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:tuple)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = bb5
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:tuple) ->  [ &t <- r0._p0 ] s1)
      | s1 = v_Some {self_'0} (fun (r0:tuple) ->  [ &u <- r0._p1 ] s2)
      | s2 =  [ &_6 <- C_Some'0 t ] s3
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_8 <- C_Some'1 u ] s1 | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- { _p0'0 = _6; _p1'0 = _8 } ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = bb14
    | bb4 = s0
      [ s0 =  [ &_10 <- C_None'0 ] s1
      | s1 =  [ &_11 <- C_None'1 ] s2
      | s2 =  [ &_0 <- { _p0'0 = _10; _p1'0 = _11 } ] s3
      | s3 = bb12 ]
    
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = return''0 {_0} ]
    )
    [ & _0 : tuple'0 = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & t : t_T = Any.any_l ()
    | & u : t_U = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _8 : t_Option'1 = Any.any_l ()
    | & _10 : t_Option'0 = Any.any_l ()
    | & _11 : t_Option'1 = Any.any_l () ]
    
    [ return''0 (result:tuple'0)-> {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body result type invariant] [%#soption'0] inv'5 result}
      {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body ensures] [%#soption'1] match self_ with
        | C_None -> result = { _p0'0 = C_None'0; _p1'0 = C_None'1 }
        | C_Some {_p0 = t ; _p1 = u} -> result = { _p0'0 = C_Some'0 t; _p1'0 = C_Some'1 u }
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_ref_T_copied_body [#"../../creusot-contracts/src/std/option.rs" 482 16 484 27]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 479 16 479 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 482 35 482 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 480 26 480 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 481 26 481 93
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_copied_body[#"../../creusot-contracts/src/std/option.rs" 482 16 484 27] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- C_Some'0 t ] s2 | s2 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_'0 : t_Option = self_ | & t : t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body ensures #0] [%#soption'1] self_ = C_None
       -> result = C_None'0}
      {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body ensures #1] [%#soption'2] self_ = C_None
      \/ (exists t : t_T . self_ = C_Some t /\ result = C_Some'0 t)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body [#"../../creusot-contracts/src/std/option.rs" 493 16 495 28]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 491 16 491 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 493 35 493 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 491 26 491 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 492 26 492 93
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : t_T)
  
  axiom precondition_fndef : forall args : t_T [precondition () args] . (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : t_T) (result : t_T)
  
  
  axiom postcondition_fndef : forall args : t_T, res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let self_ = args in res = self_ /\ inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body[#"../../creusot-contracts/src/std/option.rs" 493 16 495 28] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = clone' {t} (fun (_ret:t_T) ->  [ &_6 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_0 <- C_Some'0 _6 ] s1 | s1 = bb6 ] 
    | bb6 = bb7
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & t : t_T = Any.any_l ()
    | & _6 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body ensures #0] [%#soption'1] self_ = C_None
       -> result = C_None'0}
      {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body ensures #1] [%#soption'2] self_ = C_None
      \/ (exists t : t_T . self_ = C_Some t /\ result = C_Some'0 t)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body [#"../../creusot-contracts/src/std/option.rs" 510 16 512 27]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 504 16 504 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 510 35 510 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 505 26 505 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 507 20 508 93
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:MutBorrow.t t_T))= any
    [ good (field_0:MutBorrow.t t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : MutBorrow.t t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body[#"../../creusot-contracts/src/std/option.rs" 510 16 512 27] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:MutBorrow.t t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:MutBorrow.t t_T) ->  [ &t <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 t} s2
      | s2 = -{resolve'0 t}- s3
      | s3 =  [ &_0 <- C_Some'0 (t.current) ] s4
      | s4 = bb5 ]
    
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_'0 : t_Option = self_ | & t : MutBorrow.t t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body ensures #0] [%#soption'1] self_ = C_None
       -> result = C_None'0}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body ensures #1] [%#soption'2] self_ = C_None
      \/ (exists t : MutBorrow.t t_T . self_ = C_Some t /\ result = C_Some'0 (t.current) /\ resolve t)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body [#"../../creusot-contracts/src/std/option.rs" 524 16 526 28]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 519 16 519 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 524 35 524 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 519 26 519 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 521 20 522 93
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:MutBorrow.t t_T))= any
    [ good (field_0:MutBorrow.t t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : MutBorrow.t t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant'0] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : t_T)
  
  axiom precondition_fndef : forall args : t_T [precondition () args] . (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : t_T) (result : t_T)
  
  
  axiom postcondition_fndef : forall args : t_T, res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let self_ = args in res = self_ /\ inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : MutBorrow.t t_T) =
    resolve _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body[#"../../creusot-contracts/src/std/option.rs" 524 16 526 28] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:MutBorrow.t t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:MutBorrow.t t_T) ->  [ &t <- r0 ] s1)
      | s1 = clone' {t.current} (fun (_ret:t_T) ->  [ &_6 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 =  [ &_0 <- C_Some'0 _6 ] s3
      | s3 = bb6 ]
    
    | bb6 = bb7
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & t : MutBorrow.t t_T = Any.any_l ()
    | & _6 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body ensures #0] [%#soption'1] self_ = C_None
       -> result = C_None'0}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body ensures #1] [%#soption'2] self_ = C_None
      \/ (exists t : MutBorrow.t t_T . self_ = C_Some t /\ result = C_Some'0 (t.current) /\ resolve t)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_E_Option_Result_T_E_transpose_body [#"../../creusot-contracts/src/std/option.rs" 541 16 541 58]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 535 16 535 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 541 38 541 58
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 536 26 540 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  type t_Option  =
    | C_None
    | C_Some t_Result
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Result))= any
    [ good (field_0:t_Result)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Result [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_E [C_Err field_0 : t_Result] . C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_Result'0  =
    | C_Ok'0 t_Option'0
    | C_Err'0 t_E
  
  let rec v_Ok (input:t_Result) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T [C_Ok field_0 : t_Result] . C_Ok field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result)
  
  axiom inv_axiom [@rewrite] : forall x : t_Result [inv'1 x] . inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'2 x] . inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Result'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Result'0 [inv'4 x] . inv'4 x
  = match x with
    | C_Ok'0 a_0 -> inv'3 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_E_Option_Result_T_E_transpose_body[#"../../creusot-contracts/src/std/option.rs" 541 16 541 58] (self_:t_Option) (return'  (x:t_Result'0))= {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0 = C_None} (! bb3) | br1 (x0:t_Result)-> {self_'0 = C_Some x0} (! bb4) ] 
    | bb4 = v_Some {self_'0}
        (fun (r0:t_Result) -> any [ br0 (x0:t_T)-> {r0 = C_Ok x0} (! bb5) | br1 (x0:t_E)-> {r0 = C_Err x0} (! bb6) ] )
    | bb6 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_Result) -> v_Err {r0} (fun (r0'0:t_E) ->  [ &err <- r0'0 ] s1))
      | s1 =  [ &_0 <- C_Err'0 err ] s2
      | s2 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb15
    | bb5 = bb7
    | bb7 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_Result) -> v_Ok {r0} (fun (r0'0:t_T) ->  [ &ok <- r0'0 ] s1))
      | s1 =  [ &_7 <- C_Some'0 ok ] s2
      | s2 = bb10 ]
    
    | bb10 = s0 [ s0 =  [ &_0 <- C_Ok'0 _7 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb15
    | bb3 = bb8
    | bb8 = s0 [ s0 =  [ &_5 <- C_None'0 ] s1 | s1 =  [ &_0 <- C_Ok'0 _5 ] s2 | s2 = bb9 ] 
    | bb9 = bb15
    | bb15 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0 : t_Result'0 = Any.any_l ()
    | & self_'0 : t_Option = self_
    | & _5 : t_Option'0 = Any.any_l ()
    | & ok : t_T = Any.any_l ()
    | & _7 : t_Option'0 = Any.any_l ()
    | & err : t_E = Any.any_l () ]
    
    [ return''0 (result:t_Result'0)-> {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body ensures] [%#soption'1] match self_ with
        | C_None -> result = C_Ok'0 (C_None'0)
        | C_Some (C_Ok ok) -> result = C_Ok'0 (C_Some'0 ok)
        | C_Some (C_Err err) -> result = C_Err'0 err
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_Option_T_flatten_body [#"../../creusot-contracts/src/std/option.rs" 554 16 554 45]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 551 16 551 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 554 36 554 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 552 26 552 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 553 26 553 62
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  let rec v_Some (input:t_Option'0) (ret  (field_0:t_Option))= any
    [ good (field_0:t_Option)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Option [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_Option_T_flatten_body[#"../../creusot-contracts/src/std/option.rs" 554 16 554 45] (self_:t_Option'0) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None'0} (! bb4) | br1 (x0:t_Option)-> {self_'0 = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_Option) ->  [ &opt <- r0 ] s1) | s1 =  [ &_0 <- opt ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = return''0 {_0} ]
    ) [ & _0 : t_Option = Any.any_l () | & self_'0 : t_Option'0 = self_ | & opt : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body result type invariant] [%#soption'0] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #0] [%#soption'1] self_ = C_None'0
       -> result = C_None}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #1] [%#soption'2] self_ = C_None'0
      \/ self_ = C_Some'0 result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Option) (o : t_Option) =
    [%#sord'1] cmp_log'0 self o <> C_Greater
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : t_Option) (y'0 : t_Option) : ()
  
  
  goal vc_cmp_le_log : [%#sord] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Option) (o : t_Option) =
    [%#sord'1] cmp_log'0 self o = C_Less
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : t_Option) (y'0 : t_Option) : ()
  
  
  goal vc_cmp_lt_log : [%#sord] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Option) (o : t_Option) =
    [%#sord'1] cmp_log'0 self o <> C_Less
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : t_Option) (y'0 : t_Option) : ()
  
  
  goal vc_cmp_ge_log : [%#sord] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Option) (o : t_Option) =
    [%#sord'1] cmp_log'0 self o = C_Greater
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : t_Option) (y'0 : t_Option) : ()
  
  
  goal vc_cmp_gt_log : [%#sord] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : t_Option) : ()
  
  goal vc_refl : [%#sord] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  constant z  : t_Option
  
  constant o  : t_Ordering
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : t_Option) (y'0 : t_Option) (z'0 : t_Option) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log'0 x y = o)  -> ([%#sord'0] cmp_log'0 y z = o)  -> ([%#sord'1] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : t_Option) (y'0 : t_Option) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log'0 x y = C_Less)  -> ([%#sord'0] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : t_Option) (y'0 : t_Option) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log'0 x y = C_Greater)  -> ([%#sord'0] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : t_Option) (y'0 : t_Option) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl [#"../../creusot-contracts/src/std/option.rs" 629 4 629 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 628 14 628 45
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 629 27 629 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 622 12 623 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 606 4 606 30] (self : t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 620 4 620 64] (self : t_IntoIter) (visited : Seq.seq t_T) (o : t_IntoIter)
  
   =
    [%#soption'1] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 629 4 629 26] (self'0 : t_IntoIter) : ()
  
  goal vc_produces_refl : [%#soption] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans [#"../../creusot-contracts/src/std/option.rs" 635 4 635 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 632 15 632 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 633 15 633 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 634 14 634 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 635 91 635 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 622 12 623 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 606 4 606 30] (self : t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 620 4 620 64] (self : t_IntoIter) (visited : Seq.seq t_T) (o : t_IntoIter)
  
   =
    [%#soption'3] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 635 4 635 90] (a'0 : t_IntoIter) (ab'0 : Seq.seq t_T) (b'0 : t_IntoIter) (bc'0 : Seq.seq t_T) (c'0 : t_IntoIter) : ()
  
  
  goal vc_produces_trans : ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_refl [#"../../creusot-contracts/src/std/option.rs" 666 4 666 26] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 665 14 665 45
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 666 27 666 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 659 12 660 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 643 4 643 34] (self : t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 657 4 657 64] (self : t_Iter) (visited : Seq.seq t_T) (o : t_Iter)
  
   =
    [%#soption'1] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant self  : t_Iter
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 666 4 666 26] (self'0 : t_Iter) : ()
  
  goal vc_produces_refl : [%#soption] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_trans [#"../../creusot-contracts/src/std/option.rs" 672 4 672 90] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 669 15 669 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 670 15 670 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 671 14 671 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 672 91 672 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 659 12 660 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 643 4 643 34] (self : t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 657 4 657 64] (self : t_Iter) (visited : Seq.seq t_T) (o : t_Iter)
  
   =
    [%#soption'3] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant a  : t_Iter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 672 4 672 90] (a'0 : t_Iter) (ab'0 : Seq.seq t_T) (b'0 : t_Iter) (bc'0 : Seq.seq t_T) (c'0 : t_Iter) : ()
  
  
  goal vc_produces_trans : ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_refl [#"../../creusot-contracts/src/std/option.rs" 703 4 703 26] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 702 14 702 45
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 703 27 703 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 696 12 697 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 680 4 680 38] (self : t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 694 4 694 64] (self : t_IterMut) (visited : Seq.seq (MutBorrow.t t_T)) (o : t_IterMut)
  
   =
    [%#soption'1] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e : MutBorrow.t t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant self  : t_IterMut
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 703 4 703 26] (self'0 : t_IterMut) : ()
  
  goal vc_produces_refl : [%#soption] produces self (Seq.empty : Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_trans [#"../../creusot-contracts/src/std/option.rs" 709 4 709 90] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 706 15 706 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 707 15 707 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 708 14 708 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 709 91 709 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 696 12 697 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 680 4 680 38] (self : t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 694 4 694 64] (self : t_IterMut) (visited : Seq.seq (MutBorrow.t t_T)) (o : t_IterMut)
  
   =
    [%#soption'3] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e : MutBorrow.t t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant a  : t_IterMut
  
  constant ab  : Seq.seq (MutBorrow.t t_T)
  
  constant b  : t_IterMut
  
  constant bc  : Seq.seq (MutBorrow.t t_T)
  
  constant c  : t_IterMut
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 709 4 709 90] (a'0 : t_IterMut) (ab'0 : Seq.seq (MutBorrow.t t_T)) (b'0 : t_IterMut) (bc'0 : Seq.seq (MutBorrow.t t_T)) (c'0 : t_IterMut) : ()
  
  
  goal vc_produces_trans : ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self : Opaque.ptr) : UInt64.t
  
  constant self  : Opaque.ptr
  
  function is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self'0 : Opaque.ptr) : bool
  
  goal vc_is_null_logic : [%#sptr] (addr_logic self = (0 : UInt64.t)) = (addr_logic self = (0 : UInt64.t))
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 74 14 74 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 76 8 76 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 68 4 68 32] (self : Opaque.ptr) : UInt64.t
  
  constant self  : Opaque.ptr
  
  function is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (self'0 : Opaque.ptr) : bool
  
  goal vc_is_null_logic : [%#sptr] (addr_logic self = (0 : UInt64.t)) = (addr_logic self = (0 : UInt64.t))
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 419 4 419 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 418 14 418 45
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 419 27 419 29
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 412 12 412 66
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 81 14 81 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 80
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'4] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'5] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 83 4 83 35] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec : forall self : Slice64.slice t_T . ([%#sslice'2] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 396 4 396 33] (self : t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 410 4 410 65] (self : t_Iter) (visited : Seq.seq t_T) (tl : t_Iter)
  
   =
    [%#sslice'1] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  constant self  : t_Iter
  
  function produces_refl [#"../../creusot-contracts/src/std/slice.rs" 419 4 419 26] (self'0 : t_Iter) : ()
  
  goal vc_produces_refl : [%#sslice] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 423 15 423 32
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 424 15 424 32
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 425 14 425 42
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 426 91 426 93
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 412 12 412 66
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 81 14 81 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 80
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'6] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'7] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 83 4 83 35] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec : forall self : Slice64.slice t_T . ([%#sslice'4] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'5] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 396 4 396 33] (self : t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 410 4 410 65] (self : t_Iter) (visited : Seq.seq t_T) (tl : t_Iter)
  
   =
    [%#sslice'3] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  constant a  : t_Iter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter
  
  function produces_trans [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 90] (a'0 : t_Iter) (ab'0 : Seq.seq t_T) (b'0 : t_Iter) (bc'0 : Seq.seq t_T) (c'0 : t_Iter) : ()
  
  
  goal vc_produces_trans : ([%#sslice] produces a ab b)
   -> ([%#sslice'0] produces b bc c)  -> ([%#sslice'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 472 4 472 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 471 14 471 45
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 472 27 472 29
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 465 12 465 66
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 72 14 72 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 73 14 73 84
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 434 14 434 50
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'5] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'6] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 75 4 75 43] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec : forall self : MutBorrow.t (Slice64.slice t_T) . ([%#sslice'2] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'3] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 435 4 435 33] (self : t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0 : forall self : t_IterMut . [%#sslice'4] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 463 4 463 65] (self : t_IterMut) (visited : Seq.seq (MutBorrow.t t_T)) (tl : t_IterMut)
  
   =
    [%#sslice'1] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  constant self  : t_IterMut
  
  function produces_refl [#"../../creusot-contracts/src/std/slice.rs" 472 4 472 26] (self'0 : t_IterMut) : ()
  
  goal vc_produces_refl : [%#sslice] produces self (Seq.empty : Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 479 4 479 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 476 15 476 32
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 477 15 477 32
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 478 14 478 42
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 479 91 479 93
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 465 12 465 66
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 72 14 72 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 73 14 73 84
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 434 14 434 50
  let%span sslice'7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'7] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'8] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 75 4 75 43] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec : forall self : MutBorrow.t (Slice64.slice t_T) . ([%#sslice'4] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'5] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 435 4 435 33] (self : t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0 : forall self : t_IterMut . [%#sslice'6] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 463 4 463 65] (self : t_IterMut) (visited : Seq.seq (MutBorrow.t t_T)) (tl : t_IterMut)
  
   =
    [%#sslice'3] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  constant a  : t_IterMut
  
  constant ab  : Seq.seq (MutBorrow.t t_T)
  
  constant b  : t_IterMut
  
  constant bc  : Seq.seq (MutBorrow.t t_T)
  
  constant c  : t_IterMut
  
  function produces_trans [#"../../creusot-contracts/src/std/slice.rs" 479 4 479 90] (a'0 : t_IterMut) (ab'0 : Seq.seq (MutBorrow.t t_T)) (b'0 : t_IterMut) (bc'0 : Seq.seq (MutBorrow.t t_T)) (c'0 : t_IterMut) : ()
  
  
  goal vc_produces_trans : ([%#sslice] produces a ab b)
   -> ([%#sslice'0] produces b bc c)  -> ([%#sslice'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl [#"../../creusot-contracts/src/std/vec.rs" 249 4 249 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 248 14 248 45
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 249 27 249 29
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 242 12 242 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 210 4 210 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 240 4 240 57] (self : t_IntoIter) (visited : Seq.seq t_T) (rhs : t_IntoIter)
  
   =
    [%#svec'1] view self = Seq.(++) visited (view rhs)
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/vec.rs" 249 4 249 26] (self'0 : t_IntoIter) : ()
  
  goal vc_produces_refl : [%#svec] produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 253 15 253 32
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 254 15 254 32
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 255 14 255 42
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 256 73 256 75
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 242 12 242 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 210 4 210 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 240 4 240 57] (self : t_IntoIter) (visited : Seq.seq t_T) (rhs : t_IntoIter)
  
   =
    [%#svec'3] view self = Seq.(++) visited (view rhs)
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 72] (a'0 : t_IntoIter) (ab'0 : Seq.seq t_T) (b'0 : t_IntoIter) (bc'0 : Seq.seq t_T) (c'0 : t_IntoIter) : ()
  
  
  goal vc_produces_trans : ([%#svec] produces a ab b)
   -> ([%#svec'0] produces b bc c)  -> ([%#svec'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : Real.real) (y'0 : Real.real) : ()
  
  
  goal vc_cmp_le_log : [%#sord] Real.(<=) x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : Real.real) (y'0 : Real.real) : ()
  
  
  goal vc_cmp_lt_log : [%#sord] Real.(<) x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : Real.real) (y'0 : Real.real) : ()
  
  
  goal vc_cmp_ge_log : [%#sord] Real.(>=) x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : Real.real) (y'0 : Real.real) : ()
  
  
  goal vc_cmp_gt_log : [%#sord] Real.(>) x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : Real.real) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  constant z  : Real.real
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : Real.real) (y'0 : Real.real) (z'0 : Real.real) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : Real.real) (y'0 : Real.real) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : Real.real) (y'0 : Real.real) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : Real.real) (y'0 : Real.real) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__fn_pure__qyi11638360339920708941__clone [#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (* <fn_pure::FnPureWrapper<F> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 30 14 30 18
  let%span sfn_pure'0 = "../../creusot-contracts/src/fn_pure.rs" 30 23 30 27
  let%span sfn_pure'1 = "../../creusot-contracts/src/fn_pure.rs" 29 14 29 29
  
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_F) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  axiom inv_axiom [@rewrite] : forall x : t_F [inv'0 x] . inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : t_F)
  
  axiom precondition_fndef : forall args : t_F [precondition () args] . (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : t_F) (result : t_F)
  
  
  axiom postcondition_fndef : forall args : t_F, res : t_F [postcondition_once () args res] . postcondition_once () args res
   -> (let self_ = args in res = self_ /\ inv res)
  
  let rec clone' (self_:t_F) (return'  (x:t_F))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_F)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FnPureWrapper [inv'1 x] . inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_FnPureWrapper) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_FnPureWrapper [inv'2 x] . inv'2 x = invariant''0 x
  
  meta "compute_max_steps" 1000000
  
  let rec clone''0[#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (self:t_FnPureWrapper) (return'  (x:t_FnPureWrapper))= {[@expl:clone 'self' type invariant] [%#sfn_pure] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone' {self'0.t_FnPureWrapper__0} (fun (_ret:t_F) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_FnPureWrapper__0 = _3 } ] s1 | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0 : t_FnPureWrapper = Any.any_l () | & self'0 : t_FnPureWrapper = self | & _3 : t_F = Any.any_l () ] 
    [ return''0 (result:t_FnPureWrapper)-> {[@expl:clone result type invariant] [%#sfn_pure'0] inv'1 result}
      {[@expl:clone ensures] [%#sfn_pure'1] result = self}
      (! return' {result}) ]

end
module M_creusot_contracts__fn_pure__qyi4173004571708517458__qy95z_new [#"../../creusot-contracts/src/fn_pure.rs" 75 4 75 30] (* fn_pure::FnPureWrapper<F> *)
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 75 17 75 18
  let%span sfn_pure'0 = "../../creusot-contracts/src/fn_pure.rs" 75 26 75 30
  let%span sfn_pure'1 = "../../creusot-contracts/src/fn_pure.rs" 74 14 74 26
  let%span sfn_pure'2 = "../../creusot-contracts/src/fn_pure.rs" 83 8 83 14
  
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite] : forall x : t_FnPureWrapper [inv'0 x] . inv'0 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  function view [#"../../creusot-contracts/src/fn_pure.rs" 82 4 82 33] (self : t_FnPureWrapper) : t_F =
    [%#sfn_pure'2] self.t_FnPureWrapper__0
  
  meta "compute_max_steps" 1000000
  
  let rec qy95z_new[#"../../creusot-contracts/src/fn_pure.rs" 75 4 75 30] (f:t_F) (return'  (x:t_FnPureWrapper))= {[@expl:__new 'f' type invariant] [%#sfn_pure] inv f}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_0 <- { t_FnPureWrapper__0 = f'0 } ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = return''0 {_0} ]
    ) [ & _0 : t_FnPureWrapper = Any.any_l () | & f'0 : t_F = f ] 
    [ return''0 (result:t_FnPureWrapper)-> {[@expl:__new result type invariant] [%#sfn_pure'0] inv'0 result}
      {[@expl:__new ensures] [%#sfn_pure'1] view result = f}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__subtract [#"../../creusot-contracts/src/logic/fmap.rs" 204 4 204 46] (* logic::fmap::FMap<K, V> *)
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 196 15 196 33
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 197 14 197 36
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 198 14 198 46
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 199 14 203 5
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 181 14 185 5
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 205 8 205 33
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 155 12 155 89
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 147 19 147 71
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 164 15 164 35
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 165 14 171 5
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 172 14 172 54
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  
  use map.Map
  use mach.int.Int
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_K t_Option
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'15] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_K) : t_Option
  
   =
    [%#sfmap'13] Map.get (view self) k
  
  function contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap) (k : t_K) : bool
  
   =
    [%#sfmap'14] get_unsized self k <> C_None
  
  function subset [#"../../creusot-contracts/src/logic/fmap.rs" 153 4 153 44] (self : t_FMap) (other : t_FMap) : bool =
    [%#sfmap'5] forall k : t_K . contains self k  -> get_unsized other k = get_unsized self k
  
  function disjoint [#"../../creusot-contracts/src/logic/fmap.rs" 146 4 146 46] (self : t_FMap) (other : t_FMap) : bool
   =
    [%#sfmap'6] forall k : t_K . not contains self k \/ not contains other k
  
  function ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self : t_FMap) (other : t_FMap) : bool =
    [%#sfmap'9] view self = view other
  
  axiom ext_eq_spec : forall self : t_FMap, other : t_FMap . ([%#sfmap'7] ext_eq self other  -> self = other)
  && ([%#sfmap'8] (forall k : t_K . get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap'16] len self >= 0
  
  function union [#"../../creusot-contracts/src/logic/fmap.rs" 173 4 173 43] (self : t_FMap) (other : t_FMap) : t_FMap
  
  axiom union_spec : forall self : t_FMap, other : t_FMap . ([%#sfmap'10] disjoint self other)
   -> ([%#sfmap'11] forall k : t_K . get_unsized (union self other) k
  = (if contains self k then get_unsized self k else if contains other k then get_unsized other k else C_None))
  && ([%#sfmap'12] len (union self other) = len self + len other)
  
  function subtract_keys [#"../../creusot-contracts/src/logic/fmap.rs" 186 4 186 51] (self : t_FMap) (other : t_FMap) : t_FMap
  
  
  axiom subtract_keys_spec : forall self : t_FMap, other : t_FMap . [%#sfmap'3] forall k : t_K . get_unsized (subtract_keys self other) k
  = (if contains other k then C_None else get_unsized self k)
  
  constant self  : t_FMap
  
  constant other  : t_FMap
  
  function subtract [#"../../creusot-contracts/src/logic/fmap.rs" 204 4 204 46] (self'0 : t_FMap) (other'0 : t_FMap) : t_FMap
  
  
  goal vc_subtract : ([%#sfmap] subset other self)
   -> ([%#sfmap'3] forall k : t_K . get_unsized (subtract_keys self other) k
  = (if contains other k then C_None else get_unsized self k))
   -> (let result = subtract_keys self other in ([%#sfmap'0] disjoint result other)
  && ([%#sfmap'1] ext_eq (union other result) self)
  && ([%#sfmap'2] forall k : t_K . get_unsized result k = (if contains other k then C_None else get_unsized self k)))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (* logic::fmap::FMap<K, V> *)
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_K t_Option
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'1] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_K) : t_Option
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  constant self  : t_FMap
  
  constant other  : t_FMap
  
  function ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self'0 : t_FMap) (other'0 : t_FMap) : bool
  
  
  goal vc_ext_eq : ([%#sfmap'1] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2  -> view m1 <> view m2)
   -> ([%#sfmap'1] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2  -> view m1 <> view m2)
   -> (let result = view self = view other in ([%#sfmap] result  -> self = other)
  && ([%#sfmap'0] (forall k : t_K . get_unsized self k = get_unsized other k)  -> result))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__contains_ghost [#"../../creusot-contracts/src/logic/fmap.rs" 286 4 286 49] (* logic::fmap::FMap<K, V> *)
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 286 27 286 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 286 33 286 36
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 285 14 285 43
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 315 40 315 50
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 510 20 510 91
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 40 16 40 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 41 26 41 51
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  
  use map.Map
  use creusot.prelude.Any
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_FMap
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'9] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_K) : t_Option'0
  
   =
    [%#sfmap'8] Map.get (view self) k
  
  function contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap) (k : t_K) : bool
  
   =
    [%#sfmap'6] get_unsized self k <> C_None'0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_K)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_V)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_V) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_V)
  
  axiom inv_axiom [@rewrite] : forall x : t_V [inv'1 x] . inv'1 x = invariant' x
  
  function unwrap [#"../../creusot-contracts/src/util.rs" 56 0 56 36] (op : t_Option'0) : t_V
  
  axiom unwrap_spec : forall op : t_Option'0 . ([%#sutil] op <> C_None'0)  -> ([%#sutil'0] C_Some'0 (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 124 4 124 50] (self : t_FMap) (k : t_K) : t_V
  
   =
    [%#sfmap'7] unwrap (get_unsized self k)
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/fmap.rs" 509 4 509 30] (self : t_FMap) =
    [%#sfmap'10] forall k : t_K . contains self k  -> inv k /\ inv'1 (lookup_unsized self k)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FMap)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FMap [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_FMap) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FMap)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_FMap [inv'3 x] . inv'3 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_K) =
    [%#sinvariant] inv self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_K)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_K [inv'4 x] . inv'4 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_V) =
    [%#sinvariant] inv'0 self
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_V)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_V [inv'5 x] . inv'5 x = invariant''3 x
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option [inv'6 x] . inv'6 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'5 a_0
    end
  
  let rec get_ghost (self:t_FMap) (key:t_K) (return'  (x:t_Option))= {[@expl:get_ghost 'self' type invariant] [%#sfmap'2] inv'3 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap'3] inv'4 key}
    any
    [ return''0 (result:t_Option)-> {[%#sfmap'4] inv'6 result}
      {[%#sfmap'5] if contains self key then
        match result with
          | C_None -> false
          | C_Some r -> lookup_unsized self key = r
          end
      else
        result = C_None
      }
      (! return' {result}) ]
  
  
  predicate invariant''4 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Option) =
    [%#sinvariant] inv'6 self
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Option [inv'7 x] . inv'7 x = invariant''4 x
  
  let rec is_some (self_:t_Option) (return'  (x:bool))= {[@expl:is_some 'self_' type invariant] [%#soption] inv'7 self_}
    any [ return''0 (result:bool)-> {[%#soption'0] result = (self_ <> C_None)} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec contains_ghost[#"../../creusot-contracts/src/logic/fmap.rs" 286 4 286 49] (self:t_FMap) (key:t_K) (return'  (x:bool))= {[@expl:contains_ghost 'self' type invariant] [%#sfmap] inv'3 self}
    {[@expl:contains_ghost 'key' type invariant] [%#sfmap'0] inv'4 key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost {self'0} {key'0} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = is_some {_5} (fun (_ret:bool) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self'0 : t_FMap = self | & key'0 : t_K = key | & _5 : t_Option = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:contains_ghost ensures] [%#sfmap'1] result = contains self key}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__ext_eq [#"../../creusot-contracts/src/logic/fset.rs" 198 4 200 17] (* logic::fset::FSet<T> *)
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 197 14 197 38
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 203 12 203 63
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  constant self  : Fset.fset t_T
  
  constant other  : Fset.fset t_T
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fset.rs" 198 4 200 17] (self'0 : Fset.fset t_T) (other'0 : Fset.fset t_T)
  
  
  goal vc_ext_eq : [%#sfset] ([%#sfset'0] forall e : t_T . contains self e = contains other e)  -> self = other
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (* logic::fset::FSet<T> *)
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset t_T) (e : t_T) : Fset.fset t_T
  
   =
    [%#sfset'2] Fset.add e self
  
  constant x  : t_T
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x'0 : t_T) : Fset.fset t_T
  
  goal vc_singleton : [%#sfset] forall y : t_T . contains (insert (Fset.empty : Fset.fset t_T) x) y = (x = y)
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__unions [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (* logic::fset::FSet<T> *)
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 220 14 220 102
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 221 14 221 24
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 223 8 228 9
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  use set.Fset
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_U) (e : t_U)
  
   =
    [%#sfset'2] Fset.mem e self
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'2] Fset.mem e self
  
  function remove [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 92 4 92 37] (self : Fset.fset t_T) (e : t_T) : Fset.fset t_T
  
   =
    [%#sfset'3] Fset.remove e self
  
  constant self  : Fset.fset t_T
  
  constant f  : Map.map t_T (Fset.fset t_U)
  
  function unions [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (self'0 : Fset.fset t_T) (f'0 : Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  
  goal vc_unions : if Fset.cardinal self = 0 then
    [%#sfset] forall y : t_U . contains (Fset.empty : Fset.fset t_U) y
    = (exists x : t_T . contains'0 self x /\ contains (Map.get f x) y)
  else
    let x = Fset.pick self in (0 <= ([%#sfset'0] Fset.cardinal self)
    /\ ([%#sfset'0] Fset.cardinal (remove self x)) < ([%#sfset'0] Fset.cardinal self))
    /\ (([%#sfset] forall y : t_U . contains (unions (remove self x) f) y
    = (exists x'0 : t_T . contains'0 (remove self x) x'0 /\ contains (Map.get f x'0) y))
     -> ([%#sfset] forall y : t_U . contains (Fset.union (Map.get f x) (unions (remove self x) f)) y
    = (exists x'0 : t_T . contains'0 self x'0 /\ contains (Map.get f x'0) y)))

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (* logic::fset::FSet<T> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 282 32 282 85
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 285 32 285 108
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'9] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'8] insert (Fset.empty : Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec : forall x : Seq.seq t_T . [%#sfset'3] forall y : Seq.seq t_T . contains (singleton x) y
  = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T) (ss : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec : forall s : Fset.fset t_T, ss : Fset.fset (Seq.seq t_T) . [%#sfset'5] forall xs : Seq.seq t_T . contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  constant self  : Fset.fset t_T
  
  constant n  : int
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self'0 : Fset.fset t_T) (n'0 : int) : Fset.fset (Seq.seq t_T)
  
  
  goal vc_replicate : ([%#sfset] n >= 0)
   -> (if n = 0 then
    ([%#sfset'2] forall xs : Seq.seq t_T . Seq.length xs = 0  -> xs = (Seq.empty : Seq.seq t_T))
    && (let _ = () in let _ = () in ([%#sfset'3] forall y : Seq.seq t_T . contains (singleton (Seq.empty : Seq.seq t_T)) y
    = ((Seq.empty : Seq.seq t_T) = y))
     -> ([%#sfset'0] forall xs : Seq.seq t_T . contains (singleton (Seq.empty : Seq.seq t_T)) xs
    = (Seq.length xs = n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x))))
  else
    ([%#sfset'4] forall xs : Seq.seq t_T, i : int . 0 < i /\ i < Seq.length xs
     -> Seq.get xs i = Seq.get (tail xs) (i - 1))
    && (let _ = () in let _ = () in (([@expl:replicate requires] [%#sfset] n - 1 >= 0)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] forall xs : Seq.seq t_T . contains (replicate self (n - 1)) xs
    = (Seq.length xs = n - 1 /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))
     -> ([%#sfset'5] forall xs : Seq.seq t_T . contains (cons self (replicate self (n - 1))) xs
    = (0 < Seq.length xs /\ contains'1 self (Seq.get xs 0) /\ contains (replicate self (n - 1)) (tail xs)))
     -> ([%#sfset'0] forall xs : Seq.seq t_T . contains (cons self (replicate self (n - 1))) xs
    = (Seq.length xs = n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))))
  )
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (* logic::fset::FSet<T> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 294 15 294 21
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 295 14 295 123
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 296 14 296 15
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 300 32 300 85
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 299 12 304 13
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T)
  
   =
    [%#sfset'8] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'8] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'11] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'9] insert (Fset.empty : Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec : forall x : Seq.seq t_T . [%#sfset'3] forall y : Seq.seq t_T . contains (singleton x) y
  = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T) (ss : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec : forall s : Fset.fset t_T, ss : Fset.fset (Seq.seq t_T) . [%#sfset'12] forall xs : Seq.seq t_T . contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self : Fset.fset t_T) (n : int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def : forall self : Fset.fset t_T, n : int . ([%#sfset'4] n >= 0)
   -> replicate self n
  = ([%#sfset'10] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty : Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec : forall self : Fset.fset t_T, n : int . ([%#sfset'4] n >= 0)
   -> ([%#sfset'5] forall xs : Seq.seq t_T . contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))
  
  constant self  : Fset.fset t_T
  
  constant n  : int
  
  function replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (self'0 : Fset.fset t_T) (n'0 : int) : Fset.fset (Seq.seq t_T)
  
  
  goal vc_replicate_up_to : ([%#sfset] n >= 0)
   -> (if n = 0 then
    ([%#sfset'2] forall xs : Seq.seq t_T . Seq.length xs = 0  -> xs = (Seq.empty : Seq.seq t_T))
    && (let _ = () in let _ = () in ([%#sfset'3] forall y : Seq.seq t_T . contains (singleton (Seq.empty : Seq.seq t_T)) y
    = ((Seq.empty : Seq.seq t_T) = y))
     -> ([%#sfset'0] forall xs : Seq.seq t_T . contains (singleton (Seq.empty : Seq.seq t_T)) xs
    = (Seq.length xs <= n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x))))
  else
    (([@expl:replicate_up_to requires] [%#sfset] n - 1 >= 0)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] forall xs : Seq.seq t_T . contains (replicate_up_to self (n - 1)) xs
    = (Seq.length xs <= n - 1 /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))
     -> ([@expl:replicate requires] [%#sfset'4] n >= 0)
    /\ (([%#sfset'5] forall xs : Seq.seq t_T . contains (replicate self n) xs
    = (Seq.length xs = n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))
     -> ([%#sfset'0] forall xs : Seq.seq t_T . contains (Fset.union (replicate_up_to self (n
    - 1)) (replicate self n)) xs
    = (Seq.length xs <= n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))))
  )
end
module M_creusot_contracts__logic__fset__unions_union [#"../../creusot-contracts/src/logic/fset.rs" 501 0 501 27]
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 498 10 498 125
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 499 10 500 76
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 501 28 501 30
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 220 14 220 102
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 221 14 221 24
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 223 8 228 9
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_U) (e : t_U)
  
   =
    [%#sfset'5] Fset.mem e self
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'5] Fset.mem e self
  
  function remove [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 92 4 92 37] (self : Fset.fset t_T) (e : t_T) : Fset.fset t_T
  
   =
    [%#sfset'6] Fset.remove e self
  
  function unions [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (self : Fset.fset t_T) (f : Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  
  axiom unions_def : forall self : Fset.fset t_T, f : Map.map t_T (Fset.fset t_U) . unions self f
  = ([%#sfset'4] if Fset.cardinal self = 0 then
    Fset.empty : Fset.fset t_U
  else
    let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
  )
  
  axiom unions_spec : forall self : Fset.fset t_T, f : Map.map t_T (Fset.fset t_U) . [%#sfset'2] forall y : t_U . contains (unions self f) y
  = (exists x : t_T . contains'0 self x /\ contains (Map.get f x) y)
  
  function unions_union [#"../../creusot-contracts/src/logic/fset.rs" 501 0 501 27]  : ()
  
  goal vc_unions_union : ([%#sfset] forall s1 : Fset.fset t_T, s2 : Fset.fset t_T, f : Map.map t_T (Fset.fset t_U) . unions (Fset.union s1 s2) f
  = Fset.union (unions s1 f) (unions s2 f))
  && ([%#sfset'0] forall s : Fset.fset t_T, f : Map.map t_T (Fset.fset t_U), g : Map.map t_T (Fset.fset t_U) . unions s (fun (x : t_T) -> Fset.union (Map.get f x) (Map.get g x))
  = Fset.union (unions s f) (unions s g))
end
module M_creusot_contracts__logic__fset__map_union [#"../../creusot-contracts/src/logic/fset.rs" 507 0 507 24]
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 506 10 506 104
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 507 25 507 27
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 243 8 243 27
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  function map [#"../../creusot-contracts/src/logic/fset.rs" 242 4 242 52] (self : Fset.fset t_T) (f : Map.map t_T t_U) : Fset.fset t_U
  
   =
    [%#sfset'1] Fset.map f self
  
  function map_union [#"../../creusot-contracts/src/logic/fset.rs" 507 0 507 24]  : ()
  
  goal vc_map_union : [%#sfset] forall s : Fset.fset t_T, t : Fset.fset t_T, f : Map.map t_T t_U . map (Fset.union s t) f
  = Fset.union (map s f) (map t f)
end
module M_creusot_contracts__logic__fset__concat_union [#"../../creusot-contracts/src/logic/fset.rs" 516 0 516 24]
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 512 10 513 83
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 514 10 515 83
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 516 25 516 27
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T)
  
   =
    [%#sfset'3] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T)) (t : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec : forall s : Fset.fset (Seq.seq t_T), t : Fset.fset (Seq.seq t_T) . [%#sfset'2] forall xs : Seq.seq t_T . contains (concat s t) xs
  = (exists ys : Seq.seq t_T, zs : Seq.seq t_T . contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_union [#"../../creusot-contracts/src/logic/fset.rs" 516 0 516 24]  : ()
  
  goal vc_concat_union : ([%#sfset] forall s1 : Fset.fset (Seq.seq t_T), s2 : Fset.fset (Seq.seq t_T), t : Fset.fset (Seq.seq t_T) . concat (Fset.union s1 s2) t
  = Fset.union (concat s1 t) (concat s2 t))
  && ([%#sfset'0] forall s : Fset.fset (Seq.seq t_T), t1 : Fset.fset (Seq.seq t_T), t2 : Fset.fset (Seq.seq t_T) . concat s (Fset.union t1 t2)
  = Fset.union (concat s t1) (concat s t2))
end
module M_creusot_contracts__logic__fset__cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 522 0 522 23]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 247 8 247 27
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 521 10 521 133
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 523 20 523 115
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 524 20 524 74
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 525 20 525 89
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 523 4 523 117
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T)
  
   =
    [%#sfset'6] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T)) (t : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec : forall s : Fset.fset (Seq.seq t_T), t : Fset.fset (Seq.seq t_T) . [%#sfset'4] forall xs : Seq.seq t_T . contains (concat s t) xs
  = (exists ys : Seq.seq t_T, zs : Seq.seq t_T . contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'6] Fset.mem e self
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T) (ss : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec : forall s : Fset.fset t_T, ss : Fset.fset (Seq.seq t_T) . [%#sfset'5] forall xs : Seq.seq t_T . contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'0 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function push_front [@inline:trivial] [#"../../creusot-contracts/src/logic/seq.rs" 246 4 246 41] (self : Seq.seq t_T) (x : t_T) : Seq.seq t_T
  
   =
    [%#sseq] Seq.cons x self
  
  function cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 522 0 522 23]  : ()
  
  goal vc_cons_concat : ([%#sfset'0] forall x : t_T, xs : Seq.seq t_T, ys : Seq.seq t_T . Seq.(++) (push_front xs x) ys
  = push_front (Seq.(++) xs ys) x)
  && (let _ = () in let _ = () in ([%#sfset'1] forall x : t_T, ys : Seq.seq t_T . tail (push_front ys x) = ys)
  && (let _ = () in let _ = () in ([%#sfset'2] forall ys : Seq.seq t_T . 0 < Seq.length ys
   -> ys = push_front (tail ys) (Seq.get ys 0))
  && (let _ = () in let _ = () in [%#sfset] forall s : Fset.fset t_T, t : Fset.fset (Seq.seq t_T), u : Fset.fset (Seq.seq t_T) . concat (cons s t) u
  = cons s (concat t u))))
end
module M_creusot_contracts__logic__fset__concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 534 0 534 54]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 531 11 531 27
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 532 10 532 76
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 533 10 533 11
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 548 10 548 59
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 549 10 549 59
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 521 10 521 133
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 536 8 541 9
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 551 4 551 68
  let%span sfset'13 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'14 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'15 = "../../creusot-contracts/src/logic/fset.rs" 523 4 523 117
  let%span sfset'16 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset'17 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T)
  
   =
    [%#sfset'11] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'11] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'17] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'14] insert (Fset.empty : Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec : forall x : Seq.seq t_T . [%#sfset'13] forall y : Seq.seq t_T . contains (singleton x) y
  = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T) (ss : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec : forall s : Fset.fset t_T, ss : Fset.fset (Seq.seq t_T) . [%#sfset'16] forall xs : Seq.seq t_T . contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self : Fset.fset t_T) (n : int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def : forall self : Fset.fset t_T, n : int . ([%#sfset'2] n >= 0)
   -> replicate self n
  = ([%#sfset'9] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty : Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec : forall self : Fset.fset t_T, n : int . ([%#sfset'2] n >= 0)
   -> ([%#sfset'3] forall xs : Seq.seq t_T . contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T)) (t : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec : forall s : Fset.fset (Seq.seq t_T), t : Fset.fset (Seq.seq t_T) . [%#sfset'10] forall xs : Seq.seq t_T . contains (concat s t) xs
  = (exists ys : Seq.seq t_T, zs : Seq.seq t_T . contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 550 0 550 39] (s : Fset.fset (Seq.seq t_T)) : () =
    [%#sfset'12] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty_spec : forall s : Fset.fset (Seq.seq t_T) . ([%#sfset'5] concat (singleton (Seq.empty : Seq.seq t_T)) s
  = s)
  && ([%#sfset'6] concat s (singleton (Seq.empty : Seq.seq t_T)) = s)
  
  function cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 522 0 522 23]  : () =
    [%#sfset'15] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat_spec : [%#sfset'7] forall s : Fset.fset t_T, t : Fset.fset (Seq.seq t_T), u : Fset.fset (Seq.seq t_T) . concat (cons s t) u
  = cons s (concat t u)
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T
  
  function concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 534 0 534 54] (n'0 : int) (m'0 : int) (s'0 : Fset.fset t_T) : ()
  
  
  goal vc_concat_replicate : ([%#sfset] 0 <= n /\ 0 <= m)
   -> (if n = 0 then
    ([@expl:replicate requires] [%#sfset'2] m >= 0)
    /\ (([%#sfset'3] forall xs : Seq.seq t_T . contains (replicate s m) xs
    = (Seq.length xs = m /\ (forall x : t_T . contains'0 xs x  -> contains'1 s x)))
     -> ([%#sfset'5] concat (singleton (Seq.empty : Seq.seq t_T)) (replicate s m) = replicate s m)
    && ([%#sfset'6] concat (replicate s m) (singleton (Seq.empty : Seq.seq t_T)) = replicate s m)
     -> (let _ = concat_empty (replicate s m) in [%#sfset'0] replicate s (n + m)
    = concat (replicate s n) (replicate s m)))
  else
    ([%#sfset'7] forall s'0 : Fset.fset t_T, t : Fset.fset (Seq.seq t_T), u : Fset.fset (Seq.seq t_T) . concat (cons s'0 t) u
    = cons s'0 (concat t u))
     -> (let _ = cons_concat in (([@expl:concat_replicate requires] [%#sfset] 0 <= n - 1 /\ 0 <= m)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] replicate s (n - 1 + m) = concat (replicate s (n - 1)) (replicate s m))
     -> (let _ = concat_replicate (n - 1) m s in [%#sfset'0] replicate s (n + m)
    = concat (replicate s n) (replicate s m))))
  )
end
module M_creusot_contracts__logic__fset__concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 550 0 550 39]
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 548 10 548 59
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 549 10 549 59
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 551 20 551 66
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 552 20 552 66
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 551 4 551 68
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use seq.Seq
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T)) (t : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec : forall s : Fset.fset (Seq.seq t_T), t : Fset.fset (Seq.seq t_T) . [%#sfset'4] forall xs : Seq.seq t_T . contains (concat s t) xs
  = (exists ys : Seq.seq t_T, zs : Seq.seq t_T . contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'8] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'6] insert (Fset.empty : Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec : forall x : Seq.seq t_T . [%#sfset'5] forall y : Seq.seq t_T . contains (singleton x) y
  = (x = y)
  
  constant s  : Fset.fset (Seq.seq t_T)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 550 0 550 39] (s'0 : Fset.fset (Seq.seq t_T)) : ()
  
  goal vc_concat_empty : ([%#sfset'1] forall xs : Seq.seq t_T . Seq.(++) xs (Seq.empty : Seq.seq t_T) = xs)
  && (let _ = () in let _ = () in ([%#sfset'2] forall xs : Seq.seq t_T . Seq.(++) (Seq.empty : Seq.seq t_T) xs = xs)
  && (let _ = () in let _ = () in ([%#sfset] concat (singleton (Seq.empty : Seq.seq t_T)) s = s)
  && ([%#sfset'0] concat s (singleton (Seq.empty : Seq.seq t_T)) = s)))
end
module M_creusot_contracts__logic__fset__concat_replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 562 0 562 60]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 558 11 558 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 559 10 560 67
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 561 10 561 11
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 548 10 548 59
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 549 10 549 59
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 512 10 513 83
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 514 10 515 83
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 531 11 531 27
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 532 10 532 76
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 533 10 533 11
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 564 8 570 9
  let%span sfset'13 = "../../creusot-contracts/src/logic/fset.rs" 294 15 294 21
  let%span sfset'14 = "../../creusot-contracts/src/logic/fset.rs" 295 14 295 123
  let%span sfset'15 = "../../creusot-contracts/src/logic/fset.rs" 296 14 296 15
  let%span sfset'16 = "../../creusot-contracts/src/logic/fset.rs" 299 12 304 13
  let%span sfset'17 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'18 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset'19 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'20 = "../../creusot-contracts/src/logic/fset.rs" 551 4 551 68
  let%span sfset'21 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'22 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'23 = "../../creusot-contracts/src/logic/fset.rs" 516 25 516 27
  let%span sfset'24 = "../../creusot-contracts/src/logic/fset.rs" 536 8 541 9
  let%span sfset'25 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset'26 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset'27 = "../../creusot-contracts/src/logic/fset.rs" 521 10 521 133
  let%span sfset'28 = "../../creusot-contracts/src/logic/fset.rs" 523 4 523 117
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T)
  
   =
    [%#sfset'19] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'19] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T)) (e : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'26] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'22] insert (Fset.empty : Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec : forall x : Seq.seq t_T . [%#sfset'21] forall y : Seq.seq t_T . contains (singleton x) y
  = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T) (ss : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec : forall s : Fset.fset t_T, ss : Fset.fset (Seq.seq t_T) . [%#sfset'25] forall xs : Seq.seq t_T . contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self : Fset.fset t_T) (n : int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def : forall self : Fset.fset t_T, n : int . ([%#sfset'2] n >= 0)
   -> replicate self n
  = ([%#sfset'18] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty : Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec : forall self : Fset.fset t_T, n : int . ([%#sfset'2] n >= 0)
   -> ([%#sfset'3] forall xs : Seq.seq t_T . contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))
  
  function replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (self : Fset.fset t_T) (n : int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_up_to_def : forall self : Fset.fset t_T, n : int . ([%#sfset'13] n >= 0)
   -> replicate_up_to self n
  = ([%#sfset'16] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty : Seq.seq t_T)
  else
    Fset.union (replicate_up_to self (n - 1)) (replicate self n)
  )
  
  axiom replicate_up_to_spec : forall self : Fset.fset t_T, n : int . ([%#sfset'13] n >= 0)
   -> ([%#sfset'14] forall xs : Seq.seq t_T . contains (replicate_up_to self n) xs
  = (Seq.length xs <= n /\ (forall x : t_T . contains'0 xs x  -> contains'1 self x)))
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T)) (t : Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec : forall s : Fset.fset (Seq.seq t_T), t : Fset.fset (Seq.seq t_T) . [%#sfset'17] forall xs : Seq.seq t_T . contains (concat s t) xs
  = (exists ys : Seq.seq t_T, zs : Seq.seq t_T . contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 550 0 550 39] (s : Fset.fset (Seq.seq t_T)) : () =
    [%#sfset'20] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty_spec : forall s : Fset.fset (Seq.seq t_T) . ([%#sfset'5] concat (singleton (Seq.empty : Seq.seq t_T)) s
  = s)
  && ([%#sfset'6] concat s (singleton (Seq.empty : Seq.seq t_T)) = s)
  
  function concat_union [#"../../creusot-contracts/src/logic/fset.rs" 516 0 516 24]  : () =
    [%#sfset'23] ()
  
  axiom concat_union_spec : ([%#sfset'7] forall s1 : Fset.fset (Seq.seq t_T), s2 : Fset.fset (Seq.seq t_T), t : Fset.fset (Seq.seq t_T) . concat (Fset.union s1 s2) t
  = Fset.union (concat s1 t) (concat s2 t))
  && ([%#sfset'8] forall s : Fset.fset (Seq.seq t_T), t1 : Fset.fset (Seq.seq t_T), t2 : Fset.fset (Seq.seq t_T) . concat s (Fset.union t1 t2)
  = Fset.union (concat s t1) (concat s t2))
  
  function cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 522 0 522 23]  : () =
    [%#sfset'28] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat_spec : [%#sfset'27] forall s : Fset.fset t_T, t : Fset.fset (Seq.seq t_T), u : Fset.fset (Seq.seq t_T) . concat (cons s t) u
  = cons s (concat t u)
  
  function concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 534 0 534 54] (n : int) (m : int) (s : Fset.fset t_T) : ()
  
  
  axiom concat_replicate_def : forall n : int, m : int, s : Fset.fset t_T . ([%#sfset'9] 0 <= n /\ 0 <= m)
   -> concat_replicate n m s
  = ([%#sfset'24] if n = 0 then
    let _ = concat_empty (replicate s m) in ()
  else
    let _ = cons_concat in let _ = concat_replicate (n - 1) m s in ()
  )
  
  axiom concat_replicate_spec : forall n : int, m : int, s : Fset.fset t_T . ([%#sfset'9] 0 <= n /\ 0 <= m)
   -> ([%#sfset'10] replicate s (n + m) = concat (replicate s n) (replicate s m))
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T
  
  function concat_replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 562 0 562 60] (n'0 : int) (m'0 : int) (s'0 : Fset.fset t_T) : ()
  
  
  goal vc_concat_replicate_up_to : ([%#sfset] 0 <= n /\ n < m)
   -> (if n + 1 = m then
    ([@expl:replicate requires] [%#sfset'2] n + 1 >= 0)
    /\ (([%#sfset'3] forall xs : Seq.seq t_T . contains (replicate s (n + 1)) xs
    = (Seq.length xs = n + 1 /\ (forall x : t_T . contains'0 xs x  -> contains'1 s x)))
     -> ([%#sfset'5] concat (singleton (Seq.empty : Seq.seq t_T)) (replicate s (n + 1)) = replicate s (n + 1))
    && ([%#sfset'6] concat (replicate s (n + 1)) (singleton (Seq.empty : Seq.seq t_T)) = replicate s (n + 1))
     -> (let _ = concat_empty (replicate s (n + 1)) in [%#sfset'0] replicate_up_to s m
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - n - 1)))))
  else
    ([%#sfset'7] forall s1 : Fset.fset (Seq.seq t_T), s2 : Fset.fset (Seq.seq t_T), t : Fset.fset (Seq.seq t_T) . concat (Fset.union s1 s2) t
    = Fset.union (concat s1 t) (concat s2 t))
    && ([%#sfset'8] forall s'0 : Fset.fset (Seq.seq t_T), t1 : Fset.fset (Seq.seq t_T), t2 : Fset.fset (Seq.seq t_T) . concat s'0 (Fset.union t1 t2)
    = Fset.union (concat s'0 t1) (concat s'0 t2))
     -> (let _ = concat_union in ([@expl:concat_replicate requires] [%#sfset'9] 0 <= n /\ 0 <= m - n - 1)
    /\ (([%#sfset'10] replicate s (n + (m - n - 1)) = concat (replicate s n) (replicate s (m - n - 1)))
     -> (let _ = concat_replicate n (m - n - 1) s in (([@expl:concat_replicate_up_to requires] [%#sfset] 0 <= n
    /\ n < m - 1)
    /\ 0 <= ([%#sfset'1] m) /\ ([%#sfset'1] m - 1) < ([%#sfset'1] m))
    /\ (([%#sfset'0] replicate_up_to s (m - 1)
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - 1 - n - 1))))
     -> (let _ = concat_replicate_up_to n (m - 1) s in [%#sfset'0] replicate_up_to s m
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - n - 1))))))))
  )
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : int) (y'0 : int) : ()
  
  goal vc_cmp_le_log : [%#sord] (x <= y) = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : int) (y'0 : int) : ()
  
  goal vc_cmp_lt_log : [%#sord] (x < y) = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : int) (y'0 : int) : ()
  
  goal vc_cmp_ge_log : [%#sord] (x >= y) = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : int) (y'0 : int) : ()
  
  goal vc_cmp_gt_log : [%#sord] (x > y) = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : int) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'3] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  constant z  : int
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : int) (y'0 : int) (z'0 : int) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'2] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : int) (y'0 : int) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'2] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : int) (y'0 : int) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : int) (y'0 : int) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : UInt8.t) (y'0 : UInt8.t) : ()
  
  goal vc_cmp_le_log : [%#sord] UInt8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : UInt8.t) (y'0 : UInt8.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] UInt8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : UInt8.t) (y'0 : UInt8.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] UInt8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : UInt8.t) (y'0 : UInt8.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] UInt8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : UInt8.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'3] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  constant z  : UInt8.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : UInt8.t) (y'0 : UInt8.t) (z'0 : UInt8.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'2] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : UInt8.t) (y'0 : UInt8.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'2] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : UInt8.t) (y'0 : UInt8.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : UInt8.t) (y'0 : UInt8.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : UInt16.t) (y'0 : UInt16.t) : ()
  
  goal vc_cmp_le_log : [%#sord] UInt16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : UInt16.t) (y'0 : UInt16.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] UInt16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : UInt16.t) (y'0 : UInt16.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] UInt16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : UInt16.t) (y'0 : UInt16.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] UInt16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : UInt16.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'3] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  constant z  : UInt16.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : UInt16.t) (y'0 : UInt16.t) (z'0 : UInt16.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'2] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : UInt16.t) (y'0 : UInt16.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'2] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : UInt16.t) (y'0 : UInt16.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : UInt16.t) (y'0 : UInt16.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : UInt32.t) (y'0 : UInt32.t) : ()
  
  goal vc_cmp_le_log : [%#sord] UInt32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : UInt32.t) (y'0 : UInt32.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] UInt32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : UInt32.t) (y'0 : UInt32.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] UInt32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : UInt32.t) (y'0 : UInt32.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] UInt32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : UInt32.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'3] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  constant z  : UInt32.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : UInt32.t) (y'0 : UInt32.t) (z'0 : UInt32.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'2] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : UInt32.t) (y'0 : UInt32.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'2] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : UInt32.t) (y'0 : UInt32.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : UInt32.t) (y'0 : UInt32.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_cmp_le_log : [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : UInt64.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'3] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : UInt64.t) (y'0 : UInt64.t) (z'0 : UInt64.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : UInt128.t) (y'0 : UInt128.t) : ()
  
  
  goal vc_cmp_le_log : [%#sord] UInt128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : UInt128.t) (y'0 : UInt128.t) : ()
  
  
  goal vc_cmp_lt_log : [%#sord] UInt128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : UInt128.t) (y'0 : UInt128.t) : ()
  
  
  goal vc_cmp_ge_log : [%#sord] UInt128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : UInt128.t) (y'0 : UInt128.t) : ()
  
  
  goal vc_cmp_gt_log : [%#sord] UInt128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : UInt128.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'3] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  constant z  : UInt128.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : UInt128.t) (y'0 : UInt128.t) (z'0 : UInt128.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'2] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : UInt128.t) (y'0 : UInt128.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'2] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : UInt128.t) (y'0 : UInt128.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : UInt128.t) (y'0 : UInt128.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_cmp_le_log : [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : UInt64.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'3] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : UInt64.t) (y'0 : UInt64.t) (z'0 : UInt64.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : UInt64.t) (y'0 : UInt64.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : Int8.t) (y'0 : Int8.t) : ()
  
  goal vc_cmp_le_log : [%#sord] Int8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : Int8.t) (y'0 : Int8.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] Int8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : Int8.t) (y'0 : Int8.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] Int8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : Int8.t) (y'0 : Int8.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] Int8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : Int8.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'3] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  constant z  : Int8.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : Int8.t) (y'0 : Int8.t) (z'0 : Int8.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'2] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : Int8.t) (y'0 : Int8.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'2] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : Int8.t) (y'0 : Int8.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : Int8.t) (y'0 : Int8.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : Int16.t) (y'0 : Int16.t) : ()
  
  goal vc_cmp_le_log : [%#sord] Int16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : Int16.t) (y'0 : Int16.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] Int16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : Int16.t) (y'0 : Int16.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] Int16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : Int16.t) (y'0 : Int16.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] Int16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : Int16.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'3] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  constant z  : Int16.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : Int16.t) (y'0 : Int16.t) (z'0 : Int16.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'2] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : Int16.t) (y'0 : Int16.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'2] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : Int16.t) (y'0 : Int16.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : Int16.t) (y'0 : Int16.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : Int32.t) (y'0 : Int32.t) : ()
  
  goal vc_cmp_le_log : [%#sord] Int32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : Int32.t) (y'0 : Int32.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] Int32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : Int32.t) (y'0 : Int32.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] Int32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : Int32.t) (y'0 : Int32.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] Int32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : Int32.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'3] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  constant z  : Int32.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : Int32.t) (y'0 : Int32.t) (z'0 : Int32.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'2] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : Int32.t) (y'0 : Int32.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'2] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : Int32.t) (y'0 : Int32.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : Int32.t) (y'0 : Int32.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_cmp_le_log : [%#sord] Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : Int64.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'3] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : Int64.t) (y'0 : Int64.t) (z'0 : Int64.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : Int128.t) (y'0 : Int128.t) : ()
  
  goal vc_cmp_le_log : [%#sord] Int128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : Int128.t) (y'0 : Int128.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] Int128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : Int128.t) (y'0 : Int128.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] Int128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : Int128.t) (y'0 : Int128.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] Int128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : Int128.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'3] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  constant z  : Int128.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : Int128.t) (y'0 : Int128.t) (z'0 : Int128.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'2] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : Int128.t) (y'0 : Int128.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'2] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : Int128.t) (y'0 : Int128.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : Int128.t) (y'0 : Int128.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_cmp_le_log : [%#sord] Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : Int64.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'3] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : Int64.t) (y'0 : Int64.t) (z'0 : Int64.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : Int64.t) (y'0 : Int64.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : Char.t) (y'0 : Char.t) : ()
  
  goal vc_cmp_le_log : [%#sord] Char.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : Char.t) (y'0 : Char.t) : ()
  
  goal vc_cmp_lt_log : [%#sord] Char.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : Char.t) (y'0 : Char.t) : ()
  
  goal vc_cmp_ge_log : [%#sord] Char.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : Char.t) (y'0 : Char.t) : ()
  
  goal vc_cmp_gt_log : [%#sord] Char.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : Char.t) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'3] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  constant z  : Char.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : Char.t) (y'0 : Char.t) (z'0 : Char.t) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'2] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : Char.t) (y'0 : Char.t) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'2] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : Char.t) (y'0 : Char.t) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : Char.t) (y'0 : Char.t) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : bool) (y'0 : bool) : ()
  
  goal vc_cmp_le_log : [%#sord] Bool.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : bool) (y'0 : bool) : ()
  
  goal vc_cmp_lt_log : [%#sord] Bool.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : bool) (y'0 : bool) : ()
  
  goal vc_cmp_ge_log : [%#sord] Bool.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : bool) (y'0 : bool) : ()
  
  goal vc_cmp_gt_log : [%#sord] Bool.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : bool) : ()
  
  goal vc_refl : [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'3] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  constant z  : bool
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : bool) (y'0 : bool) (z'0 : bool) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'2] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : bool) (y'0 : bool) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'2] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : bool) (y'0 : bool) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : bool) (y'0 : bool) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec : forall x : t_B, y : t_B . [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec : forall x : t_B, y : t_B . ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec : forall x : t_B, y : t_B . ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec : forall x : t_B . [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec : forall x : t_B, y : t_B . [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec : forall x : t_B, y : t_B . [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec : forall x : t_B, y : t_B . [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec : forall x : t_B, y : t_B . [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_A, y : t_A . [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec'0 : forall x : t_A, y : t_A . ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec'0 : forall x : t_A, y : t_A . ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec'0 : forall x : t_A . [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_A, y : t_A . [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_A, y : t_A . [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self : tuple) (o : tuple) =
    [%#sord'1] self._p0 = o._p0 /\ le_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0 : tuple) (y'0 : tuple) : ()
  
  goal vc_cmp_le_log : [%#sord] le_log'1 x y = (cmp_log'1 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec : forall x : t_B, y : t_B . [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec : forall x : t_B, y : t_B . ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec : forall x : t_B, y : t_B . ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec : forall x : t_B . [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec : forall x : t_B, y : t_B . [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec : forall x : t_B, y : t_B . [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec : forall x : t_B, y : t_B . [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec : forall x : t_B, y : t_B . [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_A, y : t_A . [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec'0 : forall x : t_A, y : t_A . ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec'0 : forall x : t_A, y : t_A . ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec'0 : forall x : t_A . [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_A, y : t_A . [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_A, y : t_A . [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self : tuple) (o : tuple) =
    [%#sord'1] self._p0 = o._p0 /\ lt_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0 : tuple) (y'0 : tuple) : ()
  
  goal vc_cmp_lt_log : [%#sord] lt_log'1 x y = (cmp_log'1 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec : forall x : t_B, y : t_B . [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec : forall x : t_B, y : t_B . ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec : forall x : t_B, y : t_B . ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec : forall x : t_B . [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec : forall x : t_B, y : t_B . [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec : forall x : t_B, y : t_B . [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec : forall x : t_B, y : t_B . [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec : forall x : t_B, y : t_B . [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_A, y : t_A . [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec'0 : forall x : t_A, y : t_A . ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec'0 : forall x : t_A, y : t_A . ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec'0 : forall x : t_A . [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_A, y : t_A . [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_A, y : t_A . [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self : tuple) (o : tuple) =
    [%#sord'1] self._p0 = o._p0 /\ ge_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0 : tuple) (y'0 : tuple) : ()
  
  goal vc_cmp_ge_log : [%#sord] ge_log'1 x y = (cmp_log'1 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec : forall x : t_B, y : t_B . [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec : forall x : t_B, y : t_B . ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec : forall x : t_B, y : t_B . ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec : forall x : t_B . [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec : forall x : t_B, y : t_B . [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec : forall x : t_B, y : t_B . [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec : forall x : t_B, y : t_B . [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec : forall x : t_B, y : t_B . [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_A, y : t_A . [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec'0 : forall x : t_A, y : t_A . ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec'0 : forall x : t_A, y : t_A . ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec'0 : forall x : t_A . [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_A, y : t_A . [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_A, y : t_A . [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self : tuple) (o : tuple) =
    [%#sord'1] self._p0 = o._p0 /\ gt_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0 : tuple) (y'0 : tuple) : ()
  
  goal vc_cmp_gt_log : [%#sord] gt_log'1 x y = (cmp_log'1 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'1] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0 : tuple) : ()
  
  goal vc_refl : [%#sord] cmp_log'1 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'16] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'14] cmp_log x y = C_Greater)
   -> ([%#sord'15] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'12] cmp_log x y = C_Less)
   -> ([%#sord'13] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'9] cmp_log x y = o)
   -> ([%#sord'10] cmp_log y z = o)  -> ([%#sord'11] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'8] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'7] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'6] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'5] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'4] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'16] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'14] cmp_log'0 x y = C_Greater)
   -> ([%#sord'15] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'12] cmp_log'0 x y = C_Less)
   -> ([%#sord'13] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'9] cmp_log'0 x y = o)
   -> ([%#sord'10] cmp_log'0 y z = o)  -> ([%#sord'11] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'8] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'7] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'6] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'5] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'3] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  constant z  : tuple
  
  constant o  : t_Ordering
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0 : tuple) (y'0 : tuple) (z'0 : tuple) (o'0 : t_Ordering) : ()
  
  
  goal vc_trans : ([%#sord] cmp_log'1 x y = o)  -> ([%#sord'0] cmp_log'1 y z = o)  -> ([%#sord'1] cmp_log'1 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'2] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0 : tuple) (y'0 : tuple) : ()
  
  goal vc_antisym1 : ([%#sord] cmp_log'1 x y = C_Less)  -> ([%#sord'0] cmp_log'1 y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'2] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0 : tuple) (y'0 : tuple) : ()
  
  goal vc_antisym2 : ([%#sord] cmp_log'1 x y = C_Greater)  -> ([%#sord'0] cmp_log'1 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'1] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0 : tuple) (y'0 : tuple) : ()
  
  goal vc_eq_cmp : [%#sord] (x = y) = (cmp_log'1 x y = C_Equal)
end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__flat_map [#"../../creusot-contracts/src/logic/seq.rs" 292 4 292 73] (* logic::seq::Seq<T> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 291 14 291 24
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 293 8 297 9
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'1] Seq.([..]) self 1 (Seq.length self)
  
  constant self  : Seq.seq t_T
  
  constant other  : Map.map t_T (Seq.seq t_U)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 292 4 292 73] (self'0 : Seq.seq t_T) (other'0 : Map.map t_T (Seq.seq t_U)) : Seq.seq t_U
  
  
  goal vc_flat_map : if Seq.length self = 0 then
    true
  else
    0 <= ([%#sseq] Seq.length self) /\ ([%#sseq] Seq.length (tail self)) < ([%#sseq] Seq.length self)

end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17] (* logic::seq::Seq<T> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq'1] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  function concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17]  : ()
  
  goal vc_concat_contains : [%#sseq] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains (Seq.(++) a b) x
  = contains a x
  \/ contains b x
end
module M_creusot_contracts__logic__seq__qyi16115490154402163220__flatten [#"../../creusot-contracts/src/logic/seq.rs" 402 4 402 34] (* logic::seq::Seq<logic::seq::Seq<T>> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 401 14 401 24
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 403 8 407 9
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq (Seq.seq t_T)) : Seq.seq (Seq.seq t_T)
  
   =
    [%#sseq'1] Seq.([..]) self 1 (Seq.length self)
  
  constant self  : Seq.seq (Seq.seq t_T)
  
  function flatten [#"../../creusot-contracts/src/logic/seq.rs" 402 4 402 34] (self'0 : Seq.seq (Seq.seq t_T)) : Seq.seq t_T
  
  
  goal vc_flatten : if Seq.length self = 0 then
    true
  else
    0 <= ([%#sseq] Seq.length self) /\ ([%#sseq] Seq.length (tail self)) < ([%#sseq] Seq.length self)

end
module M_creusot_contracts__logic__seq__flat_map_singleton [#"../../creusot-contracts/src/logic/seq.rs" 680 0 680 33]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 679 10 679 87
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 680 34 680 36
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 291 14 291 24
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 293 8 297 9
  let%span sseq'3 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use seq.Seq
  use map.Map
  
  type t_A
  
  type t_B
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_A) : Seq.seq t_A =
    [%#sseq'3] Seq.([..]) self 1 (Seq.length self)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 292 4 292 73] (self : Seq.seq t_A) (other : Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  
  axiom flat_map_def : forall self : Seq.seq t_A, other : Map.map t_A (Seq.seq t_B) . flat_map self other
  = ([%#sseq'2] if Seq.length self = 0 then
    Seq.empty : Seq.seq t_B
  else
    Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
  )
  
  function flat_map_singleton [#"../../creusot-contracts/src/logic/seq.rs" 680 0 680 33]  : ()
  
  goal vc_flat_map_singleton : [%#sseq] forall x : t_A, f : Map.map t_A (Seq.seq t_B) . flat_map (Seq.singleton x) f
  = Map.get f x
end
module M_creusot_contracts__logic__seq__flat_map_push_back [#"../../creusot-contracts/src/logic/seq.rs" 686 0 686 43]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 684 10 684 108
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 685 10 685 18
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 689 24 689 85
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 687 4 690 5
  let%span sseq'3 = "../../creusot-contracts/src/logic/seq.rs" 291 14 291 24
  let%span sseq'4 = "../../creusot-contracts/src/logic/seq.rs" 293 8 297 9
  let%span sseq'5 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_A) : Seq.seq t_A =
    [%#sseq'5] Seq.([..]) self 1 (Seq.length self)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 292 4 292 73] (self : Seq.seq t_A) (other : Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  
  axiom flat_map_def : forall self : Seq.seq t_A, other : Map.map t_A (Seq.seq t_B) . flat_map self other
  = ([%#sseq'4] if Seq.length self = 0 then
    Seq.empty : Seq.seq t_B
  else
    Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
  )
  
  constant xs  : Seq.seq t_A
  
  function flat_map_push_back [#"../../creusot-contracts/src/logic/seq.rs" 686 0 686 43] (xs'0 : Seq.seq t_A) : ()
  
  goal vc_flat_map_push_back : if Seq.length xs > 0 then
    (0 <= ([%#sseq'0] Seq.length xs) /\ ([%#sseq'0] Seq.length (tail xs)) < ([%#sseq'0] Seq.length xs))
    /\ (([%#sseq] forall x : t_A, f : Map.map t_A (Seq.seq t_B) . flat_map (Seq.snoc (tail xs) x) f
    = Seq.(++) (flat_map (tail xs) f) (Map.get f x))
     -> (let _ = flat_map_push_back (tail xs) in ([%#sseq'1] forall x : t_A . Seq.snoc (tail xs) x
    = tail (Seq.snoc xs x))
    && (let _ = () in [%#sseq] forall x : t_A, f : Map.map t_A (Seq.seq t_B) . flat_map (Seq.snoc xs x) f
    = Seq.(++) (flat_map xs f) (Map.get f x))))
  else
    [%#sseq] forall x : t_A, f : Map.map t_A (Seq.seq t_B) . flat_map (Seq.snoc xs x) f
    = Seq.(++) (flat_map xs f) (Map.get f x)

end
module M_creusot_contracts__pcell__qyi11656593191764906533__clone [#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (* <pcell::Id as std::clone::Clone> *)
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 33 14 33 29
  
  use creusot.prelude.Any
  
  type t_Id
  
  meta "compute_max_steps" 1000000
  
  let rec clone'[#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (self:t_Id) (return'  (x:t_Id))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : t_Id = Any.any_l () | & self'0 : t_Id = self ] 
    [ return''0 (result:t_Id)-> {[@expl:clone ensures] [%#spcell] result = self} (! return' {result}) ]

end
module M_creusot_contracts__pcell__qyi14846468513926953542__take [#"../../creusot-contracts/src/pcell.rs" 283 4 283 65] (* pcell::PCell<T> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 153 14 153 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 158 14 158 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 283 24 283 28
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 283 30 283 34
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 279 15 279 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 283 64 283 65
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 280 14 280 53
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 281 14 281 46
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 282 14 282 66
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 156 27 156 31
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 156 33 156 37
  let%span spcell'8 = "../../creusot-contracts/src/pcell.rs" 156 64 156 67
  let%span spcell'9 = "../../creusot-contracts/src/pcell.rs" 152 15 152 37
  let%span spcell'10 = "../../creusot-contracts/src/pcell.rs" 156 75 156 76
  let%span spcell'11 = "../../creusot-contracts/src/pcell.rs" 153 14 153 43
  let%span spcell'12 = "../../creusot-contracts/src/pcell.rs" 154 14 154 46
  let%span spcell'13 = "../../creusot-contracts/src/pcell.rs" 155 14 155 53
  let%span spcell'14 = "../../creusot-contracts/src/pcell.rs" 52 8 52 19
  let%span spcell'15 = "../../creusot-contracts/src/pcell.rs" 77 20 77 41
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 97 8 97 18
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : ()) (args : ())
  
  axiom precondition_fndef : forall args : () [precondition () args] . (let () = args in true)  -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : ()) (result : t_T)
  
  
  axiom postcondition_fndef : forall args : (), res : t_T [postcondition_once () args res] . postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_T }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_UnsafeCell)
  
  axiom inv_axiom [@rewrite] : forall x : t_UnsafeCell [inv'0 x] . inv'0 x
  = match x with
    | {t_UnsafeCell__value = value} -> inv value
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_PCell)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_PCell [inv'1 x] . inv'1 x
  = match x with
    | {t_PCell__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_PCell) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_PCell)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_PCell [inv'2 x] . inv'2 x = invariant' x
  
  function val' [#"../../creusot-contracts/src/pcell.rs" 97 4 97 33] (self : t_PCellOwn) : t_T
  
  function view [#"../../creusot-contracts/src/pcell.rs" 51 4 51 33] (self : t_PCellOwn) : t_T =
    [%#spcell'14] val' self
  
  predicate invariant''0 [#"../../creusot-contracts/src/pcell.rs" 76 4 76 30] (self : t_PCellOwn) =
    [%#spcell'15] inv (view self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_PCellOwn)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_PCellOwn [inv'3 x] . inv'3 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_PCellOwn) =
    [%#sinvariant'0] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_PCellOwn)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_PCellOwn [inv'4 x] . inv'4 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/ghost.rs" 96 4 96 30] (self :  (MutBorrow.t t_PCellOwn)) =
    [%#sghost] inv'4 self
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 :  (MutBorrow.t t_PCellOwn))
  
  axiom inv_axiom'4 [@rewrite] : forall x :  (MutBorrow.t t_PCellOwn) [inv'5 x] . inv'5 x = invariant''2 x
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/pcell.rs" 241 4 241 25] (self : t_PCell) : t_Id
  
  function id'0 [#"../../creusot-contracts/src/pcell.rs" 90 4 90 25] (self : t_PCellOwn) : t_Id
  
  let rec replace (self:t_PCell) (perm: (MutBorrow.t t_PCellOwn)) (val''0:t_T) (return'  (x:t_T))= {[@expl:replace 'self' type invariant] [%#spcell'6] inv'2 self}
    {[@expl:replace 'perm' type invariant] [%#spcell'7] inv'5 perm}
    {[@expl:replace 'val' type invariant] [%#spcell'8] inv val''0}
    {[@expl:replace requires] [%#spcell'9] id self = id'0 perm.current}
    any
    [ return''0 (result:t_T)-> {[%#spcell'10] inv result}
      {[%#spcell'11] val''0 = view perm.final}
      {[%#spcell'12] result = view perm.current}
      {[%#spcell'13] id self = id'0 perm.final}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : ()) (args : ()) (result_state : ()) (result : t_T)
  
  
  axiom postcondition_fndef'0 : forall args : (), res : t_T [postcondition_mut () args () res] . postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : t_T . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : t_T . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 41] (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : ()) (args : ()) (result : t_T)
  
  
  axiom postcondition_fndef'1 : forall args : (), res : t_T [postcondition () args res] . postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 51] (self : ()) (args : ()) (res : t_T) : ()
  
  axiom fn_once_spec : forall self : (), args : (), res : t_T . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 154 4 154 67] (self : ()) (args : ()) (res_state : ()) (res : t_T) : ()
  
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : t_T . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec take[#"../../creusot-contracts/src/pcell.rs" 283 4 283 65] (self:t_PCell) (perm: (MutBorrow.t t_PCellOwn)) (return'  (x:t_T))= {[@expl:take 'self' type invariant] [%#spcell] inv'2 self}
    {[@expl:take 'perm' type invariant] [%#spcell'0] inv'5 perm}
    {[@expl:take requires] [%#spcell'1] id self = id'0 perm.current}
    (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_9 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = replace {self'0} {perm'0} {_9} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    )
    [ & _0 : t_T = Any.any_l ()
    | & self'0 : t_PCell = self
    | & perm'0 :  (MutBorrow.t t_PCellOwn) = perm
    | & _9 : t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:take result type invariant] [%#spcell'2] inv result}
      {[@expl:take ensures #0] [%#spcell'3] id self = id'0 perm.final}
      {[@expl:take ensures #1] [%#spcell'4] result = view perm.current}
      {[@expl:take ensures #2] [%#spcell'5] postcondition () () (view perm.final)}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18263836234684628832__clone [#"../../creusot-contracts/src/peano.rs" 33 9 33 14] (* <peano::PeanoInt as std::clone::Clone> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 33 9 33 14
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 15 26 15 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  let rec clone' (self_:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sclone] result = self_} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec clone''0[#"../../creusot-contracts/src/peano.rs" 33 9 33 14] (self:t_PeanoInt) (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- self'0.t_PeanoInt__0 ] s1
      | s1 = clone' {_5} (fun (_ret:UInt64.t) ->  [ &_3 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = _3 } ] s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0 : t_PeanoInt = Any.any_l ()
    | & self'0 : t_PeanoInt = self
    | & _3 : UInt64.t = Any.any_l ()
    | & _5 : UInt64.t = Any.any_l () ]
     [ return''0 (result:t_PeanoInt)-> {[@expl:clone ensures] [%#speano] result = self} (! return' {result}) ] 
end
module M_creusot_contracts__peano__qyi17635635094782400840__default [#"../../creusot-contracts/src/peano.rs" 33 22 33 29] (* <peano::PeanoInt as std::default::Default> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 153 14 153 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 158 14 158 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span speano = "../../creusot-contracts/src/peano.rs" 33 22 33 29
  let%span snum = "../../creusot-contracts/src/std/num.rs" 30 26 30 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec default (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = (0 : UInt64.t)} (! return' {result}) ]
  
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : ()) (args : ()) (result : UInt64.t)
  
   =
    let () = args in result = (0 : UInt64.t)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : ()) (args : ()) (result_state : ()) (result : UInt64.t)
  
   =
    let () = args in result = (0 : UInt64.t)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : ()) (args : ()) (res : UInt64.t) : ()
  
  
  axiom fn_mut_once_spec : forall self : (), args : (), res : UInt64.t . [%#sops'8] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : ()) (result_state : ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : ()) (b : ()) (c : ()) : ()
  
  axiom hist_inv_trans_spec : forall self : (), b : (), c : () . ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : ()) : ()
  
  axiom hist_inv_refl_spec : forall self : () . [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : ()) (args : ()) (res_state : ()) (res : UInt64.t) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : (), args : (), res_state : (), res : UInt64.t . ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 41] (self : ()) (res_state : ()) : ()
  
  axiom fn_hist_inv_spec : forall self : (), res_state : () . [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : ()) (args : ()) (result : UInt64.t)
  
   =
    let () = args in result = (0 : UInt64.t)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 51] (self : ()) (args : ()) (res : UInt64.t) : ()
  
  
  axiom fn_once_spec : forall self : (), args : (), res : UInt64.t . [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 154 4 154 67] (self : ()) (args : ()) (res_state : ()) (res : UInt64.t) : ()
  
  
  axiom fn_mut_spec : forall self : (), args : (), res_state : (), res : UInt64.t . [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec default'0[#"../../creusot-contracts/src/peano.rs" 33 22 33 29] (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:UInt64.t) ->  [ &_2 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = _2 } ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : t_PeanoInt = Any.any_l () | & _2 : UInt64.t = Any.any_l () ] 
    [ return''0 (result:t_PeanoInt)-> {[@expl:default ensures] [%#speano] true
      /\ postcondition () () result.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__new [#"../../creusot-contracts/src/peano.rs" 48 4 48 24] (* peano::PeanoInt *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 13 49 14
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 47 14 47 26
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self : t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  let rec new[#"../../creusot-contracts/src/peano.rs" 48 4 48 24] (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = ([%#speano] (0 : UInt64.t)) } ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : t_PeanoInt = Any.any_l () ] 
    [ return''0 (result:t_PeanoInt)-> {[@expl:new ensures] [%#speano'0] view result = 0} (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u64 [#"../../creusot-contracts/src/peano.rs" 78 4 78 30] (* peano::PeanoInt *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 77 14 77 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self : t_PeanoInt) : int =
    [%#speano'0] UInt64.t'int self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  let rec to_u64[#"../../creusot-contracts/src/peano.rs" 78 4 78 30] (self:t_PeanoInt) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0.t_PeanoInt__0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & self'0 : t_PeanoInt = self ] 
    [ return''0 (result:UInt64.t)-> {[@expl:to_u64 ensures] [%#speano] UInt64.t'int result = view self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u128 [#"../../creusot-contracts/src/peano.rs" 93 4 93 32] (* peano::PeanoInt *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 92 14 92 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self : t_PeanoInt) : int =
    [%#speano'0] UInt64.t'int self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  let rec to_u128[#"../../creusot-contracts/src/peano.rs" 93 4 93 32] (self:t_PeanoInt) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt128.of_int {UInt64.t'int self'0.t_PeanoInt__0} (fun (_ret_from:UInt128.t) ->  [ &_0 <- _ret_from ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0 : UInt128.t = Any.any_l () | & self'0 : t_PeanoInt = self ] 
    [ return''0 (result:UInt128.t)-> {[@expl:to_u128 ensures] [%#speano] UInt128.t'int result = view self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_i128 [#"../../creusot-contracts/src/peano.rs" 100 4 100 32] (* peano::PeanoInt *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 99 14 99 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self : t_PeanoInt) : int =
    [%#speano'0] UInt64.t'int self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  let rec to_i128[#"../../creusot-contracts/src/peano.rs" 100 4 100 32] (self:t_PeanoInt) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int128.of_int {UInt64.t'int self'0.t_PeanoInt__0} (fun (_ret_from:Int128.t) ->  [ &_0 <- _ret_from ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0 : Int128.t = Any.any_l () | & self'0 : t_PeanoInt = self ] 
    [ return''0 (result:Int128.t)-> {[@expl:to_i128 ensures] [%#speano] Int128.to_int result = view self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi924939193479538090__from [#"../../creusot-contracts/src/peano.rs" 107 4 107 34] (* <u64 as std::convert::From<peano::PeanoInt>> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 106 14 106 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 77 14 77 30
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self : t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  let rec to_u64 (self:t_PeanoInt) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#speano'0] UInt64.t'int result = view self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 107 4 107 34] (val':t_PeanoInt) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 = to_u64 {val''0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0 : UInt64.t = Any.any_l () | & val''0 : t_PeanoInt = val' ] 
    [ return''0 (result:UInt64.t)-> {[@expl:from ensures] [%#speano] UInt64.t'int result = view val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18279771819627139730__from [#"../../creusot-contracts/src/peano.rs" 114 4 114 34] (* <i64 as std::convert::From<peano::PeanoInt>> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 113 14 113 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 85 14 85 30
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.Int64
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self : t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  let rec to_i64 (self:t_PeanoInt) (return'  (x:Int64.t))= any
    [ return''0 (result:Int64.t)-> {[%#speano'0] Int64.to_int result = view self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 114 4 114 34] (val':t_PeanoInt) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0 [ s0 = to_i64 {val''0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ]  | bb1 = return''0 {_0} ]
    ) [ & _0 : Int64.t = Any.any_l () | & val''0 : t_PeanoInt = val' ] 
    [ return''0 (result:Int64.t)-> {[@expl:from ensures] [%#speano] Int64.to_int result = view val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi6128796959392123454__from [#"../../creusot-contracts/src/peano.rs" 121 4 121 34] (* <u128 as std::convert::From<peano::PeanoInt>> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 120 14 120 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 92 14 92 30
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt128
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self : t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  let rec to_u128 (self:t_PeanoInt) (return'  (x:UInt128.t))= any
    [ return''0 (result:UInt128.t)-> {[%#speano'0] UInt128.t'int result = view self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 121 4 121 34] (val':t_PeanoInt) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0 [ s0 = to_u128 {val''0} (fun (_ret:UInt128.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0 : UInt128.t = Any.any_l () | & val''0 : t_PeanoInt = val' ] 
    [ return''0 (result:UInt128.t)-> {[@expl:from ensures] [%#speano] UInt128.t'int result = view val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi11594489632978387465__from [#"../../creusot-contracts/src/peano.rs" 128 4 128 34] (* <i128 as std::convert::From<peano::PeanoInt>> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 127 14 127 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 99 14 99 30
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.Int128
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self : t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  let rec to_i128 (self:t_PeanoInt) (return'  (x:Int128.t))= any
    [ return''0 (result:Int128.t)-> {[%#speano'0] Int128.to_int result = view self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 128 4 128 34] (val':t_PeanoInt) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0 [ s0 = to_i128 {val''0} (fun (_ret:Int128.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0 : Int128.t = Any.any_l () | & val''0 : t_PeanoInt = val' ] 
    [ return''0 (result:Int128.t)-> {[@expl:from ensures] [%#speano] Int128.to_int result = view val'}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__new [#"../../creusot-contracts/src/ptr_own.rs" 57 4 57 53] (* ptr_own::PtrOwn<T> *)
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 97 8 97 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 57 15 57 16
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 57 24 57 53
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 56 14 56 64
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 66 20 66 23
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 66 36 66 65
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 65 14 65 67
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 35 8 35 16
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 41 8 41 16
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_T }
  
  type tuple  =
    { _p0: Opaque.ptr; _p1:  t_PtrOwn }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self : Opaque.ptr) : UInt64.t
  
  function is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self : Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0 : UInt64.t)
  
  axiom is_null_logic_spec : forall self : Opaque.ptr . [%#sptr] is_null_logic self = (addr_logic self = (0 : UInt64.t))
  
  function ptr [#"../../creusot-contracts/src/ptr_own.rs" 34 4 34 34] (self : t_PtrOwn) : Opaque.ptr =
    [%#sptr_own'5] self.t_PtrOwn__ptr
  
  predicate invariant''0 [#"../../creusot-contracts/src/ptr_own.rs" 48 4 48 30] (self : t_PtrOwn) =
    [%#sptr_own'7] not is_null_logic (ptr self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_PtrOwn [inv'1 x] . inv'1 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'0 val'
    end)
  
  predicate invariant''1 [#"../../creusot-contracts/src/ghost.rs" 96 4 96 30] (self :  t_PtrOwn) =
    [%#sghost] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 :  t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite] : forall x :  t_PtrOwn [inv'2 x] . inv'2 x = invariant''1 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : tuple)
  
  axiom inv_axiom'2 [@rewrite] : forall x : tuple [inv'3 x] . inv'3 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'2 x1)
  
  function val' [#"../../creusot-contracts/src/ptr_own.rs" 40 4 40 34] (self : t_PtrOwn) : t_T =
    [%#sptr_own'6] self.t_PtrOwn__val
  
  let rec from_box (val''0:t_T) (return'  (x:tuple))= {[@expl:from_box 'val' type invariant] [%#sptr_own'2] inv'0 val''0}
    any
    [ return''0 (result:tuple)-> {[%#sptr_own'3] inv'3 result}
      {[%#sptr_own'4] ptr result._p1 = result._p0 /\ val' result._p1 = val''0}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec new[#"../../creusot-contracts/src/ptr_own.rs" 57 4 57 53] (v:t_T) (return'  (x:tuple))= {[@expl:new 'v' type invariant] [%#sptr_own] inv v}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0 [ s0 = from_box {v'0} (fun (_ret:tuple) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    ) [ & _0 : tuple = Any.any_l () | & v'0 : t_T = v ] 
    [ return''0 (result:tuple)-> {[@expl:new result type invariant] [%#sptr_own'0] inv'3 result}
      {[@expl:new ensures] [%#sptr_own'1] ptr result._p1 = result._p0 /\ val' result._p1 = v}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__drop [#"../../creusot-contracts/src/ptr_own.rs" 131 4 131 61] (* ptr_own::PtrOwn<T> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 66 8 66 23
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 97 8 97 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 131 39 131 42
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 130 15 130 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 118 41 118 44
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 115 15 115 31
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 118 67 118 73
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 116 14 116 35
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 35 8 35 16
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 41 8 41 16
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_T }
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self : Opaque.ptr) : UInt64.t
  
  function is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self : Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0 : UInt64.t)
  
  axiom is_null_logic_spec : forall self : Opaque.ptr . [%#sptr] is_null_logic self = (addr_logic self = (0 : UInt64.t))
  
  function ptr [#"../../creusot-contracts/src/ptr_own.rs" 34 4 34 34] (self : t_PtrOwn) : Opaque.ptr =
    [%#sptr_own'5] self.t_PtrOwn__ptr
  
  predicate invariant' [#"../../creusot-contracts/src/ptr_own.rs" 48 4 48 30] (self : t_PtrOwn) =
    [%#sptr_own'7] not is_null_logic (ptr self)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant''0 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_PtrOwn [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'0 val'
    end)
  
  predicate invariant''1 [#"../../creusot-contracts/src/ghost.rs" 96 4 96 30] (self :  t_PtrOwn) =
    [%#sghost] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 :  t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite] : forall x :  t_PtrOwn [inv'2 x] . inv'2 x = invariant''1 x
  
  function val' [#"../../creusot-contracts/src/ptr_own.rs" 40 4 40 34] (self : t_PtrOwn) : t_T =
    [%#sptr_own'6] self.t_PtrOwn__val
  
  let rec to_box (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:t_T))= {[@expl:to_box 'own' type invariant] [%#sptr_own'1] inv'2 own}
    {[@expl:to_box requires] [%#sptr_own'2] ptr'0 = ptr own}
    any
    [ return''0 (result:t_T)-> {[%#sptr_own'3] inv'0 result} {[%#sptr_own'4] result = val' own} (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 65 4 65 28] (self : t_T) =
    [%#sresolve] resolve self
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T) =
    resolve'0 _0
  
  meta "compute_max_steps" 1000000
  
  let rec drop[#"../../creusot-contracts/src/ptr_own.rs" 131 4 131 61] (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:()))= {[@expl:drop 'own' type invariant] [%#sptr_own] inv'2 own}
    {[@expl:drop requires] [%#sptr_own'0] ptr'0 = ptr own}
    (! bb0
    [ bb0 = s0 [ s0 = to_box {ptr'1} {own'0} (fun (_ret:t_T) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 _4} s1 | s1 = -{resolve'1 _4}- s2 | s2 = bb2 ] 
    | bb2 = return''0 {_0} ]
    )
    [ & _0 : () = Any.any_l () | & ptr'1 : Opaque.ptr = ptr'0 | & own'0 :  t_PtrOwn = own | & _4 : t_T = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 46 4 46 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 15 44 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 45 14 45 31
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 46 32 46 34
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 40 8 40 44
  
  type t_T1
  
  type t_T2
  
  type tuple  =
    { _p0: t_T1; _p1: t_T2 }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T2)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T1)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : tuple) =
    match _0 with
      | {_p0 = x0 ; _p1 = x1} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 39 4 39 28] (self : tuple) =
    [%#sresolve'2] resolve'0 self._p0 /\ resolve self._p1
  
  constant self  : tuple
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 46 4 46 31] (self'0 : tuple) : ()
  
  goal vc_resolve_coherence : ([%#sresolve] structural_resolve self)  -> ([%#sresolve'0] resolve'1 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 59 4 59 31] (* <&mut T as resolve::Resolve> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 57 15 57 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 58 14 58 31
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 59 32 59 34
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : MutBorrow.t t_T) =
    _0.final = _0.current
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve'2] self.final = self.current
  
  constant self  : MutBorrow.t t_T
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 59 4 59 31] (self'0 : MutBorrow.t t_T) : ()
  
  goal vc_resolve_coherence : ([%#sresolve] structural_resolve self)  -> ([%#sresolve'0] resolve self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 72 4 72 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 70 15 70 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 71 14 71 31
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 72 32 72 34
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 66 8 66 23
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_T) =
    resolve _0
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 65 4 65 28] (self : t_T) =
    [%#sresolve'2] resolve self
  
  constant self  : t_T
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 72 4 72 31] (self'0 : t_T) : ()
  
  goal vc_resolve_coherence : ([%#sresolve] structural_resolve self)  -> ([%#sresolve'0] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 88 4 88 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 86 15 86 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 87 14 87 31
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 88 32 88 34
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Option) =
    match _0 with
      | C_None -> true
      | C_Some x0 -> resolve x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve'2] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  constant self  : t_Option
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 88 4 88 31] (self'0 : t_Option) : ()
  
  goal vc_resolve_coherence : ([%#sresolve] structural_resolve self)  -> ([%#sresolve'0] resolve'0 self)
end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone [#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot = "../../creusot-contracts/src/snapshot.rs" 56 14 56 29
  
  use creusot.prelude.Any
  
  type t_T
  
  meta "compute_max_steps" 1000000
  
  let rec clone'[#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (self:t_T) (return'  (x:t_T))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : t_T = Any.any_l () | & self'0 : t_T = self ] 
    [ return''0 (result:t_T)-> {[@expl:clone ensures] [%#ssnapshot] result = self} (! return' {result}) ]

end
module M_creusot_contracts__util__unwrap [#"../../creusot-contracts/src/util.rs" 56 0 56 36]
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span sutil'1 = "../../creusot-contracts/src/util.rs" 45 11 45 16
  let%span sutil'2 = "../../creusot-contracts/src/util.rs" 46 10 46 15
  let%span sutil'3 = "../../creusot-contracts/src/util.rs" 47 10 47 11
  let%span sutil'4 = "../../creusot-contracts/src/util.rs" 57 4 60 5
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function unreachable [#"../../creusot-contracts/src/util.rs" 48 0 48 28]  : t_T
  
  axiom unreachable_spec : ([%#sutil'1] false)  -> ([%#sutil'2] false)
  
  constant op  : t_Option
  
  function unwrap [#"../../creusot-contracts/src/util.rs" 56 0 56 36] (op'0 : t_Option) : t_T
  
  goal vc_unwrap : ([%#sutil] op <> C_None)
   -> match op with
    | C_Some t -> [%#sutil'0] C_Some t = op
    | C_None -> ([@expl:unreachable requires] [%#sutil'1] false)
    /\ (([%#sutil'2] false)  -> ([%#sutil'0] C_Some unreachable = op))
    end
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl__refines [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 71 4 71 26
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self : t_IntoIter) (visited : Seq.seq t_T) (o : t_IntoIter)
  
   =
    [%#sarray'0] view self = Seq.(++) visited (view o)
  
  goal refines : [%#sarray] forall self : t_IntoIter . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans__refines [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 78 4 78 90
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self : t_IntoIter) (visited : Seq.seq t_T) (o : t_IntoIter)
  
   =
    [%#sarray'0] view self = Seq.(++) visited (view o)
  
  goal refines : [%#sarray] forall a : t_IntoIter . forall ab : Seq.seq t_T . forall b : t_IntoIter . forall bc : Seq.seq t_T . forall c : t_IntoIter . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self : t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple'0) (x : tuple'0) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'1
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view self) k = C_Some'0 v
     -> (exists k1 : t_K . deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  goal refines : [%#shash_map] forall self : t_IntoIter'0 . forall result : () . produces self (Seq.empty : Seq.seq tuple'0) self
   -> produces self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self : t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple'0) (x : tuple'0) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'1
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view self) k = C_Some'0 v
     -> (exists k1 : t_K . deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  goal refines : [%#shash_map] forall a : t_IntoIter'0 . forall ab : Seq.seq tuple'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq tuple'0 . forall c : t_IntoIter'0 . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self : t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self : t_Iter'0) (visited : Seq.seq tuple) (o : t_Iter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view self) k = C_Some v
     -> (exists k2 : t_K . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  goal refines : [%#shash_map] forall a : t_Iter'0 . forall ab : Seq.seq tuple . forall b : t_Iter'0 . forall bc : Seq.seq tuple . forall c : t_Iter'0 . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self : t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self : t_Iter'0) (visited : Seq.seq tuple) (o : t_Iter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view self) k = C_Some v
     -> (exists k2 : t_K . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  goal refines : [%#shash_map] forall self : t_Iter'0 . forall result : () . produces self (Seq.empty : Seq.seq tuple) self
   -> produces self (Seq.empty : Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self : t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self : t_IterMut'0) (visited : Seq.seq tuple) (o : t_IterMut'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : MutBorrow.t t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : MutBorrow.t t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view self) k = C_Some v
     -> (exists k1 : t_K . deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  goal refines : [%#shash_map] forall a : t_IterMut'0 . forall ab : Seq.seq tuple . forall b : t_IterMut'0 . forall bc : Seq.seq tuple . forall c : t_IterMut'0 . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self : t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'2] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap) (k : t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self : t_IterMut'0) (visited : Seq.seq tuple) (o : t_IterMut'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k : t_K, v : MutBorrow.t t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : MutBorrow.t t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view self) k = C_Some v
     -> (exists k1 : t_K . deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  goal refines : [%#shash_map] forall self : t_IterMut'0 . forall result : () . produces self (Seq.empty : Seq.seq tuple) self
   -> produces self (Seq.empty : Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self : t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_IntoIter'1) (visited : Seq.seq t_T) (end' : t_IntoIter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self : t_IntoIter'1) (visited : Seq.seq t_T) (o : t_IntoIter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines : [%#shash_set] forall self : t_IntoIter'1 . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self : t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_IntoIter'1) (visited : Seq.seq t_T) (end' : t_IntoIter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self : t_IntoIter'1) (visited : Seq.seq t_T) (o : t_IntoIter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines : [%#shash_set] forall a : t_IntoIter'1 . forall ab : Seq.seq t_T . forall b : t_IntoIter'1 . forall bc : Seq.seq t_T . forall c : t_IntoIter'1 . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self : t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Iter'1) (visited : Seq.seq t_T) (end' : t_Iter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self : t_Iter'1) (visited : Seq.seq t_T) (o : t_Iter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines : [%#shash_set] forall a : t_Iter'1 . forall ab : Seq.seq t_T . forall b : t_Iter'1 . forall bc : Seq.seq t_T . forall c : t_Iter'1 . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self : t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Iter'1) (visited : Seq.seq t_T) (end' : t_Iter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self : t_Iter'1) (visited : Seq.seq t_T) (o : t_Iter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines : [%#shash_set] forall self : t_Iter'1 . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self : t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Intersection) (visited : Seq.seq t_T) (end' : t_Intersection)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self : t_Intersection) (visited : Seq.seq t_T) (o : t_Intersection)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines : [%#shash_set] forall self : t_Intersection . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self : t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Intersection) (visited : Seq.seq t_T) (end' : t_Intersection)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self : t_Intersection) (visited : Seq.seq t_T) (o : t_Intersection)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines : [%#shash_set] forall a : t_Intersection . forall ab : Seq.seq t_T . forall b : t_Intersection . forall bc : Seq.seq t_T . forall c : t_Intersection . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self : t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Difference) (visited : Seq.seq t_T) (end' : t_Difference)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self : t_Difference) (visited : Seq.seq t_T) (o : t_Difference)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines : [%#shash_set] forall self : t_Difference . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self : t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start : t_Difference) (visited : Seq.seq t_T) (end' : t_Difference)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self : t_Difference) (visited : Seq.seq t_T) (o : t_Difference)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines : [%#shash_set] forall a : t_Difference . forall ab : Seq.seq t_T . forall b : t_Difference . forall bc : Seq.seq t_T . forall c : t_Difference . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans__refines [#"../../creusot-contracts/src/std/deque.rs" 182 4 182 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 182 4 182 90
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 168 12 168 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 81 14 81 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 80
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'1] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'2] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 83 4 83 35] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec : forall self : Slice64.slice t_T . ([%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'0] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 152 4 152 33] (self : t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 166 4 166 65] (self : t_Iter'0) (visited : Seq.seq t_T) (tl : t_Iter'0)
  
   =
    [%#sdeque'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  goal refines : [%#sdeque] forall a : t_Iter'0 . forall ab : Seq.seq t_T . forall b : t_Iter'0 . forall bc : Seq.seq t_T . forall c : t_Iter'0 . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl__refines [#"../../creusot-contracts/src/std/deque.rs" 175 4 175 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 175 4 175 26
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 168 12 168 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 81 14 81 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 80
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'1] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'2] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 83 4 83 35] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec : forall self : Slice64.slice t_T . ([%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'0] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 152 4 152 33] (self : t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 166 4 166 65] (self : t_Iter'0) (visited : Seq.seq t_T) (tl : t_Iter'0)
  
   =
    [%#sdeque'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  goal refines : [%#sdeque] forall self : t_Iter'0 . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 63 4 63 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 63 4 63 90
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_T) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_T) (b : t_I) (bc : Seq.seq t_T) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_T, b : t_I, bc : Seq.seq t_T, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Cloned)
  
  axiom inv_axiom [@rewrite] : forall x : t_Cloned [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned) : t_I
  
  axiom iter_spec : forall self : t_Cloned . [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned) (visited : Seq.seq t_T) (o : t_Cloned)
  
   =
    [%#scloned'0] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scloned] forall a : t_Cloned . forall ab : Seq.seq t_T . forall b : t_Cloned . forall bc : Seq.seq t_T . forall c : t_Cloned . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 57 4 57 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 57 4 57 26
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_T) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_T) (b : t_I) (bc : Seq.seq t_T) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_T, b : t_I, bc : Seq.seq t_T, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Cloned)
  
  axiom inv_axiom [@rewrite] : forall x : t_Cloned [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned) : t_I
  
  axiom iter_spec : forall self : t_Cloned . [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned) (visited : Seq.seq t_T) (o : t_Cloned)
  
   =
    [%#scloned'0] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scloned] forall self : t_Cloned . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T) self
   -> produces'0 self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 57 4 57 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 57 4 57 26
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_T) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_T) (b : t_I) (bc : Seq.seq t_T) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_T, b : t_I, bc : Seq.seq t_T, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Copied)
  
  axiom inv_axiom [@rewrite] : forall x : t_Copied [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied) : t_I
  
  axiom iter_spec : forall self : t_Copied . [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied) (visited : Seq.seq t_T) (o : t_Copied)
  
   =
    [%#scopied'0] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scopied] forall self : t_Copied . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T) self
   -> produces'0 self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 63 4 63 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 63 4 63 90
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_T) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_T) (b : t_I) (bc : Seq.seq t_T) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_T, b : t_I, bc : Seq.seq t_T, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Copied)
  
  axiom inv_axiom [@rewrite] : forall x : t_Copied [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied) : t_I
  
  axiom iter_spec : forall self : t_Copied . [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied) (visited : Seq.seq t_T) (o : t_Copied)
  
   =
    [%#scopied'0] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scopied] forall a : t_Copied . forall ab : Seq.seq t_T . forall b : t_Copied . forall bc : Seq.seq t_T . forall c : t_Copied . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty) (visited : Seq.seq t_T) (o : t_Empty)
  
   =
    [%#sempty'0] visited = (Seq.empty : Seq.seq t_T) /\ self = o
  
  goal refines : [%#sempty] forall self : t_Empty . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty) (visited : Seq.seq t_T) (o : t_Empty)
  
   =
    [%#sempty'0] visited = (Seq.empty : Seq.seq t_T) /\ self = o
  
  goal refines : [%#sempty] forall a : t_Empty . forall ab : Seq.seq t_T . forall b : t_Empty . forall bc : Seq.seq t_T . forall c : t_Empty . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 87 4 87 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 87 4 87 90
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 71 12 75 113
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 44 12 48 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate) : t_I
  
  axiom iter_spec : forall self : t_Enumerate . [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 42 4 42 30] (self : t_Enumerate) =
    [%#senumerate'2] (forall s : Seq.seq t_Item, i : t_I [produces (iter self) s i] . produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i : MutBorrow.t t_I . completed i  -> produces i.current (Seq.empty : Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite] : forall x : t_Enumerate [inv'0 x] . inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 69 4 69 64] (self : t_Enumerate) (visited : Seq.seq tuple) (o : t_Enumerate)
  
   =
    [%#senumerate'0] Seq.length visited = n o - n self
    /\ (exists s : Seq.seq t_Item . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  goal refines : [%#senumerate] forall a : t_Enumerate . forall ab : Seq.seq tuple . forall b : t_Enumerate . forall bc : Seq.seq tuple . forall c : t_Enumerate . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 81 4 81 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 81 4 81 26
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 71 12 75 113
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 44 12 48 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate) : t_I
  
  axiom iter_spec : forall self : t_Enumerate . [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 42 4 42 30] (self : t_Enumerate) =
    [%#senumerate'2] (forall s : Seq.seq t_Item, i : t_I [produces (iter self) s i] . produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i : MutBorrow.t t_I . completed i  -> produces i.current (Seq.empty : Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite] : forall x : t_Enumerate [inv'0 x] . inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 69 4 69 64] (self : t_Enumerate) (visited : Seq.seq tuple) (o : t_Enumerate)
  
   =
    [%#senumerate'0] Seq.length visited = n o - n self
    /\ (exists s : Seq.seq t_Item . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  goal refines : [%#senumerate] forall self : t_Enumerate . forall result : () . produces'0 self (Seq.empty : Seq.seq tuple) self
   -> produces'0 self (Seq.empty : Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 143
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 124
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : bool) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : bool . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : bool . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self : t_Filter) =
    [%#sfilter'1] forall f : t_F, i : t_Item . precondition f i
    /\ (forall f'0 : t_F, g : t_F . hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1 : t_F, f2 : t_F, i'0 : t_Item . not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Filter)
  
  axiom inv_axiom [@rewrite] : forall x : t_Filter [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter) : t_F
  
  axiom func_spec : forall self : t_Filter . [%#sfilter'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter) : t_I
  
  axiom iter_spec : forall self : t_Filter . [%#sfilter'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self : t_Filter) (visited : Seq.seq t_Item) (succ : t_Filter)
  
   =
    [%#sfilter'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s : Seq.seq t_Item, f : Map.map int int . produces (iter self) s (iter succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  goal refines : [%#sfilter] forall self : t_Filter . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 143
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 124
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : bool) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : bool . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : bool . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self : t_Filter) =
    [%#sfilter'1] forall f : t_F, i : t_Item . precondition f i
    /\ (forall f'0 : t_F, g : t_F . hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1 : t_F, f2 : t_F, i'0 : t_Item . not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Filter)
  
  axiom inv_axiom [@rewrite] : forall x : t_Filter [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter) : t_F
  
  axiom func_spec : forall self : t_Filter . [%#sfilter'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter) : t_I
  
  axiom iter_spec : forall self : t_Filter . [%#sfilter'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self : t_Filter) (visited : Seq.seq t_Item) (succ : t_Filter)
  
   =
    [%#sfilter'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s : Seq.seq t_Item, f : Map.map int int . produces (iter self) s (iter succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  goal refines : [%#sfilter] forall a : t_Filter . forall ab : Seq.seq t_Item . forall b : t_Filter . forall bc : Seq.seq t_Item . forall c : t_Filter . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 148
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 50
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 54
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 135
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f : t_F) =
    [%#sfilter_map'4] forall i : t_Item . precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : t_Option) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : t_Option . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : t_Option . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f : t_F) =
    [%#sfilter_map'5] forall g : t_F . hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1 : t_F) =
    [%#sfilter_map'6] forall f2 : t_F, i : t_Item . not ((exists b : t_B . postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap) : t_F
  
  axiom func_spec : forall self : t_FilterMap . [%#sfilter_map'2] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self : t_FilterMap) =
    [%#sfilter_map'1] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite] : forall x : t_FilterMap [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap) : t_I
  
  axiom iter_spec : forall self : t_FilterMap . [%#sfilter_map'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self : t_FilterMap) (visited : Seq.seq t_B) (succ : t_FilterMap)
  
   =
    [%#sfilter_map'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s : Seq.seq t_Item, f : Map.map int int . produces (iter self) s (iter succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  goal refines : [%#sfilter_map] forall self : t_FilterMap . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B) self
   -> produces'0 self (Seq.empty : Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 148
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 50
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 54
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 135
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f : t_F) =
    [%#sfilter_map'4] forall i : t_Item . precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : t_Option) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : t_Option . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : t_Option . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f : t_F) =
    [%#sfilter_map'5] forall g : t_F . hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1 : t_F) =
    [%#sfilter_map'6] forall f2 : t_F, i : t_Item . not ((exists b : t_B . postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap) : t_F
  
  axiom func_spec : forall self : t_FilterMap . [%#sfilter_map'2] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self : t_FilterMap) =
    [%#sfilter_map'1] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite] : forall x : t_FilterMap [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap) : t_I
  
  axiom iter_spec : forall self : t_FilterMap . [%#sfilter_map'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self : t_FilterMap) (visited : Seq.seq t_B) (succ : t_FilterMap)
  
   =
    [%#sfilter_map'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s : Seq.seq t_Item, f : Map.map int int . produces (iter self) s (iter succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  goal refines : [%#sfilter_map] forall a : t_FilterMap . forall ab : Seq.seq t_B . forall b : t_FilterMap . forall bc : Seq.seq t_B . forall c : t_FilterMap . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Fuse)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse [inv'1 x] . inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse) : t_Option
  
  axiom view_spec : forall self : t_Fuse . ([%#sfuse'1] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'2] forall other : t_Fuse . view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse) (prod : Seq.seq t_Item) (other : t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty : Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  goal refines : [%#sfuse] forall a : t_Fuse . forall ab : Seq.seq t_Item . forall b : t_Fuse . forall bc : Seq.seq t_Item . forall c : t_Fuse . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Fuse)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse [inv'1 x] . inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse) : t_Option
  
  axiom view_spec : forall self : t_Fuse . ([%#sfuse'1] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'2] forall other : t_Fuse . view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse) (prod : Seq.seq t_Item) (other : t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty : Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  goal refines : [%#sfuse] forall self : t_Fuse . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map.rs" 79 4 79 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 79 4 79 26
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 62 12 73 75
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Map)
  
  axiom inv_axiom [@rewrite] : forall x : t_Map [inv'1 x] . inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map) : t_F
  
  axiom func_spec : forall self : t_Map . [%#smap'1] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map) : t_I
  
  axiom iter_spec : forall self : t_Map . [%#smap'2] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 60 4 60 67] (self : t_Map) (visited : Seq.seq t_B) (succ : t_Map)
  
   =
    [%#smap'0] hist_inv (func self) (func succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item [produces (iter self) s (iter succ)] . Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap] forall self : t_Map . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B) self
   -> produces'0 self (Seq.empty : Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map.rs" 85 4 85 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 85 4 85 90
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 62 12 73 75
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Item) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Item) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : t_Item) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : t_Item, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : t_Item) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : t_Item, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Map)
  
  axiom inv_axiom [@rewrite] : forall x : t_Map [inv'1 x] . inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map) : t_F
  
  axiom func_spec : forall self : t_Map . [%#smap'1] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map) : t_I
  
  axiom iter_spec : forall self : t_Map . [%#smap'2] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 60 4 60 67] (self : t_Map) (visited : Seq.seq t_B) (succ : t_Map)
  
   =
    [%#smap'0] hist_inv (func self) (func succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item [produces (iter self) s (iter succ)] . Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap] forall a : t_Map . forall ab : Seq.seq t_B . forall b : t_Map . forall bc : Seq.seq t_B . forall c : t_Map . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 23 4 23 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 4 23 26
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 35 8 47 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : tuple) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : tuple) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : tuple) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : tuple, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : tuple) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : tuple, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 34 4 34 67] (self : t_MapInv) (visited : Seq.seq t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'0] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item . Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap_inv] forall self : t_MapInv . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B) self
   -> produces'0 self (Seq.empty : Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 29 4 29 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 4 29 90
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 35 8 47 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : tuple) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : tuple) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : tuple) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : tuple, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : tuple) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : tuple, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 34 4 34 67] (self : t_MapInv) (visited : Seq.seq t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'0] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item . Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap_inv] forall a : t_MapInv . forall ab : Seq.seq t_B . forall b : t_MapInv . forall bc : Seq.seq t_B . forall c : t_MapInv . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans__refines [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once) (visited : Seq.seq t_T) (o : t_Once)
  
   =
    [%#sonce'0] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines : [%#sonce] forall a : t_Once . forall ab : Seq.seq t_T . forall b : t_Once . forall bc : Seq.seq t_T . forall c : t_Once . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl__refines [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once) (visited : Seq.seq t_T) (o : t_Once)
  
   =
    [%#sonce'0] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines : [%#sonce] forall self : t_Once . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range) (visited : Seq.seq t_Idx) (o : t_Range)
  
   =
    [%#srange'0] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  goal refines : [%#srange] forall self : t_Range . forall result : () . produces self (Seq.empty : Seq.seq t_Idx) self
   -> produces self (Seq.empty : Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range) (visited : Seq.seq t_Idx) (o : t_Range)
  
   =
    [%#srange'0] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  goal refines : [%#srange] forall a : t_Range . forall ab : Seq.seq t_Idx . forall b : t_Range . forall bc : Seq.seq t_Idx . forall c : t_Range . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r : t_RangeInclusive) : int
  
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec : forall r : t_RangeInclusive . [%#srange'1] is_empty_log r
  = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self : t_RangeInclusive) (visited : Seq.seq t_Idx) (o : t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  goal refines : [%#srange] forall a : t_RangeInclusive . forall ab : Seq.seq t_Idx . forall b : t_RangeInclusive . forall bc : Seq.seq t_Idx . forall c : t_RangeInclusive . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r : t_RangeInclusive) : int
  
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec : forall r : t_RangeInclusive . [%#srange'1] is_empty_log r
  = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self : t_RangeInclusive) (visited : Seq.seq t_Idx) (o : t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  goal refines : [%#srange] forall self : t_RangeInclusive . forall result : () . produces self (Seq.empty : Seq.seq t_Idx) self
   -> produces self (Seq.empty : Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat) (visited : Seq.seq t_T) (o : t_Repeat)
  
   =
    [%#srepeat'0] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view self)
  
  goal refines : [%#srepeat] forall self : t_Repeat . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat) (visited : Seq.seq t_T) (o : t_Repeat)
  
   =
    [%#srepeat'0] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view self)
  
  goal refines : [%#srepeat] forall a : t_Repeat . forall ab : Seq.seq t_T . forall b : t_Repeat . forall bc : Seq.seq t_T . forall c : t_Repeat . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 78 14 78 50
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 82 15 82 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 83 15 83 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 84 14 84 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 75 4 75 70] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 85 4 85 96] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_back_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 79 4 79 32] (self : t_I) : ()
  
  axiom produces_back_refl_spec : forall self : t_I . [%#siter] produces_back self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rev)
  
  axiom inv_axiom [@rewrite] : forall x : t_Rev [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev) : t_I
  
  axiom iter_spec : forall self : t_Rev . [%#srev'1] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev) (visited : Seq.seq t_Item) (o : t_Rev)
  
   =
    [%#srev'0] produces_back (iter self) visited (iter o)
  
  goal refines : [%#srev] forall self : t_Rev . forall result : () . produces self (Seq.empty : Seq.seq t_Item) self
   -> produces self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 78 14 78 50
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 82 15 82 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 83 15 83 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 84 14 84 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 75 4 75 70] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 85 4 85 96] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_back_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 79 4 79 32] (self : t_I) : ()
  
  axiom produces_back_refl_spec : forall self : t_I . [%#siter] produces_back self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Rev)
  
  axiom inv_axiom [@rewrite] : forall x : t_Rev [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev) : t_I
  
  axiom iter_spec : forall self : t_Rev . [%#srev'1] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev) (visited : Seq.seq t_Item) (o : t_Rev)
  
   =
    [%#srev'0] produces_back (iter self) visited (iter o)
  
  goal refines : [%#srev] forall a : t_Rev . forall ab : Seq.seq t_Item . forall b : t_Rev . forall bc : Seq.seq t_Item . forall c : t_Rev . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 79 4 79 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 79 4 79 90
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip) : int
  
  axiom n_spec : forall self : t_Skip . [%#sskip'1] n self >= 0 /\ n self <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Skip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Skip [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip) : t_I
  
  axiom iter_spec : forall self : t_Skip . [%#sskip'2] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip) (visited : Seq.seq t_Item) (o : t_Skip)
  
   =
    [%#sskip'0] visited = (Seq.empty : Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item . Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  goal refines : [%#sskip] forall a : t_Skip . forall ab : Seq.seq t_Item . forall b : t_Skip . forall bc : Seq.seq t_Item . forall c : t_Skip . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 73 4 73 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 73 4 73 26
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip) : int
  
  axiom n_spec : forall self : t_Skip . [%#sskip'1] n self >= 0 /\ n self <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Skip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Skip [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip) : t_I
  
  axiom iter_spec : forall self : t_Skip . [%#sskip'2] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip) (visited : Seq.seq t_Item) (o : t_Skip)
  
   =
    [%#sskip'0] visited = (Seq.empty : Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item . Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  goal refines : [%#sskip] forall self : t_Skip . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl__refines [#"../../creusot-contracts/src/std/iter/take.rs" 71 4 71 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 71 4 71 26
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take) : int
  
  axiom n_spec : forall self : t_Take . [%#stake'1] n self >= 0 /\ n self <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Take)
  
  axiom inv_axiom [@rewrite] : forall x : t_Take [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take) : t_I
  
  axiom iter_spec : forall self : t_Take . [%#stake'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take) (visited : Seq.seq t_Item) (o : t_Take)
  
   =
    [%#stake'0] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  goal refines : [%#stake] forall self : t_Take . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans__refines [#"../../creusot-contracts/src/std/iter/take.rs" 77 4 77 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 77 4 77 90
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take) : int
  
  axiom n_spec : forall self : t_Take . [%#stake'1] n self >= 0 /\ n self <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Take)
  
  axiom inv_axiom [@rewrite] : forall x : t_Take [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take) : t_I
  
  axiom iter_spec : forall self : t_Take . [%#stake'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take) (visited : Seq.seq t_Item) (o : t_Take)
  
   =
    [%#stake'0] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  goal refines : [%#stake] forall a : t_Take . forall ab : Seq.seq t_Item . forall b : t_Take . forall bc : Seq.seq t_Item . forall c : t_Take . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A) (visited : Seq.seq t_Item) (o : t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A) (ab : Seq.seq t_Item) (b : t_A) (bc : Seq.seq t_Item) (c : t_A) : ()
  
  
  axiom produces_trans_spec : forall a : t_A, ab : Seq.seq t_Item, b : t_A, bc : Seq.seq t_Item, c : t_A . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A) : ()
  
  axiom produces_refl_spec : forall self : t_A . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Zip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Zip [inv'1 x] . inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip) : t_A
  
  axiom itera_spec : forall self : t_Zip . [%#szip'1] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B) (visited : Seq.seq t_Item'0) (o : t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B) (ab : Seq.seq t_Item'0) (b : t_B) (bc : Seq.seq t_Item'0) (c : t_B) : ()
  
  
  axiom produces_trans_spec'0 : forall a : t_B, ab : Seq.seq t_Item'0, b : t_B, bc : Seq.seq t_Item'0, c : t_B . ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B) : ()
  
  axiom produces_refl_spec'0 : forall self : t_B . [%#siter] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip) : t_B
  
  axiom iterb_spec : forall self : t_Zip . [%#szip'2] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip) (visited : Seq.seq tuple) (o : t_Zip)
  
   =
    [%#szip'0] exists p1 : Seq.seq t_Item, p2 : Seq.seq t_Item'0 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  goal refines : [%#szip] forall a : t_Zip . forall ab : Seq.seq tuple . forall b : t_Zip . forall bc : Seq.seq tuple . forall c : t_Zip . produces'1 b bc c
  /\ produces'1 a ab b
   -> produces'1 b bc c
  /\ produces'1 a ab b /\ (forall result : () . produces'1 a (Seq.(++) ab bc) c  -> produces'1 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A) (visited : Seq.seq t_Item) (o : t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A) (ab : Seq.seq t_Item) (b : t_A) (bc : Seq.seq t_Item) (c : t_A) : ()
  
  
  axiom produces_trans_spec : forall a : t_A, ab : Seq.seq t_Item, b : t_A, bc : Seq.seq t_Item, c : t_A . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A) : ()
  
  axiom produces_refl_spec : forall self : t_A . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Zip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Zip [inv'1 x] . inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip) : t_A
  
  axiom itera_spec : forall self : t_Zip . [%#szip'1] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B) (visited : Seq.seq t_Item'0) (o : t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B) (ab : Seq.seq t_Item'0) (b : t_B) (bc : Seq.seq t_Item'0) (c : t_B) : ()
  
  
  axiom produces_trans_spec'0 : forall a : t_B, ab : Seq.seq t_Item'0, b : t_B, bc : Seq.seq t_Item'0, c : t_B . ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B) : ()
  
  axiom produces_refl_spec'0 : forall self : t_B . [%#siter] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip) : t_B
  
  axiom iterb_spec : forall self : t_Zip . [%#szip'2] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip) (visited : Seq.seq tuple) (o : t_Zip)
  
   =
    [%#szip'0] exists p1 : Seq.seq t_Item, p2 : Seq.seq t_Item'0 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  goal refines : [%#szip] forall self : t_Zip . forall result : () . produces'1 self (Seq.empty : Seq.seq tuple) self
   -> produces'1 self (Seq.empty : Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl__refines [#"../../creusot-contracts/src/std/iter.rs" 231 4 231 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 231 4 231 26
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 219 20 219 64
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'2] produces a ab b)
   -> ([%#siter'3] produces b bc c)  -> ([%#siter'4] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter'1] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 218 4 218 64] (self : MutBorrow.t t_I) (visited : Seq.seq t_Item) (o : MutBorrow.t t_I)
  
   =
    [%#siter'0] produces self.current visited o.current /\ self.final = o.final
  
  goal refines : [%#siter] forall self : MutBorrow.t t_I . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans__refines [#"../../creusot-contracts/src/std/iter.rs" 238 4 238 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 238 4 238 90
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 219 20 219 64
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'2] produces a ab b)
   -> ([%#siter'3] produces b bc c)  -> ([%#siter'4] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter'1] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 218 4 218 64] (self : MutBorrow.t t_I) (visited : Seq.seq t_Item) (o : MutBorrow.t t_I)
  
   =
    [%#siter'0] produces self.current visited o.current /\ self.final = o.final
  
  goal refines : [%#siter] forall a : MutBorrow.t t_I . forall ab : Seq.seq t_Item . forall b : MutBorrow.t t_I . forall bc : Seq.seq t_Item . forall c : MutBorrow.t t_I . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 629 4 629 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 629 4 629 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 622 12 623 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 606 4 606 30] (self : t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 620 4 620 64] (self : t_IntoIter) (visited : Seq.seq t_T) (o : t_IntoIter)
  
   =
    [%#soption'0] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines : [%#soption] forall self : t_IntoIter . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 635 4 635 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 635 4 635 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 622 12 623 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 606 4 606 30] (self : t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 620 4 620 64] (self : t_IntoIter) (visited : Seq.seq t_T) (o : t_IntoIter)
  
   =
    [%#soption'0] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines : [%#soption] forall a : t_IntoIter . forall ab : Seq.seq t_T . forall b : t_IntoIter . forall bc : Seq.seq t_T . forall c : t_IntoIter . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 672 4 672 90] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 672 4 672 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 659 12 660 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 643 4 643 34] (self : t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 657 4 657 64] (self : t_Iter) (visited : Seq.seq t_T) (o : t_Iter)
  
   =
    [%#soption'0] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines : [%#soption] forall a : t_Iter . forall ab : Seq.seq t_T . forall b : t_Iter . forall bc : Seq.seq t_T . forall c : t_Iter . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 666 4 666 26] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 666 4 666 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 659 12 660 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 643 4 643 34] (self : t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 657 4 657 64] (self : t_Iter) (visited : Seq.seq t_T) (o : t_Iter)
  
   =
    [%#soption'0] visited = (Seq.empty : Seq.seq t_T) /\ self = o
    \/ (exists e : t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines : [%#soption] forall self : t_Iter . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 703 4 703 26] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 703 4 703 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 696 12 697 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 680 4 680 38] (self : t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 694 4 694 64] (self : t_IterMut) (visited : Seq.seq (MutBorrow.t t_T)) (o : t_IterMut)
  
   =
    [%#soption'0] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e : MutBorrow.t t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines : [%#soption] forall self : t_IterMut . forall result : () . produces self (Seq.empty : Seq.seq (MutBorrow.t t_T)) self
   -> produces self (Seq.empty : Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 709 4 709 90] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 709 4 709 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 696 12 697 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 680 4 680 38] (self : t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 694 4 694 64] (self : t_IterMut) (visited : Seq.seq (MutBorrow.t t_T)) (o : t_IterMut)
  
   =
    [%#soption'0] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e : MutBorrow.t t_T . view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines : [%#soption] forall a : t_IterMut . forall ab : Seq.seq (MutBorrow.t t_T) . forall b : t_IterMut . forall bc : Seq.seq (MutBorrow.t t_T) . forall c : t_IterMut . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 426 4 426 90
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 412 12 412 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 81 14 81 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 80
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'3] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'4] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 83 4 83 35] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec : forall self : Slice64.slice t_T . ([%#sslice'1] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'2] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 396 4 396 33] (self : t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 410 4 410 65] (self : t_Iter) (visited : Seq.seq t_T) (tl : t_Iter)
  
   =
    [%#sslice'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  goal refines : [%#sslice] forall a : t_Iter . forall ab : Seq.seq t_T . forall b : t_Iter . forall bc : Seq.seq t_T . forall c : t_Iter . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 419 4 419 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 419 4 419 26
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 412 12 412 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 81 14 81 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 80
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'3] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'4] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 83 4 83 35] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec : forall self : Slice64.slice t_T . ([%#sslice'1] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'2] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 396 4 396 33] (self : t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 410 4 410 65] (self : t_Iter) (visited : Seq.seq t_T) (tl : t_Iter)
  
   =
    [%#sslice'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  goal refines : [%#sslice] forall self : t_Iter . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 479 4 479 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 479 4 479 90
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 465 12 465 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 72 14 72 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 73 14 73 84
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 434 14 434 50
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'4] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'5] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 75 4 75 43] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec : forall self : MutBorrow.t (Slice64.slice t_T) . ([%#sslice'1] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'2] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 435 4 435 33] (self : t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0 : forall self : t_IterMut . [%#sslice'3] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 463 4 463 65] (self : t_IterMut) (visited : Seq.seq (MutBorrow.t t_T)) (tl : t_IterMut)
  
   =
    [%#sslice'0] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  goal refines : [%#sslice] forall a : t_IterMut . forall ab : Seq.seq (MutBorrow.t t_T) . forall b : t_IterMut . forall bc : Seq.seq (MutBorrow.t t_T) . forall c : t_IterMut . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 472 4 472 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 472 4 472 26
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 465 12 465 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 72 14 72 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 73 14 73 84
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 434 14 434 50
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'4] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'5] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 75 4 75 43] (self : MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec : forall self : MutBorrow.t (Slice64.slice t_T) . ([%#sslice'1] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'2] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 435 4 435 33] (self : t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0 : forall self : t_IterMut . [%#sslice'3] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 463 4 463 65] (self : t_IterMut) (visited : Seq.seq (MutBorrow.t t_T)) (tl : t_IterMut)
  
   =
    [%#sslice'0] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  goal refines : [%#sslice] forall self : t_IterMut . forall result : () . produces self (Seq.empty : Seq.seq (MutBorrow.t t_T)) self
   -> produces self (Seq.empty : Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans__refines [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 256 4 256 72
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 242 12 242 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 210 4 210 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 240 4 240 57] (self : t_IntoIter) (visited : Seq.seq t_T) (rhs : t_IntoIter)
  
   =
    [%#svec'0] view self = Seq.(++) visited (view rhs)
  
  goal refines : [%#svec] forall a : t_IntoIter . forall ab : Seq.seq t_T . forall b : t_IntoIter . forall bc : Seq.seq t_T . forall c : t_IntoIter . produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result : () . produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl__refines [#"../../creusot-contracts/src/std/vec.rs" 249 4 249 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 249 4 249 26
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 242 12 242 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 210 4 210 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 240 4 240 57] (self : t_IntoIter) (visited : Seq.seq t_T) (rhs : t_IntoIter)
  
   =
    [%#svec'0] view self = Seq.(++) visited (view rhs)
  
  goal refines : [%#svec] forall self : t_IntoIter . forall result : () . produces self (Seq.empty : Seq.seq t_T) self
   -> produces self (Seq.empty : Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 161 4 161 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Reverse) (o : t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Less
  
  goal refines : [%#scmp] forall x : t_Reverse . forall y : t_Reverse . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1__refines [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 189 4 189 33
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines : [%#scmp] forall x : t_Reverse . forall y : t_Reverse . cmp_log'0 x y = C_Less
   -> cmp_log'0 x y = C_Less /\ (forall result : () . cmp_log'0 y x = C_Greater  -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp__refines [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 200 4 200 31
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines : [%#scmp] forall x : t_Reverse . forall y : t_Reverse . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal)  -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl__refines [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 176 4 176 20
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines : [%#scmp] forall x : t_Reverse . forall result : () . cmp_log'0 x x = C_Equal
   -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans__refines [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 183 4 183 52
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines : [%#scmp] forall x : t_Reverse . forall y : t_Reverse . forall z : t_Reverse . forall o : t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2__refines [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 195 4 195 33
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines : [%#scmp] forall x : t_Reverse . forall y : t_Reverse . cmp_log'0 x y = C_Greater
   -> cmp_log'0 x y = C_Greater /\ (forall result : () . cmp_log'0 y x = C_Less  -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 156 4 156 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Reverse) (o : t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Greater
  
  goal refines : [%#scmp] forall x : t_Reverse . forall y : t_Reverse . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 166 4 166 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Reverse) (o : t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Less
  
  goal refines : [%#scmp] forall x : t_Reverse . forall y : t_Reverse . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 171 4 171 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse) (o : t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Reverse) (o : t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Greater
  
  goal refines : [%#scmp] forall x : t_Reverse . forall y : t_Reverse . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines : [%#sord] forall x : t_Option . forall y : t_Option . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal)  -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Option) (o : t_Option) =
    [%#sord'0] cmp_log'0 self o = C_Less
  
  goal refines : [%#sord] forall x : t_Option . forall y : t_Option . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines : [%#sord] forall x : t_Option . forall y : t_Option . cmp_log'0 x y = C_Less
   -> cmp_log'0 x y = C_Less /\ (forall result : () . cmp_log'0 y x = C_Greater  -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Option) (o : t_Option) =
    [%#sord'0] cmp_log'0 self o <> C_Less
  
  goal refines : [%#sord] forall x : t_Option . forall y : t_Option . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Option) (o : t_Option) =
    [%#sord'0] cmp_log'0 self o = C_Greater
  
  goal refines : [%#sord] forall x : t_Option . forall y : t_Option . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines : [%#sord] forall x : t_Option . forall y : t_Option . forall z : t_Option . forall o : t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines : [%#sord] forall x : t_Option . forall result : () . cmp_log'0 x x = C_Equal  -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Option) (o : t_Option) =
    [%#sord'0] cmp_log'0 self o <> C_Greater
  
  goal refines : [%#sord] forall x : t_Option . forall y : t_Option . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 590 8 595 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T) (other : t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T) (y : t_T) : ()
  
  axiom eq_cmp_spec : forall x : t_T, y : t_T . [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym2_spec : forall x : t_T, y : t_T . ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T) (y : t_T) : ()
  
  axiom antisym1_spec : forall x : t_T, y : t_T . ([%#sord'8] cmp_log x y = C_Less)
   -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T) (y : t_T) (z : t_T) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_T, y : t_T, z : t_T, o : t_Ordering . ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T) : ()
  
  axiom refl_spec : forall x : t_T . [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T) (o : t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_gt_log_spec : forall x : t_T, y : t_T . [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T) (o : t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_ge_log_spec : forall x : t_T, y : t_T . [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T) (o : t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_lt_log_spec : forall x : t_T, y : t_T . [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T) (o : t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T) (y : t_T) : ()
  
  axiom cmp_le_log_spec : forall x : t_T, y : t_T . [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 589 4 589 41] (self : t_Option) (o : t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines : [%#sord] forall x : t_Option . forall y : t_Option . cmp_log'0 x y = C_Greater
   -> cmp_log'0 x y = C_Greater /\ (forall result : () . cmp_log'0 y x = C_Less  -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<=) x y
  = (cmp_log x y <> C_Greater)  -> Real.(<=) x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall y : Real.real . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<) x y
  = (cmp_log x y = C_Less)  -> Real.(<) x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>=) x y
  = (cmp_log x y <> C_Less)  -> Real.(>=) x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>) x y
  = (cmp_log x y = C_Greater)  -> Real.(>) x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall y : Real.real . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall y : Real.real . forall z : Real.real . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall y : Real.real . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Real.real . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall y : int . forall result : () . (x >= y) = (cmp_log x y <> C_Less)
   -> (x >= y) = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall y : int . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall y : int . forall result : () . (x > y) = (cmp_log x y = C_Greater)
   -> (x > y) = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall y : int . forall result : () . (x <= y) = (cmp_log x y <> C_Greater)
   -> (x <= y) = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall y : int . forall result : () . (x < y) = (cmp_log x y = C_Less)
   -> (x < y) = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall y : int . forall result : () . (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall y : int . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : int . forall y : int . forall z : int . forall o : t_Ordering . cmp_log y z = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.ge x y
  = (cmp_log x y <> C_Less)  -> UInt8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.gt x y
  = (cmp_log x y = C_Greater)  -> UInt8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.lt x y
  = (cmp_log x y = C_Less)  -> UInt8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall y : UInt8.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall y : UInt8.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall y : UInt8.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.le x y
  = (cmp_log x y <> C_Greater)  -> UInt8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering
  
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt8.t . forall y : UInt8.t . forall z : UInt8.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall y : UInt16.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.gt x y
  = (cmp_log x y = C_Greater)  -> UInt16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall y : UInt16.t . forall z : UInt16.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall y : UInt16.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.le x y
  = (cmp_log x y <> C_Greater)  -> UInt16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.lt x y
  = (cmp_log x y = C_Less)  -> UInt16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.ge x y
  = (cmp_log x y <> C_Less)  -> UInt16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall y : UInt16.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt16.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall y : UInt32.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.ge x y
  = (cmp_log x y <> C_Less)  -> UInt32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.lt x y
  = (cmp_log x y = C_Less)  -> UInt32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.le x y
  = (cmp_log x y <> C_Greater)  -> UInt32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall y : UInt32.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall y : UInt32.t . forall z : UInt32.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall y : UInt32.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.gt x y
  = (cmp_log x y = C_Greater)  -> UInt32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.gt x y
  = (cmp_log x y = C_Greater)  -> UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall z : UInt64.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.lt x y
  = (cmp_log x y = C_Less)  -> UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ge x y
  = (cmp_log x y <> C_Less)  -> UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.le x y
  = (cmp_log x y <> C_Greater)  -> UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall y : UInt128.t . forall z : UInt128.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall y : UInt128.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall y : UInt128.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.le x y
  = (cmp_log x y <> C_Greater)  -> UInt128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.ge x y
  = (cmp_log x y <> C_Less)  -> UInt128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall y : UInt128.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.gt x y
  = (cmp_log x y = C_Greater)  -> UInt128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.lt x y
  = (cmp_log x y = C_Less)  -> UInt128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.le x y
  = (cmp_log x y <> C_Greater)  -> UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall z : UInt64.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ge x y
  = (cmp_log x y <> C_Less)  -> UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.gt x y
  = (cmp_log x y = C_Greater)  -> UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.lt x y
  = (cmp_log x y = C_Less)  -> UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall y : Int8.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.ge x y
  = (cmp_log x y <> C_Less)  -> Int8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.le x y
  = (cmp_log x y <> C_Greater)  -> Int8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.lt x y
  = (cmp_log x y = C_Less)  -> Int8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.gt x y
  = (cmp_log x y = C_Greater)  -> Int8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall y : Int8.t . forall z : Int8.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall y : Int8.t . forall result : () . (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall y : Int8.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering
   =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int8.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.lt x y
  = (cmp_log x y = C_Less)  -> Int16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.ge x y
  = (cmp_log x y <> C_Less)  -> Int16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall y : Int16.t . forall z : Int16.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall y : Int16.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.gt x y
  = (cmp_log x y = C_Greater)  -> Int16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall y : Int16.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall y : Int16.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering
  
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.le x y
  = (cmp_log x y <> C_Greater)  -> Int16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.ge x y
  = (cmp_log x y <> C_Less)  -> Int32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall y : Int32.t . forall z : Int32.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.le x y
  = (cmp_log x y <> C_Greater)  -> Int32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall y : Int32.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.lt x y
  = (cmp_log x y = C_Less)  -> Int32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall y : Int32.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.gt x y
  = (cmp_log x y = C_Greater)  -> Int32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering
  
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int32.t . forall y : Int32.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.le x y
  = (cmp_log x y <> C_Greater)  -> Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall z : Int64.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.gt x y
  = (cmp_log x y = C_Greater)  -> Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.lt x y
  = (cmp_log x y = C_Less)  -> Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.ge x y
  = (cmp_log x y <> C_Less)  -> Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.lt x y
  = (cmp_log x y = C_Less)  -> Int128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall y : Int128.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall y : Int128.t . forall z : Int128.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall y : Int128.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall y : Int128.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.gt x y
  = (cmp_log x y = C_Greater)  -> Int128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.le x y
  = (cmp_log x y <> C_Greater)  -> Int128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.ge x y
  = (cmp_log x y <> C_Less)  -> Int128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . (x = y)
  = (cmp_log x y = C_Equal)  -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.gt x y
  = (cmp_log x y = C_Greater)  -> Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.ge x y
  = (cmp_log x y <> C_Less)  -> Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.lt x y
  = (cmp_log x y = C_Less)  -> Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.le x y
  = (cmp_log x y <> C_Greater)  -> Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering
  
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Int64.t . forall y : Int64.t . forall z : Int64.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall y : Char.t . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall y : Char.t . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall y : Char.t . forall result : () . Char.ge x y
  = (cmp_log x y <> C_Less)  -> Char.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall y : Char.t . forall result : () . Char.lt x y
  = (cmp_log x y = C_Less)  -> Char.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall y : Char.t . forall z : Char.t . forall o : t_Ordering . cmp_log y z
  = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall y : Char.t . forall result : () . (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall y : Char.t . forall result : () . Char.gt x y
  = (cmp_log x y = C_Greater)  -> Char.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering
   =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : Char.t . forall y : Char.t . forall result : () . Char.le x y
  = (cmp_log x y <> C_Greater)  -> Char.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall y : bool . forall result : () . Bool.le x y
  = (cmp_log x y <> C_Greater)  -> Bool.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall y : bool . cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result : () . cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall y : bool . cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result : () . cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall y : bool . forall result : () . Bool.ge x y = (cmp_log x y <> C_Less)
   -> Bool.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall y : bool . forall result : () . Bool.lt x y = (cmp_log x y = C_Less)
   -> Bool.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall result : () . cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall y : bool . forall z : bool . forall o : t_Ordering . cmp_log y z = o
  /\ cmp_log x y = o
   -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result : () . cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall y : bool . forall result : () . (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines : [%#sord] forall x : bool . forall y : bool . forall result : () . Bool.gt x y
  = (cmp_log x y = C_Greater)  -> Bool.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec : forall x : t_B, y : t_B . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec : forall x : t_B, y : t_B . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec : forall x : t_B, y : t_B . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec : forall x : t_B . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec : forall x : t_B, y : t_B . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec : forall x : t_B, y : t_B . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec : forall x : t_B, y : t_B . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec : forall x : t_B, y : t_B . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_A, y : t_A . [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec'0 : forall x : t_A, y : t_A . ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec'0 : forall x : t_A, y : t_A . ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec'0 : forall x : t_A . [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_A, y : t_A . [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_A, y : t_A . [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self : tuple) (o : tuple) =
    [%#sord'0] self._p0 = o._p0 /\ gt_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall y : tuple . forall result : () . gt_log'1 x y
  = (cmp_log'1 x y = C_Greater)  -> gt_log'1 x y = (cmp_log'1 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec : forall x : t_B, y : t_B . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec : forall x : t_B, y : t_B . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec : forall x : t_B, y : t_B . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec : forall x : t_B . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec : forall x : t_B, y : t_B . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec : forall x : t_B, y : t_B . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec : forall x : t_B, y : t_B . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec : forall x : t_B, y : t_B . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_A, y : t_A . [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec'0 : forall x : t_A, y : t_A . ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec'0 : forall x : t_A, y : t_A . ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec'0 : forall x : t_A . [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_A, y : t_A . [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_A, y : t_A . [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self : tuple) (o : tuple) =
    [%#sord'0] self._p0 = o._p0 /\ ge_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall y : tuple . forall result : () . ge_log'1 x y
  = (cmp_log'1 x y <> C_Less)  -> ge_log'1 x y = (cmp_log'1 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall y : tuple . cmp_log'1 x y = C_Greater
   -> cmp_log'1 x y = C_Greater /\ (forall result : () . cmp_log'1 y x = C_Less  -> cmp_log'1 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall y : tuple . forall result : () . (x = y) = (cmp_log'1 x y = C_Equal)
   -> (x = y) = (cmp_log'1 x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec : forall x : t_B, y : t_B . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec : forall x : t_B, y : t_B . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec : forall x : t_B, y : t_B . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec : forall x : t_B . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec : forall x : t_B, y : t_B . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec : forall x : t_B, y : t_B . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec : forall x : t_B, y : t_B . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec : forall x : t_B, y : t_B . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_A, y : t_A . [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec'0 : forall x : t_A, y : t_A . ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec'0 : forall x : t_A, y : t_A . ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec'0 : forall x : t_A . [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_A, y : t_A . [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_A, y : t_A . [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self : tuple) (o : tuple) =
    [%#sord'0] self._p0 = o._p0 /\ le_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall y : tuple . forall result : () . le_log'1 x y
  = (cmp_log'1 x y <> C_Greater)  -> le_log'1 x y = (cmp_log'1 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall result : () . cmp_log'1 x x = C_Equal  -> cmp_log'1 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall y : tuple . forall z : tuple . forall o : t_Ordering . cmp_log'1 y z
  = o
  /\ cmp_log'1 x y = o
   -> cmp_log'1 y z = o /\ cmp_log'1 x y = o /\ (forall result : () . cmp_log'1 x z = o  -> cmp_log'1 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec : forall x : t_B, y : t_B . [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec : forall x : t_B, y : t_B . ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec : forall x : t_B, y : t_B . ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec : forall x : t_B . [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec : forall x : t_B, y : t_B . [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec : forall x : t_B, y : t_B . [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec : forall x : t_B, y : t_B . [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec : forall x : t_B, y : t_B . [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_A, y : t_A . [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec'0 : forall x : t_A, y : t_A . ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec'0 : forall x : t_A, y : t_A . ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec'0 : forall x : t_A . [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_A, y : t_A . [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_A, y : t_A . [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_A, y : t_A . [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self : tuple) (o : tuple) =
    [%#sord'0] self._p0 = o._p0 /\ lt_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall y : tuple . forall result : () . lt_log'1 x y
  = (cmp_log'1 x y = C_Less)  -> lt_log'1 x y = (cmp_log'1 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A) (other : t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A) (y : t_A) : ()
  
  axiom eq_cmp_spec : forall x : t_A, y : t_A . [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym2_spec : forall x : t_A, y : t_A . ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A) (y : t_A) : ()
  
  axiom antisym1_spec : forall x : t_A, y : t_A . ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A) (y : t_A) (z : t_A) (o : t_Ordering) : ()
  
  
  axiom trans_spec : forall x : t_A, y : t_A, z : t_A, o : t_Ordering . ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A) : ()
  
  axiom refl_spec : forall x : t_A . [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A) (o : t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_gt_log_spec : forall x : t_A, y : t_A . [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A) (o : t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_ge_log_spec : forall x : t_A, y : t_A . [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A) (o : t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_lt_log_spec : forall x : t_A, y : t_A . [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A) (o : t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A) (y : t_A) : ()
  
  axiom cmp_le_log_spec : forall x : t_A, y : t_A . [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B) (other : t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B) (y : t_B) : ()
  
  axiom eq_cmp_spec'0 : forall x : t_B, y : t_B . [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym2_spec'0 : forall x : t_B, y : t_B . ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B) (y : t_B) : ()
  
  axiom antisym1_spec'0 : forall x : t_B, y : t_B . ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B) (y : t_B) (z : t_B) (o : t_Ordering) : ()
  
  
  axiom trans_spec'0 : forall x : t_B, y : t_B, z : t_B, o : t_Ordering . ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B) : ()
  
  axiom refl_spec'0 : forall x : t_B . [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B) (o : t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B) (o : t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : t_B, y : t_B . [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B) (o : t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : t_B, y : t_B . [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B) (o : t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B) (y : t_B) : ()
  
  axiom cmp_le_log_spec'0 : forall x : t_B, y : t_B . [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple) (o : tuple) : t_Ordering
   =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines : [%#sord] forall x : tuple . forall y : tuple . cmp_log'1 x y = C_Less
   -> cmp_log'1 x y = C_Less /\ (forall result : () . cmp_log'1 y x = C_Greater  -> cmp_log'1 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__deque__qyi15330951746891243504__resolve_coherence__refines [#"../../creusot-contracts/src/std/deque.rs" 71 4 71 31] (* <std::collections::VecDeque<T> as resolve::Resolve> *)
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 71 4 71 31
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 64 20 64 83
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 16 14 16 41
  let%span sdeque'2 = "../../creusot-contracts/src/std/deque.rs" 44 8 44 31
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_VecDeque  =
    { t_VecDeque__head: UInt64.t; t_VecDeque__len: UInt64.t; t_VecDeque__buf: t_RawVec }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_VecDeque) =
    match _0 with
      | {t_VecDeque__head = x0 ; t_VecDeque__len = x1 ; t_VecDeque__buf = x2} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_VecDeque)
  
  axiom inv_axiom [@rewrite] : forall x : t_VecDeque [inv x] . inv x = true
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/deque.rs" 17 4 17 27] (self : t_VecDeque) : Seq.seq t_T
  
  axiom view_spec : forall self : t_VecDeque . [%#sdeque'1] Seq.length (view self) <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/std/deque.rs" 43 4 43 47] (self : t_VecDeque) (ix : int) : t_T
  
   =
    [%#sdeque'2] Seq.get (view self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/deque.rs" 63 4 63 28] (self : t_VecDeque) =
    [%#sdeque'0] forall i : int . 0 <= i /\ i < Seq.length (view self)  -> resolve (index_logic self i)
  
  goal refines : [%#sdeque] forall self : t_VecDeque . structural_resolve self /\ inv self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi7712864753404203214__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 28 4 28 31] (* <std::iter::Cloned<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 28 4 28 31
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 21 8 21 29
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Cloned) =
    match _0 with
      | {t_Cloned__it = x0} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Cloned)
  
  axiom inv_axiom [@rewrite] : forall x : t_Cloned [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Cloned) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Cloned)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned [inv'1 x] . inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned) : t_I
  
  axiom iter_spec : forall self : t_Cloned . [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 20 4 20 28] (self : t_Cloned) =
    [%#scloned'0] resolve (iter self)
  
  goal refines : [%#scloned] forall self : t_Cloned . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi10817769304312191898__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 28 4 28 31] (* <std::iter::Copied<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 28 4 28 31
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Copied) =
    match _0 with
      | {t_Copied__it = x0} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Copied)
  
  axiom inv_axiom [@rewrite] : forall x : t_Copied [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Copied) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Copied)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied [inv'1 x] . inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied) : t_I
  
  axiom iter_spec : forall self : t_Copied . [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 20 4 20 28] (self : t_Copied) =
    [%#scopied'0] resolve (iter self)
  
  goal refines : [%#scopied] forall self : t_Copied . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi7229971731912667430__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 37 4 37 31] (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 37 4 37 31
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 30 8 30 29
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Enumerate) =
    match _0 with
      | {t_Enumerate__iter = x0 ; t_Enumerate__count = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Enumerate)
  
  axiom inv_axiom : forall x : t_Enumerate [inv'0 x] . inv'0 x
   -> match x with
    | {t_Enumerate__iter = iter ; t_Enumerate__count = count} -> inv iter
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Enumerate) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Enumerate)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate [inv'1 x] . inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate) : t_I
  
  axiom iter_spec : forall self : t_Enumerate . [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 29 4 29 28] (self : t_Enumerate) =
    [%#senumerate'0] resolve (iter self)
  
  goal refines : [%#senumerate] forall self : t_Enumerate . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi7619436869179474426__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map.rs" 39 4 39 31] (* <std::iter::Map<I, F> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 39 4 39 31
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 32 8 32 54
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Map) =
    match _0 with
      | {t_Map__iter = x0 ; t_Map__f = x1} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Map)
  
  axiom inv_axiom [@rewrite] : forall x : t_Map [inv'1 x] . inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Map) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Map)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map [inv'2 x] . inv'2 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map) : t_I
  
  axiom iter_spec : forall self : t_Map . [%#smap'1] inv'1 self  -> inv (iter self)
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map) : t_F
  
  axiom func_spec : forall self : t_Map . [%#smap'2] inv'1 self  -> inv'0 (func self)
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map.rs" 31 4 31 28] (self : t_Map) =
    [%#smap'0] resolve'0 (iter self) /\ resolve (func self)
  
  goal refines : [%#smap] forall self : t_Map . structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result : () . resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 61 4 61 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 61 4 61 31
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 55 8 55 50
  
  use seq.Seq
  
  type t_I
  
  type t_F
  
  type t_B
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_B }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_MapInv) =
    match _0 with
      | {t_MapInv__iter = x0 ; t_MapInv__func = x1 ; t_MapInv__produced = x2} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_MapInv)
  
  axiom inv_axiom : forall x : t_MapInv [inv'1 x] . inv'1 x
   -> match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'0 func
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_MapInv) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_MapInv)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_MapInv [inv'2 x] . inv'2 x = invariant' x
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 54 4 54 28] (self : t_MapInv) =
    [%#smap_inv'0] resolve'0 self.t_MapInv__iter /\ resolve self.t_MapInv__func
  
  goal refines : [%#smap_inv] forall self : t_MapInv . structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result : () . resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi1800235112549046777__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 40 4 40 31] (* <std::iter::Skip<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 40 4 40 31
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 32 12 32 33
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Skip) =
    match _0 with
      | {t_Skip__iter = x0 ; t_Skip__n = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Skip)
  
  axiom inv_axiom [@rewrite] : forall x : t_Skip [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n} -> inv iter
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Skip) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Skip)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip [inv'1 x] . inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip) : t_I
  
  axiom iter_spec : forall self : t_Skip . [%#sskip'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 30 4 30 28] (self : t_Skip) =
    [%#sskip'0] resolve (iter self)
  
  goal refines : [%#sskip] forall self : t_Skip . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi7846602308660485643__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/take.rs" 48 4 48 31] (* <std::iter::Take<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 48 4 48 31
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 41 8 41 29
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Take) =
    match _0 with
      | {t_Take__iter = x0 ; t_Take__n = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Take)
  
  axiom inv_axiom [@rewrite] : forall x : t_Take [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n} -> inv iter
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Take) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Take)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take [inv'1 x] . inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take) : t_I
  
  axiom iter_spec : forall self : t_Take . [%#stake'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/take.rs" 40 4 40 28] (self : t_Take) =
    [%#stake'0] resolve (iter self)
  
  goal refines : [%#stake] forall self : t_Take . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi6798028551487775744__resolve_coherence__refines [#"../../creusot-contracts/src/std/slice.rs" 451 4 451 31] (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 451 4 451 31
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 444 20 444 36
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 434 14 434 50
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_IterMut) =
    match _0 with
      | {t_IterMut__ptr = x0 ; t_IterMut__end_or_len = x1 ; t_IterMut__qy95zmarker = x2} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_IterMut)
  
  axiom inv_axiom [@rewrite] : forall x : t_IterMut [inv x] . inv x = true
  
  type t_T
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec : forall self : Slice64.slice t_T . ([%#sslice'2] Seq.length (view self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'3] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 435 4 435 33] (self : t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0 : forall self : t_IterMut . [%#sslice'1] Seq.length (view (view'0 self).final)
  = Seq.length (view (view'0 self).current)
  
  predicate resolve [#"../../creusot-contracts/src/std/slice.rs" 443 4 443 28] (self : t_IterMut) =
    [%#sslice'0] (view'0 self).current = (view'0 self).final
  
  goal refines : [%#sslice] forall self : t_IterMut . structural_resolve self /\ inv self
   -> structural_resolve self /\ (forall result : () . resolve self  -> resolve self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi16169840827095121464__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 52 4 52 31] (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 673 20 673 95
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 52 4 52 31
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 45 20 45 83
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 20 14 20 41
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 62 20 62 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_A
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: t_A }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Vec) =
    match _0 with
      | {t_Vec__buf = x0 ; t_Vec__len = x1} -> true
      end
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/seq.rs" 672 4 672 30] (self : Seq.seq t_T) =
    [%#sseq] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'0 (Seq.get self i)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 21 4 21 27] (self : t_Vec) : Seq.seq t_T
  
  axiom view_spec : forall self : t_Vec . [%#svec'1] Seq.length (view self) <= UInt64.t'int (v_MAX : UInt64.t)
  
  predicate invariant''1 [#"../../creusot-contracts/src/std/vec.rs" 61 4 61 30] (self : t_Vec) =
    [%#svec'2] inv'1 (view self)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Vec)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec [inv'2 x] . inv'2 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Vec) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Vec)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Vec [inv'3 x] . inv'3 x = invariant''2 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 28 4 28 47] (self : t_Vec) (ix : int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 44 4 44 28] (self : t_Vec) =
    [%#svec'0] forall i : int . 0 <= i /\ i < Seq.length (view self)  -> resolve (index_logic self i)
  
  goal refines : [%#svec] forall self : t_Vec . structural_resolve self /\ inv'3 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9945000909994515642__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 227 4 227 31] (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 227 4 227 31
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 220 20 220 83
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_IntoIter) =
    match _0 with
      | {t_IntoIter__buf = x0 ; t_IntoIter__phantom = x1 ; t_IntoIter__cap = x2 ; t_IntoIter__alloc = x3 ; t_IntoIter__ptr = x4 ; t_IntoIter__end = x5} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_ManuallyDrop)
  
  axiom inv_axiom [@rewrite] : forall x : t_ManuallyDrop [inv'0 x] . inv'0 x
  = match x with
    | {t_ManuallyDrop__value = value} -> inv value
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_IntoIter)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IntoIter [inv'1 x] . inv'1 x
  = match x with
    | {t_IntoIter__buf = buf ; t_IntoIter__phantom = phantom ; t_IntoIter__cap = cap ; t_IntoIter__alloc = alloc ; t_IntoIter__ptr = ptr ; t_IntoIter__end = end'} -> inv'0 alloc
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_IntoIter) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_IntoIter)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter [inv'2 x] . inv'2 x = invariant' x
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 210 4 210 33] (self : t_IntoIter) : Seq.seq t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 219 4 219 28] (self : t_IntoIter) =
    [%#svec'0] forall i : int . 0 <= i /\ i < Seq.length (view self)  -> resolve (Seq.get (view self) i)
  
  goal refines : [%#svec] forall self : t_IntoIter . structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost__qyi8064556118965643473__resolve_coherence__refines [#"../../creusot-contracts/src/ghost.rs" 112 4 112 31] (* <ghost::Ghost<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 112 4 112 31
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 105 8 105 23
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 97 8 97 18
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 :  t_T)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/ghost.rs" 96 4 96 30] (self :  t_T) =
    [%#sghost'1] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 :  t_T)
  
  axiom inv_axiom [@rewrite] : forall x :  t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self :  t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 :  t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x :  t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/ghost.rs" 104 4 104 28] (self :  t_T) =
    [%#sghost'0] resolve self
  
  goal refines : [%#sghost] forall self :  t_T . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__pcell__qyi12897409324816536085__resolve_coherence__refines [#"../../creusot-contracts/src/pcell.rs" 68 4 68 31] (* <pcell::PCellOwn<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 66 8 66 23
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 68 4 68 31
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 60 8 60 28
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_PCellOwn) =
    match _0 with
      | {t_PCellOwn__0 = x0} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_PCellOwn)
  
  axiom inv_axiom : forall x : t_PCellOwn [inv x] . inv x
   -> match x with
    | {t_PCellOwn__0 = a_0} -> true
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_PCellOwn) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_PCellOwn)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_PCellOwn [inv'0 x] . inv'0 x = invariant' x
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 65 4 65 28] (self : t_T) =
    [%#sresolve] resolve self
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T) =
    resolve'0 _0
  
  function val' [#"../../creusot-contracts/src/pcell.rs" 97 4 97 33] (self : t_PCellOwn) : t_T
  
  predicate resolve'2 [#"../../creusot-contracts/src/pcell.rs" 59 4 59 28] (self : t_PCellOwn) =
    [%#spcell'0] resolve'1 (val' self)
  
  goal refines : [%#spcell] forall self : t_PCellOwn . structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ inv'0 self /\ (forall result : () . resolve'2 self  -> resolve'2 self)
end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 46 4 46 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 46 4 46 31
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 40 8 40 44
  
  type t_T1
  
  type t_T2
  
  type tuple  =
    { _p0: t_T1; _p1: t_T2 }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T2)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T1)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : tuple) =
    match _0 with
      | {_p0 = x0 ; _p1 = x1} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T1)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T2)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : tuple)
  
  axiom inv_axiom [@rewrite] : forall x : tuple [inv'1 x] . inv'1 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : tuple) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : tuple)
  
  axiom inv_axiom'0 [@rewrite] : forall x : tuple [inv'2 x] . inv'2 x = invariant' x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 39 4 39 28] (self : tuple) =
    [%#sresolve'0] resolve'0 self._p0 /\ resolve self._p1
  
  goal refines : [%#sresolve] forall self : tuple . structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result : () . resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 59 4 59 31] (* <&mut T as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 59 4 59 31
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 53 20 53 34
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : MutBorrow.t t_T) =
    _0.final = _0.current
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_T) =
    [%#sinvariant'0] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite] : forall x : MutBorrow.t t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : MutBorrow.t t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 52 4 52 28] (self : MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  goal refines : [%#sresolve] forall self : MutBorrow.t t_T . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve self  -> resolve self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 72 4 72 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 72 4 72 31
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 66 8 66 23
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_T) =
    resolve _0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 65 4 65 28] (self : t_T) =
    [%#sresolve'0] resolve self
  
  goal refines : [%#sresolve] forall self : t_T . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 88 4 88 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 88 4 88 31
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 79 8 82 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_0 : t_Option) =
    match _0 with
      | C_None -> true
      | C_Some x0 -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option [inv'1 x] . inv'1 x = invariant' x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 78 4 78 28] (self : t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  goal refines : [%#sresolve] forall self : t_Option . structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'6 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'7 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'8 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'9 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom [@rewrite] : forall x : t_Option [inv'0 x] . inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Fuse)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse [inv'1 x] . inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse) : t_Option
  
  axiom view_spec : forall self : t_Fuse . ([%#sfuse'8] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'9] forall other : t_Fuse . view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse) (prod : Seq.seq t_Item) (other : t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty : Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a : t_Fuse) (ab : Seq.seq t_Item) (b : t_Fuse) (bc : Seq.seq t_Item) (c : t_Fuse) : ()
  
   =
    [%#sfuse'7] ()
  
  axiom produces_trans_spec'0 : forall a : t_Fuse, ab : Seq.seq t_Item, b : t_Fuse, bc : Seq.seq t_Item, c : t_Fuse . ([%#sfuse'4] produces'0 a ab b)
   -> ([%#sfuse'5] produces'0 b bc c)  -> ([%#sfuse'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self : t_Fuse) : () =
    [%#sfuse'3] ()
  
  axiom produces_refl_spec'0 : forall self : t_Fuse . [%#sfuse'2] produces'0 self (Seq.empty : Seq.seq t_Item) self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t t_Fuse) : t_Option =
    [%#smodel] view self.current
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : MutBorrow.t t_Fuse) =
    [%#sfuse'1] (view'0 self = C_None
    \/ (exists it : MutBorrow.t t_I . completed it /\ view'0 self = C_Some (it.current)))
    /\ view self.final = C_None
  
  goal refines : [%#sfuse] forall self : MutBorrow.t t_Fuse . forall steps : Seq.seq t_Item . forall next : t_Fuse . produces'0 self.final steps next
  /\ completed'0 self
   -> produces'0 self.final steps next
  /\ completed'0 self
  /\ (forall result : () . steps = (Seq.empty : Seq.seq t_Item) /\ self.final = next
   -> steps = (Seq.empty : Seq.seq t_Item) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 86 4 86 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 118 15 118 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 119 14 119 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 124 14 124 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 129 15 129 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 130 15 130 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 14 131 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 14 137 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 86 4 86 44
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 175 14 175 68
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 178 12 183 74
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 35 8 47 9
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 22 14 22 45
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 27 23 29
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 26 15 26 32
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 27 15 27 32
  let%span smap_inv'8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 14 28 42
  let%span smap_inv'9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 91 29 93
  let%span smap_inv'10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 70 12 72 73
  let%span smap_inv'11 = "../../creusot-contracts/src/std/iter/map_inv.rs" 149 12 152 47
  let%span smap_inv'12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 120 14 120 81
  let%span smap_inv'13 = "../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 128 88
  let%span smap_inv'14 = "../../creusot-contracts/src/std/iter/map_inv.rs" 113 12 115 63
  let%span smap_inv'15 = "../../creusot-contracts/src/std/iter/map_inv.rs" 136 12 141 71
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I) (visited : Seq.seq t_Item) (o : t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I) (ab : Seq.seq t_Item) (b : t_I) (bc : Seq.seq t_Item) (c : t_I) : ()
  
  
  axiom produces_trans_spec : forall a : t_I, ab : Seq.seq t_Item, b : t_I, bc : Seq.seq t_Item, c : t_I . ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I) : ()
  
  axiom produces_refl_spec : forall self : t_I . [%#siter] produces self (Seq.empty : Seq.seq t_Item) self
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I)
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : tuple)
  
  predicate next_precondition [#"../../creusot-contracts/src/std/iter/map_inv.rs" 111 4 111 78] (iter : t_I) (func : t_F) (produced : Seq.seq t_Item)
  
   =
    [%#smap_inv'14] forall e : t_Item, i : t_I . produces iter (Seq.singleton e) i
     -> precondition func { _p0 = e; _p1 = produced }
  
  type t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : tuple) (result : t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : tuple) (result_state : t_F) (result : t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (self : t_F) (args : tuple) (res : t_B) : ()
  
  
  axiom fn_mut_once_spec : forall self : t_F, args : tuple, res : t_B . [%#sops'5] postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (self : t_F) (b : t_F) (c : t_F) : ()
  
  axiom hist_inv_trans_spec : forall self : t_F, b : t_F, c : t_F . ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (self : t_F) : ()
  
  axiom hist_inv_refl_spec : forall self : t_F . [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (self : t_F) (args : tuple) (res_state : t_F) (res : t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec : forall self : t_F, args : tuple, res_state : t_F, res : t_B . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 134 4 134 49] (iter : t_I) (func : t_F) =
    [%#smap_inv'15] forall s : Seq.seq t_Item, e1 : t_Item, e2 : t_Item, f : MutBorrow.t t_F, b : t_B, i : t_I . hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  predicate reinitialize [#"../../creusot-contracts/src/std/iter/map_inv.rs" 147 4 147 33]  =
    [%#smap_inv'11] forall iter : MutBorrow.t t_I, func : t_F . completed iter
     -> next_precondition iter.final func (Seq.empty : Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 73] (iter : t_I) (func : t_F) (produced : Seq.seq t_Item)
  
   =
    [%#smap_inv'13] forall s : Seq.seq t_Item, e1 : t_Item, e2 : t_Item, f : MutBorrow.t t_F, b : t_B, i : t_I . hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = Seq.(++) produced s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec : forall iter : t_I, func : t_F, produced : Seq.seq t_Item . [%#smap_inv'12] produced
  = (Seq.empty : Seq.seq t_Item)  -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/map_inv.rs" 68 4 68 30] (self : t_MapInv) =
    [%#smap_inv'10] reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_MapInv)
  
  axiom inv_axiom [@rewrite] : forall x : t_MapInv [inv'1 x] . inv'1 x
  = (invariant' x
  /\ match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'0 func
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_MapInv) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_MapInv)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_MapInv [inv'2 x] . inv'2 x = invariant''0 x
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 34 4 34 67] (self : t_MapInv) (visited : Seq.seq t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'3] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs : Seq.seq (MutBorrow.t t_F) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item . Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 29 4 29 90] (a : t_MapInv) (ab : Seq.seq t_B) (b : t_MapInv) (bc : Seq.seq t_B) (c : t_MapInv) : ()
  
   =
    [%#smap_inv'9] ()
  
  axiom produces_trans_spec'0 : forall a : t_MapInv, ab : Seq.seq t_B, b : t_MapInv, bc : Seq.seq t_B, c : t_MapInv . ([%#smap_inv'6] produces'0 a ab b)
   -> ([%#smap_inv'7] produces'0 b bc c)  -> ([%#smap_inv'8] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 23 4 23 26] (self : t_MapInv) : () =
    [%#smap_inv'5] ()
  
  axiom produces_refl_spec'0 : forall self : t_MapInv . [%#smap_inv'4] produces'0 self (Seq.empty : Seq.seq t_B) self
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : MutBorrow.t t_MapInv) =
    [%#smap_inv'0] (self.final).t_MapInv__produced = (Seq.empty : Seq.seq t_Item)
    /\ completed (MutBorrow.borrow_logic (self.current).t_MapInv__iter (self.final).t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func = (self.final).t_MapInv__func
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 176 4 176 57] (self : t_MapInv) (visited : t_B) (succ : t_MapInv)
  
   =
    [%#smap_inv'2] exists f : MutBorrow.t t_F, e : t_Item . f.current = self.t_MapInv__func
    /\ f.final = succ.t_MapInv__func
    /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
    /\ precondition f.current { _p0 = e; _p1 = self.t_MapInv__produced }
    /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited
  
  axiom produces_one_spec : forall self : t_MapInv, visited : t_B, succ : t_MapInv . [%#smap_inv'1] produces_one self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_B)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Option)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option [inv'4 x] . inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  goal refines : [%#smap_inv] forall self_ : MutBorrow.t t_MapInv . inv'2 self_
   -> inv'2 self_
  /\ (forall result : t_Option . match result with
    | C_None -> completed'0 self_
    | C_Some v -> produces_one self_.current v self_.final
    end
  /\ inv'4 result
   -> match result with
    | C_None -> completed'0 self_
    | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
    end
  /\ inv'4 result)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self : t_Range) (visited : Seq.seq t_Idx) (o : t_Range)
  
   =
    [%#srange'0] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  goal refines : [%#srange] forall self : t_Range . forall result : () . produces_back self (Seq.empty : Seq.seq t_Idx) self
   -> produces_back self (Seq.empty : Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self : t_Range) (visited : Seq.seq t_Idx) (o : t_Range)
  
   =
    [%#srange'0] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  goal refines : [%#srange] forall a : t_Range . forall ab : Seq.seq t_Idx . forall b : t_Range . forall bc : Seq.seq t_Idx . forall c : t_Range . produces_back b bc c
  /\ produces_back a ab b
   -> produces_back b bc c
  /\ produces_back a ab b
  /\ (forall result : () . produces_back a (Seq.(++) ab bc) c  -> produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r : t_RangeInclusive) : int
  
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec : forall r : t_RangeInclusive . [%#srange'1] is_empty_log r
  = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self : t_RangeInclusive) (visited : Seq.seq t_Idx) (o : t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  goal refines : [%#srange] forall self : t_RangeInclusive . forall result : () . produces_back self (Seq.empty : Seq.seq t_Idx) self
   -> produces_back self (Seq.empty : Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 220 14 220 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 208 4 208 29] (self : t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 214 4 214 27] (self : t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 221 4 224 35] (self : t_RangeInclusive) : bool
  
  axiom is_empty_log_spec : forall self : t_RangeInclusive . [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r : t_RangeInclusive) : int
  
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec : forall r : t_RangeInclusive . [%#srange'1] is_empty_log r
  = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self : t_RangeInclusive) (visited : Seq.seq t_Idx) (o : t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  goal refines : [%#srange] forall a : t_RangeInclusive . forall ab : Seq.seq t_Idx . forall b : t_RangeInclusive . forall bc : Seq.seq t_Idx . forall c : t_RangeInclusive . produces_back b bc c
  /\ produces_back a ab b
   -> produces_back b bc c
  /\ produces_back a ab b
  /\ (forall result : () . produces_back a (Seq.(++) ab bc) c  -> produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__hist_inv_trans__refines [#"../../creusot-contracts/src/std/ops.rs" 132 4 132 45] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 132 4 132 45
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  goal refines : [%#sops] forall self : t_F . forall b : t_F . forall c : t_F . hist_inv b c /\ hist_inv self b
   -> hist_inv b c /\ hist_inv self b /\ (forall result : () . hist_inv self c  -> hist_inv self c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__fn_mut_once__refines [#"../../creusot-contracts/src/std/ops.rs" 138 4 138 55] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 138 4 138 55
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Args) (result : t_Output)
  
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Args) (result_state : t_F) (result : t_Output)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  goal refines : [%#sops] forall self : t_F . forall args : t_Args . forall res : t_Output . forall result : () . postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
   -> postcondition_once self args res
  = (exists res_state : t_F . postcondition_mut self args res_state res /\ resolve res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__postcondition_mut_hist_inv__refines [#"../../creusot-contracts/src/std/ops.rs" 120 4 120 87] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 120 4 120 87
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Args) (result_state : t_F) (result : t_Output)
  
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  goal refines : [%#sops] forall self : t_F . forall args : t_Args . forall res_state : t_F . forall res : t_Output . postcondition_mut self args res_state res
   -> postcondition_mut self args res_state res
  /\ (forall result : () . hist_inv self res_state  -> hist_inv self res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__hist_inv_refl__refines [#"../../creusot-contracts/src/std/ops.rs" 125 4 125 26] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 125 4 125 26
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  goal refines : [%#sops] forall self : t_F . forall result : () . hist_inv self self  -> hist_inv self self
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_mut__refines [#"../../creusot-contracts/src/std/ops.rs" 154 4 154 67] (* <F as std::ops::FnExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 154 4 154 67
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_F) (args : t_Args) (result_state : t_F) (result : t_Output)
  
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : t_F) (args : t_Args) (result : t_Output)
  
  
  goal refines : [%#sops] forall self : t_F . forall args : t_Args . forall res_state : t_F . forall res : t_Output . forall result : () . postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
   -> postcondition_mut self args res_state res = (postcondition self args res /\ self = res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_once__refines [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 51] (* <F as std::ops::FnExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 159 4 159 51
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_F) (args : t_Args) (result : t_Output)
  
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : t_F) (args : t_Args) (result : t_Output)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_0 : t_F)
  
  goal refines : [%#sops] forall self : t_F . forall args : t_Args . forall res : t_Output . forall result : () . postcondition_once self args res
  = (postcondition self args res /\ resolve self)
   -> postcondition_once self args res = (postcondition self args res /\ resolve self)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_hist_inv__refines [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 41] (* <F as std::ops::FnExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 164 4 164 41
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 112 4 112 49] (self : t_F) (result_state : t_F)
  
  goal refines : [%#sops] forall self : t_F . forall res_state : t_F . forall result : () . hist_inv self res_state
  = (self = res_state)  -> hist_inv self res_state = (self = res_state)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 60 4 60 34
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self : Opaque.ptr) : UInt64.t
  
  goal refines : [%#sptr] forall self : Opaque.ptr . forall result : bool . result = (addr_logic self = (0 : UInt64.t))
   -> result = (addr_logic self = (0 : UInt64.t))
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 75 4 75 34
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 68 4 68 32] (self : Opaque.ptr) : UInt64.t
  
  goal refines : [%#sptr] forall self : Opaque.ptr . forall result : bool . result = (addr_logic self = (0 : UInt64.t))
   -> result = (addr_logic self = (0 : UInt64.t))
end
module M_creusot_contracts__fn_pure__qyi11638360339920708941__clone__refines [#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (* <fn_pure::FnPureWrapper<F> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 30 4 30 27
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite] : forall x : t_FnPureWrapper [inv'0 x] . inv'0 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_FnPureWrapper) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FnPureWrapper [inv'1 x] . inv'1 x = invariant' x
  
  goal refines : [%#sfn_pure] forall self_ : t_FnPureWrapper . inv'1 self_
   -> inv'1 self_
  /\ (forall result : t_FnPureWrapper . result = self_ /\ inv'0 result  -> result = self_ /\ inv'0 result)
end
module M_creusot_contracts__ghost__qyi11517682701084838082__clone__refines [#"../../creusot-contracts/src/ghost.rs" 53 4 53 27] (* <ghost::Ghost<T> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 53 4 53 27
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 97 8 97 18
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/ghost.rs" 96 4 96 30] (self :  t_T) =
    [%#sghost'0] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 :  t_T)
  
  axiom inv_axiom [@rewrite] : forall x :  t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self :  t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 :  t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x :  t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  goal refines : [%#sghost] forall self_ :  t_T . inv'1 self_
   -> inv'1 self_ /\ (forall result :  t_T . result = self_ /\ inv'0 result  -> result = self_ /\ inv'0 result)
end
module M_creusot_contracts__logic__fmap__qyi1775402764303793352__clone__refines [#"../../creusot-contracts/src/logic/fmap.rs" 496 4 496 27] (* <logic::fmap::FMap<K, V> as std::clone::Clone> *)
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 496 4 496 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 510 20 510 91
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap) : Map.map t_K t_Option
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'4] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap) (k : t_K) : t_Option
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  function contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap) (k : t_K) : bool
  
   =
    [%#sfmap'1] get_unsized self k <> C_None
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_K)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_V)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_V) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_V)
  
  axiom inv_axiom [@rewrite] : forall x : t_V [inv'1 x] . inv'1 x = invariant' x
  
  function unwrap [#"../../creusot-contracts/src/util.rs" 56 0 56 36] (op : t_Option) : t_V
  
  axiom unwrap_spec : forall op : t_Option . ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 124 4 124 50] (self : t_FMap) (k : t_K) : t_V
  
   =
    [%#sfmap'2] unwrap (get_unsized self k)
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/fmap.rs" 509 4 509 30] (self : t_FMap) =
    [%#sfmap'0] forall k : t_K . contains self k  -> inv k /\ inv'1 (lookup_unsized self k)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FMap)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FMap [inv'2 x] . inv'2 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_FMap) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FMap)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_FMap [inv'3 x] . inv'3 x = invariant''1 x
  
  goal refines : [%#sfmap] forall self_ : t_FMap . inv'3 self_
   -> inv'3 self_ /\ (forall result : t_FMap . result = self_ /\ inv'2 result  -> result = self_ /\ inv'2 result)
end
module M_creusot_contracts__logic__fset__qyi13324666171263681189__clone__refines [#"../../creusot-contracts/src/logic/fset.rs" 475 4 475 27] (* <logic::fset::FSet<T> as std::clone::Clone> *)
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 475 4 475 27
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 489 20 489 63
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T) (e : t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/logic/fset.rs" 488 4 488 30] (self : Fset.fset t_T) =
    [%#sfset'0] forall x : t_T . contains self x  -> inv x
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Fset.fset t_T)
  
  axiom inv_axiom [@rewrite] : forall x : Fset.fset t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : Fset.fset t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Fset.fset t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Fset.fset t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  goal refines : [%#sfset] forall self_ : Fset.fset t_T . inv'1 self_
   -> inv'1 self_ /\ (forall result : Fset.fset t_T . result = self_ /\ inv'0 result  -> result = self_ /\ inv'0 result)
end
module M_creusot_contracts__logic__int__qyi3540547019284611154__clone__refines [#"../../creusot-contracts/src/logic/int.rs" 33 4 33 27] (* <logic::int::Int as std::clone::Clone> *)
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 33 4 33 27
  
  goal refines : [%#sint] forall self_ : int . forall result : int . result = self_  -> result = self_
end
module M_creusot_contracts__logic__seq__qyi7164078029063507335__clone__refines [#"../../creusot-contracts/src/logic/seq.rs" 660 4 660 27] (* <logic::seq::Seq<T> as std::clone::Clone> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 660 4 660 27
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 673 20 673 95
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_T)
  
  axiom inv_axiom [@rewrite] : forall x : t_T [inv'0 x] . inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/seq.rs" 672 4 672 30] (self : Seq.seq t_T) =
    [%#sseq'0] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'0 (Seq.get self i)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t_T [inv'1 x] . inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : Seq.seq t_T) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T [inv'2 x] . inv'2 x = invariant''1 x
  
  goal refines : [%#sseq] forall self_ : Seq.seq t_T . inv'2 self_
   -> inv'2 self_ /\ (forall result : Seq.seq t_T . result = self_ /\ inv'1 result  -> result = self_ /\ inv'1 result)
end
module M_creusot_contracts__pcell__qyi11656593191764906533__clone__refines [#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (* <pcell::Id as std::clone::Clone> *)
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 34 4 34 27
  
  type t_Id
  
  goal refines : [%#spcell] forall self_ : t_Id . forall result : t_Id . result = self_  -> result = self_
end
module M_creusot_contracts__peano__qyi18263836234684628832__clone__refines [#"../../creusot-contracts/src/peano.rs" 33 9 33 14] (* <peano::PeanoInt as std::clone::Clone> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 33 9 33 14
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  goal refines : [%#speano] forall self_ : t_PeanoInt . forall result : t_PeanoInt . result = self_  -> result = self_
end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone__refines [#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot = "../../creusot-contracts/src/snapshot.rs" 57 4 57 27
  
  type t_T
  
  goal refines : [%#ssnapshot] forall self_ : t_T . forall result : t_T . result = self_  -> result = self_
end
module M_creusot_contracts__fn_pure__qyi15308794846353696785__call_once__refines [#"../../creusot-contracts/src/fn_pure.rs" 44 4 44 66] (* <fn_pure::FnPureWrapper<F> as std::ops::FnOnce<I>> *)
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 44 4 44 66
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_FnPureWrapper) (args : t_I)
   =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite] : forall x : t_FnPureWrapper [inv'1 x] . inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : t_F) (args : t_I) (result : t_Output)
  
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 93 4 93 73] (self : t_FnPureWrapper) (args : t_I) (result : t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Output)
  
  goal refines : [%#sfn_pure] forall self_ : t_FnPureWrapper . forall arg : t_I . precondition'0 self_ arg
  /\ inv arg /\ inv'1 self_
   -> precondition'0 self_ arg
  /\ inv arg
  /\ inv'1 self_
  /\ (forall result : t_Output . postcondition_once self_ arg result /\ inv'2 result
   -> postcondition_once self_ arg result /\ inv'2 result)
end
module M_creusot_contracts__fn_pure__qyi5108156253941351966__call_mut__refines [#"../../creusot-contracts/src/fn_pure.rs" 54 4 54 70] (* <fn_pure::FnPureWrapper<F> as std::ops::FnMut<I>> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 54 4 54 70
  
  use creusot.prelude.MutBorrow
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_FnPureWrapper) (args : t_I)
   =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite] : forall x : t_FnPureWrapper [inv'1 x] . inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 99 4 99 30] (self : MutBorrow.t t_FnPureWrapper) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : MutBorrow.t t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_FnPureWrapper [inv'2 x] . inv'2 x = invariant' x
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : t_F) (args : t_I) (result : t_Output)
  
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 104 4 104 92] (self : t_FnPureWrapper) (args : t_I) (result_state : t_FnPureWrapper) (result : t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result /\ self = result_state
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Output)
  
  goal refines : [%#sfn_pure] forall self_ : MutBorrow.t t_FnPureWrapper . forall arg : t_I . precondition'0 self_.current arg
  /\ inv arg /\ inv'2 self_
   -> precondition'0 self_.current arg
  /\ inv arg
  /\ inv'2 self_
  /\ (forall result : t_Output . postcondition_mut self_.current arg self_.final result /\ inv'3 result
   -> postcondition_mut self_.current arg self_.final result /\ inv'3 result)
end
module M_creusot_contracts__fn_pure__qyi448029234342275964__call__refines [#"../../creusot-contracts/src/fn_pure.rs" 64 4 64 62] (* <fn_pure::FnPureWrapper<F> as std::ops::Fn<I>> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 64 4 64 62
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_F) (args : t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 85 4 85 45] (self : t_FnPureWrapper) (args : t_I)
   =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite] : forall x : t_FnPureWrapper [inv'1 x] . inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 89 4 89 30] (self : t_FnPureWrapper) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FnPureWrapper [inv'2 x] . inv'2 x = invariant' x
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : t_F) (args : t_I) (result : t_Output)
  
  
  predicate postcondition'0 [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 68] (self : t_FnPureWrapper) (args : t_I) (result : t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 111 0 111 35] (_0 : t_Output)
  
  goal refines : [%#sfn_pure] forall self_ : t_FnPureWrapper . forall arg : t_I . precondition'0 self_ arg
  /\ inv arg /\ inv'2 self_
   -> precondition'0 self_ arg
  /\ inv arg
  /\ inv'2 self_
  /\ (forall result : t_Output . postcondition'0 self_ arg result /\ inv'3 result
   -> postcondition'0 self_ arg result /\ inv'3 result)
end
module M_creusot_contracts__logic__int__qyi8495612394334423323__eq__refines [#"../../creusot-contracts/src/logic/int.rs" 238 4 238 38] (* <logic::int::Int as std::cmp::PartialEq> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 92 8 92 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 238 4 238 38
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 91 4 91 44] (self : int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : int) : int =
    [%#smodel] deep_model self
  
  goal refines : [%#sint] forall self_ : int . forall rhs : int . forall result : bool . result = (self_ = rhs)
   -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
