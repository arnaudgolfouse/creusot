module M_creusot_contracts__cell__permcell__qyi3578931356383317664__id_ghost (* cell::permcell::PermCellOwn<T> *)
  use creusot.prelude.Any
  
  type t_PermCellOwn
  
  type t_Id
  
  function id (self: t_PermCellOwn) : t_Id
  
  let rec into_ghost (self: t_Id) (return (x: t_Id)) = any
    [ return (result: t_Id) -> {result = self} (! return {result}) ]
  
  predicate inv (_1: t_PermCellOwn)
  
  predicate invariant' [@inline:trivial] (self: t_PermCellOwn) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_PermCellOwn) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec id_ghost (self: t_PermCellOwn) (return (x: t_Id)) = {[@expl:id_ghost 'self' type invariant] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- id self ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_ghost {_3} (fun (_ret: t_Id) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_Id = Any.any_l () | & self: t_PermCellOwn = self | & _3: t_Id = Any.any_l () ])
    [ return (result: t_Id) -> {[@expl:id_ghost ensures] result = id self} (! return {result}) ]
end
module M_creusot_contracts__cell__permcell__qyi12443308788980502857__id_ghost (* cell::permcell::PermCell<T> *)
  use creusot.prelude.Any
  
  type t_PermCell
  
  type t_Id
  
  function id (self: t_PermCell) : t_Id
  
  let rec into_ghost (self: t_Id) (return (x: t_Id)) = any
    [ return (result: t_Id) -> {result = self} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec id_ghost (self: t_PermCell) (return (x: t_Id)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- id self ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_ghost {_3} (fun (_ret: t_Id) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_Id = Any.any_l () | & self: t_PermCell = self | & _3: t_Id = Any.any_l () ])
    [ return (result: t_Id) -> {[@expl:id_ghost ensures] result = id self} (! return {result}) ]
end
module M_creusot_contracts__cell__permcell__qyi12443308788980502857__take (* cell::permcell::PermCell<T> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true) -> precondition () args
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let () = args in inv res)
  
  let rec default (return (x: t_T)) = {[@expl:default requires] precondition () ()}
    any [ return (result: t_T) -> {postcondition_once () () result} (! return {result}) ]
  
  type t_PermCell
  
  type t_PermCellOwn
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  function val' (self: t_PermCellOwn) : t_T
  
  predicate invariant''0 [@inline:trivial] (self: t_PermCellOwn) = inv'0 (val' self)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 (_1: t_PermCellOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PermCellOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_PermCellOwn) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) = inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: MutBorrow.t t_PermCellOwn) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  type t_Id
  
  function id (self: t_PermCell) : t_Id
  
  function id'0 (self: t_PermCellOwn) : t_Id
  
  function view [@inline:trivial] (self: t_PermCellOwn) : t_T = val' self
  
  meta "rewrite_def" function view
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PermCellOwn) : t_PermCellOwn = self.final
  
  meta "rewrite_def" function fin
  
  let rec replace (self: t_PermCell) (perm: MutBorrow.t t_PermCellOwn) (val''0: t_T) (return (x: t_T)) =
    {[@expl:replace 'perm' type invariant] inv'3 perm}
    {[@expl:replace 'val' type invariant] inv val''0}
    {[@expl:replace requires] id self = id'0 perm.current}
    any
    [ return (result: t_T) -> {inv result}
      {val''0 = view (fin perm)}
      {result = view perm.current}
      {id self = id'0 (fin perm)}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let () = args in inv res)
  
  function fn_mut_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition () args res]. postcondition () args res
      -> (let () = args in inv res)
  
  function fn_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take (self: t_PermCell) (perm: MutBorrow.t t_PermCellOwn) (return (x: t_T)) =
    {[@expl:take 'perm' type invariant] inv'3 perm}
    {[@expl:take requires] id self = id'0 perm.current}
    (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret: t_T) -> [ &_9 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = replace {self} {perm} {_9} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: t_T = Any.any_l ()
    | & self: t_PermCell = self
    | & perm: MutBorrow.t t_PermCellOwn = perm
    | & _9: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:take result type invariant] inv result}
      {[@expl:take ensures #0] id self = id'0 (fin perm)}
      {[@expl:take ensures #1] result = view perm.current}
      {[@expl:take ensures #2] postcondition () () (view (fin perm))}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__fn_ghost__qyi2064759324376620136__clone (* <ghost::fn_ghost::FnGhostWrapper<F> as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnGhostWrapper = { t_FnGhostWrapper__0: t_F }
  
  predicate inv (_1: t_F)
  
  predicate invariant' [@inline:trivial] (self: t_F) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_F) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate precondition (self: ()) (args: t_F)
  
  axiom precondition_fndef: forall args: t_F [precondition () args]. (let self_ = args in inv'0 self_)
      -> precondition () args
  
  predicate postcondition_once (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef: forall args: t_F, res: t_F [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  let rec clone' (self_: t_F) (return (x: t_F)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_F) -> {postcondition_once () self_ result} (! return {result}) ]
  
  predicate inv'1 (_1: t_FnGhostWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper [inv'1 x]. inv'1 x = inv x.t_FnGhostWrapper__0
  
  predicate invariant''0 [@inline:trivial] (self: t_FnGhostWrapper) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_FnGhostWrapper) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_F, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_F, res: t_F. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1: forall args: t_F, res: t_F [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_spec: forall self: (), args: t_F, res: t_F. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  function view [@inline:trivial] (self: t_FnGhostWrapper) : t_F = self.t_FnGhostWrapper__0
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''0 (self: t_FnGhostWrapper) (return (x: t_FnGhostWrapper)) =
    {[@expl:clone 'self' type invariant] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone' {self.t_FnGhostWrapper__0} (fun (_ret: t_F) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { t_FnGhostWrapper__0 = _3 } ] s1 | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: t_FnGhostWrapper = Any.any_l () | & self: t_FnGhostWrapper = self | & _3: t_F = Any.any_l () ])
    [ return (result: t_FnGhostWrapper) -> {[@expl:clone result type invariant] inv'1 result}
      {[@expl:clone ensures] postcondition () (view self) (view result)}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__fn_ghost__qyi3756533087425350211__qy95z_new (* ghost::fn_ghost::FnGhostWrapper<F> *)
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnGhostWrapper = { t_FnGhostWrapper__0: t_F }
  
  predicate inv (_1: t_F)
  
  predicate inv'0 (_1: t_FnGhostWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper [inv'0 x]. inv'0 x = inv x.t_FnGhostWrapper__0
  
  function view [@inline:trivial] (self: t_FnGhostWrapper) : t_F = self.t_FnGhostWrapper__0
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec qy95z_new (f: t_F) (return (x: t_FnGhostWrapper)) = {[@expl:__new 'f' type invariant] inv f}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { t_FnGhostWrapper__0 = f } ] s1 | s1 = bb2 ] | bb2 = return {_0} ]
    [ & _0: t_FnGhostWrapper = Any.any_l () | & f: t_F = f ])
    [ return (result: t_FnGhostWrapper) -> {[@expl:__new result type invariant] inv'0 result}
      {[@expl:__new ensures] view result = f}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__local_invariant__qyi15922258954415376118__open (* <ghost::Ghost<&'a ghost::local_invariant::LocalInvariant<T>> as ghost::local_invariant::LocalInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Set
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_LocalInvariant
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  predicate inv (_1: t_F)
  
  predicate contains [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = Set.mem e self
  
  meta "rewrite_def" predicate contains
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains'0 (self: t_Tokens) (namespace: t_Namespace) = contains (namespaces self) namespace
  
  function namespace (self: t_LocalInvariant) : t_Namespace
  
  type t_T
  
  type t_Public
  
  predicate protocol (self: t_T) (data: t_Public)
  
  function public (self: t_LocalInvariant) : t_Public
  
  predicate inv'0 (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_T) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: t_F) (args: MutBorrow.t t_T)
  
  predicate postcondition_once (self: t_F) (args: MutBorrow.t t_T) (result: t_A)
  
  function fin [@inline:trivial] (self: MutBorrow.t t_T) : t_T = self.final
  
  meta "rewrite_def" function fin
  
  predicate inv'3 (_1: t_A)
  
  let rec open (this: t_LocalInvariant) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open 'f' type invariant] inv f}
    {[@expl:open requires #0] contains'0 tokens (namespace this)}
    {[@expl:open requires #1] forall t: MutBorrow.t t_T. protocol t.current (public this) /\ inv'2 t
      -> precondition f t /\ (forall res: t_A. postcondition_once f t res -> protocol (fin t) (public this))}
    any
    [ return (result: t_A) -> {inv'3 result}
      {exists t: MutBorrow.t t_T. protocol t.current (public this) /\ postcondition_once f t result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open'0 (self: t_LocalInvariant) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open 'f' type invariant] inv f}
    {[@expl:open requires #0] contains'0 tokens (namespace self)}
    {[@expl:open requires #1] forall t: MutBorrow.t t_T. protocol t.current (public self) /\ inv'2 t
      -> precondition f t /\ (forall res: t_A. postcondition_once f t res -> protocol (fin t) (public self))}
    (! bb0
    [ bb0 = s0 [ s0 = open {self} {tokens} {f} (fun (_ret: t_A) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: t_A = Any.any_l () | & self: t_LocalInvariant = self | & tokens: t_Tokens = tokens | & f: t_F = f ])
    [ return (result: t_A) -> {[@expl:open result type invariant] inv'3 result}
      {[@expl:open ensures] exists t: MutBorrow.t t_T. protocol t.current (public self)
        /\ postcondition_once f t result}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__local_invariant__qyi2997475845828180053__open (* <ghost::Ghost<&'a T> as ghost::local_invariant::LocalInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: t_T) = inv'1 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  let rec deref (self: t_T) (return (x: t_T)) = {[@expl:deref 'self' type invariant] inv'2 self}
    any [ return (result: t_T) -> {inv'3 result} {result = self} (! return {result}) ]
  
  type t_Target
  
  predicate precondition (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in false) -> precondition () args
  
  predicate inv'4 (_1: t_Target)
  
  predicate invariant''3 [@inline:trivial] (self: t_Target) = inv'4 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 [@inline:trivial] (_1: t_Target) = invariant''3 _1
  
  meta "rewrite_def" predicate inv'5
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_Target)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_Target [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv'5 res)
  
  let rec deref'0 (self_: t_T) (return (x: t_Target)) = {[@expl:deref requires] precondition () self_}
    any [ return (result: t_Target) -> {postcondition_once () self_ result} (! return {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: t_Target) = inv'5 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'6 [@inline:trivial] (_1: t_Target) = invariant''4 _1
  
  meta "rewrite_def" predicate inv'6
  
  let rec new (x: t_Target) (return (x'0: t_Target)) = {[@expl:new 'x' type invariant] inv'5 x}
    any [ return (result: t_Target) -> {inv'6 result} {result = x} (! return {result}) ]
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  type tuple = { f0: t_Target; f1: t_Tokens; f2: t_F }
  
  predicate precondition'0 (self: ()) (args: tuple)
  
  axiom precondition_fndef'0:
    forall args: tuple [precondition'0 () args]. (let {f0 = self; f1 = tokens; f2 = f} = args in false)
      -> precondition'0 () args
  
  predicate inv'7 (_1: t_A)
  
  predicate postcondition_once'0 (self: ()) (args: tuple) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: tuple, res: t_A [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv'7 res)
  
  let rec open (self: t_Target) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open requires] precondition'0 () { f0 = self; f1 = tokens; f2 = f }}
    any
    [ return (result: t_A) -> {postcondition_once'0 () { f0 = self; f1 = tokens; f2 = f } result} (! return {result}) ]
  
  predicate inv'8 (_1: t_F)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_Target)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_Target [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv'5 res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_Target) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_Target. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_Target) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_Target. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_Target)
  
  axiom postcondition_fndef'2: forall args: t_T, res: t_Target [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv'5 res)
  
  function fn_once (self: ()) (args: t_T) (res: t_Target) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_Target. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_Target) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_Target. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  function new_logic (x: t_Target) : t_Target
  
  axiom new_logic_spec: forall x: t_Target. new_logic x = x
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut'0 (self: ()) (args: tuple) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'3:
    forall args: tuple, res: t_A [postcondition_mut'0 () args () res]. postcondition_mut'0 () args () res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv'7 res)
  
  function fn_mut_once'0 (self: ()) (args: tuple) (res: t_A) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: tuple, res: t_A. postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv'0
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). hist_inv'0 self b -> hist_inv'0 b c -> hist_inv'0 self c
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: tuple) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_spec'0:
    forall self: (), args: tuple, res_state: (), res: t_A. postcondition_mut'0 self args res_state res
      -> hist_inv'0 self res_state
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: tuple) (result: t_A)
  
  axiom postcondition_fndef'4: forall args: tuple, res: t_A [postcondition'0 () args res]. postcondition'0 () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv'7 res)
  
  function fn_once'0 (self: ()) (args: tuple) (res: t_A) : ()
  
  axiom fn_once_spec'0: forall self: (), args: tuple, res: t_A. postcondition_once'0 self args res
      = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: tuple) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_spec'0:
    forall self: (), args: tuple, res_state: (), res: t_A. postcondition_mut'0 self args res_state res
      = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open'0 (self: t_T) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open 'self' type invariant] inv'1 self}
    {[@expl:open 'f' type invariant] inv'8 f}
    {[@expl:open requires #0] precondition () self}
    {[@expl:open requires #1] forall this: t_Target. postcondition () self this
      -> precondition'0 () { f0 = new_logic this; f1 = tokens; f2 = f }}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_13 <- self ] s1 | s1 = deref {_13} (fun (_ret: t_T) -> [ &_11 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = deref'0 {_11} (fun (_ret: t_Target) -> [ &_9 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = new {_9} (fun (_ret: t_Target) -> [ &this <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = open {this} {tokens} {f} (fun (_ret: t_A) -> [ &_0 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: t_A = Any.any_l ()
    | & self: t_T = self
    | & tokens: t_Tokens = tokens
    | & f: t_F = f
    | & this: t_Target = Any.any_l ()
    | & _9: t_Target = Any.any_l ()
    | & _11: t_T = Any.any_l ()
    | & _13: t_T = Any.any_l () ])
    [ return (result: t_A) -> {[@expl:open result type invariant] inv'7 result}
      {[@expl:open ensures] exists this: t_Target. postcondition () self this
        /\ postcondition'0 () { f0 = new_logic this; f1 = tokens; f2 = f } result}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__local_invariant__qyi11665730000181028090__open (* <&'a ghost::Ghost<L> as ghost::local_invariant::LocalInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_L
  
  predicate inv (_1: t_L)
  
  predicate invariant' [@inline:trivial] (self: t_L) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_L) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: t_L) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_L) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: t_L) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: t_L) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: t_L) = inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: t_L) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  let rec borrow (self: t_L) (return (x: t_L)) = {[@expl:borrow 'self' type invariant] inv'1 self}
    any [ return (result: t_L) -> {inv'3 result} {result = self} (! return {result}) ]
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  type tuple = { f0: t_L; f1: t_Tokens; f2: t_F }
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef:
    forall args: tuple [precondition () args]. (let {f0 = self; f1 = tokens; f2 = f} = args in false)
      -> precondition () args
  
  predicate inv'4 (_1: t_A)
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_A)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_A [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv'4 res)
  
  let rec open (self: t_L) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open requires] precondition () { f0 = self; f1 = tokens; f2 = f }}
    any
    [ return (result: t_A) -> {postcondition_once () { f0 = self; f1 = tokens; f2 = f } result} (! return {result}) ]
  
  predicate inv'5 (_1: t_F)
  
  function new_logic (x: t_L) : t_L
  
  axiom new_logic_spec: forall x: t_L. new_logic x = x
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: tuple) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: tuple, res: t_A [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv'4 res)
  
  function fn_mut_once (self: ()) (args: tuple) (res: t_A) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: tuple, res: t_A. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: tuple) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: tuple, res_state: (), res: t_A. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: tuple) (result: t_A)
  
  axiom postcondition_fndef'1: forall args: tuple, res: t_A [postcondition () args res]. postcondition () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv'4 res)
  
  function fn_once (self: ()) (args: tuple) (res: t_A) : ()
  
  axiom fn_once_spec: forall self: (), args: tuple, res: t_A. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: tuple) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_spec: forall self: (), args: tuple, res_state: (), res: t_A. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open'0 (self: t_L) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open 'self' type invariant] inv'1 self}
    {[@expl:open 'f' type invariant] inv'5 f}
    {[@expl:open requires] precondition () { f0 = new_logic self; f1 = tokens; f2 = f }}
    (! bb0
    [ bb0 = s0 [ s0 = borrow {self} (fun (_ret: t_L) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = open {_6} {tokens} {f} (fun (_ret: t_A) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_A = Any.any_l ()
    | & self: t_L = self
    | & tokens: t_Tokens = tokens
    | & f: t_F = f
    | & _6: t_L = Any.any_l () ])
    [ return (result: t_A) -> {[@expl:open result type invariant] inv'4 result}
      {[@expl:open ensures] postcondition () { f0 = new_logic self; f1 = tokens; f2 = f } result}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__ptr_own__qyi18153041897836823367__new (* ghost::ptr_own::PtrOwn<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn
  
  type tuple = { f0: Opaque.ptr; f1: t_PtrOwn }
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate is_aligned_to_logic (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_logic : UInt64.t
  
  axiom align_of_logic_spec: (0: UInt64.t) <> align_of_logic
    /\ UInt64.bw_and align_of_logic (UInt64.sub align_of_logic (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_logic_spec'0: Int.mod size_of_T (UInt64.t'int align_of_logic) = 0
  
  predicate is_aligned_logic [@inline:trivial] (ptr'0: Opaque.ptr) = is_aligned_to_logic ptr'0 align_of_logic
  
  meta "rewrite_def" predicate is_aligned_logic
  
  predicate is_aligned_logic'0 [@inline:trivial] (self: Opaque.ptr) = is_aligned_logic self
  
  meta "rewrite_def" predicate is_aligned_logic'0
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn) = is_aligned_logic'0 (ptr self)
  
  predicate metadata_matches [@inline:trivial] (_value: t_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches
  
  function val' (self: t_PtrOwn) : t_T
  
  function metadata_logic (_1: Opaque.ptr) : ()
  
  function size_of_val_logic [@inline:trivial] (val''0: t_T) : int = size_of_T
  
  meta "rewrite_def" function size_of_val_logic
  
  axiom size_of_val_logic_spec: forall val''0: t_T. 0 <= size_of_val_logic val''0
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self
    /\ metadata_matches (val' self) (metadata_logic (ptr self))
    /\ size_of_val_logic (val' self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr self)) + size_of_val_logic (val' self) <= UInt64.t'int const_MAX'0
    /\ inv'1 (val' self)
  
  predicate inv'2 (_1: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_PtrOwn) = inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: t_PtrOwn) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate inv'4 [@inline:trivial] (_1: tuple) = inv'3 _1.f1
  
  meta "rewrite_def" predicate inv'4
  
  let rec from_box (val''0: t_T) (return (x: tuple)) = {[@expl:from_box 'val' type invariant] inv'0 val''0}
    any
    [ return (result: tuple) -> {inv'4 result}
      {ptr result.f1 = result.f0 /\ val' result.f1 = val''0}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new (v: t_T) (return (x: tuple)) = {[@expl:new 'v' type invariant] inv v}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = from_box {v} (fun (_ret: tuple) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ] [ & _0: tuple = Any.any_l () | & v: t_T = v ])
    [ return (result: tuple) -> {[@expl:new result type invariant] inv'4 result}
      {[@expl:new ensures] ptr result.f1 = result.f0 /\ val' result.f1 = v}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__ptr_own__qyi18153041897836823367__drop (* ghost::ptr_own::PtrOwn<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_PtrOwn
  
  type t_T
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate is_aligned_logic (ptr'0: Opaque.ptr)
  
  predicate is_aligned_logic'0 [@inline:trivial] (self: Opaque.ptr) = is_aligned_logic self
  
  meta "rewrite_def" predicate is_aligned_logic'0
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn) = is_aligned_logic'0 (ptr self)
  
  type t_Metadata
  
  predicate metadata_matches (_value: t_T) (_metadata: t_Metadata)
  
  function val' (self: t_PtrOwn) : t_T
  
  function metadata_logic (_1: Opaque.ptr) : t_Metadata
  
  function size_of_val_logic (val''0: t_T) : int
  
  axiom size_of_val_logic_spec: forall val''0: t_T. 0 <= size_of_val_logic val''0
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self
    /\ metadata_matches (val' self) (metadata_logic (ptr self))
    /\ size_of_val_logic (val' self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr self)) + size_of_val_logic (val' self) <= UInt64.t'int const_MAX'0
    /\ inv'0 (val' self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_PtrOwn) = inv'1 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: t_PtrOwn) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 (self: t_T) = inv self
  
  predicate inv'3 [@inline:trivial] (_1: t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  let rec to_box (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return (x: t_T)) = {[@expl:to_box 'own' type invariant] inv'2 own}
    {[@expl:to_box requires] ptr'0 = ptr own}
    any [ return (result: t_T) -> {inv'3 result} {result = val' own} (! return {result}) ]
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 [@inline:trivial] (_1: t_T) = resolve _1
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec drop (ptr'0: Opaque.ptr) (own: t_PtrOwn) (return (x: ())) = {[@expl:drop 'own' type invariant] inv'2 own}
    {[@expl:drop requires] ptr'0 = ptr own}
    (! bb0
    [ bb0 = s0 [ s0 = to_box {ptr'0} {own} (fun (_ret: t_T) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'3 _4} s1 | s1 = -{resolve'0 _4}- s2 | s2 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: () = Any.any_l () | & ptr'0: Opaque.ptr = ptr'0 | & own: t_PtrOwn = own | & _4: t_T = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_creusot_contracts__ghost__ptr_own__qyi18153041897836823367__ptr_is_aligned_lemma (* ghost::ptr_own::PtrOwn<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.int.Int64
  
  type t_PtrOwn
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate is_aligned_logic (ptr'0: Opaque.ptr)
  
  predicate is_aligned_logic'0 [@inline:trivial] (self: Opaque.ptr) = is_aligned_logic self
  
  meta "rewrite_def" predicate is_aligned_logic'0
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn) = is_aligned_logic'0 (ptr self)
  
  type t_T
  
  type t_Metadata
  
  predicate metadata_matches (_value: t_T) (_metadata: t_Metadata)
  
  function val' (self: t_PtrOwn) : t_T
  
  function metadata_logic (_1: Opaque.ptr) : t_Metadata
  
  function size_of_val_logic (val''0: t_T) : int
  
  axiom size_of_val_logic_spec: forall val''0: t_T. 0 <= size_of_val_logic val''0
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self
    /\ metadata_matches (val' self) (metadata_logic (ptr self))
    /\ size_of_val_logic (val' self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr self)) + size_of_val_logic (val' self) <= UInt64.t'int const_MAX'0
    /\ inv'0 (val' self)
  
  predicate inv'1 (_1: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: t_PtrOwn) = inv'1 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: t_PtrOwn) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ptr_is_aligned_lemma (self: t_PtrOwn) (return (x: ())) =
    {[@expl:ptr_is_aligned_lemma 'self' type invariant] inv'2 self}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:ptr_is_aligned_lemma ensures] is_aligned_logic'0 (ptr self)} (! return {result}) ]
end
module M_creusot_contracts__ghost__resource__fmap_view__qyi4074634815133952471__new (* ghost::resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_View
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Ag
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'0)
  
  constant unit': t_FMap = empty
  
  axiom unit_spec: forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'0 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Ag. op factor'0 c <> C_Some'0 self
        end
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None'0} -> C_Some'1 x
      | {f0 = C_None'0} -> C_None'1
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl (self: t_Option'0) (other: t_Option'0) = factor'0 other self <> C_None'1
  
  function incl_transitive (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
  axiom incl_op_spec: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. op'0 self other = C_Some'1 comb
      -> incl self comb
  
  type tuple'0 = { f0'0: t_K; f1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'0) (a: tuple'0) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic f { f0'0 = k; f1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {f0'0 = k; f1'0 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some comb
      -> incl'0 self comb
  
  predicate rel (a: t_Option) (f: t_FMap) =
    match a with
      | C_Some a'0 -> incl'0 f a'0
      | C_None -> true
      end
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_FMap. rel (C_None) f
  
  function rel_mono (a: t_Option) (f1'1: t_FMap) (f2: t_FMap) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1'1: t_FMap, f2: t_FMap. rel a f1'1 -> incl'0 f2 f1'1 -> rel a f2
  
  function auth (self: t_View) : t_Option
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  function new (auth'0: t_Option) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_FMap. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_FMap. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function new_auth [@inline:trivial] (auth'0: t_FMap) : t_View = new (C_Some auth'0) unit'
  
  meta "rewrite_def" function new_auth
  
  type t_Resource
  
  function val' (self: t_Resource) : t_View
  
  function view'0 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'0
  
  let rec alloc (r: t_View) (return (x: t_Resource)) = any
    [ return (result: t_Resource) -> {view'0 result = r} (! return {result}) ]
  
  let rec into_inner (self: t_Resource) (return (x: t_Resource)) = any
    [ return (result: t_Resource) -> {result = self} (! return {result}) ]
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  predicate invariant' (self: t_Authority) = auth (view'0 self.t_Authority__0) <> C_None
  
  predicate inv (_1: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_Authority) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 [@inline:trivial] (_1: t_Authority) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'0
  
  let rec new'0 (x: t_Authority) (return (x'0: t_Authority)) = {[@expl:new 'x' type invariant] inv x}
    any [ return (result: t_Authority) -> {inv'0 result} {result = x} (! return {result}) ]
  
  type t_FMap'0
  
  type t_Option'2 = C_None'2 | C_Some'2 t_V
  
  function view'1 (self: t_FMap'0) : Map.map t_K t_Option'2
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'2 = Map.get (view'1 self) k
  
  meta "rewrite_def" function get'0
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) = forall k: t_K. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. ext_eq self other = (self = other)
  
  function index_logic'0 [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. len'0 self >= 0
  
  function map (self: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap'0
  
  axiom map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get'0 (map self f) k]. get'0 (map self f) k
        = match get self k with
          | C_None'0 -> C_None'2
          | C_Some'0 v -> C_Some'2 (index_logic'0 f { f0'0 = k; f1'0 = v })
          end
  
  axiom map_spec'0: forall self: t_FMap, f: Map.map tuple'0 t_V. len'0 (map self f) = len self
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map t_FMap bool) (a: t_FMap) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. (exists x: t_FMap. index_logic'1 p x)
      -> index_logic'1 p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_FMap = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_FMap) -> true)
      end
  
  function view'2 (self: t_Authority) : t_FMap'0 =
    map (unwrap_logic (auth (view'0 self.t_Authority__0))) (fun (__0: tuple'0) -> let {f1'0 = x} = __0 in x.t_Ag__0)
  
  constant empty'0 : t_FMap'0
  
  axiom empty_spec'1: len'0 empty'0 = 0
  
  axiom empty_spec'2: view'1 empty'0 = Const.const (C_None'2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'1 (return (x: t_Authority)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_6 <- new_auth empty ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = alloc {_6} (fun (_ret: t_Resource) -> [ &_5 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = into_inner {_5} (fun (_ret: t_Resource) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_3 <- { t_Authority__0 = _4 } ] s1
      | s1 = new'0 {_3} (fun (_ret: t_Authority) -> [ &r <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = {[@expl:assertion] ext_eq (view'2 r) empty'0} s1 | s1 = [ &_0 <- r ] s2 | s2 = return {_0} ] ]
    [ & _0: t_Authority = Any.any_l ()
    | & r: t_Authority = Any.any_l ()
    | & _3: t_Authority = Any.any_l ()
    | & _4: t_Resource = Any.any_l ()
    | & _5: t_Resource = Any.any_l ()
    | & _6: t_View = Any.any_l () ])
    [ return (result: t_Authority) -> {[@expl:new result type invariant] inv'0 result}
      {[@expl:new ensures] view'2 result = empty'0}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__resource__fmap_view__qyi4074634815133952471__insert (* ghost::resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_V
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_K
  
  type t_FMapInsertLocalUpdate = { t_FMapInsertLocalUpdate__0: t_K; t_FMapInsertLocalUpdate__1: t_Ag }
  
  type t_AuthUpdate = { t_AuthUpdate__0: t_FMapInsertLocalUpdate }
  
  type t_Resource
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_View
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function auth (self: t_View) : t_Option
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Ag
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate premise (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (_3: t_FMap) =
    get from_auth self.t_FMapInsertLocalUpdate__0 = C_None'0
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'0 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'0)
  
  constant unit': t_FMap = empty
  
  axiom unit_spec: forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'0 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Ag. op factor'0 c <> C_Some'0 self
        end
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None'0} -> C_Some'1 x
      | {f0 = C_None'0} -> C_None'1
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl (self: t_Option'0) (other: t_Option'0) = factor'0 other self <> C_None'1
  
  function incl_transitive (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
  axiom incl_op_spec: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. op'0 self other = C_Some'1 comb
      -> incl self comb
  
  type tuple'0 = { f0'0: t_K; f1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'0) (a: tuple'0) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic f { f0'0 = k; f1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {f0'0 = k; f1'0 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some comb
      -> incl'0 self comb
  
  predicate rel (a: t_Option) (f: t_FMap) =
    match a with
      | C_Some a'0 -> incl'0 f a'0
      | C_None -> true
      end
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_FMap. rel (C_None) f
  
  function rel_mono (a: t_Option) (f1'1: t_FMap) (f2: t_FMap) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1'1: t_FMap, f2: t_FMap. rel a f1'1 -> incl'0 f2 f1'1 -> rel a f2
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise'0 (self: t_AuthUpdate) (from: t_View) =
    match auth from with
      | C_Some auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None -> false
      end
  
  function val' (self: t_Resource) : t_View
  
  function view'0 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'0
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  type tuple'1 = { f0'1: t_FMap; f1'1: t_FMap }
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: t_K) (v: t_Ag) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_Ag. view (insert self k v) = Map.set (view self) k (C_Some'0 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_Ag. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function update (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (from_frag: t_FMap) : tuple'1 =
    { f0'1 = insert from_auth self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1;
      f1'1 = insert from_frag self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1 }
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_FMap bool) (a: t_FMap) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. (exists x: t_FMap. index_logic'0 p x)
      -> index_logic'0 p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_FMap = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_FMap) -> true)
      end
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option
  
  function and_then_logic'2 (self: t_Option'2) (f: Map.map t_Option t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple'2 = { f0'2: t_Option; f1'2: t_Option }
  
  function map_logic'0 (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option'2 = match self with
      | C_None -> C_None'2
      | C_Some x -> C_Some'2 (Map.get f x)
      end
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'2 = match { f0'2 = self; f1'2 = other } with
      | {f0'2 = C_None} -> C_Some'2 other
      | {f1'2 = C_None} -> C_Some'2 self
      | {f0'2 = C_Some x; f1'2 = C_Some y} -> map_logic'0 (op'1 x y) (fun (z: t_FMap) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic'2 (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic'2 (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  function frame_preserving (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (from_frag: t_FMap) (frame: t_Option) : ()
  
  axiom frame_preserving_spec:
    forall self: t_FMapInsertLocalUpdate, from_auth: t_FMap, from_frag: t_FMap, frame: t_Option. premise self from_auth from_frag
      -> op'2 (C_Some from_frag) frame = C_Some'2 (C_Some from_auth)
      -> (let {f0'1 = to_auth; f1'1 = to_frag} = update self from_auth from_frag in op'2 (C_Some to_frag) frame
      = C_Some'2 (C_Some to_auth))
  
  function new (auth'0: t_Option) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_FMap. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_FMap. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function update'0 (self: t_AuthUpdate) (from: t_View) (_3: ()) : t_View =
    let from_auth = unwrap_logic (auth from) in let {f0'1 = auth'0; f1'1 = frag'0} = update self.t_AuthUpdate__0 from_auth (frag from) in let _ = frame_preserving self.t_AuthUpdate__0 from_auth (frag from) (factor'1 from_auth (frag from)) in new (C_Some auth'0) frag'0
  
  axiom update_spec: forall self: t_AuthUpdate, from: t_View, _3: (). premise'0 self from
      -> (let {f0'1 = auth'0; f1'1 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in rel (C_Some auth'0) frag'0)
  
  let rec update'1 (self: MutBorrow.t t_Resource) (upd: t_AuthUpdate) (return (x: ())) =
    {[@expl:update requires] premise'0 upd (view'0 self.current)}
    any
    [ return (result: ()) -> {id self.final = id self.current}
      {view'0 self.final = update'0 upd (view'0 self.current) result}
      (! return {result}) ]
  
  type t_FMap'0
  
  type t_Option'3 = C_None'3 | C_Some'3 t_V
  
  function view'1 (self: t_FMap'0) : Map.map t_K t_Option'3
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'3 = Map.get (view'1 self) k
  
  meta "rewrite_def" function get'0
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) = forall k: t_K. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. ext_eq self other = (self = other)
  
  function index_logic'1 [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. len'0 self >= 0
  
  function map (self: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap'0
  
  axiom map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get'0 (map self f) k]. get'0 (map self f) k
        = match get self k with
          | C_None'0 -> C_None'3
          | C_Some'0 v -> C_Some'3 (index_logic'1 f { f0'0 = k; f1'0 = v })
          end
  
  axiom map_spec'0: forall self: t_FMap, f: Map.map tuple'0 t_V. len'0 (map self f) = len self
  
  function view'2 (self: t_Authority) : t_FMap'0 =
    map (unwrap_logic (auth (view'0 self.t_Authority__0))) (fun (__0: tuple'0) -> let {f1'0 = x} = __0 in x.t_Ag__0)
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) = get'0 self k <> C_None'3
  
  meta "rewrite_def" predicate contains'0
  
  function insert'0 (self: t_FMap'0) (k: t_K) (v: t_V) : t_FMap'0
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_K, v: t_V. view'1 (insert'0 self k v)
      = Map.set (view'1 self) k (C_Some'3 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_K, v: t_V. len'0 (insert'0 self k v)
      = (if contains'0 self k then len'0 self else len'0 self + 1)
  
  predicate invariant' (self: t_Authority) = auth (view'0 self.t_Authority__0) <> C_None
  
  predicate inv (_1: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Authority) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_Authority) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_Authority) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  type t_Option'4 = C_None'4 | C_Some'4 t_View
  
  function and_then_logic'3 (self: t_Option'4) (f: Map.map t_View t_Option'4) : t_Option'4 = match self with
      | C_None'4 -> C_None'4
      | C_Some'4 x -> Map.get f x
      end
  
  function op'3 (self: t_View) (other: t_View) : t_Option'4 = match op'1 (frag self) (frag other) with
      | C_Some f -> match { f0'2 = auth self; f1'2 = auth other } with
        | {f0'2 = C_None; f1'2 = a} -> if rel a f then C_Some'4 (new a f) else C_None'4
        | {f0'2 = a; f1'2 = C_None} -> if rel a f then C_Some'4 (new a f) else C_None'4
        | _ -> C_None'4
        end
      | C_None -> C_None'4
      end
  
  function associative'3 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'3:
    forall a: t_View, b: t_View, c: t_View. and_then_logic'3 (op'3 a b) (fun (ab: t_View) -> op'3 ab c)
      = and_then_logic'3 (op'3 b c) (fun (bc: t_View) -> op'3 a bc)
  
  function commutative'3 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'3: forall a: t_View, b: t_View. op'3 a b = op'3 b a
  
  function new_frag [@inline:trivial] (frag'0: t_FMap) : t_View = new (C_None) frag'0
  
  meta "rewrite_def" function new_frag
  
  function core (self: t_Ag) : t_Option'0 = C_Some'0 self
  
  axiom core_spec: forall self: t_Ag. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core_total (self: t_FMap) : t_FMap =
    let r = filter_map self (fun (__0: tuple'0) -> let {f1'0 = v} = __0 in core v) in r
  
  axiom core_total_spec: forall self: t_FMap. op'1 (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. op'1 (core_total self) self = C_Some self
  
  function core_total'0 (self: t_View) : t_View = new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. op'3 (core_total'0 self) (core_total'0 self)
      = C_Some'4 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. op'3 (core_total'0 self) self = C_Some'4 self
  
  function core'0 (self: t_View) : t_Option'4 = C_Some'4 (core_total'0 self)
  
  axiom core_spec'0: forall self: t_View. match core'0 self with
        | C_Some'4 c -> op'3 c c = C_Some'4 c /\ op'3 c self = C_Some'4 self
        | C_None'4 -> true
        end
  
  let rec core'1 (self: t_Resource) (return (x: t_Resource)) = {[@expl:core requires] core'0 (view'0 self) <> C_None'4}
    any
    [ return (result: t_Resource) -> {id result = id self}
      {C_Some'4 (view'0 result) = core'0 (view'0 self)}
      (! return {result}) ]
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  predicate invariant''1 (self: t_Fragment) =
    get (frag (view'0 self.t_Fragment__0)) self.t_Fragment__1 = C_Some'0 { t_Ag__0 = self.t_Fragment__2 }
  
  predicate inv'1 (_1: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x = invariant''1 x
  
  function id'0 (self: t_Authority) : t_Id = id self.t_Authority__0
  
  type tuple'3 = { f0'3: t_K; f1'3: t_V }
  
  function view'3 (self: t_Fragment) : tuple'3 = { f0'3 = self.t_Fragment__1; f1'3 = self.t_Fragment__2 }
  
  function id'1 (self: t_Fragment) : t_Id = id self.t_Fragment__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert'1 (self: MutBorrow.t t_Authority) (k: t_K) (v: t_V) (return (x: t_Fragment)) =
    {[@expl:insert 'self' type invariant] inv'0 self}
    {[@expl:insert requires] not contains'0 (view'2 self.current) k}
    (! bb0
    [ bb0 = s0 [ s0 = [ &s <- self.current ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_16 <- { t_Ag__0 = v } ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_14 <- { t_FMapInsertLocalUpdate__0 = k; t_FMapInsertLocalUpdate__1 = _16 } ] s1
      | s1 = [ &_13 <- { t_AuthUpdate__0 = _14 } ] s2
      | s2 = MutBorrow.borrow_final <t_Resource> {self.current.t_Authority__0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Resource) ->
            [ &_12 <- _ret ] [ &self <- { self with current = { t_Authority__0 = _ret.final } } ] s3)
      | s3 = update'1 {_12} {_13} (fun (_ret: ()) -> [ &_11 <- _ret ] s4)
      | s4 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] ext_eq (view'2 self.current) (insert'0 (view'2 s) k v)} s1
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve self}- s3
      | s3 = core'1 {self.current.t_Authority__0} (fun (_ret: t_Resource) -> [ &_20 <- _ret ] s4)
      | s4 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- { t_Fragment__0 = _20; t_Fragment__1 = k; t_Fragment__2 = v } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Fragment = Any.any_l ()
    | & self: MutBorrow.t t_Authority = self
    | & k: t_K = k
    | & v: t_V = v
    | & s: t_Authority = Any.any_l ()
    | & _11: () = Any.any_l ()
    | & _12: MutBorrow.t t_Resource = Any.any_l ()
    | & _13: t_AuthUpdate = Any.any_l ()
    | & _14: t_FMapInsertLocalUpdate = Any.any_l ()
    | & _16: t_Ag = Any.any_l ()
    | & _20: t_Resource = Any.any_l () ])
    [ return (result: t_Fragment) -> {[@expl:insert result type invariant] inv'1 result}
      {[@expl:insert ensures #0] view'2 self.final = insert'0 (view'2 self.current) k v}
      {[@expl:insert ensures #1] id'0 self.final = id'0 self.current}
      {[@expl:insert ensures #2] view'3 result = { f0'3 = k; f1'3 = v }}
      {[@expl:insert ensures #3] id'1 result = id'0 self.current}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__resource__fmap_view__qyi4074634815133952471__contains (* ghost::resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Authority = { t_Authority__0: t_Resource }
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  type t_View
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0 = C_None'0 | C_Some'0 t_FMap
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Ag
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 = match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 = match { f0 = self; f1 = other } with
      | {f0 = C_None'1} -> C_Some'2 other
      | {f1 = C_None'1} -> C_Some'2 self
      | {f0 = C_Some'1 x; f1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'0: forall a: t_Option'1, b: t_Option'1. op'0 a b = op'0 b a
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'2)
      -> (forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = empty
  
  axiom unit_spec: forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
        end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None'1} -> C_Some'2 x
      | {f0 = C_None'1} -> C_None'2
      | {f0 = C_Some'1 x; f1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) = factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. op'0 self other = C_Some'2 comb
      -> incl self comb
  
  type tuple'0 = { f0'0: t_K; f1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option'1. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'1 -> C_None'1
          | C_Some'1 v -> index_logic f { f0'0 = k; f1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {f0'0 = k; f1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
        | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some'0 comb
      -> incl'0 self comb
  
  predicate rel (a: t_Option'0) (f: t_FMap) =
    match a with
      | C_Some'0 a'0 -> incl'0 f a'0
      | C_None'0 -> true
      end
  
  function rel_unit (a: t_Option'0) : ()
  
  axiom rel_unit_spec: forall a: t_Option'0. rel a unit'
  
  function rel_none (a: t_Option'0) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_FMap. rel (C_None'0) f
  
  function rel_mono (a: t_Option'0) (f1'1: t_FMap) (f2: t_FMap) : ()
  
  axiom rel_mono_spec: forall a: t_Option'0, f1'1: t_FMap, f2: t_FMap. rel a f1'1 -> incl'0 f2 f1'1 -> rel a f2
  
  function auth (self: t_View) : t_Option'0
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'1 = { f0'1: t_Option'0; f1'1: t_Option'0 }
  
  function new (auth'0: t_Option'0) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option'0, frag'0: t_FMap. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'0, frag'0: t_FMap. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'2 (self: t_View) (other: t_View) : t_Option = match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'0; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'0} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. op'2 a b = op'2 b a
  
  function new_frag [@inline:trivial] (frag'0: t_FMap) : t_View = new (C_None'0) frag'0
  
  meta "rewrite_def" function new_frag
  
  function factor'2 (self: t_View) (factor'3: t_View) : t_Option = match factor'1 (frag self) (frag factor'3) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth factor'3 } with
        | {f0'1 = C_Some'0 a; f1'1 = C_None'0} -> C_Some (new (C_Some'0 a) f)
        | {f0'1 = a1; f1'1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. match factor'2 self factor'3 with
        | C_Some c -> op'2 factor'3 c = C_Some self
        | C_None -> forall c: t_View. op'2 factor'3 c <> C_Some self
        end
  
  predicate incl'1 (self: t_View) (other: t_View) = factor'2 other self <> C_None
  
  function incl_transitive'1 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. incl'1 a b -> incl'1 b c -> incl'1 a c
  
  function incl_op'1 (self: t_View) (other: t_View) (comb: t_View) : ()
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. op'2 self other = C_Some comb
      -> incl'1 self comb
  
  predicate incl_eq (self: t_View) (other: t_View) = self = other \/ incl'1 self other
  
  function val' (self: t_Resource) : t_View
  
  function view'0 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'0
  
  let rec join_shared (self: t_Resource) (other: t_Resource) (return (x: t_Resource)) =
    {[@expl:join_shared requires] id self = id other}
    any
    [ return (result: t_Resource) -> {id result = id self}
      {incl_eq (view'0 self) (view'0 result) /\ incl_eq (view'0 other) (view'0 result)}
      (! return {result}) ]
  
  type tuple'2 = { f0'2: t_K; f1'2: t_V }
  
  function view'1 (self: t_Fragment) : tuple'2 = { f0'2 = self.t_Fragment__1; f1'2 = self.t_Fragment__2 }
  
  predicate invariant' (self: t_Authority) = auth (view'0 self.t_Authority__0) <> C_None'0
  
  predicate inv (_1: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_Authority) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 [@inline:trivial] (_1: t_Authority) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''1 (self: t_Fragment) =
    get (frag (view'0 self.t_Fragment__0)) self.t_Fragment__1 = C_Some'1 { t_Ag__0 = self.t_Fragment__2 }
  
  predicate inv'1 (_1: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: t_Fragment) = inv'1 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 [@inline:trivial] (_1: t_Fragment) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'2
  
  function id'0 (self: t_Authority) : t_Id = id self.t_Authority__0
  
  function id'1 (self: t_Fragment) : t_Id = id self.t_Fragment__0
  
  type t_FMap'0
  
  type t_Option'3 = C_None'3 | C_Some'3 t_V
  
  function view'2 (self: t_FMap'0) : Map.map t_K t_Option'3
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'3 = Map.get (view'2 self) k
  
  meta "rewrite_def" function get'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function len'0 (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. len'0 self >= 0
  
  function map (self: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap'0
  
  axiom map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get'0 (map self f) k]. get'0 (map self f) k
        = match get self k with
          | C_None'1 -> C_None'3
          | C_Some'1 v -> C_Some'3 (index_logic'0 f { f0'0 = k; f1'0 = v })
          end
  
  axiom map_spec'0: forall self: t_FMap, f: Map.map tuple'0 t_V. len'0 (map self f) = len self
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map t_FMap bool) (a: t_FMap) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. (exists x: t_FMap. index_logic'1 p x)
      -> index_logic'1 p (such_that p)
  
  function unwrap_logic (self: t_Option'0) : t_FMap = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_FMap) -> true)
      end
  
  function view'3 (self: t_Authority) : t_FMap'0 =
    map (unwrap_logic (auth (view'0 self.t_Authority__0))) (fun (__0: tuple'0) -> let {f1'0 = x} = __0 in x.t_Ag__0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains (self: t_Authority) (frag'0: t_Fragment) (return (x: ())) =
    {[@expl:contains 'self' type invariant] inv'0 self}
    {[@expl:contains 'frag' type invariant] inv'2 frag'0}
    {[@expl:contains requires] id'0 self = id'1 frag'0}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- frag'0.t_Fragment__0 ] s1
      | s1 = join_shared {self.t_Authority__0} {_8} (fun (_ret: t_Resource) -> [ &new_resource <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] get (frag (view'0 new_resource)) (view'1 frag'0).f0'2
        = C_Some'1 { t_Ag__0 = (view'1 frag'0).f1'2 }}
        s1
      | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: t_Authority = self
    | & frag'0: t_Fragment = frag'0
    | & new_resource: t_Resource = Any.any_l ()
    | & _8: t_Resource = Any.any_l () ])
    [ return (result: ()) -> {[@expl:contains ensures] get'0 (view'3 self) (view'1 frag'0).f0'2
      = C_Some'3 ((view'1 frag'0).f1'2)}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__resource__fmap_view__qyi11277603908270514611__clone (* <ghost::resource::fmap_view::Fragment<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_View
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0 = C_None'0 | C_Some'0 t_FMap
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Ag
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function map_logic (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2 = match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option'1 = if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 = match { f0 = self; f1 = other } with
      | {f0 = C_None'1} -> C_Some'2 other
      | {f1 = C_None'1} -> C_Some'2 self
      | {f0 = C_Some'1 x; f1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'0: forall a: t_Option'1, b: t_Option'1. op'0 a b = op'0 b a
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'2)
      -> (forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = empty
  
  axiom unit_spec: forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option'1 = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
        end
  
  function factor'0 (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None'1} -> C_Some'2 x
      | {f0 = C_None'1} -> C_None'2
      | {f0 = C_Some'1 x; f1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl (self: t_Option'1) (other: t_Option'1) = factor'0 other self <> C_None'2
  
  function incl_transitive (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. op'0 self other = C_Some'2 comb
      -> incl self comb
  
  type tuple'0 = { f0'0: t_K; f1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option'1. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'1 -> C_None'1
          | C_Some'1 v -> index_logic f { f0'0 = k; f1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {f0'0 = k; f1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
        | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some'0 comb
      -> incl'0 self comb
  
  predicate rel (a: t_Option'0) (f: t_FMap) =
    match a with
      | C_Some'0 a'0 -> incl'0 f a'0
      | C_None'0 -> true
      end
  
  function rel_unit (a: t_Option'0) : ()
  
  axiom rel_unit_spec: forall a: t_Option'0. rel a unit'
  
  function rel_none (a: t_Option'0) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_FMap. rel (C_None'0) f
  
  function rel_mono (a: t_Option'0) (f1'1: t_FMap) (f2: t_FMap) : ()
  
  axiom rel_mono_spec: forall a: t_Option'0, f1'1: t_FMap, f2: t_FMap. rel a f1'1 -> incl'0 f2 f1'1 -> rel a f2
  
  function auth (self: t_View) : t_Option'0
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'1 = { f0'1: t_Option'0; f1'1: t_Option'0 }
  
  function new (auth'0: t_Option'0) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option'0, frag'0: t_FMap. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'0, frag'0: t_FMap. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'2 (self: t_View) (other: t_View) : t_Option = match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'0; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'0} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'2:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. op'2 a b = op'2 b a
  
  function new_frag [@inline:trivial] (frag'0: t_FMap) : t_View = new (C_None'0) frag'0
  
  meta "rewrite_def" function new_frag
  
  function core (self: t_Ag) : t_Option'1 = C_Some'1 self
  
  axiom core_spec: forall self: t_Ag. match core self with
        | C_Some'1 c -> op c c = C_Some'1 c /\ op c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  function core_total (self: t_FMap) : t_FMap =
    let r = filter_map self (fun (__0: tuple'0) -> let {f1'0 = v} = __0 in core v) in r
  
  axiom core_total_spec: forall self: t_FMap. op'1 (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. op'1 (core_total self) self = C_Some'0 self
  
  function core_total'0 (self: t_View) : t_View = new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. op'2 (core_total'0 self) (core_total'0 self)
      = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. op'2 (core_total'0 self) self = C_Some self
  
  function core'0 (self: t_View) : t_Option = C_Some (core_total'0 self)
  
  axiom core_spec'0: forall self: t_View. match core'0 self with
        | C_Some c -> op'2 c c = C_Some c /\ op'2 c self = C_Some self
        | C_None -> true
        end
  
  function val' (self: t_Resource) : t_View
  
  function view'0 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'0
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  let rec core'1 (self: t_Resource) (return (x: t_Resource)) = {[@expl:core requires] core'0 (view'0 self) <> C_None}
    any
    [ return (result: t_Resource) -> {id result = id self}
      {C_Some (view'0 result) = core'0 (view'0 self)}
      (! return {result}) ]
  
  predicate invariant' (self: t_Fragment) =
    get (frag (view'0 self.t_Fragment__0)) self.t_Fragment__1 = C_Some'1 { t_Ag__0 = self.t_Fragment__2 }
  
  predicate inv (_1: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_Fragment) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 [@inline:trivial] (_1: t_Fragment) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'0
  
  type tuple'2 = { f0'2: t_K; f1'2: t_V }
  
  function view'1 (self: t_Fragment) : tuple'2 = { f0'2 = self.t_Fragment__1; f1'2 = self.t_Fragment__2 }
  
  function id'0 (self: t_Fragment) : t_Id = id self.t_Fragment__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: t_Fragment) (return (x: t_Fragment)) = {[@expl:clone 'self' type invariant] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = core'1 {self.t_Fragment__0} (fun (_ret: t_Resource) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_0 <- { t_Fragment__0 = _4; t_Fragment__1 = self.t_Fragment__1; t_Fragment__2 = self.t_Fragment__2 } ]
        s1
      | s1 = return {_0} ] ]
    [ & _0: t_Fragment = Any.any_l () | & self: t_Fragment = self | & _4: t_Resource = Any.any_l () ])
    [ return (result: t_Fragment) -> {[@expl:clone result type invariant] inv result}
      {[@expl:clone ensures #0] view'1 result = view'1 self}
      {[@expl:clone ensures #1] id'0 result = id'0 self}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__resource__m__qyi7338446641796430796__split_off (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  
  type t_Resource
  
  let rec dummy (return (x: t_Resource)) = any [ return (result: t_Resource) -> (! return {result}) ]
  
  let rec replace (dest: MutBorrow.t t_Resource) (src: t_Resource) (return (x: t_Resource)) = any
    [ return (result: t_Resource) -> {dest.final = src} {result = dest.current} (! return {result}) ]
  
  type t_R
  
  type tuple = { f0: t_Resource; f1: t_Resource }
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  predicate incl_eq (self: t_R) (other: t_R) = self = other \/ incl self other
  
  predicate incl_eq_op (a: t_R) (b: t_R) (x: t_R) =
    match op a b with
      | C_None -> false
      | C_Some ab -> incl_eq ab x
      end
  
  function val' (self: t_Resource) : t_R
  
  function view [@inline:trivial] (self: t_Resource) : t_R = val' self
  
  meta "rewrite_def" function view
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  let rec split (self: t_Resource) (a: t_R) (b: t_R) (return (x: tuple)) =
    {[@expl:split requires] incl_eq_op a b (view self)}
    any
    [ return (result: tuple) -> {id result.f0 = id self /\ id result.f1 = id self}
      {view result.f0 = a}
      {view result.f1 = b}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_Resource) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_1: t_Resource)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec split_off (self: MutBorrow.t t_Resource) (r: t_R) (s: t_R) (return (x: t_Resource)) =
    {[@expl:split_off requires] incl_eq_op r s (view self.current)}
    (! bb0
    [ bb0 = s0 [ s0 = dummy (fun (_ret: t_Resource) -> [ &_10 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <t_Resource> {self.current}
          (fun (_ret: MutBorrow.t t_Resource) -> [ &_9 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = replace {_9} {_10} (fun (_ret: t_Resource) -> [ &this <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = split {this} {r} {s} (fun (_ret: tuple) -> [ &_13 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &r'0 <- _13.f0 ] s1
      | s1 = [ &this'0 <- _13.f1 ] s2
      | s2 = MutBorrow.borrow_final <t_Resource> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Resource) -> [ &_18 <- _ret ] [ &self <- { self with current = _ret.final } ] s3)
      | s3 = replace {_18} {this'0} (fun (_ret: t_Resource) -> [ &_17 <- _ret ] s4)
      | s4 = bb4 ]
    | bb4 = s0 [ s0 = -{resolve self}- s1 | s1 = -{resolve'0 _17}- s2 | s2 = [ &_0 <- r'0 ] s3 | s3 = return {_0} ] ]
    [ & _0: t_Resource = Any.any_l ()
    | & self: MutBorrow.t t_Resource = self
    | & r: t_R = r
    | & s: t_R = s
    | & this: t_Resource = Any.any_l ()
    | & _9: MutBorrow.t t_Resource = Any.any_l ()
    | & _10: t_Resource = Any.any_l ()
    | & r'0: t_Resource = Any.any_l ()
    | & this'0: t_Resource = Any.any_l ()
    | & _13: tuple = Any.any_l ()
    | & _17: t_Resource = Any.any_l ()
    | & _18: MutBorrow.t t_Resource = Any.any_l () ])
    [ return (result: t_Resource) -> {[@expl:split_off ensures #0] id self.final = id self.current
      /\ id result = id self.current}
      {[@expl:split_off ensures #1] view self.final = s}
      {[@expl:split_off ensures #2] view result = r}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__resource__m__qyi7338446641796430796__join_in (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  
  type t_Resource
  
  let rec dummy (return (x: t_Resource)) = any [ return (result: t_Resource) -> (! return {result}) ]
  
  let rec replace (dest: MutBorrow.t t_Resource) (src: t_Resource) (return (x: t_Resource)) = any
    [ return (result: t_Resource) -> {dest.final = src} {result = dest.current} (! return {result}) ]
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  type t_R
  
  function val' (self: t_Resource) : t_R
  
  function view [@inline:trivial] (self: t_Resource) : t_R = val' self
  
  meta "rewrite_def" function view
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  let rec join (self: t_Resource) (other: t_Resource) (return (x: t_Resource)) = {[@expl:join requires] id self
    = id other}
    any
    [ return (result: t_Resource) -> {id result = id self}
      {C_Some (view result) = op (view self) (view other)}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_Resource) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 (_1: t_Resource)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec join_in (self: MutBorrow.t t_Resource) (other: t_Resource) (return (x: ())) =
    {[@expl:join_in requires] id self.current = id other}
    (! bb0
    [ bb0 = s0 [ s0 = dummy (fun (_ret: t_Resource) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <t_Resource> {self.current}
          (fun (_ret: MutBorrow.t t_Resource) -> [ &_7 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = replace {_7} {_8} (fun (_ret: t_Resource) -> [ &this <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = join {this} {other} (fun (_ret: t_Resource) -> [ &this'0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Resource) -> [ &_13 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = replace {_13} {this'0} (fun (_ret: t_Resource) -> [ &_12 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = -{resolve self}- s1 | s1 = -{resolve'0 _12}- s2 | s2 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Resource = self
    | & other: t_Resource = other
    | & this: t_Resource = Any.any_l ()
    | & _7: MutBorrow.t t_Resource = Any.any_l ()
    | & _8: t_Resource = Any.any_l ()
    | & this'0: t_Resource = Any.any_l ()
    | & _12: t_Resource = Any.any_l ()
    | & _13: MutBorrow.t t_Resource = Any.any_l () ])
    [ return (result: ()) -> {[@expl:join_in ensures #0] id self.final = id self.current}
      {[@expl:join_in ensures #1] C_Some (view self.final) = op (view self.current) (view other)}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__resource__m__qyi7338446641796430796__weaken (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  predicate index_logic [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. (exists x: t_R. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_R = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_R) -> true)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  type t_Resource
  
  function val' (self: t_Resource) : t_R
  
  function view [@inline:trivial] (self: t_Resource) : t_R = val' self
  
  meta "rewrite_def" function view
  
  predicate incl_eq (self: t_R) (other: t_R) = self = other \/ incl self other
  
  predicate incl_eq_op (a: t_R) (b: t_R) (x: t_R) =
    match op a b with
      | C_None -> false
      | C_Some ab -> incl_eq ab x
      end
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  let rec split_off (self: MutBorrow.t t_Resource) (r: t_R) (s: t_R) (return (x: t_Resource)) =
    {[@expl:split_off requires] incl_eq_op r s (view self.current)}
    any
    [ return (result: t_Resource) -> {id self.final = id self.current /\ id result = id self.current}
      {view self.final = s}
      {view result = r}
      (! return {result}) ]
  
  predicate resolve (_1: t_Resource)
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Resource) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec weaken (self: MutBorrow.t t_Resource) (target: t_R) (return (x: ())) =
    {[@expl:weaken requires] incl target (view self.current)}
    (! bb0
    [ bb0 = s0 [ s0 = [ &f <- unwrap_logic (factor (view self.current) target) ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Resource) -> [ &_9 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = split_off {_9} {f} {target} (fun (_ret: t_Resource) -> [ &_8 <- _ret ] s2)
      | s2 = -{resolve _8}- s3
      | s3 = bb2 ]
    | bb2 = s0 [ s0 = -{resolve'0 self}- s1 | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Resource = self
    | & target: t_R = target
    | & f: t_R = Any.any_l ()
    | & _8: t_Resource = Any.any_l ()
    | & _9: MutBorrow.t t_Resource = Any.any_l () ])
    [ return (result: ()) -> {[@expl:weaken ensures #0] id self.final = id self.current}
      {[@expl:weaken ensures #1] view self.final = target}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__resource__m__qyi7338446641796430796__update (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use set.Set
  use map.Map
  use creusot.prelude.Any
  
  type t_U
  
  predicate inv (_1: t_U)
  
  predicate resolve (_1: t_U)
  
  type t_Resource
  
  type t_R
  
  function val' (self: t_Resource) : t_R
  
  function view [@inline:trivial] (self: t_Resource) : t_R = val' self
  
  meta "rewrite_def" function view
  
  type t_Choice
  
  predicate premise (self: t_U) (from: t_R)
  
  function update (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  predicate contains [@inline:trivial] (self: Set.set t_R) (e: t_R) = Set.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate index_logic [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_logic p x)
      -> index_logic p (such_that p)
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function frame_preserving (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_spec: forall self: t_U, from: t_R, frame: t_R. premise self from
      -> op from frame <> C_None -> op (update self from (frame_preserving self from frame)) frame <> C_None
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic'0 (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  let rec update_raw (self: MutBorrow.t t_Resource) (target_s: Set.set t_R) (return (x: t_R)) =
    {[@expl:update_raw requires] forall f: t_Option. op'0 (C_Some (view self.current)) f <> C_None'0
      -> (exists x: t_R. contains target_s x /\ op'0 (C_Some x) f <> C_None'0)}
    any
    [ return (result: t_R) -> {id self.final = id self.current}
      {contains target_s result}
      {view self.final = result}
      (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Resource) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec update'0 (self: MutBorrow.t t_Resource) (upd: t_U) (return (x: t_Choice)) =
    {[@expl:update 'upd' type invariant] inv upd}
    {[@expl:update requires] premise upd (view self.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:type invariant] inv upd} s1
      | s1 = -{resolve upd}- s2
      | s2 = [ &v <- view self.current ] s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = [ &target_s <- fun (r'0: t_R) -> exists ch: t_Choice. update upd v ch = r'0 ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:assertion] contains target_s (update upd v (such_that (fun (__0: t_Choice) -> true)))} s1
      | s1 = {[@expl:assertion] forall f: t_R. op v f <> C_None
          -> (exists ch: t_Choice. op (update upd v ch) f <> C_None)}
        s2
      | s2 = [ &_14 <- () ] s3
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Resource) -> [ &_17 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = update_raw {_17} {target_s} (fun (_ret: t_R) -> [ &r <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = -{resolve'0 self}- s1
      | s1 = [ &_0 <- such_that (fun (ch: t_Choice) -> update upd v ch = r) ] s2
      | s2 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_Choice = Any.any_l ()
    | & self: MutBorrow.t t_Resource = self
    | & upd: t_U = upd
    | & v: t_R = Any.any_l ()
    | & target_s: Set.set t_R = Any.any_l ()
    | & _14: () = Any.any_l ()
    | & r: t_R = Any.any_l ()
    | & _17: MutBorrow.t t_Resource = Any.any_l () ])
    [ return (result: t_Choice) -> {[@expl:update ensures #0] id self.final = id self.current}
      {[@expl:update ensures #1] view self.final = update upd (view self.current) result}
      (! return {result}) ]
end
module M_creusot_contracts__ghost__qyi11517682701084838082__clone (* <ghost::Ghost<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  let rec deref (self: t_T) (return (x: t_T)) = {[@expl:deref 'self' type invariant] inv'1 self}
    any [ return (result: t_T) -> {inv'2 result} {result = self} (! return {result}) ]
  
  let rec new (x: t_T) (return (x'0: t_T)) = {[@expl:new 'x' type invariant] inv x}
    any [ return (result: t_T) -> {inv'0 result} {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: t_T) (return (x: t_T)) = {[@expl:clone 'self' type invariant] inv'1 self}
    (! bb0
    [ bb0 = s0 [ s0 = deref {self} (fun (_ret: t_T) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = new {_4} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_T = Any.any_l () | & self: t_T = self | & _4: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:clone result type invariant] inv'0 result}
      {[@expl:clone ensures] result = self}
      (! return {result}) ]
end
module M_creusot_contracts__invariant__qyi11000281680484769800__clone (* <invariant::Subset<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Subset
  
  type t_T
  
  predicate invariant' (self: t_T)
  
  function view (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function view_inj (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. view self = view other -> self = other
  
  predicate inv (_1: t_T)
  
  axiom inv_axiom: forall x: t_T [inv x]. inv x -> invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'0
  
  let rec deref (self: t_Subset) (return (x: t_T)) = any
    [ return (result: t_T) -> {inv'0 result} {result = view self} (! return {result}) ]
  
  predicate precondition (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
      -> precondition () args
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  let rec clone' (self_: t_T) (return (x: t_T)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_T) -> {postcondition_once () self_ result} (! return {result}) ]
  
  function new_logic (x: t_T) : t_Subset
  
  axiom new_logic_spec: forall x: t_T. invariant' x -> view (new_logic x) = x
  
  let rec new (x: t_T) (return (x'0: t_Subset)) = {[@expl:new 'x' type invariant] inv x}
    any [ return (result: t_Subset) -> {result = new_logic x} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''0 (self: t_Subset) (return (x: t_Subset)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref {self} (fun (_ret: t_T) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = clone' {_7} (fun (_ret: t_T) -> [ &_5 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new {_5} (fun (_ret: t_Subset) -> [ &_0 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_Subset = Any.any_l ()
    | & self: t_Subset = self
    | & _3: () = Any.any_l ()
    | & _5: t_T = Any.any_l ()
    | & _7: t_T = Any.any_l () ])
    [ return (result: t_Subset) -> {[@expl:clone ensures] postcondition () (view self) (view result)}
      (! return {result}) ]
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__ext_eq (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function view_inj (self: t_FMap) (other: t_FMap) : () = ()
  
  axiom view_inj_spec: forall self: t_FMap, other: t_FMap. view self = view other -> self = other
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap
  
  constant other : t_FMap
  
  predicate ext_eq (self: t_FMap) (other: t_FMap)
  
  goal vc_ext_eq: [@expl:ext_eq ensures] (forall k: t_K. get self k = get other k) = (self = other)
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__filter (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate index_logic [@inline:trivial] (self: Map.map tuple bool) (a: tuple) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function index_logic'0 [@inline:trivial] (self: Map.map tuple t_Option) (a: tuple) : t_Option = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function filter_map (self: t_FMap) (f: Map.map tuple t_Option) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple t_Option. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None -> C_None
          | C_Some v -> index_logic'0 f { f0 = k; f1 = v }
          end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap
  
  constant p : Map.map tuple bool
  
  function filter (self: t_FMap) (p: Map.map tuple bool) : t_FMap
  
  goal vc_filter: (forall __0: tuple. let {f0 = k; f1 = v} = __0 in true)
    /\ ((forall k: t_K [get (filter_map self (fun (__0: tuple) -> let {f0 = k'0; f1 = v} = __0 in if index_logic p { f0 = k'0;
                                                                                                                     f1 = v } then
          C_Some v
        else
          C_None
        )) k]. get (filter_map self (fun (__0: tuple) -> let {f0 = k'0; f1 = v} = __0 in if index_logic p { f0 = k'0;
                                                                                                            f1 = v } then
            C_Some v
          else
            C_None
          )) k
        = match get self k with
          | C_None -> C_None
          | C_Some v -> index_logic'0 (fun (__0: tuple) -> let {f0 = k'0; f1 = v'0} = __0 in if index_logic p { f0 = k'0;
                                                                                                                f1 = v'0 } then
            C_Some v'0
          else
            C_None
          ) { f0 = k; f1 = v }
          end)
    -> (let result = filter_map self (fun (__0: tuple) -> let {f0 = k; f1 = v} = __0 in if index_logic p { f0 = k;
                                                                                                           f1 = v } then
      C_Some v
    else
      C_None
    ) in [@expl:filter ensures] forall k: t_K [get result k]. get result k
      = match get self k with
        | C_None -> C_None
        | C_Some v -> if index_logic p { f0 = k; f1 = v } then C_Some v else C_None
        end))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__contains_ghost (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option'0) : t_V = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_FMap) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_FMap) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''1 [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 [@inline:trivial] (_1: t_K) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate invariant''2 [@inline:trivial] (self: t_V) = inv'0 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 [@inline:trivial] (_1: t_V) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'4
  
  predicate inv'5 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_V) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_K) (return (x: t_Option)) =
    {[@expl:get_ghost 'self' type invariant] inv'2 self}
    {[@expl:get_ghost 'key' type invariant] inv'3 key}
    any
    [ return (result: t_Option) -> {inv'5 result}
      {result = map_logic (get self key) (fun (v: t_V) -> v)}
      (! return {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Option) = inv'5 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'6 [@inline:trivial] (_1: t_Option) = invariant''3 _1
  
  meta "rewrite_def" predicate inv'6
  
  let rec is_some (self_: t_Option) (return (x: bool)) = {[@expl:is_some 'self_' type invariant] inv'6 self_}
    any [ return (result: bool) -> {result = (self_ <> C_None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains_ghost (self: t_FMap) (key: t_K) (return (x: bool)) =
    {[@expl:contains_ghost 'self' type invariant] inv'2 self}
    {[@expl:contains_ghost 'key' type invariant] inv'3 key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost {self} {key} (fun (_ret: t_Option) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = is_some {_5} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self: t_FMap = self | & key: t_K = key | & _5: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:contains_ghost ensures] result = contains self key} (! return {result}) ]
end
module M_creusot_contracts__logic__fmap__qyi16260369704185797910__index (* <logic::fmap::FMap<K, V> as std::ops::Index<&'a K>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option'0) : t_V = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_FMap) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_FMap) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''1 [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 [@inline:trivial] (_1: t_K) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate invariant''2 [@inline:trivial] (self: t_V) = inv'0 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 [@inline:trivial] (_1: t_V) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'4
  
  predicate inv'5 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_V) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  let rec get_ghost (self: t_FMap) (key: t_K) (return (x: t_Option)) =
    {[@expl:get_ghost 'self' type invariant] inv'2 self}
    {[@expl:get_ghost 'key' type invariant] inv'3 key}
    any
    [ return (result: t_Option) -> {inv'5 result}
      {result = map_logic (get self key) (fun (v: t_V) -> v)}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option) (return (x: t_V)) = {[@expl:unwrap 'self_' type invariant] inv'5 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return (result: t_V) -> {inv'4 result} {C_Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index (self: t_FMap) (key: t_K) (return (x: t_V)) = {[@expl:index 'self' type invariant] inv'2 self}
    {[@expl:index 'key' type invariant] inv'3 key}
    {[@expl:index requires] contains self key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost {self} {key} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_6} (fun (_ret: t_V) -> [ &_5 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- _5 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_V = Any.any_l ()
    | & self: t_FMap = self
    | & key: t_K = key
    | & _5: t_V = Any.any_l ()
    | & _6: t_Option = Any.any_l () ])
    [ return (result: t_V) -> {[@expl:index result type invariant] inv'4 result}
      {[@expl:index ensures] C_Some'0 result = get self key}
      (! return {result}) ]
end
module M_creusot_contracts__logic__fmap__qyi2426308143065609886__into_iter (* <logic::fmap::FMap<K, V> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use map.Map
  
  type t_FMap
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 (_1: t_FMapIter)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMapIter [inv'2 x]. inv'2 x = inv'1 x.t_FMapIter__inner
  
  function view'0 (self: t_FMapIter) : t_FMap = self.t_FMapIter__inner
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter (self: t_FMap) (return (x: t_FMapIter)) = {[@expl:into_iter 'self' type invariant] inv'1 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { t_FMapIter__inner = self } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_FMapIter = Any.any_l () | & self: t_FMap = self ])
    [ return (result: t_FMapIter) -> {[@expl:into_iter result type invariant] inv'2 result}
      {[@expl:into_iter ensures] view'0 result = self}
      (! return {result}) ]
end
module M_creusot_contracts__logic__fmap__qyi17788021891652805456__next (* <logic::fmap::FMapIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  use seq.Seq
  
  type t_FMap
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_FMap) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_FMap) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate inv'3 [@inline:trivial] (_1: tuple) = inv _1.f0 /\ inv'0 _1.f1
  
  meta "rewrite_def" predicate inv'3
  
  predicate inv'4 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'4 x]. inv'4 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'3 a_0
        end
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = ext_eq self empty
  
  function insert (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. view (insert self k v) = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  let rec remove_one_ghost (self: MutBorrow.t t_FMap) (return (x: t_Option'0)) =
    {[@expl:remove_one_ghost 'self' type invariant] inv'2 self}
    any
    [ return (result: t_Option'0) -> {inv'4 result}
      {match result with
        | C_None'0 -> self.current = self.final /\ is_empty self.current
        | C_Some'0 {f0 = k; f1 = v} -> self.current = insert self.final k v /\ not contains self.final k
        end}
      (! return {result}) ]
  
  predicate inv'5 (_1: t_FMapIter)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapIter [inv'5 x]. inv'5 x = inv'1 x.t_FMapIter__inner
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_FMapIter) = inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 [@inline:trivial] (_1: MutBorrow.t t_FMapIter) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'6
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_FMapIter) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  function get'0 (self: Seq.seq tuple) (ix: int) : t_Option'0 = if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  function view'0 (self: t_FMapIter) : t_FMap = self.t_FMapIter__inner
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple) (o: t_FMapIter) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get'0 visited i = C_Some'0 { f0 = k; f1 = v }
        -> not contains (view'0 o) k /\ get (view'0 self) k = C_Some v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get (view'0 o) k = get (view'0 self) k)
  
  function produces_trans (a: t_FMapIter) (ab: Seq.seq tuple) (b: t_FMapIter) (bc: Seq.seq tuple) (c: t_FMapIter) : () =
    let ac = Seq.(++) ab bc in ()
  
  axiom produces_trans_spec:
    forall a: t_FMapIter, ab: Seq.seq tuple, b: t_FMapIter, bc: Seq.seq tuple, c: t_FMapIter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_FMapIter) : () = ()
  
  axiom produces_refl_spec: forall self: t_FMapIter. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate completed (self: MutBorrow.t t_FMapIter) = is_empty (view'0 self.current)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next (self: MutBorrow.t t_FMapIter) (return (x: t_Option'0)) = {[@expl:next 'self' type invariant] inv'6 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self.current.t_FMapIter__inner}
        MutBorrow.borrow_final <t_FMap> {self.current.t_FMapIter__inner}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_FMap) ->
            [ &_3 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = { t_FMapIter__inner = _ret.final } } ] s1)
      | s1 = remove_one_ghost {_3} (fun (_ret: t_Option'0) -> [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'6 self} s1 | s1 = -{resolve self}- s2 | s2 = return {_0} ] ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self: MutBorrow.t t_FMapIter = self
    | & _3: MutBorrow.t t_FMap = Any.any_l () ])
    [ return (result: t_Option'0) -> {[@expl:next result type invariant] inv'4 result}
      {[@expl:next ensures] match result with
        | C_None'0 -> completed self
        | C_Some'0 {f0 = k; f1 = v} -> produces self.current (Seq.singleton { f0 = k; f1 = v }) self.final
        /\ view'0 self.current = insert (view'0 self.final) k v
        end}
      (! return {result}) ]
end
module M_creusot_contracts__logic__fmap__qyi14545271337334171048__produces_refl (* <logic::fmap::FMapIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some tuple
  
  function get (self: Seq.seq tuple) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  function view'0 (self: t_FMapIter) : t_FMap = self.t_FMapIter__inner
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple) (o: t_FMapIter) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get visited i = C_Some { f0 = k; f1 = v }
        -> not contains (view'0 o) k /\ get'0 (view'0 self) k = C_Some'0 v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'0 o) k = get'0 (view'0 self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMapIter
  
  function produces_refl (self: t_FMapIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__logic__fmap__qyi14545271337334171048__produces_trans (* <logic::fmap::FMapIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some tuple
  
  function get (self: Seq.seq tuple) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  function view'0 (self: t_FMapIter) : t_FMap = self.t_FMapIter__inner
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple) (o: t_FMapIter) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get visited i = C_Some { f0 = k; f1 = v }
        -> not contains (view'0 o) k /\ get'0 (view'0 self) k = C_Some'0 v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'0 o) k = get'0 (view'0 self) k)
  
  predicate contains'0 (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMapIter
  
  constant ab : Seq.seq tuple
  
  constant b : t_FMapIter
  
  constant bc : Seq.seq tuple
  
  constant c : t_FMapIter
  
  function produces_trans (a: t_FMapIter) (ab: Seq.seq tuple) (b: t_FMapIter) (bc: Seq.seq tuple) (c: t_FMapIter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (let ac = Seq.(++) ab bc in (forall x: tuple. contains'0 ab x -> contains'0 ac x)
    && (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get ac (i + Seq.length ab) = Seq.get bc i)
    && (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length ac -> (Seq.get ac i).f0 <> k)
        -> (forall i: int. 0 <= i /\ i < Seq.length ab -> (Seq.get ab i).f0 <> k)
        /\ (forall i: int. 0 <= i /\ i < Seq.length bc -> (Seq.get bc i).f0 <> k)
        /\ get'0 (view'0 a) k = get'0 (view'0 b) k /\ get'0 (view'0 b) k = get'0 (view'0 c) k)
    && ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__logic__fmap__qyi11609140033975796267__into_iter (* <&'a logic::fmap::FMap<K, V> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_FMap'0
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_FMap) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_FMap) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains'0
  
  predicate invariant''1 [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 [@inline:trivial] (_1: t_K) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate invariant''2 [@inline:trivial] (self: t_V) = inv'0 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 [@inline:trivial] (_1: t_V) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'4
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec'0: forall p: Map.map t_V bool. (exists x: t_V. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'0) : t_V = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: t_V) -> true)
      end
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_V = unwrap_logic'0 (get'0 self k)
  
  meta "rewrite_def" function lookup'0
  
  function index_logic'2 [@inline:trivial] (self: t_FMap'0) (key: t_K) : t_V = lookup'0 self key
  
  meta "rewrite_def" function index_logic'2
  
  predicate invariant''3 [@inline:trivial] (self: t_FMap'0) =
    forall k: t_K. contains'0 self k -> inv'3 k /\ inv'4 (index_logic'2 self k)
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'5 (_1: t_FMap'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap'0 [inv'5 x]. inv'5 x = invariant''3 x
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. len self >= 0
  
  function len'0 (self: t_FMap) : int
  
  axiom len_spec'0: forall self: t_FMap. len'0 self >= 0
  
  let rec as_ref_ghost (self: t_FMap) (return (x: t_FMap'0)) = {[@expl:as_ref_ghost 'self' type invariant] inv'2 self}
    any
    [ return (result: t_FMap'0) -> {inv'5 result}
      {len result = len'0 self}
      {forall k: t_K, v: t_V. (get self k = C_Some v) = (get'0 result k = C_Some'0 v)}
      (! return {result}) ]
  
  type t_FMapIterRef = { t_FMapIterRef__inner: t_FMap'0 }
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_FMap bool) (a: t_FMap) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'1 (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec'1: forall p: Map.map t_FMap bool. (exists x: t_FMap. index_logic'3 p x)
      -> index_logic'3 p (such_that'1 p)
  
  function view'1 (self: t_FMapIterRef) : t_FMap = such_that'1 (fun (m: t_FMap) -> forall k: t_K, v: t_V. (get m k
        = C_Some v)
      = (get'0 self.t_FMapIterRef__inner k = C_Some'0 v))
  
  predicate inv'6 (_1: t_FMapIterRef)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapIterRef [inv'6 x]. inv'6 x = inv'5 x.t_FMapIterRef__inner
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter (self: t_FMap) (return (x: t_FMapIterRef)) = {[@expl:into_iter 'self' type invariant] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = as_ref_ghost {self} (fun (_ret: t_FMap'0) -> [ &_6 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &result <- { t_FMapIterRef__inner = _6 } ] s1
      | s1 = {[@expl:assertion] ext_eq (view'1 result) _self} s2
      | s2 = [ &_0 <- result ] s3
      | s3 = return {_0} ] ]
    [ & _0: t_FMapIterRef = Any.any_l ()
    | & self: t_FMap = self
    | & _self: t_FMap = Any.any_l ()
    | & result: t_FMapIterRef = Any.any_l ()
    | & _6: t_FMap'0 = Any.any_l () ])
    [ return (result: t_FMapIterRef) -> {[@expl:into_iter result type invariant] inv'6 result}
      {[@expl:into_iter ensures] view'1 result = self}
      (! return {result}) ]
end
module M_creusot_contracts__logic__fmap__qyi4821133328050537988__produces_refl (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap
  
  type t_FMapIterRef = { t_FMapIterRef__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some tuple
  
  function get (self: Seq.seq tuple) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains [@inline:trivial] (self: t_FMap'0) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  predicate index_logic [@inline:trivial] (self: Map.map t_FMap'0 bool) (a: t_FMap'0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_FMap'0 bool) : t_FMap'0
  
  axiom such_that_spec: forall p: Map.map t_FMap'0 bool. (exists x: t_FMap'0. index_logic p x)
      -> index_logic p (such_that p)
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'1 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'1
  
  function view'1 (self: t_FMapIterRef) : t_FMap'0 = such_that (fun (m: t_FMap'0) -> forall k: t_K, v: t_V. (get'0 m k
        = C_Some'0 v)
      = (get'1 self.t_FMapIterRef__inner k = C_Some'1 v))
  
  predicate produces (self: t_FMapIterRef) (visited: Seq.seq tuple) (o: t_FMapIterRef) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get visited i = C_Some { f0 = k; f1 = v }
        -> not contains (view'1 o) k /\ get'0 (view'1 self) k = C_Some'0 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'1 o) k = get'0 (view'1 self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMapIterRef
  
  function produces_refl (self: t_FMapIterRef) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__logic__fmap__qyi4821133328050537988__produces_trans (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap
  
  type t_FMapIterRef = { t_FMapIterRef__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some tuple
  
  function get (self: Seq.seq tuple) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains [@inline:trivial] (self: t_FMap'0) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  predicate index_logic [@inline:trivial] (self: Map.map t_FMap'0 bool) (a: t_FMap'0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_FMap'0 bool) : t_FMap'0
  
  axiom such_that_spec: forall p: Map.map t_FMap'0 bool. (exists x: t_FMap'0. index_logic p x)
      -> index_logic p (such_that p)
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'1 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'1
  
  function view'1 (self: t_FMapIterRef) : t_FMap'0 = such_that (fun (m: t_FMap'0) -> forall k: t_K, v: t_V. (get'0 m k
        = C_Some'0 v)
      = (get'1 self.t_FMapIterRef__inner k = C_Some'1 v))
  
  predicate produces (self: t_FMapIterRef) (visited: Seq.seq tuple) (o: t_FMapIterRef) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get visited i = C_Some { f0 = k; f1 = v }
        -> not contains (view'1 o) k /\ get'0 (view'1 self) k = C_Some'0 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'1 o) k = get'0 (view'1 self) k)
  
  predicate contains'0 (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMapIterRef
  
  constant ab : Seq.seq tuple
  
  constant b : t_FMapIterRef
  
  constant bc : Seq.seq tuple
  
  constant c : t_FMapIterRef
  
  function produces_trans (a: t_FMapIterRef) (ab: Seq.seq tuple) (b: t_FMapIterRef) (bc: Seq.seq tuple) (c: t_FMapIterRef) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (let ac = Seq.(++) ab bc in (forall x: tuple. contains'0 ab x -> contains'0 ac x)
    && (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get ac (i + Seq.length ab) = Seq.get bc i)
    && (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length ac -> (Seq.get ac i).f0 <> k)
        -> (forall i: int. 0 <= i /\ i < Seq.length ab -> (Seq.get ab i).f0 <> k)
        /\ (forall i: int. 0 <= i /\ i < Seq.length bc -> (Seq.get bc i).f0 <> k)
        /\ get'0 (view'1 a) k = get'0 (view'1 b) k /\ get'0 (view'1 b) k = get'0 (view'1 c) k)
    && ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__ext_eq (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant other : Fset.fset t_T
  
  predicate ext_eq (self: Fset.fset t_T) (other: Fset.fset t_T)
  
  goal vc_ext_eq: [@expl:ext_eq ensures] (forall e: t_T. contains self e = contains other e) = (self = other)
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__singleton (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function insert [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.add e self
  
  meta "rewrite_def" function insert
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  function singleton (x: t_T) : Fset.fset t_T
  
  goal vc_singleton: [@expl:singleton ensures] forall y: t_T. contains (insert (Fset.empty: Fset.fset t_T) x) y
      = (x = y)
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__unions (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  predicate contains [@inline:trivial] (self: Fset.fset t_U) (e: t_U) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  function remove [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant f : Map.map t_T (Fset.fset t_U)
  
  function unions (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  goal vc_unions: if Fset.cardinal self = 0 then
      [@expl:unions ensures] forall y: t_U. contains (Fset.empty: Fset.fset t_U) y
        = (exists x: t_T. contains'0 self x /\ contains (Map.get f x) y)
    else
      let x = Fset.pick self in well_founded_relation (Fset.cardinal self) (Fset.cardinal (remove self x))
      /\ ((forall y: t_U. contains (unions (remove self x) f) y
          = (exists x'0: t_T. contains'0 (remove self x) x'0 /\ contains (Map.get f x'0) y))
      -> ([@expl:unions ensures] forall y: t_U. contains (Fset.union (Map.get f x) (unions (remove self x) f)) y
        = (exists x'0: t_T. contains'0 self x'0 /\ contains (Map.get f x'0) y)))

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__cons (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function remove [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: t_T. contains'0 self x /\ contains (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset t_T
  
  constant ss : Fset.fset (Seq.seq t_T)
  
  function cons (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  goal vc_cons: (forall x: t_T, xs: Seq.seq t_T. tail (push_front xs x) = xs)
    && (forall xs: Seq.seq t_T. 0 < Seq.length xs -> push_front (tail xs) (Seq.get xs 0) = xs)
    && ((forall y: Seq.seq t_T. contains (unions s (fun (x: t_T) -> map ss (fun (xs: Seq.seq t_T) -> push_front xs x))) y
        = (exists x: t_T. contains'0 s x
          /\ contains (Map.get (fun (x'0: t_T) -> map ss (fun (xs: Seq.seq t_T) -> push_front xs x'0)) x) y))
    -> ([@expl:cons ensures] forall xs: Seq.seq t_T. contains (unions s (fun (x: t_T) -> map ss (fun (xs'0: Seq.seq t_T) -> push_front xs'0 x))) xs
      = (0 < Seq.length xs /\ contains'0 s (Seq.get xs 0) /\ contains ss (tail xs))))
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__concat (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function remove [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: Seq.seq t_T. contains self x /\ contains (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset (Seq.seq t_T)
  
  constant t : Fset.fset (Seq.seq t_T)
  
  function concat (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  goal vc_concat:
    (forall y: Seq.seq t_T. contains (unions s (fun (ys: Seq.seq t_T) -> map t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))) y
        = (exists x: Seq.seq t_T. contains s x
          /\ contains (Map.get (fun (ys: Seq.seq t_T) -> map t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs)) x) y))
    -> ([@expl:concat ensures] forall xs: Seq.seq t_T. contains (unions s (fun (ys: Seq.seq t_T) -> map t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))) xs
      = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs))
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'1
  
  function insert [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert
  
  function singleton (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) = insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function remove [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: t_T. contains'1 self x /\ contains (Map.get f x) y)
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  function cons (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions s (fun (x: t_T) -> map ss (fun (xs: Seq.seq t_T) -> push_front xs x))
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (cons s ss) xs
        = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant n : int
  
  function replicate (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  goal vc_replicate: n >= 0
    -> (if n = 0 then
      (forall xs: Seq.seq t_T. Seq.length xs = 0 -> xs = (Seq.empty: Seq.seq t_T))
      && ((forall y: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) y = ((Seq.empty: Seq.seq t_T) = y))
      -> ([@expl:replicate ensures] forall xs: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x))))
    else
      (forall xs: Seq.seq t_T, i: int. 0 < i /\ i < Seq.length xs -> Seq.get xs i = Seq.get (tail xs) (i - 1))
      && (([@expl:replicate requires] n - 1 >= 0) /\ well_founded_relation n (n - 1))
      /\ ((forall xs: Seq.seq t_T. contains (replicate self (n - 1)) xs
          = (Seq.length xs = n - 1 /\ (forall x: t_T. contains'0 xs x -> contains'1 self x)))
      -> (forall xs: Seq.seq t_T. contains (cons self (replicate self (n - 1))) xs
          = (0 < Seq.length xs /\ contains'1 self (Seq.get xs 0) /\ contains (replicate self (n - 1)) (tail xs)))
      -> ([@expl:replicate ensures] forall xs: Seq.seq t_T. contains (cons self (replicate self (n - 1))) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x))))
    )
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate_up_to (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'1
  
  function insert [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert
  
  function singleton (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) = insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: t_T. contains'1 self x /\ contains (Map.get f x) y)
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  function cons (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions s (fun (x: t_T) -> map ss (fun (xs: Seq.seq t_T) -> push_front xs x))
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (cons s ss) xs
        = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate self n = (if n = 0 then singleton (Seq.empty: Seq.seq t_T) else cons self (replicate self (n - 1)))
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains (replicate self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant n : int
  
  function replicate_up_to (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  goal vc_replicate_up_to: n >= 0
    -> (if n = 0 then
      (forall xs: Seq.seq t_T. Seq.length xs = 0 -> xs = (Seq.empty: Seq.seq t_T))
      && ((forall y: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) y = ((Seq.empty: Seq.seq t_T) = y))
      -> ([@expl:replicate_up_to ensures] forall xs: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x))))
    else
      (([@expl:replicate_up_to requires] n - 1 >= 0) /\ well_founded_relation n (n - 1))
      /\ ((forall xs: Seq.seq t_T. contains (replicate_up_to self (n - 1)) xs
          = (Seq.length xs <= n - 1 /\ (forall x: t_T. contains'0 xs x -> contains'1 self x)))
      -> ([@expl:replicate requires] n >= 0)
      /\ ((forall xs: Seq.seq t_T. contains (replicate self n) xs
          = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x)))
      -> ([@expl:replicate_up_to ensures] forall xs: Seq.seq t_T. contains (Fset.union (replicate_up_to self (n
          - 1)) (replicate self n)) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x)))))
    )
end
module M_creusot_contracts__logic__fset__unions_union
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  predicate contains [@inline:trivial] (self: Fset.fset t_U) (e: t_U) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  function remove [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  axiom unions_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset t_U
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). forall y: t_U. contains (unions self f) y
        = (exists x: t_T. contains'0 self x /\ contains (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unions_union : ()
  
  goal vc_unions_union:
    ([@expl:unions_union ensures #0] forall s1: Fset.fset t_T, s2: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions (Fset.union s1 s2) f
        = Fset.union (unions s1 f) (unions s2 f))
    && ([@expl:unions_union ensures #1] forall s: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U), g: Map.map t_T (Fset.fset t_U). unions s (fun (x: t_T) -> Fset.union (Map.get f x) (Map.get g x))
      = Fset.union (unions s f) (unions s g))
end
module M_creusot_contracts__logic__fset__map_union
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  function map (self: Fset.fset t_T) (f: Map.map t_T t_U) : Fset.fset t_U = Fset.map f self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function map_union : ()
  
  goal vc_map_union:
    [@expl:map_union ensures] forall s: Fset.fset t_T, t: Fset.fset t_T, f: Map.map t_T t_U. map (Fset.union s t) f
      = Fset.union (map s f) (map t f)
end
module M_creusot_contracts__logic__fset__concat_union
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function remove [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: Seq.seq t_T. contains self x /\ contains (Map.get f x) y)
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function concat (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions s (fun (ys: Seq.seq t_T) -> map t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (concat s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function concat_union : ()
  
  goal vc_concat_union:
    ([@expl:concat_union ensures #0] forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
        = Fset.union (concat s1 t) (concat s2 t))
    && ([@expl:concat_union ensures #1] forall s: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s (Fset.union t1 t2)
      = Fset.union (concat s t1) (concat s t2))
end
module M_creusot_contracts__logic__fset__cons_concat
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function remove [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: Seq.seq t_T. contains self x /\ contains (Map.get f x) y)
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function concat (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions s (fun (ys: Seq.seq t_T) -> map t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (concat s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'0
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove'0
  
  function unions'0 (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def'0: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions'0 self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions'0 (remove'0 self x) f)
      )
  
  axiom unions_spec'0:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions'0 self f) y
        = (exists x: t_T. contains'0 self x /\ contains (Map.get f x) y)
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  function cons (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions'0 s (fun (x: t_T) -> map ss (fun (xs: Seq.seq t_T) -> push_front xs x))
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (cons s ss) xs
        = (0 < Seq.length xs /\ contains'0 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function cons_concat : ()
  
  goal vc_cons_concat: (forall x: t_T, xs: Seq.seq t_T, ys: Seq.seq t_T. Seq.(++) (push_front xs x) ys
        = push_front (Seq.(++) xs ys) x)
    && (forall x: t_T, ys: Seq.seq t_T. tail (push_front ys x) = ys)
    && (forall ys: Seq.seq t_T. 0 < Seq.length ys -> ys = push_front (tail ys) (Seq.get ys 0))
    && ([@expl:cons_concat ensures] forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
      = cons s (concat t u))
end
module M_creusot_contracts__logic__fset__concat_replicate
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  use map.Map
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'1
  
  function insert [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert
  
  function singleton (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) = insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: t_T. contains'1 self x /\ contains (Map.get f x) y)
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  function cons (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions s (fun (x: t_T) -> map ss (fun (xs: Seq.seq t_T) -> push_front xs x))
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (cons s ss) xs
        = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate self n = (if n = 0 then singleton (Seq.empty: Seq.seq t_T) else cons self (replicate self (n - 1)))
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains (replicate self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x)))
  
  function remove'0 [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove'0
  
  function unions'0 (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def'0:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions'0 self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions'0 (remove'0 self x) f)
      )
  
  axiom unions_spec'0:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions'0 self f) y
        = (exists x: Seq.seq t_T. contains self x /\ contains (Map.get f x) y)
  
  function concat (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions'0 s (fun (ys: Seq.seq t_T) -> map t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (concat s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty (s: Fset.fset (Seq.seq t_T)) : () = ()
  
  axiom concat_empty_spec: forall s: Fset.fset (Seq.seq t_T). concat (singleton (Seq.empty: Seq.seq t_T)) s = s
  
  axiom concat_empty_spec'0: forall s: Fset.fset (Seq.seq t_T). concat s (singleton (Seq.empty: Seq.seq t_T)) = s
  
  constant cons_concat: () = ()
  
  axiom cons_concat_spec:
    forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
      = cons s (concat t u)
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant n : int
  
  constant m : int
  
  constant s : Fset.fset t_T
  
  function concat_replicate (n: int) (m: int) (s: Fset.fset t_T) : ()
  
  goal vc_concat_replicate: 0 <= n /\ 0 <= m
    -> (if n = 0 then
      ([@expl:replicate requires] m >= 0)
      /\ ((forall xs: Seq.seq t_T. contains (replicate s m) xs
          = (Seq.length xs = m /\ (forall x: t_T. contains'0 xs x -> contains'1 s x)))
      -> concat (singleton (Seq.empty: Seq.seq t_T)) (replicate s m) = replicate s m
        && concat (replicate s m) (singleton (Seq.empty: Seq.seq t_T)) = replicate s m
      -> (let _ = concat_empty (replicate s m) in [@expl:concat_replicate ensures] replicate s (n + m)
      = concat (replicate s n) (replicate s m)))
    else
      (forall s'0: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s'0 t) u
          = cons s'0 (concat t u))
      -> (let _ = cons_concat in (([@expl:concat_replicate requires] 0 <= n - 1 /\ 0 <= m)
        /\ well_founded_relation n (n - 1))
      /\ (replicate s (n - 1 + m) = concat (replicate s (n - 1)) (replicate s m)
      -> (let _ = concat_replicate (n - 1) m s in [@expl:concat_replicate ensures] replicate s (n + m)
      = concat (replicate s n) (replicate s m))))
    )
end
module M_creusot_contracts__logic__fset__concat_empty
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function remove [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: Seq.seq t_T. contains self x /\ contains (Map.get f x) y)
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function concat (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions s (fun (ys: Seq.seq t_T) -> map t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (concat s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function insert [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert
  
  function singleton (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) = insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset (Seq.seq t_T)
  
  function concat_empty (s: Fset.fset (Seq.seq t_T)) : ()
  
  goal vc_concat_empty: (forall xs: Seq.seq t_T. Seq.(++) xs (Seq.empty: Seq.seq t_T) = xs)
    && (forall xs: Seq.seq t_T. Seq.(++) (Seq.empty: Seq.seq t_T) xs = xs)
    && ([@expl:concat_empty ensures #0] concat (singleton (Seq.empty: Seq.seq t_T)) s = s)
    && ([@expl:concat_empty ensures #1] concat s (singleton (Seq.empty: Seq.seq t_T)) = s)
end
module M_creusot_contracts__logic__fset__concat_replicate_up_to
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  use map.Map
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains'1
  
  function insert [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert
  
  function singleton (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) = insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove
  
  function unions (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
      )
  
  axiom unions_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions self f) y
        = (exists x: t_T. contains'1 self x /\ contains (Map.get f x) y)
  
  function map (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    Fset.map f self
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  function cons (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions s (fun (x: t_T) -> map ss (fun (xs: Seq.seq t_T) -> push_front xs x))
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (cons s ss) xs
        = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate self n = (if n = 0 then singleton (Seq.empty: Seq.seq t_T) else cons self (replicate self (n - 1)))
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains (replicate self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x)))
  
  function replicate_up_to (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_up_to_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_up_to self n
      = (if n = 0 then
        singleton (Seq.empty: Seq.seq t_T)
      else
        Fset.union (replicate_up_to self (n - 1)) (replicate self n)
      )
  
  axiom replicate_up_to_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains (replicate_up_to self n) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x -> contains'1 self x)))
  
  function remove'0 [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove'0
  
  function unions'0 (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_def'0:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions'0 self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions'0 (remove'0 self x) f)
      )
  
  axiom unions_spec'0:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains (unions'0 self f) y
        = (exists x: Seq.seq t_T. contains self x /\ contains (Map.get f x) y)
  
  function concat (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions'0 s (fun (ys: Seq.seq t_T) -> map t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains (concat s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty (s: Fset.fset (Seq.seq t_T)) : () = ()
  
  axiom concat_empty_spec: forall s: Fset.fset (Seq.seq t_T). concat (singleton (Seq.empty: Seq.seq t_T)) s = s
  
  axiom concat_empty_spec'0: forall s: Fset.fset (Seq.seq t_T). concat s (singleton (Seq.empty: Seq.seq t_T)) = s
  
  constant concat_union: () = ()
  
  axiom concat_union_spec:
    forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
      = Fset.union (concat s1 t) (concat s2 t)
  
  axiom concat_union_spec'0:
    forall s: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s (Fset.union t1 t2)
      = Fset.union (concat s t1) (concat s t2)
  
  constant cons_concat: () = ()
  
  axiom cons_concat_spec:
    forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
      = cons s (concat t u)
  
  function concat_replicate (n: int) (m: int) (s: Fset.fset t_T) : ()
  
  axiom concat_replicate_def: forall n: int, m: int, s: Fset.fset t_T. 0 <= n /\ 0 <= m
      -> concat_replicate n m s
      = (if n = 0 then
        let _ = concat_empty (replicate s m) in ()
      else
        let _ = cons_concat in let _ = concat_replicate (n - 1) m s in ()
      )
  
  axiom concat_replicate_spec: forall n: int, m: int, s: Fset.fset t_T. 0 <= n /\ 0 <= m
      -> replicate s (n + m) = concat (replicate s n) (replicate s m)
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant n : int
  
  constant m : int
  
  constant s : Fset.fset t_T
  
  function concat_replicate_up_to (n: int) (m: int) (s: Fset.fset t_T) : ()
  
  goal vc_concat_replicate_up_to: 0 <= n /\ n < m
    -> (if n + 1 = m then
      ([@expl:replicate requires] n + 1 >= 0)
      /\ ((forall xs: Seq.seq t_T. contains (replicate s (n + 1)) xs
          = (Seq.length xs = n + 1 /\ (forall x: t_T. contains'0 xs x -> contains'1 s x)))
      -> concat (singleton (Seq.empty: Seq.seq t_T)) (replicate s (n + 1)) = replicate s (n + 1)
        && concat (replicate s (n + 1)) (singleton (Seq.empty: Seq.seq t_T)) = replicate s (n + 1)
      -> (let _ = concat_empty (replicate s (n + 1)) in [@expl:concat_replicate_up_to ensures] replicate_up_to s m
      = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - n - 1)))))
    else
      (forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
            = Fset.union (concat s1 t) (concat s2 t))
        && (forall s'0: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s'0 (Fset.union t1 t2)
          = Fset.union (concat s'0 t1) (concat s'0 t2))
      -> (let _ = concat_union in ([@expl:concat_replicate requires] 0 <= n /\ 0 <= m - n - 1)
      /\ (replicate s (n + (m - n - 1)) = concat (replicate s n) (replicate s (m - n - 1))
      -> (let _ = concat_replicate n (m - n - 1) s in (([@expl:concat_replicate_up_to requires] 0 <= n /\ n < m - 1)
        /\ well_founded_relation m (m - 1))
      /\ (replicate_up_to s (m - 1)
        = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - 1 - n - 1)))
      -> (let _ = concat_replicate_up_to n (m - 1) s in [@expl:concat_replicate_up_to ensures] replicate_up_to s m
      = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - n - 1))))))))
    )
end
module M_creusot_contracts__logic__id__qyi676594641912026951__clone (* <logic::id::Id as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: t_Id) (return (x: t_Id)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = return {_0} ] ] [ & _0: t_Id = Any.any_l () | & self: t_Id = self ])
    [ return (result: t_Id) -> {[@expl:clone ensures] result = self} (! return {result}) ]
end
module M_creusot_contracts__logic__id__qyi14416423697585690270__ne (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Id
  
  let rec eq (self: t_Id) (other: t_Id) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self = other)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ne (self: t_Id) (other: t_Id) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = eq {self} {other} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- not _4 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self: t_Id = self | & other: t_Id = other | & _4: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:ne ensures] result <> (self = other)} (! return {result}) ]
end
module M_creusot_contracts__logic__int__qyi3540547019284611154__clone (* <logic::int::Int as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: int) (return (x: int)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = return {_0} ] ] [ & _0: int = Any.any_l () | & self: int = self ])
    [ return (result: int) -> {[@expl:clone ensures] result = self} (! return {result}) ]
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__cmp_le_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate le_log'0 (self: t_T) (other: t_T) = le_log self other
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_le_log'0 (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__cmp_lt_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate lt_log'0 (self: t_T) (other: t_T) = lt_log self other
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_lt_log'0 (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__cmp_ge_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate ge_log'0 (self: t_T) (other: t_T) = ge_log self other
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_ge_log'0 (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__cmp_gt_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate gt_log'0 (self: t_T) (other: t_T) = gt_log self other
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_gt_log'0 (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__refl (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  function refl'0 (x: t_T) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__trans (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  constant z : t_T
  
  constant o : t_Ordering
  
  function trans'0 (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log'0 x y = o -> cmp_log'0 y z = o -> ([@expl:trans ensures] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__antisym1 (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function antisym1'0 (x: t_T) (y: t_T) : ()
  
  goal vc_antisym1: cmp_log'0 x y = C_Less -> ([@expl:antisym1 ensures] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__antisym2 (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function antisym2'0 (x: t_T) (y: t_T) : ()
  
  goal vc_antisym2: cmp_log'0 x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__eq_cmp (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function eq_cmp'0 (x: t_T) (y: t_T) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_le_log (x: int) (y: int) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] (x <= y) = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] (x < y) = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] (x >= y) = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] (x > y) = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  function refl (x: int) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  constant z : int
  
  constant o : t_Ordering
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1 (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function antisym1 (x: int) (y: int) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2 (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function antisym2 (x: int) (y: int) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function eq_cmp (x: int) (y: int) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_le_log (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] UInt8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_lt_log (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] UInt8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_ge_log (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] UInt8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_gt_log (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] UInt8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  function refl (x: UInt8.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  constant z : UInt8.t
  
  constant o : t_Ordering
  
  function trans (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1 (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function antisym1 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2 (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function antisym2 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function eq_cmp (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_le_log (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] UInt16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_lt_log (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] UInt16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_ge_log (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] UInt16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_gt_log (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] UInt16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  function refl (x: UInt16.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  constant z : UInt16.t
  
  constant o : t_Ordering
  
  function trans (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1 (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function antisym1 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2 (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function antisym2 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function eq_cmp (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_le_log (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] UInt32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_lt_log (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] UInt32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_ge_log (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] UInt32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_gt_log (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] UInt32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  function refl (x: UInt32.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  constant z : UInt32.t
  
  constant o : t_Ordering
  
  function trans (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1 (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function antisym1 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2 (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function antisym2 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function eq_cmp (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  function refl (x: UInt64.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  constant z : UInt64.t
  
  constant o : t_Ordering
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1 (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2 (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_le_log (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] UInt128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_lt_log (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] UInt128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_ge_log (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] UInt128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_gt_log (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] UInt128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  function refl (x: UInt128.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  constant z : UInt128.t
  
  constant o : t_Ordering
  
  function trans (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1 (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function antisym1 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2 (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function antisym2 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function eq_cmp (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  function refl (x: UInt64.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  constant z : UInt64.t
  
  constant o : t_Ordering
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1 (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2 (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_le_log (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Int8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_lt_log (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Int8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_ge_log (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Int8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_gt_log (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Int8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  function refl (x: Int8.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  constant z : Int8.t
  
  constant o : t_Ordering
  
  function trans (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1 (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function antisym1 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2 (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function antisym2 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function eq_cmp (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_le_log (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Int16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_lt_log (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Int16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_ge_log (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Int16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_gt_log (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Int16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  function refl (x: Int16.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  constant z : Int16.t
  
  constant o : t_Ordering
  
  function trans (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1 (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function antisym1 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2 (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function antisym2 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function eq_cmp (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_le_log (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Int32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_lt_log (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Int32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_ge_log (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Int32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_gt_log (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Int32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  function refl (x: Int32.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  constant z : Int32.t
  
  constant o : t_Ordering
  
  function trans (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1 (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function antisym1 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2 (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function antisym2 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function eq_cmp (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_le_log (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_lt_log (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_ge_log (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_gt_log (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  function refl (x: Int64.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  constant z : Int64.t
  
  constant o : t_Ordering
  
  function trans (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1 (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym1 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2 (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym2 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function eq_cmp (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_le_log (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Int128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_lt_log (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Int128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_ge_log (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Int128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_gt_log (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Int128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  function refl (x: Int128.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  constant z : Int128.t
  
  constant o : t_Ordering
  
  function trans (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1 (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function antisym1 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2 (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function antisym2 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function eq_cmp (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_le_log (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_lt_log (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_ge_log (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_gt_log (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  function refl (x: Int64.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  constant z : Int64.t
  
  constant o : t_Ordering
  
  function trans (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1 (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym1 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2 (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym2 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function eq_cmp (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_le_log (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Char.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_lt_log (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Char.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_ge_log (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Char.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_gt_log (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Char.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  function refl (x: Char.t) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  constant z : Char.t
  
  constant o : t_Ordering
  
  function trans (x: Char.t) (y: Char.t) (z: Char.t) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1 (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function antisym1 (x: Char.t) (y: Char.t) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2 (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function antisym2 (x: Char.t) (y: Char.t) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function eq_cmp (x: Char.t) (y: Char.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_le_log (x: bool) (y: bool) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Bool.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_lt_log (x: bool) (y: bool) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Bool.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_ge_log (x: bool) (y: bool) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Bool.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_gt_log (x: bool) (y: bool) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Bool.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  function refl (x: bool) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  constant z : bool
  
  constant o : t_Ordering
  
  function trans (x: bool) (y: bool) (z: bool) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1 (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function antisym1 (x: bool) (y: bool) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2 (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function antisym2 (x: bool) (y: bool) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function eq_cmp (x: bool) (y: bool) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_B) (o: t_B)
  
  function cmp_gt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_B) (o: t_B)
  
  function cmp_ge_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_B) (o: t_B)
  
  function cmp_lt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_B) (o: t_B)
  
  function cmp_le_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_A) (o: t_A)
  
  function cmp_le_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate le_log'1 (self: tuple) (o: tuple) = self.f0 = o.f0 /\ le_log self.f1 o.f1 \/ lt_log'0 self.f0 o.f0
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log'0 self.f0 o.f0 in if r = C_Equal then
      cmp_log self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  constant y : tuple
  
  function cmp_le_log'1 (x: tuple) (y: tuple) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] le_log'1 x y = (cmp_log'1 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_B) (o: t_B)
  
  function cmp_gt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_B) (o: t_B)
  
  function cmp_ge_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_B) (o: t_B)
  
  function cmp_lt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_B) (o: t_B)
  
  function cmp_le_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_A) (o: t_A)
  
  function cmp_le_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate lt_log'1 (self: tuple) (o: tuple) = self.f0 = o.f0 /\ lt_log self.f1 o.f1 \/ lt_log'0 self.f0 o.f0
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log'0 self.f0 o.f0 in if r = C_Equal then
      cmp_log self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  constant y : tuple
  
  function cmp_lt_log'1 (x: tuple) (y: tuple) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] lt_log'1 x y = (cmp_log'1 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_B) (o: t_B)
  
  function cmp_gt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_B) (o: t_B)
  
  function cmp_ge_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_B) (o: t_B)
  
  function cmp_lt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_B) (o: t_B)
  
  function cmp_le_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_A) (o: t_A)
  
  function cmp_le_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate ge_log'1 (self: tuple) (o: tuple) = self.f0 = o.f0 /\ ge_log self.f1 o.f1 \/ gt_log'0 self.f0 o.f0
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log'0 self.f0 o.f0 in if r = C_Equal then
      cmp_log self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  constant y : tuple
  
  function cmp_ge_log'1 (x: tuple) (y: tuple) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] ge_log'1 x y = (cmp_log'1 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_B) (o: t_B)
  
  function cmp_gt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_B) (o: t_B)
  
  function cmp_ge_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_B) (o: t_B)
  
  function cmp_lt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_B) (o: t_B)
  
  function cmp_le_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_A) (o: t_A)
  
  function cmp_le_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate gt_log'1 (self: tuple) (o: tuple) = self.f0 = o.f0 /\ gt_log self.f1 o.f1 \/ gt_log'0 self.f0 o.f0
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log'0 self.f0 o.f0 in if r = C_Equal then
      cmp_log self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  constant y : tuple
  
  function cmp_gt_log'1 (x: tuple) (y: tuple) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] gt_log'1 x y = (cmp_log'1 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  function refl'1 (x: tuple) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log'1 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  constant y : tuple
  
  constant z : tuple
  
  constant o : t_Ordering
  
  function trans'1 (x: tuple) (y: tuple) (z: tuple) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log'1 x y = o -> cmp_log'1 y z = o -> ([@expl:trans ensures] cmp_log'1 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1 (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  constant y : tuple
  
  function antisym1'1 (x: tuple) (y: tuple) : ()
  
  goal vc_antisym1: cmp_log'1 x y = C_Less -> ([@expl:antisym1 ensures] cmp_log'1 y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2 (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  constant y : tuple
  
  function antisym2'1 (x: tuple) (y: tuple) : ()
  
  goal vc_antisym2: cmp_log'1 x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log'1 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tuple
  
  constant y : tuple
  
  function eq_cmp'1 (x: tuple) (y: tuple) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log'1 x y = C_Equal)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__factor (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag
  
  constant factor : t_Ag
  
  function factor'0 (self: t_Ag) (factor: t_Ag) : t_Option
  
  goal vc_factor: [@expl:factor ensures] match op self factor with
      | C_Some c -> op factor c = C_Some self
      | C_None -> forall c: t_Ag. op factor c <> C_Some self
      end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__commutative (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Ag
  
  constant b : t_Ag
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  goal vc_commutative: [@expl:commutative ensures] op a b = op b a
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__associative (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function and_then_logic (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Ag
  
  constant b : t_Ag
  
  constant c : t_Ag
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  goal vc_associative: [@expl:associative ensures] and_then_logic (op a b) (fun (ab: t_Ag) -> op ab c)
    = and_then_logic (op b c) (fun (bc: t_Ag) -> op a bc)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__core (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag
  
  function core (self: t_Ag) : t_Option
  
  goal vc_core: [@expl:core ensures] match C_Some self with
      | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
      | C_None -> true
      end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__core_is_maximal_idemp (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  function core (self: t_Ag) : t_Option = C_Some self
  
  axiom core_spec: forall self: t_Ag. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Ag. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Ag) (other: t_Ag) = factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag
  
  constant i : t_Ag
  
  function core_is_maximal_idemp (self: t_Ag) (i: t_Ag) : ()
  
  goal vc_core_is_maximal_idemp: op i i = C_Some i
    -> op i self = C_Some self
    -> ([@expl:core_is_maximal_idemp ensures] match core self with
      | C_Some c -> incl i c
      | C_None -> false
      end)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_mono (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  predicate rel (a: t_Option) (f: t_T) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option
  
  constant f1 : t_T
  
  constant f2 : t_T
  
  function rel_mono (a: t_Option) (f1: t_T) (f2: t_T) : ()
  
  goal vc_rel_mono: rel a f1 -> incl f2 f1 -> ([@expl:rel_mono ensures] rel a f2)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_none (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  predicate rel (a: t_Option) (f: t_T) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option
  
  constant f : t_T
  
  function rel_none (a: t_Option) (f: t_T) : ()
  
  goal vc_rel_none: [@expl:rel_none ensures] rel (C_None) f
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_unit (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  predicate rel (a: t_Option) (f: t_T) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function core_total (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. op (core_total self) self = C_Some self
  
  constant unit' : t_T
  
  axiom unit_spec: forall x: t_T [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_T. incl x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option
  
  function rel_unit (a: t_Option) : ()
  
  goal vc_rel_unit: [@expl:rel_unit ensures] rel a unit'
end
module M_creusot_contracts__logic__ra__auth__qyi1963254905082259216__update (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate = { t_AuthUpdate__0: t_U }
  
  type t_View
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function auth (self: t_View) : t_Option
  
  predicate premise (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function core_total (self: t_R) : t_R
  
  axiom core_total_spec: forall self: t_R. op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_R. op (core_total self) self = C_Some self
  
  constant unit' : t_R
  
  axiom unit_spec: forall x: t_R [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_R. incl x x
  
  predicate rel (a: t_Option) (f: t_R) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function rel_unit (a: t_Option) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_R) : () = ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_R. rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_R, f2: t_R. rel a f1 -> incl f2 f1 -> rel a f2
  
  function frag (self: t_View) : t_R
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise'0 (self: t_AuthUpdate) (from: t_View) =
    match auth from with
      | C_Some auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None -> false
      end
  
  type tuple = { f0: t_R; f1: t_R }
  
  function update (self: t_U) (from_auth: t_R) (from_frag: t_R) : tuple
  
  predicate index_logic [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. (exists x: t_R. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_R = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_R) -> true)
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic'0 (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  function frame_preserving (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option) : ()
  
  axiom frame_preserving_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option. premise self from_auth from_frag
      -> op'0 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
      -> (let {f0 = to_auth; f1 = to_frag} = update self from_auth from_frag in op'0 (C_Some to_frag) frame
      = C_Some'0 (C_Some to_auth))
  
  function new (auth'0: t_Option) (frag'0: t_R) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_R. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_R. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_AuthUpdate
  
  constant from : t_View
  
  constant _3 : ()
  
  function update'0 (self: t_AuthUpdate) (from: t_View) (_3: ()) : t_View
  
  goal vc_update: premise'0 self from
    -> ([@expl:unwrap_logic requires] auth from <> C_None)
    /\ (let from_auth = unwrap_logic (auth from) in rel (auth from) (frag from)
    -> (let {f0 = auth'0; f1 = frag'0} = update self.t_AuthUpdate__0 from_auth (frag from) in rel (auth from) (frag from)
    -> rel (auth from) (frag from)
    -> match factor from_auth (frag from) with
        | C_Some c -> op (frag from) c = C_Some from_auth
        | C_None -> forall c: t_R. op (frag from) c <> C_Some from_auth
        end
    -> (([@expl:frame_preserving requires #0] premise self.t_AuthUpdate__0 from_auth (frag from))
      && ([@expl:frame_preserving requires #1] op'0 (C_Some (frag from)) (factor from_auth (frag from))
      = C_Some'0 (C_Some from_auth)))
    /\ ((let {f0 = to_auth; f1 = to_frag} = update self.t_AuthUpdate__0 from_auth (frag from) in op'0 (C_Some to_frag) (factor from_auth (frag from))
      = C_Some'0 (C_Some to_auth))
    -> (let _ = frame_preserving self.t_AuthUpdate__0 from_auth (frag from) (factor from_auth (frag from)) in ([@expl:new requires] rel (C_Some auth'0) frag'0)
    /\ (auth (new (C_Some auth'0) frag'0) = C_Some auth'0 && frag (new (C_Some auth'0) frag'0) = frag'0
    -> ([@expl:update ensures] let {f0 = auth'1; f1 = frag'1} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in rel (C_Some auth'1) frag'1))))))
end
module M_creusot_contracts__logic__ra__auth__qyi1963254905082259216__frame_preserving (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate = { t_AuthUpdate__0: t_U }
  
  type t_View
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function auth (self: t_View) : t_Option
  
  predicate premise (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function core_total (self: t_R) : t_R
  
  axiom core_total_spec: forall self: t_R. op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_R. op (core_total self) self = C_Some self
  
  constant unit' : t_R
  
  axiom unit_spec: forall x: t_R [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_R. incl x x
  
  predicate rel (a: t_Option) (f: t_R) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function rel_unit (a: t_Option) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_R) : () = ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_R. rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_R, f2: t_R. rel a f1 -> incl f2 f1 -> rel a f2
  
  function frag (self: t_View) : t_R
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise'0 (self: t_AuthUpdate) (from: t_View) =
    match auth from with
      | C_Some auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None -> false
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_View
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_View t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function new (auth'0: t_Option) (frag'0: t_R) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_R. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_R. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option'0 = match op (frag self) (frag other) with
      | C_Some f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None; f1 = a} -> if rel a f then C_Some'0 (new a f) else C_None'0
        | {f0 = a; f1 = C_None} -> if rel a f then C_Some'0 (new a f) else C_None'0
        | _ -> C_None'0
        end
      | C_None -> C_None'0
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic'0 (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  type tuple'0 = { f0'0: t_R; f1'0: t_R }
  
  function update (self: t_U) (from_auth: t_R) (from_frag: t_R) : tuple'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. (exists x: t_R. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_R = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_R) -> true)
      end
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_Option t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function map_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option'1 = match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  function op'1 (self: t_Option) (other: t_Option) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'1 other
      | {f1 = C_None} -> C_Some'1 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'1 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'1:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic'1 (op'1 a b) (fun (ab: t_Option) -> op'1 ab c)
      = and_then_logic'1 (op'1 b c) (fun (bc: t_Option) -> op'1 a bc)
  
  function commutative'1 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'1: forall a: t_Option, b: t_Option. op'1 a b = op'1 b a
  
  function frame_preserving (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option) : ()
  
  axiom frame_preserving_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option. premise self from_auth from_frag
      -> op'1 (C_Some from_frag) frame = C_Some'1 (C_Some from_auth)
      -> (let {f0'0 = to_auth; f1'0 = to_frag} = update self from_auth from_frag in op'1 (C_Some to_frag) frame
      = C_Some'1 (C_Some to_auth))
  
  function update'0 (self: t_AuthUpdate) (from: t_View) (_3: ()) : t_View =
    let from_auth = unwrap_logic (auth from) in let {f0'0 = auth'0; f1'0 = frag'0} = update self.t_AuthUpdate__0 from_auth (frag from) in let _ = frame_preserving self.t_AuthUpdate__0 from_auth (frag from) (factor from_auth (frag from)) in new (C_Some auth'0) frag'0
  
  axiom update_spec: forall self: t_AuthUpdate, from: t_View, _3: (). premise'0 self from
      -> (let {f0'0 = auth'0; f1'0 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in rel (C_Some auth'0) frag'0)
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_View bool) (a: t_View) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that'0 (p: Map.map t_View bool) : t_View
  
  axiom such_that_spec'0: forall p: Map.map t_View bool. (exists x: t_View. index_logic'0 p x)
      -> index_logic'0 p (such_that'0 p)
  
  function unwrap_logic'0 (self: t_Option'0) : t_View = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: t_View) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_AuthUpdate
  
  constant from : t_View
  
  constant frame : t_View
  
  function frame_preserving'0 (self: t_AuthUpdate) (from: t_View) (frame: t_View) : ()
  
  goal vc_frame_preserving: premise'0 self from
    -> op'0 from frame <> C_None'0
    -> ([@expl:unwrap_logic requires] auth from <> C_None)
    /\ (let auth'0 = unwrap_logic (auth from) in ([@expl:unwrap_logic requires] op'0 from frame <> C_None'0)
    /\ (rel (auth (unwrap_logic'0 (op'0 from frame))) (frag (unwrap_logic'0 (op'0 from frame)))
    -> (let x = frag (unwrap_logic'0 (op'0 from frame)) in match factor auth'0 x with
        | C_Some c -> op x c = C_Some auth'0
        | C_None -> forall c: t_R. op x c <> C_Some auth'0
        end
    -> ([@expl:unwrap_logic requires] factor auth'0 x <> C_None)
    /\ (let y = unwrap_logic (factor auth'0 x) in rel (auth frame) (frag frame)
    -> ([@expl:unwrap_logic requires] op (frag frame) y <> C_None)
    /\ (let f = unwrap_logic (op (frag frame) y) in rel (auth from) (frag from)
    -> (([@expl:frame_preserving requires #0] premise self.t_AuthUpdate__0 auth'0 (frag from))
      && ([@expl:frame_preserving requires #1] op'1 (C_Some (frag from)) (C_Some f) = C_Some'1 (C_Some auth'0)))
    /\ ((let {f0'0 = to_auth; f1'0 = to_frag} = update self.t_AuthUpdate__0 auth'0 (frag from) in op'1 (C_Some to_frag) (C_Some f)
      = C_Some'1 (C_Some to_auth))
    -> (let _ = frame_preserving self.t_AuthUpdate__0 auth'0 (frag from) (C_Some f) in [@expl:frame_preserving ensures] op'0 (update'0 self from ()) frame
    <> C_None'0)))))))
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__factor (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl
  
  constant factor : t_Excl
  
  function factor'0 (self: t_Excl) (factor: t_Excl) : t_Option
  
  goal vc_factor: [@expl:factor ensures] match C_None with
      | C_Some c -> op factor c = C_Some self
      | C_None -> forall c: t_Excl. op factor c <> C_Some self
      end
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__commutative (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Excl
  
  constant b : t_Excl
  
  function commutative (a: t_Excl) (b: t_Excl) : ()
  
  goal vc_commutative: [@expl:commutative ensures] op a b = op b a
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__associative (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function and_then_logic (self: t_Option) (f: Map.map t_Excl t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Excl
  
  constant b : t_Excl
  
  constant c : t_Excl
  
  function associative (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  goal vc_associative: [@expl:associative ensures] and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
    = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__core (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl
  
  function core (self: t_Excl) : t_Option
  
  goal vc_core: [@expl:core ensures] match C_None with
      | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
      | C_None -> true
      end
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__core_is_maximal_idemp (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  function core (self: t_Excl) : t_Option = C_None
  
  axiom core_spec: forall self: t_Excl. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function factor (self: t_Excl) (factor'0: t_Excl) : t_Option = C_None
  
  axiom factor_spec: forall self: t_Excl, factor'0: t_Excl. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Excl. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Excl) (other: t_Excl) = factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl
  
  constant i : t_Excl
  
  function core_is_maximal_idemp (self: t_Excl) (i: t_Excl) : ()
  
  goal vc_core_is_maximal_idemp: op i i = C_Some i
    -> op i self = C_Some self
    -> ([@expl:core_is_maximal_idemp ensures] match core self with
      | C_Some c -> incl i c
      | C_None -> false
      end)
end
module M_creusot_contracts__logic__ra__excl__qyi10476702783314713742__update (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_ExclUpdate = { t_ExclUpdate__0: t_T }
  
  type t_Excl = { t_Excl__0: t_T }
  
  predicate premise (self: t_ExclUpdate) (_2: t_Excl) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ExclUpdate
  
  constant from : t_Excl
  
  constant _3 : ()
  
  function update (self: t_ExclUpdate) (from: t_Excl) (_3: ()) : t_Excl
  
  goal vc_update: true
end
module M_creusot_contracts__logic__ra__excl__qyi10476702783314713742__frame_preserving (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_ExclUpdate = { t_ExclUpdate__0: t_T }
  
  type t_Excl = { t_Excl__0: t_T }
  
  predicate premise (self: t_ExclUpdate) (_2: t_Excl) = true
  
  type t_Option = C_None | C_Some t_Excl
  
  function and_then_logic (self: t_Option) (f: Map.map t_Excl t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  function associative (a: t_Excl) (b: t_Excl) (c: t_Excl) : () = ()
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
  
  function commutative (a: t_Excl) (b: t_Excl) : () = ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. op a b = op b a
  
  function update (self: t_ExclUpdate) (from: t_Excl) (_3: ()) : t_Excl = { t_Excl__0 = self.t_ExclUpdate__0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ExclUpdate
  
  constant from : t_Excl
  
  constant frame : t_Excl
  
  function frame_preserving (self: t_ExclUpdate) (from: t_Excl) (frame: t_Excl) : ()
  
  goal vc_frame_preserving: premise self from
    -> op from frame <> C_None -> ([@expl:frame_preserving ensures] op (update self from ()) frame <> C_None)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__factor (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None'0} -> C_Some'1 x
      | {f0 = C_None'0} -> C_None'1
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_Option'0) (other: t_Option'0) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. incl'0 a b
      -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : () = ()
  
  axiom incl_op_spec'0: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. op'0 self other = C_Some'1 comb
      -> incl'0 self comb
  
  type tuple'1 = { f0'1: t_K; f1'1: t_V }
  
  function index_logic'1 [@inline:trivial] (self: Map.map tuple'1 t_Option'0) (a: tuple'1) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function filter_map (self: t_FMap) (f: Map.map tuple'1 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'1 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic'1 f { f0'1 = k; f1'1 = v }
          end
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap
  
  constant factor'1 : t_FMap
  
  function factor'2 (self: t_FMap) (factor'1: t_FMap) : t_Option
  
  goal vc_factor: if forall k: t_K. incl'0 (get factor'1 k) (get self k) then
      (forall __0: tuple'1. let {f0'1 = k; f1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k) with
              | C_Some'1 c -> op'0 (get factor'1 k) c = C_Some'1 (C_Some'0 vo)
              | C_None'1 -> forall c: t_Option'0. op'0 (get factor'1 k) c <> C_Some'1 (C_Some'0 vo)
              end
          -> match factor'0 (C_Some'0 vo) (get factor'1 k) with
            | C_Some'1 r -> true
            | C_None'1 -> true
            end)
      /\ ((forall k: t_K [get (filter_map self (fun (__0: tuple'1) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k'0) with
            | C_Some'1 r -> r
            | C_None'1 -> C_None'0
            end)) k]. get (filter_map self (fun (__0: tuple'1) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k'0) with
              | C_Some'1 r -> r
              | C_None'1 -> C_None'0
              end)) k
          = match get self k with
            | C_None'0 -> C_None'0
            | C_Some'0 v -> index_logic'1 (fun (__0: tuple'1) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k'0) with
              | C_Some'1 r -> r
              | C_None'1 -> C_None'0
              end) { f0'1 = k; f1'1 = v }
            end)
      -> (let res = filter_map self (fun (__0: tuple'1) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in match op'1 factor'1 res with
        | C_None -> false
        && ([@expl:factor ensures] match C_Some res with
          | C_Some c -> op'1 factor'1 c = C_Some self
          | C_None -> forall c: t_FMap. op'1 factor'1 c <> C_Some self
          end)
        | C_Some o -> ext_eq o self = (o = self)
        -> ext_eq o self
        && ([@expl:factor ensures] match C_Some res with
          | C_Some c -> op'1 factor'1 c = C_Some self
          | C_None -> forall c: t_FMap. op'1 factor'1 c <> C_Some self
          end)
        end))
    else
      [@expl:factor ensures] match C_None with
        | C_Some c -> op'1 factor'1 c = C_Some self
        | C_None -> forall c: t_FMap. op'1 factor'1 c <> C_Some self
        end

end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__commutative (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1 = { f0'1: t_Option; f1'1: t_Option }
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMap
  
  constant b : t_FMap
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  goal vc_commutative: match { f0'1 = op'1 a b; f1'1 = op'1 b a } with
      | {f0'1 = C_Some ab; f1'1 = C_Some ba} -> ext_eq ab ba = (ab = ba)
      -> ext_eq ab ba && ([@expl:commutative ensures] op'1 a b = op'1 b a)
      | {f0'1 = C_None; f1'1 = C_None} -> [@expl:commutative ensures] op'1 a b = op'1 b a
      | _ -> false && ([@expl:commutative ensures] op'1 a b = op'1 b a)
      end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__associative (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1 = { f0'1: t_Option; f1'1: t_Option }
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMap
  
  constant b : t_FMap
  
  constant c : t_FMap
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  goal vc_associative: match { f0'1 = op'1 a b; f1'1 = op'1 b c } with
      | {f0'1 = C_Some ab; f1'1 = C_Some bc} -> match { f0'1 = op'1 ab c; f1'1 = op'1 a bc } with
        | {f0'1 = C_Some x; f1'1 = C_Some y} -> ext_eq x y = (x = y)
        -> ext_eq x y
        && ([@expl:associative ensures] and_then_logic (op'1 a b) (fun (ab'0: t_FMap) -> op'1 ab'0 c)
        = and_then_logic (op'1 b c) (fun (bc'0: t_FMap) -> op'1 a bc'0))
        | _ -> [@expl:associative ensures] and_then_logic (op'1 a b) (fun (ab'0: t_FMap) -> op'1 ab'0 c)
        = and_then_logic (op'1 b c) (fun (bc'0: t_FMap) -> op'1 a bc'0)
        end
      | _ -> [@expl:associative ensures] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
      end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__core (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1 = { f0'1: t_K; f1'1: t_V }
  
  function index_logic'1 [@inline:trivial] (self: Map.map tuple'1 t_Option'0) (a: tuple'1) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function filter_map (self: t_FMap) (f: Map.map tuple'1 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'1 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic'1 f { f0'1 = k; f1'1 = v }
          end
  
  function core (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core_total (self: t_FMap) : t_FMap =
    let r = filter_map self (fun (__0: tuple'1) -> let {f1'1 = v} = __0 in core v) in r
  
  axiom core_total_spec: forall self: t_FMap. op'1 (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. op'1 (core_total self) self = C_Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap
  
  function core'0 (self: t_FMap) : t_Option
  
  goal vc_core: op'1 (core_total self) (core_total self) = C_Some (core_total self)
      && op'1 (core_total self) self = C_Some self
    -> ([@expl:core ensures] match C_Some (core_total self) with
      | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
      | C_None -> true
      end)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__core_is_maximal_idemp (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1 = { f0'1: t_K; f1'1: t_V }
  
  function index_logic'1 [@inline:trivial] (self: Map.map tuple'1 t_Option'0) (a: tuple'1) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function filter_map (self: t_FMap) (f: Map.map tuple'1 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'1 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic'1 f { f0'1 = k; f1'1 = v }
          end
  
  function core (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core_total (self: t_FMap) : t_FMap =
    let r = filter_map self (fun (__0: tuple'1) -> let {f1'1 = v} = __0 in core v) in r
  
  axiom core_total_spec: forall self: t_FMap. op'1 (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. op'1 (core_total self) self = C_Some self
  
  function core'0 (self: t_FMap) : t_Option = C_Some (core_total self)
  
  axiom core_spec'0: forall self: t_FMap. match core'0 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None'0} -> C_Some'1 x
      | {f0 = C_None'0} -> C_None'1
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_Option'0) (other: t_Option'0) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. incl'0 a b
      -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : () = ()
  
  axiom incl_op_spec'0: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. op'0 self other = C_Some'1 comb
      -> incl'0 self comb
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option =
    if forall k: t_K. incl'0 (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'1) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'1 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None
  
  function core_is_maximal_idemp (self: t_V) (i: t_V) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_V, i: t_V. op i i = C_Some'0 i
      -> op i self = C_Some'0 self
      -> match core self with
        | C_Some'0 c -> incl i c
        | C_None'0 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap
  
  constant i : t_FMap
  
  function core_is_maximal_idemp'0 (self: t_FMap) (i: t_FMap) : ()
  
  goal vc_core_is_maximal_idemp: op'1 i i = C_Some i
    -> op'1 i self = C_Some self
    -> ([@expl:core_is_maximal_idemp ensures] match core'0 self with
      | C_Some c -> incl'1 i c
      | C_None -> false
      end)
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__unit (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None'0} -> C_Some'1 other
      | {f1'0 = C_None'0} -> C_Some'1 self
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'1 = { f0'1: t_V; f1'1: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. forall k: t_K [get (merge self m f) k]. match { f0'0 = get self k;
                                                                                                            f1'0 = get m k } with
          | {f0'0 = C_None'0; f1'0 = y} -> get (merge self m f) k = y
          | {f0'0 = x; f1'0 = C_None'0} -> get (merge self m f) k = x
          | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'1) -> let {f0'1 = x; f1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : () = match { f0 = op'1 a b; f1 = op'1 b c } with
      | {f0 = C_Some ab; f1 = C_Some bc} -> match { f0 = op'1 ab c; f1 = op'1 a bc } with
        | {f0 = C_Some x; f1 = C_Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : () = ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None'0)
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map t_FMap bool) (a: t_FMap) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec'0: forall p: Map.map t_FMap bool. (exists x: t_FMap. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function unwrap_logic (self: t_Option) : t_FMap = match self with
      | C_Some x -> x
      | C_None -> such_that'0 (fun (__0: t_FMap) -> true)
      end
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit' : t_FMap
  
  goal vc_unit: (forall x: t_FMap. len empty = 0 && view empty = Const.const (C_None'0)
        -> ([@expl:unwrap_logic requires] op'1 x empty <> C_None))
    /\ (forall x: t_FMap. ext_eq (unwrap_logic (op'1 x empty)) x)
    && (len empty = 0 && view empty = Const.const (C_None'0)
    -> (let result = empty in [@expl:unit ensures] forall x: t_FMap [op'1 x result]. op'1 x result = C_Some x))
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__core_total (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None'0} -> C_Some'1 other
      | {f1'0 = C_None'0} -> C_Some'1 self
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'1 = { f0'1: t_V; f1'1: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. forall k: t_K [get (merge self m f) k]. match { f0'0 = get self k;
                                                                                                            f1'0 = get m k } with
          | {f0'0 = C_None'0; f1'0 = y} -> get (merge self m f) k = y
          | {f0'0 = x; f1'0 = C_None'0} -> get (merge self m f) k = x
          | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'1) -> let {f0'1 = x; f1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : () = match { f0 = op'1 a b; f1 = op'1 b c } with
      | {f0 = C_Some ab; f1 = C_Some bc} -> match { f0 = op'1 ab c; f1 = op'1 a bc } with
        | {f0 = C_Some x; f1 = C_Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : () = ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  type tuple'2 = { f0'2: t_K; f1'2: t_V }
  
  function core (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function index_logic'1 [@inline:trivial] (self: Map.map tuple'2 t_Option'0) (a: tuple'2) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function filter_map (self: t_FMap) (f: Map.map tuple'2 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'2 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic'1 f { f0'2 = k; f1'2 = v }
          end
  
  predicate index_logic'2 [@inline:trivial] (self: Map.map t_FMap bool) (a: t_FMap) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'2
  
  function such_that'0 (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec'0: forall p: Map.map t_FMap bool. (exists x: t_FMap. index_logic'2 p x)
      -> index_logic'2 p (such_that'0 p)
  
  function unwrap_logic (self: t_Option) : t_FMap = match self with
      | C_Some x -> x
      | C_None -> such_that'0 (fun (__0: t_FMap) -> true)
      end
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap
  
  function core_total (self: t_FMap) : t_FMap
  
  goal vc_core_total: (forall __0: tuple'2. let {f1'2 = v} = __0 in true)
    /\ ((forall k: t_K [get (filter_map self (fun (__0: tuple'2) -> let {f1'2 = v} = __0 in core v)) k]. get (filter_map self (fun (__0: tuple'2) -> let {f1'2 = v} = __0 in core v)) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic'1 (fun (__0: tuple'2) -> let {f1'2 = v'0} = __0 in core v'0) { f0'2 = k;
                                                                                                     f1'2 = v }
          end)
    -> (let r = filter_map self (fun (__0: tuple'2) -> let {f1'2 = v} = __0 in core v) in ([@expl:unwrap_logic requires] op'1 r r
      <> C_None)
    /\ (ext_eq (unwrap_logic (op'1 r r)) r = (unwrap_logic (op'1 r r) = r)
    -> ext_eq (unwrap_logic (op'1 r r)) r
    && ([@expl:unwrap_logic requires] op'1 r self <> C_None)
    /\ (ext_eq (unwrap_logic (op'1 r self)) self = (unwrap_logic (op'1 r self) = self)
    -> ext_eq (unwrap_logic (op'1 r self)) self
    && (let result = r in ([@expl:core_total ensures #0] op'1 result result = C_Some result)
    && ([@expl:core_total ensures #1] op'1 result self = C_Some self))))))
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__core_is_total (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  type tuple'1 = { f0'1: t_Option; f1'1: t_Option }
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : () = match { f0'1 = op'1 a b; f1'1 = op'1 b c } with
      | {f0'1 = C_Some ab; f1'1 = C_Some bc} -> match { f0'1 = op'1 ab c; f1'1 = op'1 a bc } with
        | {f0'1 = C_Some x; f1'1 = C_Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : () = ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  type tuple'2 = { f0'2: t_K; f1'2: t_V }
  
  function index_logic'1 [@inline:trivial] (self: Map.map tuple'2 t_Option'0) (a: tuple'2) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function filter_map (self: t_FMap) (f: Map.map tuple'2 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'2 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic'1 f { f0'2 = k; f1'2 = v }
          end
  
  function core (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core_total (self: t_FMap) : t_FMap =
    let r = filter_map self (fun (__0: tuple'2) -> let {f1'2 = v} = __0 in core v) in r
  
  axiom core_total_spec: forall self: t_FMap. op'1 (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. op'1 (core_total self) self = C_Some self
  
  function core'0 (self: t_FMap) : t_Option = C_Some (core_total self)
  
  axiom core_spec'0: forall self: t_FMap. match core'0 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap
  
  function core_is_total (self: t_FMap) : ()
  
  goal vc_core_is_total: [@expl:core_is_total ensures] core'0 self = C_Some (core_total self)
end
module M_creusot_contracts__logic__ra__fmap__qyi17941324210461407630__total_op (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_V t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_V t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option
  
  function factor (self: t_V) (factor'0: t_V) : t_Option
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_V. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_V) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function index_logic'0 [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None} -> get (merge self m f) k = x
          | {f0 = C_Some x; f1 = C_Some y} -> get (merge self m f) k = C_Some (index_logic'0 f { f0'0 = x; f1'0 = y })
          end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap
  
  constant other : t_FMap
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  goal vc_total_op: (forall k: t_K. op'0 (get self k) (get other k) <> C_None'0)
    -> (forall __0: tuple'0. let {f0'0 = x; f1'0 = y} = __0 in match op x y with
          | C_Some r -> true
          | _ -> [@expl:such_that requires] exists x'0: t_V. index_logic (fun (__0'0: t_V) -> true) x'0
          end)
    /\ ((forall k: t_K [get (merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
          | C_Some r -> r
          | _ -> such_that (fun (__0'0: t_V) -> true)
          end)) k]. match { f0 = get self k; f1 = get other k } with
          | {f0 = C_None; f1 = y} -> get (merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y'0} = __0 in match op x y'0 with
              | C_Some r -> r
              | _ -> such_that (fun (__0'0: t_V) -> true)
              end)) k
          = y
          | {f0 = x; f1 = C_None} -> get (merge self other (fun (__0: tuple'0) -> let {f0'0 = x'0; f1'0 = y} = __0 in match op x'0 y with
              | C_Some r -> r
              | _ -> such_that (fun (__0'0: t_V) -> true)
              end)) k
          = x
          | {f0 = C_Some x; f1 = C_Some y} -> get (merge self other (fun (__0: tuple'0) -> let {f0'0 = x'0; f1'0 = y'0} = __0 in match op x'0 y'0 with
              | C_Some r -> r
              | _ -> such_that (fun (__0'0: t_V) -> true)
              end)) k
          = C_Some (index_logic'0 (fun (__0: tuple'0) -> let {f0'0 = x'0; f1'0 = y'0} = __0 in match op x'0 y'0 with
            | C_Some r -> r
            | _ -> such_that (fun (__0'0: t_V) -> true)
            end) { f0'0 = x; f1'0 = y })
          end)
    -> ([@expl:total_op ensures] forall k: t_K. C_Some'0 (get (merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
          | C_Some r -> r
          | _ -> such_that (fun (__0'0: t_V) -> true)
          end)) k)
      = op'0 (get self k) (get other k)))
end
module M_creusot_contracts__logic__ra__fmap__qyi945878506295166927__frame_preserving (* <logic::ra::fmap::FMapInsertLocalUpdate<K, V> as logic::ra::update::LocalUpdate<logic::fmap::FMap<K, V>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_K
  
  type t_V
  
  type t_FMapInsertLocalUpdate = { t_FMapInsertLocalUpdate__0: t_K; t_FMapInsertLocalUpdate__1: t_V }
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate premise (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (_3: t_FMap) =
    get from_auth self.t_FMapInsertLocalUpdate__0 = C_None'0
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option'1 = match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option'0
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'0 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  function map_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'2 = match self with
      | C_None'0 -> C_None'2
      | C_Some'0 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'2 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'2 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None'0} -> C_Some'2 other
      | {f1'0 = C_None'0} -> C_Some'2 self
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> map_logic'0 (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'1 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type tuple'1 = { f0'1: t_V; f1'1: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. forall k: t_K [get (merge self m f) k]. match { f0'0 = get self k;
                                                                                                            f1'0 = get m k } with
          | {f0'0 = C_None'0; f1'0 = y} -> get (merge self m f) k = y
          | {f0'0 = x; f1'0 = C_None'0} -> get (merge self m f) k = x
          | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'1) -> let {f0'1 = x; f1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'2)
      -> (forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'2 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : () = match { f0 = op'1 a b; f1 = op'1 b c } with
      | {f0 = C_Some ab; f1 = C_Some bc} -> match { f0 = op'1 ab c; f1 = op'1 a bc } with
        | {f0 = C_Some x; f1 = C_Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : () = ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'1 other
      | {f1 = C_None} -> C_Some'1 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_FMap) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  type tuple'2 = { f0'2: t_FMap; f1'2: t_FMap }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. view (insert self k v) = Map.set (view self) k (C_Some'0 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function update (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (from_frag: t_FMap) : tuple'2 =
    { f0'2 = insert from_auth self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1;
      f1'2 = insert from_frag self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1 }
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMapInsertLocalUpdate
  
  constant from_auth : t_FMap
  
  constant from_frag : t_FMap
  
  constant frame : t_Option
  
  function frame_preserving (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (from_frag: t_FMap) (frame: t_Option) : ()
  
  goal vc_frame_preserving: premise self from_auth from_frag
    -> op'2 (C_Some from_frag) frame = C_Some'1 (C_Some from_auth)
    -> (let {f0'2 = to_auth; f1'2 = to_frag} = update self from_auth from_frag in match op'2 (C_Some to_frag) frame with
      | C_Some'1 (C_Some x) -> ext_eq to_auth x = (to_auth = x)
      -> ext_eq to_auth x
      && ([@expl:frame_preserving ensures] let {f0'2 = to_auth'0; f1'2 = to_frag'0} = update self from_auth from_frag in op'2 (C_Some to_frag'0) frame
      = C_Some'1 (C_Some to_auth'0))
      | _ -> false
      && ([@expl:frame_preserving ensures] let {f0'2 = to_auth'0; f1'2 = to_frag'0} = update self from_auth from_frag in op'2 (C_Some to_frag'0) frame
      = C_Some'1 (C_Some to_auth'0))
      end)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__factor (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option
  
  constant factor'0 : t_Option
  
  function factor'1 (self: t_Option) (factor'0: t_Option) : t_Option'0
  
  goal vc_factor: match { f0 = self; f1 = factor'0 } with
      | {f0 = x; f1 = C_None} -> [@expl:factor ensures] match C_Some'0 x with
        | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
        end
      | {f0 = C_None} -> [@expl:factor ensures] match C_None'0 with
        | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
        end
      | {f0 = C_Some x; f1 = C_Some y} -> match factor x y with
          | C_Some c -> op y c = C_Some x
          | C_None -> forall c: t_T. op y c <> C_Some x
          end
      -> match factor x y with
        | C_Some z -> [@expl:factor ensures] match C_Some'0 (C_Some z) with
          | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
          | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
          end
        | C_None -> if x = y then
          [@expl:factor ensures] match C_Some'0 (C_None) with
            | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
            | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
            end
        else
          [@expl:factor ensures] match C_None'0 with
            | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
            | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
            end
        
        end
      end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__commutative (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option
  
  constant b : t_Option
  
  function commutative'0 (a: t_Option) (b: t_Option) : ()
  
  goal vc_commutative: [@expl:commutative ensures] op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__associative (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option; f2: t_Option }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option
  
  constant b : t_Option
  
  constant c : t_Option
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  goal vc_associative: match { f0'0 = a; f1'0 = b; f2 = c } with
      | {f0'0 = C_None} -> [@expl:associative ensures] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
      | {f1'0 = C_None} -> [@expl:associative ensures] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
      | {f2 = C_None} -> [@expl:associative ensures] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
      | {f0'0 = C_Some aa; f1'0 = C_Some bb; f2 = C_Some cc} -> and_then_logic'0 (op aa bb) (fun (ab: t_T) -> op ab cc)
        = and_then_logic'0 (op bb cc) (fun (bc: t_T) -> op aa bc)
      -> ([@expl:associative ensures] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc))
      end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__core (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function core (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function core_total (self: t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. op'0 (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. op'0 (core_total self) self = C_Some'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option
  
  function core'0 (self: t_Option) : t_Option'0
  
  goal vc_core: op'0 (core_total self) (core_total self) = C_Some'0 (core_total self)
      && op'0 (core_total self) self = C_Some'0 self
    -> ([@expl:core ensures] match C_Some'0 (core_total self) with
      | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
      | C_None'0 -> true
      end)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__core_is_maximal_idemp (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function core (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function core_total (self: t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. op'0 (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. op'0 (core_total self) self = C_Some'0 self
  
  function core'0 (self: t_Option) : t_Option'0 = C_Some'0 (core_total self)
  
  axiom core_spec'0: forall self: t_Option. match core'0 self with
        | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function factor'0 (self: t_Option) (factor'1: t_Option) : t_Option'0 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None} -> C_Some'0 x
      | {f0 = C_None} -> C_None'0
      | {f0 = C_Some x; f1 = C_Some y} -> match factor x y with
        | C_Some z -> C_Some'0 (C_Some z)
        | C_None -> if x = y then C_Some'0 (C_None) else C_None'0
        end
      end
  
  axiom factor_spec'0: forall self: t_Option, factor'1: t_Option. match factor'0 self factor'1 with
        | C_Some'0 c -> op'0 factor'1 c = C_Some'0 self
        | C_None'0 -> forall c: t_Option. op'0 factor'1 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_Option) (other: t_Option) = factor'0 other self <> C_None'0
  
  function core_is_maximal_idemp (self: t_T) (i: t_T) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_T, i: t_T. op i i = C_Some i
      -> op i self = C_Some self
      -> match core self with
        | C_Some c -> incl i c
        | C_None -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option
  
  constant i : t_Option
  
  function core_is_maximal_idemp'0 (self: t_Option) (i: t_Option) : ()
  
  goal vc_core_is_maximal_idemp: op'0 i i = C_Some'0 i
    -> op'0 i self = C_Some'0 self
    -> match { f0 = self; f1 = i } with
      | {f0 = C_Some x; f1 = C_Some i'0} -> (([@expl:core_is_maximal_idemp requires #0] op i'0 i'0 = C_Some i'0)
        && ([@expl:core_is_maximal_idemp requires #1] op i'0 x = C_Some x))
      /\ (match core x with
          | C_Some c -> incl i'0 c
          | C_None -> false
          end
      -> ([@expl:core_is_maximal_idemp ensures] match core'0 self with
        | C_Some'0 c -> incl'0 i c
        | C_None'0 -> false
        end))
      | _ -> [@expl:core_is_maximal_idemp ensures] match core'0 self with
        | C_Some'0 c -> incl'0 i c
        | C_None'0 -> false
        end
      end
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__unit (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option; f2: t_Option }
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : () = match { f0 = a; f1 = b; f2 = c } with
      | {f0 = C_None} -> ()
      | {f1 = C_None} -> ()
      | {f2 = C_None} -> ()
      | {f0 = C_Some aa; f1 = C_Some bb; f2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : () = ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit' : t_Option
  
  goal vc_unit: let result = C_None in [@expl:unit ensures] forall x: t_Option [op'0 x result]. op'0 x result
      = C_Some'0 x
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__core_total (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option; f2: t_Option }
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : () = match { f0 = a; f1 = b; f2 = c } with
      | {f0 = C_None} -> ()
      | {f1 = C_None} -> ()
      | {f2 = C_None} -> ()
      | {f0 = C_Some aa; f1 = C_Some bb; f2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : () = ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  function core (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option
  
  function core_total (self: t_Option) : t_Option
  
  goal vc_core_total: match self with
      | C_None -> let result = C_None in ([@expl:core_total ensures #0] op'0 result result = C_Some'0 result)
      && ([@expl:core_total ensures #1] op'0 result self = C_Some'0 self)
      | C_Some x -> match core x with
          | C_Some c -> op c c = C_Some c /\ op c x = C_Some x
          | C_None -> true
          end
      -> (let result = core x in ([@expl:core_total ensures #0] op'0 result result = C_Some'0 result)
      && ([@expl:core_total ensures #1] op'0 result self = C_Some'0 self))
      end
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__core_is_total (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option; f2: t_Option }
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : () = match { f0'0 = a; f1'0 = b; f2 = c } with
      | {f0'0 = C_None} -> ()
      | {f1'0 = C_None} -> ()
      | {f2 = C_None} -> ()
      | {f0'0 = C_Some aa; f1'0 = C_Some bb; f2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : () = ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  function core (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function core_total (self: t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. op'0 (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. op'0 (core_total self) self = C_Some'0 self
  
  function core'0 (self: t_Option) : t_Option'0 = C_Some'0 (core_total self)
  
  axiom core_spec'0: forall self: t_Option. match core'0 self with
        | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option
  
  function core_is_total (self: t_Option) : ()
  
  goal vc_core_is_total: [@expl:core_is_total ensures] core'0 self = C_Some'0 (core_total self)
end
module M_creusot_contracts__logic__ra__option__qyi9919140421117497760__update (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_OptionUpdate = { t_OptionUpdate__0: t_U }
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  type t_Choice
  
  predicate premise (self: t_U) (from: t_R)
  
  predicate premise'0 (self: t_OptionUpdate) (from: t_Option) =
    match from with
      | C_Some from'0 -> premise self.t_OptionUpdate__0 from'0
      | C_None -> false
      end
  
  function update (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_OptionUpdate
  
  constant from : t_Option
  
  constant ch : t_Choice
  
  function update'0 (self: t_OptionUpdate) (from: t_Option) (ch: t_Choice) : t_Option
  
  goal vc_update: premise'0 self from
    -> match from with
      | C_Some from'0 -> [@expl:update requires] premise self.t_OptionUpdate__0 from'0
      | C_None -> true
      end
end
module M_creusot_contracts__logic__ra__option__qyi9919140421117497760__frame_preserving (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_OptionUpdate = { t_OptionUpdate__0: t_U }
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  type t_Choice
  
  predicate premise (self: t_U) (from: t_R)
  
  predicate premise'0 (self: t_OptionUpdate) (from: t_Option) =
    match from with
      | C_Some from'0 -> premise self.t_OptionUpdate__0 from'0
      | C_None -> false
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option; f2: t_Option }
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : () = match { f0 = a; f1 = b; f2 = c } with
      | {f0 = C_None} -> ()
      | {f1 = C_None} -> ()
      | {f2 = C_None} -> ()
      | {f0 = C_Some aa; f1 = C_Some bb; f2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : () = ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  function update (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update'0 (self: t_OptionUpdate) (from: t_Option) (ch: t_Choice) : t_Option = match from with
      | C_Some from'0 -> C_Some (update self.t_OptionUpdate__0 from'0 ch)
      | C_None -> C_None
      end
  
  predicate index_logic [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. (exists x: t_R. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_R = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_R) -> true)
      end
  
  function frame_preserving (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_spec: forall self: t_U, from: t_R, frame: t_R. premise self from
      -> op from frame <> C_None -> op (update self from (frame_preserving self from frame)) frame <> C_None
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that'0 (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec'0: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_logic'0 p x)
      -> index_logic'0 p (such_that'0 p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_OptionUpdate
  
  constant from : t_Option
  
  constant frame : t_Option
  
  function frame_preserving'0 (self: t_OptionUpdate) (from: t_Option) (frame: t_Option) : t_Choice
  
  goal vc_frame_preserving: premise'0 self from
    -> op'0 from frame <> C_None'0
    -> match frame with
      | C_Some frame'0 -> ([@expl:unwrap_logic requires] from <> C_None)
      /\ (([@expl:frame_preserving requires #0] premise self.t_OptionUpdate__0 (unwrap_logic from))
        && ([@expl:frame_preserving requires #1] op (unwrap_logic from) frame'0 <> C_None))
      /\ (op (update self.t_OptionUpdate__0 (unwrap_logic from) (frame_preserving self.t_OptionUpdate__0 (unwrap_logic from) frame'0)) frame'0
        <> C_None
      -> ([@expl:frame_preserving ensures] op'0 (update'0 self from (frame_preserving self.t_OptionUpdate__0 (unwrap_logic from) frame'0)) frame
      <> C_None'0))
      | C_None -> ([@expl:such_that requires] exists x: t_Choice. index_logic'0 (fun (__0: t_Choice) -> true) x)
      /\ (index_logic'0 (fun (__0: t_Choice) -> true) (such_that'0 (fun (__0: t_Choice) -> true))
      -> ([@expl:frame_preserving ensures] op'0 (update'0 self from (such_that'0 (fun (__0: t_Choice) -> true))) frame
      <> C_None'0))
      end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__factor (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                               f1 = y }))
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tuple
  
  constant factor'1 : tuple
  
  function factor'2 (self: tuple) (factor'1: tuple) : t_Option
  
  goal vc_factor: match factor self.f0 factor'1.f0 with
        | C_Some'0 c -> op factor'1.f0 c = C_Some'0 (self.f0)
        | C_None'0 -> forall c: t_T. op factor'1.f0 c <> C_Some'0 (self.f0)
        end
    -> match factor'0 self.f1 factor'1.f1 with
        | C_Some'1 c -> op'0 factor'1.f1 c = C_Some'1 (self.f1)
        | C_None'1 -> forall c: t_U. op'0 factor'1.f1 c <> C_Some'1 (self.f1)
        end
    -> match { f0'0 = factor self.f0 factor'1.f0; f1'0 = factor'0 self.f1 factor'1.f1 } with
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'1 y} -> [@expl:factor ensures] match C_Some { f0 = x; f1 = y } with
        | C_Some c -> op'1 factor'1 c = C_Some self
        | C_None -> forall c: tuple. op'1 factor'1 c <> C_Some self
        end
      | _ -> [@expl:factor ensures] match C_None with
        | C_Some c -> op'1 factor'1 c = C_Some self
        | C_None -> forall c: tuple. op'1 factor'1 c <> C_Some self
        end
      end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__commutative (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                               f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : tuple
  
  constant b : tuple
  
  function commutative'1 (a: tuple) (b: tuple) : ()
  
  goal vc_commutative: [@expl:commutative ensures] op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__associative (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                 f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : tuple
  
  constant b : tuple
  
  constant c : tuple
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : ()
  
  goal vc_associative: [@expl:associative ensures] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
    = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__core (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                               f1 = y }))
  
  function core (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core'0 (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. match core'0 self with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tuple
  
  function core'1 (self: tuple) : t_Option
  
  goal vc_core: match core self.f0 with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self.f0 = C_Some'0 (self.f0)
        | C_None'0 -> true
        end
    -> match core'0 self.f1 with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self.f1 = C_Some'1 (self.f1)
        | C_None'1 -> true
        end
    -> match { f0'0 = core self.f0; f1'0 = core'0 self.f1 } with
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'1 y} -> [@expl:core ensures] match C_Some { f0 = x; f1 = y } with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
      | _ -> [@expl:core ensures] match C_None with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
      end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__core_is_maximal_idemp (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                               f1 = y }))
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'1 }
  
  function core (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core'0 (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. match core'0 self with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  function core'1 (self: tuple) : t_Option = match { f0'0 = core self.f0; f1'0 = core'0 self.f1 } with
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'1 y} -> C_Some { f0 = x; f1 = y }
      | _ -> C_None
      end
  
  axiom core_spec'1: forall self: tuple. match core'1 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  function factor'1 (self: tuple) (factor'2: tuple) : t_Option = match { f0'0 = factor self.f0 factor'2.f0;
                                                                         f1'0 = factor'0 self.f1 factor'2.f1 } with
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'1 y} -> C_Some { f0 = x; f1 = y }
      | _ -> C_None
      end
  
  axiom factor_spec'1: forall self: tuple, factor'2: tuple. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: tuple. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'1 (self: tuple) (other: tuple) = factor'1 other self <> C_None
  
  function core_is_maximal_idemp (self: t_T) (i: t_T) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_T, i: t_T. op i i = C_Some'0 i
      -> op i self = C_Some'0 self
      -> match core self with
        | C_Some'0 c -> incl i c
        | C_None'0 -> false
        end
  
  function core_is_maximal_idemp'0 (self: t_U) (i: t_U) : ()
  
  axiom core_is_maximal_idemp_spec'0: forall self: t_U, i: t_U. op'0 i i = C_Some'1 i
      -> op'0 i self = C_Some'1 self
      -> match core'0 self with
        | C_Some'1 c -> incl'0 i c
        | C_None'1 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tuple
  
  constant i : tuple
  
  function core_is_maximal_idemp'1 (self: tuple) (i: tuple) : ()
  
  goal vc_core_is_maximal_idemp: op'1 i i = C_Some i
    -> op'1 i self = C_Some self
    -> (([@expl:core_is_maximal_idemp requires #0] op i.f0 i.f0 = C_Some'0 (i.f0))
      && ([@expl:core_is_maximal_idemp requires #1] op i.f0 self.f0 = C_Some'0 (self.f0)))
    /\ (match core self.f0 with
        | C_Some'0 c -> incl i.f0 c
        | C_None'0 -> false
        end
    -> (let _ = core_is_maximal_idemp self.f0 i.f0 in (([@expl:core_is_maximal_idemp requires #0] op'0 i.f1 i.f1
        = C_Some'1 (i.f1))
      && ([@expl:core_is_maximal_idemp requires #1] op'0 i.f1 self.f1 = C_Some'1 (self.f1)))
    /\ (match core'0 self.f1 with
        | C_Some'1 c -> incl'0 i.f1 c
        | C_None'1 -> false
        end
    -> (let _ = core_is_maximal_idemp'0 self.f1 i.f1 in [@expl:core_is_maximal_idemp ensures] match core'1 self with
      | C_Some c -> incl'1 i c
      | C_None -> false
      end))))
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__unit (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                 f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  function core_total (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_T
  
  axiom unit_spec: forall x: t_T [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_T. incl x x
  
  function core_total'0 (self: t_U) : t_U
  
  axiom core_total_spec'1: forall self: t_U. op'0 (core_total'0 self) (core_total'0 self) = C_Some'1 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_U. op'0 (core_total'0 self) self = C_Some'1 self
  
  constant unit''0 : t_U
  
  axiom unit_spec'0: forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x
  
  constant unit_core'0: () = ()
  
  axiom unit_core_spec'0: core_total'0 unit''0 = unit''0
  
  constant incl_refl'0: () = let _ = unit''0 in ()
  
  axiom incl_refl_spec'0: forall x: t_U. incl'0 x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit''1 : tuple
  
  goal vc_unit: (forall x: t_T [op x unit']. op x unit' = C_Some'0 x)
    -> (forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x)
    -> (let result = { f0 = unit'; f1 = unit''0 } in [@expl:unit ensures] forall x: tuple [op'1 x result]. op'1 x result
      = C_Some x)
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__core_total (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                 f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  constant unit' : t_T
  
  axiom unit_spec: forall x: t_T [op x unit']. op x unit' = C_Some'0 x
  
  function core_total (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. op (core_total self) self = C_Some'0 self
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_T. incl x x
  
  constant unit''0 : t_U
  
  axiom unit_spec'0: forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x
  
  function core_total'0 (self: t_U) : t_U
  
  axiom core_total_spec'1: forall self: t_U. op'0 (core_total'0 self) (core_total'0 self) = C_Some'1 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_U. op'0 (core_total'0 self) self = C_Some'1 self
  
  constant unit_core'0: () = ()
  
  axiom unit_core_spec'0: core_total'0 unit''0 = unit''0
  
  constant incl_refl'0: () = let _ = unit''0 in ()
  
  axiom incl_refl_spec'0: forall x: t_U. incl'0 x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tuple
  
  function core_total'1 (self: tuple) : tuple
  
  goal vc_core_total: op (core_total self.f0) (core_total self.f0) = C_Some'0 (core_total self.f0)
      && op (core_total self.f0) self.f0 = C_Some'0 (self.f0)
    -> op'0 (core_total'0 self.f1) (core_total'0 self.f1) = C_Some'1 (core_total'0 self.f1)
      && op'0 (core_total'0 self.f1) self.f1 = C_Some'1 (self.f1)
    -> (let result = { f0 = core_total self.f0;
                       f1 = core_total'0 self.f1 } in ([@expl:core_total ensures #0] op'1 result result = C_Some result)
    && ([@expl:core_total ensures #1] op'1 result self = C_Some self))
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__core_is_total (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                 f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'1 }
  
  function core (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core'0 (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. match core'0 self with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  function core'1 (self: tuple) : t_Option = match { f0'0 = core self.f0; f1'0 = core'0 self.f1 } with
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'1 y} -> C_Some { f0 = x; f1 = y }
      | _ -> C_None
      end
  
  axiom core_spec'1: forall self: tuple. match core'1 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  constant unit' : t_T
  
  axiom unit_spec: forall x: t_T [op x unit']. op x unit' = C_Some'0 x
  
  function core_total (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. op (core_total self) self = C_Some'0 self
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_T. incl x x
  
  constant unit''0 : t_U
  
  axiom unit_spec'0: forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x
  
  function core_total'0 (self: t_U) : t_U
  
  axiom core_total_spec'1: forall self: t_U. op'0 (core_total'0 self) (core_total'0 self) = C_Some'1 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_U. op'0 (core_total'0 self) self = C_Some'1 self
  
  constant unit_core'0: () = ()
  
  axiom unit_core_spec'0: core_total'0 unit''0 = unit''0
  
  constant incl_refl'0: () = let _ = unit''0 in ()
  
  axiom incl_refl_spec'0: forall x: t_U. incl'0 x x
  
  function core_total'1 (self: tuple) : tuple = { f0 = core_total self.f0; f1 = core_total'0 self.f1 }
  
  axiom core_total_spec'3: forall self: tuple. op'1 (core_total'1 self) (core_total'1 self) = C_Some (core_total'1 self)
  
  axiom core_total_spec'4: forall self: tuple. op'1 (core_total'1 self) self = C_Some self
  
  function core_is_total (self: t_T) : ()
  
  axiom core_is_total_spec: forall self: t_T. core self = C_Some'0 (core_total self)
  
  function core_is_total'0 (self: t_U) : ()
  
  axiom core_is_total_spec'0: forall self: t_U. core'0 self = C_Some'1 (core_total'0 self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tuple
  
  function core_is_total'1 (self: tuple) : ()
  
  goal vc_core_is_total: core self.f0 = C_Some'0 (core_total self.f0)
    -> (let _ = core_is_total self.f0 in core'0 self.f1 = C_Some'1 (core_total'0 self.f1)
    -> (let _ = core_is_total'0 self.f1 in [@expl:core_is_total ensures] core'1 self = C_Some (core_total'1 self)))
end
module M_creusot_contracts__logic__ra__prod__qyi12871785784760244066__update (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate = { t_ProdUpdate__0: t_U1; t_ProdUpdate__1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tuple = { f0: t_R1; f1: t_R2 }
  
  type t_Choice
  
  type t_Choice'0
  
  type tuple'0 = { f0'0: t_Choice; f1'0: t_Choice'0 }
  
  predicate premise (self: t_U1) (from: t_R1)
  
  predicate premise'0 (self: t_U2) (from: t_R2)
  
  predicate premise'1 (self: t_ProdUpdate) (from: tuple) =
    premise self.t_ProdUpdate__0 from.f0 /\ premise'0 self.t_ProdUpdate__1 from.f1
  
  function update (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update'0 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ProdUpdate
  
  constant from : tuple
  
  constant ch : tuple'0
  
  function update'1 (self: t_ProdUpdate) (from: tuple) (ch: tuple'0) : tuple
  
  goal vc_update: premise'1 self from
    -> ([@expl:update requires] premise self.t_ProdUpdate__0 from.f0)
    /\ ([@expl:update requires] premise'0 self.t_ProdUpdate__1 from.f1)
end
module M_creusot_contracts__logic__ra__prod__qyi12871785784760244066__frame_preserving (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate = { t_ProdUpdate__0: t_U1; t_ProdUpdate__1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tuple = { f0: t_R1; f1: t_R2 }
  
  type t_Choice
  
  type t_Choice'0
  
  type tuple'0 = { f0'0: t_Choice; f1'0: t_Choice'0 }
  
  predicate premise (self: t_U1) (from: t_R1)
  
  predicate premise'0 (self: t_U2) (from: t_R2)
  
  predicate premise'1 (self: t_ProdUpdate) (from: tuple) =
    premise self.t_ProdUpdate__0 from.f0 /\ premise'0 self.t_ProdUpdate__1 from.f1
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_R1 t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic (self: t_Option'1) (f: Map.map t_R2 tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_R1) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_R2) -> { f0 = x;
                                                                                                                   f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  function update (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update'0 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  function update'1 (self: t_ProdUpdate) (from: tuple) (ch: tuple'0) : tuple =
    { f0 = update self.t_ProdUpdate__0 from.f0 ch.f0'0; f1 = update'0 self.t_ProdUpdate__1 from.f1 ch.f1'0 }
  
  function frame_preserving (self: t_U1) (from: t_R1) (frame: t_R1) : t_Choice
  
  axiom frame_preserving_spec: forall self: t_U1, from: t_R1, frame: t_R1. premise self from
      -> op from frame <> C_None'0 -> op (update self from (frame_preserving self from frame)) frame <> C_None'0
  
  function frame_preserving'0 (self: t_U2) (from: t_R2) (frame: t_R2) : t_Choice'0
  
  axiom frame_preserving_spec'0: forall self: t_U2, from: t_R2, frame: t_R2. premise'0 self from
      -> op'0 from frame <> C_None'1 -> op'0 (update'0 self from (frame_preserving'0 self from frame)) frame <> C_None'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ProdUpdate
  
  constant from : tuple
  
  constant frame : tuple
  
  function frame_preserving'1 (self: t_ProdUpdate) (from: tuple) (frame: tuple) : tuple'0
  
  goal vc_frame_preserving: premise'1 self from
    -> op'1 from frame <> C_None
    -> (([@expl:frame_preserving requires #0] premise self.t_ProdUpdate__0 from.f0)
      && ([@expl:frame_preserving requires #1] op from.f0 frame.f0 <> C_None'0))
    /\ (op (update self.t_ProdUpdate__0 from.f0 (frame_preserving self.t_ProdUpdate__0 from.f0 frame.f0)) frame.f0
      <> C_None'0
    -> (([@expl:frame_preserving requires #0] premise'0 self.t_ProdUpdate__1 from.f1)
      && ([@expl:frame_preserving requires #1] op'0 from.f1 frame.f1 <> C_None'1))
    /\ (op'0 (update'0 self.t_ProdUpdate__1 from.f1 (frame_preserving'0 self.t_ProdUpdate__1 from.f1 frame.f1)) frame.f1
      <> C_None'1
    -> ([@expl:frame_preserving ensures] op'1 (update'1 self from { f0'0 = frame_preserving self.t_ProdUpdate__0 from.f0 frame.f0;
                                                                    f1'0 = frame_preserving'0 self.t_ProdUpdate__1 from.f1 frame.f1 }) frame
    <> C_None)))
end
module M_creusot_contracts__logic__ra__prod__qyi5623508861439716845__frame_preserving (* <logic::ra::prod::ProdLocalUpdate<U1, U2> as logic::ra::update::LocalUpdate<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U1
  
  type t_U2
  
  type t_ProdLocalUpdate = { t_ProdLocalUpdate__0: t_U1; t_ProdLocalUpdate__1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tuple = { f0: t_R1; f1: t_R2 }
  
  type t_Option = C_None | C_Some tuple
  
  predicate premise (self: t_U1) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise'0 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise'1 (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple) =
    premise self.t_ProdLocalUpdate__0 from_auth.f0 from_frag.f0
    /\ premise'0 self.t_ProdLocalUpdate__1 from_auth.f1 from_frag.f1
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R1
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R1 t_Option) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> Map.get f x
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'1
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'2 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'1 comb -> incl self comb
  
  type t_Option'2 = C_None'2 | C_Some'2 t_R2
  
  function map_logic'0 (self: t_Option'2) (f: Map.map t_R2 tuple) : t_Option = match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'3 (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'2
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'3 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'3 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'2 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'1 (op self.f0 other.f0) (fun (x: t_R1) -> map_logic'0 (op'0 self.f1 other.f1) (fun (y: t_R2) -> { f0 = x;
                                                                                                                     f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic'0 (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op'1 x y) (fun (z: tuple) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  type tuple'1 = { f0'1: tuple; f1'1: tuple }
  
  type tuple'2 = { f0'2: t_R1; f1'2: t_R1 }
  
  function update (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) : tuple'2
  
  type tuple'3 = { f0'3: t_R2; f1'3: t_R2 }
  
  function update'0 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) : tuple'3
  
  function update'1 (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple) : tuple'1 =
    let {f0'2 = to_auth0; f1'2 = to_frag0} = update self.t_ProdLocalUpdate__0 from_auth.f0 from_frag.f0 in let {f0'3 = to_auth1; f1'3 = to_frag1} = update'0 self.t_ProdLocalUpdate__1 from_auth.f1 from_frag.f1 in { f0'1 = { f0 = to_auth0;
                                                                                                                                                                                                                               f1 = to_auth1 };
                                                                                                                                                                                                                      f1'1 = { f0 = to_frag0;
                                                                                                                                                                                                                               f1 = to_frag1 } }
  
  function map_logic'1 (self: t_Option) (f: Map.map tuple t_R1) : t_Option'1 = match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  type t_Option'3 = C_None'3 | C_Some'3 t_Option'1
  
  function and_then_logic'4 (self: t_Option'3) (f: Map.map t_Option'1 t_Option'3) : t_Option'3 = match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple'4 = { f0'4: t_Option'1; f1'4: t_Option'1 }
  
  function map_logic'2 (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'3 = match self with
      | C_None'1 -> C_None'3
      | C_Some'1 x -> C_Some'3 (Map.get f x)
      end
  
  function op'3 (self: t_Option'1) (other: t_Option'1) : t_Option'3 = match { f0'4 = self; f1'4 = other } with
      | {f0'4 = C_None'1} -> C_Some'3 other
      | {f1'4 = C_None'1} -> C_Some'3 self
      | {f0'4 = C_Some'1 x; f1'4 = C_Some'1 y} -> map_logic'2 (op x y) (fun (z: t_R1) -> C_Some'1 z)
      end
  
  function associative'3 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'3:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'4 (op'3 a b) (fun (ab: t_Option'1) -> op'3 ab c)
      = and_then_logic'4 (op'3 b c) (fun (bc: t_Option'1) -> op'3 a bc)
  
  function commutative'3 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'3: forall a: t_Option'1, b: t_Option'1. op'3 a b = op'3 b a
  
  function frame_preserving (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) (frame: t_Option'1) : ()
  
  axiom frame_preserving_spec:
    forall self: t_U1, from_auth: t_R1, from_frag: t_R1, frame: t_Option'1. premise self from_auth from_frag
      -> op'3 (C_Some'1 from_frag) frame = C_Some'3 (C_Some'1 from_auth)
      -> (let {f0'2 = to_auth; f1'2 = to_frag} = update self from_auth from_frag in op'3 (C_Some'1 to_frag) frame
      = C_Some'3 (C_Some'1 to_auth))
  
  function map_logic'3 (self: t_Option) (f: Map.map tuple t_R2) : t_Option'2 = match self with
      | C_None -> C_None'2
      | C_Some x -> C_Some'2 (Map.get f x)
      end
  
  type t_Option'4 = C_None'4 | C_Some'4 t_Option'2
  
  function and_then_logic'5 (self: t_Option'4) (f: Map.map t_Option'2 t_Option'4) : t_Option'4 = match self with
      | C_None'4 -> C_None'4
      | C_Some'4 x -> Map.get f x
      end
  
  type tuple'5 = { f0'5: t_Option'2; f1'5: t_Option'2 }
  
  function map_logic'4 (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'4 = match self with
      | C_None'2 -> C_None'4
      | C_Some'2 x -> C_Some'4 (Map.get f x)
      end
  
  function op'4 (self: t_Option'2) (other: t_Option'2) : t_Option'4 = match { f0'5 = self; f1'5 = other } with
      | {f0'5 = C_None'2} -> C_Some'4 other
      | {f1'5 = C_None'2} -> C_Some'4 self
      | {f0'5 = C_Some'2 x; f1'5 = C_Some'2 y} -> map_logic'4 (op'0 x y) (fun (z: t_R2) -> C_Some'2 z)
      end
  
  function associative'4 (a: t_Option'2) (b: t_Option'2) (c: t_Option'2) : ()
  
  axiom associative_spec'4:
    forall a: t_Option'2, b: t_Option'2, c: t_Option'2. and_then_logic'5 (op'4 a b) (fun (ab: t_Option'2) -> op'4 ab c)
      = and_then_logic'5 (op'4 b c) (fun (bc: t_Option'2) -> op'4 a bc)
  
  function commutative'4 (a: t_Option'2) (b: t_Option'2) : ()
  
  axiom commutative_spec'4: forall a: t_Option'2, b: t_Option'2. op'4 a b = op'4 b a
  
  function frame_preserving'0 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) (frame: t_Option'2) : ()
  
  axiom frame_preserving_spec'0:
    forall self: t_U2, from_auth: t_R2, from_frag: t_R2, frame: t_Option'2. premise'0 self from_auth from_frag
      -> op'4 (C_Some'2 from_frag) frame = C_Some'4 (C_Some'2 from_auth)
      -> (let {f0'3 = to_auth; f1'3 = to_frag} = update'0 self from_auth from_frag in op'4 (C_Some'2 to_frag) frame
      = C_Some'4 (C_Some'2 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ProdLocalUpdate
  
  constant from_auth : tuple
  
  constant from_frag : tuple
  
  constant frame : t_Option
  
  function frame_preserving'1 (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple) (frame: t_Option) : ()
  
  goal vc_frame_preserving: premise'1 self from_auth from_frag
    -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
    -> (([@expl:frame_preserving requires #0] premise self.t_ProdLocalUpdate__0 from_auth.f0 from_frag.f0)
      && ([@expl:frame_preserving requires #1] op'3 (C_Some'1 (from_frag.f0)) (map_logic'1 frame (fun (f: tuple) -> f.f0))
      = C_Some'3 (C_Some'1 (from_auth.f0))))
    /\ ((let {f0'2 = to_auth; f1'2 = to_frag} = update self.t_ProdLocalUpdate__0 from_auth.f0 from_frag.f0 in op'3 (C_Some'1 to_frag) (map_logic'1 frame (fun (f: tuple) -> f.f0))
      = C_Some'3 (C_Some'1 to_auth))
    -> (let _ = frame_preserving self.t_ProdLocalUpdate__0 from_auth.f0 from_frag.f0 (map_logic'1 frame (fun (f: tuple) -> f.f0)) in (([@expl:frame_preserving requires #0] premise'0 self.t_ProdLocalUpdate__1 from_auth.f1 from_frag.f1)
      && ([@expl:frame_preserving requires #1] op'4 (C_Some'2 (from_frag.f1)) (map_logic'3 frame (fun (f: tuple) -> f.f1))
      = C_Some'4 (C_Some'2 (from_auth.f1))))
    /\ ((let {f0'3 = to_auth; f1'3 = to_frag} = update'0 self.t_ProdLocalUpdate__1 from_auth.f1 from_frag.f1 in op'4 (C_Some'2 to_frag) (map_logic'3 frame (fun (f: tuple) -> f.f1))
      = C_Some'4 (C_Some'2 to_auth))
    -> (let _ = frame_preserving'0 self.t_ProdLocalUpdate__1 from_auth.f1 from_frag.f1 (map_logic'3 frame (fun (f: tuple) -> f.f1)) in [@expl:frame_preserving ensures] let {f0'1 = to_auth; f1'1 = to_frag} = update'1 self from_auth from_frag in op'2 (C_Some to_frag) frame
    = C_Some'0 (C_Some to_auth)))))
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__factor (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum
  
  constant factor'1 : t_Sum
  
  function factor'2 (self: t_Sum) (factor'1: t_Sum) : t_Option
  
  goal vc_factor: match { f0 = self; f1 = factor'1 } with
      | {f0 = C_Left x; f1 = C_Left y} -> match factor x y with
          | C_Some'0 c -> op y c = C_Some'0 x
          | C_None'0 -> forall c: t_R1. op y c <> C_Some'0 x
          end
      -> ([@expl:factor ensures] match map_logic (factor x y) (fun (l: t_R1) -> C_Left l) with
        | C_Some c -> op'1 factor'1 c = C_Some self
        | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
        end)
      | {f0 = C_Right x; f1 = C_Right y} -> match factor'0 x y with
          | C_Some'1 c -> op'0 y c = C_Some'1 x
          | C_None'1 -> forall c: t_R2. op'0 y c <> C_Some'1 x
          end
      -> ([@expl:factor ensures] match map_logic'0 (factor'0 x y) (fun (r: t_R2) -> C_Right r) with
        | C_Some c -> op'1 factor'1 c = C_Some self
        | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
        end)
      | _ -> [@expl:factor ensures] match C_None with
        | C_Some c -> op'1 factor'1 c = C_Some self
        | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
        end
      end
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__commutative (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Sum
  
  constant b : t_Sum
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : ()
  
  goal vc_commutative: [@expl:commutative ensures] op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__associative (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  function and_then_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'0 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'1 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Sum
  
  constant b : t_Sum
  
  constant c : t_Sum
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
  goal vc_associative: [@expl:associative ensures] and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
    = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__core (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function core (self: t_R1) : t_Option'0
  
  axiom core_spec: forall self: t_R1. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core'0 (self: t_R2) : t_Option'1
  
  axiom core_spec'0: forall self: t_R2. match core'0 self with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum
  
  function core'1 (self: t_Sum) : t_Option
  
  goal vc_core: match self with
      | C_Left x -> match core x with
          | C_Some'0 c -> op c c = C_Some'0 c /\ op c x = C_Some'0 x
          | C_None'0 -> true
          end
      -> ([@expl:core ensures] match map_logic (core x) (fun (l: t_R1) -> C_Left l) with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end)
      | C_Right x -> match core'0 x with
          | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c x = C_Some'1 x
          | C_None'1 -> true
          end
      -> ([@expl:core ensures] match map_logic'0 (core'0 x) (fun (r: t_R2) -> C_Right r) with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end)
      end
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__core_is_maximal_idemp (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function core (self: t_R1) : t_Option'0
  
  axiom core_spec: forall self: t_R1. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core'0 (self: t_R2) : t_Option'1
  
  axiom core_spec'0: forall self: t_R2. match core'0 self with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  function core'1 (self: t_Sum) : t_Option = match self with
      | C_Left x -> map_logic (core x) (fun (l: t_R1) -> C_Left l)
      | C_Right x -> map_logic'0 (core'0 x) (fun (r: t_R2) -> C_Right r)
      end
  
  axiom core_spec'1: forall self: t_Sum. match core'1 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  function factor'1 (self: t_Sum) (factor'2: t_Sum) : t_Option = match { f0 = self; f1 = factor'2 } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (factor x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (factor'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  axiom factor_spec'1: forall self: t_Sum, factor'2: t_Sum. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: t_Sum. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'1 (self: t_Sum) (other: t_Sum) = factor'1 other self <> C_None
  
  function core_is_maximal_idemp (self: t_R1) (i: t_R1) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_R1, i: t_R1. op i i = C_Some'0 i
      -> op i self = C_Some'0 self
      -> match core self with
        | C_Some'0 c -> incl i c
        | C_None'0 -> false
        end
  
  function core_is_maximal_idemp'0 (self: t_R2) (i: t_R2) : ()
  
  axiom core_is_maximal_idemp_spec'0: forall self: t_R2, i: t_R2. op'0 i i = C_Some'1 i
      -> op'0 i self = C_Some'1 self
      -> match core'0 self with
        | C_Some'1 c -> incl'0 i c
        | C_None'1 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum
  
  constant i : t_Sum
  
  function core_is_maximal_idemp'1 (self: t_Sum) (i: t_Sum) : ()
  
  goal vc_core_is_maximal_idemp: op'1 i i = C_Some i
    -> op'1 i self = C_Some self
    -> match { f0 = self; f1 = i } with
      | {f0 = C_Left s; f1 = C_Left i'0} -> (([@expl:core_is_maximal_idemp requires #0] op i'0 i'0 = C_Some'0 i'0)
        && ([@expl:core_is_maximal_idemp requires #1] op i'0 s = C_Some'0 s))
      /\ (match core s with
          | C_Some'0 c -> incl i'0 c
          | C_None'0 -> false
          end
      -> ([@expl:core_is_maximal_idemp ensures] match core'1 self with
        | C_Some c -> incl'1 i c
        | C_None -> false
        end))
      | {f0 = C_Right s; f1 = C_Right i'0} -> (([@expl:core_is_maximal_idemp requires #0] op'0 i'0 i'0 = C_Some'1 i'0)
        && ([@expl:core_is_maximal_idemp requires #1] op'0 i'0 s = C_Some'1 s))
      /\ (match core'0 s with
          | C_Some'1 c -> incl'0 i'0 c
          | C_None'1 -> false
          end
      -> ([@expl:core_is_maximal_idemp ensures] match core'1 self with
        | C_Some c -> incl'1 i c
        | C_None -> false
        end))
      | _ -> [@expl:core_is_maximal_idemp ensures] match core'1 self with
        | C_Some c -> incl'1 i c
        | C_None -> false
        end
      end
end
module M_creusot_contracts__logic__ra__sum__qyi1847493758823096333__update (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateL = { t_SumUpdateL__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Choice
  
  predicate premise (self: t_U) (from: t_R1)
  
  predicate premise'0 (self: t_SumUpdateL) (from: t_Sum) =
    match from with
      | C_Left from'0 -> premise self.t_SumUpdateL__0 from'0
      | C_Right _ -> false
      end
  
  function update (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateL
  
  constant from : t_Sum
  
  constant ch : t_Choice
  
  function update'0 (self: t_SumUpdateL) (from: t_Sum) (ch: t_Choice) : t_Sum
  
  goal vc_update: premise'0 self from
    -> match from with
      | C_Left from'0 -> [@expl:update requires] premise self.t_SumUpdateL__0 from'0
      | x -> true
      end
end
module M_creusot_contracts__logic__ra__sum__qyi1847493758823096333__frame_preserving (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateL = { t_SumUpdateL__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Choice
  
  predicate premise (self: t_U) (from: t_R1)
  
  predicate premise'0 (self: t_SumUpdateL) (from: t_Sum) =
    match from with
      | C_Left from'0 -> premise self.t_SumUpdateL__0 from'0
      | C_Right _ -> false
      end
  
  type t_Option = C_None | C_Some t_Sum
  
  function and_then_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'0 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'1 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : () = ()
  
  axiom associative_spec'1:
    forall a: t_Sum, b: t_Sum, c: t_Sum. and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : () = ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. op'1 a b = op'1 b a
  
  function update (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update'0 (self: t_SumUpdateL) (from: t_Sum) (ch: t_Choice) : t_Sum = match from with
      | C_Left from'0 -> C_Left (update self.t_SumUpdateL__0 from'0 ch)
      | x -> x
      end
  
  function frame_preserving (self: t_U) (from: t_R1) (frame: t_R1) : t_Choice
  
  axiom frame_preserving_spec: forall self: t_U, from: t_R1, frame: t_R1. premise self from
      -> op from frame <> C_None'0 -> op (update self from (frame_preserving self from frame)) frame <> C_None'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_logic p x)
      -> index_logic p (such_that p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateL
  
  constant from : t_Sum
  
  constant frame : t_Sum
  
  function frame_preserving'0 (self: t_SumUpdateL) (from: t_Sum) (frame: t_Sum) : t_Choice
  
  goal vc_frame_preserving: premise'0 self from
    -> op'1 from frame <> C_None
    -> match { f0 = from; f1 = frame } with
      | {f0 = C_Left from'0; f1 = C_Left frame'0} -> (([@expl:frame_preserving requires #0] premise self.t_SumUpdateL__0 from'0)
        && ([@expl:frame_preserving requires #1] op from'0 frame'0 <> C_None'0))
      /\ (op (update self.t_SumUpdateL__0 from'0 (frame_preserving self.t_SumUpdateL__0 from'0 frame'0)) frame'0
        <> C_None'0
      -> ([@expl:frame_preserving ensures] op'1 (update'0 self from (frame_preserving self.t_SumUpdateL__0 from'0 frame'0)) frame
      <> C_None))
      | _ -> ([@expl:such_that requires] exists x: t_Choice. index_logic (fun (__0: t_Choice) -> true) x)
      /\ (index_logic (fun (__0: t_Choice) -> true) (such_that (fun (__0: t_Choice) -> true))
      -> ([@expl:frame_preserving ensures] op'1 (update'0 self from (such_that (fun (__0: t_Choice) -> true))) frame
      <> C_None))
      end
end
module M_creusot_contracts__logic__ra__sum__qyi15765748900338894532__update (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateR = { t_SumUpdateR__0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum = C_Left t_V | C_Right t_R
  
  type t_Choice
  
  predicate premise (self: t_U) (from: t_R)
  
  predicate premise'0 (self: t_SumUpdateR) (from: t_Sum) =
    match from with
      | C_Right from'0 -> premise self.t_SumUpdateR__0 from'0
      | C_Left _ -> false
      end
  
  function update (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateR
  
  constant from : t_Sum
  
  constant ch : t_Choice
  
  function update'0 (self: t_SumUpdateR) (from: t_Sum) (ch: t_Choice) : t_Sum
  
  goal vc_update: premise'0 self from
    -> match from with
      | C_Right from'0 -> [@expl:update requires] premise self.t_SumUpdateR__0 from'0
      | x -> true
      end
end
module M_creusot_contracts__logic__ra__sum__qyi15765748900338894532__frame_preserving (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateR = { t_SumUpdateR__0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum = C_Left t_V | C_Right t_R
  
  type t_Choice
  
  predicate premise (self: t_U) (from: t_R)
  
  predicate premise'0 (self: t_SumUpdateR) (from: t_Sum) =
    match from with
      | C_Right from'0 -> premise self.t_SumUpdateR__0 from'0
      | C_Left _ -> false
      end
  
  type t_Option = C_None | C_Some t_Sum
  
  function and_then_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R) (other: t_R) : t_Option'1
  
  function factor'0 (self: t_R) (factor'1: t_R) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R, factor'1: t_R. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R) (other: t_R) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R, b: t_R, c: t_R. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec'0: forall a: t_R, b: t_R, c: t_R. and_then_logic'1 (op'0 a b) (fun (ab: t_R) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_R) -> op'0 a bc)
  
  function commutative'0 (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec'0: forall a: t_R, b: t_R. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R, other: t_R, comb: t_R. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_V) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : () = ()
  
  axiom associative_spec'1:
    forall a: t_Sum, b: t_Sum, c: t_Sum. and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : () = ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. op'1 a b = op'1 b a
  
  function update (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update'0 (self: t_SumUpdateR) (from: t_Sum) (ch: t_Choice) : t_Sum = match from with
      | C_Right from'0 -> C_Right (update self.t_SumUpdateR__0 from'0 ch)
      | x -> x
      end
  
  function frame_preserving (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_spec: forall self: t_U, from: t_R, frame: t_R. premise self from
      -> op'0 from frame <> C_None'1 -> op'0 (update self from (frame_preserving self from frame)) frame <> C_None'1
  
  predicate index_logic [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_logic p x)
      -> index_logic p (such_that p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateR
  
  constant from : t_Sum
  
  constant frame : t_Sum
  
  function frame_preserving'0 (self: t_SumUpdateR) (from: t_Sum) (frame: t_Sum) : t_Choice
  
  goal vc_frame_preserving: premise'0 self from
    -> op'1 from frame <> C_None
    -> match { f0 = from; f1 = frame } with
      | {f0 = C_Right from'0; f1 = C_Right frame'0} -> (([@expl:frame_preserving requires #0] premise self.t_SumUpdateR__0 from'0)
        && ([@expl:frame_preserving requires #1] op'0 from'0 frame'0 <> C_None'1))
      /\ (op'0 (update self.t_SumUpdateR__0 from'0 (frame_preserving self.t_SumUpdateR__0 from'0 frame'0)) frame'0
        <> C_None'1
      -> ([@expl:frame_preserving ensures] op'1 (update'0 self from (frame_preserving self.t_SumUpdateR__0 from'0 frame'0)) frame
      <> C_None))
      | _ -> ([@expl:such_that requires] exists x: t_Choice. index_logic (fun (__0: t_Choice) -> true) x)
      /\ (index_logic (fun (__0: t_Choice) -> true) (such_that (fun (__0: t_Choice) -> true))
      -> ([@expl:frame_preserving ensures] op'1 (update'0 self from (such_that (fun (__0: t_Choice) -> true))) frame
      <> C_None))
      end
end
module M_creusot_contracts__logic__ra__sum__qyi3083214512297526849__frame_preserving (* <logic::ra::sum::SumLocalUpdateL<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateL = { t_SumLocalUpdateL__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  predicate premise (self: t_U) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise'0 (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum) =
    match { f0 = from_auth; f1 = from_frag } with
      | {f0 = C_Left from_auth'0; f1 = C_Left from_frag'0} -> premise self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0
      | {f0 = C_Right _; f1 = C_Right _} -> false
      | _ -> true
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R1
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'1
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'1 comb -> incl self comb
  
  type t_Option'2 = C_None'2 | C_Some'2 t_R2
  
  function map_logic'1 (self: t_Option'2) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'2
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'2 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic'0 (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'1 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : () = ()
  
  axiom associative_spec'1:
    forall a: t_Sum, b: t_Sum, c: t_Sum. and_then_logic'0 (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : () = ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. op'1 a b = op'1 b a
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_Sum) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  type tuple'1 = { f0'1: t_R1; f1'1: t_R1 }
  
  function update (self: t_U) (from_auth: t_R1) (from_frag: t_R1) : tuple'1
  
  predicate index_logic [@inline:trivial] (self: Map.map tuple bool) (a: tuple) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map tuple bool) : tuple
  
  axiom such_that_spec: forall p: Map.map tuple bool. (exists x: tuple. index_logic p x) -> index_logic p (such_that p)
  
  function update'0 (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum) : tuple = match { f0 = from_auth;
                                                                                                      f1 = from_frag } with
      | {f0 = C_Left from_auth'0; f1 = C_Left from_frag'0} -> let {f0'1 = to_auth; f1'1 = to_frag} = update self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0 in { f0 = C_Left to_auth;
                                                                                                                                                                   f1 = C_Left to_frag }
      | _ -> such_that (fun (__0: tuple) -> true)
      end
  
  type tuple'2 = { f0'2: t_Sum; f1'2: t_Sum; f2: t_Option }
  
  type t_Option'3 = C_None'3 | C_Some'3 t_Option'1
  
  function and_then_logic'3 (self: t_Option'3) (f: Map.map t_Option'1 t_Option'3) : t_Option'3 = match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple'3 = { f0'3: t_Option'1; f1'3: t_Option'1 }
  
  function map_logic'2 (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'3 = match self with
      | C_None'1 -> C_None'3
      | C_Some'1 x -> C_Some'3 (Map.get f x)
      end
  
  function op'3 (self: t_Option'1) (other: t_Option'1) : t_Option'3 = match { f0'3 = self; f1'3 = other } with
      | {f0'3 = C_None'1} -> C_Some'3 other
      | {f1'3 = C_None'1} -> C_Some'3 self
      | {f0'3 = C_Some'1 x; f1'3 = C_Some'1 y} -> map_logic'2 (op x y) (fun (z: t_R1) -> C_Some'1 z)
      end
  
  function associative'3 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'3:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'3 (op'3 a b) (fun (ab: t_Option'1) -> op'3 ab c)
      = and_then_logic'3 (op'3 b c) (fun (bc: t_Option'1) -> op'3 a bc)
  
  function commutative'3 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'3: forall a: t_Option'1, b: t_Option'1. op'3 a b = op'3 b a
  
  function frame_preserving (self: t_U) (from_auth: t_R1) (from_frag: t_R1) (frame: t_Option'1) : ()
  
  axiom frame_preserving_spec:
    forall self: t_U, from_auth: t_R1, from_frag: t_R1, frame: t_Option'1. premise self from_auth from_frag
      -> op'3 (C_Some'1 from_frag) frame = C_Some'3 (C_Some'1 from_auth)
      -> (let {f0'1 = to_auth; f1'1 = to_frag} = update self from_auth from_frag in op'3 (C_Some'1 to_frag) frame
      = C_Some'3 (C_Some'1 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumLocalUpdateL
  
  constant from_auth : t_Sum
  
  constant from_frag : t_Sum
  
  constant frame : t_Option
  
  function frame_preserving'0 (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum) (frame: t_Option) : ()
  
  goal vc_frame_preserving: premise'0 self from_auth from_frag
    -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
    -> match { f0'2 = from_auth; f1'2 = from_frag; f2 = frame } with
      | {f0'2 = C_Left from_auth'0; f1'2 = C_Left from_frag'0; f2 = C_Some (C_Left frame'0)} -> (([@expl:frame_preserving requires #0] premise self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0)
        && ([@expl:frame_preserving requires #1] op'3 (C_Some'1 from_frag'0) (C_Some'1 frame'0)
        = C_Some'3 (C_Some'1 from_auth'0)))
      /\ ((let {f0'1 = to_auth; f1'1 = to_frag} = update self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0 in op'3 (C_Some'1 to_frag) (C_Some'1 frame'0)
        = C_Some'3 (C_Some'1 to_auth))
      -> ([@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
      = C_Some'0 (C_Some to_auth)))
      | {f0'2 = C_Left from_auth'0; f1'2 = C_Left from_frag'0; f2 = C_None} -> (([@expl:frame_preserving requires #0] premise self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0)
        && ([@expl:frame_preserving requires #1] op'3 (C_Some'1 from_frag'0) (C_None'1)
        = C_Some'3 (C_Some'1 from_auth'0)))
      /\ ((let {f0'1 = to_auth; f1'1 = to_frag} = update self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0 in op'3 (C_Some'1 to_frag) (C_None'1)
        = C_Some'3 (C_Some'1 to_auth))
      -> ([@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
      = C_Some'0 (C_Some to_auth)))
      | _ -> [@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
      = C_Some'0 (C_Some to_auth)
      end
end
module M_creusot_contracts__logic__ra__sum__qyi3543961907530750261__frame_preserving (* <logic::ra::sum::SumLocalUpdateR<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateR = { t_SumLocalUpdateR__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  predicate premise (self: t_U) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise'0 (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum) =
    match { f0 = from_auth; f1 = from_frag } with
      | {f0 = C_Right from_auth'0; f1 = C_Right from_frag'0} -> premise self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0
      | {f0 = C_Left _; f1 = C_Left _} -> false
      | _ -> true
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R1
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'1
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'1 comb -> incl self comb
  
  type t_Option'2 = C_None'2 | C_Some'2 t_R2
  
  function map_logic'1 (self: t_Option'2) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'2
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'2 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic'0 (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'1 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : () = ()
  
  axiom associative_spec'1:
    forall a: t_Sum, b: t_Sum, c: t_Sum. and_then_logic'0 (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : () = ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. op'1 a b = op'1 b a
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_Sum) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  type tuple'1 = { f0'1: t_R2; f1'1: t_R2 }
  
  function update (self: t_U) (from_auth: t_R2) (from_frag: t_R2) : tuple'1
  
  predicate index_logic [@inline:trivial] (self: Map.map tuple bool) (a: tuple) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map tuple bool) : tuple
  
  axiom such_that_spec: forall p: Map.map tuple bool. (exists x: tuple. index_logic p x) -> index_logic p (such_that p)
  
  function update'0 (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum) : tuple = match { f0 = from_auth;
                                                                                                      f1 = from_frag } with
      | {f0 = C_Right from_auth'0; f1 = C_Right from_frag'0} -> let {f0'1 = to_auth; f1'1 = to_frag} = update self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0 in { f0 = C_Right to_auth;
                                                                                                                                                                     f1 = C_Right to_frag }
      | _ -> such_that (fun (__0: tuple) -> true)
      end
  
  type tuple'2 = { f0'2: t_Sum; f1'2: t_Sum; f2: t_Option }
  
  type t_Option'3 = C_None'3 | C_Some'3 t_Option'2
  
  function and_then_logic'3 (self: t_Option'3) (f: Map.map t_Option'2 t_Option'3) : t_Option'3 = match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple'3 = { f0'3: t_Option'2; f1'3: t_Option'2 }
  
  function map_logic'2 (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'3 = match self with
      | C_None'2 -> C_None'3
      | C_Some'2 x -> C_Some'3 (Map.get f x)
      end
  
  function op'3 (self: t_Option'2) (other: t_Option'2) : t_Option'3 = match { f0'3 = self; f1'3 = other } with
      | {f0'3 = C_None'2} -> C_Some'3 other
      | {f1'3 = C_None'2} -> C_Some'3 self
      | {f0'3 = C_Some'2 x; f1'3 = C_Some'2 y} -> map_logic'2 (op'0 x y) (fun (z: t_R2) -> C_Some'2 z)
      end
  
  function associative'3 (a: t_Option'2) (b: t_Option'2) (c: t_Option'2) : ()
  
  axiom associative_spec'3:
    forall a: t_Option'2, b: t_Option'2, c: t_Option'2. and_then_logic'3 (op'3 a b) (fun (ab: t_Option'2) -> op'3 ab c)
      = and_then_logic'3 (op'3 b c) (fun (bc: t_Option'2) -> op'3 a bc)
  
  function commutative'3 (a: t_Option'2) (b: t_Option'2) : ()
  
  axiom commutative_spec'3: forall a: t_Option'2, b: t_Option'2. op'3 a b = op'3 b a
  
  function frame_preserving (self: t_U) (from_auth: t_R2) (from_frag: t_R2) (frame: t_Option'2) : ()
  
  axiom frame_preserving_spec:
    forall self: t_U, from_auth: t_R2, from_frag: t_R2, frame: t_Option'2. premise self from_auth from_frag
      -> op'3 (C_Some'2 from_frag) frame = C_Some'3 (C_Some'2 from_auth)
      -> (let {f0'1 = to_auth; f1'1 = to_frag} = update self from_auth from_frag in op'3 (C_Some'2 to_frag) frame
      = C_Some'3 (C_Some'2 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumLocalUpdateR
  
  constant from_auth : t_Sum
  
  constant from_frag : t_Sum
  
  constant frame : t_Option
  
  function frame_preserving'0 (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum) (frame: t_Option) : ()
  
  goal vc_frame_preserving: premise'0 self from_auth from_frag
    -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
    -> match { f0'2 = from_auth; f1'2 = from_frag; f2 = frame } with
      | {f0'2 = C_Right from_auth'0; f1'2 = C_Right from_frag'0; f2 = C_Some (C_Right frame'0)} -> (([@expl:frame_preserving requires #0] premise self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0)
        && ([@expl:frame_preserving requires #1] op'3 (C_Some'2 from_frag'0) (C_Some'2 frame'0)
        = C_Some'3 (C_Some'2 from_auth'0)))
      /\ ((let {f0'1 = to_auth; f1'1 = to_frag} = update self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0 in op'3 (C_Some'2 to_frag) (C_Some'2 frame'0)
        = C_Some'3 (C_Some'2 to_auth))
      -> ([@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
      = C_Some'0 (C_Some to_auth)))
      | {f0'2 = C_Right from_auth'0; f1'2 = C_Right from_frag'0; f2 = C_None} -> (([@expl:frame_preserving requires #0] premise self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0)
        && ([@expl:frame_preserving requires #1] op'3 (C_Some'2 from_frag'0) (C_None'2)
        = C_Some'3 (C_Some'2 from_auth'0)))
      /\ ((let {f0'1 = to_auth; f1'1 = to_frag} = update self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0 in op'3 (C_Some'2 to_frag) (C_None'2)
        = C_Some'3 (C_Some'2 to_auth))
      -> ([@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
      = C_Some'0 (C_Some to_auth)))
      | _ -> [@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
      = C_Some'0 (C_Some to_auth)
      end
end
module M_creusot_contracts__logic__ra__update__qyi11826117606277287715__update (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  predicate premise (self: t_R) (from: t_R) = forall y: t_R. op from y <> C_None -> op self y <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_R
  
  constant from : t_R
  
  constant _3 : ()
  
  function update (self: t_R) (from: t_R) (_3: ()) : t_R
  
  goal vc_update: true
end
module M_creusot_contracts__logic__ra__update__qyi11826117606277287715__frame_preserving (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  predicate premise (self: t_R) (from: t_R) = forall y: t_R. op from y <> C_None -> op self y <> C_None
  
  function update (self: t_R) (from: t_R) (_3: ()) : t_R = self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_R
  
  constant from : t_R
  
  constant frame : t_R
  
  function frame_preserving (self: t_R) (from: t_R) (frame: t_R) : ()
  
  goal vc_frame_preserving: premise self from
    -> op from frame <> C_None -> ([@expl:frame_preserving ensures] op (update self from ()) frame <> C_None)
end
module M_creusot_contracts__logic__ra__update__qyi5477729486377161480__update (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function index_logic [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate premise (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op from y <> C_None -> (exists ch: t_Choice. op (index_logic self ch) y <> C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Map.map t_Choice t_R
  
  constant from : t_R
  
  constant ch : t_Choice
  
  function update (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R
  
  goal vc_update: true
end
module M_creusot_contracts__logic__ra__update__qyi5477729486377161480__frame_preserving (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function index_logic [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate premise (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op from y <> C_None -> (exists ch: t_Choice. op (index_logic self ch) y <> C_None)
  
  function update (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R = index_logic self ch
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_logic'0 p x)
      -> index_logic'0 p (such_that p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Map.map t_Choice t_R
  
  constant from : t_R
  
  constant frame : t_R
  
  function frame_preserving (self: Map.map t_Choice t_R) (from: t_R) (frame: t_R) : t_Choice
  
  goal vc_frame_preserving: premise self from
    -> op from frame <> C_None
    -> (forall ch: t_Choice. [@expl:update requires] premise self from)
    /\ ([@expl:such_that requires] exists x: t_Choice. index_logic'0 (fun (ch: t_Choice) -> op (update self from ch) frame
        <> C_None) x)
    /\ (index_logic'0 (fun (ch: t_Choice) -> op (update self from ch) frame
      <> C_None) (such_that (fun (ch: t_Choice) -> op (update self from ch) frame <> C_None))
    -> ([@expl:frame_preserving ensures] op (update self from (such_that (fun (ch: t_Choice) -> op (update self from ch) frame
      <> C_None))) frame
    <> C_None))
end
module M_creusot_contracts__logic__ra__update__qyi10922308247021603688__frame_preserving (* <snapshot::Snapshot<(R, R)> as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type tuple = { f0: t_R; f1: t_R }
  
  type t_Option = C_None | C_Some t_R
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  predicate premise (self: tuple) (from_auth: t_R) (from_frag: t_R) =
    forall f: t_Option. op'0 (C_Some from_frag) f = C_Some'0 (C_Some from_auth)
      -> op'0 (C_Some (self.f1)) f = C_Some'0 (C_Some (self.f0))
  
  function update (self: tuple) (_2: t_R) (_3: t_R) : tuple = self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tuple
  
  constant from_auth : t_R
  
  constant from_frag : t_R
  
  constant frame : t_Option
  
  function frame_preserving (self: tuple) (from_auth: t_R) (from_frag: t_R) (frame: t_Option) : ()
  
  goal vc_frame_preserving: premise self from_auth from_frag
    -> op'0 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
    -> ([@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update self from_auth from_frag in op'0 (C_Some to_frag) frame
    = C_Some'0 (C_Some to_auth))
end
module M_creusot_contracts__logic__ra__view__qyi3129231301466035151__inhabits (* <logic::ra::view::InnerView<R> as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function inhabits : t_InnerView
  
  goal vc_inhabits: (forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x)
    -> ([@expl:inhabits ensures] invariant' { t_InnerView__auth = C_None; t_InnerView__frag = unit' })
end
module M_creusot_contracts__logic__ra__view__qyi9160327263184903567__frag (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View
  
  function frag (self: t_View) : t_Frag
  
  goal vc_frag: invariant' (view self.t_View__0)
    -> ([@expl:frag ensures] rel (auth self) (view self.t_View__0).t_InnerView__frag)
end
module M_creusot_contracts__logic__ra__view__qyi9160327263184903567__ext_eq (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function view_inj (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. view self = view other -> self = other
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View
  
  constant other : t_View
  
  predicate ext_eq (self: t_View) (other: t_View)
  
  goal vc_ext_eq: if auth self = auth other then
      rel (auth self) (frag self)
      -> rel (auth other) (frag other) -> ([@expl:ext_eq ensures] (frag self = frag other) = (self = other))
    else
      [@expl:ext_eq ensures] false = (self = other)

end
module M_creusot_contracts__logic__ra__view__qyi9160327263184903567__new (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant auth'0 : t_Option
  
  constant frag'0 : t_Frag
  
  function new (auth'0: t_Option) (frag'0: t_Frag) : t_View
  
  goal vc_new: rel auth'0 frag'0
    -> ([@expl:new_logic requires] invariant' { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 })
    /\ (view (new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 })
      = { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 }
    -> (let result = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                               t_InnerView__frag = frag'0 } } in ([@expl:new ensures #0] auth result
      = auth'0)
    && ([@expl:new ensures #1] frag result = frag'0)))
end
module M_creusot_contracts__logic__ra__view__qyi9160327263184903567__new_frag (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                        t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant frag'0 : t_Frag
  
  function new_frag (frag'0: t_Frag) : t_View
  
  goal vc_new_frag: rel (C_None) frag'0 -> ([@expl:new requires] rel (C_None) frag'0)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__factor (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function view_inj (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. view self = view other -> self = other
  
  function new_frag [@inline:trivial] (frag'0: t_Frag) : t_View = new (C_None'1) frag'0
  
  meta "rewrite_def" function new_frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View
  
  constant factor'0 : t_View
  
  function factor'1 (self: t_View) (factor'0: t_View) : t_Option
  
  goal vc_factor: rel (auth self) (frag self)
    -> rel (auth factor'0) (frag factor'0)
    -> match factor (frag self) (frag factor'0) with
        | C_Some'0 c -> op (frag factor'0) c = C_Some'0 (frag self)
        | C_None'0 -> forall c: t_Frag. op (frag factor'0) c <> C_Some'0 (frag self)
        end
    -> match factor (frag self) (frag factor'0) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth factor'0 } with
        | {f0 = C_Some'1 a; f1 = C_None'1} -> ([@expl:new requires] rel (C_Some'1 a) f)
        /\ (auth (new (C_Some'1 a) f) = C_Some'1 a && frag (new (C_Some'1 a) f) = f
        -> ([@expl:factor ensures] match C_Some (new (C_Some'1 a) f) with
          | C_Some c -> op'0 factor'0 c = C_Some self
          | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
          end))
        | {f0 = a1; f1 = a2} -> if a1 = a2 then
          ([@expl:new_frag requires] rel (C_None'1) f)
          /\ ([@expl:factor ensures] match C_Some (new_frag f) with
            | C_Some c -> op'0 factor'0 c = C_Some self
            | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
            end)
        else
          [@expl:factor ensures] match C_None with
            | C_Some c -> op'0 factor'0 c = C_Some self
            | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
            end
        
        end
      | C_None'0 -> [@expl:factor ensures] match C_None with
        | C_Some c -> op'0 factor'0 c = C_Some self
        | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
        end
      end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__commutative (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_View
  
  constant b : t_View
  
  function commutative'0 (a: t_View) (b: t_View) : ()
  
  goal vc_commutative: [@expl:commutative ensures] op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__associative (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1; f2: t_Option'1 }
  
  function view_inj (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. view self = view other -> self = other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_View
  
  constant b : t_View
  
  constant c : t_View
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : ()
  
  goal vc_associative: rel (auth a) (frag a)
    -> rel (auth b) (frag b)
    -> rel (auth b) (frag b)
    -> rel (auth c) (frag c)
    -> match { f0'0 = op (frag a) (frag b); f1'0 = op (frag b) (frag c) } with
      | {f0'0 = C_Some'0 fab; f1'0 = C_Some'0 fbc} -> rel (auth c) (frag c)
      -> rel (auth a) (frag a)
      -> match { f0'0 = op fab (frag c); f1'0 = op (frag a) fbc } with
        | {f0'0 = C_Some'0 fabc1; f1'0 = C_Some'0 fabc2} -> fabc1 = fabc2
        && match { f0'1 = auth a; f1'1 = auth b; f2 = auth c } with
          | {f0'1 = C_Some'1 _; f1'1 = C_None'1; f2 = C_None'1} | {f0'1 = C_None'1; f1'1 = C_Some'1 _; f2 = C_None'1} | {f0'1 = C_None'1; f1'1 = C_None'1; f2 = C_Some'1 _} -> [@expl:associative ensures] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
          = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
          | _ -> [@expl:associative ensures] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
          = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
          end
        | _ -> [@expl:associative ensures] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
        = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
        end
      | _ -> [@expl:associative ensures] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
      end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__core (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function new_frag [@inline:trivial] (frag'0: t_Frag) : t_View = new (C_None'1) frag'0
  
  meta "rewrite_def" function new_frag
  
  function core_total'0 (self: t_View) : t_View = new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. op'0 (core_total'0 self) (core_total'0 self)
      = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. op'0 (core_total'0 self) self = C_Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View
  
  function core (self: t_View) : t_Option
  
  goal vc_core: op'0 (core_total'0 self) (core_total'0 self) = C_Some (core_total'0 self)
      && op'0 (core_total'0 self) self = C_Some self
    -> ([@expl:core ensures] match C_Some (core_total'0 self) with
      | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
      | C_None -> true
      end)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__core_is_maximal_idemp (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function new_frag [@inline:trivial] (frag'0: t_Frag) : t_View = new (C_None'1) frag'0
  
  meta "rewrite_def" function new_frag
  
  function core_total'0 (self: t_View) : t_View = new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. op'0 (core_total'0 self) (core_total'0 self)
      = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. op'0 (core_total'0 self) self = C_Some self
  
  function core (self: t_View) : t_Option = C_Some (core_total'0 self)
  
  axiom core_spec: forall self: t_View. match core self with
        | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
        | C_None -> true
        end
  
  function factor'0 (self: t_View) (factor'1: t_View) : t_Option = match factor (frag self) (frag factor'1) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth factor'1 } with
        | {f0 = C_Some'1 a; f1 = C_None'1} -> C_Some (new (C_Some'1 a) f)
        | {f0 = a1; f1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'0: forall self: t_View, factor'1: t_View. match factor'0 self factor'1 with
        | C_Some c -> op'0 factor'1 c = C_Some self
        | C_None -> forall c: t_View. op'0 factor'1 c <> C_Some self
        end
  
  predicate incl'0 (self: t_View) (other: t_View) = factor'0 other self <> C_None
  
  function core'0 (self: t_Frag) : t_Option'0
  
  axiom core_spec'0: forall self: t_Frag. match core'0 self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core_is_total (self: t_Frag) : ()
  
  axiom core_is_total_spec: forall self: t_Frag. core'0 self = C_Some'0 (core_total self)
  
  function core_is_maximal_idemp (self: t_Frag) (i: t_Frag) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_Frag, i: t_Frag. op i i = C_Some'0 i
      -> op i self = C_Some'0 self
      -> match core'0 self with
        | C_Some'0 c -> incl i c
        | C_None'0 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View
  
  constant i : t_View
  
  function core_is_maximal_idemp'0 (self: t_View) (i: t_View) : ()
  
  goal vc_core_is_maximal_idemp: op'0 i i = C_Some i
    -> op'0 i self = C_Some self
    -> rel (auth self) (frag self)
    -> rel (auth i) (frag i)
    -> (([@expl:core_is_maximal_idemp requires #0] op (frag i) (frag i) = C_Some'0 (frag i))
      && ([@expl:core_is_maximal_idemp requires #1] op (frag i) (frag self) = C_Some'0 (frag self)))
    /\ (match core'0 (frag self) with
        | C_Some'0 c -> incl (frag i) c
        | C_None'0 -> false
        end
    -> ([@expl:core_is_maximal_idemp ensures] match core self with
      | C_Some c -> incl'0 i c
      | C_None -> false
      end))
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__unit (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'0 = { f0'0: t_Option'1; f1'0: t_Option'1; f2: t_Option'1 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'1; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some'1 _; f1'0 = C_None'1; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_Some'1 _; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  predicate ext_eq (self: t_View) (other: t_View) = auth self = auth other /\ frag self = frag other
  
  axiom ext_eq_spec: forall self: t_View, other: t_View. ext_eq self other = (self = other)
  
  function new_frag [@inline:trivial] (frag'0: t_Frag) : t_View = new (C_None'1) frag'0
  
  meta "rewrite_def" function new_frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit''0 : t_View
  
  goal vc_unit: (forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x)
    -> ([@expl:new_frag requires] rel (C_None'1) unit')
    /\ (let result = new_frag unit' in [@expl:unit ensures] forall x: t_View [op'0 x result]. op'0 x result = C_Some x)
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__core_total (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'0 = { f0'0: t_Option'1; f1'0: t_Option'1; f2: t_Option'1 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'1; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some'1 _; f1'0 = C_None'1; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_Some'1 _; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  function core (self: t_Frag) : t_Option'0
  
  axiom core_spec: forall self: t_Frag. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core_is_total (self: t_Frag) : ()
  
  axiom core_is_total_spec: forall self: t_Frag. core self = C_Some'0 (core_total self)
  
  predicate ext_eq (self: t_View) (other: t_View) = auth self = auth other /\ frag self = frag other
  
  axiom ext_eq_spec: forall self: t_View, other: t_View. ext_eq self other = (self = other)
  
  function new_frag [@inline:trivial] (frag'0: t_Frag) : t_View = new (C_None'1) frag'0
  
  meta "rewrite_def" function new_frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View
  
  function core_total'0 (self: t_View) : t_View
  
  goal vc_core_total: rel (auth self) (frag self)
    -> op (core_total (frag self)) (core_total (frag self)) = C_Some'0 (core_total (frag self))
      && op (core_total (frag self)) (frag self) = C_Some'0 (frag self)
    -> ([@expl:new_frag requires] rel (C_None'1) (core_total (frag self)))
    /\ (let result = new_frag (core_total (frag self)) in ([@expl:core_total ensures #0] op'0 result result
      = C_Some result)
    && ([@expl:core_total ensures #1] op'0 result self = C_Some self))
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__core_is_total (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1; f2: t_Option'1 }
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0'0 = op (frag a) (frag b);
                                                                                    f1'0 = op (frag b) (frag c) } with
      | {f0'0 = C_Some'0 fab; f1'0 = C_Some'0 fbc} -> match { f0'0 = op fab (frag c); f1'0 = op (frag a) fbc } with
        | {f0'0 = C_Some'0 fabc1; f1'0 = C_Some'0 fabc2} -> match { f0'1 = auth a; f1'1 = auth b; f2 = auth c } with
          | {f0'1 = C_Some'1 _; f1'1 = C_None'1; f2 = C_None'1} | {f0'1 = C_None'1; f1'1 = C_Some'1 _; f2 = C_None'1} | {f0'1 = C_None'1; f1'1 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  function new_frag [@inline:trivial] (frag'0: t_Frag) : t_View = new (C_None'1) frag'0
  
  meta "rewrite_def" function new_frag
  
  function core_total'0 (self: t_View) : t_View = new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. op'0 (core_total'0 self) (core_total'0 self)
      = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. op'0 (core_total'0 self) self = C_Some self
  
  function core (self: t_View) : t_Option = C_Some (core_total'0 self)
  
  axiom core_spec: forall self: t_View. match core self with
        | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
        | C_None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View
  
  function core_is_total (self: t_View) : ()
  
  goal vc_core_is_total: [@expl:core_is_total ensures] core self = C_Some (core_total'0 self)
end
module M_creusot_contracts__logic__ra__view__qyi5759646997670148869__update (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate = { t_ViewUpdate__0: Map.map t_Choice tuple }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function index_logic [@inline:trivial] (self: Map.map t_Choice tuple) (a: t_Choice) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise (self: t_ViewUpdate) (from: t_View) =
    auth from <> C_None
    /\ (forall ch: t_Choice. rel (C_Some ((index_logic self.t_ViewUpdate__0 ch).f0)) (index_logic self.t_ViewUpdate__0 ch).f1)
    /\ (forall frame: t_Frag. match op (frag from) frame with
          | C_Some'0 ff -> rel (auth from) ff
          | C_None'0 -> false
          end
      -> (exists ch: t_Choice. match op (index_logic self.t_ViewUpdate__0 ch).f1 frame with
          | C_Some'0 ff -> rel (C_Some ((index_logic self.t_ViewUpdate__0 ch).f0)) ff
          | C_None'0 -> false
          end))
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                        t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdate
  
  constant from : t_View
  
  constant ch : t_Choice
  
  function update (self: t_ViewUpdate) (from: t_View) (ch: t_Choice) : t_View
  
  goal vc_update: premise self from
    -> ([@expl:new requires] rel (C_Some ((index_logic self.t_ViewUpdate__0 ch).f0)) (index_logic self.t_ViewUpdate__0 ch).f1)
end
module M_creusot_contracts__logic__ra__view__qyi5759646997670148869__frame_preserving (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate = { t_ViewUpdate__0: Map.map t_Choice tuple }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function index_logic [@inline:trivial] (self: Map.map t_Choice tuple) (a: t_Choice) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise (self: t_ViewUpdate) (from: t_View) =
    auth from <> C_None
    /\ (forall ch: t_Choice. rel (C_Some ((index_logic self.t_ViewUpdate__0 ch).f0)) (index_logic self.t_ViewUpdate__0 ch).f1)
    /\ (forall frame: t_Frag. match op (frag from) frame with
          | C_Some'0 ff -> rel (auth from) ff
          | C_None'0 -> false
          end
      -> (exists ch: t_Choice. match op (index_logic self.t_ViewUpdate__0 ch).f1 frame with
          | C_Some'0 ff -> rel (C_Some ((index_logic self.t_ViewUpdate__0 ch).f0)) ff
          | C_None'0 -> false
          end))
  
  type t_Option'1 = C_None'1 | C_Some'1 t_View
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_View t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  type tuple'1 = { f0'1: t_Option; f1'1: t_Option; f2: t_Option }
  
  type tuple'2 = { f0'2: t_Option; f1'2: t_Option }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                        t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option'1 = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'2 = auth self; f1'2 = auth other } with
        | {f0'2 = C_None; f1'2 = a} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | {f0'2 = a; f1'2 = C_None} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | _ -> C_None'1
        end
      | C_None'0 -> C_None'1
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0'0 = op (frag a) (frag b);
                                                                                    f1'0 = op (frag b) (frag c) } with
      | {f0'0 = C_Some'0 fab; f1'0 = C_Some'0 fbc} -> match { f0'0 = op fab (frag c); f1'0 = op (frag a) fbc } with
        | {f0'0 = C_Some'0 fabc1; f1'0 = C_Some'0 fabc2} -> match { f0'1 = auth a; f1'1 = auth b; f2 = auth c } with
          | {f0'1 = C_Some _; f1'1 = C_None; f2 = C_None} | {f0'1 = C_None; f1'1 = C_Some _; f2 = C_None} | {f0'1 = C_None; f1'1 = C_None; f2 = C_Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic'0 (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  function update (self: t_ViewUpdate) (from: t_View) (ch: t_Choice) : t_View =
    new (C_Some ((index_logic self.t_ViewUpdate__0 ch).f0)) (index_logic self.t_ViewUpdate__0 ch).f1
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_logic'0 p x)
      -> index_logic'0 p (such_that p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdate
  
  constant from : t_View
  
  constant frame : t_View
  
  function frame_preserving (self: t_ViewUpdate) (from: t_View) (frame: t_View) : t_Choice
  
  goal vc_frame_preserving: premise self from
    -> op'0 from frame <> C_None'1
    -> (forall ch: t_Choice. [@expl:update requires] premise self from)
    /\ ([@expl:such_that requires] exists x: t_Choice. index_logic'0 (fun (ch: t_Choice) -> op'0 (update self from ch) frame
        <> C_None'1) x)
    /\ (index_logic'0 (fun (ch: t_Choice) -> op'0 (update self from ch) frame
      <> C_None'1) (such_that (fun (ch: t_Choice) -> op'0 (update self from ch) frame <> C_None'1))
    -> ([@expl:frame_preserving ensures] op'0 (update self from (such_that (fun (ch: t_Choice) -> op'0 (update self from ch) frame
      <> C_None'1))) frame
    <> C_None'1))
end
module M_creusot_contracts__logic__ra__view__qyi7400797033094478444__update (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_ViewUpdateInsert = { t_ViewUpdateInsert__0: t_Auth; t_ViewUpdateInsert__1: t_Frag }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  predicate premise (self: t_ViewUpdateInsert) (from: t_View) =
    auth from <> C_None
    /\ (forall f: t_Frag. rel (auth from) f
      -> match op self.t_ViewUpdateInsert__1 f with
        | C_Some'0 ff -> rel (C_Some (self.t_ViewUpdateInsert__0)) ff
        | C_None'0 -> false
        end)
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                        t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateInsert
  
  constant from : t_View
  
  constant _3 : ()
  
  function update (self: t_ViewUpdateInsert) (from: t_View) (_3: ()) : t_View
  
  goal vc_update: premise self from
    -> ([@expl:new requires] rel (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1)
    /\ (auth (new (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1)
        = C_Some (self.t_ViewUpdateInsert__0)
      && frag (new (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1) = self.t_ViewUpdateInsert__1
    -> ([@expl:update ensures] rel (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1))
end
module M_creusot_contracts__logic__ra__view__qyi7400797033094478444__frame_preserving (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_ViewUpdateInsert = { t_ViewUpdateInsert__0: t_Auth; t_ViewUpdateInsert__1: t_Frag }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  predicate premise (self: t_ViewUpdateInsert) (from: t_View) =
    auth from <> C_None
    /\ (forall f: t_Frag. rel (auth from) f
      -> match op self.t_ViewUpdateInsert__1 f with
        | C_Some'0 ff -> rel (C_Some (self.t_ViewUpdateInsert__0)) ff
        | C_None'0 -> false
        end)
  
  type t_Option'1 = C_None'1 | C_Some'1 t_View
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_View t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option; f2: t_Option }
  
  type tuple'1 = { f0'1: t_Option; f1'1: t_Option }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                        t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option'1 = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None; f1'1 = a} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | {f0'1 = a; f1'1 = C_None} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | _ -> C_None'1
        end
      | C_None'0 -> C_None'1
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some _; f1'0 = C_None; f2 = C_None} | {f0'0 = C_None; f1'0 = C_Some _; f2 = C_None} | {f0'0 = C_None; f1'0 = C_None; f2 = C_Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic'0 (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  function update (self: t_ViewUpdateInsert) (from: t_View) (_3: ()) : t_View =
    new (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  axiom update_spec: forall self: t_ViewUpdateInsert, from: t_View, _3: (). premise self from
      -> rel (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateInsert
  
  constant from : t_View
  
  constant frame : t_View
  
  function frame_preserving (self: t_ViewUpdateInsert) (from: t_View) (frame: t_View) : ()
  
  goal vc_frame_preserving: premise self from
    -> op'0 from frame <> C_None'1
    -> rel (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
    && ([@expl:frame_preserving ensures] op'0 (update self from ()) frame <> C_None'1)
end
module M_creusot_contracts__logic__ra__view__qyi5746217084655472194__update (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_ViewUpdateRemove = { t_ViewUpdateRemove__0: t_Auth }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise (self: t_ViewUpdateRemove) (from: t_View) =
    auth from <> C_None
    /\ (forall f: t_Frag. match op (frag from) f with
          | C_Some'0 ff -> rel (auth from) ff
          | C_None'0 -> false
          end -> rel (C_Some (self.t_ViewUpdateRemove__0)) f)
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                        t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function new_auth [@inline:trivial] (auth'0: t_Auth) : t_View = new (C_Some auth'0) unit'
  
  meta "rewrite_def" function new_auth
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateRemove
  
  constant from : t_View
  
  constant _3 : ()
  
  function update (self: t_ViewUpdateRemove) (from: t_View) (_3: ()) : t_View
  
  goal vc_update: premise self from -> ([@expl:update ensures] rel (C_Some (self.t_ViewUpdateRemove__0)) unit')
end
module M_creusot_contracts__logic__ra__view__qyi5746217084655472194__frame_preserving (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_ViewUpdateRemove = { t_ViewUpdateRemove__0: t_Auth }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise (self: t_ViewUpdateRemove) (from: t_View) =
    auth from <> C_None
    /\ (forall f: t_Frag. match op (frag from) f with
          | C_Some'0 ff -> rel (auth from) ff
          | C_None'0 -> false
          end -> rel (C_Some (self.t_ViewUpdateRemove__0)) f)
  
  type t_Option'1 = C_None'1 | C_Some'1 t_View
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_View t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option; f2: t_Option }
  
  type tuple'1 = { f0'1: t_Option; f1'1: t_Option }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                        t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option'1 = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None; f1'1 = a} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | {f0'1 = a; f1'1 = C_None} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | _ -> C_None'1
        end
      | C_None'0 -> C_None'1
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some _; f1'0 = C_None; f2 = C_None} | {f0'0 = C_None; f1'0 = C_Some _; f2 = C_None} | {f0'0 = C_None; f1'0 = C_None; f2 = C_Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic'0 (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  function new_auth [@inline:trivial] (auth'0: t_Auth) : t_View = new (C_Some auth'0) unit'
  
  meta "rewrite_def" function new_auth
  
  function update (self: t_ViewUpdateRemove) (from: t_View) (_3: ()) : t_View = new_auth self.t_ViewUpdateRemove__0
  
  axiom update_spec: forall self: t_ViewUpdateRemove, from: t_View, _3: (). premise self from
      -> rel (C_Some (self.t_ViewUpdateRemove__0)) unit'
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateRemove
  
  constant from : t_View
  
  constant frame : t_View
  
  function frame_preserving (self: t_ViewUpdateRemove) (from: t_View) (frame: t_View) : ()
  
  goal vc_frame_preserving: premise self from
    -> op'0 from frame <> C_None'1 -> ([@expl:frame_preserving ensures] op'0 (update self from ()) frame <> C_None'1)
end
module M_creusot_contracts__logic__ra__RA__incl_op
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Self
  
  type t_Option = C_None | C_Some t_Self
  
  function op (self: t_Self) (other: t_Self) : t_Option
  
  function factor (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Self) (other: t_Self) = factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Self
  
  constant other : t_Self
  
  constant comb : t_Self
  
  function incl_op (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
  goal vc_incl_op: op self other = C_Some comb -> ([@expl:incl_op ensures] incl self comb)
end
module M_creusot_contracts__logic__ra__RA__incl_transitive
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option = C_None | C_Some t_Self
  
  function op (self: t_Self) (other: t_Self) : t_Option
  
  function factor (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Self) (other: t_Self) = factor other self <> C_None
  
  function and_then_logic (self: t_Option) (f: Map.map t_Self t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function associative (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_spec: forall a: t_Self, b: t_Self, c: t_Self. and_then_logic (op a b) (fun (ab: t_Self) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Self) -> op a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Self
  
  constant b : t_Self
  
  constant c : t_Self
  
  function incl_transitive (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  goal vc_incl_transitive: incl a b -> incl b c -> ([@expl:incl_transitive ensures] incl a c)
end
module M_creusot_contracts__logic__ra__UnitRA__incl_refl
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option = C_None | C_Some t_Self
  
  function and_then_logic (self: t_Option) (f: Map.map t_Self t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Self) (other: t_Self) : t_Option
  
  function factor (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Self) (other: t_Self) = factor other self <> C_None
  
  function incl_transitive (a: t_Self) (b: t_Self) (c: t_Self) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Self, b: t_Self, c: t_Self. incl a b -> incl b c -> incl a c
  
  function associative (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_spec: forall a: t_Self, b: t_Self, c: t_Self. and_then_logic (op a b) (fun (ab: t_Self) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Self) -> op a bc)
  
  function commutative (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_spec: forall a: t_Self, b: t_Self. op a b = op b a
  
  function incl_op (self: t_Self) (other: t_Self) (comb: t_Self) : () = ()
  
  axiom incl_op_spec: forall self: t_Self, other: t_Self, comb: t_Self. op self other = C_Some comb -> incl self comb
  
  constant unit' : t_Self
  
  axiom unit_spec: forall x: t_Self [op x unit']. op x unit' = C_Some x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function incl_refl : ()
  
  goal vc_incl_refl: (forall x: t_Self [op x unit']. op x unit' = C_Some x)
    -> (let _ = unit' in [@expl:incl_refl ensures] forall x: t_Self. incl x x)
end
module M_creusot_contracts__logic__ra__UnitRA__unit_core
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option = C_None | C_Some t_Self
  
  function and_then_logic (self: t_Option) (f: Map.map t_Self t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Self) (other: t_Self) : t_Option
  
  function factor (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Self) (other: t_Self) = factor other self <> C_None
  
  function incl_transitive (a: t_Self) (b: t_Self) (c: t_Self) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Self, b: t_Self, c: t_Self. incl a b -> incl b c -> incl a c
  
  function associative (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_spec: forall a: t_Self, b: t_Self, c: t_Self. and_then_logic (op a b) (fun (ab: t_Self) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Self) -> op a bc)
  
  function commutative (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_spec: forall a: t_Self, b: t_Self. op a b = op b a
  
  function incl_op (self: t_Self) (other: t_Self) (comb: t_Self) : () = ()
  
  axiom incl_op_spec: forall self: t_Self, other: t_Self, comb: t_Self. op self other = C_Some comb -> incl self comb
  
  function core_total (self: t_Self) : t_Self
  
  axiom core_total_spec: forall self: t_Self. op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_Self. op (core_total self) self = C_Some self
  
  constant unit' : t_Self
  
  axiom unit_spec: forall x: t_Self [op x unit']. op x unit' = C_Some x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_core : ()
  
  goal vc_unit_core: [@expl:unit_core ensures] core_total unit' = unit'
end
module M_creusot_contracts__logic__ra__UnitRA__core_total
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option = C_None | C_Some t_Self
  
  function and_then_logic (self: t_Option) (f: Map.map t_Self t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Self) (other: t_Self) : t_Option
  
  function factor (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Self) (other: t_Self) = factor other self <> C_None
  
  function incl_transitive (a: t_Self) (b: t_Self) (c: t_Self) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Self, b: t_Self, c: t_Self. incl a b -> incl b c -> incl a c
  
  function associative (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_spec: forall a: t_Self, b: t_Self, c: t_Self. and_then_logic (op a b) (fun (ab: t_Self) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Self) -> op a bc)
  
  function commutative (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_spec: forall a: t_Self, b: t_Self. op a b = op b a
  
  function incl_op (self: t_Self) (other: t_Self) (comb: t_Self) : () = ()
  
  axiom incl_op_spec: forall self: t_Self, other: t_Self, comb: t_Self. op self other = C_Some comb -> incl self comb
  
  constant unit' : t_Self
  
  axiom unit_spec: forall x: t_Self [op x unit']. op x unit' = C_Some x
  
  function core (self: t_Self) : t_Option
  
  axiom core_spec: forall self: t_Self. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function core_is_maximal_idemp (self: t_Self) (i: t_Self) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_Self, i: t_Self. op i i = C_Some i
      -> op i self = C_Some self
      -> match core self with
        | C_Some c -> incl i c
        | C_None -> false
        end
  
  predicate index_logic [@inline:trivial] (self: Map.map t_Self bool) (a: t_Self) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_Self bool) : t_Self
  
  axiom such_that_spec: forall p: Map.map t_Self bool. (exists x: t_Self. index_logic p x)
      -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_Self = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_Self) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Self
  
  function core_total (self: t_Self) : t_Self
  
  goal vc_core_total: (forall x: t_Self [op x unit']. op x unit' = C_Some x)
    -> (([@expl:core_is_maximal_idemp requires #0] op unit' unit' = C_Some unit')
      && ([@expl:core_is_maximal_idemp requires #1] op unit' self = C_Some self))
    /\ (match core self with
        | C_Some c -> incl unit' c
        | C_None -> false
        end
    -> (let _ = core_is_maximal_idemp self unit' in match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
    -> ([@expl:unwrap_logic requires] core self <> C_None)
    /\ (let result = unwrap_logic (core self) in ([@expl:core_total ensures #0] op result result = C_Some result)
    && ([@expl:core_total ensures #1] op result self = C_Some self))))
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__cmp_le_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_le_log (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] Real.(<=) x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__cmp_lt_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_lt_log (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] Real.(<) x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__cmp_ge_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_ge_log (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] Real.(>=) x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__cmp_gt_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_gt_log (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] Real.(>) x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__refl (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  function refl (x: Real.real) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__trans (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  constant z : Real.real
  
  constant o : t_Ordering
  
  function trans (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log x y = o -> cmp_log y z = o -> ([@expl:trans ensures] cmp_log x z = o)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__antisym1 (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function antisym1 (x: Real.real) (y: Real.real) : ()
  
  goal vc_antisym1: cmp_log x y = C_Less -> ([@expl:antisym1 ensures] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__antisym2 (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function antisym2 (x: Real.real) (y: Real.real) : ()
  
  goal vc_antisym2: cmp_log x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__eq_cmp (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function eq_cmp (x: Real.real) (y: Real.real) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__map (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  function index_logic [@inline:trivial] (self: Map.map t_T t_U) (a: t_T) : t_U = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function push_front [@inline:trivial] (self: Seq.seq t_U) (x: t_U) : Seq.seq t_U = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq t_T
  
  constant m : Map.map t_T t_U
  
  function map (self: Seq.seq t_T) (m: Map.map t_T t_U) : Seq.seq t_U
  
  goal vc_map: if Seq.length self = 0 then
      let result = Seq.empty: Seq.seq t_U in ([@expl:map ensures #0] Seq.length result = Seq.length self)
      && ([@expl:map ensures #1] forall i: int. 0 <= i /\ i < Seq.length self
        -> Seq.get result i = index_logic m (Seq.get self i))
    else
      well_founded_relation (Seq.length self) (Seq.length (tail self))
      /\ (Seq.length (map (tail self) m) = Seq.length (tail self)
        && (forall i: int. 0 <= i /\ i < Seq.length (tail self)
          -> Seq.get (map (tail self) m) i = index_logic m (Seq.get (tail self) i))
      -> (let result = push_front (map (tail self) m) (Map.get m (Seq.get self 0)) in ([@expl:map ensures #0] Seq.length result
        = Seq.length self)
      && ([@expl:map ensures #1] forall i: int. 0 <= i /\ i < Seq.length self
        -> Seq.get result i = index_logic m (Seq.get self i))))

end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__flat_map (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq t_T
  
  constant other : Map.map t_T (Seq.seq t_U)
  
  function flat_map (self: Seq.seq t_T) (other: Map.map t_T (Seq.seq t_U)) : Seq.seq t_U
  
  goal vc_flat_map: if Seq.length self = 0 then
      true
    else
      well_founded_relation (Seq.length self) (Seq.length (tail self))

end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__concat_contains (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function concat_contains : ()
  
  goal vc_concat_contains:
    [@expl:concat_contains ensures] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains (Seq.(++) a b) x
        = contains a x
      \/ contains b x
end
module M_creusot_contracts__logic__seq__qyi16115490154402163220__flatten (* logic::seq::Seq<logic::seq::Seq<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  function tail (self: Seq.seq (Seq.seq t_T)) : Seq.seq (Seq.seq t_T) = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq (Seq.seq t_T)
  
  function flatten (self: Seq.seq (Seq.seq t_T)) : Seq.seq t_T
  
  goal vc_flatten: if Seq.length self = 0 then
      true
    else
      well_founded_relation (Seq.length self) (Seq.length (tail self))

end
module M_creusot_contracts__logic__seq__qyi16716636390792333424__index (* <logic::seq::Seq<T> as std::ops::Index<logic::int::Int>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) = inv'1 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: Seq.seq t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function get (self: Seq.seq t_T) (ix: int) : t_Option'0 = if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  let rec get_ghost (self: Seq.seq t_T) (index: int) (return (x: t_Option)) =
    {[@expl:get_ghost 'self' type invariant] inv'2 self}
    any
    [ return (result: t_Option) -> {inv'4 result}
      {match get self index with
        | C_None'0 -> result = C_None
        | C_Some'0 v -> result = C_Some v
        end}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option) (return (x: t_T)) = {[@expl:unwrap 'self_' type invariant] inv'4 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return (result: t_T) -> {inv'3 result} {C_Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index (self: Seq.seq t_T) (index'0: int) (return (x: t_T)) = {[@expl:index 'self' type invariant] inv'2 self}
    {[@expl:index requires] 0 <= index'0 /\ index'0 < Seq.length self}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost {self} {index'0} (fun (_ret: t_Option) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_6} (fun (_ret: t_T) -> [ &_5 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- _5 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & self: Seq.seq t_T = self
    | & index'0: int = index'0
    | & _5: t_T = Any.any_l ()
    | & _6: t_Option = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:index result type invariant] inv'3 result}
      {[@expl:index ensures] result = Seq.get self index'0}
      (! return {result}) ]
end
module M_creusot_contracts__logic__seq__qyi3278447201291925478__index_mut (* <logic::seq::Seq<T> as std::ops::IndexMut<logic::int::Int>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  type t_Option = C_None | C_Some (MutBorrow.t t_T)
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function get (self: Seq.seq t_T) (ix: int) : t_Option'0 = if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  let rec get_mut_ghost (self: MutBorrow.t (Seq.seq t_T)) (index: int) (return (x: t_Option)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv'2 self}
    any
    [ return (result: t_Option) -> {inv'4 result}
      {match result with
        | C_None -> get self.current index = C_None'0 /\ self.current = self.final
        | C_Some r -> get self.current index = C_Some'0 (r.current) /\ r.final = Seq.get self.final index
        end}
      {forall i: int. i <> index -> get self.current i = get self.final i}
      {Seq.length self.current = Seq.length self.final}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option) (return (x: MutBorrow.t t_T)) = {[@expl:unwrap 'self_' type invariant] inv'4 self_}
    {[@expl:unwrap requires] self_ <> C_None}
    any [ return (result: MutBorrow.t t_T) -> {inv'3 result} {C_Some result = self_} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_mut (self: MutBorrow.t (Seq.seq t_T)) (index: int) (return (x: MutBorrow.t t_T)) =
    {[@expl:index_mut 'self' type invariant] inv'2 self}
    {[@expl:index_mut requires] 0 <= index /\ index < Seq.length self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self.current}
        MutBorrow.borrow_final <Seq.seq t_T> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t (Seq.seq t_T)) ->
            [ &_10 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = get_mut_ghost {_10} {index} (fun (_ret: t_Option) -> [ &_9 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_9} (fun (_ret: MutBorrow.t t_T) -> [ &_8 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_3 <- _ret ] -{inv _ret.final}-
            [ &_8 <- { _8 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'3 _8} s2
      | s2 = -{resolve _8}- s3
      | s3 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_0 <- _ret ] -{inv _ret.final}-
            [ &_3 <- { _3 with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv'3 _3} s5
      | s5 = -{resolve _3}- s6
      | s6 = {[@expl:type invariant] inv'2 self} s7
      | s7 = -{resolve'0 self}- s8
      | s8 = return {_0} ] ]
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self: MutBorrow.t (Seq.seq t_T) = self
    | & index: int = index
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _10: MutBorrow.t (Seq.seq t_T) = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) -> {[@expl:index_mut result type invariant] inv'3 result}
      {[@expl:index_mut ensures #0] Seq.length self.current = Seq.length self.final}
      {[@expl:index_mut ensures #1] result.current = Seq.get self.current index
      /\ result.final = Seq.get self.final index}
      {[@expl:index_mut ensures #2] forall i: int. i <> index -> get self.current i = get self.final i}
      (! return {result}) ]
end
module M_creusot_contracts__logic__seq__qyi17455570526542197641__into_iter (* <logic::seq::Seq<T> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 (_1: t_SeqIter)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter [inv'2 x]. inv'2 x = inv'1 x.t_SeqIter__inner
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter (self: Seq.seq t_T) (return (x: t_SeqIter)) = {[@expl:into_iter 'self' type invariant] inv'1 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { t_SeqIter__inner = self } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_SeqIter = Any.any_l () | & self: Seq.seq t_T = self ])
    [ return (result: t_SeqIter) -> {[@expl:into_iter result type invariant] inv'2 result}
      {[@expl:into_iter ensures] view result = self}
      (! return {result}) ]
end
module M_creusot_contracts__logic__seq__qyi785709447733932085__next (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  type t_Option = C_None | C_Some t_T
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  function push_front [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  let rec pop_front_ghost (self: MutBorrow.t (Seq.seq t_T)) (return (x: t_Option)) =
    {[@expl:pop_front_ghost 'self' type invariant] inv'2 self}
    any
    [ return (result: t_Option) -> {inv'3 result}
      {match result with
        | C_None -> self.current = (Seq.empty: Seq.seq t_T) /\ self.current = self.final
        | C_Some r -> self.current = push_front self.final r
        end}
      (! return {result}) ]
  
  predicate inv'4 (_1: t_SeqIter)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_SeqIter [inv'4 x]. inv'4 x = inv'1 x.t_SeqIter__inner
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_SeqIter) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 [@inline:trivial] (_1: MutBorrow.t t_SeqIter) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'5
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_SeqIter) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  predicate produces (self: t_SeqIter) (visited: Seq.seq t_T) (o: t_SeqIter) = view self = Seq.(++) visited (view o)
  
  function produces_trans (a: t_SeqIter) (ab: Seq.seq t_T) (b: t_SeqIter) (bc: Seq.seq t_T) (c: t_SeqIter) : () = ()
  
  axiom produces_trans_spec:
    forall a: t_SeqIter, ab: Seq.seq t_T, b: t_SeqIter, bc: Seq.seq t_T, c: t_SeqIter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_SeqIter) : () = ()
  
  axiom produces_refl_spec: forall self: t_SeqIter. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate completed (self: MutBorrow.t t_SeqIter) = view self.current = (Seq.empty: Seq.seq t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next (self: MutBorrow.t t_SeqIter) (return (x: t_Option)) = {[@expl:next 'self' type invariant] inv'5 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self.current.t_SeqIter__inner}
        MutBorrow.borrow_final <Seq.seq t_T> {self.current.t_SeqIter__inner}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t (Seq.seq t_T)) ->
            [ &_3 <- _ret ] -{inv'1 _ret.final}-
            [ &self <- { self with current = { t_SeqIter__inner = _ret.final } } ] s1)
      | s1 = pop_front_ghost {_3} (fun (_ret: t_Option) -> [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'5 self} s1 | s1 = -{resolve self}- s2 | s2 = return {_0} ] ]
    [ & _0: t_Option = Any.any_l ()
    | & self: MutBorrow.t t_SeqIter = self
    | & _3: MutBorrow.t (Seq.seq t_T) = Any.any_l () ])
    [ return (result: t_Option) -> {[@expl:next result type invariant] inv'3 result}
      {[@expl:next ensures] match result with
        | C_None -> completed self
        | C_Some v -> produces self.current (Seq.singleton v) self.final
        end}
      (! return {result}) ]
end
module M_creusot_contracts__logic__seq__qyi17207334030084003748__produces_refl (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  predicate produces (self: t_SeqIter) (visited: Seq.seq t_T) (o: t_SeqIter) = view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIter
  
  function produces_refl (self: t_SeqIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__logic__seq__qyi17207334030084003748__produces_trans (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  predicate produces (self: t_SeqIter) (visited: Seq.seq t_T) (o: t_SeqIter) = view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_SeqIter
  
  constant ab : Seq.seq t_T
  
  constant b : t_SeqIter
  
  constant bc : Seq.seq t_T
  
  constant c : t_SeqIter
  
  function produces_trans (a: t_SeqIter) (ab: Seq.seq t_T) (b: t_SeqIter) (bc: Seq.seq t_T) (c: t_SeqIter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__logic__seq__qyi1510294819003656547__into_iter (* <&'a logic::seq::Seq<T> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) = inv'1 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: Seq.seq t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  let rec len_ghost (self: Seq.seq t_T) (return (x: int)) = {[@expl:len_ghost 'self' type invariant] inv'2 self}
    any [ return (result: int) -> {result = Seq.length self} (! return {result}) ]
  
  let rec sub (self: int) (other: int) (return (x: int)) = any
    [ return (result: int) -> {result = self - other} (! return {result}) ]
  
  type t_SeqIterRef = { t_SeqIterRef__inner: Seq.seq t_T; t_SeqIterRef__index: int }
  
  predicate invariant''2 (self: t_SeqIterRef) =
    0 <= self.t_SeqIterRef__index /\ self.t_SeqIterRef__index <= Seq.length self.t_SeqIterRef__inner
  
  predicate inv'3 (_1: t_SeqIterRef)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIterRef [inv'3 x]. inv'3 x
      = (invariant''2 x /\ inv'2 x.t_SeqIterRef__inner)
  
  function view (self: t_SeqIterRef) : Seq.seq t_T =
    Seq.([..]) self.t_SeqIterRef__inner self.t_SeqIterRef__index (Seq.length self.t_SeqIterRef__inner)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter (self: Seq.seq t_T) (return (x: t_SeqIterRef)) =
    {[@expl:into_iter 'self' type invariant] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 = len_ghost {self} (fun (_ret: int) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = len_ghost {self} (fun (_ret: int) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = sub {_5} {_7} (fun (_ret: int) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0 <- { t_SeqIterRef__inner = self; t_SeqIterRef__index = _4 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_SeqIterRef = Any.any_l ()
    | & self: Seq.seq t_T = self
    | & _4: int = Any.any_l ()
    | & _5: int = Any.any_l ()
    | & _7: int = Any.any_l () ])
    [ return (result: t_SeqIterRef) -> {[@expl:into_iter result type invariant] inv'3 result}
      {[@expl:into_iter ensures] view result = self}
      (! return {result}) ]
end
module M_creusot_contracts__logic__seq__qyi15242110712714185722__next (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  type t_SeqIterRef = { t_SeqIterRef__inner: Seq.seq t_T; t_SeqIterRef__index: int }
  
  function view (self: t_SeqIterRef) : Seq.seq t_T =
    Seq.([..]) self.t_SeqIterRef__inner self.t_SeqIterRef__index (Seq.length self.t_SeqIterRef__inner)
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) = inv'1 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: Seq.seq t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function get (self: Seq.seq t_T) (ix: int) : t_Option'0 = if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  let rec get_ghost (self: Seq.seq t_T) (index: int) (return (x: t_Option)) =
    {[@expl:get_ghost 'self' type invariant] inv'2 self}
    any
    [ return (result: t_Option) -> {inv'4 result}
      {match get self index with
        | C_None'0 -> result = C_None
        | C_Some'0 v -> result = C_Some v
        end}
      (! return {result}) ]
  
  predicate invariant''3 (self: t_SeqIterRef) =
    0 <= self.t_SeqIterRef__index /\ self.t_SeqIterRef__index <= Seq.length self.t_SeqIterRef__inner
  
  predicate inv'5 (_1: t_SeqIterRef)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_SeqIterRef [inv'5 x]. inv'5 x
      = (invariant''3 x /\ inv'2 x.t_SeqIterRef__inner)
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_SeqIterRef) = inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'6 [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef) = invariant''4 _1
  
  meta "rewrite_def" predicate inv'6
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  let rec incr_ghost (self: MutBorrow.t int) (return (x: ())) = any
    [ return (result: ()) -> {self.final = self.current + 1} (! return {result}) ]
  
  function tail (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate produces (self: t_SeqIterRef) (visited: Seq.seq t_T) (o: t_SeqIterRef) =
    let visited'0 = visited in view self = Seq.(++) visited'0 (view o)
  
  function produces_trans (a: t_SeqIterRef) (ab: Seq.seq t_T) (b: t_SeqIterRef) (bc: Seq.seq t_T) (c: t_SeqIterRef) : ()
   = ()
  
  axiom produces_trans_spec:
    forall a: t_SeqIterRef, ab: Seq.seq t_T, b: t_SeqIterRef, bc: Seq.seq t_T, c: t_SeqIterRef. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_SeqIterRef) : () = ()
  
  axiom produces_refl_spec: forall self: t_SeqIterRef. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate completed (self: MutBorrow.t t_SeqIterRef) = view self.current = (Seq.empty: Seq.seq t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next (self: MutBorrow.t t_SeqIterRef) (return (x: t_Option)) = {[@expl:next 'self' type invariant] inv'6 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_before <- view self.current ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = get_ghost {self.current.t_SeqIterRef__inner} {self.current.t_SeqIterRef__index}
          (fun (_ret: t_Option) -> [ &_5 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = any [ br0 -> {_5 = C_None} (! bb6) | br1 (x0: t_T) -> {_5 = C_Some x0} (! bb4) ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'6 self} s1
      | s1 = -{resolve self}- s2
      | s2 = {[@expl:assertion] self.current.t_SeqIterRef__index = Seq.length self.current.t_SeqIterRef__inner} s3
      | s3 = {[@expl:assertion] view self.current = (Seq.empty: Seq.seq t_T)} s4
      | s4 = [ &_0 <- C_None ] s5
      | s5 = bb7 ]
    | bb4 = s0
      [ s0 = v_Some {_5} (fun (r0: t_T) -> [ &res <- r0 ] s1)
      | s1 = MutBorrow.borrow_final <int> {self.current.t_SeqIterRef__index}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t int) ->
            [ &_11 <- _ret ] [ &self <- { self with current = { self.current with t_SeqIterRef__index = _ret.final } } ]
            s2)
      | s2 = incr_ghost {_11} (fun (_ret: ()) -> [ &_10 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 self} s1
      | s1 = -{resolve self}- s2
      | s2 = {[@expl:assertion] view self.current = tail _before} s3
      | s3 = [ &_0 <- C_Some res ] s4
      | s4 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option = Any.any_l ()
    | & self: MutBorrow.t t_SeqIterRef = self
    | & _before: Seq.seq t_T = Any.any_l ()
    | & _5: t_Option = Any.any_l ()
    | & res: t_T = Any.any_l ()
    | & _10: () = Any.any_l ()
    | & _11: MutBorrow.t int = Any.any_l () ])
    [ return (result: t_Option) -> {[@expl:next result type invariant] inv'4 result}
      {[@expl:next ensures] match result with
        | C_None -> completed self
        | C_Some v -> produces self.current (Seq.singleton v) self.final
        end}
      (! return {result}) ]
end
module M_creusot_contracts__logic__seq__qyi7064237699691893604__produces_refl (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef = { t_SeqIterRef__inner: Seq.seq t_T; t_SeqIterRef__index: int }
  
  function view (self: t_SeqIterRef) : Seq.seq t_T =
    Seq.([..]) self.t_SeqIterRef__inner self.t_SeqIterRef__index (Seq.length self.t_SeqIterRef__inner)
  
  predicate produces (self: t_SeqIterRef) (visited: Seq.seq t_T) (o: t_SeqIterRef) =
    let visited'0 = visited in view self = Seq.(++) visited'0 (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIterRef
  
  function produces_refl (self: t_SeqIterRef) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__logic__seq__qyi7064237699691893604__produces_trans (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef = { t_SeqIterRef__inner: Seq.seq t_T; t_SeqIterRef__index: int }
  
  function view (self: t_SeqIterRef) : Seq.seq t_T =
    Seq.([..]) self.t_SeqIterRef__inner self.t_SeqIterRef__index (Seq.length self.t_SeqIterRef__inner)
  
  predicate produces (self: t_SeqIterRef) (visited: Seq.seq t_T) (o: t_SeqIterRef) =
    let visited'0 = visited in view self = Seq.(++) visited'0 (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_SeqIterRef
  
  constant ab : Seq.seq t_T
  
  constant b : t_SeqIterRef
  
  constant bc : Seq.seq t_T
  
  constant c : t_SeqIterRef
  
  function produces_trans (a: t_SeqIterRef) (ab: Seq.seq t_T) (b: t_SeqIterRef) (bc: Seq.seq t_T) (c: t_SeqIterRef) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__logic__seq__flat_map_singleton
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  
  type t_A
  
  type t_B
  
  function tail (self: Seq.seq t_A) : Seq.seq t_A = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  axiom flat_map_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq t_B
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
      )
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function flat_map_singleton : ()
  
  goal vc_flat_map_singleton:
    [@expl:flat_map_singleton ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.singleton x) f
      = Map.get f x
end
module M_creusot_contracts__logic__seq__flat_map_push_back
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  function tail (self: Seq.seq t_A) : Seq.seq t_A = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  axiom flat_map_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq t_B
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
      )
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant xs : Seq.seq t_A
  
  function flat_map_push_back (xs: Seq.seq t_A) : ()
  
  goal vc_flat_map_push_back: if Seq.length xs > 0 then
      well_founded_relation (Seq.length xs) (Seq.length (tail xs))
      /\ ((forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc (tail xs) x) f
          = Seq.(++) (flat_map (tail xs) f) (Map.get f x))
      -> (let _ = flat_map_push_back (tail xs) in (forall x: t_A. Seq.snoc (tail xs) x = tail (Seq.snoc xs x))
      && ([@expl:flat_map_push_back ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc xs x) f
        = Seq.(++) (flat_map xs f) (Map.get f x))))
    else
      [@expl:flat_map_push_back ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc xs x) f
        = Seq.(++) (flat_map xs f) (Map.get f x)

end
module M_creusot_contracts__logic__seq__qyi4911090196027168916__resolve_coherence (* <logic::seq::SeqIter<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  type t_Option = C_None | C_Some t_T
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'0 x]. resolve'0 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve x0
        end
  
  function get (self: Seq.seq t_T) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  predicate resolve'1 (self: Seq.seq t_T) = forall i: int. resolve'0 (get self i)
  
  predicate resolve'2 (_1: Seq.seq t_T)
  
  axiom resolve_axiom'0: forall x: Seq.seq t_T [resolve'2 x]. resolve'2 x -> resolve'1 x
  
  predicate structural_resolve (_1: t_SeqIter) = resolve'2 _1.t_SeqIter__inner
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  predicate resolve'3 [@inline:trivial] (self: t_SeqIter) = resolve'2 (view self)
  
  meta "rewrite_def" predicate resolve'3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIter
  
  function resolve_coherence (self: t_SeqIter) : ()
  
  goal vc_resolve_coherence: structural_resolve self -> ([@expl:resolve_coherence ensures] resolve'3 self)
end
module M_creusot_contracts__logic__well_founded__qyi6309403424797654971__no_infinite_decreasing_sequence (* <u8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt8.t, y: UInt8.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym2_spec: forall x: UInt8.t, y: UInt8.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym1_spec: forall x: UInt8.t, y: UInt8.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt8.t, y: UInt8.t, z: UInt8.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt8.t) : ()
  
  axiom refl_spec: forall x: UInt8.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt8.t, y: UInt8.t. UInt8.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt8.t, y: UInt8.t. UInt8.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt8.t, y: UInt8.t. UInt8.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt8.t, y: UInt8.t. UInt8.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt8.t) (other: UInt8.t) = UInt8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt8.t) (a: int) : UInt8.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt8.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int UInt8.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> UInt8.t'int (index_logic s i) - UInt8.t'int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> UInt8.t'int (index_logic s i)
      - UInt8.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt8.t'int (index_logic s i)
      - UInt8.t'int const_MIN))) (index_logic'0 (fun (i: int) -> UInt8.t'int (index_logic s i)
      - UInt8.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt8.t'int (index_logic s i)
        - UInt8.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> UInt8.t'int (index_logic s i)
    - UInt8.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi13365674792282857752__no_infinite_decreasing_sequence (* <u16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt16.t, y: UInt16.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym2_spec: forall x: UInt16.t, y: UInt16.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym1_spec: forall x: UInt16.t, y: UInt16.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt16.t, y: UInt16.t, z: UInt16.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt16.t) : ()
  
  axiom refl_spec: forall x: UInt16.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt16.t, y: UInt16.t. UInt16.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt16.t, y: UInt16.t. UInt16.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt16.t, y: UInt16.t. UInt16.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt16.t, y: UInt16.t. UInt16.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt16.t) (other: UInt16.t) = UInt16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt16.t) (a: int) : UInt16.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: UInt16.t = (0: UInt16.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt16.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int UInt16.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> UInt16.t'int (index_logic s i) - UInt16.t'int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> UInt16.t'int (index_logic s i)
      - UInt16.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt16.t'int (index_logic s i)
      - UInt16.t'int const_MIN))) (index_logic'0 (fun (i: int) -> UInt16.t'int (index_logic s i)
      - UInt16.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt16.t'int (index_logic s i)
        - UInt16.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> UInt16.t'int (index_logic s i)
    - UInt16.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi12322784451431554842__no_infinite_decreasing_sequence (* <u32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt32.t, y: UInt32.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym2_spec: forall x: UInt32.t, y: UInt32.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym1_spec: forall x: UInt32.t, y: UInt32.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt32.t, y: UInt32.t, z: UInt32.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt32.t) : ()
  
  axiom refl_spec: forall x: UInt32.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt32.t, y: UInt32.t. UInt32.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt32.t, y: UInt32.t. UInt32.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt32.t, y: UInt32.t. UInt32.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt32.t, y: UInt32.t. UInt32.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt32.t) (other: UInt32.t) = UInt32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt32.t) (a: int) : UInt32.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: UInt32.t = (0: UInt32.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt32.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int UInt32.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> UInt32.t'int (index_logic s i) - UInt32.t'int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> UInt32.t'int (index_logic s i)
      - UInt32.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt32.t'int (index_logic s i)
      - UInt32.t'int const_MIN))) (index_logic'0 (fun (i: int) -> UInt32.t'int (index_logic s i)
      - UInt32.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt32.t'int (index_logic s i)
        - UInt32.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> UInt32.t'int (index_logic s i)
    - UInt32.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi3704748901488424246__no_infinite_decreasing_sequence (* <u64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt64.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int UInt64.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> UInt64.t'int (index_logic s i) - UInt64.t'int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> UInt64.t'int (index_logic s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt64.t'int (index_logic s i)
      - UInt64.t'int const_MIN))) (index_logic'0 (fun (i: int) -> UInt64.t'int (index_logic s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt64.t'int (index_logic s i)
        - UInt64.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> UInt64.t'int (index_logic s i)
    - UInt64.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi1252550884029967619__no_infinite_decreasing_sequence (* <u128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt128.t, y: UInt128.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym2_spec: forall x: UInt128.t, y: UInt128.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym1_spec: forall x: UInt128.t, y: UInt128.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt128.t, y: UInt128.t, z: UInt128.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt128.t) : ()
  
  axiom refl_spec: forall x: UInt128.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt128.t, y: UInt128.t. UInt128.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt128.t, y: UInt128.t. UInt128.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt128.t, y: UInt128.t. UInt128.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt128.t, y: UInt128.t. UInt128.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt128.t) (other: UInt128.t) = UInt128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt128.t) (a: int) : UInt128.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: UInt128.t = (0: UInt128.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt128.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int UInt128.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> UInt128.t'int (index_logic s i) - UInt128.t'int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> UInt128.t'int (index_logic s i)
      - UInt128.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt128.t'int (index_logic s i)
      - UInt128.t'int const_MIN))) (index_logic'0 (fun (i: int) -> UInt128.t'int (index_logic s i)
      - UInt128.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt128.t'int (index_logic s i)
        - UInt128.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> UInt128.t'int (index_logic s i)
    - UInt128.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi11167162977841660089__no_infinite_decreasing_sequence (* <usize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt64.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int UInt64.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> UInt64.t'int (index_logic s i) - UInt64.t'int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> UInt64.t'int (index_logic s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt64.t'int (index_logic s i)
      - UInt64.t'int const_MIN))) (index_logic'0 (fun (i: int) -> UInt64.t'int (index_logic s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> UInt64.t'int (index_logic s i)
        - UInt64.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> UInt64.t'int (index_logic s i)
    - UInt64.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi4052372126950253571__no_infinite_decreasing_sequence (* <i8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int8.t) (y: Int8.t) : ()
  
  axiom eq_cmp_spec: forall x: Int8.t, y: Int8.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym2_spec: forall x: Int8.t, y: Int8.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym1_spec: forall x: Int8.t, y: Int8.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int8.t, y: Int8.t, z: Int8.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int8.t) : ()
  
  axiom refl_spec: forall x: Int8.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int8.t, y: Int8.t. Int8.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int8.t, y: Int8.t. Int8.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int8.t, y: Int8.t. Int8.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int8.t, y: Int8.t. Int8.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int8.t) (other: Int8.t) = Int8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int8.t) (a: int) : Int8.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int8.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int Int8.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> Int8.to_int (index_logic s i) - Int8.to_int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> Int8.to_int (index_logic s i)
      - Int8.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int8.to_int (index_logic s i)
      - Int8.to_int const_MIN))) (index_logic'0 (fun (i: int) -> Int8.to_int (index_logic s i)
      - Int8.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int8.to_int (index_logic s i)
        - Int8.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> Int8.to_int (index_logic s i)
    - Int8.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi13817872832197934357__no_infinite_decreasing_sequence (* <i16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int16.t) (y: Int16.t) : ()
  
  axiom eq_cmp_spec: forall x: Int16.t, y: Int16.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym2_spec: forall x: Int16.t, y: Int16.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym1_spec: forall x: Int16.t, y: Int16.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int16.t, y: Int16.t, z: Int16.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int16.t) : ()
  
  axiom refl_spec: forall x: Int16.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int16.t, y: Int16.t. Int16.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int16.t, y: Int16.t. Int16.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int16.t, y: Int16.t. Int16.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int16.t, y: Int16.t. Int16.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int16.t) (other: Int16.t) = Int16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int16.t) (a: int) : Int16.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: Int16.t = (-32768: Int16.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int16.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int Int16.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> Int16.to_int (index_logic s i) - Int16.to_int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> Int16.to_int (index_logic s i)
      - Int16.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int16.to_int (index_logic s i)
      - Int16.to_int const_MIN))) (index_logic'0 (fun (i: int) -> Int16.to_int (index_logic s i)
      - Int16.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int16.to_int (index_logic s i)
        - Int16.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> Int16.to_int (index_logic s i)
    - Int16.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi14488472979989826699__no_infinite_decreasing_sequence (* <i32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_spec: forall x: Int32.t, y: Int32.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_spec: forall x: Int32.t, y: Int32.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int32.t) : ()
  
  axiom refl_spec: forall x: Int32.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int32.t) (a: int) : Int32.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: Int32.t = (-2147483648: Int32.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int32.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int Int32.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> Int32.to_int (index_logic s i) - Int32.to_int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> Int32.to_int (index_logic s i)
      - Int32.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int32.to_int (index_logic s i)
      - Int32.to_int const_MIN))) (index_logic'0 (fun (i: int) -> Int32.to_int (index_logic s i)
      - Int32.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int32.to_int (index_logic s i)
        - Int32.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> Int32.to_int (index_logic s i)
    - Int32.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi9107029114244384425__no_infinite_decreasing_sequence (* <i64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int64.t) : ()
  
  axiom refl_spec: forall x: Int64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int64.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int Int64.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> Int64.to_int (index_logic s i) - Int64.to_int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> Int64.to_int (index_logic s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int64.to_int (index_logic s i)
      - Int64.to_int const_MIN))) (index_logic'0 (fun (i: int) -> Int64.to_int (index_logic s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int64.to_int (index_logic s i)
        - Int64.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> Int64.to_int (index_logic s i)
    - Int64.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi7767210905695706209__no_infinite_decreasing_sequence (* <i128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int128.t) (y: Int128.t) : ()
  
  axiom eq_cmp_spec: forall x: Int128.t, y: Int128.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym2_spec: forall x: Int128.t, y: Int128.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym1_spec: forall x: Int128.t, y: Int128.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int128.t, y: Int128.t, z: Int128.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int128.t) : ()
  
  axiom refl_spec: forall x: Int128.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int128.t, y: Int128.t. Int128.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int128.t, y: Int128.t. Int128.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int128.t, y: Int128.t. Int128.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int128.t, y: Int128.t. Int128.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int128.t) (other: Int128.t) = Int128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int128.t) (a: int) : Int128.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int128.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int Int128.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> Int128.to_int (index_logic s i) - Int128.to_int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> Int128.to_int (index_logic s i)
      - Int128.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int128.to_int (index_logic s i)
      - Int128.to_int const_MIN))) (index_logic'0 (fun (i: int) -> Int128.to_int (index_logic s i)
      - Int128.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int128.to_int (index_logic s i)
        - Int128.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> Int128.to_int (index_logic s i)
    - Int128.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi16083863403565404456__no_infinite_decreasing_sequence (* <isize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int64.t) : ()
  
  axiom refl_spec: forall x: Int64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic'0 [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int int. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int int. not well_founded_relation'0 (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int64.t
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int Int64.t) : int
  
  goal vc_no_infinite_decreasing_sequence:
    no_infinite_decreasing_sequence (fun (i: int) -> Int64.to_int (index_logic s i) - Int64.to_int const_MIN) >= 0
      && not well_founded_relation'0 (index_logic'0 (fun (i: int) -> Int64.to_int (index_logic s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int64.to_int (index_logic s i)
      - Int64.to_int const_MIN))) (index_logic'0 (fun (i: int) -> Int64.to_int (index_logic s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence (fun (i: int) -> Int64.to_int (index_logic s i)
        - Int64.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> Int64.to_int (index_logic s i)
    - Int64.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi15685960674935199696__no_infinite_decreasing_sequence (* <&T as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation (self: t_T) (other: t_T)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: t_T) (other: t_T) = well_founded_relation self other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T. not well_founded_relation (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int t_T) : int
  
  goal vc_no_infinite_decreasing_sequence: no_infinite_decreasing_sequence (fun (i: int) -> index_logic s i) >= 0
      && not well_founded_relation (index_logic'0 (fun (i: int) -> index_logic s i) (no_infinite_decreasing_sequence (fun (i: int) -> index_logic s i))) (index_logic'0 (fun (i: int) -> index_logic s i) (no_infinite_decreasing_sequence (fun (i: int) -> index_logic s i)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> index_logic s i) in ([@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'0 (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi11731306862075323925__no_infinite_decreasing_sequence (* <std::boxed::Box<T> as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation (self: t_T) (other: t_T)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: t_T) (other: t_T) = well_founded_relation self other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T. not well_founded_relation (index_logic'0 s (no_infinite_decreasing_sequence s)) (index_logic'0 s (no_infinite_decreasing_sequence s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int t_T) : int
  
  goal vc_no_infinite_decreasing_sequence: no_infinite_decreasing_sequence (fun (i: int) -> index_logic s i) >= 0
      && not well_founded_relation (index_logic'0 (fun (i: int) -> index_logic s i) (no_infinite_decreasing_sequence (fun (i: int) -> index_logic s i))) (index_logic'0 (fun (i: int) -> index_logic s i) (no_infinite_decreasing_sequence (fun (i: int) -> index_logic s i)
      + 1))
    -> (let result = no_infinite_decreasing_sequence (fun (i: int) -> index_logic s i) in ([@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'0 (index_logic s result) (index_logic s (result
    + 1))))
end
module M_creusot_contracts__logic__well_founded__qyi4207107057392109463__no_infinite_decreasing_sequence (* <() as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  predicate well_founded_relation [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int ()) (a: int) : () = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int ()
  
  function no_infinite_decreasing_sequence (s: Map.map int ()) : int
  
  goal vc_no_infinite_decreasing_sequence: let result = 0 in ([@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation (index_logic s result) (index_logic s (result
    + 1)))
end
module M_creusot_contracts__logic__well_founded__qyi11248794011242651965__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5, T6, T7) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type t_T7
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6; f7: t_T7 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation'4 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation'5 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation'6 (self: t_T7) (other: t_T7)
  
  predicate well_founded_relation'7 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation'3 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation'4 self.f5 other.f5
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2
      /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation'5 self.f6 other.f6
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3
    /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ self.f6 = other.f6 /\ well_founded_relation'6 self.f7 other.f7
  
  meta "rewrite_def" predicate well_founded_relation'7
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  type tuple'0 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4; f4'0: t_T5; f5'0: t_T6; f6'0: t_T7 }
  
  type tuple'1 = { f0'1: t_T0; f1'1: tuple'0 }
  
  function tuple_to_pair (self: tuple) : tuple'1 = { f0'1 = self.f0;
                                                     f1'1 = { f0'0 = self.f1;
                                                              f1'0 = self.f2;
                                                              f2'0 = self.f3;
                                                              f3'0 = self.f4;
                                                              f4'0 = self.f5;
                                                              f5'0 = self.f6;
                                                              f6'0 = self.f7 } }
  
  predicate well_founded_relation'8 [@inline:trivial] (self: tuple'0) (other: tuple'0) =
    well_founded_relation'0 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation'1 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation'2 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation'3 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation'4 self.f4'0 other.f4'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0
      /\ self.f3'0 = other.f3'0 /\ self.f4'0 = other.f4'0 /\ well_founded_relation'5 self.f5'0 other.f5'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0
    /\ self.f3'0 = other.f3'0
    /\ self.f4'0 = other.f4'0 /\ self.f5'0 = other.f5'0 /\ well_founded_relation'6 self.f6'0 other.f6'0
  
  meta "rewrite_def" predicate well_founded_relation'8
  
  predicate well_founded_relation'9 [@inline:trivial] (self: tuple'1) (other: tuple'1) =
    well_founded_relation self.f0'1 other.f0'1 \/ self.f0'1 = other.f0'1 /\ well_founded_relation'8 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation'9
  
  function index_logic'1 [@inline:trivial] (self: Map.map int tuple'1) (a: int) : tuple'1 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function extract_next_decr (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'9 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (i + 1)).f0'1 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'9 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'9 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (extract_next_decr s i)).f0'1
  
  function extract_nth (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'9 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'9 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'9 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic'1 s prev).f0'1 (index_logic'1 s (extract_nth s i)).f0'1)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_spec'0: forall p: Map.map t_T0 bool. (exists x: t_T0. index_logic'3 p x)
      -> index_logic'3 p (such_that'0 p)
  
  function first_component_decr (s: Map.map int tuple'1) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_logic'1 s (extract_nth s i)).f0'1
    else
      such_that'0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_spec: forall s: Map.map int tuple'1. (forall i: int. 0 <= i
          -> well_founded_relation'9 (index_logic'1 s i) (index_logic'1 s (i + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation (index_logic'2 (first_component_decr s) i) (index_logic'2 (first_component_decr s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation (index_logic'2 s (no_infinite_decreasing_sequence s)) (index_logic'2 s (no_infinite_decreasing_sequence s
      + 1))
  
  constant unreachable : int
  
  axiom unreachable_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int tuple) : int
  
  goal vc_no_infinite_decreasing_sequence: if exists r: int. r >= 0
      /\ not well_founded_relation'7 (index_logic s r) (index_logic s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_logic'0 (fun (r: int) -> r >= 0
          /\ not well_founded_relation'7 (index_logic s r) (index_logic s (r + 1))) x)
      /\ (index_logic'0 (fun (r: int) -> r >= 0
        /\ not well_founded_relation'7 (index_logic s r) (index_logic s (r + 1))) (such_that (fun (r: int) -> r >= 0
        /\ not well_founded_relation'7 (index_logic s r) (index_logic s (r + 1))))
      -> (let result = such_that (fun (r: int) -> r >= 0
      /\ not well_founded_relation'7 (index_logic s r) (index_logic s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'7 (index_logic s result) (index_logic s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation'9 (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) i) (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) i) (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) >= 0
        && not well_founded_relation (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))))) (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'7 (index_logic s result) (index_logic s (result
      + 1)))))))

end
module M_creusot_contracts__logic__well_founded__qyi15628048186059727938__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5, T6) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation'4 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation'5 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation'6 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation'3 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation'4 self.f5 other.f5
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation'5 self.f6 other.f6
  
  meta "rewrite_def" predicate well_founded_relation'6
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  type tuple'0 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4; f4'0: t_T5; f5'0: t_T6 }
  
  type tuple'1 = { f0'1: t_T0; f1'1: tuple'0 }
  
  function tuple_to_pair (self: tuple) : tuple'1 = { f0'1 = self.f0;
                                                     f1'1 = { f0'0 = self.f1;
                                                              f1'0 = self.f2;
                                                              f2'0 = self.f3;
                                                              f3'0 = self.f4;
                                                              f4'0 = self.f5;
                                                              f5'0 = self.f6 } }
  
  predicate well_founded_relation'7 [@inline:trivial] (self: tuple'0) (other: tuple'0) =
    well_founded_relation'0 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation'1 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation'2 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation'3 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation'4 self.f4'0 other.f4'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0
    /\ self.f3'0 = other.f3'0 /\ self.f4'0 = other.f4'0 /\ well_founded_relation'5 self.f5'0 other.f5'0
  
  meta "rewrite_def" predicate well_founded_relation'7
  
  predicate well_founded_relation'8 [@inline:trivial] (self: tuple'1) (other: tuple'1) =
    well_founded_relation self.f0'1 other.f0'1 \/ self.f0'1 = other.f0'1 /\ well_founded_relation'7 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation'8
  
  function index_logic'1 [@inline:trivial] (self: Map.map int tuple'1) (a: int) : tuple'1 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function extract_next_decr (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'8 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (i + 1)).f0'1 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'8 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'8 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (extract_next_decr s i)).f0'1
  
  function extract_nth (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'8 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'8 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'8 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic'1 s prev).f0'1 (index_logic'1 s (extract_nth s i)).f0'1)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_spec'0: forall p: Map.map t_T0 bool. (exists x: t_T0. index_logic'3 p x)
      -> index_logic'3 p (such_that'0 p)
  
  function first_component_decr (s: Map.map int tuple'1) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_logic'1 s (extract_nth s i)).f0'1
    else
      such_that'0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_spec: forall s: Map.map int tuple'1. (forall i: int. 0 <= i
          -> well_founded_relation'8 (index_logic'1 s i) (index_logic'1 s (i + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation (index_logic'2 (first_component_decr s) i) (index_logic'2 (first_component_decr s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation (index_logic'2 s (no_infinite_decreasing_sequence s)) (index_logic'2 s (no_infinite_decreasing_sequence s
      + 1))
  
  constant unreachable : int
  
  axiom unreachable_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int tuple) : int
  
  goal vc_no_infinite_decreasing_sequence: if exists r: int. r >= 0
      /\ not well_founded_relation'6 (index_logic s r) (index_logic s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_logic'0 (fun (r: int) -> r >= 0
          /\ not well_founded_relation'6 (index_logic s r) (index_logic s (r + 1))) x)
      /\ (index_logic'0 (fun (r: int) -> r >= 0
        /\ not well_founded_relation'6 (index_logic s r) (index_logic s (r + 1))) (such_that (fun (r: int) -> r >= 0
        /\ not well_founded_relation'6 (index_logic s r) (index_logic s (r + 1))))
      -> (let result = such_that (fun (r: int) -> r >= 0
      /\ not well_founded_relation'6 (index_logic s r) (index_logic s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'6 (index_logic s result) (index_logic s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation'8 (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) i) (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) i) (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) >= 0
        && not well_founded_relation (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))))) (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'6 (index_logic s result) (index_logic s (result
      + 1)))))))

end
module M_creusot_contracts__logic__well_founded__qyi8633347720896034824__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation'4 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation'5 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation'3 self.f4 other.f4
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation'4 self.f5 other.f5
  
  meta "rewrite_def" predicate well_founded_relation'5
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  type tuple'0 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4; f4'0: t_T5 }
  
  type tuple'1 = { f0'1: t_T0; f1'1: tuple'0 }
  
  function tuple_to_pair (self: tuple) : tuple'1 = { f0'1 = self.f0;
                                                     f1'1 = { f0'0 = self.f1;
                                                              f1'0 = self.f2;
                                                              f2'0 = self.f3;
                                                              f3'0 = self.f4;
                                                              f4'0 = self.f5 } }
  
  predicate well_founded_relation'6 [@inline:trivial] (self: tuple'0) (other: tuple'0) =
    well_founded_relation'0 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation'1 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation'2 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation'3 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation'4 self.f4'0 other.f4'0
  
  meta "rewrite_def" predicate well_founded_relation'6
  
  predicate well_founded_relation'7 [@inline:trivial] (self: tuple'1) (other: tuple'1) =
    well_founded_relation self.f0'1 other.f0'1 \/ self.f0'1 = other.f0'1 /\ well_founded_relation'6 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation'7
  
  function index_logic'1 [@inline:trivial] (self: Map.map int tuple'1) (a: int) : tuple'1 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function extract_next_decr (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'7 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (i + 1)).f0'1 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'7 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'7 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (extract_next_decr s i)).f0'1
  
  function extract_nth (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'7 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'7 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'7 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic'1 s prev).f0'1 (index_logic'1 s (extract_nth s i)).f0'1)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_spec'0: forall p: Map.map t_T0 bool. (exists x: t_T0. index_logic'3 p x)
      -> index_logic'3 p (such_that'0 p)
  
  function first_component_decr (s: Map.map int tuple'1) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_logic'1 s (extract_nth s i)).f0'1
    else
      such_that'0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_spec: forall s: Map.map int tuple'1. (forall i: int. 0 <= i
          -> well_founded_relation'7 (index_logic'1 s i) (index_logic'1 s (i + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation (index_logic'2 (first_component_decr s) i) (index_logic'2 (first_component_decr s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation (index_logic'2 s (no_infinite_decreasing_sequence s)) (index_logic'2 s (no_infinite_decreasing_sequence s
      + 1))
  
  constant unreachable : int
  
  axiom unreachable_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int tuple) : int
  
  goal vc_no_infinite_decreasing_sequence: if exists r: int. r >= 0
      /\ not well_founded_relation'5 (index_logic s r) (index_logic s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_logic'0 (fun (r: int) -> r >= 0
          /\ not well_founded_relation'5 (index_logic s r) (index_logic s (r + 1))) x)
      /\ (index_logic'0 (fun (r: int) -> r >= 0
        /\ not well_founded_relation'5 (index_logic s r) (index_logic s (r + 1))) (such_that (fun (r: int) -> r >= 0
        /\ not well_founded_relation'5 (index_logic s r) (index_logic s (r + 1))))
      -> (let result = such_that (fun (r: int) -> r >= 0
      /\ not well_founded_relation'5 (index_logic s r) (index_logic s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'5 (index_logic s result) (index_logic s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation'7 (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) i) (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) i) (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) >= 0
        && not well_founded_relation (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))))) (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'5 (index_logic s result) (index_logic s (result
      + 1)))))))

end
module M_creusot_contracts__logic__well_founded__qyi8393942673489523592__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation'4 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation'3 self.f4 other.f4
  
  meta "rewrite_def" predicate well_founded_relation'4
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  type tuple'0 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4 }
  
  type tuple'1 = { f0'1: t_T0; f1'1: tuple'0 }
  
  function tuple_to_pair (self: tuple) : tuple'1 = { f0'1 = self.f0;
                                                     f1'1 = { f0'0 = self.f1;
                                                              f1'0 = self.f2;
                                                              f2'0 = self.f3;
                                                              f3'0 = self.f4 } }
  
  predicate well_founded_relation'5 [@inline:trivial] (self: tuple'0) (other: tuple'0) =
    well_founded_relation'0 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation'1 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation'2 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation'3 self.f3'0 other.f3'0
  
  meta "rewrite_def" predicate well_founded_relation'5
  
  predicate well_founded_relation'6 [@inline:trivial] (self: tuple'1) (other: tuple'1) =
    well_founded_relation self.f0'1 other.f0'1 \/ self.f0'1 = other.f0'1 /\ well_founded_relation'5 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation'6
  
  function index_logic'1 [@inline:trivial] (self: Map.map int tuple'1) (a: int) : tuple'1 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function extract_next_decr (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'6 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (i + 1)).f0'1 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'6 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'6 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (extract_next_decr s i)).f0'1
  
  function extract_nth (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'6 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'6 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'6 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic'1 s prev).f0'1 (index_logic'1 s (extract_nth s i)).f0'1)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_spec'0: forall p: Map.map t_T0 bool. (exists x: t_T0. index_logic'3 p x)
      -> index_logic'3 p (such_that'0 p)
  
  function first_component_decr (s: Map.map int tuple'1) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_logic'1 s (extract_nth s i)).f0'1
    else
      such_that'0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_spec: forall s: Map.map int tuple'1. (forall i: int. 0 <= i
          -> well_founded_relation'6 (index_logic'1 s i) (index_logic'1 s (i + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation (index_logic'2 (first_component_decr s) i) (index_logic'2 (first_component_decr s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation (index_logic'2 s (no_infinite_decreasing_sequence s)) (index_logic'2 s (no_infinite_decreasing_sequence s
      + 1))
  
  constant unreachable : int
  
  axiom unreachable_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int tuple) : int
  
  goal vc_no_infinite_decreasing_sequence: if exists r: int. r >= 0
      /\ not well_founded_relation'4 (index_logic s r) (index_logic s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_logic'0 (fun (r: int) -> r >= 0
          /\ not well_founded_relation'4 (index_logic s r) (index_logic s (r + 1))) x)
      /\ (index_logic'0 (fun (r: int) -> r >= 0
        /\ not well_founded_relation'4 (index_logic s r) (index_logic s (r + 1))) (such_that (fun (r: int) -> r >= 0
        /\ not well_founded_relation'4 (index_logic s r) (index_logic s (r + 1))))
      -> (let result = such_that (fun (r: int) -> r >= 0
      /\ not well_founded_relation'4 (index_logic s r) (index_logic s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'4 (index_logic s result) (index_logic s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation'6 (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) i) (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) i) (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) >= 0
        && not well_founded_relation (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))))) (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'4 (index_logic s result) (index_logic s (result
      + 1)))))))

end
module M_creusot_contracts__logic__well_founded__qyi949392529840141709__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
  
  meta "rewrite_def" predicate well_founded_relation'3
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  type tuple'0 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3 }
  
  type tuple'1 = { f0'1: t_T0; f1'1: tuple'0 }
  
  function tuple_to_pair (self: tuple) : tuple'1 = { f0'1 = self.f0;
                                                     f1'1 = { f0'0 = self.f1; f1'0 = self.f2; f2'0 = self.f3 } }
  
  predicate well_founded_relation'4 [@inline:trivial] (self: tuple'0) (other: tuple'0) =
    well_founded_relation'0 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation'1 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation'2 self.f2'0 other.f2'0
  
  meta "rewrite_def" predicate well_founded_relation'4
  
  predicate well_founded_relation'5 [@inline:trivial] (self: tuple'1) (other: tuple'1) =
    well_founded_relation self.f0'1 other.f0'1 \/ self.f0'1 = other.f0'1 /\ well_founded_relation'4 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation'5
  
  function index_logic'1 [@inline:trivial] (self: Map.map int tuple'1) (a: int) : tuple'1 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function extract_next_decr (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'5 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (i + 1)).f0'1 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'5 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'5 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (extract_next_decr s i)).f0'1
  
  function extract_nth (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'5 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'5 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'5 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic'1 s prev).f0'1 (index_logic'1 s (extract_nth s i)).f0'1)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_spec'0: forall p: Map.map t_T0 bool. (exists x: t_T0. index_logic'3 p x)
      -> index_logic'3 p (such_that'0 p)
  
  function first_component_decr (s: Map.map int tuple'1) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_logic'1 s (extract_nth s i)).f0'1
    else
      such_that'0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_spec: forall s: Map.map int tuple'1. (forall i: int. 0 <= i
          -> well_founded_relation'5 (index_logic'1 s i) (index_logic'1 s (i + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation (index_logic'2 (first_component_decr s) i) (index_logic'2 (first_component_decr s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation (index_logic'2 s (no_infinite_decreasing_sequence s)) (index_logic'2 s (no_infinite_decreasing_sequence s
      + 1))
  
  constant unreachable : int
  
  axiom unreachable_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int tuple) : int
  
  goal vc_no_infinite_decreasing_sequence: if exists r: int. r >= 0
      /\ not well_founded_relation'3 (index_logic s r) (index_logic s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_logic'0 (fun (r: int) -> r >= 0
          /\ not well_founded_relation'3 (index_logic s r) (index_logic s (r + 1))) x)
      /\ (index_logic'0 (fun (r: int) -> r >= 0
        /\ not well_founded_relation'3 (index_logic s r) (index_logic s (r + 1))) (such_that (fun (r: int) -> r >= 0
        /\ not well_founded_relation'3 (index_logic s r) (index_logic s (r + 1))))
      -> (let result = such_that (fun (r: int) -> r >= 0
      /\ not well_founded_relation'3 (index_logic s r) (index_logic s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'3 (index_logic s result) (index_logic s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation'5 (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) i) (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) i) (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) >= 0
        && not well_founded_relation (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))))) (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'3 (index_logic s result) (index_logic s (result
      + 1)))))))

end
module M_creusot_contracts__logic__well_founded__qyi10765982677188459404__no_infinite_decreasing_sequence (* <(T0, T1, T2) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
  
  meta "rewrite_def" predicate well_founded_relation'2
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  type tuple'0 = { f0'0: t_T1; f1'0: t_T2 }
  
  type tuple'1 = { f0'1: t_T0; f1'1: tuple'0 }
  
  function tuple_to_pair (self: tuple) : tuple'1 = { f0'1 = self.f0; f1'1 = { f0'0 = self.f1; f1'0 = self.f2 } }
  
  predicate well_founded_relation'3 [@inline:trivial] (self: tuple'0) (other: tuple'0) =
    well_founded_relation'0 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation'1 self.f1'0 other.f1'0
  
  meta "rewrite_def" predicate well_founded_relation'3
  
  predicate well_founded_relation'4 [@inline:trivial] (self: tuple'1) (other: tuple'1) =
    well_founded_relation self.f0'1 other.f0'1 \/ self.f0'1 = other.f0'1 /\ well_founded_relation'3 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation'4
  
  function index_logic'1 [@inline:trivial] (self: Map.map int tuple'1) (a: int) : tuple'1 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function extract_next_decr (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'4 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (i + 1)).f0'1 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'4 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'4 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic'1 s i).f0'1 (index_logic'1 s (extract_next_decr s i)).f0'1
  
  function extract_nth (s: Map.map int tuple'1) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'4 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'4 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple'1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'4 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic'1 s prev).f0'1 (index_logic'1 s (extract_nth s i)).f0'1)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_spec'0: forall p: Map.map t_T0 bool. (exists x: t_T0. index_logic'3 p x)
      -> index_logic'3 p (such_that'0 p)
  
  function first_component_decr (s: Map.map int tuple'1) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_logic'1 s (extract_nth s i)).f0'1
    else
      such_that'0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_spec: forall s: Map.map int tuple'1. (forall i: int. 0 <= i
          -> well_founded_relation'4 (index_logic'1 s i) (index_logic'1 s (i + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation (index_logic'2 (first_component_decr s) i) (index_logic'2 (first_component_decr s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation (index_logic'2 s (no_infinite_decreasing_sequence s)) (index_logic'2 s (no_infinite_decreasing_sequence s
      + 1))
  
  constant unreachable : int
  
  axiom unreachable_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int tuple) : int
  
  goal vc_no_infinite_decreasing_sequence: if exists r: int. r >= 0
      /\ not well_founded_relation'2 (index_logic s r) (index_logic s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_logic'0 (fun (r: int) -> r >= 0
          /\ not well_founded_relation'2 (index_logic s r) (index_logic s (r + 1))) x)
      /\ (index_logic'0 (fun (r: int) -> r >= 0
        /\ not well_founded_relation'2 (index_logic s r) (index_logic s (r + 1))) (such_that (fun (r: int) -> r >= 0
        /\ not well_founded_relation'2 (index_logic s r) (index_logic s (r + 1))))
      -> (let result = such_that (fun (r: int) -> r >= 0
      /\ not well_founded_relation'2 (index_logic s r) (index_logic s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'2 (index_logic s result) (index_logic s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation'4 (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) i) (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) i) (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) >= 0
        && not well_founded_relation (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))))) (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'2 (index_logic s result) (index_logic s (result
      + 1)))))))

end
module M_creusot_contracts__logic__well_founded__qyi16996715548001152850__no_infinite_decreasing_sequence (* <(T0, T1) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type tuple = { f0: t_T0; f1: t_T1 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation'1
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  type tuple'0 = { f0'0: t_T0; f1'0: t_T1 }
  
  function tuple_to_pair (self: tuple) : tuple'0 = { f0'0 = self.f0; f1'0 = self.f1 }
  
  predicate well_founded_relation'2 [@inline:trivial] (self: t_T1) (other: t_T1) = well_founded_relation'0 self other
  
  meta "rewrite_def" predicate well_founded_relation'2
  
  predicate well_founded_relation'3 [@inline:trivial] (self: tuple'0) (other: tuple'0) =
    well_founded_relation self.f0'0 other.f0'0 \/ self.f0'0 = other.f0'0 /\ well_founded_relation'2 self.f1'0 other.f1'0
  
  meta "rewrite_def" predicate well_founded_relation'3
  
  function index_logic'1 [@inline:trivial] (self: Map.map int tuple'0) (a: int) : tuple'0 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function extract_next_decr (s: Map.map int tuple'0) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple'0, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'3 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic'1 s i).f0'0 (index_logic'1 s (i + 1)).f0'0 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple'0, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'3 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple'0, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'3 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic'1 s i).f0'0 (index_logic'1 s (extract_next_decr s i)).f0'0
  
  function extract_nth (s: Map.map int tuple'0) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple'0, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'3 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple'0, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'3 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple'0, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'3 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic'1 s prev).f0'0 (index_logic'1 s (extract_nth s i)).f0'0)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_spec'0: forall p: Map.map t_T0 bool. (exists x: t_T0. index_logic'3 p x)
      -> index_logic'3 p (such_that'0 p)
  
  function first_component_decr (s: Map.map int tuple'0) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_logic'1 s (extract_nth s i)).f0'0
    else
      such_that'0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_spec: forall s: Map.map int tuple'0. (forall i: int. 0 <= i
          -> well_founded_relation'3 (index_logic'1 s i) (index_logic'1 s (i + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation (index_logic'2 (first_component_decr s) i) (index_logic'2 (first_component_decr s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation (index_logic'2 s (no_infinite_decreasing_sequence s)) (index_logic'2 s (no_infinite_decreasing_sequence s
      + 1))
  
  constant unreachable : int
  
  axiom unreachable_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int tuple) : int
  
  goal vc_no_infinite_decreasing_sequence: if exists r: int. r >= 0
      /\ not well_founded_relation'1 (index_logic s r) (index_logic s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_logic'0 (fun (r: int) -> r >= 0
          /\ not well_founded_relation'1 (index_logic s r) (index_logic s (r + 1))) x)
      /\ (index_logic'0 (fun (r: int) -> r >= 0
        /\ not well_founded_relation'1 (index_logic s r) (index_logic s (r + 1))) (such_that (fun (r: int) -> r >= 0
        /\ not well_founded_relation'1 (index_logic s r) (index_logic s (r + 1))))
      -> (let result = such_that (fun (r: int) -> r >= 0
      /\ not well_founded_relation'1 (index_logic s r) (index_logic s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'1 (index_logic s result) (index_logic s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation'3 (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) i) (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) i) (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) >= 0
        && not well_founded_relation (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))))) (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'1 (index_logic s result) (index_logic s (result
      + 1)))))))

end
module M_creusot_contracts__logic__well_founded__qyi8411281253318747442__no_infinite_decreasing_sequence (* <(T0,) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: t_T0) (other: t_T0) = well_founded_relation self other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. (exists x: int. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  type tuple = { f0: t_T0; f1: () }
  
  function tuple_to_pair (self: t_T0) : tuple = { f0 = self; f1 = () }
  
  predicate well_founded_relation'1 [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation'1
  
  predicate well_founded_relation'2 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation'1 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation'2
  
  function index_logic'1 [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function index_logic'2 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic'2
  
  function extract_next_decr (s: Map.map int tuple) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'2 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic'1 s i).f0 (index_logic'1 s (i + 1)).f0 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'2 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'2 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic'1 s i).f0 (index_logic'1 s (extract_next_decr s i)).f0
  
  function extract_nth (s: Map.map int tuple) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'2 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'2 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'2 (index_logic'1 s i'0) (index_logic'1 s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic'1 s prev).f0 (index_logic'1 s (extract_nth s i)).f0)
  
  predicate index_logic'3 [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'3
  
  function such_that'0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_spec'0: forall p: Map.map t_T0 bool. (exists x: t_T0. index_logic'3 p x)
      -> index_logic'3 p (such_that'0 p)
  
  function first_component_decr (s: Map.map int tuple) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_logic'1 s (extract_nth s i)).f0
    else
      such_that'0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_spec: forall s: Map.map int tuple. (forall i: int. 0 <= i
          -> well_founded_relation'2 (index_logic'1 s i) (index_logic'1 s (i + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation (index_logic'2 (first_component_decr s) i) (index_logic'2 (first_component_decr s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence s >= 0
  
  axiom no_infinite_decreasing_sequence_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation (index_logic'2 s (no_infinite_decreasing_sequence s)) (index_logic'2 s (no_infinite_decreasing_sequence s
      + 1))
  
  constant unreachable : int
  
  axiom unreachable_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T0
  
  function no_infinite_decreasing_sequence'0 (s: Map.map int t_T0) : int
  
  goal vc_no_infinite_decreasing_sequence: if exists r: int. r >= 0
      /\ not well_founded_relation'0 (index_logic s r) (index_logic s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_logic'0 (fun (r: int) -> r >= 0
          /\ not well_founded_relation'0 (index_logic s r) (index_logic s (r + 1))) x)
      /\ (index_logic'0 (fun (r: int) -> r >= 0
        /\ not well_founded_relation'0 (index_logic s r) (index_logic s (r + 1))) (such_that (fun (r: int) -> r >= 0
        /\ not well_founded_relation'0 (index_logic s r) (index_logic s (r + 1))))
      -> (let result = such_that (fun (r: int) -> r >= 0
      /\ not well_founded_relation'0 (index_logic s r) (index_logic s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'0 (index_logic s result) (index_logic s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation'2 (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) i) (index_logic'1 (fun (i'0: int) -> tuple_to_pair (index_logic s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) i) (index_logic'2 (first_component_decr (fun (i'0: int) -> tuple_to_pair (index_logic s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) >= 0
        && not well_founded_relation (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))))) (index_logic'2 (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) (no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence (first_component_decr (fun (i: int) -> tuple_to_pair (index_logic s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation'0 (index_logic s result) (index_logic s (result
      + 1)))))))

end
module M_creusot_contracts__logic__well_founded__extract_next_decr
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T1
  
  type t_T2
  
  type tuple = { f0: t_T1; f1: t_T2 }
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate well_founded_relation (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'0 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'1 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  constant i : int
  
  function extract_next_decr (s: Map.map int tuple) (i: int) : int
  
  goal vc_extract_next_decr: (forall i'0: int. 0 <= i'0
        -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
    -> 0 <= i
    -> (if well_founded_relation (index_logic s i).f0 (index_logic s (i + 1)).f0 then
      let result = i + 1 in ([@expl:extract_next_decr ensures #0] i < result)
      && ([@expl:extract_next_decr ensures #1] well_founded_relation (index_logic s i).f0 (index_logic s result).f0)
    else
      ((([@expl:extract_next_decr requires #0] forall i'0: int. 0 <= i'0
              -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
          && ([@expl:extract_next_decr requires #1] 0 <= i + 1))
        /\ well_founded_relation'0 (index_logic s i).f1 (index_logic s (i + 1)).f1)
      /\ (i + 1 < extract_next_decr s (i + 1)
        && well_founded_relation (index_logic s (i + 1)).f0 (index_logic s (extract_next_decr s (i + 1))).f0
      -> (let result = extract_next_decr s (i + 1) in ([@expl:extract_next_decr ensures #0] i < result)
      && ([@expl:extract_next_decr ensures #1] well_founded_relation (index_logic s i).f0 (index_logic s result).f0)))
    )
end
module M_creusot_contracts__logic__well_founded__extract_nth
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T1
  
  type t_T2
  
  type tuple = { f0: t_T1; f1: t_T2 }
  
  predicate well_founded_relation (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'0 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'1 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation'1
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate well_founded_relation'2 [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation'2
  
  function extract_next_decr (s: Map.map int tuple) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic s i).f0 (index_logic s (i + 1)).f0 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic s i).f0 (index_logic s (extract_next_decr s i)).f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  constant i : int
  
  function extract_nth (s: Map.map int tuple) (i: int) : int
  
  goal vc_extract_nth: (forall i'0: int. 0 <= i'0
        -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
    -> 0 <= i
    -> (if i = 0 then
      let result = 0 in ([@expl:extract_nth ensures #0] 0 <= result)
      && ([@expl:extract_nth ensures #1] 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < result
      /\ well_founded_relation (index_logic s prev).f0 (index_logic s result).f0))
    else
      ((([@expl:extract_nth requires #0] forall i'0: int. 0 <= i'0
              -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
          && ([@expl:extract_nth requires #1] 0 <= i - 1))
        /\ well_founded_relation'2 i (i - 1))
      /\ (0 <= extract_nth s (i - 1)
        && (0 < i - 1
        -> (let prev = extract_nth s (i - 1 - 1) in prev < extract_nth s (i - 1)
        /\ well_founded_relation (index_logic s prev).f0 (index_logic s (extract_nth s (i - 1))).f0))
      -> (let prev = extract_nth s (i - 1) in (([@expl:extract_next_decr requires #0] forall i'0: int. 0 <= i'0
            -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
        && ([@expl:extract_next_decr requires #1] 0 <= prev))
      /\ (prev < extract_next_decr s prev
        && well_founded_relation (index_logic s prev).f0 (index_logic s (extract_next_decr s prev)).f0
      -> (let result = extract_next_decr s prev in ([@expl:extract_nth ensures #0] 0 <= result)
      && ([@expl:extract_nth ensures #1] 0 < i
      -> (let prev'0 = extract_nth s (i - 1) in prev'0 < result
      /\ well_founded_relation (index_logic s prev'0).f0 (index_logic s result).f0))))))
    )
end
module M_creusot_contracts__logic__well_founded__first_component_decr
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T1
  
  type t_T2
  
  type tuple = { f0: t_T1; f1: t_T2 }
  
  predicate well_founded_relation (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'0 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'1 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation'1
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [@inline:trivial] (self: Map.map int t_T1) (a: int) : t_T1 = Map.get self a
  
  meta "rewrite_def" function index_logic'0
  
  function extract_next_decr (s: Map.map int tuple) (i: int) : int
  
  axiom extract_next_decr_def: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
      -> 0 <= i
      -> extract_next_decr s i
      = (if well_founded_relation (index_logic s i).f0 (index_logic s (i + 1)).f0 then
        i + 1
      else
        extract_next_decr s (i + 1)
      )
  
  axiom extract_next_decr_spec: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
      -> 0 <= i -> i < extract_next_decr s i
  
  axiom extract_next_decr_spec'0: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
      -> 0 <= i -> well_founded_relation (index_logic s i).f0 (index_logic s (extract_next_decr s i)).f0
  
  function extract_nth (s: Map.map int tuple) (i: int) : int
  
  axiom extract_nth_def: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
      -> 0 <= i -> extract_nth s i = (if i = 0 then 0 else let prev = extract_nth s (i - 1) in extract_next_decr s prev)
  
  axiom extract_nth_spec: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1))) -> 0 <= i -> 0 <= extract_nth s i
  
  axiom extract_nth_spec'0: forall s: Map.map int tuple, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth s (i - 1) in prev < extract_nth s i
      /\ well_founded_relation (index_logic s prev).f0 (index_logic s (extract_nth s i)).f0)
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map t_T1 bool) (a: t_T1) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that (p: Map.map t_T1 bool) : t_T1
  
  axiom such_that_spec: forall p: Map.map t_T1 bool. (exists x: t_T1. index_logic'1 p x)
      -> index_logic'1 p (such_that p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tuple
  
  function first_component_decr (s: Map.map int tuple) : Map.map int t_T1
  
  goal vc_first_component_decr: (forall i: int. 0 <= i
        -> well_founded_relation'1 (index_logic s i) (index_logic s (i + 1)))
    -> (forall i: int. if 0 <= i then
          ([@expl:extract_nth requires #0] forall i'0: int. 0 <= i'0
              -> well_founded_relation'1 (index_logic s i'0) (index_logic s (i'0 + 1)))
          && ([@expl:extract_nth requires #1] 0 <= i)
        else
          [@expl:such_that requires] exists x: t_T1. index_logic'1 (fun (__0: t_T1) -> true) x
      )
    /\ (let result = fun (i: int) -> if 0 <= i then
      (index_logic s (extract_nth s i)).f0
    else
      such_that (fun (__0: t_T1) -> true)
     in [@expl:first_component_decr ensures] forall i: int. 0 <= i
      -> well_founded_relation (index_logic'0 result i) (index_logic'0 result (i + 1)))
end
module M_creusot_contracts__peano__qyi18263836234684628832__clone (* <peano::PeanoInt as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec clone' (self_: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = self_} (! return {result}) ]
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: UInt64.t) (result_state: ()) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''0 (self: t_PeanoInt) (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_5 <- self.t_PeanoInt__0 ] s1
      | s1 = clone' {_5} (fun (_ret: UInt64.t) -> [ &_3 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { t_PeanoInt__0 = _3 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_PeanoInt = Any.any_l ()
    | & self: t_PeanoInt = self
    | & _3: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@expl:clone ensures] postcondition () self.t_PeanoInt__0 result.t_PeanoInt__0}
      (! return {result}) ]
end
module M_creusot_contracts__peano__qyi17635635094782400840__default (* <peano::PeanoInt as std::default::Default> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec default (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = (0: UInt64.t)} (! return {result}) ]
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: UInt64.t. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: UInt64.t. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: UInt64.t) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: UInt64.t. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: UInt64.t. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default'0 (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret: UInt64.t) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { t_PeanoInt__0 = _2 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_PeanoInt = Any.any_l () | & _2: UInt64.t = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@expl:default ensures] true /\ postcondition () () result.t_PeanoInt__0}
      (! return {result}) ]
end
module M_creusot_contracts__peano__qyi13288218011503588188__assert_receiver_is_total_eq (* <peano::PeanoInt as std::cmp::Eq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq (self: t_PeanoInt) (return (x: ())) = (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_le_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_le_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] le_log x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_lt_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_lt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] lt_log x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_ge_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_ge_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] ge_log x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_gt_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_gt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] gt_log x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__refl (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  function refl'0 (x: t_PeanoInt) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__peano__qyi5347411415401763779__trans (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  constant z : t_PeanoInt
  
  constant o : t_Ordering
  
  function trans'0 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log'0 x y = o -> cmp_log'0 y z = o -> ([@expl:trans ensures] cmp_log'0 x z = o)
end
module M_creusot_contracts__peano__qyi5347411415401763779__antisym1 (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function antisym1'0 (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_antisym1: cmp_log'0 x y = C_Less -> ([@expl:antisym1 ensures] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__antisym2 (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function antisym2'0 (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_antisym2: cmp_log'0 x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__eq_cmp (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function eq_cmp'0 (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__peano__qyi18300662544233371341__partial_cmp (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  function eq_cmp'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_PeanoInt) : () = ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. cmp_log'0 x x = C_Equal
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_gt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_ge_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_lt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_le_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. le_log x y = (cmp_log'0 x y <> C_Greater)
  
  let rec cmp (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Ordering)) = any
    [ return (result: t_Ordering) -> {result = cmp_log'0 self other} (! return {result}) ]
  
  type t_Option = C_None | C_Some t_Ordering
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec partial_cmp (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option)) = (! bb0
    [ bb0 = s0 [ s0 = cmp {self} {other} (fun (_ret: t_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- C_Some _4 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Option = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Ordering = Any.any_l () ])
    [ return (result: t_Option) -> {[@expl:partial_cmp ensures] result = C_Some (cmp_log'0 self other)}
      (! return {result}) ]
end
module M_creusot_contracts__peano__qyi18300662544233371341__lt (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  function eq_cmp'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_PeanoInt) : () = ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. cmp_log'0 x x = C_Equal
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_gt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_ge_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_lt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_le_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. le_log x y = (cmp_log'0 x y <> C_Greater)
  
  let rec partial_cmp (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log'0 self other)} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec lt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:lt ensures] result = UInt64.lt (view self) (view other)} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi18300662544233371341__le (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  function eq_cmp'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_PeanoInt) : () = ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. cmp_log'0 x x = C_Equal
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_gt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_ge_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_lt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_le_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. le_log x y = (cmp_log'0 x y <> C_Greater)
  
  let rec partial_cmp (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log'0 self other)} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec le (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:le ensures] result = UInt64.le (view self) (view other)} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi18300662544233371341__gt (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  function eq_cmp'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_PeanoInt) : () = ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. cmp_log'0 x x = C_Equal
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_gt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_ge_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_lt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_le_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. le_log x y = (cmp_log'0 x y <> C_Greater)
  
  let rec partial_cmp (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log'0 self other)} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec gt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:gt ensures] result = UInt64.gt (view self) (view other)} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi18300662544233371341__ge (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  function eq_cmp'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_PeanoInt) : () = ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. cmp_log'0 x x = C_Equal
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_gt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_ge_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_lt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_le_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. le_log x y = (cmp_log'0 x y <> C_Greater)
  
  let rec partial_cmp (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log'0 self other)} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ge (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:ge ensures] result = UInt64.ge (view self) (view other)} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi18409208157518949721__cmp (* <peano::PeanoInt as std::cmp::Ord> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Ordering)) = any
    [ return (result: t_Ordering) -> {result = cmp_log (deep_model self_) (deep_model rhs)} (! return {result}) ]
  
  function cmp_log'0 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp'0 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec'0: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec'0: forall x: UInt64.t, y: UInt64.t. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec'0: forall x: UInt64.t, y: UInt64.t. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: UInt64.t) : ()
  
  axiom refl_spec'0: forall x: UInt64.t. cmp_log'0 x x = C_Equal
  
  function cmp_gt_log'0 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec'0: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log'0 x y = C_Greater)
  
  function cmp_ge_log'0 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec'0: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log'0 x y <> C_Less)
  
  function cmp_lt_log'0 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec'0: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log'0 x y = C_Less)
  
  function cmp_le_log'0 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec'0: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log'0 self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'1
  
  function eq_cmp'1 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log'1 x y = C_Equal)
  
  function antisym2'1 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'1 x y = C_Greater -> cmp_log'1 y x = C_Less
  
  function antisym1'1 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'1 x y = C_Less -> cmp_log'1 y x = C_Greater
  
  function trans'1 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_spec'1: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log'1 x y = o
      -> cmp_log'1 y z = o -> cmp_log'1 x z = o
  
  function refl'1 (x: t_PeanoInt) : () = ()
  
  axiom refl_spec'1: forall x: t_PeanoInt. cmp_log'1 x x = C_Equal
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_gt_log'1 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. gt_log x y = (cmp_log'1 x y = C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_ge_log'1 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. ge_log x y = (cmp_log'1 x y <> C_Less)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_lt_log'1 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. lt_log x y = (cmp_log'1 x y = C_Less)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_le_log'1 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. le_log x y = (cmp_log'1 x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec cmp'0 (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Ordering)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- other.t_PeanoInt__0 ] s1
      | s1 = cmp {self.t_PeanoInt__0} {_6} (fun (_ret: t_Ordering) -> [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = return {_0} ]
    [ & _0: t_Ordering = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _6: UInt64.t = Any.any_l () ])
    [ return (result: t_Ordering) -> {[@expl:cmp ensures] result = cmp_log'1 self other} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi14634619887680291373__eq (* <peano::PeanoInt as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self.t_PeanoInt__0 = other.t_PeanoInt__0 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self: t_PeanoInt = self | & other: t_PeanoInt = other ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (self = other)} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi4712407557780062981__new (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { t_PeanoInt__0 = (0: UInt64.t) } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_PeanoInt = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@expl:new ensures] result.t_PeanoInt__0 = (0: UInt64.t)} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u64 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_u64 (self: t_PeanoInt) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self.t_PeanoInt__0 ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: UInt64.t) -> {[@expl:to_u64 ensures] result = self.t_PeanoInt__0} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u128 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_u128 (self: t_PeanoInt) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt128.of_int {UInt64.t'int self.t_PeanoInt__0} (fun (_ret_from: UInt128.t) -> [ &_0 <- _ret_from ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt128.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: UInt128.t) -> {[@expl:to_u128 ensures] UInt128.t'int result = UInt64.t'int self.t_PeanoInt__0}
      (! return {result}) ]
end
module M_creusot_contracts__peano__qyi4712407557780062981__to_i128 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_i128 (self: t_PeanoInt) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int128.of_int {UInt64.t'int self.t_PeanoInt__0} (fun (_ret_from: Int128.t) -> [ &_0 <- _ret_from ] s1)
      | s1 = return {_0} ] ] [ & _0: Int128.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: Int128.t) -> {[@expl:to_i128 ensures] Int128.to_int result = UInt64.t'int self.t_PeanoInt__0}
      (! return {result}) ]
end
module M_creusot_contracts__peano__qyi924939193479538090__from (* <u64 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec to_u64 (self: t_PeanoInt) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = self.t_PeanoInt__0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from (val': t_PeanoInt) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_u64 {val'} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: UInt64.t) -> {[@expl:from ensures] result = val'.t_PeanoInt__0} (! return {result}) ]
end
module M_creusot_contracts__peano__qyi18279771819627139730__from (* <i64 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec to_i64 (self: t_PeanoInt) (return (x: Int64.t)) = any
    [ return (result: Int64.t) -> {Int64.to_int result = UInt64.t'int self.t_PeanoInt__0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from (val': t_PeanoInt) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_i64 {val'} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: Int64.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: Int64.t) -> {[@expl:from ensures] Int64.to_int result = UInt64.t'int val'.t_PeanoInt__0}
      (! return {result}) ]
end
module M_creusot_contracts__peano__qyi6128796959392123454__from (* <u128 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec to_u128 (self: t_PeanoInt) (return (x: UInt128.t)) = any
    [ return (result: UInt128.t) -> {UInt128.t'int result = UInt64.t'int self.t_PeanoInt__0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from (val': t_PeanoInt) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_u128 {val'} (fun (_ret: UInt128.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: UInt128.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: UInt128.t) -> {[@expl:from ensures] UInt128.t'int result = UInt64.t'int val'.t_PeanoInt__0}
      (! return {result}) ]
end
module M_creusot_contracts__peano__qyi11594489632978387465__from (* <i128 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  let rec to_i128 (self: t_PeanoInt) (return (x: Int128.t)) = any
    [ return (result: Int128.t) -> {Int128.to_int result = UInt64.t'int self.t_PeanoInt__0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from (val': t_PeanoInt) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_i128 {val'} (fun (_ret: Int128.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: Int128.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: Int128.t) -> {[@expl:from ensures] Int128.to_int result = UInt64.t'int val'.t_PeanoInt__0}
      (! return {result}) ]
end
module M_creusot_contracts__resolve__qyi1804364923227103020__resolve_coherence (* <&'a T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate resolve (self: t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_T
  
  function resolve_coherence (self: t_T) : ()
  
  goal vc_resolve_coherence: [@expl:resolve_coherence ensures] resolve self
end
module M_creusot_contracts__resolve__qyi13312526907268931455__resolve_coherence (* <&'a mut T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate resolve (self: MutBorrow.t t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_T
  
  function resolve_coherence (self: MutBorrow.t t_T) : ()
  
  goal vc_resolve_coherence: [@expl:resolve_coherence ensures] resolve self
end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' (self: t_T) (return (x: t_T)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = return {_0} ] ] [ & _0: t_T = Any.any_l () | & self: t_T = self ])
    [ return (result: t_T) -> {[@expl:clone ensures] result = self} (! return {result}) ]
end
module M_creusot_contracts__std__array__qyi10624171005586529217__produces_refl (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter
  
  function produces_refl (self: t_IntoIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__array__qyi10624171005586529217__produces_trans (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq t_T) (b: t_IntoIter) (bc: Seq.seq t_T) (c: t_IntoIter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__clone__extern_spec_Clone_bool_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_bool_clone_body (self_: bool) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ] [ & _0: bool = Any.any_l () | & self_: bool = self_ ])
    [ return (result: bool) -> {[@expl:extern_spec_Clone_bool_clone_body ensures] result = self_} (! return {result}) ]
end
module M_creusot_contracts__std__clone__extern_spec_Clone_f32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.float.Float32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_f32_clone_body (self_: Float32.t) (return (x: Float32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Float32.t = Any.any_l () | & self_: Float32.t = self_ ])
    [ return (result: Float32.t) -> {[@expl:extern_spec_Clone_f32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__clone__extern_spec_Clone_f64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.float.Float64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_f64_clone_body (self_: Float64.t) (return (x: Float64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Float64.t = Any.any_l () | & self_: Float64.t = self_ ])
    [ return (result: Float64.t) -> {[@expl:extern_spec_Clone_f64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__clone__extern_spec_T_Cloneqy95z_ref_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Cloneqy95z_ref_T_clone_body (self_: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_T_Clone__ref_T_clone_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ] [ & _0: t_T = Any.any_l () | & self_: t_T = self_ ])
    [ return (result: t_T) -> {[@expl:extern_spec_T_Clone__ref_T_clone_body result type invariant] inv'0 result}
      {[@expl:extern_spec_T_Clone__ref_T_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__collections__hash_map__qyi2751221633790567300__produces_refl (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IntoIter
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_IntoIter) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq tuple) (o: t_IntoIter) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
        -> (exists k1: t_K. deep_model k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2 /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1).f0 = deep_model (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter
  
  function produces_refl (self: t_IntoIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__collections__hash_map__qyi2751221633790567300__produces_trans (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IntoIter
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_IntoIter) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq tuple) (o: t_IntoIter) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
        -> (exists k1: t_K. deep_model k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2 /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1).f0 = deep_model (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter
  
  constant ab : Seq.seq tuple
  
  constant b : t_IntoIter
  
  constant bc : Seq.seq tuple
  
  constant c : t_IntoIter
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq tuple) (b: t_IntoIter) (bc: Seq.seq tuple) (c: t_IntoIter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_map__qyi17229515035433614012__produces_refl (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_Iter) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_Iter) (visited: Seq.seq tuple) (o: t_Iter) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
        -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter
  
  function produces_refl (self: t_Iter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__collections__hash_map__qyi17229515035433614012__produces_trans (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_Iter) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_Iter) (visited: Seq.seq tuple) (o: t_Iter) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
        -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter
  
  constant ab : Seq.seq tuple
  
  constant b : t_Iter
  
  constant bc : Seq.seq tuple
  
  constant c : t_Iter
  
  function produces_trans (a: t_Iter) (ab: Seq.seq tuple) (b: t_Iter) (bc: Seq.seq tuple) (c: t_Iter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_map__qyi7200148303891188075__produces_refl (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IterMut
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_IterMut) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some (MutBorrow.t t_V)
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_IterMut) (visited: Seq.seq tuple) (o: t_IterMut) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
        -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut
  
  function produces_refl (self: t_IterMut) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__collections__hash_map__qyi7200148303891188075__produces_trans (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IterMut
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_IterMut) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some (MutBorrow.t t_V)
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_IterMut) (visited: Seq.seq tuple) (o: t_IterMut) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
        -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut
  
  constant ab : Seq.seq tuple
  
  constant b : t_IterMut
  
  constant bc : Seq.seq tuple
  
  constant c : t_IterMut
  
  function produces_trans (a: t_IterMut) (ab: Seq.seq tuple) (b: t_IterMut) (bc: Seq.seq tuple) (c: t_IterMut) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_set__set_produces_trans
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_I
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_I) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_I) (visited: Seq.seq t_T) (end': t_I) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j) -> i = j)
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  type t_Option = C_None | C_Some t_T
  
  function get (self: Seq.seq t_T) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_I
  
  constant ab : Seq.seq t_T
  
  constant b : t_I
  
  constant bc : Seq.seq t_T
  
  constant c : t_I
  
  function set_produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  goal vc_set_produces_trans: set_produces a ab b
    -> set_produces b bc c
    -> (forall a'0: Seq.seq t_T, b'0: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a'0 b'0) x = contains'0 a'0 x
        \/ contains'0 b'0 x)
    -> (let _ = concat_contains in (forall i: int, x: t_T. Seq.length ab <= i /\ get (Seq.(++) ab bc) i = C_Some x
        -> contains'0 bc x)
    && (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@expl:set_produces_trans ensures] set_produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__std__collections__hash_set__qyi16362841949556730032__produces_refl (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_IntoIter
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_IntoIter) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_IntoIter) (visited: Seq.seq t_T) (end': t_IntoIter) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j) -> i = j)
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter
  
  function produces_refl (self: t_IntoIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_set__qyi16362841949556730032__produces_trans (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_IntoIter
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_IntoIter) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_IntoIter) (visited: Seq.seq t_T) (end': t_IntoIter) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j) -> i = j)
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = set_produces self visited o
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_IntoIter) (ab: Seq.seq t_T) (b: t_IntoIter) (bc: Seq.seq t_T) (c: t_IntoIter) : () =
    let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_IntoIter, ab: Seq.seq t_T, b: t_IntoIter, bc: Seq.seq t_T, c: t_IntoIter. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq t_T) (b: t_IntoIter) (bc: Seq.seq t_T) (c: t_IntoIter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (([@expl:set_produces_trans requires #0] set_produces a ab b)
      && ([@expl:set_produces_trans requires #1] set_produces b bc c))
    /\ (set_produces a (Seq.(++) ab bc) c
    -> (let _ = set_produces_trans a ab b bc c in [@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__std__collections__hash_set__qyi14856790125802176998__produces_refl (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Iter) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Iter) (visited: Seq.seq t_T) (end': t_Iter) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter
  
  function produces_refl (self: t_Iter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_set__qyi14856790125802176998__produces_trans (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Iter) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Iter) (visited: Seq.seq t_T) (end': t_Iter) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) = set_produces self visited o
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : () =
    let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Iter, ab: Seq.seq t_T, b: t_Iter, bc: Seq.seq t_T, c: t_Iter. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter
  
  function produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (([@expl:set_produces_trans requires #0] set_produces a ab b)
      && ([@expl:set_produces_trans requires #1] set_produces b bc c))
    /\ (set_produces a (Seq.(++) ab bc) c
    -> (let _ = set_produces_trans a ab b bc c in [@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__std__collections__hash_set__qyi1282364555482257102__produces_refl (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Intersection
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Intersection
  
  function produces_refl (self: t_Intersection) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_set__qyi1282364555482257102__produces_trans (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Intersection
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection) = set_produces self visited o
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
   = let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Intersection
  
  constant ab : Seq.seq t_T
  
  constant b : t_Intersection
  
  constant bc : Seq.seq t_T
  
  constant c : t_Intersection
  
  function produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (([@expl:set_produces_trans requires #0] set_produces a ab b)
      && ([@expl:set_produces_trans requires #1] set_produces b bc c))
    /\ (set_produces a (Seq.(++) ab bc) c
    -> (let _ = set_produces_trans a ab b bc c in [@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__std__collections__hash_set__qyi3953735896298504416__produces_refl (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Difference
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Difference) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Difference
  
  function produces_refl (self: t_Difference) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_set__qyi3953735896298504416__produces_trans (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Difference
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Difference) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference) = set_produces self visited o
  
  constant concat_contains: () = ()
  
  axiom concat_contains_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
        = contains'0 a x
      \/ contains'0 b x
  
  function set_produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
   = let _ = concat_contains in ()
  
  axiom set_produces_trans_spec:
    forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. set_produces a ab b
      -> set_produces b bc c -> set_produces a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Difference
  
  constant ab : Seq.seq t_T
  
  constant b : t_Difference
  
  constant bc : Seq.seq t_T
  
  constant c : t_Difference
  
  function produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c
    -> (([@expl:set_produces_trans requires #0] set_produces a ab b)
      && ([@expl:set_produces_trans requires #1] set_produces b bc c))
    /\ (set_produces a (Seq.(++) ab bc) c
    -> (let _ = set_produces_trans a ab b bc c in [@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_PartialEq_Rhs_ne_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  predicate inv (_1: t_Self_)
  
  predicate invariant' [@inline:trivial] (self: t_Self_) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_Self_) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: t_Self_) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_Self_) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 (_1: t_Rhs)
  
  predicate invariant''1 [@inline:trivial] (self: t_Rhs) = inv'2 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 [@inline:trivial] (_1: t_Rhs) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate invariant''2 [@inline:trivial] (self: t_Rhs) = inv'3 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'4 [@inline:trivial] (_1: t_Rhs) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'4
  
  type t_DeepModelTy
  
  function deep_model (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  function deep_model'1 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'1
  
  function deep_model'2 (self: t_Rhs) : t_DeepModelTy
  
  function deep_model'3 [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model'2 self
  
  meta "rewrite_def" function deep_model'3
  
  function deep_model'4 [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model'3 self
  
  meta "rewrite_def" function deep_model'4
  
  let rec eq (self_: t_Self_) (rhs: t_Rhs) (return (x: bool)) = {[@expl:eq 'self_' type invariant] inv'1 self_}
    {[@expl:eq 'rhs' type invariant] inv'4 rhs}
    any [ return (result: bool) -> {result = (deep_model'1 self_ = deep_model'4 rhs)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialEq_Rhs_ne_body (self_: t_Self_) (rhs: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'self_' type invariant] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'rhs' type invariant] inv'3 rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq {self_} {rhs} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- not _4 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self_: t_Self_ = self_ | & rhs: t_Rhs = rhs | & _4: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body ensures] result
      = (deep_model'0 self_ <> deep_model'3 rhs)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_PartialOrd_Rhs_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  type tuple = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv (_1: t_Rhs)
  
  predicate invariant' [@inline:trivial] (self: t_Rhs) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_Rhs) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Self_)
  
  predicate invariant''0 [@inline:trivial] (self: t_Self_) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_Self_) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'0 rhs
        /\ inv'2 self_) -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Option)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option)) =
    {[@expl:partial_cmp requires] precondition () { f0 = self_; f1 = rhs }}
    any [ return (result: t_Option) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'1 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'1
  
  function deep_model'2 [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_lt_body (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'other' type invariant] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: t_Self_ = self_ | & other: t_Rhs = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body ensures] result
      = lt_log (deep_model'1 self_) (deep_model'2 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_PartialOrd_Rhs_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  type tuple = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv (_1: t_Rhs)
  
  predicate invariant' [@inline:trivial] (self: t_Rhs) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_Rhs) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Self_)
  
  predicate invariant''0 [@inline:trivial] (self: t_Self_) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_Self_) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'0 rhs
        /\ inv'2 self_) -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Option)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option)) =
    {[@expl:partial_cmp requires] precondition () { f0 = self_; f1 = rhs }}
    any [ return (result: t_Option) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'1 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'1
  
  function deep_model'2 [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_le_body (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'other' type invariant] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: t_Self_ = self_ | & other: t_Rhs = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body ensures] result
      = le_log (deep_model'1 self_) (deep_model'2 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_PartialOrd_Rhs_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  type tuple = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv (_1: t_Rhs)
  
  predicate invariant' [@inline:trivial] (self: t_Rhs) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_Rhs) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Self_)
  
  predicate invariant''0 [@inline:trivial] (self: t_Self_) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_Self_) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'0 rhs
        /\ inv'2 self_) -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Option)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option)) =
    {[@expl:partial_cmp requires] precondition () { f0 = self_; f1 = rhs }}
    any [ return (result: t_Option) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'1 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'1
  
  function deep_model'2 [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_gt_body (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'other' type invariant] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: t_Self_ = self_ | & other: t_Rhs = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body ensures] result
      = gt_log (deep_model'1 self_) (deep_model'2 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_PartialOrd_Rhs_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  type tuple = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv (_1: t_Rhs)
  
  predicate invariant' [@inline:trivial] (self: t_Rhs) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_Rhs) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Self_)
  
  predicate invariant''0 [@inline:trivial] (self: t_Self_) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_Self_) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = rhs} = args in inv'0 rhs
        /\ inv'2 self_) -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Option)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option)) =
    {[@expl:partial_cmp requires] precondition () { f0 = self_; f1 = rhs }}
    any [ return (result: t_Option) -> {postcondition_once () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'1 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'1
  
  function deep_model'2 [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_ge_body (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'other' type invariant] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: t_Self_ = self_ | & other: t_Rhs = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body ensures] result
      = ge_log (deep_model'1 self_) (deep_model'2 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_Ord_max_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv (_1: t_Self_)
  
  predicate invariant' [@inline:trivial] (self: t_Self_) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_Self_) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef:
    forall args: tuple [precondition () args]. (let {f0 = self_; f1 = other} = args in inv'0 other /\ inv'0 self_)
      -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate postcondition_once (self: ()) (args: tuple) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = other} = args in res = le_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec le (self_: t_Self_) (other: t_Self_) (return (x: bool)) = {[@expl:le requires] precondition () { f0 = self_;
                                                                                                           f1 = other }}
    any [ return (result: bool) -> {postcondition_once () { f0 = self_; f1 = other } result} (! return {result}) ]
  
  predicate resolve (_1: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_max_body (self_: t_Self_) (o: t_Self_) (return (x: t_Self_)) =
    {[@expl:extern_spec_std_cmp_Ord_max_body 'self_' type invariant] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_max_body 'o' type invariant] inv o}
    (! bb0
    [ bb0 = s0 [ s0 = le {self_} {o} (fun (_ret: bool) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_8 = false} (! bb3) | br1 -> {_8} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv self_} s1 | s1 = -{resolve self_}- s2 | s2 = [ &_0 <- o ] s3 | s3 = bb6 ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv o} s1 | s1 = -{resolve o}- s2 | s2 = [ &_0 <- self_ ] s3 | s3 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_Self_ = Any.any_l () | & self_: t_Self_ = self_ | & o: t_Self_ = o | & _8: bool = Any.any_l () ])
    [ return (result: t_Self_) -> {[@expl:extern_spec_std_cmp_Ord_max_body result type invariant] inv result}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #0] ge_log (deep_model result) (deep_model self_)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #1] ge_log (deep_model result) (deep_model o)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #2] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #3] le_log (deep_model self_) (deep_model o) -> result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #4] lt_log (deep_model o) (deep_model self_) -> result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_Ord_min_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv (_1: t_Self_)
  
  predicate invariant' [@inline:trivial] (self: t_Self_) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_Self_) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef:
    forall args: tuple [precondition () args]. (let {f0 = self_; f1 = other} = args in inv'0 other /\ inv'0 self_)
      -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate postcondition_once (self: ()) (args: tuple) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = other} = args in res = lt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec lt (self_: t_Self_) (other: t_Self_) (return (x: bool)) = {[@expl:lt requires] precondition () { f0 = self_;
                                                                                                           f1 = other }}
    any [ return (result: bool) -> {postcondition_once () { f0 = self_; f1 = other } result} (! return {result}) ]
  
  predicate resolve (_1: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_min_body (self_: t_Self_) (o: t_Self_) (return (x: t_Self_)) =
    {[@expl:extern_spec_std_cmp_Ord_min_body 'self_' type invariant] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_min_body 'o' type invariant] inv o}
    (! bb0
    [ bb0 = s0 [ s0 = lt {self_} {o} (fun (_ret: bool) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_8 = false} (! bb3) | br1 -> {_8} (! bb2) ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv o} s1 | s1 = -{resolve o}- s2 | s2 = [ &_0 <- self_ ] s3 | s3 = bb6 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv self_} s1 | s1 = -{resolve self_}- s2 | s2 = [ &_0 <- o ] s3 | s3 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_Self_ = Any.any_l () | & self_: t_Self_ = self_ | & o: t_Self_ = o | & _8: bool = Any.any_l () ])
    [ return (result: t_Self_) -> {[@expl:extern_spec_std_cmp_Ord_min_body result type invariant] inv result}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #0] le_log (deep_model result) (deep_model self_)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #1] le_log (deep_model result) (deep_model o)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #2] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #3] lt_log (deep_model self_) (deep_model o) -> result = self_}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #4] le_log (deep_model o) (deep_model self_) -> result = o}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_Ord_clamp_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv (_1: t_Self_)
  
  predicate invariant' [@inline:trivial] (self: t_Self_) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_Self_) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef:
    forall args: tuple [precondition () args]. (let {f0 = self_; f1 = other} = args in inv'0 other /\ inv'0 self_)
      -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate postcondition_once (self: ()) (args: tuple) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = other} = args in res = gt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec gt (self_: t_Self_) (other: t_Self_) (return (x: bool)) = {[@expl:gt requires] precondition () { f0 = self_;
                                                                                                           f1 = other }}
    any [ return (result: bool) -> {postcondition_once () { f0 = self_; f1 = other } result} (! return {result}) ]
  
  predicate resolve (_1: t_Self_)
  
  predicate precondition'0 (self: ()) (args: tuple)
  
  axiom precondition_fndef'0:
    forall args: tuple [precondition'0 () args]. (let {f0 = self_; f1 = other} = args in inv'0 other /\ inv'0 self_)
      -> precondition'0 () args
  
  predicate postcondition_once'0 (self: ()) (args: tuple) (result: bool)
  
  axiom postcondition_fndef'0:
    forall args: tuple, res: bool [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let {f0 = self_; f1 = other} = args in res = lt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec lt (self_: t_Self_) (other: t_Self_) (return (x: bool)) = {[@expl:lt requires] precondition'0 () { f0 = self_;
                                                                                                             f1 = other }}
    any [ return (result: bool) -> {postcondition_once'0 () { f0 = self_; f1 = other } result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_clamp_body (self_: t_Self_) (min: t_Self_) (max: t_Self_) (return (x: t_Self_)) =
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'self_' type invariant] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'min' type invariant] inv min}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'max' type invariant] inv max}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body requires] le_log (deep_model min) (deep_model max)}
    (! bb0
    [ bb0 = s0 [ s0 = gt {self_} {max} (fun (_ret: bool) -> [ &_9 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_9 = false} (! bb3) | br1 -> {_9} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv min} s1
      | s1 = -{resolve min}- s2
      | s2 = {[@expl:type invariant] inv self_} s3
      | s3 = -{resolve self_}- s4
      | s4 = [ &_0 <- max ] s5
      | s5 = bb11 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv max} s1
      | s1 = -{resolve max}- s2
      | s2 = lt {self_} {min} (fun (_ret: bool) -> [ &_12 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_12 = false} (! bb6) | br1 -> {_12} (! bb5) ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv self_} s1 | s1 = -{resolve self_}- s2 | s2 = [ &_0 <- min ] s3 | s3 = bb11 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv min} s1 | s1 = -{resolve min}- s2 | s2 = [ &_0 <- self_ ] s3 | s3 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_Self_ = Any.any_l ()
    | & self_: t_Self_ = self_
    | & min: t_Self_ = min
    | & max: t_Self_ = max
    | & _9: bool = Any.any_l ()
    | & _12: bool = Any.any_l () ])
    [ return (result: t_Self_) -> {[@expl:extern_spec_std_cmp_Ord_clamp_body result type invariant] inv result}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #0] ge_log (deep_model result) (deep_model min)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #1] le_log (deep_model result) (deep_model max)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #2] result = self_ \/ result = min \/ result = max}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #3] if gt_log (deep_model self_) (deep_model max) then
        result = max
      else
        if lt_log (deep_model self_) (deep_model min) then result = min else result = self_
      }
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_max_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type tuple = { f0: t_T; f1: t_T }
  
  predicate inv (_1: t_T)
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = o} = args in inv o
        /\ inv self_) -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = o} = args in (lt_log (deep_model o) (deep_model self_) -> res = self_)
      /\ (le_log (deep_model self_) (deep_model o) -> res = o)
      /\ (res = self_ \/ res = o)
      /\ ge_log (deep_model res) (deep_model o) /\ ge_log (deep_model res) (deep_model self_) /\ inv res)
  
  let rec max (self_: t_T) (o: t_T) (return (x: t_T)) = {[@expl:max requires] precondition () { f0 = self_; f1 = o }}
    any [ return (result: t_T) -> {postcondition_once () { f0 = self_; f1 = o } result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_max_body (v1: t_T) (v2: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_cmp_max_body 'v1' type invariant] inv v1}
    {[@expl:extern_spec_std_cmp_max_body 'v2' type invariant] inv v2}
    (! bb0
    [ bb0 = s0 [ s0 = max {v1} {v2} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb3 ] | bb3 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & v1: t_T = v1 | & v2: t_T = v2 ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_cmp_max_body result type invariant] inv result}
      {[@expl:extern_spec_std_cmp_max_body ensures #0] ge_log (deep_model result) (deep_model v1)}
      {[@expl:extern_spec_std_cmp_max_body ensures #1] ge_log (deep_model result) (deep_model v2)}
      {[@expl:extern_spec_std_cmp_max_body ensures #2] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #3] le_log (deep_model v1) (deep_model v2) -> result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #4] lt_log (deep_model v2) (deep_model v1) -> result = v1}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_std_cmp_min_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type tuple = { f0: t_T; f1: t_T }
  
  predicate inv (_1: t_T)
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {f0 = self_; f1 = o} = args in inv o
        /\ inv self_) -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: tuple, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let {f0 = self_; f1 = o} = args in (le_log (deep_model o) (deep_model self_) -> res = o)
      /\ (lt_log (deep_model self_) (deep_model o) -> res = self_)
      /\ (res = self_ \/ res = o)
      /\ le_log (deep_model res) (deep_model o) /\ le_log (deep_model res) (deep_model self_) /\ inv res)
  
  let rec min (self_: t_T) (o: t_T) (return (x: t_T)) = {[@expl:min requires] precondition () { f0 = self_; f1 = o }}
    any [ return (result: t_T) -> {postcondition_once () { f0 = self_; f1 = o } result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_min_body (v1: t_T) (v2: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_cmp_min_body 'v1' type invariant] inv v1}
    {[@expl:extern_spec_std_cmp_min_body 'v2' type invariant] inv v2}
    (! bb0
    [ bb0 = s0 [ s0 = min {v1} {v2} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb3 ] | bb3 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & v1: t_T = v1 | & v2: t_T = v2 ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_cmp_min_body result type invariant] inv result}
      {[@expl:extern_spec_std_cmp_min_body ensures #0] le_log (deep_model result) (deep_model v1)}
      {[@expl:extern_spec_std_cmp_min_body ensures #1] le_log (deep_model result) (deep_model v2)}
      {[@expl:extern_spec_std_cmp_min_body ensures #2] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_min_body ensures #3] lt_log (deep_model v1) (deep_model v2) -> result = v1}
      {[@expl:extern_spec_std_cmp_min_body ensures #4] le_log (deep_model v2) (deep_model v1) -> result = v2}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i8_i8_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int8.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_lt_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int8.t = self_ | & other: Int8.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i8_i8_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i8_i8_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int8.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_le_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int8.t = self_ | & other: Int8.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i8_i8_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i8_i8_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int8.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_gt_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int8.t = self_ | & other: Int8.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i8_i8_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i8_i8_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int8.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_ge_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int8.t = self_ | & other: Int8.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i8_i8_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i16_i16_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int16.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_lt_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int16.t = self_ | & other: Int16.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i16_i16_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i16_i16_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int16.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_le_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int16.t = self_ | & other: Int16.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i16_i16_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i16_i16_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int16.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_gt_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int16.t = self_ | & other: Int16.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i16_i16_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i16_i16_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int16.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_ge_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int16.t = self_ | & other: Int16.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i16_i16_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i32_i32_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int32.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_lt_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int32.t = self_ | & other: Int32.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i32_i32_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i32_i32_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int32.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_le_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int32.t = self_ | & other: Int32.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i32_i32_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i32_i32_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int32.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_gt_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int32.t = self_ | & other: Int32.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i32_i32_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i32_i32_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int32.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_ge_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int32.t = self_ | & other: Int32.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i32_i32_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i64_i64_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_lt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int64.t = self_ | & other: Int64.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i64_i64_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i64_i64_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_le_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int64.t = self_ | & other: Int64.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i64_i64_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i64_i64_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_gt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int64.t = self_ | & other: Int64.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i64_i64_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i64_i64_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_ge_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int64.t = self_ | & other: Int64.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i64_i64_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i128_i128_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int128.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_lt_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i128_i128_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i128_i128_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int128.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_le_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i128_i128_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i128_i128_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int128.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_gt_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i128_i128_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_i128_i128_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int128.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_ge_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i128_i128_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_isize_isize_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_lt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int64.t = self_ | & other: Int64.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_isize_isize_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_isize_isize_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_le_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int64.t = self_ | & other: Int64.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_isize_isize_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_isize_isize_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_gt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int64.t = self_ | & other: Int64.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_isize_isize_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_isize_isize_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: Int64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_ge_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: Int64.t = self_ | & other: Int64.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_isize_isize_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u8_u8_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt8.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_lt_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: UInt8.t = self_ | & other: UInt8.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u8_u8_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u8_u8_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt8.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_le_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: UInt8.t = self_ | & other: UInt8.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u8_u8_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u8_u8_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt8.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_gt_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: UInt8.t = self_ | & other: UInt8.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u8_u8_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u8_u8_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt8.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_ge_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self_: UInt8.t = self_ | & other: UInt8.t = other | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u8_u8_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u16_u16_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt16.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_lt_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u16_u16_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u16_u16_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt16.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_le_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u16_u16_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u16_u16_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt16.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_gt_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u16_u16_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u16_u16_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt16.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_ge_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u16_u16_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u32_u32_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt32.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_lt_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u32_u32_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u32_u32_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt32.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_le_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u32_u32_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u32_u32_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt32.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_gt_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u32_u32_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u32_u32_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt32.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_ge_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u32_u32_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u64_u64_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_lt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u64_u64_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u64_u64_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_le_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u64_u64_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u64_u64_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_gt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u64_u64_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u64_u64_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_ge_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u64_u64_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u128_u128_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt128.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_lt_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u128_u128_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u128_u128_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt128.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_le_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u128_u128_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u128_u128_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt128.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_gt_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u128_u128_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_u128_u128_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt128.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_ge_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u128_u128_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_usize_usize_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_lt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_usize_usize_lt_body ensures] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_usize_usize_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_le_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_usize_usize_le_body ensures] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_usize_usize_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_gt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_usize_usize_gt_body ensures] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__extern_spec_PartialOrd_usize_usize_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type t_Option = C_None | C_Some t_Ordering
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: int) : ()
  
  axiom refl_spec: forall x: int. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model
  
  let rec partial_cmp (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option)) = any
    [ return (result: t_Option) -> {result = C_Some (cmp_log (deep_model self_) (deep_model rhs))} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Ordering)) = any
    [ good (field_0: t_Ordering) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  function deep_model'0 [@inline:trivial] (self: UInt64.t) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_ge_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_} {other} (fun (_ret: t_Option) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = C_Some x0} (! bb3) ]
    | bb3 = v_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_usize_usize_ge_body ensures] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return {result}) ]
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__cmp_le_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate le_log'0 (self: t_Reverse) (o: t_Reverse) = cmp_log'0 self o <> C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  constant y : t_Reverse
  
  function cmp_le_log'0 (x: t_Reverse) (y: t_Reverse) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__cmp_lt_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate lt_log'0 (self: t_Reverse) (o: t_Reverse) = cmp_log'0 self o = C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  constant y : t_Reverse
  
  function cmp_lt_log'0 (x: t_Reverse) (y: t_Reverse) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__cmp_ge_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate ge_log'0 (self: t_Reverse) (o: t_Reverse) = cmp_log'0 self o <> C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  constant y : t_Reverse
  
  function cmp_ge_log'0 (x: t_Reverse) (y: t_Reverse) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__cmp_gt_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate gt_log'0 (self: t_Reverse) (o: t_Reverse) = cmp_log'0 self o = C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  constant y : t_Reverse
  
  function cmp_gt_log'0 (x: t_Reverse) (y: t_Reverse) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__refl (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  function refl'0 (x: t_Reverse) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__trans (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  constant y : t_Reverse
  
  constant z : t_Reverse
  
  constant o : t_Ordering
  
  function trans'0 (x: t_Reverse) (y: t_Reverse) (z: t_Reverse) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log'0 x y = o -> cmp_log'0 y z = o -> ([@expl:trans ensures] cmp_log'0 x z = o)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__antisym1 (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  constant y : t_Reverse
  
  function antisym1'0 (x: t_Reverse) (y: t_Reverse) : ()
  
  goal vc_antisym1: cmp_log'0 x y = C_Less -> ([@expl:antisym1 ensures] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__antisym2 (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  constant y : t_Reverse
  
  function antisym2'0 (x: t_Reverse) (y: t_Reverse) : ()
  
  goal vc_antisym2: cmp_log'0 x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__eq_cmp (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse
  
  constant y : t_Reverse
  
  function eq_cmp'0 (x: t_Reverse) (y: t_Reverse) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__std__deque__qyi7285194934641240501__produces_refl (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter
  
  function produces_refl (self: t_Iter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__deque__qyi7285194934641240501__produces_trans (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter
  
  function produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__hint__extern_spec_std_hint_assert_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_assert_unchecked_body (cond: bool) (return (x: ())) =
    {[@expl:extern_spec_std_hint_assert_unchecked_body requires] cond}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_creusot_contracts__std__hint__extern_spec_std_hint_black_box_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_black_box_body (dummy: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_hint_black_box_body 'dummy' type invariant] inv dummy}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- dummy ] s1 | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & dummy: t_T = dummy ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_hint_black_box_body result type invariant] inv result}
      {[@expl:extern_spec_std_hint_black_box_body ensures] result = dummy}
      (! return {result}) ]
end
module M_creusot_contracts__std__hint__extern_spec_std_hint_spin_loop_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_spin_loop_body (return (x: ())) =
    {[@expl:extern_spec_std_hint_spin_loop_body requires] true}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:extern_spec_std_hint_spin_loop_body ensures] true} (! return {result}) ]
end
module M_creusot_contracts__std__hint__extern_spec_std_hint_unreachable_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  predicate inv [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_unreachable_unchecked_body (return (x: ())) =
    {[@expl:extern_spec_std_hint_unreachable_unchecked_body requires] false}
    (! bb0
    [ bb0 = {false} any ])
    [ return (result: ()) -> {[@expl:extern_spec_std_hint_unreachable_unchecked_body result type invariant] inv result}
      (! return {result}) ]
end
module M_creusot_contracts__std__hint__extern_spec_std_hint_must_use_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_must_use_body (value: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_hint_must_use_body 'value' type invariant] inv value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- value ] s1 | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & value: t_T = value ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_hint_must_use_body result type invariant] inv result}
      {[@expl:extern_spec_std_hint_must_use_body ensures] result = value}
      (! return {result}) ]
end
module M_creusot_contracts__std__intrinsics__extern_spec_core_intrinsics_assume_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_intrinsics_assume_body (b: bool) (return (x: ())) =
    {[@expl:extern_spec_core_intrinsics_assume_body requires] b}
    (! bb0
    [ bb0 = any [ br0 -> {b = false} (! bb1) | br1 -> {b} (! bb2) ] | bb2 = return {_0} | bb1 = {false} any ]
    [ & _0: () = Any.any_l () | & b: bool = b ]) [ return (result: ()) -> (! return {result}) ]
end
module M_creusot_contracts__std__io__extern_spec_std_ioqy95z_print_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Arguments
  
  predicate inv (_1: t_Arguments)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_ioqy95z_print_body (args: t_Arguments) (return (x: ())) =
    {[@expl:extern_spec_std_io__print_body 'args' type invariant] inv args}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:extern_spec_std_io__print_body ensures] true} (! return {result}) ]
end
module M_creusot_contracts__std__io__extern_spec_std_ioqy95z_eprint_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Arguments
  
  predicate inv (_1: t_Arguments)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_ioqy95z_eprint_body (args: t_Arguments) (return (x: ())) =
    {[@expl:extern_spec_std_io__eprint_body 'args' type invariant] inv args}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:extern_spec_std_io__eprint_body ensures] true} (! return {result}) ]
end
module M_creusot_contracts__std__iter__cloned__qyi12959622540969022492__produces_refl (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Cloned
  
  type t_T
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_T) self
  
  function iter (self: t_Cloned) : t_I
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate produces'0 (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Cloned
  
  function produces_refl'0 (self: t_Cloned) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__cloned__qyi12959622540969022492__produces_trans (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Cloned
  
  type t_T
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_T) self
  
  function iter (self: t_Cloned) : t_I
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate produces'0 (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Cloned
  
  constant ab : Seq.seq t_T
  
  constant b : t_Cloned
  
  constant bc : Seq.seq t_T
  
  constant c : t_Cloned
  
  function produces_trans'0 (a: t_Cloned) (ab: Seq.seq t_T) (b: t_Cloned) (bc: Seq.seq t_T) (c: t_Cloned) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__copied__qyi13437018464510937253__produces_refl (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Copied
  
  type t_T
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_T) self
  
  function iter (self: t_Copied) : t_I
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Copied
  
  function produces_refl'0 (self: t_Copied) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__copied__qyi13437018464510937253__produces_trans (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Copied
  
  type t_T
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_T) self
  
  function iter (self: t_Copied) : t_I
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Copied
  
  constant ab : Seq.seq t_T
  
  constant b : t_Copied
  
  constant bc : Seq.seq t_T
  
  constant c : t_Copied
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__empty__qyi10224556657375706108__produces_refl (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty
  
  type t_T
  
  predicate produces (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Empty
  
  function produces_refl (self: t_Empty) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__empty__qyi10224556657375706108__produces_trans (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty
  
  type t_T
  
  predicate produces (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Empty
  
  constant ab : Seq.seq t_T
  
  constant b : t_Empty
  
  constant bc : Seq.seq t_T
  
  constant c : t_Empty
  
  function produces_trans (a: t_Empty) (ab: Seq.seq t_T) (b: t_Empty) (bc: Seq.seq t_T) (c: t_Empty) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__enumerate__qyi3278642960586057751__invariant (* <std::iter::Enumerate<I> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Enumerate
  
  type t_I
  
  predicate inv (_1: t_I)
  
  function iter (self: t_Enumerate) : t_I
  
  type t_Item
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function n (self: t_Enumerate) : UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed (self: MutBorrow.t t_I)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Enumerate
  
  predicate invariant' (self: t_Enumerate)
  
  goal vc_invariant: if inv (iter self) then
      if forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
        -> UInt64.t'int (n self) + Seq.length s < UInt64.t'int const_MAX then
        [@expl:invariant ensures] (forall i: MutBorrow.t t_I. completed i
            -> produces i.current (Seq.empty: Seq.seq t_Item) i.final) -> inv (iter self)
      else
        [@expl:invariant ensures] false -> inv (iter self)
    
    else
      [@expl:invariant ensures] false -> inv (iter self)

end
module M_creusot_contracts__std__iter__enumerate__qyi17760969447503171583__produces_refl (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Enumerate
  
  type t_Item
  
  type tuple = { f0: UInt64.t; f1: t_Item }
  
  function n (self: t_Enumerate) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Enumerate) : t_I
  
  predicate produces'0 (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate) =
    Seq.length visited = UInt64.t'int (n o) - UInt64.t'int (n self)
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n self) + i /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Enumerate
  
  function produces_refl'0 (self: t_Enumerate) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__iter__enumerate__qyi17760969447503171583__produces_trans (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Enumerate
  
  type t_Item
  
  type tuple = { f0: UInt64.t; f1: t_Item }
  
  function n (self: t_Enumerate) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Enumerate) : t_I
  
  predicate produces'0 (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate) =
    Seq.length visited = UInt64.t'int (n o) - UInt64.t'int (n self)
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n self) + i /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Enumerate
  
  constant ab : Seq.seq tuple
  
  constant b : t_Enumerate
  
  constant bc : Seq.seq tuple
  
  constant c : t_Enumerate
  
  function produces_trans'0 (a: t_Enumerate) (ab: Seq.seq tuple) (b: t_Enumerate) (bc: Seq.seq tuple) (c: t_Enumerate) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__filter__qyi14352509440997797406__invariant (* <std::iter::Filter<I, F> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Filter
  
  type t_I
  
  predicate inv (_1: t_I)
  
  function iter (self: t_Filter) : t_I
  
  type t_F
  
  predicate inv'0 (_1: t_F)
  
  function func (self: t_Filter) : t_F
  
  type t_Item
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (_1: t_F) = forall f: t_F, i: t_Item. precondition f i
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (_1: t_F) = forall f: t_F, g: t_F. hist_inv f g -> f = g
  
  predicate precise (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut f1 i f2 true /\ postcondition_mut f1 i f2 false)
  
  predicate private_invariant (f: t_Filter) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Filter
  
  predicate invariant' (self: t_Filter)
  
  goal vc_invariant: if inv (iter self) then
      if inv'0 (func self) then
        [@expl:invariant ensures] private_invariant self -> inv (iter self) /\ inv'0 (func self)
      else
        [@expl:invariant ensures] false -> inv (iter self) /\ inv'0 (func self)
    
    else
      [@expl:invariant ensures] false -> inv (iter self) /\ inv'0 (func self)

end
module M_creusot_contracts__std__iter__filter__qyi990465010469908032__produces_refl (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Filter
  
  type t_Item
  
  type t_F
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (_1: t_F) = forall f: t_F, i: t_Item. precondition f i
  
  function func (self: t_Filter) : t_F
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (_1: t_F) = forall f: t_F, g: t_F. hist_inv f g -> f = g
  
  predicate precise (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut f1 i f2 true /\ postcondition_mut f1 i f2 false)
  
  predicate private_invariant (f: t_Filter) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Filter) : t_I
  
  predicate produces'0 (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter) =
    private_invariant self
    -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Filter
  
  function produces_refl'0 (self: t_Filter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__filter__qyi990465010469908032__produces_trans (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Filter
  
  type t_Item
  
  type t_F
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (_1: t_F) = forall f: t_F, i: t_Item. precondition f i
  
  function func (self: t_Filter) : t_F
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (_1: t_F) = forall f: t_F, g: t_F. hist_inv f g -> f = g
  
  predicate precise (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut f1 i f2 true /\ postcondition_mut f1 i f2 false)
  
  predicate private_invariant (f: t_Filter) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Filter) : t_I
  
  predicate produces'0 (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter) =
    private_invariant self
    -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Filter
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Filter
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Filter
  
  function produces_trans'0 (a: t_Filter) (ab: Seq.seq t_Item) (b: t_Filter) (bc: Seq.seq t_Item) (c: t_Filter) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__filter_map__qyi11148334412739605610__produces_refl (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FilterMap
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (f: t_F) = forall i: t_Item. precondition f i
  
  function func (self: t_FilterMap) : t_F
  
  type t_Option = C_None | C_Some t_B
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_Option)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (f: t_F) = forall g: t_F. hist_inv f g -> f = g
  
  predicate precise (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
      /\ postcondition_mut f1 i f2 (C_None))
  
  predicate private_invariant (f: t_FilterMap) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_FilterMap) : t_I
  
  predicate produces'0 (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap) =
    private_invariant self
    -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FilterMap
  
  function produces_refl'0 (self: t_FilterMap) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__std__iter__filter_map__qyi11148334412739605610__produces_trans (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FilterMap
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (f: t_F) = forall i: t_Item. precondition f i
  
  function func (self: t_FilterMap) : t_F
  
  type t_Option = C_None | C_Some t_B
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_Option)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (f: t_F) = forall g: t_F. hist_inv f g -> f = g
  
  predicate precise (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
      /\ postcondition_mut f1 i f2 (C_None))
  
  predicate private_invariant (f: t_FilterMap) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_FilterMap) : t_I
  
  predicate produces'0 (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap) =
    private_invariant self
    -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FilterMap
  
  constant ab : Seq.seq t_B
  
  constant b : t_FilterMap
  
  constant bc : Seq.seq t_B
  
  constant c : t_FilterMap
  
  function produces_trans'0 (a: t_FilterMap) (ab: Seq.seq t_B) (b: t_FilterMap) (bc: Seq.seq t_B) (c: t_FilterMap) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__fuse__qyi3534357438560453877__produces_refl (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse
  
  type t_Item
  
  type t_I
  
  type t_Option = C_None | C_Some t_I
  
  function view (self: t_Fuse) : t_Option
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse) =
    match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Fuse
  
  function produces_refl'0 (self: t_Fuse) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__fuse__qyi3534357438560453877__produces_trans (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse
  
  type t_Item
  
  type t_I
  
  type t_Option = C_None | C_Some t_I
  
  function view (self: t_Fuse) : t_Option
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse) =
    match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Fuse
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Fuse
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Fuse
  
  function produces_trans'0 (a: t_Fuse) (ab: Seq.seq t_Item) (b: t_Fuse) (bc: Seq.seq t_Item) (c: t_Fuse) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__fuse__qyi12953744680688287360__is_fused (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_Fuse
  
  type t_Item
  
  type t_I
  
  type t_Option = C_None | C_Some t_I
  
  function view (self: t_Fuse) : t_Option
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse) =
    match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  function produces_trans'0 (a: t_Fuse) (ab: Seq.seq t_Item) (b: t_Fuse) (bc: Seq.seq t_Item) (c: t_Fuse) : () = ()
  
  axiom produces_trans_spec'0:
    forall a: t_Fuse, ab: Seq.seq t_Item, b: t_Fuse, bc: Seq.seq t_Item, c: t_Fuse. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Fuse) : () = ()
  
  axiom produces_refl_spec'0: forall self: t_Fuse. produces'0 self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed (self: MutBorrow.t t_I)
  
  predicate completed'0 (self: MutBorrow.t t_Fuse) =
    (view self.current = C_None
      \/ (exists it: MutBorrow.t t_I. completed it /\ view self.current = C_Some (it.current)))
    /\ view self.final = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_Fuse
  
  constant steps : Seq.seq t_Item
  
  constant next : t_Fuse
  
  function is_fused (self: MutBorrow.t t_Fuse) (steps: Seq.seq t_Item) (next: t_Fuse) : ()
  
  goal vc_is_fused: completed'0 self
    -> produces'0 self.final steps next -> ([@expl:is_fused ensures] steps = (Seq.empty: Seq.seq t_Item))
end
module M_creusot_contracts__std__iter__map__qyi7764956636839637908__invariant (* <std::iter::Map<I, F> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_Map
  
  type t_I
  
  predicate inv (_1: t_I)
  
  function iter (self: t_Map) : t_I
  
  type t_F
  
  predicate inv'0 (_1: t_F)
  
  function func (self: t_Map) : t_F
  
  type t_Item
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed (self: MutBorrow.t t_I)
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate next_precondition (iter'0: t_I) (func'0: t_F) =
    forall e: t_Item, i: t_I [produces iter'0 (Seq.singleton e) i]. produces iter'0 (Seq.singleton e) i
      -> precondition func'0 e
  
  type t_B
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate preservation (iter'0: t_I) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I [produces iter'0 (Seq.snoc (Seq.snoc s e1) e2) i, postcondition_mut f.current e1 f.final b]. hist_inv func'0 f.current
      -> produces iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current e1 -> postcondition_mut f.current e1 f.final b -> precondition f.final e2
  
  predicate reinitialize =
    forall iter'0: MutBorrow.t t_I, func'0: t_F. completed iter'0
      -> next_precondition iter'0.final func'0 /\ preservation iter'0.final func'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map
  
  predicate invariant' (self: t_Map)
  
  goal vc_invariant: if inv (iter self) then
      if inv'0 (func self) then
        if reinitialize then
          if preservation (iter self) (func self) then
            [@expl:invariant ensures] next_precondition (iter self) (func self) -> inv (iter self) /\ inv'0 (func self)
          else
            [@expl:invariant ensures] false -> inv (iter self) /\ inv'0 (func self)
        
        else
          [@expl:invariant ensures] false -> inv (iter self) /\ inv'0 (func self)
      
      else
        [@expl:invariant ensures] false -> inv (iter self) /\ inv'0 (func self)
    
    else
      [@expl:invariant ensures] false -> inv (iter self) /\ inv'0 (func self)

end
module M_creusot_contracts__std__iter__map__qyi306403796899090344__produces_refl (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Map
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function func (self: t_Map) : t_F
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Map) : t_I
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map) =
    hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
        /\ produces (iter self) s (iter succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func self = func succ
          else
            (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv (func self) (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current (Seq.get s i)
          /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map
  
  function produces_refl'0 (self: t_Map) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__std__iter__map__qyi306403796899090344__produces_trans (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Map
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function func (self: t_Map) : t_F
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Map) : t_I
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map) =
    hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
        /\ produces (iter self) s (iter succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func self = func succ
          else
            (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv (func self) (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current (Seq.get s i)
          /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Map
  
  constant ab : Seq.seq t_B
  
  constant b : t_Map
  
  constant bc : Seq.seq t_B
  
  constant c : t_Map
  
  function produces_trans'0 (a: t_Map) (ab: Seq.seq t_B) (b: t_Map) (bc: Seq.seq t_B) (c: t_Map) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__map_inv__qyi10280853954906842925__produces_refl (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv = { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current { f0 = Seq.get s i;
                                                   f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv
  
  function produces_refl'0 (self: t_MapInv) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__std__iter__map_inv__qyi10280853954906842925__produces_trans (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv = { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current { f0 = Seq.get s i;
                                                   f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_MapInv
  
  constant ab : Seq.seq t_B
  
  constant b : t_MapInv
  
  constant bc : Seq.seq t_B
  
  constant c : t_MapInv
  
  function produces_trans'0 (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__map_inv__qyi8002351551305542163__next (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv = { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  predicate inv (_1: t_I)
  
  type t_Option = C_None | C_Some t_Item
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_I) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_I) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate precondition (self: ()) (args: MutBorrow.t t_I)
  
  axiom precondition_fndef: forall args: MutBorrow.t t_I [precondition () args]. (let self_ = args in inv'0 self_)
      -> precondition () args
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed (self: MutBorrow.t t_I)
  
  predicate inv'1 (_1: t_Item)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'1 a_0
        end
  
  predicate postcondition_once (self: ()) (args: MutBorrow.t t_I) (result: t_Option)
  
  axiom postcondition_fndef:
    forall args: MutBorrow.t t_I, res: t_Option [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in match res with
          | C_None -> completed self_
          | C_Some v -> produces self_.current (Seq.singleton v) self_.final
          end
      /\ inv'2 res)
  
  let rec next (self_: MutBorrow.t t_I) (return (x: t_Option)) = {[@expl:next requires] precondition () self_}
    any [ return (result: t_Option) -> {postcondition_once () self_ result} (! return {result}) ]
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Item)) = any
    [ good (field_0: t_Item) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Item [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition'0 (self: t_F) (args: tuple)
  
  predicate inv'3 (_1: t_F)
  
  type t_B
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_F) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'4 [@inline:trivial] (_1: MutBorrow.t t_F) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'4
  
  predicate inv'5 [@inline:trivial] (_1: tuple) = inv'1 _1.f0
  
  meta "rewrite_def" predicate inv'5
  
  predicate inv'6 (_1: t_B)
  
  predicate postcondition_once'0 (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once'0 self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  let rec call_mut (self_: MutBorrow.t t_F) (arg: tuple) (return (x: t_B)) =
    {[@expl:call_mut 'self_' type invariant] inv'4 self_}
    {[@expl:call_mut 'arg' type invariant] inv'5 arg}
    {[@expl:call_mut requires] precondition'0 self_.current arg}
    any
    [ return (result: t_B) -> {inv'6 result}
      {postcondition_mut self_.current arg self_.final result}
      (! return {result}) ]
  
  predicate next_precondition (iter: t_I) (func: t_F) (produced: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. produces iter (Seq.singleton e) i -> precondition'0 func { f0 = e; f1 = produced }
  
  predicate preservation (iter: t_I) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition'0 f.current { f0 = e1; f1 = s }
      -> postcondition_mut f.current { f0 = e1; f1 = s } f.final b
      -> precondition'0 f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize =
    forall iter: MutBorrow.t t_I, func: t_F. completed iter
      -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv (iter: t_I) (func: t_F) (produced: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition'0 f.current { f0 = e1; f1 = Seq.(++) produced s }
      -> postcondition_mut f.current { f0 = e1; f1 = Seq.(++) produced s } f.final b
      -> precondition'0 f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec: forall iter: t_I, func: t_F, produced: Seq.seq t_Item. produced
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant''1 (self: t_MapInv) =
    reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  function produces_one_invariant (self: t_MapInv) (e: t_Item) (r: t_B) (f: MutBorrow.t t_F) (iter: t_I) : () = ()
  
  axiom produces_one_invariant_spec:
    forall self: t_MapInv, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter: t_I. invariant''1 self
      -> produces self.t_MapInv__iter (Seq.singleton e) iter
      -> f.current = self.t_MapInv__func
      -> postcondition_mut f.current { f0 = e; f1 = self.t_MapInv__produced } f.final r
      -> preservation_inv iter f.final (Seq.snoc self.t_MapInv__produced e)
  
  axiom produces_one_invariant_spec'0:
    forall self: t_MapInv, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter: t_I. invariant''1 self
      -> produces self.t_MapInv__iter (Seq.singleton e) iter
      -> f.current = self.t_MapInv__func
      -> postcondition_mut f.current { f0 = e; f1 = self.t_MapInv__produced } f.final r
      -> next_precondition iter f.final (Seq.snoc self.t_MapInv__produced e)
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition'0 (Seq.get fs i).current { f0 = Seq.get s i;
                                                     f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  function produces_trans'0 (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : () = ()
  
  axiom produces_trans_spec'0:
    forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_MapInv) : () = ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. produces'0 self (Seq.empty: Seq.seq t_B) self
  
  predicate produces_one (self: t_MapInv) (visited: t_B) (succ: t_MapInv) =
    exists f: MutBorrow.t t_F, e: t_Item. f.current = self.t_MapInv__func
      /\ f.final = succ.t_MapInv__func
      /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
      /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
      /\ precondition'0 f.current { f0 = e; f1 = self.t_MapInv__produced }
      /\ postcondition_mut f.current { f0 = e; f1 = self.t_MapInv__produced } f.final visited
  
  axiom produces_one_spec: forall self: t_MapInv, visited: t_B, succ: t_MapInv. produces_one self visited succ
      = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'7 (_1: t_MapInv)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_MapInv [inv'7 x]. inv'7 x
      = (invariant''1 x /\ inv x.t_MapInv__iter /\ inv'3 x.t_MapInv__func)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_MapInv) = inv'7 self.current /\ inv'7 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 [@inline:trivial] (_1: MutBorrow.t t_MapInv) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'8
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_MapInv) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_B
  
  predicate inv'9 (_1: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'9 x]. inv'9 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  predicate completed'0 (self: MutBorrow.t t_MapInv) =
    self.final.t_MapInv__produced = (Seq.empty: Seq.seq t_Item)
    /\ completed (MutBorrow.borrow_logic self.current.t_MapInv__iter self.final.t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ self.current.t_MapInv__func = self.final.t_MapInv__func
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next'0 (self: MutBorrow.t t_MapInv) (return (x: t_Option'0)) = {[@expl:next 'self' type invariant] inv'8 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self.current ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv self.current.t_MapInv__iter}
        MutBorrow.borrow_final <t_I> {self.current.t_MapInv__iter} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_I) ->
            [ &_6 <- _ret ] -{inv _ret.final}-
            [ &self <- { self with current = { self.current with t_MapInv__iter = _ret.final } } ] s1)
      | s1 = next {_6} (fun (_ret: t_Option) -> [ &_5 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_5 = C_None} (! bb5) | br1 (x0: t_Item) -> {_5 = C_Some x0} (! bb6) ]
    | bb6 = s0
      [ s0 = v_Some {_5} (fun (r0: t_Item) -> [ &v <- r0 ] s1)
      | s1 = {[@expl:assertion] precondition'0 self.current.t_MapInv__func { f0 = v;
                                                                             f1 = self.current.t_MapInv__produced }}
        s2
      | s2 = [ &produced <- Seq.snoc self.current.t_MapInv__produced v ] s3
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'3 self.current.t_MapInv__func}
        MutBorrow.borrow_final <t_F> {self.current.t_MapInv__func} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_F) ->
            [ &_14 <- _ret ] -{inv'3 _ret.final}-
            [ &self <- { self with current = { self.current with t_MapInv__func = _ret.final } } ] s1)
      | s1 = [ &_15 <- { f0 = v; f1 = self.current.t_MapInv__produced } ] s2
      | s2 = call_mut {_14} {_15} (fun (_ret: t_B) -> [ &r <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0
      [ s0 = [ &self <- { self with current = { self.current with t_MapInv__produced = produced } } ] s1
      | s1 = [ &_19 <- () ] s2
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {[@expl:assertion] produces_one old_self r self.current} s1
      | s1 = {[@expl:type invariant] inv'8 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 = [ &_0 <- C_Some'0 r ] s4
      | s4 = bb16 ]
    | bb5 = s0 [ s0 = [ &_24 <- Seq.empty: Seq.seq t_Item ] s1 | s1 = bb14 ]
    | bb14 = s0
      [ s0 = [ &self <- { self with current = { self.current with t_MapInv__produced = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv'8 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 = [ &_0 <- C_None'0 ] s4
      | s4 = bb16 ]
    | bb16 = return {_0} ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self: MutBorrow.t t_MapInv = self
    | & old_self: t_MapInv = Any.any_l ()
    | & _5: t_Option = Any.any_l ()
    | & _6: MutBorrow.t t_I = Any.any_l ()
    | & v: t_Item = Any.any_l ()
    | & produced: Seq.seq t_Item = Any.any_l ()
    | & r: t_B = Any.any_l ()
    | & _14: MutBorrow.t t_F = Any.any_l ()
    | & _15: tuple = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _24: Seq.seq t_Item = Any.any_l () ])
    [ return (result: t_Option'0) -> {[@expl:next result type invariant] inv'9 result}
      {[@expl:next ensures] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces_one self.current v self.final
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__iter__map_inv__qyi6396809843712938673__preservation_inv (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  type t_B
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate preservation (iter: t_I) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current { f0 = e1; f1 = s }
      -> postcondition_mut f.current { f0 = e1; f1 = s } f.final b
      -> precondition f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant iter : t_I
  
  constant func : t_F
  
  constant produced : Seq.seq t_Item
  
  predicate preservation_inv (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
  goal vc_preservation_inv: [@expl:preservation_inv ensures] produced = (Seq.empty: Seq.seq t_Item)
    -> (forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
        -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
        -> precondition f.current { f0 = e1; f1 = Seq.(++) produced s }
        -> postcondition_mut f.current { f0 = e1; f1 = Seq.(++) produced s } f.final b
        -> precondition f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced s) e1 })
    = preservation iter func
end
module M_creusot_contracts__std__iter__map_inv__qyi6396809843712938673__produces_one_invariant (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv = { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed (self: MutBorrow.t t_I)
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate next_precondition (iter: t_I) (func: t_F) (produced: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. produces iter (Seq.singleton e) i -> precondition func { f0 = e; f1 = produced }
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate preservation (iter: t_I) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current { f0 = e1; f1 = s }
      -> postcondition_mut f.current { f0 = e1; f1 = s } f.final b
      -> precondition f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize =
    forall iter: MutBorrow.t t_I, func: t_F. completed iter
      -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv (iter: t_I) (func: t_F) (produced: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current { f0 = e1; f1 = Seq.(++) produced s }
      -> postcondition_mut f.current { f0 = e1; f1 = Seq.(++) produced s } f.final b
      -> precondition f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec: forall iter: t_I, func: t_F, produced: Seq.seq t_Item. produced
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' (self: t_MapInv) =
    reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  function push_front [@inline:trivial] (self: Seq.seq t_Item) (x: t_Item) : Seq.seq t_Item = Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv
  
  constant e : t_Item
  
  constant r : t_B
  
  constant f : MutBorrow.t t_F
  
  constant iter : t_I
  
  function produces_one_invariant (self: t_MapInv) (e: t_Item) (r: t_B) (f: MutBorrow.t t_F) (iter: t_I) : ()
  
  goal vc_produces_one_invariant: invariant' self
    -> produces self.t_MapInv__iter (Seq.singleton e) iter
    -> f.current = self.t_MapInv__func
    -> postcondition_mut f.current { f0 = e; f1 = self.t_MapInv__produced } f.final r
    -> (forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, i: t_I. produces iter (Seq.snoc (Seq.snoc s e1) e2) i
        -> produces self.t_MapInv__iter (Seq.snoc (Seq.snoc (push_front s e) e1) e2) i)
    && ([@expl:produces_one_invariant ensures #0] preservation_inv iter f.final (Seq.snoc self.t_MapInv__produced e))
    && ([@expl:produces_one_invariant ensures #1] next_precondition iter f.final (Seq.snoc self.t_MapInv__produced e))
end
module M_creusot_contracts__std__iter__map_inv__qyi6396809843712938673__produces_one (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv = { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current { f0 = Seq.get s i;
                                                   f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  function produces_trans'0 (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : () = ()
  
  axiom produces_trans_spec'0:
    forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_MapInv) : () = ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. produces'0 self (Seq.empty: Seq.seq t_B) self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv
  
  constant visited : t_B
  
  constant succ : t_MapInv
  
  predicate produces_one (self: t_MapInv) (visited: t_B) (succ: t_MapInv)
  
  goal vc_produces_one: [@expl:produces_one ensures] (exists f: MutBorrow.t t_F, e: t_Item. f.current
          = self.t_MapInv__func
        /\ f.final = succ.t_MapInv__func
        /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
        /\ precondition f.current { f0 = e; f1 = self.t_MapInv__produced }
        /\ postcondition_mut f.current { f0 = e; f1 = self.t_MapInv__produced } f.final visited)
    = produces'0 self (Seq.singleton visited) succ
end
module M_creusot_contracts__std__iter__once__qyi403149096834806456__produces_refl (* <std::iter::Once<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_Once) : t_Option
  
  predicate produces (self: t_Once) (visited: Seq.seq t_T) (o: t_Once) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Once
  
  function produces_refl (self: t_Once) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__once__qyi403149096834806456__produces_trans (* <std::iter::Once<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_Once) : t_Option
  
  predicate produces (self: t_Once) (visited: Seq.seq t_T) (o: t_Once) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Once
  
  constant ab : Seq.seq t_T
  
  constant b : t_Once
  
  constant bc : Seq.seq t_T
  
  constant c : t_Once
  
  function produces_trans (a: t_Once) (ab: Seq.seq t_T) (b: t_Once) (bc: Seq.seq t_T) (c: t_Once) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__range__qyi990280207493253415__produces_refl (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range = { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model (self: t_Idx) : int
  
  predicate produces (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Range
  
  function produces_refl (self: t_Range) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__std__iter__range__qyi990280207493253415__produces_trans (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range = { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model (self: t_Idx) : int
  
  predicate produces (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Range
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_Range
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_Range
  
  function produces_trans (a: t_Range) (ab: Seq.seq t_Idx) (b: t_Range) (bc: Seq.seq t_Idx) (c: t_Range) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__range__qyi9685214752154132849__produces_back_refl (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range = { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model (self: t_Idx) : int
  
  predicate produces_back (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range) =
    self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Range
  
  function produces_back_refl (self: t_Range) : ()
  
  goal vc_produces_back_refl: [@expl:produces_back_refl ensures] produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__std__iter__range__qyi9685214752154132849__produces_back_trans (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range = { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model (self: t_Idx) : int
  
  predicate produces_back (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range) =
    self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Range
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_Range
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_Range
  
  function produces_back_trans (a: t_Range) (ab: Seq.seq t_Idx) (b: t_Range) (bc: Seq.seq t_Idx) (c: t_Range) : ()
  
  goal vc_produces_back_trans: produces_back a ab b
    -> produces_back b bc c -> ([@expl:produces_back_trans ensures] produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__range__range_inclusive_len
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant r : t_RangeInclusive
  
  function range_inclusive_len (r: t_RangeInclusive) : int
  
  goal vc_range_inclusive_len: not is_empty_log r -> deep_model (start_log r) <= deep_model (end_log r)
    -> (if is_empty_log r then
      [@expl:range_inclusive_len ensures] is_empty_log r = (0 = 0)
    else
      [@expl:range_inclusive_len ensures] is_empty_log r = (deep_model (end_log r) - deep_model (start_log r) + 1 = 0)
    )
end
module M_creusot_contracts__std__iter__range__qyi2076862701479908027__produces_refl (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_RangeInclusive
  
  function produces_refl (self: t_RangeInclusive) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__std__iter__range__qyi2076862701479908027__produces_trans (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_RangeInclusive
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_RangeInclusive
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_RangeInclusive
  
  function produces_trans (a: t_RangeInclusive) (ab: Seq.seq t_Idx) (b: t_RangeInclusive) (bc: Seq.seq t_Idx) (c: t_RangeInclusive) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__range__qyi12388694168379144585__produces_back_refl (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_RangeInclusive
  
  function produces_back_refl (self: t_RangeInclusive) : ()
  
  goal vc_produces_back_refl: [@expl:produces_back_refl ensures] produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__std__iter__range__qyi12388694168379144585__produces_back_trans (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_RangeInclusive
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_RangeInclusive
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_RangeInclusive
  
  function produces_back_trans (a: t_RangeInclusive) (ab: Seq.seq t_Idx) (b: t_RangeInclusive) (bc: Seq.seq t_Idx) (c: t_RangeInclusive) : ()
  
  goal vc_produces_back_trans: produces_back a ab b
    -> produces_back b bc c -> ([@expl:produces_back_trans ensures] produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__repeat__qyi13156433517158091792__produces_refl (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Repeat
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  function view (self: t_Repeat) : t_T
  
  predicate produces (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat) =
    self = o /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> postcondition () (view self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Repeat
  
  function produces_refl (self: t_Repeat) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__repeat__qyi13156433517158091792__produces_trans (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Repeat
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  function view (self: t_Repeat) : t_T
  
  predicate produces (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat) =
    self = o /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> postcondition () (view self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Repeat
  
  constant ab : Seq.seq t_T
  
  constant b : t_Repeat
  
  constant bc : Seq.seq t_T
  
  constant c : t_Repeat
  
  function produces_trans (a: t_Repeat) (ab: Seq.seq t_T) (b: t_Repeat) (bc: Seq.seq t_T) (c: t_Repeat) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__rev__qyi8570485907461319344__produces_refl (* <std::iter::Rev<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev
  
  type t_Item
  
  type t_I
  
  predicate produces_back (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back a ab b
      -> produces_back b bc c -> produces_back a (Seq.(++) ab bc) c
  
  function produces_back_refl (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. produces_back self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Rev) : t_I
  
  predicate produces (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev) = produces_back (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Rev
  
  function produces_refl (self: t_Rev) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__rev__qyi8570485907461319344__produces_trans (* <std::iter::Rev<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev
  
  type t_Item
  
  type t_I
  
  predicate produces_back (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back a ab b
      -> produces_back b bc c -> produces_back a (Seq.(++) ab bc) c
  
  function produces_back_refl (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. produces_back self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Rev) : t_I
  
  predicate produces (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev) = produces_back (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Rev
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Rev
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Rev
  
  function produces_trans (a: t_Rev) (ab: Seq.seq t_Item) (b: t_Rev) (bc: Seq.seq t_Item) (c: t_Rev) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__skip__qyi13252230069947492373__produces_refl (* <std::iter::Skip<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Skip
  
  type t_Item
  
  function n (self: t_Skip) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Skip) : t_I
  
  predicate resolve (_1: t_Item)
  
  predicate produces'0 (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n self)
      /\ produces (iter self) (Seq.(++) s visited) (iter o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Skip
  
  function produces_refl'0 (self: t_Skip) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__skip__qyi13252230069947492373__produces_trans (* <std::iter::Skip<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Skip
  
  type t_Item
  
  function n (self: t_Skip) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Skip) : t_I
  
  predicate resolve (_1: t_Item)
  
  predicate produces'0 (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n self)
      /\ produces (iter self) (Seq.(++) s visited) (iter o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Skip
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Skip
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Skip
  
  function produces_trans'0 (a: t_Skip) (ab: Seq.seq t_Item) (b: t_Skip) (bc: Seq.seq t_Item) (c: t_Skip) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__take__qyi10011901481142542325__produces_refl (* <std::iter::Take<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Take
  
  type t_Item
  
  function n (self: t_Take) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Take) : t_I
  
  predicate produces'0 (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take) =
    UInt64.t'int (n self) = UInt64.t'int (n o) + Seq.length visited /\ produces (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Take
  
  function produces_refl'0 (self: t_Take) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__take__qyi10011901481142542325__produces_trans (* <std::iter::Take<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Take
  
  type t_Item
  
  function n (self: t_Take) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Take) : t_I
  
  predicate produces'0 (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take) =
    UInt64.t'int (n self) = UInt64.t'int (n o) + Seq.length visited /\ produces (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Take
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Take
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Take
  
  function produces_trans'0 (a: t_Take) (ab: Seq.seq t_Item) (b: t_Take) (bc: Seq.seq t_Item) (c: t_Take) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__zip__qyi9055347977946847871__produces_refl (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Zip
  
  type t_Item
  
  type t_Item'0
  
  type tuple = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. produces self (Seq.empty: Seq.seq t_Item) self
  
  function itera (self: t_Zip) : t_A
  
  type t_B
  
  predicate produces'0 (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans'0 (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb (self: t_Zip) : t_B
  
  predicate produces'1 (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Zip
  
  function produces_refl'1 (self: t_Zip) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'1 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__iter__zip__qyi9055347977946847871__produces_trans (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Zip
  
  type t_Item
  
  type t_Item'0
  
  type tuple = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. produces self (Seq.empty: Seq.seq t_Item) self
  
  function itera (self: t_Zip) : t_A
  
  type t_B
  
  predicate produces'0 (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans'0 (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb (self: t_Zip) : t_B
  
  predicate produces'1 (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Zip
  
  constant ab : Seq.seq tuple
  
  constant b : t_Zip
  
  constant bc : Seq.seq tuple
  
  constant c : t_Zip
  
  function produces_trans'1 (a: t_Zip) (ab: Seq.seq tuple) (b: t_Zip) (bc: Seq.seq tuple) (c: t_Zip) : ()
  
  goal vc_produces_trans: produces'1 a ab b
    -> produces'1 b bc c -> ([@expl:produces_trans ensures] produces'1 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__Iterator__map_inv
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Any
  use creusot.prelude.MutBorrow
  
  type t_Item
  
  type t_Self
  
  type t_F
  
  type t_MapInv = { t_MapInv__iter: t_Self; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  predicate inv (_1: t_Self)
  
  predicate inv'0 (_1: t_F)
  
  predicate produces (self: t_Self) (visited: Seq.seq t_Item) (o: t_Self)
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate completed (self: MutBorrow.t t_Self)
  
  predicate next_precondition (iter: t_Self) (func: t_F) (produced: Seq.seq t_Item) =
    forall e: t_Item, i: t_Self. produces iter (Seq.singleton e) i -> precondition func { f0 = e; f1 = produced }
  
  type t_B
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate preservation (iter: t_Self) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_Self. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current { f0 = e1; f1 = s }
      -> postcondition_mut f.current { f0 = e1; f1 = s } f.final b
      -> precondition f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize =
    forall iter: MutBorrow.t t_Self, func: t_F. completed iter
      -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv (iter: t_Self) (func: t_F) (produced: Seq.seq t_Item)
  
  axiom preservation_inv_spec: forall iter: t_Self, func: t_F, produced: Seq.seq t_Item. produced
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' (self: t_MapInv) =
    reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  predicate inv'1 (_1: t_MapInv)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv [inv'1 x]. inv'1 x
      = (invariant' x /\ inv x.t_MapInv__iter /\ inv'0 x.t_MapInv__func)
  
  type tuple'0 = { f0'0: t_Self; f1'0: t_F }
  
  predicate precondition'0 (self: ()) (args: tuple'0)
  
  axiom precondition_fndef:
    forall args: tuple'0 [precondition'0 () args]. (let {f0'0 = self; f1'0 = func} = args in preservation self func
        /\ reinitialize
        /\ (forall e: t_Item, i2: t_Self. produces self (Seq.singleton e) i2
            -> precondition func { f0 = e; f1 = Seq.empty: Seq.seq t_Item })
        /\ inv'0 func /\ inv self) -> precondition'0 () args
  
  predicate postcondition_once'0 (self: ()) (args: tuple'0) (result: t_MapInv)
  
  axiom postcondition_fndef:
    forall args: tuple'0, res: t_MapInv [postcondition_once'0 () args res]. postcondition_once'0 () args res
      -> (let {f0'0 = self; f1'0 = func} = args in res
        = { t_MapInv__iter = self; t_MapInv__func = func; t_MapInv__produced = Seq.empty: Seq.seq t_Item }
      /\ inv'1 res)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec map_inv (self: t_Self) (func: t_F) (return (x: t_MapInv)) = {[@expl:map_inv 'self' type invariant] inv self}
    {[@expl:map_inv 'func' type invariant] inv'0 func}
    {[@expl:map_inv requires #0] forall e: t_Item, i2: t_Self. produces self (Seq.singleton e) i2
      -> precondition func { f0 = e; f1 = Seq.empty: Seq.seq t_Item }}
    {[@expl:map_inv requires #1] reinitialize}
    {[@expl:map_inv requires #2] preservation self func}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = [ &_9 <- Seq.empty: Seq.seq t_Item ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_0 <- { t_MapInv__iter = self; t_MapInv__func = func; t_MapInv__produced = _9 } ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_MapInv = Any.any_l ()
    | & self: t_Self = self
    | & func: t_F = func
    | & _9: Seq.seq t_Item = Any.any_l () ])
    [ return (result: t_MapInv) -> {[@expl:map_inv result type invariant] inv'1 result}
      {[@expl:map_inv ensures] result
      = { t_MapInv__iter = self; t_MapInv__func = func; t_MapInv__produced = Seq.empty: Seq.seq t_Item }}
      (! return {result}) ]
end
module M_creusot_contracts__std__iter__qyi15776886527438550973__produces_refl (* <&mut I as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_I
  
  function produces_refl'0 (self: MutBorrow.t t_I) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__qyi15776886527438550973__produces_trans (* <&mut I as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : MutBorrow.t t_I
  
  constant ab : Seq.seq t_Item
  
  constant b : MutBorrow.t t_I
  
  constant bc : Seq.seq t_Item
  
  constant c : MutBorrow.t t_I
  
  function produces_trans'0 (a: MutBorrow.t t_I) (ab: Seq.seq t_Item) (b: MutBorrow.t t_I) (bc: Seq.seq t_Item) (c: MutBorrow.t t_I) : ()
  
  goal vc_produces_trans: produces'0 a ab b
    -> produces'0 b bc c -> ([@expl:produces_trans ensures] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__mem__extern_spec_std_mem_replace_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  let rec swap (x: MutBorrow.t t_T) (y: MutBorrow.t t_T) (return (x'0: ())) = {[@expl:swap 'x' type invariant] inv'0 x}
    {[@expl:swap 'y' type invariant] inv'0 y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_replace_body (dest: MutBorrow.t t_T) (src: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_mem_replace_body 'dest' type invariant] inv'0 dest}
    {[@expl:extern_spec_std_mem_replace_body 'src' type invariant] inv src}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &src'0 <- src ] s1
      | s1 = {inv src'0}
        MutBorrow.borrow_mut <t_T> {src'0}
          (fun (_ret: MutBorrow.t t_T) -> [ &_9 <- _ret ] -{inv _ret.final}- [ &src'0 <- _ret.final ] s2)
      | s2 = {inv dest.current}
        MutBorrow.borrow_final <t_T> {dest.current} {MutBorrow.get_id dest}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_7 <- _ret ] -{inv _ret.final}-
            [ &dest <- { dest with current = _ret.final } ] s3)
      | s3 = {inv _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_8 <- _ret ] -{inv _ret.final}-
            [ &_9 <- { _9 with current = _ret.final } ] s4)
      | s4 = swap {_7} {_8} (fun (_ret: ()) -> [ &_6 <- _ret ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 _9} s1
      | s1 = -{resolve _9}- s2
      | s2 = {[@expl:type invariant] inv'0 dest} s3
      | s3 = -{resolve dest}- s4
      | s4 = [ &_0 <- src'0 ] s5
      | s5 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_T = Any.any_l ()
    | & dest: MutBorrow.t t_T = dest
    | & src: t_T = src
    | & src'0: t_T = Any.any_l ()
    | & _6: () = Any.any_l ()
    | & _7: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_mem_replace_body result type invariant] inv result}
      {[@expl:extern_spec_std_mem_replace_body ensures #0] dest.final = src}
      {[@expl:extern_spec_std_mem_replace_body ensures #1] result = dest.current}
      (! return {result}) ]
end
module M_creusot_contracts__std__mem__extern_spec_std_mem_take_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true) -> precondition () args
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let () = args in inv res)
  
  let rec default (return (x: t_T)) = {[@expl:default requires] precondition () ()}
    any [ return (result: t_T) -> {postcondition_once () () result} (! return {result}) ]
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  let rec replace (dest: MutBorrow.t t_T) (src: t_T) (return (x: t_T)) =
    {[@expl:replace 'dest' type invariant] inv'0 dest}
    {[@expl:replace 'src' type invariant] inv src}
    any [ return (result: t_T) -> {inv result} {dest.final = src} {result = dest.current} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let () = args in inv res)
  
  function fn_mut_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition () args res]. postcondition () args res
      -> (let () = args in inv res)
  
  function fn_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve'0 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_take_body (dest: MutBorrow.t t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_mem_take_body 'dest' type invariant] inv'0 dest}
    (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret: t_T) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv dest.current}
        MutBorrow.borrow_final <t_T> {dest.current} {MutBorrow.get_id dest}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_4 <- _ret ] -{inv _ret.final}-
            [ &dest <- { dest with current = _ret.final } ] s1)
      | s1 = replace {_4} {_5} (fun (_ret: t_T) -> [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 dest} s1 | s1 = -{resolve dest}- s2 | s2 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & dest: MutBorrow.t t_T = dest
    | & _4: MutBorrow.t t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_mem_take_body result type invariant] inv result}
      {[@expl:extern_spec_std_mem_take_body ensures #0] result = dest.current}
      {[@expl:extern_spec_std_mem_take_body ensures #1] postcondition () () dest.final}
      (! return {result}) ]
end
module M_creusot_contracts__std__mem__extern_spec_std_mem_drop_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate resolve (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_drop_body (t: t_T) (return (x: ())) =
    {[@expl:extern_spec_std_mem_drop_body 't' type invariant] inv t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv t} s1 | s1 = -{resolve t}- s2 | s2 = bb1 ] | bb1 = return {_0} ]
    [ & _0: () = Any.any_l () | & t: t_T = t ])
    [ return (result: ()) -> {[@expl:extern_spec_std_mem_drop_body ensures] resolve t} (! return {result}) ]
end
module M_creusot_contracts__std__mem__extern_spec_std_mem_forget_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate resolve (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_forget_body (t: t_T) (return (x: ())) =
    {[@expl:extern_spec_std_mem_forget_body 't' type invariant] inv t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv t} s1 | s1 = -{resolve t}- s2 | s2 = bb1 ] | bb1 = return {_0} ]
    [ & _0: () = Any.any_l () | & t: t_T = t ])
    [ return (result: ()) -> {[@expl:extern_spec_std_mem_forget_body ensures] resolve t} (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_u8_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u8_default_body (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt8.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt8.t = Any.any_l () ])
    [ return (result: UInt8.t) -> {[@expl:extern_spec_Default_u8_default_body ensures] result = (0: UInt8.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_u8_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u8_clone_body (self_: UInt8.t) (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt8.t = Any.any_l () | & self_: UInt8.t = self_ ])
    [ return (result: UInt8.t) -> {[@expl:extern_spec_Clone_u8_clone_body ensures] result = self_} (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_u16_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u16_default_body (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt16.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt16.t = Any.any_l () ])
    [ return (result: UInt16.t) -> {[@expl:extern_spec_Default_u16_default_body ensures] result = (0: UInt16.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_u16_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u16_clone_body (self_: UInt16.t) (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt16.t = Any.any_l () | & self_: UInt16.t = self_ ])
    [ return (result: UInt16.t) -> {[@expl:extern_spec_Clone_u16_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_u32_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u32_default_body (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt32.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt32.t = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:extern_spec_Default_u32_default_body ensures] result = (0: UInt32.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_u32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u32_clone_body (self_: UInt32.t) (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l () | & self_: UInt32.t = self_ ])
    [ return (result: UInt32.t) -> {[@expl:extern_spec_Clone_u32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_u64_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u64_default_body (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt64.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:extern_spec_Default_u64_default_body ensures] result = (0: UInt64.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_u64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u64_clone_body (self_: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & self_: UInt64.t = self_ ])
    [ return (result: UInt64.t) -> {[@expl:extern_spec_Clone_u64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_u128_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u128_default_body (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt128.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt128.t = Any.any_l () ])
    [ return (result: UInt128.t) -> {[@expl:extern_spec_Default_u128_default_body ensures] result = (0: UInt128.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_u128_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u128_clone_body (self_: UInt128.t) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt128.t = Any.any_l () | & self_: UInt128.t = self_ ])
    [ return (result: UInt128.t) -> {[@expl:extern_spec_Clone_u128_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_usize_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_usize_default_body (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt64.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:extern_spec_Default_usize_default_body ensures] result = (0: UInt64.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_usize_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_usize_clone_body (self_: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & self_: UInt64.t = self_ ])
    [ return (result: UInt64.t) -> {[@expl:extern_spec_Clone_usize_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_i8_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i8_default_body (return (x: Int8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int8.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int8.t = Any.any_l () ])
    [ return (result: Int8.t) -> {[@expl:extern_spec_Default_i8_default_body ensures] result = (0: Int8.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_i8_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i8_clone_body (self_: Int8.t) (return (x: Int8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l () | & self_: Int8.t = self_ ])
    [ return (result: Int8.t) -> {[@expl:extern_spec_Clone_i8_clone_body ensures] result = self_} (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_i16_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i16_default_body (return (x: Int16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int16.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int16.t = Any.any_l () ])
    [ return (result: Int16.t) -> {[@expl:extern_spec_Default_i16_default_body ensures] result = (0: Int16.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_i16_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i16_clone_body (self_: Int16.t) (return (x: Int16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int16.t = Any.any_l () | & self_: Int16.t = self_ ])
    [ return (result: Int16.t) -> {[@expl:extern_spec_Clone_i16_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_i32_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i32_default_body (return (x: Int32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int32.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int32.t = Any.any_l () ])
    [ return (result: Int32.t) -> {[@expl:extern_spec_Default_i32_default_body ensures] result = (0: Int32.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_i32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i32_clone_body (self_: Int32.t) (return (x: Int32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int32.t = Any.any_l () | & self_: Int32.t = self_ ])
    [ return (result: Int32.t) -> {[@expl:extern_spec_Clone_i32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_i64_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i64_default_body (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int64.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:extern_spec_Default_i64_default_body ensures] result = (0: Int64.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_i64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i64_clone_body (self_: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & self_: Int64.t = self_ ])
    [ return (result: Int64.t) -> {[@expl:extern_spec_Clone_i64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_i128_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i128_default_body (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int128.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int128.t = Any.any_l () ])
    [ return (result: Int128.t) -> {[@expl:extern_spec_Default_i128_default_body ensures] result = (0: Int128.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_i128_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i128_clone_body (self_: Int128.t) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int128.t = Any.any_l () | & self_: Int128.t = self_ ])
    [ return (result: Int128.t) -> {[@expl:extern_spec_Clone_i128_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Default_isize_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_isize_default_body (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int64.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:extern_spec_Default_isize_default_body ensures] result = (0: Int64.t)}
      (! return {result}) ]
end
module M_creusot_contracts__std__num__extern_spec_Clone_isize_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_isize_clone_body (self_: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & self_: Int64.t = self_ ])
    [ return (result: Int64.t) -> {[@expl:extern_spec_Clone_isize_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__ops__extern_spec_core_option_T_Try_Option_T_from_output_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Try_Option_T_from_output_body (output: t_T) (return (x: t_Option)) =
    {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body 'output' type invariant] inv output}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- C_Some output ] s1 | s1 = bb2 ] | bb2 = return {_0} ]
    [ & _0: t_Option = Any.any_l () | & output: t_T = output ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body result type invariant] inv'0 result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body ensures] result = C_Some output}
      (! return {result}) ]
end
module M_creusot_contracts__std__ops__extern_spec_core_option_T_Try_Option_T_branch_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 ()
  
  type t_ControlFlow = C_Continue t_T | C_Break t_Option'0
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate inv'1 [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'1 a_0
        end
  
  predicate inv'3 (_1: t_ControlFlow)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_ControlFlow [inv'3 x]. inv'3 x
      = match x with
        | C_Continue a_0 -> inv a_0
        | C_Break a_0 -> inv'2 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Try_Option_T_branch_body (self_: t_Option) (return (x: t_ControlFlow)) =
    {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body 'self_' type invariant] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb3) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &v <- r0 ] s1) | s1 = [ &_0 <- C_Continue v ] s2 | s2 = bb8 ]
    | bb3 = s0 [ s0 = [ &_6 <- C_None'0 ] s1 | s1 = [ &_0 <- C_Break _6 ] s2 | s2 = bb8 ]
    | bb8 = return {_0} ]
    [ & _0: t_ControlFlow = Any.any_l ()
    | & self_: t_Option = self_
    | & v: t_T = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l () ])
    [ return (result: t_ControlFlow) ->
    {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body result type invariant] inv'3 result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body ensures] match self_ with
        | C_Some v -> result = C_Continue v
        | C_None -> result = C_Break (C_None'0)
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__ops__extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 ()
  
  predicate inv [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv
  
  predicate inv'0 (_1: t_Option'0)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option'0 [inv'0 x]. inv'0 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv a_0
        end
  
  predicate inv'1 (_1: t_T)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'1 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body (residual: t_Option'0)
    (return (x: t_Option)) =
    {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body 'residual' type invariant] inv'0 residual}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = return {_0} ] ] [ & _0: t_Option = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body result type invariant] inv'2 result}
      {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body ensures] result
      = C_None}
      (! return {result}) ]
end
module M_creusot_contracts__std__ops__extern_spec_core_result_T_E_Try_Result_T_E_from_output_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result = C_Ok t_T | C_Err t_E
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_E)
  
  predicate inv'1 (_1: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
      = match x with
        | C_Ok a_0 -> inv a_0
        | C_Err a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_from_output_body (output: t_T) (return (x: t_Result)) =
    {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body 'output' type invariant] inv output}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- C_Ok output ] s1 | s1 = bb2 ] | bb2 = return {_0} ]
    [ & _0: t_Result = Any.any_l () | & output: t_T = output ])
    [ return (result: t_Result) ->
    {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body result type invariant] inv'1 result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body ensures] result = C_Ok output}
      (! return {result}) ]
end
module M_creusot_contracts__std__ops__extern_spec_core_result_T_E_Try_Result_T_E_branch_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result = C_Ok t_T | C_Err t_E
  
  let rec v_Err (input: t_Result) (ret (field_0: t_E)) = any
    [ good (field_0: t_E) -> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  type t_Result'0 = C_Ok'0 () | C_Err'0 t_E
  
  type t_ControlFlow = C_Continue t_T | C_Break t_Result'0
  
  let rec v_Ok (input: t_Result) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Ok field_0: t_Result]. C_Ok field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_E)
  
  predicate inv'1 (_1: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
      = match x with
        | C_Ok a_0 -> inv a_0
        | C_Err a_0 -> inv'0 a_0
        end
  
  predicate inv'2 [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv'2
  
  predicate inv'3 (_1: t_Result'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result'0 [inv'3 x]. inv'3 x
      = match x with
        | C_Ok'0 a_0 -> inv'2 a_0
        | C_Err'0 a_0 -> inv'0 a_0
        end
  
  predicate inv'4 (_1: t_ControlFlow)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_ControlFlow [inv'4 x]. inv'4 x
      = match x with
        | C_Continue a_0 -> inv a_0
        | C_Break a_0 -> inv'3 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_branch_body (self_: t_Result) (return (x: t_ControlFlow)) =
    {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 (x0: t_T) -> {self_ = C_Ok x0} (! bb4) | br1 (x0: t_E) -> {self_ = C_Err x0} (! bb3) ]
    | bb3 = s0 [ s0 = v_Err {self_} (fun (r0: t_E) -> [ &e <- r0 ] s1) | s1 = [ &_7 <- C_Err'0 e ] s2 | s2 = bb7 ]
    | bb7 = s0 [ s0 = [ &_0 <- C_Break _7 ] s1 | s1 = bb11 ]
    | bb4 = s0 [ s0 = v_Ok {self_} (fun (r0: t_T) -> [ &v <- r0 ] s1) | s1 = [ &_0 <- C_Continue v ] s2 | s2 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_ControlFlow = Any.any_l ()
    | & self_: t_Result = self_
    | & v: t_T = Any.any_l ()
    | & e: t_E = Any.any_l ()
    | & _7: t_Result'0 = Any.any_l () ])
    [ return (result: t_ControlFlow) ->
    {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body result type invariant] inv'4 result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body ensures] match self_ with
        | C_Ok v -> result = C_Continue v
        | C_Err e -> result = C_Break (C_Err'0 e)
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__ops__extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_E
  
  type t_Result = C_Ok () | C_Err t_E
  
  let rec v_Err (input: t_Result) (ret (field_0: t_E)) = any
    [ good (field_0: t_E) -> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  type t_F
  
  predicate inv (_1: t_E)
  
  predicate precondition (self: ()) (args: t_E)
  
  axiom precondition_fndef: forall args: t_E [precondition () args]. (let value = args in inv value)
      -> precondition () args
  
  predicate inv'0 (_1: t_F)
  
  predicate postcondition_once (self: ()) (args: t_E) (result: t_F)
  
  axiom postcondition_fndef: forall args: t_E, res: t_F [postcondition_once () args res]. postcondition_once () args res
      -> (let value = args in inv'0 res)
  
  let rec from (value: t_E) (return (x: t_F)) = {[@expl:from requires] precondition () value}
    any [ return (result: t_F) -> {postcondition_once () value result} (! return {result}) ]
  
  type t_T
  
  type t_Result'0 = C_Ok'0 t_T | C_Err'0 t_F
  
  predicate inv'1 [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 (_1: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'2 x]. inv'2 x
      = match x with
        | C_Ok a_0 -> inv'1 a_0
        | C_Err a_0 -> inv a_0
        end
  
  predicate inv'3 (_1: t_T)
  
  predicate inv'4 (_1: t_Result'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result'0 [inv'4 x]. inv'4 x
      = match x with
        | C_Ok'0 a_0 -> inv'3 a_0
        | C_Err'0 a_0 -> inv'0 a_0
        end
  
  type tuple = { f0: t_Result'0; f1: t_Result }
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_E) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_E, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let value = args in inv'0 res)
  
  function fn_mut_once (self: ()) (args: t_E) (res: t_F) : () = ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_E, res: t_F. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : () = ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : () = ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_E) (res_state: ()) (res: t_F) : () = ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_E, res_state: (), res: t_F. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : () = ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_E) (result: t_F)
  
  axiom postcondition_fndef'1: forall args: t_E, res: t_F [postcondition () args res]. postcondition () args res
      -> (let value = args in inv'0 res)
  
  function fn_once (self: ()) (args: t_E) (res: t_F) : () = ()
  
  axiom fn_once_spec: forall self: (), args: t_E, res: t_F. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_E) (res_state: ()) (res: t_F) : () = ()
  
  axiom fn_mut_spec: forall self: (), args: t_E, res_state: (), res: t_F. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body
    (residual: t_Result) (return (x: t_Result'0)) =
    {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body 'residual' type invariant] inv'2 residual}
    (! bb0
    [ bb0 = s0
      [ s0 = v_Err {residual} (fun (r0: t_E) -> [ &e <- r0 ] s1)
      | s1 = from {e} (fun (_ret: t_F) -> [ &_4 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- C_Err'0 _4 ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_Result'0 = Any.any_l ()
    | & residual: t_Result = residual
    | & e: t_E = Any.any_l ()
    | & _4: t_F = Any.any_l () ])
    [ return (result: t_Result'0) ->
    {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body result type invariant] inv'4 result}
      {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body ensures] match { f0 = result;
                                                                                                                            f1 = residual } with
        | {f0 = C_Err'0 result'0; f1 = C_Err residual'0} -> postcondition () residual'0 result'0
        | _ -> false
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_T_PartialEq_Option_T_eq_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  type t_DeepModelTy
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  function deep_model'1 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'1
  
  let rec eq (self_: t_T) (rhs: t_T) (return (x: bool)) = {[@expl:eq 'self_' type invariant] inv'1 self_}
    {[@expl:eq 'rhs' type invariant] inv'1 rhs}
    any [ return (result: bool) -> {result = (deep_model'1 self_ = deep_model'1 rhs)} (! return {result}) ]
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant''1 [@inline:trivial] (self: t_Option) = inv'2 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 [@inline:trivial] (_1: t_Option) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'3
  
  type t_Option'0 = C_None'0 | C_Some'0 t_DeepModelTy
  
  function deep_model'2 [@inline:trivial] (self: t_Option) : t_Option'0 = match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  meta "rewrite_def" function deep_model'2
  
  function deep_model'3 [@inline:trivial] (self: t_Option) : t_Option'0 = deep_model'2 self
  
  meta "rewrite_def" function deep_model'3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_PartialEq_Option_T_eq_body (self_: t_Option) (rhs: t_Option) (return (x: bool)) =
    {[@expl:extern_spec_T_PartialEq_Option_T_eq_body 'self_' type invariant] inv'3 self_}
    {[@expl:extern_spec_T_PartialEq_Option_T_eq_body 'rhs' type invariant] inv'3 rhs}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- { f0 = self_; f1 = rhs } ] s1
      | s1 = any [ br0 -> {_4.f0 = C_None} (! bb2) | br1 (x0: t_T) -> {_4.f0 = C_Some x0} (! bb4) ] ]
    | bb4 = any [ br0 -> {_4.f1 = C_None} (! bb1) | br1 (x0: t_T) -> {_4.f1 = C_Some x0} (! bb6) ]
    | bb6 = s0
      [ s0 = v_Some {_4.f0} (fun (r0: t_T) -> [ &x <- r0 ] s1)
      | s1 = v_Some {_4.f1} (fun (r0: t_T) -> [ &y <- r0 ] s2)
      | s2 = eq {x} {y} (fun (_ret: bool) -> [ &_0 <- _ret ] s3)
      | s3 = bb9 ]
    | bb2 = any [ br0 -> {_4.f1 = C_None} (! bb7) | br1 (x0: t_T) -> {_4.f1 = C_Some x0} (! bb1) ]
    | bb1 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb9 ]
    | bb7 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: t_Option = self_
    | & rhs: t_Option = rhs
    | & _4: tuple = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & y: t_T = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T_PartialEq_Option_T_eq_body ensures] result
      = (deep_model'3 self_ = deep_model'3 rhs)}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_T_Clone_Option_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate precondition (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
      -> precondition () args
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  let rec clone' (self_: t_T) (return (x: t_T)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_T) -> {postcondition_once () self_ result} (! return {result}) ]
  
  predicate inv'1 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: t_Option) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_Option) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone_Option_T_clone_body (self_: t_Option) (return (x: t_Option)) =
    {[@expl:extern_spec_T_Clone_Option_T_clone_body 'self_' type invariant] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &x <- r0 ] s1)
      | s1 = clone' {x} (fun (_ret: t_T) -> [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_Some _5 ] s1 | s1 = bb7 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option = Any.any_l () | & self_: t_Option = self_ | & x: t_T = Any.any_l () | & _5: t_T = Any.any_l () ])
    [ return (result: t_Option) -> {[@expl:extern_spec_T_Clone_Option_T_clone_body result type invariant] inv'1 result}
      {[@expl:extern_spec_T_Clone_Option_T_clone_body ensures] match { f0 = self_; f1 = result } with
        | {f0 = C_None; f1 = C_None} -> true
        | {f0 = C_Some s; f1 = C_Some r} -> postcondition () s r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_is_some_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant' [@inline:trivial] (self: t_Option) = inv'0 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: t_Option) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_some_body (self_: t_Option) (return (x: bool)) =
    {[@expl:extern_spec_std_option_T_Option_T_is_some_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb3) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb5 ]
    | bb3 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ] [ & _0: bool = Any.any_l () | & self_: t_Option = self_ ])
    [ return (result: bool) -> {[@expl:extern_spec_std_option_T_Option_T_is_some_body ensures] result
      = (self_ <> C_None)}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_is_some_and_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type impl_FnOnce_T_____bool___Destruct
  
  predicate inv (_1: impl_FnOnce_T_____bool___Destruct)
  
  predicate inv'0 (_1: t_T)
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = inv'0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate precondition (self: impl_FnOnce_T_____bool___Destruct) (args: t_T)
  
  predicate postcondition_once (self: impl_FnOnce_T_____bool___Destruct) (args: t_T) (result: bool)
  
  let rec call_once (self_: impl_FnOnce_T_____bool___Destruct) (arg: t_T) (return (x: bool)) =
    {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once 'arg' type invariant] inv'1 arg}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: bool) -> {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate resolve (_1: impl_FnOnce_T_____bool___Destruct)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_some_and_body (self_: t_Option) (f: impl_FnOnce_T_____bool___Destruct)
    (return (x: bool)) = {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'f' type invariant] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body requires] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = C_None} (! bb3) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_9 <- t ] s2
      | s2 = call_once {f} {_9} (fun (_ret: bool) -> [ &_0 <- _ret ] s3)
      | s3 = bb11 ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv f} s1 | s1 = -{resolve f}- s2 | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: t_Option = self_
    | & f: impl_FnOnce_T_____bool___Destruct = f
    | & t: t_T = Any.any_l ()
    | & _9: t_T = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body ensures] match self_ with
        | C_None -> result = false
        | C_Some t -> postcondition_once f t result
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_is_none_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant' [@inline:trivial] (self: t_Option) = inv'0 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: t_Option) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  let rec is_some (self_: t_Option) (return (x: bool)) = {[@expl:is_some 'self_' type invariant] inv'1 self_}
    any [ return (result: bool) -> {result = (self_ <> C_None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_none_body (self_: t_Option) (return (x: bool)) =
    {[@expl:extern_spec_std_option_T_Option_T_is_none_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = s0 [ s0 = is_some {self_} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- not _4 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self_: t_Option = self_ | & _4: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_option_T_Option_T_is_none_body ensures] result
      = (self_ = C_None)}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_as_ref_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant' [@inline:trivial] (self: t_Option) = inv'0 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: t_Option) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate inv'3 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'2 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_ref_body (self_: t_Option) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option_T_as_ref_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb3) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- C_Some'0 t ] s2 | s2 = bb5 ]
    | bb3 = s0 [ s0 = [ &_0 <- C_None'0 ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ] [ & _0: t_Option'0 = Any.any_l () | & self_: t_Option = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option_T_as_ref_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #0] self_ = C_None -> result = C_None'0}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #1] self_ = C_None
      \/ (exists r: t_T. result = C_Some'0 r /\ self_ = C_Some r)}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_as_mut_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_T)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate inv'1 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_Option) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Option) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate inv'3 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_mut_body (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option_T_as_mut_body 'self_' type invariant] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = C_None} (! bb3) | br1 (x0: t_T) -> {self_.current = C_Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = v_Some {self_.current}
          (fun (r0: t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &t <- _ret ] -{inv _ret.final}-
                [ &self_ <- { self_ with current = C_Some _ret.final } ] s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_7 <- _ret ] -{inv _ret.final}-
            [ &t <- { t with current = _ret.final } ] s2)
      | s2 = [ &_0 <- C_Some'0 _7 ] s3
      | s3 = {[@expl:type invariant] inv'0 t} s4
      | s4 = -{resolve t}- s5
      | s5 = bb5 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_} s1
      | s1 = -{resolve'0 self_}- s2
      | s2 = [ &_0 <- C_None'0 ] s3
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = {[@expl:type invariant] inv'2 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 = return {_0} ] ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_: MutBorrow.t t_Option = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _7: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option_T_as_mut_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #0] self_.current = C_None
      -> result = C_None'0 /\ self_.final = C_None}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_T. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_as_slice_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 (self: t_T) = inv self
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: Seq.seq t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 (self: Slice64.slice t_T) = inv'2 (Slice64.view self)
  
  predicate inv'3 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate invariant''3 [@inline:trivial] (self: Slice64.slice t_T) = inv'3 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'4 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''3 _1
  
  meta "rewrite_def" predicate inv'4
  
  let rec from_ref (s: t_T) (return (x: Slice64.slice t_T)) = {[@expl:from_ref 's' type invariant] inv'0 s}
    any
    [ return (result: Slice64.slice t_T) -> {inv'4 result}
      {Seq.length (Slice64.view result) = 1}
      {Seq.get (Slice64.view result) 0 = s}
      (! return {result}) ]
  
  predicate inv'5 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant''4 [@inline:trivial] (self: t_Option) = inv'5 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'6 [@inline:trivial] (_1: t_Option) = invariant''4 _1
  
  meta "rewrite_def" predicate inv'6
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_slice_body (self_: t_Option) (return (x: Slice64.slice t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_as_slice_body 'self_' type invariant] inv'6 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = from_ref {t} (fun (_ret: Slice64.slice t_T) -> [ &_9 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_3 <- _9 ] s1 | s1 = bb6 ]
    | bb4 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array t_T) -> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
              [ &self_ <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- self_ ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array t_T = Any.any_l () | & self_: Slice64.array t_T = Any.any_l () ]
        [ _const_ret (_const: Slice64.array t_T) -> [ &_11 <- _const ] s1 ]
      | s1 = [ &_6 <- _11 ] s2
      | s2 = [ &_3 <- _6 ] s3
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = [ &_0 <- _3 ] s1 | s1 = return {_0} ] ]
    [ & _0: Slice64.slice t_T = Any.any_l ()
    | & self_: t_Option = self_
    | & _3: Slice64.slice t_T = Any.any_l ()
    | & _6: Slice64.array t_T = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _9: Slice64.slice t_T = Any.any_l ()
    | & _11: Slice64.array t_T = Any.any_l () ])
    [ return (result: Slice64.slice t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_as_slice_body result type invariant] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_slice_body ensures] match self_ with
        | C_None -> Seq.length (Slice64.view result) = 0
        | C_Some t -> Seq.length (Slice64.view result) = 1 /\ Seq.get (Slice64.view result) 0 = t
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_as_mut_slice_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 (self: t_T) = inv self
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'1 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: Seq.seq t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 (self: Slice64.slice t_T) = inv'2 (Slice64.view self)
  
  predicate inv'3 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'4 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant''3 _1
  
  meta "rewrite_def" predicate inv'4
  
  let rec from_mut (s: MutBorrow.t t_T) (return (x: MutBorrow.t (Slice64.slice t_T))) =
    {[@expl:from_mut 's' type invariant] inv'0 s}
    any
    [ return (result: MutBorrow.t (Slice64.slice t_T)) -> {inv'4 result}
      {Seq.length (Slice64.view result.current) = 1}
      {Seq.get (Slice64.view result.current) 0 = s.current}
      {Seq.length (Slice64.view result.final) = 1}
      {Seq.get (Slice64.view result.final) 0 = s.final}
      (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate inv'5 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'6 [@inline:trivial] (_1: MutBorrow.t t_Option) = invariant''4 _1
  
  meta "rewrite_def" predicate inv'6
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_Option) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate invariant''5 (self: Slice64.array t_T) =
    inv'2 (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (0: UInt64.t)
  
  predicate inv'7 [@inline:trivial] (_1: Slice64.array t_T) = invariant''5 _1
  
  meta "rewrite_def" predicate inv'7
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t (Slice64.array t_T)) =
    inv'7 self.current /\ inv'7 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'8 [@inline:trivial] (_1: MutBorrow.t (Slice64.array t_T)) = invariant''6 _1
  
  meta "rewrite_def" predicate inv'8
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t (Slice64.array t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_mut_slice_body (self_: MutBorrow.t t_Option)
    (return (x: MutBorrow.t (Slice64.slice t_T))) =
    {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body 'self_' type invariant] inv'6 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = C_None} (! bb2) | br1 (x0: t_T) -> {self_.current = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_.current}
          (fun (r0: t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &t <- _ret ] -{inv _ret.final}-
                [ &self_ <- { self_ with current = C_Some _ret.final } ] s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_11 <- _ret ] -{inv _ret.final}-
            [ &t <- { t with current = _ret.final } ] s2)
      | s2 = from_mut {_11} (fun (_ret: MutBorrow.t (Slice64.slice t_T)) -> [ &_10 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'3 _10.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_4 <- _ret ] -{inv'3 _ret.final}-
            [ &_10 <- { _10 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'4 _10} s2
      | s2 = -{resolve _10}- s3
      | s3 = {[@expl:type invariant] inv'0 t} s4
      | s4 = -{resolve'0 t}- s5
      | s5 = bb6 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'6 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb4 ]
    | bb4 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array t_T) -> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
              [ &self_ <- __arr_temp ] s1'0) ]
          | s1'0 = {inv'7 self_}
            MutBorrow.borrow_mut <Slice64.array t_T> {self_}
              (fun (_ret: MutBorrow.t (Slice64.array t_T)) ->
                [ &_0'0 <- _ret ] -{inv'7 _ret.final}-
                [ &self_ <- _ret.final ] s2'0)
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: MutBorrow.t (Slice64.array t_T) = Any.any_l () | & self_: Slice64.array t_T = Any.any_l () ]
        [ _const_ret (_const: MutBorrow.t (Slice64.array t_T)) -> [ &_12 <- _const ] s1 ]
      | s1 = {inv'7 _12.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t (Slice64.array t_T)) ->
            [ &_7 <- _ret ] -{inv'7 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = {inv'7 _7.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_7.current} {MutBorrow.get_id _7}
          (fun (_ret: MutBorrow.t (Slice64.array t_T)) ->
            [ &_6 <- _ret ] -{inv'7 _ret.final}-
            [ &_7 <- { _7 with current = _ret.final } ] s3)
      | s3 = [ &_4 <- _6 ] s4
      | s4 = {[@expl:type invariant] inv'8 _7} s5
      | s5 = -{resolve'2 _7}- s6
      | s6 = bb8 ]
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'8 _12} s1 | s1 = -{resolve'2 _12}- s2 | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {inv'3 _4.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_4.current} {MutBorrow.get_id _4}
          (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_2 <- _ret ] -{inv'3 _ret.final}-
            [ &_4 <- { _4 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'4 _4} s2
      | s2 = -{resolve _4}- s3
      | s3 = {inv'3 _2.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_0 <- _ret ] -{inv'3 _ret.final}-
            [ &_2 <- { _2 with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv'4 _2} s5
      | s5 = -{resolve _2}- s6
      | s6 = {[@expl:type invariant] inv'6 self_} s7
      | s7 = -{resolve'1 self_}- s8
      | s8 = return {_0} ] ]
    [ & _0: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & self_: MutBorrow.t t_Option = self_
    | & _2: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _4: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _6: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & _7: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _11: MutBorrow.t t_T = Any.any_l ()
    | & _12: MutBorrow.t (Slice64.array t_T) = Any.any_l () ])
    [ return (result: MutBorrow.t (Slice64.slice t_T)) ->
    {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body result type invariant] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body ensures] match self_.current with
        | C_None -> Seq.length (Slice64.view result.current) = 0
        | C_Some _ -> exists b: MutBorrow.t t_T. self_.current = C_Some (b.current)
          /\ self_.final = C_Some (b.final)
          /\ Seq.get (Slice64.view result.current) 0 = b.current
          /\ Seq.get (Slice64.view result.final) 0 = b.final
          /\ Seq.length (Slice64.view result.current) = 1 /\ Seq.length (Slice64.view result.final) = 1
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_expect_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_expect_body (self_: t_Option) (msg: string) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_expect_body 'self_' type invariant] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_expect_body requires] self_ <> C_None}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb6 ]
    | bb6 = return {_0}
    | bb4 = {false} any ] [ & _0: t_T = Any.any_l () | & self_: t_Option = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_option_T_Option_T_expect_body result type invariant] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_expect_body ensures] C_Some result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_unwrap_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_body (self_: t_Option) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_body 'self_' type invariant] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_body requires] self_ <> C_None}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb6 ]
    | bb6 = return {_0}
    | bb4 = {false} any ] [ & _0: t_T = Any.any_l () | & self_: t_Option = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_option_T_Option_T_unwrap_body result type invariant] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_body ensures] C_Some result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_unwrap_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate resolve (_1: t_T)
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_body (self_: t_Option) (default: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'self_' type invariant] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'default' type invariant] inv default}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv default} s1 | s1 = -{resolve default}- s2 | s2 = bb5 ]
    | bb5 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb9 ]
    | bb4 = s0 [ s0 = [ &_0 <- default ] s1 | s1 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & self_: t_Option = self_ | & default: t_T = default | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body result type invariant] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #0] self_ = C_None -> result = default}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #1] self_ = C_None
      \/ self_ = C_Some result /\ resolve default}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_F
  
  predicate inv (_1: t_F)
  
  predicate resolve (_1: t_F)
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate precondition (self: t_F) (args: ())
  
  predicate inv'0 (_1: t_T)
  
  predicate postcondition_once (self: t_F) (args: ()) (result: t_T)
  
  let rec call_once (self_: t_F) (arg: ()) (return (x: t_T)) = {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: t_T) -> {inv'0 result} {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate inv'1 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body (self_: t_Option) (f: t_F) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'f' type invariant] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body requires] self_ = C_None -> precondition f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv f} s1 | s1 = -{resolve f}- s2 | s2 = bb5 ]
    | bb5 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb10 ]
    | bb4 = s0 [ s0 = call_once {f} {_9} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_T = Any.any_l ()
    | & self_: t_Option = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _9: () = Any.any_l () ])
    [ return (result: t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body result type invariant] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body ensures] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = t
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_unwrap_or_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate precondition (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true) -> precondition () args
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let () = args in inv res)
  
  let rec default (return (x: t_T)) = {[@expl:default requires] precondition () ()}
    any [ return (result: t_T) -> {postcondition_once () () result} (! return {result}) ]
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let () = args in inv res)
  
  function fn_mut_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition () args res]. postcondition () args res
      -> (let () = args in inv res)
  
  function fn_once (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_default_body (self_: t_Option) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body 'self_' type invariant] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb5) ]
    | bb5 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb8 ]
    | bb4 = s0 [ s0 = default (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = return {_0} ] [ & _0: t_T = Any.any_l () | & self_: t_Option = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body result type invariant] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #0] self_ = C_None
      -> postcondition () () result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #1] self_ = C_None
      \/ self_ = C_Some result}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_unwrap_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_unchecked_body (self_: t_Option) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body 'self_' type invariant] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body requires] self_ <> C_None}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb6 ]
    | bb6 = return {_0}
    | bb4 = {false} any ] [ & _0: t_T = Any.any_l () | & self_: t_Option = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body result type invariant] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body ensures] C_Some result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_map_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_F
  
  type t_U
  
  predicate inv (_1: t_F)
  
  predicate inv'0 (_1: t_T)
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = inv'0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate precondition (self: t_F) (args: t_T)
  
  predicate inv'2 (_1: t_U)
  
  predicate postcondition_once (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once (self_: t_F) (arg: t_T) (return (x: t_U)) = {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once 'arg' type invariant] inv'1 arg}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: t_U) -> {inv'2 result} {postcondition_once self_ arg result} (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_U
  
  predicate resolve (_1: t_F)
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  predicate inv'4 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'4 x]. inv'4 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'2 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_body (self_: t_Option) (f: t_F) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'self_' type invariant] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'f' type invariant] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_map_body requires] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb5) ]
    | bb5 = s0
      [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_10 <- t ] s2
      | s2 = call_once {f} {_10} (fun (_ret: t_U) -> [ &_8 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = [ &_0 <- C_Some'0 _8 ] s1 | s1 = bb12 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv f} s1 | s1 = -{resolve f}- s2 | s2 = [ &_0 <- C_None'0 ] s3 | s3 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_: t_Option = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: t_U = Any.any_l ()
    | & _10: t_T = Any.any_l () ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option_T_map_body result type invariant] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_body ensures] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> exists r: t_U. result = C_Some'0 r /\ postcondition_once f t r
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_inspect_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_F
  
  predicate inv (_1: t_F)
  
  predicate inv'0 (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 [@inline:trivial] (_1: t_T) = inv'1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: t_F) (args: t_T)
  
  predicate postcondition_once (self: t_F) (args: t_T) (result: ())
  
  let rec call_once (self_: t_F) (arg: t_T) (return (x: ())) = {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once 'arg' type invariant] inv'2 arg}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: ()) -> {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate resolve (_1: t_F)
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_inspect_body (self_: t_Option) (f: t_F) (return (x: t_Option)) =
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'self_' type invariant] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'f' type invariant] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body requires] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb2) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_12 <- t ] s2
      | s2 = [ &_10 <- _12 ] s3
      | s3 = call_once {f} {_10} (fun (_ret: ()) -> [ &_8 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_Some t ] s1 | s1 = bb10 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv f} s1 | s1 = -{resolve f}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Option = Any.any_l ()
    | & self_: t_Option = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _10: t_T = Any.any_l ()
    | & _12: t_T = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #0] result = self_}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #1] match self_ with
        | C_None -> true
        | C_Some t -> postcondition_once f t ()
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_map_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_U
  
  predicate inv (_1: t_U)
  
  predicate resolve (_1: t_U)
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_F
  
  predicate inv'0 (_1: t_F)
  
  predicate inv'1 (_1: t_T)
  
  predicate inv'2 [@inline:trivial] (_1: t_T) = inv'1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: t_F) (args: t_T)
  
  predicate postcondition_once (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once (self_: t_F) (arg: t_T) (return (x: t_U)) = {[@expl:call_once 'self_' type invariant] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] inv'2 arg}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: t_U) -> {inv result} {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate resolve'0 (_1: t_F)
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'1 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_or_body (self_: t_Option) (default: t_U) (f: t_F) (return (x: t_U)) =
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'self_' type invariant] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'default' type invariant] inv default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'f' type invariant] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body requires] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb2) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv default} s1
      | s1 = -{resolve default}- s2
      | s2 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_9 <- t ] s4
      | s4 = call_once {f} {_9} (fun (_ret: t_U) -> [ &_0 <- _ret ] s5)
      | s5 = bb11 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- default ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_U = Any.any_l ()
    | & self_: t_Option = self_
    | & default: t_U = default
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _9: t_T = Any.any_l () ])
    [ return (result: t_U) -> {[@expl:extern_spec_std_option_T_Option_T_map_or_body result type invariant] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_body ensures] match self_ with
        | C_None -> result = default
        | C_Some t -> postcondition_once f t result
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_map_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_D
  
  predicate inv (_1: t_D)
  
  predicate resolve (_1: t_D)
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_F
  
  type t_U
  
  predicate inv'0 (_1: t_F)
  
  predicate inv'1 (_1: t_T)
  
  predicate inv'2 [@inline:trivial] (_1: t_T) = inv'1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: t_F) (args: t_T)
  
  predicate inv'3 (_1: t_U)
  
  predicate postcondition_once (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once (self_: t_F) (arg: t_T) (return (x: t_U)) = {[@expl:call_once 'self_' type invariant] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] inv'2 arg}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: t_U) -> {inv'3 result} {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate resolve'0 (_1: t_F)
  
  predicate precondition'0 (self: t_D) (args: ())
  
  predicate postcondition_once'0 (self: t_D) (args: ()) (result: t_U)
  
  let rec call_once'0 (self_: t_D) (arg: ()) (return (x: t_U)) = {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once requires] precondition'0 self_ arg}
    any [ return (result: t_U) -> {inv'3 result} {postcondition_once'0 self_ arg result} (! return {result}) ]
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'1 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body (self_: t_Option) (default: t_D) (f: t_F)
    (return (x: t_U)) = {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'self_' type invariant] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'default' type invariant] inv default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'f' type invariant] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body requires] match self_ with
      | C_None -> precondition'0 default ()
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb2) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv default} s1
      | s1 = -{resolve default}- s2
      | s2 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_11 <- t ] s4
      | s4 = call_once {f} {_11} (fun (_ret: t_U) -> [ &_0 <- _ret ] s5)
      | s5 = bb12 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = call_once'0 {default} {_8} (fun (_ret: t_U) -> [ &_0 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: t_U = Any.any_l ()
    | & self_: t_Option = self_
    | & default: t_D = default
    | & f: t_F = f
    | & _8: () = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _11: t_T = Any.any_l () ])
    [ return (result: t_U) ->
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body ensures] match self_ with
        | C_None -> postcondition_once'0 default () result
        | C_Some t -> postcondition_once f t result
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_ok_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_E
  
  predicate inv (_1: t_E)
  
  predicate resolve (_1: t_E)
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Result = C_Ok t_T | C_Err t_E
  
  predicate inv'0 (_1: t_T)
  
  predicate inv'1 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  predicate inv'2 (_1: t_Result)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result [inv'2 x]. inv'2 x
      = match x with
        | C_Ok a_0 -> inv'0 a_0
        | C_Err a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_ok_or_body (self_: t_Option) (err: t_E) (return (x: t_Result)) =
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'self_' type invariant] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'err' type invariant] inv err}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv err} s1
      | s1 = -{resolve err}- s2
      | s2 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_0 <- C_Ok t ] s4
      | s4 = bb10 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_Err err ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Result = Any.any_l () | & self_: t_Option = self_ | & err: t_E = err | & t: t_T = Any.any_l () ])
    [ return (result: t_Result) ->
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body result type invariant] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_body ensures] match self_ with
        | C_None -> result = C_Err err
        | C_Some t -> result = C_Ok t /\ resolve err
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_ok_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_F
  
  predicate inv (_1: t_F)
  
  predicate resolve (_1: t_F)
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_E
  
  type t_Result = C_Ok t_T | C_Err t_E
  
  predicate precondition (self: t_F) (args: ())
  
  predicate inv'0 (_1: t_E)
  
  predicate postcondition_once (self: t_F) (args: ()) (result: t_E)
  
  let rec call_once (self_: t_F) (arg: ()) (return (x: t_E)) = {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: t_E) -> {inv'0 result} {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate inv'1 (_1: t_T)
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'1 a_0
        end
  
  predicate inv'3 (_1: t_Result)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result [inv'3 x]. inv'3 x
      = match x with
        | C_Ok a_0 -> inv'1 a_0
        | C_Err a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body (self_: t_Option) (err: t_F) (return (x: t_Result)) =
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'err' type invariant] inv err}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body requires] self_ = C_None -> precondition err ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv err} s1
      | s1 = -{resolve err}- s2
      | s2 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_0 <- C_Ok t ] s4
      | s4 = bb11 ]
    | bb4 = s0 [ s0 = call_once {err} {_8} (fun (_ret: t_E) -> [ &_6 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_Err _6 ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_Result = Any.any_l ()
    | & self_: t_Option = self_
    | & err: t_F = err
    | & _6: t_E = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Result) ->
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body ensures] match self_ with
        | C_None -> exists r: t_E. result = C_Err r /\ postcondition_once err () r
        | C_Some t -> result = C_Ok t
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_and_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'0 x]. resolve'0 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve x0
        end
  
  type t_U
  
  type t_Option'0 = C_None'0 | C_Some'0 t_U
  
  predicate inv'1 (_1: t_U)
  
  predicate inv'2 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'1 a_0
        end
  
  predicate resolve'1 (_1: t_U)
  
  predicate resolve'2 (_1: t_Option'0)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Option'0 [resolve'2 x]. resolve'2 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 x0 -> resolve'1 x0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_and_body (self_: t_Option) (optb: t_Option'0) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option_T_and_body 'self_' type invariant] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_body 'optb' type invariant] inv'2 optb}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb2) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_} s1
      | s1 = -{resolve'0 self_}- s2
      | s2 = [ &_0 <- optb ] s3
      | s3 = bb7 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'2 optb} s1
      | s1 = -{resolve'2 optb}- s2
      | s2 = {[@expl:type invariant] inv'0 self_} s3
      | s3 = -{resolve'0 self_}- s4
      | s4 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None'0 ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ] [ & _0: t_Option'0 = Any.any_l () | & self_: t_Option = self_ | & optb: t_Option'0 = optb ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option_T_and_body result type invariant] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #0] self_ = C_None
      -> result = C_None'0 /\ resolve'2 optb}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #1] self_ = C_None \/ result = optb /\ resolve'0 self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_and_then_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_F
  
  type t_U
  
  type t_Option'0 = C_None'0 | C_Some'0 t_U
  
  predicate inv (_1: t_F)
  
  predicate inv'0 (_1: t_T)
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = inv'0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate precondition (self: t_F) (args: t_T)
  
  predicate inv'2 (_1: t_U)
  
  predicate inv'3 (_1: t_Option'0)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'2 a_0
        end
  
  predicate postcondition_once (self: t_F) (args: t_T) (result: t_Option'0)
  
  let rec call_once (self_: t_F) (arg: t_T) (return (x: t_Option'0)) =
    {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once 'arg' type invariant] inv'1 arg}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: t_Option'0) -> {inv'3 result} {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate resolve (_1: t_F)
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_and_then_body (self_: t_Option) (f: t_F) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'self_' type invariant] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'f' type invariant] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body requires] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb2) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_8 <- t ] s2
      | s2 = call_once {f} {_8} (fun (_ret: t_Option'0) -> [ &_0 <- _ret ] s3)
      | s3 = bb10 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv f} s1 | s1 = -{resolve f}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None'0 ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_: t_Option = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: t_T = Any.any_l () ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_then_body ensures] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> postcondition_once f t result
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_filter_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_P
  
  predicate inv (_1: t_P)
  
  predicate inv'0 (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 [@inline:trivial] (_1: t_T) = inv'1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: t_P) (args: t_T)
  
  predicate postcondition_once (self: t_P) (args: t_T) (result: bool)
  
  let rec call_once (self_: t_P) (arg: t_T) (return (x: bool)) = {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once 'arg' type invariant] inv'2 arg}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: bool) -> {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_P)
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_filter_body (self_: t_Option) (predicate': t_P) (return (x: t_Option)) =
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'self_' type invariant] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'predicate' type invariant] inv predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body requires] match self_ with
      | C_None -> true
      | C_Some t -> precondition predicate' t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb2) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_11 <- t ] s2
      | s2 = [ &_9 <- _11 ] s3
      | s3 = call_once {predicate'} {_9} (fun (_ret: bool) -> [ &_7 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb6) ]
    | bb6 = s0 [ s0 = [ &_0 <- C_Some t ] s1 | s1 = bb14 ]
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve t}- s2 | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = bb14 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv predicate'} s1 | s1 = -{resolve'0 predicate'}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = bb14 ]
    | bb14 = return {_0} ]
    [ & _0: t_Option = Any.any_l ()
    | & self_: t_Option = self_
    | & predicate': t_P = predicate'
    | & t: t_T = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_T = Any.any_l ()
    | & _11: t_T = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_T_filter_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_filter_body ensures] match self_ with
        | C_None -> result = C_None
        | C_Some t -> match result with
          | C_None -> postcondition_once predicate' t false /\ resolve t
          | C_Some r -> postcondition_once predicate' t true /\ r = t
          end
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'0 x]. resolve'0 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve x0
        end
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_or_body (self_: t_Option) (optb: t_Option) (return (x: t_Option)) =
    {[@expl:extern_spec_std_option_T_Option_T_or_body 'self_' type invariant] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_body 'optb' type invariant] inv'0 optb}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'0 optb} s1
      | s1 = -{resolve'0 optb}- s2
      | s2 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_0 <- C_Some t ] s4
      | s4 = bb9 ]
    | bb4 = s0 [ s0 = [ &_0 <- optb ] s1 | s1 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: t_Option = Any.any_l () | & self_: t_Option = self_ | & optb: t_Option = optb | & t: t_T = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_T_or_body result type invariant] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #0] self_ = C_None -> result = optb}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #1] self_ = C_None \/ result = self_ /\ resolve'0 optb}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_F
  
  predicate inv (_1: t_F)
  
  predicate resolve (_1: t_F)
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate precondition (self: t_F) (args: ())
  
  predicate inv'0 (_1: t_T)
  
  predicate inv'1 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  predicate postcondition_once (self: t_F) (args: ()) (result: t_Option)
  
  let rec call_once (self_: t_F) (arg: ()) (return (x: t_Option)) = {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: t_Option) -> {inv'1 result} {postcondition_once self_ arg result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_or_else_body (self_: t_Option) (f: t_F) (return (x: t_Option)) =
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'self_' type invariant] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'f' type invariant] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body requires] self_ = C_None -> precondition f ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv f} s1
      | s1 = -{resolve f}- s2
      | s2 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_0 <- C_Some t ] s4
      | s4 = bb10 ]
    | bb4 = s0 [ s0 = call_once {f} {_7} (fun (_ret: t_Option) -> [ &_0 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Option = Any.any_l ()
    | & self_: t_Option = self_
    | & f: t_F = f
    | & _7: () = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body result type invariant] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_else_body ensures] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = C_Some t
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_xor_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'0 x]. resolve'0 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve x0
        end
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_xor_body (self_: t_Option) (optb: t_Option) (return (x: t_Option)) =
    {[@expl:extern_spec_std_option_T_Option_T_xor_body 'self_' type invariant] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_xor_body 'optb' type invariant] inv'0 optb}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- { f0 = self_; f1 = optb } ] s1 | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4.f0 = C_None} (! bb6) | br1 (x0: t_T) -> {_4.f0 = C_Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'0 _4.f1} s1
      | s1 = -{resolve'0 _4.f1}- s2
      | s2 = any [ br0 -> {_4.f1 = C_None} (! bb9) | br1 (x0: t_T) -> {_4.f1 = C_Some x0} (! bb24) ] ]
    | bb24 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {f0 = C_Some x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {f0 = C_Some x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = bb3 ]
    | bb9 = s0 [ s0 = v_Some {_4.f0} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = bb10 ]
    | bb6 = any [ br0 -> {_4.f1 = C_None} (! bb23) | br1 (x0: t_T) -> {_4.f1 = C_Some x0} (! bb8) ]
    | bb23 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {f1 = C_Some x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {f1 = C_Some x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = bb16 ]
    | bb8 = s0 [ s0 = v_Some {_4.f1} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = [ &_0 <- C_Some t ] s1 | s1 = bb16 ]
    | bb16 = return {_0} ]
    [ & _0: t_Option = Any.any_l ()
    | & self_: t_Option = self_
    | & optb: t_Option = optb
    | & _4: tuple = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_T_xor_body result type invariant] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_xor_body ensures] match { f0 = self_; f1 = optb } with
        | {f0 = C_None; f1 = C_None} -> result = C_None
        | {f0 = C_Some t1; f1 = C_Some t2} -> result = C_None /\ resolve t1 /\ resolve t2
        | {f0 = C_Some t; f1 = C_None} -> result = C_Some t
        | {f0 = C_None; f1 = C_Some t} -> result = C_Some t
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_insert_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'0 x]. resolve'0 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve x0
        end
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_Option) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Option) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_insert_body (self_: MutBorrow.t t_Option) (value: t_T)
    (return (x: MutBorrow.t t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_insert_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_insert_body 'value' type invariant] inv value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_6 <- C_Some value ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_.current} s1
      | s1 = -{resolve'0 self_.current}- s2
      | s2 = [ &self_ <- { self_ with current = _6 } ] s3
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {self_.current = C_None} (! bb6) | br1 (x0: t_T) -> {self_.current = C_Some x0} (! bb7) ]
    | bb7 = s0
      [ s0 = v_Some {self_.current}
          (fun (r0: t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &v <- _ret ] -{inv _ret.final}-
                [ &self_ <- { self_ with current = C_Some _ret.final } ] s1))
      | s1 = {inv v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_8 <- _ret ] -{inv _ret.final}-
            [ &v <- { v with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'1 v} s3
      | s3 = -{resolve'1 v}- s4
      | s4 = {inv _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_3 <- _ret ] -{inv _ret.final}-
            [ &_8 <- { _8 with current = _ret.final } ] s5)
      | s5 = {[@expl:type invariant] inv'1 _8} s6
      | s6 = -{resolve'1 _8}- s7
      | s7 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_0 <- _ret ] -{inv _ret.final}-
            [ &_3 <- { _3 with current = _ret.final } ] s8)
      | s8 = {[@expl:type invariant] inv'1 _3} s9
      | s9 = -{resolve'1 _3}- s10
      | s10 = bb9 ]
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'2 self_} s1 | s1 = -{resolve'2 self_}- s2 | s2 = return {_0} ]
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv'2 self_} s1 | s1 = -{resolve'2 self_}- s2 | s2 = bb8 ]
    | bb8 = {false} any ]
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option = self_
    | & value: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_insert_body result type invariant] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #0] match self_.current with
        | C_Some t -> resolve t
        | C_None -> true
        end}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #1] result.current = value
      /\ self_.final = C_Some (result.final)}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_get_or_insert_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate resolve (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate resolve'0 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'0 x]. resolve'0 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve x0
        end
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate resolve'1 [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_Option) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate resolve'2 [@inline:trivial] (_1: MutBorrow.t t_Option) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_body (self_: MutBorrow.t t_Option) (value: t_T)
    (return (x: MutBorrow.t t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'value' type invariant] inv value}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = C_None} (! bb4) | br1 (x0: t_T) -> {self_.current = C_Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv value} s1 | s1 = -{resolve value}- s2 | s2 = bb9 ]
    | bb4 = s0 [ s0 = [ &_7 <- C_Some value ] s1 | s1 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_.current} s1
      | s1 = -{resolve'0 self_.current}- s2
      | s2 = [ &self_ <- { self_ with current = _7 } ] s3
      | s3 = bb9 ]
    | bb9 = any [ br0 -> {self_.current = C_None} (! bb11) | br1 (x0: t_T) -> {self_.current = C_Some x0} (! bb12) ]
    | bb12 = s0
      [ s0 = v_Some {self_.current}
          (fun (r0: t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &v <- _ret ] -{inv _ret.final}-
                [ &self_ <- { self_ with current = C_Some _ret.final } ] s1))
      | s1 = {inv v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_9 <- _ret ] -{inv _ret.final}-
            [ &v <- { v with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv'1 v} s3
      | s3 = -{resolve'1 v}- s4
      | s4 = {inv _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_3 <- _ret ] -{inv _ret.final}-
            [ &_9 <- { _9 with current = _ret.final } ] s5)
      | s5 = {[@expl:type invariant] inv'1 _9} s6
      | s6 = -{resolve'1 _9}- s7
      | s7 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_0 <- _ret ] -{inv _ret.final}-
            [ &_3 <- { _3 with current = _ret.final } ] s8)
      | s8 = {[@expl:type invariant] inv'1 _3} s9
      | s9 = -{resolve'1 _3}- s10
      | s10 = bb14 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self_} s1 | s1 = -{resolve'2 self_}- s2 | s2 = return {_0} ]
    | bb11 = s0 [ s0 = {[@expl:type invariant] inv'2 self_} s1 | s1 = -{resolve'2 self_}- s2 | s2 = bb13 ]
    | bb13 = {false} any ]
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option = self_
    | & value: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _7: t_Option = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body result type invariant] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body ensures] match self_.current with
        | C_None -> result.current = value /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final) /\ resolve value
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_F
  
  predicate inv (_1: t_F)
  
  predicate resolve (_1: t_F)
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv'0 (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate precondition (self: t_F) (args: ())
  
  predicate postcondition_once (self: t_F) (args: ()) (result: t_T)
  
  let rec call_once (self_: t_F) (arg: ()) (return (x: t_T)) = {[@expl:call_once 'self_' type invariant] inv self_}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: t_T) -> {inv'0 result} {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  predicate resolve'1 (_1: t_T)
  
  predicate resolve'2 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'2 x]. resolve'2 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve'1 x0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_T)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'3 [@inline:trivial] (_1: MutBorrow.t t_Option) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate inv'4 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'4 x]. inv'4 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'1 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] inv'3 self_}
    any
    [ return (result: t_Option'0) -> {inv'4 result}
      {self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {self_.current = C_None
      \/ (exists r: MutBorrow.t t_T. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return (x: MutBorrow.t t_T)) = {[@expl:unwrap 'self_' type invariant] inv'4 self_}
    {[@expl:unwrap requires] self_ <> C_None'0}
    any [ return (result: MutBorrow.t t_T) -> {inv'1 result} {C_Some'0 result = self_} (! return {result}) ]
  
  predicate resolve'3 [@inline:trivial] (_1: MutBorrow.t t_Option) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body (self_: MutBorrow.t t_Option) (f: t_F)
    (return (x: MutBorrow.t t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'f' type invariant] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body requires] self_.current = C_None
    -> precondition f ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = C_None} (! bb4) | br1 (x0: t_T) -> {self_.current = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv f} s1
      | s1 = -{resolve f}- s2
      | s2 = v_Some {self_.current}
          (fun (r0: t_T) ->
            {inv'0 r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &t <- _ret ] -{inv'0 _ret.final}-
                [ &self_ <- { self_ with current = C_Some _ret.final } ] s3))
      | s3 = {inv'0 t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_6 <- _ret ] -{inv'0 _ret.final}-
            [ &t <- { t with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv'1 t} s5
      | s5 = -{resolve'0 t}- s6
      | s6 = bb12 ]
    | bb4 = s0 [ s0 = call_once {f} {_12} (fun (_ret: t_T) -> [ &_10 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &_9 <- C_Some _10 ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_.current} s1
      | s1 = -{resolve'2 self_.current}- s2
      | s2 = [ &self_ <- { self_ with current = _9 } ] s3
      | s3 = bb9 ]
    | bb9 = s0
      [ s0 = {inv'2 self_.current}
        MutBorrow.borrow_final <t_Option> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &self_ <- { self_ with current = _ret.final } ] s1)
      | s1 = as_mut {_15} (fun (_ret: t_Option'0) -> [ &_14 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0 [ s0 = unwrap {_14} (fun (_ret: MutBorrow.t t_T) -> [ &_13 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = {inv'0 _13.current}
        MutBorrow.borrow_final <t_T> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_8 <- _ret ] -{inv'0 _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'1 _13} s2
      | s2 = -{resolve'0 _13}- s3
      | s3 = {inv'0 _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_6 <- _ret ] -{inv'0 _ret.final}-
            [ &_8 <- { _8 with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv'1 _8} s5
      | s5 = -{resolve'0 _8}- s6
      | s6 = bb12 ]
    | bb12 = s0
      [ s0 = {inv'0 _6.current}
        MutBorrow.borrow_final <t_T> {_6.current} {MutBorrow.get_id _6}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_3 <- _ret ] -{inv'0 _ret.final}-
            [ &_6 <- { _6 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'1 _6} s2
      | s2 = -{resolve'0 _6}- s3
      | s3 = {inv'0 _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_0 <- _ret ] -{inv'0 _ret.final}-
            [ &_3 <- { _3 with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv'1 _3} s5
      | s5 = -{resolve'0 _3}- s6
      | s6 = bb13 ]
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'3 self_}- s2 | s2 = return {_0} ] ]
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option = self_
    | & f: t_F = f
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _6: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _10: t_T = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & _13: MutBorrow.t t_T = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body result type invariant] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body ensures] match self_.current with
        | C_None -> postcondition_once f () result.current /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final)
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_take_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_Option) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: MutBorrow.t t_Option) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  let rec replace (dest: MutBorrow.t t_Option) (src: t_Option) (return (x: t_Option)) =
    {[@expl:replace 'dest' type invariant] inv'1 dest}
    {[@expl:replace 'src' type invariant] inv'0 src}
    any [ return (result: t_Option) -> {inv'0 result} {dest.final = src} {result = dest.current} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_Option) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_take_body (self_: MutBorrow.t t_Option) (return (x: t_Option)) =
    {[@expl:extern_spec_std_option_T_Option_T_take_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- C_None ] s1
      | s1 = {inv'0 self_.current}
        MutBorrow.borrow_final <t_Option> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_3 <- _ret ] -{inv'0 _ret.final}-
            [ &self_ <- { self_ with current = _ret.final } ] s2)
      | s2 = replace {_3} {_4} (fun (_ret: t_Option) -> [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self_} s1 | s1 = -{resolve self_}- s2 | s2 = return {_0} ] ]
    [ & _0: t_Option = Any.any_l ()
    | & self_: MutBorrow.t t_Option = self_
    | & _3: MutBorrow.t t_Option = Any.any_l ()
    | & _4: t_Option = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_T_take_body result type invariant] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_body ensures] result = self_.current /\ self_.final = C_None}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_take_if_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  type t_P
  
  predicate inv'0 (_1: t_P)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_T) = inv'1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: t_P) (args: MutBorrow.t t_T)
  
  predicate postcondition_once (self: t_P) (args: MutBorrow.t t_T) (result: bool)
  
  let rec call_once (self_: t_P) (arg: MutBorrow.t t_T) (return (x: bool)) =
    {[@expl:call_once 'self_' type invariant] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] inv'2 arg}
    {[@expl:call_once requires] precondition self_ arg}
    any [ return (result: bool) -> {postcondition_once self_ arg result} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate inv'3 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'4 [@inline:trivial] (_1: MutBorrow.t t_Option) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'4
  
  let rec take (self_: MutBorrow.t t_Option) (return (x: t_Option)) = {[@expl:take 'self_' type invariant] inv'4 self_}
    any
    [ return (result: t_Option) -> {inv'3 result} {result = self_.current /\ self_.final = C_None} (! return {result}) ]
  
  predicate resolve'0 [@inline:trivial] (_1: MutBorrow.t t_Option) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 (_1: t_P)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_take_if_body (self_: MutBorrow.t t_Option) (predicate': t_P)
    (return (x: t_Option)) = {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'self_' type invariant] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'predicate' type invariant] inv'0 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body requires] match self_.current with
      | C_None -> true
      | C_Some t -> forall b: MutBorrow.t t_T. inv'1 b /\ b.current = t -> precondition predicate' b
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = C_None} (! bb2) | br1 (x0: t_T) -> {self_.current = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_.current}
          (fun (r0: t_T) ->
            {inv r0}
            MutBorrow.borrow_mut <t_T> {r0}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &t <- _ret ] -{inv _ret.final}-
                [ &self_ <- { self_ with current = C_Some _ret.final } ] s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_10 <- _ret ] -{inv _ret.final}-
            [ &t <- { t with current = _ret.final } ] s2)
      | s2 = [ &_9 <- _10 ] s3
      | s3 = call_once {predicate'} {_9} (fun (_ret: bool) -> [ &_7 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb6) ] ]
    | bb6 = s0
      [ s0 = {inv'3 self_.current}
        MutBorrow.borrow_final <t_Option> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_11 <- _ret ] -{inv'3 _ret.final}-
            [ &self_ <- { self_ with current = _ret.final } ] s1)
      | s1 = take {_11} (fun (_ret: t_Option) -> [ &_0 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0 [ s0 = {[@expl:type invariant] inv'4 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 = bb12 ]
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'4 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = bb12 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 predicate'} s1
      | s1 = -{resolve'1 predicate'}- s2
      | s2 = {[@expl:type invariant] inv'4 self_} s3
      | s3 = -{resolve'0 self_}- s4
      | s4 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: t_Option = Any.any_l ()
    | & self_: MutBorrow.t t_Option = self_
    | & predicate': t_P = predicate'
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l ()
    | & _11: MutBorrow.t t_Option = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_if_body ensures] match self_.current with
        | C_None -> result = C_None /\ self_.final = C_None
        | C_Some cur -> exists b: MutBorrow.t t_T, res: bool. inv'1 b
          /\ cur = b.current
          /\ postcondition_once predicate' b res
          /\ (if res then
            self_.final = C_None /\ result = C_Some (b.final)
          else
            self_.final = C_Some (b.final) /\ result = C_None
          )
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_replace_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_Option) = inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: MutBorrow.t t_Option) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  let rec replace (dest: MutBorrow.t t_Option) (src: t_Option) (return (x: t_Option)) =
    {[@expl:replace 'dest' type invariant] inv'1 dest}
    {[@expl:replace 'src' type invariant] inv'0 src}
    any [ return (result: t_Option) -> {inv'0 result} {dest.final = src} {result = dest.current} (! return {result}) ]
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_Option) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_replace_body (self_: MutBorrow.t t_Option) (value: t_T)
    (return (x: t_Option)) = {[@expl:extern_spec_std_option_T_Option_T_replace_body 'self_' type invariant] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_replace_body 'value' type invariant] inv value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- C_Some value ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'0 self_.current}
        MutBorrow.borrow_final <t_Option> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_4 <- _ret ] -{inv'0 _ret.final}-
            [ &self_ <- { self_ with current = _ret.final } ] s1)
      | s1 = replace {_4} {_5} (fun (_ret: t_Option) -> [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'1 self_} s1 | s1 = -{resolve self_}- s2 | s2 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_Option = Any.any_l ()
    | & self_: MutBorrow.t t_Option = self_
    | & value: t_T = value
    | & _4: MutBorrow.t t_Option = Any.any_l ()
    | & _5: t_Option = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_T_replace_body result type invariant] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_replace_body ensures] result = self_.current
      /\ self_.final = C_Some value}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_T_zip_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_U
  
  type t_Option'0 = C_None'0 | C_Some'0 t_U
  
  type tuple = { f0: t_Option; f1: t_Option'0 }
  
  predicate inv (_1: t_U)
  
  predicate inv'0 (_1: t_Option'0)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option'0 [inv'0 x]. inv'0 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv a_0
        end
  
  predicate resolve (_1: t_U)
  
  predicate resolve'0 (_1: t_Option'0)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option'0 [resolve'0 x]. resolve'0 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 x0 -> resolve x0
        end
  
  predicate inv'1 (_1: t_T)
  
  predicate resolve'1 (_1: t_T)
  
  type tuple'0 = { f0'0: t_T; f1'0: t_U }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple'0
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  let rec v_Some'0 (input: t_Option'0) (ret (field_0: t_U)) = any
    [ good (field_0: t_U) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_U [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'1 a_0
        end
  
  predicate inv'3 [@inline:trivial] (_1: tuple'0) = inv'1 _1.f0'0 /\ inv _1.f1'0
  
  meta "rewrite_def" predicate inv'3
  
  predicate inv'4 (_1: t_Option'1)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'1 [inv'4 x]. inv'4 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'3 a_0
        end
  
  predicate resolve'2 (_1: t_Option)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Option [resolve'2 x]. resolve'2 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve'1 x0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_zip_body (self_: t_Option) (other: t_Option'0) (return (x: t_Option'1)) =
    {[@expl:extern_spec_std_option_T_Option_T_zip_body 'self_' type invariant] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_zip_body 'other' type invariant] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- { f0 = self_; f1 = other } ] s1 | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4.f0 = C_None} (! bb25) | br1 (x0: t_T) -> {_4.f0 = C_Some x0} (! bb4) ]
    | bb25 = s0
      [ s0 = {[@expl:type invariant] inv'0 _4.f1} s1
      | s1 = -{resolve'0 _4.f1}- s2
      | s2 = {[@expl:type invariant] match _4 with
          | {f0 = C_Some x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {f0 = C_Some x} -> resolve'1 x
          | _ -> true
          end}-
        s4
      | s4 = bb3 ]
    | bb4 = any [ br0 -> {_4.f1 = C_None'0} (! bb26) | br1 (x0: t_U) -> {_4.f1 = C_Some'0 x0} (! bb6) ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {f1 = C_Some'0 x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {f1 = C_Some'0 x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {f0 = C_Some x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {f0 = C_Some x} -> resolve'1 x
          | _ -> true
          end}-
        s4
      | s4 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0 <- C_None'1 ] s1 | s1 = bb15 ]
    | bb6 = s0
      [ s0 = v_Some {_4.f0} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = v_Some'0 {_4.f1} (fun (r0: t_U) -> [ &u <- r0 ] s2)
      | s2 = [ &_11 <- { f0'0 = t; f1'0 = u } ] s3
      | s3 = bb8 ]
    | bb8 = s0 [ s0 = [ &_0 <- C_Some'1 _11 ] s1 | s1 = bb15 ]
    | bb15 = return {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self_: t_Option = self_
    | & other: t_Option'0 = other
    | & _4: tuple = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _11: tuple'0 = Any.any_l () ])
    [ return (result: t_Option'1) ->
    {[@expl:extern_spec_std_option_T_Option_T_zip_body result type invariant] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_zip_body ensures] match { f0 = self_; f1 = other } with
        | {f0 = C_None} -> result = C_None'1 /\ resolve'0 other
        | {f1 = C_None'0} -> result = C_None'1 /\ resolve'2 self_
        | {f0 = C_Some t; f1 = C_Some'0 u} -> result = C_Some'1 { f0'0 = t; f1'0 = u }
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  let rec v_Some (input: t_Option) (ret (field_0: tuple)) = any
    [ good (field_0: tuple) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'1 }
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_U)
  
  predicate inv'1 [@inline:trivial] (_1: tuple) = inv _1.f0 /\ inv'0 _1.f1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'1 a_0
        end
  
  predicate inv'3 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv a_0
        end
  
  predicate inv'4 (_1: t_Option'1)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'1 [inv'4 x]. inv'4 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'0 a_0
        end
  
  predicate inv'5 [@inline:trivial] (_1: tuple'0) = inv'3 _1.f0'0 /\ inv'4 _1.f1'0
  
  meta "rewrite_def" predicate inv'5
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body (self_: t_Option) (return (x: tuple'0)) =
    {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body 'self_' type invariant] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb3) | br1 (x0: tuple) -> {self_ = C_Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = v_Some {self_} (fun (r0: tuple) -> [ &t <- r0.f0 ] s1)
      | s1 = v_Some {self_} (fun (r0: tuple) -> [ &u <- r0.f1 ] s2)
      | s2 = [ &_6 <- C_Some'0 t ] s3
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = [ &_8 <- C_Some'1 u ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &_0 <- { f0'0 = _6; f1'0 = _8 } ] s1 | s1 = bb14 ]
    | bb3 = s0
      [ s0 = [ &_10 <- C_None'0 ] s1
      | s1 = [ &_11 <- C_None'1 ] s2
      | s2 = [ &_0 <- { f0'0 = _10; f1'0 = _11 } ] s3
      | s3 = bb14 ]
    | bb14 = return {_0} ]
    [ & _0: tuple'0 = Any.any_l ()
    | & self_: t_Option = self_
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l ()
    | & _8: t_Option'1 = Any.any_l ()
    | & _10: t_Option'0 = Any.any_l ()
    | & _11: t_Option'1 = Any.any_l () ])
    [ return (result: tuple'0) ->
    {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body result type invariant] inv'5 result}
      {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body ensures] match self_ with
        | C_None -> result = { f0'0 = C_None'0; f1'0 = C_None'1 }
        | C_Some {f0 = t; f1 = u} -> result = { f0'0 = C_Some'0 t; f1'0 = C_Some'1 u }
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Optionqy95z_ref_T_copied_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  predicate inv'2 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_copied_body (self_: t_Option) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- C_Some'0 t ] s2 | s2 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None'0 ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ] [ & _0: t_Option'0 = Any.any_l () | & self_: t_Option = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body result type invariant] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body ensures] match self_ with
        | C_None -> result = C_None'0
        | C_Some s -> result = C_Some'0 s
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  let rec v_Some (input: t_Option) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate precondition (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
      -> precondition () args
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  let rec clone' (self_: t_T) (return (x: t_T)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_T) -> {postcondition_once () self_ result} (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  predicate inv'1 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  predicate inv'2 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv a_0
        end
  
  type tuple = { f0: t_Option; f1: t_Option'0 }
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body (self_: t_Option) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = clone' {t} (fun (_ret: t_T) -> [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_Some'0 _5 ] s1 | s1 = bb7 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None'0 ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_: t_Option = self_
    | & t: t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body result type invariant] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body ensures] match { f0 = self_; f1 = result } with
        | {f0 = C_None; f1 = C_None'0} -> true
        | {f0 = C_Some s; f1 = C_Some'0 r} -> postcondition () s r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some (MutBorrow.t t_T)
  
  let rec v_Some (input: t_Option) (ret (field_0: MutBorrow.t t_T)) = any
    [ good (field_0: MutBorrow.t t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  predicate inv'1 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  predicate inv'2 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body (self_: t_Option) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: MutBorrow.t t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_} (fun (r0: MutBorrow.t t_T) -> [ &t <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 t} s2
      | s2 = -{resolve t}- s3
      | s3 = [ &_0 <- C_Some'0 (t.current) ] s4
      | s4 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None'0 ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: t_Option'0 = Any.any_l () | & self_: t_Option = self_ | & t: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body result type invariant] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body ensures] match self_ with
        | C_None -> result = C_None'0
        | C_Some s -> result = C_Some'0 (s.current) /\ s.final = s.current
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some (MutBorrow.t t_T)
  
  let rec v_Some (input: t_Option) (ret (field_0: MutBorrow.t t_T)) = any
    [ good (field_0: MutBorrow.t t_T) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate precondition (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'1 self_)
      -> precondition () args
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  let rec clone' (self_: t_T) (return (x: t_T)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_T) -> {postcondition_once () self_ result} (! return {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'0 a_0
        end
  
  predicate inv'3 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv a_0
        end
  
  type tuple = { f0: t_Option; f1: t_Option'0 }
  
  predicate resolve'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve'0
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve'0 self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body (self_: t_Option) (return (x: t_Option'0)) =
    {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body 'self_' type invariant] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb4) | br1 (x0: MutBorrow.t t_T) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = v_Some {self_} (fun (r0: MutBorrow.t t_T) -> [ &t <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 t} s2
      | s2 = -{resolve t}- s3
      | s3 = clone' {t.current} (fun (_ret: t_T) -> [ &_5 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- C_Some'0 _5 ] s1 | s1 = bb7 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None'0 ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_: t_Option = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ])
    [ return (result: t_Option'0) ->
    {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body result type invariant] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body ensures] match { f0 = self_; f1 = result } with
        | {f0 = C_None; f1 = C_None'0} -> true
        | {f0 = C_Some s; f1 = C_Some'0 r} -> postcondition () s.current r /\ s.final = s.current
        | _ -> false
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_E_Option_Result_T_E_transpose_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result = C_Ok t_T | C_Err t_E
  
  type t_Option = C_None | C_Some t_Result
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Result)) = any
    [ good (field_0: t_Result) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Result [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  let rec v_Err (input: t_Result) (ret (field_0: t_E)) = any
    [ good (field_0: t_E) -> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  type t_Result'0 = C_Ok'0 t_Option'0 | C_Err'0 t_E
  
  let rec v_Ok (input: t_Result) (ret (field_0: t_T)) = any
    [ good (field_0: t_T) -> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Ok field_0: t_Result]. C_Ok field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_E)
  
  predicate inv'1 (_1: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
      = match x with
        | C_Ok a_0 -> inv a_0
        | C_Err a_0 -> inv'0 a_0
        end
  
  predicate inv'2 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'1 a_0
        end
  
  predicate inv'3 (_1: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv a_0
        end
  
  predicate inv'4 (_1: t_Result'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Result'0 [inv'4 x]. inv'4 x
      = match x with
        | C_Ok'0 a_0 -> inv'3 a_0
        | C_Err'0 a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_E_Option_Result_T_E_transpose_body (self_: t_Option) (return (x: t_Result'0)) =
    {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body 'self_' type invariant] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None} (! bb7) | br1 (x0: t_Result) -> {self_ = C_Some x0} (! bb3) ]
    | bb3 = v_Some {self_}
        (fun (r0: t_Result) ->
          any [ br0 (x0: t_T) -> {r0 = C_Ok x0} (! bb6) | br1 (x0: t_E) -> {r0 = C_Err x0} (! bb5) ])
    | bb5 = s0
      [ s0 = v_Some {self_} (fun (r0: t_Result) -> v_Err {r0} (fun (r0'0: t_E) -> [ &err <- r0'0 ] s1))
      | s1 = [ &_0 <- C_Err'0 err ] s2
      | s2 = bb15 ]
    | bb6 = s0
      [ s0 = v_Some {self_} (fun (r0: t_Result) -> v_Ok {r0} (fun (r0'0: t_T) -> [ &ok <- r0'0 ] s1))
      | s1 = [ &_7 <- C_Some'0 ok ] s2
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- C_Ok'0 _7 ] s1 | s1 = bb15 ]
    | bb7 = s0 [ s0 = [ &_5 <- C_None'0 ] s1 | s1 = [ &_0 <- C_Ok'0 _5 ] s2 | s2 = bb15 ]
    | bb15 = return {_0} ]
    [ & _0: t_Result'0 = Any.any_l ()
    | & self_: t_Option = self_
    | & _5: t_Option'0 = Any.any_l ()
    | & ok: t_T = Any.any_l ()
    | & _7: t_Option'0 = Any.any_l ()
    | & err: t_E = Any.any_l () ])
    [ return (result: t_Result'0) ->
    {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body result type invariant] inv'4 result}
      {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body ensures] match self_ with
        | C_None -> result = C_Ok'0 (C_None'0)
        | C_Some (C_Ok ok) -> result = C_Ok'0 (C_Some'0 ok)
        | C_Some (C_Err err) -> result = C_Err'0 err
        end}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__extern_spec_std_option_T_Option_Option_T_flatten_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  let rec v_Some (input: t_Option'0) (ret (field_0: t_Option)) = any
    [ good (field_0: t_Option) -> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Option [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  predicate inv'1 (_1: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'1 x]. inv'1 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'0 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_Option_T_flatten_body (self_: t_Option'0) (return (x: t_Option)) =
    {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body 'self_' type invariant] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0: t_Option) -> {self_ = C_Some'0 x0} (! bb3) ]
    | bb3 = s0 [ s0 = v_Some {self_} (fun (r0: t_Option) -> [ &opt <- r0 ] s1) | s1 = [ &_0 <- opt ] s2 | s2 = bb7 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_None ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option = Any.any_l () | & self_: t_Option'0 = self_ | & opt: t_Option = Any.any_l () ])
    [ return (result: t_Option) ->
    {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body result type invariant] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #0] self_ = C_None'0 -> result = C_None}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #1] self_ = C_None'0
      \/ self_ = C_Some'0 result}
      (! return {result}) ]
end
module M_creusot_contracts__std__option__qyi15687504979643803552__cmp_le_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  predicate le_log'0 (self: t_Option) (o: t_Option) = cmp_log'0 self o <> C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  constant y : t_Option
  
  function cmp_le_log'0 (x: t_Option) (y: t_Option) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__cmp_lt_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  predicate lt_log'0 (self: t_Option) (o: t_Option) = cmp_log'0 self o = C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  constant y : t_Option
  
  function cmp_lt_log'0 (x: t_Option) (y: t_Option) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__cmp_ge_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  predicate ge_log'0 (self: t_Option) (o: t_Option) = cmp_log'0 self o <> C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  constant y : t_Option
  
  function cmp_ge_log'0 (x: t_Option) (y: t_Option) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__cmp_gt_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  predicate gt_log'0 (self: t_Option) (o: t_Option) = cmp_log'0 self o = C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  constant y : t_Option
  
  function cmp_gt_log'0 (x: t_Option) (y: t_Option) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__refl (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  function refl'0 (x: t_Option) : ()
  
  goal vc_refl: [@expl:refl ensures] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__std__option__qyi15687504979643803552__trans (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  constant y : t_Option
  
  constant z : t_Option
  
  constant o : t_Ordering
  
  function trans'0 (x: t_Option) (y: t_Option) (z: t_Option) (o: t_Ordering) : ()
  
  goal vc_trans: cmp_log'0 x y = o -> cmp_log'0 y z = o -> ([@expl:trans ensures] cmp_log'0 x z = o)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__antisym1 (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  constant y : t_Option
  
  function antisym1'0 (x: t_Option) (y: t_Option) : ()
  
  goal vc_antisym1: cmp_log'0 x y = C_Less -> ([@expl:antisym1 ensures] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__antisym2 (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  constant y : t_Option
  
  function antisym2'0 (x: t_Option) (y: t_Option) : ()
  
  goal vc_antisym2: cmp_log'0 x y = C_Greater -> ([@expl:antisym2 ensures] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__eq_cmp (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option
  
  constant y : t_Option
  
  function eq_cmp'0 (x: t_Option) (y: t_Option) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__std__option__qyi16875853811649438191__produces_refl (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_IntoIter) : t_Option
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter
  
  function produces_refl (self: t_IntoIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__option__qyi16875853811649438191__produces_trans (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_IntoIter) : t_Option
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq t_T) (b: t_IntoIter) (bc: Seq.seq t_T) (c: t_IntoIter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__option__qyi14990757896004605758__produces_refl (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_Iter) : t_Option
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter
  
  function produces_refl (self: t_Iter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__option__qyi14990757896004605758__produces_trans (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_Iter) : t_Option
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter
  
  function produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__option__qyi3871448523939226478__produces_refl (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut
  
  type t_T
  
  type t_Option = C_None | C_Some (MutBorrow.t t_T)
  
  function view (self: t_IterMut) : t_Option
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut
  
  function produces_refl (self: t_IterMut) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__std__option__qyi3871448523939226478__produces_trans (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut
  
  type t_T
  
  type t_Option = C_None | C_Some (MutBorrow.t t_T)
  
  function view (self: t_IterMut) : t_Option
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut
  
  constant ab : Seq.seq (MutBorrow.t t_T)
  
  constant b : t_IterMut
  
  constant bc : Seq.seq (MutBorrow.t t_T)
  
  constant c : t_IterMut
  
  function produces_trans (a: t_IterMut) (ab: Seq.seq (MutBorrow.t t_T)) (b: t_IterMut) (bc: Seq.seq (MutBorrow.t t_T)) (c: t_IterMut) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__option__qyi748817807773504354__unwrap_logic (* <std::option::Option<T> as std::option::OptionExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  predicate index_logic [@inline:trivial] (self: Map.map t_T bool) (a: t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_T bool) : t_T
  
  axiom such_that_spec: forall p: Map.map t_T bool. (exists x: t_T. index_logic p x) -> index_logic p (such_that p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option
  
  function unwrap_logic (self: t_Option) : t_T
  
  goal vc_unwrap_logic: self <> C_None
    -> match self with
      | C_Some x -> true
      | C_None -> [@expl:such_that requires] exists x: t_T. index_logic (fun (__0: t_T) -> true) x
      end
end
module M_creusot_contracts__std__ptr__extern_spec_Tqy95z_ptrconst_T_cast_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Tqy95z_ptrconst_T_cast_body (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- Opaque.thin self_ ] s1 | s1 = [ &_0 <- _4 ] s2 | s2 = return {_0} ] ]
    [ & _0: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ | & _4: Opaque.ptr = Any.any_l () ])
    [ return (result: Opaque.ptr) -> {[@expl:extern_spec_T__ptrconst_T_cast_body ensures] result = Opaque.thin self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__ptr__extern_spec_Tqy95z_ptrconst_T_is_aligned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_logic : UInt64.t
  
  axiom align_of_logic_spec: (0: UInt64.t) <> align_of_logic
    /\ UInt64.bw_and align_of_logic (UInt64.sub align_of_logic (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_logic_spec'0: Int.mod size_of_T (UInt64.t'int align_of_logic) = 0
  
  let rec align_of (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = align_of_logic} (! return {result}) ]
  
  predicate is_aligned_to_logic (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  let rec is_aligned_to (self_: Opaque.ptr) (align: UInt64.t) (return (x: bool)) = {[@expl:is_aligned_to requires] align
      <> (0: UInt64.t)
    /\ UInt64.bw_and align (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)}
    any [ return (result: bool) -> {result = is_aligned_to_logic self_ align} (! return {result}) ]
  
  predicate is_aligned_logic [@inline:trivial] (ptr: Opaque.ptr) = is_aligned_to_logic ptr align_of_logic
  
  meta "rewrite_def" predicate is_aligned_logic
  
  predicate is_aligned_logic'0 [@inline:trivial] (self: Opaque.ptr) = is_aligned_logic self
  
  meta "rewrite_def" predicate is_aligned_logic'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Tqy95z_ptrconst_T_is_aligned_body (self_: Opaque.ptr) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = align_of (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = is_aligned_to {self_} {_5} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: bool = Any.any_l () | & self_: Opaque.ptr = self_ | & _5: UInt64.t = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T__ptrconst_T_is_aligned_body ensures] result
      = is_aligned_logic'0 self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__ptr__extern_spec_Tqy95z_ptrconst_T_is_aligned_to_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64BW
  use creusot.prelude.Opaque
  use creusot.prelude.PtrBW
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use seq.Seq
  
  let rec is_power_of_two (self_: UInt64BW.t) (return (x: bool)) = any
    [ return (result: bool) -> {result
      = (self_ <> (0: UInt64BW.t) /\ UInt64BW.bw_and self_ (UInt64BW.sub self_ (1: UInt64BW.t)) = (0: UInt64BW.t))}
      (! return {result}) ]
  
  let rec addr (self_: Opaque.ptr) (return (x: UInt64BW.t)) = any
    [ return (result: UInt64BW.t) -> {result = PtrBW.addr_logic_u64 self_} (! return {result}) ]
  
  type t_Arguments
  
  predicate inv [@inline:trivial] (_1: Seq.seq string) = true
  
  meta "rewrite_def" predicate inv
  
  predicate invariant' (self: Slice64.array string) =
    inv (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64BW.t'int (1: UInt64BW.t)
  
  predicate inv'0 [@inline:trivial] (_1: Slice64.array string) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Slice64.array string) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Slice64.array string) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64BW.t) (o: UInt64BW.t) : t_Ordering = if UInt64BW.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64BW.t, y: UInt64BW.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom antisym2_spec: forall x: UInt64BW.t, y: UInt64BW.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom antisym1_spec: forall x: UInt64BW.t, y: UInt64BW.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64BW.t) (y: UInt64BW.t) (z: UInt64BW.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64BW.t, y: UInt64BW.t, z: UInt64BW.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64BW.t) : ()
  
  axiom refl_spec: forall x: UInt64BW.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.le x y = (cmp_log x y <> C_Greater)
  
  predicate inv'2 (_1: t_Arguments)
  
  let rec new_const (pieces: Slice64.array string) (return (x: t_Arguments)) =
    {[@expl:new_const 'pieces' type invariant] inv'1 pieces}
    {[@expl:new_const requires] UInt64BW.le (1: UInt64BW.t) (1: UInt64BW.t)}
    any [ return (result: t_Arguments) -> {inv'2 result} (! return {result}) ]
  
  predicate is_aligned_to_logic (self: Opaque.ptr) (align: UInt64BW.t) =
    UInt64BW.bw_and (PtrBW.addr_logic_u64 self) (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Tqy95z_ptrconst_T_is_aligned_to_body (self_: Opaque.ptr) (align: UInt64BW.t) (return (x: bool)) =
    {[@expl:extern_spec_T__ptrconst_T_is_aligned_to_body requires] align <> (0: UInt64BW.t)
    /\ UInt64BW.bw_and align (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = is_power_of_two {align} (fun (_ret: bool) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_7 = false} (! bb3) | br1 -> {_7} (! bb2) ]
    | bb2 = s0 [ s0 = addr {self_} (fun (_ret: UInt64BW.t) -> [ &_17 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = UInt64BW.sub {align} {(1: UInt64BW.t)} (fun (_ret: UInt64BW.t) -> [ &_19 <- _ret ] s1)
      | s1 = [ &_16 <- UInt64BW.bw_and _17 _19 ] s2
      | s2 = [ &_0 <- _16 = (0: UInt64BW.t) ] s3
      | s3 = return {_0} ]
    | bb3 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array string) -> (! -{Seq.get __arr_temp.Slice64.elts 0
                = "is_aligned_to: align is not a power-of-two"
              /\ Seq.length __arr_temp.Slice64.elts = 1}-
              [ &self_ <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- self_ ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array string = Any.any_l () | & self_: Slice64.array string = Any.any_l () ]
        [ _const_ret (_const: Slice64.array string) -> [ &_21 <- _const ] s1 ]
      | s1 = [ &_14 <- _21 ] s2
      | s2 = new_const {_14} (fun (_ret: t_Arguments) -> [ &_12 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = {false} any ]
    [ & _0: bool = Any.any_l ()
    | & self_: Opaque.ptr = self_
    | & align: UInt64BW.t = align
    | & _7: bool = Any.any_l ()
    | & _12: t_Arguments = Any.any_l ()
    | & _14: Slice64.array string = Any.any_l ()
    | & _16: UInt64BW.t = Any.any_l ()
    | & _17: UInt64BW.t = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: Slice64.array string = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T__ptrconst_T_is_aligned_to_body ensures] result
      = is_aligned_to_logic self_ align}
      (! return {result}) ]
end
module M_creusot_contracts__std__ptr__extern_spec_Tqy95z_ptrmut_T_cast_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Tqy95z_ptrmut_T_cast_body (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- Opaque.thin self_ ] s1 | s1 = [ &_0 <- _4 ] s2 | s2 = return {_0} ] ]
    [ & _0: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ | & _4: Opaque.ptr = Any.any_l () ])
    [ return (result: Opaque.ptr) -> {[@expl:extern_spec_T__ptrmut_T_cast_body ensures] result = Opaque.thin self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__ptr__extern_spec_Tqy95z_ptrmut_T_is_aligned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_logic : UInt64.t
  
  axiom align_of_logic_spec: (0: UInt64.t) <> align_of_logic
    /\ UInt64.bw_and align_of_logic (UInt64.sub align_of_logic (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_logic_spec'0: Int.mod size_of_T (UInt64.t'int align_of_logic) = 0
  
  let rec align_of (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = align_of_logic} (! return {result}) ]
  
  predicate is_aligned_to_logic (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  let rec is_aligned_to (self_: Opaque.ptr) (align: UInt64.t) (return (x: bool)) = {[@expl:is_aligned_to requires] align
      <> (0: UInt64.t)
    /\ UInt64.bw_and align (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)}
    any [ return (result: bool) -> {result = is_aligned_to_logic self_ align} (! return {result}) ]
  
  predicate is_aligned_to_logic'0 (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  predicate is_aligned_logic [@inline:trivial] (ptr: Opaque.ptr) = is_aligned_to_logic'0 ptr align_of_logic
  
  meta "rewrite_def" predicate is_aligned_logic
  
  predicate is_aligned_logic'0 [@inline:trivial] (self: Opaque.ptr) = is_aligned_logic self
  
  meta "rewrite_def" predicate is_aligned_logic'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Tqy95z_ptrmut_T_is_aligned_body (self_: Opaque.ptr) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = align_of (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = is_aligned_to {self_} {_5} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: bool = Any.any_l () | & self_: Opaque.ptr = self_ | & _5: UInt64.t = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T__ptrmut_T_is_aligned_body ensures] result
      = is_aligned_logic'0 self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__ptr__extern_spec_Tqy95z_ptrmut_T_is_aligned_to_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64BW
  use creusot.prelude.Opaque
  use creusot.prelude.PtrBW
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use seq.Seq
  
  let rec is_power_of_two (self_: UInt64BW.t) (return (x: bool)) = any
    [ return (result: bool) -> {result
      = (self_ <> (0: UInt64BW.t) /\ UInt64BW.bw_and self_ (UInt64BW.sub self_ (1: UInt64BW.t)) = (0: UInt64BW.t))}
      (! return {result}) ]
  
  let rec addr (self_: Opaque.ptr) (return (x: UInt64BW.t)) = any
    [ return (result: UInt64BW.t) -> {result = PtrBW.addr_logic_u64 self_} (! return {result}) ]
  
  type t_Arguments
  
  predicate inv [@inline:trivial] (_1: Seq.seq string) = true
  
  meta "rewrite_def" predicate inv
  
  predicate invariant' (self: Slice64.array string) =
    inv (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64BW.t'int (1: UInt64BW.t)
  
  predicate inv'0 [@inline:trivial] (_1: Slice64.array string) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Slice64.array string) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Slice64.array string) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64BW.t) (o: UInt64BW.t) : t_Ordering = if UInt64BW.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64BW.t, y: UInt64BW.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom antisym2_spec: forall x: UInt64BW.t, y: UInt64BW.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom antisym1_spec: forall x: UInt64BW.t, y: UInt64BW.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64BW.t) (y: UInt64BW.t) (z: UInt64BW.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64BW.t, y: UInt64BW.t, z: UInt64BW.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64BW.t) : ()
  
  axiom refl_spec: forall x: UInt64BW.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.le x y = (cmp_log x y <> C_Greater)
  
  predicate inv'2 (_1: t_Arguments)
  
  let rec new_const (pieces: Slice64.array string) (return (x: t_Arguments)) =
    {[@expl:new_const 'pieces' type invariant] inv'1 pieces}
    {[@expl:new_const requires] UInt64BW.le (1: UInt64BW.t) (1: UInt64BW.t)}
    any [ return (result: t_Arguments) -> {inv'2 result} (! return {result}) ]
  
  predicate is_aligned_to_logic (self: Opaque.ptr) (align: UInt64BW.t) =
    UInt64BW.bw_and (PtrBW.addr_logic_u64 self) (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Tqy95z_ptrmut_T_is_aligned_to_body (self_: Opaque.ptr) (align: UInt64BW.t) (return (x: bool)) =
    {[@expl:extern_spec_T__ptrmut_T_is_aligned_to_body requires] align <> (0: UInt64BW.t)
    /\ UInt64BW.bw_and align (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = is_power_of_two {align} (fun (_ret: bool) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_7 = false} (! bb3) | br1 -> {_7} (! bb2) ]
    | bb2 = s0 [ s0 = addr {self_} (fun (_ret: UInt64BW.t) -> [ &_17 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = UInt64BW.sub {align} {(1: UInt64BW.t)} (fun (_ret: UInt64BW.t) -> [ &_19 <- _ret ] s1)
      | s1 = [ &_16 <- UInt64BW.bw_and _17 _19 ] s2
      | s2 = [ &_0 <- _16 = (0: UInt64BW.t) ] s3
      | s3 = return {_0} ]
    | bb3 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array string) -> (! -{Seq.get __arr_temp.Slice64.elts 0
                = "is_aligned_to: align is not a power-of-two"
              /\ Seq.length __arr_temp.Slice64.elts = 1}-
              [ &self_ <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- self_ ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array string = Any.any_l () | & self_: Slice64.array string = Any.any_l () ]
        [ _const_ret (_const: Slice64.array string) -> [ &_21 <- _const ] s1 ]
      | s1 = [ &_14 <- _21 ] s2
      | s2 = new_const {_14} (fun (_ret: t_Arguments) -> [ &_12 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = {false} any ]
    [ & _0: bool = Any.any_l ()
    | & self_: Opaque.ptr = self_
    | & align: UInt64BW.t = align
    | & _7: bool = Any.any_l ()
    | & _12: t_Arguments = Any.any_l ()
    | & _14: Slice64.array string = Any.any_l ()
    | & _16: UInt64BW.t = Any.any_l ()
    | & _17: UInt64BW.t = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: Slice64.array string = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T__ptrmut_T_is_aligned_to_body ensures] result
      = is_aligned_to_logic self_ align}
      (! return {result}) ]
end
module M_creusot_contracts__std__ptr__extern_spec_T_Cloneqy95z_ptrmut_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Cloneqy95z_ptrmut_T_clone_body (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ ])
    [ return (result: Opaque.ptr) -> {[@expl:extern_spec_T_Clone__ptrmut_T_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__ptr__extern_spec_T_Cloneqy95z_ptrconst_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Cloneqy95z_ptrconst_T_clone_body (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ ])
    [ return (result: Opaque.ptr) -> {[@expl:extern_spec_T_Clone__ptrconst_T_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_creusot_contracts__std__range__extern_spec_T_From_Range_T_legacy_Range_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Range = { t_Range__start: t_T; t_Range__end: t_T }
  
  type t_Range'0 = { t_Range__start'0: t_T; t_Range__end'0: t_T }
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Range)
  
  axiom inv_axiom [@rewrite]: forall x: t_Range [inv'0 x]. inv'0 x = (inv x.t_Range__start /\ inv x.t_Range__end)
  
  predicate inv'1 (_1: t_Range'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Range'0 [inv'1 x]. inv'1 x
      = (inv x.t_Range__start'0 /\ inv x.t_Range__end'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_Range_T_legacy_Range_T_from_body (value: t_Range) (return (x: t_Range'0)) =
    {[@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body 'value' type invariant] inv'0 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = [ &_0 <- { t_Range__start'0 = value.t_Range__start; t_Range__end'0 = value.t_Range__end } ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ] [ & _0: t_Range'0 = Any.any_l () | & value: t_Range = value ])
    [ return (result: t_Range'0) ->
    {[@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body result type invariant] inv'1 result}
      {[@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body ensures] result
      = { t_Range__start'0 = value.t_Range__start; t_Range__end'0 = value.t_Range__end }}
      (! return {result}) ]
end
module M_creusot_contracts__std__range__extern_spec_T_From_legacy_Range_T_Range_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Range = { t_Range__start: t_T; t_Range__end: t_T }
  
  type t_Range'0 = { t_Range__start'0: t_T; t_Range__end'0: t_T }
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_Range)
  
  axiom inv_axiom [@rewrite]: forall x: t_Range [inv'0 x]. inv'0 x = (inv x.t_Range__start /\ inv x.t_Range__end)
  
  predicate inv'1 (_1: t_Range'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Range'0 [inv'1 x]. inv'1 x
      = (inv x.t_Range__start'0 /\ inv x.t_Range__end'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_legacy_Range_T_Range_T_from_body (value: t_Range) (return (x: t_Range'0)) =
    {[@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body 'value' type invariant] inv'0 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = [ &_0 <- { t_Range__start'0 = value.t_Range__start; t_Range__end'0 = value.t_Range__end } ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ] [ & _0: t_Range'0 = Any.any_l () | & value: t_Range = value ])
    [ return (result: t_Range'0) ->
    {[@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body result type invariant] inv'1 result}
      {[@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body ensures] result
      = { t_Range__start'0 = value.t_Range__start; t_Range__end'0 = value.t_Range__end }}
      (! return {result}) ]
end
module M_creusot_contracts__std__range__extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeFrom = { t_RangeFrom__start: t_T }
  
  type t_RangeFrom'0 = { t_RangeFrom__start'0: t_T }
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_RangeFrom)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeFrom [inv'0 x]. inv'0 x = inv x.t_RangeFrom__start
  
  predicate inv'1 (_1: t_RangeFrom'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_RangeFrom'0 [inv'1 x]. inv'1 x = inv x.t_RangeFrom__start'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body (value: t_RangeFrom) (return (x: t_RangeFrom'0)) =
    {[@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body 'value' type invariant] inv'0 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = [ &_0 <- { t_RangeFrom__start'0 = value.t_RangeFrom__start } ] s1 | s1 = bb3 ]
    | bb3 = return {_0} ] [ & _0: t_RangeFrom'0 = Any.any_l () | & value: t_RangeFrom = value ])
    [ return (result: t_RangeFrom'0) ->
    {[@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body result type invariant] inv'1 result}
      {[@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body ensures] result
      = { t_RangeFrom__start'0 = value.t_RangeFrom__start }}
      (! return {result}) ]
end
module M_creusot_contracts__std__range__extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeFrom = { t_RangeFrom__start: t_T }
  
  type t_RangeFrom'0 = { t_RangeFrom__start'0: t_T }
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_RangeFrom)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeFrom [inv'0 x]. inv'0 x = inv x.t_RangeFrom__start
  
  predicate inv'1 (_1: t_RangeFrom'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_RangeFrom'0 [inv'1 x]. inv'1 x = inv x.t_RangeFrom__start'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body (value: t_RangeFrom) (return (x: t_RangeFrom'0)) =
    {[@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body 'value' type invariant] inv'0 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = [ &_0 <- { t_RangeFrom__start'0 = value.t_RangeFrom__start } ] s1 | s1 = bb3 ]
    | bb3 = return {_0} ] [ & _0: t_RangeFrom'0 = Any.any_l () | & value: t_RangeFrom = value ])
    [ return (result: t_RangeFrom'0) ->
    {[@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body result type invariant] inv'1 result}
      {[@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body ensures] result
      = { t_RangeFrom__start'0 = value.t_RangeFrom__start }}
      (! return {result}) ]
end
module M_creusot_contracts__std__range__extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeInclusive = { t_RangeInclusive__start: t_T; t_RangeInclusive__last: t_T }
  
  type t_RangeInclusive'0
  
  predicate inv (_1: t_T)
  
  predicate inv'0 (_1: t_RangeInclusive'0)
  
  function start_log (self: t_RangeInclusive'0) : t_T
  
  function end_log (self: t_RangeInclusive'0) : t_T
  
  type t_DeepModelTy
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate is_empty_log (self: t_RangeInclusive'0)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive'0. not is_empty_log self
      -> le_log (deep_model (start_log self)) (deep_model (end_log self))
  
  let rec new (start: t_T) (end': t_T) (return (x: t_RangeInclusive'0)) = {[@expl:new 'start' type invariant] inv start}
    {[@expl:new 'end' type invariant] inv end'}
    any
    [ return (result: t_RangeInclusive'0) -> {inv'0 result}
      {start_log result = start}
      {end_log result = end'}
      {le_log (deep_model start) (deep_model end') -> not is_empty_log result}
      (! return {result}) ]
  
  predicate inv'1 (_1: t_RangeInclusive)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeInclusive [inv'1 x]. inv'1 x
      = (inv x.t_RangeInclusive__start /\ inv x.t_RangeInclusive__last)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body (value: t_RangeInclusive)
    (return (x: t_RangeInclusive'0)) =
    {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body 'value' type invariant] inv'1 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = new {value.t_RangeInclusive__start} {value.t_RangeInclusive__last}
          (fun (_ret: t_RangeInclusive'0) -> [ &_0 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = return {_0} ] [ & _0: t_RangeInclusive'0 = Any.any_l () | & value: t_RangeInclusive = value ])
    [ return (result: t_RangeInclusive'0) ->
    {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body result type invariant] inv'0 result}
      {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #0] start_log result
      = value.t_RangeInclusive__start}
      {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #1] end_log result
      = value.t_RangeInclusive__last}
      {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #2] le_log (deep_model value.t_RangeInclusive__start) (deep_model value.t_RangeInclusive__last)
      -> not is_empty_log result}
      (! return {result}) ]
end
module M_creusot_contracts__std__slice__qyi314041225306698538__as_ptr_own (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn
  
  type tuple = { f0: Opaque.ptr; f1: t_PtrOwn }
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 (self: Slice64.slice t_T) = inv'1 (Slice64.view self)
  
  predicate inv'2 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: Slice64.slice t_T) = inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches
  
  function val' (self: t_PtrOwn) : Slice64.slice t_T
  
  function metadata_logic (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_logic [@inline:trivial] (val''0: Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val''0)
  
  meta "rewrite_def" function size_of_val_logic
  
  axiom size_of_val_logic_spec: forall val''0: Slice64.slice t_T. 0 <= size_of_val_logic val''0
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant''3 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self
    /\ metadata_matches (val' self) (metadata_logic (ptr self))
    /\ size_of_val_logic (val' self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr self)) + size_of_val_logic (val' self) <= UInt64.t'int const_MAX'0
    /\ inv'3 (val' self)
  
  predicate inv'4 (_1: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_PtrOwn) = inv'4 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'5 [@inline:trivial] (_1: t_PtrOwn) = invariant''4 _1
  
  meta "rewrite_def" predicate inv'5
  
  predicate invariant''5 [@inline:trivial] (self: t_PtrOwn) = inv'5 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'6 [@inline:trivial] (_1: t_PtrOwn) = invariant''5 _1
  
  meta "rewrite_def" predicate inv'6
  
  predicate inv'7 [@inline:trivial] (_1: tuple) = inv'6 _1.f1
  
  meta "rewrite_def" predicate inv'7
  
  let rec from_ref (r: Slice64.slice t_T) (return (x: tuple)) = {[@expl:from_ref 'r' type invariant] inv'3 r}
    any
    [ return (result: tuple) -> {inv'7 result} {ptr result.f1 = result.f0} {val' result.f1 = r} (! return {result}) ]
  
  type tuple'0 = { f0'0: Opaque.ptr; f1'0: t_PtrOwn }
  
  predicate inv'8 [@inline:trivial] (_1: tuple'0) = inv'6 _1.f1'0
  
  meta "rewrite_def" predicate inv'8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_ptr_own (self: Slice64.slice t_T) (return (x: tuple'0)) =
    {[@expl:as_ptr_own 'self' type invariant] inv'3 self}
    (! bb0
    [ bb0 = s0 [ s0 = from_ref {self} (fun (_ret: tuple) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &ptr'0 <- _7.f0 ] s1
      | s1 = [ &own <- _7.f1 ] s2
      | s2 = [ &_9 <- Opaque.thin ptr'0 ] s3
      | s3 = [ &_0 <- { f0'0 = _9; f1'0 = own } ] s4
      | s4 = return {_0} ] ]
    [ & _0: tuple'0 = Any.any_l ()
    | & self: Slice64.slice t_T = self
    | & ptr'0: Opaque.ptr = Any.any_l ()
    | & own: t_PtrOwn = Any.any_l ()
    | & _7: tuple = Any.any_l ()
    | & _9: Opaque.ptr = Any.any_l () ])
    [ return (result: tuple'0) -> {[@expl:as_ptr_own result type invariant] inv'8 result}
      {[@expl:as_ptr_own ensures #0] result.f0'0 = Opaque.thin (ptr result.f1'0)}
      {[@expl:as_ptr_own ensures #1] self = val' result.f1'0}
      (! return {result}) ]
end
module M_creusot_contracts__std__slice__qyi314041225306698538__as_mut_ptr_own (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 (self: Slice64.slice t_T) = inv'1 (Slice64.view self)
  
  predicate inv'2 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  type t_PtrOwn
  
  type tuple = { f0: Opaque.ptr; f1: MutBorrow.t t_PtrOwn }
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches
  
  function val' (self: t_PtrOwn) : Slice64.slice t_T
  
  function metadata_logic (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_logic [@inline:trivial] (val''0: Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val''0)
  
  meta "rewrite_def" function size_of_val_logic
  
  axiom size_of_val_logic_spec: forall val''0: Slice64.slice t_T. 0 <= size_of_val_logic val''0
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant''3 [@inline:trivial] (self: Slice64.slice t_T) = inv'2 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'4 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''3 _1
  
  meta "rewrite_def" predicate inv'4
  
  predicate invariant''4 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self
    /\ metadata_matches (val' self) (metadata_logic (ptr self))
    /\ size_of_val_logic (val' self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr self)) + size_of_val_logic (val' self) <= UInt64.t'int const_MAX'0
    /\ inv'4 (val' self)
  
  predicate inv'5 (_1: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv'5 x]. inv'5 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'6 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = invariant''5 _1
  
  meta "rewrite_def" predicate inv'6
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'6 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'7 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = invariant''6 _1
  
  meta "rewrite_def" predicate inv'7
  
  predicate inv'8 [@inline:trivial] (_1: tuple) = inv'7 _1.f1
  
  meta "rewrite_def" predicate inv'8
  
  let rec from_mut (r: MutBorrow.t (Slice64.slice t_T)) (return (x: tuple)) =
    {[@expl:from_mut 'r' type invariant] inv'3 r}
    any
    [ return (result: tuple) -> {inv'8 result}
      {ptr result.f1.current = result.f0}
      {val' result.f1.current = r.current}
      {val' result.f1.final = r.final}
      (! return {result}) ]
  
  type tuple'0 = { f0'0: Opaque.ptr; f1'0: MutBorrow.t t_PtrOwn }
  
  predicate resolve [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve
  
  predicate inv'9 [@inline:trivial] (_1: tuple'0) = inv'7 _1.f1'0
  
  meta "rewrite_def" predicate inv'9
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PtrOwn) : t_PtrOwn = self.final
  
  meta "rewrite_def" function fin
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_mut_ptr_own (self: MutBorrow.t (Slice64.slice t_T)) (return (x: tuple'0)) =
    {[@expl:as_mut_ptr_own 'self' type invariant] inv'3 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 self.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_9 <- _ret ] -{inv'2 _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = from_mut {_9} (fun (_ret: tuple) -> [ &_8 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &ptr'0 <- _8.f0 ] s1
      | s1 = [ &own <- _8.f1 ] s2
      | s2 = [ &_10 <- Opaque.thin ptr'0 ] s3
      | s3 = [ &_0 <- { f0'0 = _10; f1'0 = own } ] s4
      | s4 = {[@expl:type invariant] inv'3 self} s5
      | s5 = -{resolve self}- s6
      | s6 = return {_0} ] ]
    [ & _0: tuple'0 = Any.any_l ()
    | & self: MutBorrow.t (Slice64.slice t_T) = self
    | & ptr'0: Opaque.ptr = Any.any_l ()
    | & own: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _8: tuple = Any.any_l ()
    | & _9: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _10: Opaque.ptr = Any.any_l () ])
    [ return (result: tuple'0) -> {[@expl:as_mut_ptr_own result type invariant] inv'9 result}
      {[@expl:as_mut_ptr_own ensures #0] result.f0'0 = Opaque.thin (ptr result.f1'0.current)}
      {[@expl:as_mut_ptr_own ensures #1] self.current = val' result.f1'0.current}
      {[@expl:as_mut_ptr_own ensures #2] self.final = val' (fin result.f1'0)}
      (! return {result}) ]
end
module M_creusot_contracts__std__slice__qyi18390169926879820046__produces_refl (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter
  
  function produces_refl (self: t_Iter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__slice__qyi18390169926879820046__produces_trans (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter
  
  function produces_trans (a: t_Iter) (ab: Seq.seq t_T) (b: t_Iter) (bc: Seq.seq t_T) (c: t_Iter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__slice__qyi16967112428427721086__produces_refl (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_IterMut
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_mut_seq (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq self)
        -> Seq.get (to_mut_seq self) i
        = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_spec: forall self: t_IterMut. Seq.length (Slice64.view (view self).final)
      = Seq.length (Slice64.view (view self).current)
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut) =
    to_mut_seq (view self) = Seq.(++) visited (to_mut_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut
  
  function produces_refl (self: t_IterMut) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__std__slice__qyi16967112428427721086__produces_trans (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_IterMut
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_mut_seq (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq self)
        -> Seq.get (to_mut_seq self) i
        = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_spec: forall self: t_IterMut. Seq.length (Slice64.view (view self).final)
      = Seq.length (Slice64.view (view self).current)
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut) =
    to_mut_seq (view self) = Seq.(++) visited (to_mut_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut
  
  constant ab : Seq.seq (MutBorrow.t t_T)
  
  constant b : t_IterMut
  
  constant bc : Seq.seq (MutBorrow.t t_T)
  
  constant c : t_IterMut
  
  function produces_trans (a: t_IterMut) (ab: Seq.seq (MutBorrow.t t_T)) (b: t_IterMut) (bc: Seq.seq (MutBorrow.t t_T)) (c: t_IterMut) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__vec__qyi9182455043427114830__produces_refl (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter) =
    view self = Seq.(++) visited (view rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter
  
  function produces_refl (self: t_IntoIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__vec__qyi9182455043427114830__produces_trans (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter) =
    view self = Seq.(++) visited (view rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter
  
  function produces_trans (a: t_IntoIter) (ab: Seq.seq t_T) (b: t_IntoIter) (bc: Seq.seq t_T) (c: t_IntoIter) : ()
  
  goal vc_produces_trans: produces a ab b
    -> produces b bc c -> ([@expl:produces_trans ensures] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__cell__permcell__qyi13158525461644244414__resolve_coherence__refines (* <cell::permcell::PermCellOwn<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_PermCellOwn
  
  predicate structural_resolve (_1: t_PermCellOwn)
  
  predicate inv (_1: t_PermCellOwn)
  
  type t_T
  
  predicate resolve [@inline:trivial] (_1: t_T) = true
  
  meta "rewrite_def" predicate resolve
  
  function val' (self: t_PermCellOwn) : t_T
  
  predicate resolve'0 [@inline:trivial] (self: t_PermCellOwn) = resolve (val' self)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_PermCellOwn. structural_resolve self /\ inv self
      -> structural_resolve self /\ inv self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__invariant__qyi4568223824573003996__resolve_coherence__refines (* <invariant::Subset<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset
  
  predicate structural_resolve (_1: t_Subset)
  
  predicate inv [@inline:trivial] (_1: t_Subset) = true
  
  meta "rewrite_def" predicate inv
  
  type t_T
  
  predicate resolve (_1: t_T)
  
  predicate invariant' (self: t_T)
  
  function view (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  predicate resolve'0 [@inline:trivial] (self: t_Subset) = resolve (view self)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Subset. structural_resolve self /\ inv self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__logic__fmap__qyi7346618835798223822__resolve_coherence__refines (* <logic::fmap::FMap<K, V> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  predicate structural_resolve (_1: t_FMap)
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate resolve (_1: t_K)
  
  predicate resolve'0 (_1: t_V)
  
  predicate resolve'1 (self: t_FMap) = forall k: t_K, v: t_V. get self k = C_Some v -> resolve k /\ resolve'0 v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap. structural_resolve self /\ inv'1 self
      -> structural_resolve self /\ (forall result: (). resolve'1 self -> resolve'1 self)
end
module M_creusot_contracts__logic__fmap__qyi12157922019206519737__resolve_coherence__refines (* <logic::fmap::FMapIter<K, V> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate resolve (_1: t_K)
  
  predicate resolve'0 (_1: t_V)
  
  predicate resolve'1 (self: t_FMap) = forall k: t_K, v: t_V. get self k = C_Some v -> resolve k /\ resolve'0 v
  
  predicate resolve'2 (_1: t_FMap)
  
  axiom resolve_axiom: forall x: t_FMap [resolve'2 x]. resolve'2 x -> resolve'1 x
  
  predicate structural_resolve (_1: t_FMapIter) = resolve'2 _1.t_FMapIter__inner
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 (_1: t_FMapIter)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMapIter [inv'2 x]. inv'2 x = inv'1 x.t_FMapIter__inner
  
  function view'0 (self: t_FMapIter) : t_FMap = self.t_FMapIter__inner
  
  predicate resolve'3 (self: t_FMapIter) = resolve'2 (view'0 self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMapIter. structural_resolve self /\ inv'2 self
      -> structural_resolve self /\ (forall result: (). resolve'3 self -> resolve'3 self)
end
module M_creusot_contracts__logic__fset__qyi4246286320577759594__resolve_coherence__refines (* <logic::fset::FSet<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate structural_resolve (_1: Fset.fset t_T)
  
  predicate inv (_1: Fset.fset t_T)
  
  predicate contains [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (self: Fset.fset t_T) = forall x: t_T. contains self x -> resolve x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Fset.fset t_T. structural_resolve self /\ inv self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__logic__seq__qyi16733741354031147838__resolve_coherence__refines (* <logic::seq::Seq<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate structural_resolve (_1: Seq.seq t_T)
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  type t_Option = C_None | C_Some t_T
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'0 x]. resolve'0 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve x0
        end
  
  function get (self: Seq.seq t_T) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  predicate resolve'1 (self: Seq.seq t_T) = forall i: int. resolve'0 (get self i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Seq.seq t_T. structural_resolve self /\ inv'1 self
      -> structural_resolve self /\ (forall result: (). resolve'1 self -> resolve'1 self)
end
module M_creusot_contracts__logic__seq__qyi4911090196027168916__resolve_coherence__refines (* <logic::seq::SeqIter<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  type t_Option = C_None | C_Some t_T
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 (_1: t_Option)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option [resolve'0 x]. resolve'0 x
      = match x with
        | C_None -> true
        | C_Some x0 -> resolve x0
        end
  
  function get (self: Seq.seq t_T) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  predicate resolve'1 (self: Seq.seq t_T) = forall i: int. resolve'0 (get self i)
  
  predicate resolve'2 (_1: Seq.seq t_T)
  
  axiom resolve_axiom'0: forall x: Seq.seq t_T [resolve'2 x]. resolve'2 x -> resolve'1 x
  
  predicate structural_resolve (_1: t_SeqIter) = resolve'2 _1.t_SeqIter__inner
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 (_1: t_SeqIter)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter [inv'2 x]. inv'2 x = inv'1 x.t_SeqIter__inner
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  predicate resolve'3 [@inline:trivial] (self: t_SeqIter) = resolve'2 (view self)
  
  meta "rewrite_def" predicate resolve'3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIter. structural_resolve self /\ inv'2 self
      -> structural_resolve self /\ (forall result: (). resolve'3 self -> resolve'3 self)
end
module M_creusot_contracts__resolve__qyi1804364923227103020__resolve_coherence__refines (* <&'a T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate structural_resolve (_1: t_T) = true
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate resolve (self: t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_T. structural_resolve self /\ inv'0 self
      -> (forall result: (). resolve self -> resolve self)
end
module M_creusot_contracts__resolve__qyi13312526907268931455__resolve_coherence__refines (* <&'a mut T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate structural_resolve (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_T) = inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: MutBorrow.t t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate resolve (self: MutBorrow.t t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t t_T. structural_resolve self /\ inv'0 self
      -> (forall result: (). resolve self -> resolve self)
end
module M_creusot_contracts__std__array__qyi10472786876058693326__resolve_coherence__refines (* <[T; N] as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  
  type t_T
  
  predicate structural_resolve (_1: Slice64.array t_T)
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  constant const_N : UInt64.t
  
  predicate invariant''1 (self: Slice64.array t_T) =
    inv'1 (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int const_N
  
  predicate inv'2 [@inline:trivial] (_1: Slice64.array t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 [@inline:trivial] (self: Slice64.array t_T) =
    forall i: int. 0 <= i /\ i < UInt64.t'int const_N -> resolve (Seq.get (Slice64.view self) i)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.array t_T. structural_resolve self /\ inv'2 self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__boxed__qyi16987717371723104459__resolve_coherence__refines (* <std::boxed::Box<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate resolve (_1: t_T)
  
  predicate structural_resolve (_1: t_T) = resolve _1
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate resolve'0 [@inline:trivial] (self: t_T) = true
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_T. structural_resolve self /\ inv'0 self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__deque__qyi13680360502534194761__resolve_coherence__refines (* <std::collections::VecDeque<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  
  type t_VecDeque
  
  predicate structural_resolve (_1: t_VecDeque)
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_VecDeque) : Seq.seq t_T
  
  axiom view_spec: forall self: t_VecDeque. Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_VecDeque) = inv'1 (view self)
  
  predicate inv'2 (_1: t_VecDeque)
  
  axiom inv_axiom: forall x: t_VecDeque [inv'2 x]. inv'2 x -> invariant''1 x
  
  predicate resolve (_1: t_T)
  
  function index_logic [@inline:trivial] (self: t_VecDeque) (ix: int) : t_T = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  predicate resolve'0 [@inline:trivial] (self: t_VecDeque) =
    forall i: int. 0 <= i /\ i < Seq.length (view self) -> resolve (index_logic self i)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_VecDeque. structural_resolve self /\ inv'2 self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__iter__cloned__qyi7712864753404203214__resolve_coherence__refines (* <std::iter::Cloned<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Cloned
  
  predicate structural_resolve (_1: t_Cloned)
  
  type t_I
  
  predicate inv (_1: t_I)
  
  function iter (self: t_Cloned) : t_I
  
  predicate invariant' [@inline:trivial] (self: t_Cloned) = inv (iter self)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: t_Cloned)
  
  axiom inv_axiom: forall x: t_Cloned [inv'0 x]. inv'0 x -> invariant' x
  
  predicate resolve (_1: t_I)
  
  predicate resolve'0 [@inline:trivial] (self: t_Cloned) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Cloned. structural_resolve self /\ inv'0 self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__iter__copied__qyi10817769304312191898__resolve_coherence__refines (* <std::iter::Copied<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Copied
  
  predicate structural_resolve (_1: t_Copied)
  
  type t_I
  
  predicate inv (_1: t_I)
  
  function iter (self: t_Copied) : t_I
  
  predicate invariant' [@inline:trivial] (self: t_Copied) = inv (iter self)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 (_1: t_Copied)
  
  axiom inv_axiom: forall x: t_Copied [inv'0 x]. inv'0 x -> invariant' x
  
  predicate resolve (_1: t_I)
  
  predicate resolve'0 [@inline:trivial] (self: t_Copied) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Copied. structural_resolve self /\ inv'0 self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__iter__enumerate__qyi7229971731912667430__resolve_coherence__refines (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Enumerate
  
  predicate structural_resolve (_1: t_Enumerate)
  
  predicate inv (_1: t_Enumerate)
  
  type t_I
  
  predicate resolve (_1: t_I)
  
  function iter (self: t_Enumerate) : t_I
  
  predicate resolve'0 [@inline:trivial] (self: t_Enumerate) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Enumerate. structural_resolve self /\ inv self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__iter__map__qyi7619436869179474426__resolve_coherence__refines (* <std::iter::Map<I, F> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Map
  
  predicate structural_resolve (_1: t_Map)
  
  predicate inv (_1: t_Map)
  
  type t_I
  
  predicate resolve (_1: t_I)
  
  function iter (self: t_Map) : t_I
  
  type t_F
  
  predicate resolve'0 (_1: t_F)
  
  function func (self: t_Map) : t_F
  
  predicate resolve'1 [@inline:trivial] (self: t_Map) = resolve (iter self) /\ resolve'0 (func self)
  
  meta "rewrite_def" predicate resolve'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map. structural_resolve self /\ inv self
      -> structural_resolve self /\ (forall result: (). resolve'1 self -> resolve'1 self)
end
module M_creusot_contracts__std__iter__skip__qyi1800235112549046777__resolve_coherence__refines (* <std::iter::Skip<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Skip
  
  predicate structural_resolve (_1: t_Skip)
  
  predicate inv (_1: t_Skip)
  
  type t_I
  
  predicate resolve (_1: t_I)
  
  function iter (self: t_Skip) : t_I
  
  predicate resolve'0 [@inline:trivial] (self: t_Skip) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Skip. structural_resolve self /\ inv self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__iter__take__qyi7846602308660485643__resolve_coherence__refines (* <std::iter::Take<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Take
  
  predicate structural_resolve (_1: t_Take)
  
  predicate inv (_1: t_Take)
  
  type t_I
  
  predicate resolve (_1: t_I)
  
  function iter (self: t_Take) : t_I
  
  predicate resolve'0 [@inline:trivial] (self: t_Take) = resolve (iter self)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Take. structural_resolve self /\ inv self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__slice__qyi13715984201317679185__resolve_coherence__refines (* <[T] as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate structural_resolve (_1: Slice64.slice t_T)
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 (self: Slice64.slice t_T) = inv'1 (Slice64.view self)
  
  predicate inv'2 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate resolve (_1: t_T)
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  predicate resolve'0 [@inline:trivial] (self: Slice64.slice t_T) =
    forall i: int. 0 <= i /\ i < Seq.length (Slice64.view self) -> resolve (index_logic self i)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.slice t_T. structural_resolve self /\ inv'2 self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__slice__qyi6798028551487775744__resolve_coherence__refines (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  
  type t_IterMut
  
  predicate structural_resolve (_1: t_IterMut)
  
  predicate inv (_1: t_IterMut)
  
  type t_T
  
  function view (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_spec: forall self: t_IterMut. Seq.length (Slice64.view (view self).final)
      = Seq.length (Slice64.view (view self).current)
  
  predicate resolve [@inline:trivial] (self: t_IterMut) = (view self).current = (view self).final
  
  meta "rewrite_def" predicate resolve
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IterMut. structural_resolve self /\ inv self
      -> structural_resolve self /\ (forall result: (). resolve self -> resolve self)
end
module M_creusot_contracts__std__vec__qyi16169840827095121464__resolve_coherence__refines (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  
  type t_Vec
  
  predicate structural_resolve (_1: t_Vec)
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate invariant''1 (self: t_Vec) = inv'1 (view self)
  
  predicate inv'2 (_1: t_Vec)
  
  axiom inv_axiom: forall x: t_Vec [inv'2 x]. inv'2 x -> invariant''1 x
  
  predicate resolve (_1: t_T)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : t_T = Seq.get (view self) ix
  
  meta "rewrite_def" function index_logic
  
  predicate resolve'0 [@inline:trivial] (self: t_Vec) =
    forall i: int. 0 <= i /\ i < Seq.length (view self) -> resolve (index_logic self i)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Vec. structural_resolve self /\ inv'2 self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__std__vec__qyi9945000909994515642__resolve_coherence__refines (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  use seq.Seq
  
  type t_IntoIter
  
  predicate structural_resolve (_1: t_IntoIter)
  
  predicate inv (_1: t_IntoIter)
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate resolve (_1: t_T)
  
  predicate resolve'0 [@inline:trivial] (self: t_IntoIter) =
    forall i: int. 0 <= i /\ i < Seq.length (view self) -> resolve (Seq.get (view self) i)
  
  meta "rewrite_def" predicate resolve'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter. structural_resolve self /\ inv self
      -> structural_resolve self /\ (forall result: (). resolve'0 self -> resolve'0 self)
end
module M_creusot_contracts__ghost__fn_ghost__qyi2064759324376620136__clone__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_FnGhostWrapper = { t_FnGhostWrapper__0: t_F }
  
  predicate inv (_1: t_F)
  
  predicate inv'0 (_1: t_FnGhostWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper [inv'0 x]. inv'0 x = inv x.t_FnGhostWrapper__0
  
  predicate invariant' [@inline:trivial] (self: t_FnGhostWrapper) = inv'0 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 [@inline:trivial] (_1: t_FnGhostWrapper) = invariant' _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate postcondition_once (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef: forall args: t_F, res: t_F [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_F, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_F, res: t_F. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1: forall args: t_F, res: t_F [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_spec: forall self: (), args: t_F, res: t_F. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate invariant''0 [@inline:trivial] (self: t_F) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_F) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate precondition (self: ()) (args: t_F)
  
  axiom precondition_fndef: forall args: t_F [precondition () args]. (let self_ = args in inv'2 self_)
      -> precondition () args
  
  let rec clone' (self_: t_F) (return (x: t_F)) = {[@expl:clone requires] precondition () self_}
    any [ return (result: t_F) -> {postcondition_once () self_ result} (! return {result}) ]
  
  function view [@inline:trivial] (self: t_FnGhostWrapper) : t_F = self.t_FnGhostWrapper__0
  
  meta "rewrite_def" function view
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper. inv'1 self_
      -> inv'1 self_
      /\ (forall result: t_FnGhostWrapper. postcondition () (view self_) (view result) /\ inv'0 result -> inv'0 result)
end
module M_creusot_contracts__ghost__resource__fmap_view__qyi11277603908270514611__clone__refines (* <ghost::resource::fmap_view::Fragment<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment = { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_FMap
  
  type t_Ag = { t_Ag__0: t_V }
  
  type t_Option = C_None | C_Some t_Ag
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type t_View
  
  type t_Option'0 = C_None'0 | C_Some'0 t_FMap
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option'1 = match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. op a b = op b a
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'1 other
      | {f1 = C_None} -> C_Some'1 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic'0 (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option'0 = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None)
  
  constant unit': t_FMap = empty
  
  axiom unit_spec: forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Ag. op factor'0 c <> C_Some self
        end
  
  function factor'0 (self: t_Option) (factor'1: t_Option) : t_Option'1 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None} -> C_Some'1 x
      | {f0 = C_None} -> C_None'1
      | {f0 = C_Some x; f1 = C_Some y} -> match factor x y with
        | C_Some z -> C_Some'1 (C_Some z)
        | C_None -> if x = y then C_Some'1 (C_None) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option, factor'1: t_Option. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_Option. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl (self: t_Option) (other: t_Option) = factor'0 other self <> C_None'1
  
  function incl_transitive (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom incl_transitive_spec: forall a: t_Option, b: t_Option, c: t_Option. incl a b -> incl b c -> incl a c
  
  function incl_op (self: t_Option) (other: t_Option) (comb: t_Option) : ()
  
  axiom incl_op_spec: forall self: t_Option, other: t_Option, comb: t_Option. op'0 self other = C_Some'1 comb
      -> incl self comb
  
  type tuple'0 = { f0'0: t_K; f1'0: t_Ag }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_Option) (a: tuple'0) : t_Option = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function filter_map (self: t_FMap) (f: Map.map tuple'0 t_Option) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'0 t_Option. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None -> C_None
          | C_Some v -> index_logic f { f0'0 = k; f1'0 = v }
          end
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option'0 =
    if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {f0'0 = k; f1'0 = vo} = __0 in match factor'0 (C_Some vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None
        end) in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
        | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None'0
  
  function incl_transitive'0 (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. op'1 self other = C_Some'0 comb
      -> incl'0 self comb
  
  predicate rel (a: t_Option'0) (f: t_FMap) =
    match a with
      | C_Some'0 a'0 -> incl'0 f a'0
      | C_None'0 -> true
      end
  
  function rel_unit (a: t_Option'0) : ()
  
  axiom rel_unit_spec: forall a: t_Option'0. rel a unit'
  
  function rel_none (a: t_Option'0) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_FMap. rel (C_None'0) f
  
  function rel_mono (a: t_Option'0) (f1'1: t_FMap) (f2: t_FMap) : ()
  
  axiom rel_mono_spec: forall a: t_Option'0, f1'1: t_FMap, f2: t_FMap. rel a f1'1 -> incl'0 f2 f1'1 -> rel a f2
  
  function auth (self: t_View) : t_Option'0
  
  function frag (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  function val' (self: t_Resource) : t_View
  
  function view'0 [@inline:trivial] (self: t_Resource) : t_View = val' self
  
  meta "rewrite_def" function view'0
  
  predicate invariant' (self: t_Fragment) =
    get (frag (view'0 self.t_Fragment__0)) self.t_Fragment__1 = C_Some { t_Ag__0 = self.t_Fragment__2 }
  
  predicate inv (_1: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_Fragment) = inv self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'0 [@inline:trivial] (_1: t_Fragment) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'0
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  function id'0 (self: t_Fragment) : t_Id = id self.t_Fragment__0
  
  type tuple'1 = { f0'1: t_K; f1'1: t_V }
  
  function view'1 (self: t_Fragment) : tuple'1 = { f0'1 = self.t_Fragment__1; f1'1 = self.t_Fragment__2 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Fragment. inv'0 self_
      -> inv'0 self_
      /\ (forall result: t_Fragment. id'0 result = id'0 self_ /\ view'1 result = view'1 self_ /\ inv result
        -> inv result)
end
module M_creusot_contracts__ghost__qyi11517682701084838082__clone__refines (* <ghost::Ghost<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_T. inv'1 self_
      -> inv'1 self_ /\ (forall result: t_T. result = self_ /\ inv'0 result -> inv'0 result)
end
module M_creusot_contracts__logic__fmap__qyi1775402764303793352__clone__refines (* <logic::fmap::FMap<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [@inline:trivial] (self: t_FMap) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_FMap) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FMap. inv'2 self_
      -> inv'2 self_ /\ (forall result: t_FMap. result = self_ /\ inv'1 result -> inv'1 result)
end
module M_creusot_contracts__logic__fset__qyi13324666171263681189__clone__refines (* <logic::fset::FSet<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_T)
  
  predicate invariant' [@inline:trivial] (self: Fset.fset t_T) = forall x: t_T. contains self x -> inv x
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: Fset.fset t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Fset.fset t_T) = inv'0 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Fset.fset t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: Fset.fset t_T. inv'1 self_
      -> inv'1 self_ /\ (forall result: Fset.fset t_T. result = self_ /\ inv'0 result -> inv'0 result)
end
module M_creusot_contracts__logic__seq__qyi7164078029063507335__clone__refines (* <logic::seq::Seq<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) = inv'1 self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'2 [@inline:trivial] (_1: Seq.seq t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: Seq.seq t_T. inv'2 self_
      -> inv'2 self_ /\ (forall result: Seq.seq t_T. result = self_ /\ inv'1 result -> inv'1 result)
end
module M_creusot_contracts__ghost__fn_ghost__qyi7686160621403946688__call_once__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::FnOnce<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_FnGhostWrapper = { t_FnGhostWrapper__0: t_F }
  
  type t_I
  
  predicate precondition (self: t_F) (args: t_I)
  
  predicate precondition'0 [@inline:trivial] (self: t_FnGhostWrapper) (args: t_I) =
    precondition self.t_FnGhostWrapper__0 args
  
  meta "rewrite_def" predicate precondition'0
  
  predicate inv (_1: t_I)
  
  predicate inv'0 (_1: t_F)
  
  predicate inv'1 (_1: t_FnGhostWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper [inv'1 x]. inv'1 x = inv'0 x.t_FnGhostWrapper__0
  
  type t_Output
  
  predicate postcondition (self: t_F) (args: t_I) (result: t_Output)
  
  predicate postcondition_once [@inline:trivial] (self: t_FnGhostWrapper) (args: t_I) (result: t_Output) =
    postcondition self.t_FnGhostWrapper__0 args result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate inv'2 (_1: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper. forall arg: t_I. precondition'0 self_ arg /\ inv arg /\ inv'1 self_
        -> precondition'0 self_ arg
        /\ inv arg
        /\ inv'1 self_
        /\ (forall result: t_Output. postcondition_once self_ arg result /\ inv'2 result
          -> postcondition_once self_ arg result /\ inv'2 result)
end
module M_creusot_contracts__ghost__fn_ghost__qyi16362356824709806354__call_mut__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::FnMut<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_F
  
  type t_FnGhostWrapper = { t_FnGhostWrapper__0: t_F }
  
  type t_I
  
  predicate precondition (self: t_F) (args: t_I)
  
  predicate precondition'0 [@inline:trivial] (self: t_FnGhostWrapper) (args: t_I) =
    precondition self.t_FnGhostWrapper__0 args
  
  meta "rewrite_def" predicate precondition'0
  
  predicate inv (_1: t_I)
  
  predicate inv'0 (_1: t_F)
  
  predicate inv'1 (_1: t_FnGhostWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper [inv'1 x]. inv'1 x = inv'0 x.t_FnGhostWrapper__0
  
  predicate invariant' [@inline:trivial] (self: MutBorrow.t t_FnGhostWrapper) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_FnGhostWrapper) = invariant' _1
  
  meta "rewrite_def" predicate inv'2
  
  type t_Output
  
  predicate postcondition (self: t_F) (args: t_I) (result: t_Output)
  
  predicate postcondition_mut [@inline:trivial] (self: t_FnGhostWrapper) (args: t_I) (result_state: t_FnGhostWrapper) (result: t_Output) =
    postcondition self.t_FnGhostWrapper__0 args result /\ self = result_state
  
  meta "rewrite_def" predicate postcondition_mut
  
  predicate inv'3 (_1: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_FnGhostWrapper. forall arg: t_I. precondition'0 self_.current arg
          /\ inv arg /\ inv'2 self_
        -> precondition'0 self_.current arg
        /\ inv arg
        /\ inv'2 self_
        /\ (forall result: t_Output. postcondition_mut self_.current arg self_.final result /\ inv'3 result
          -> postcondition_mut self_.current arg self_.final result /\ inv'3 result)
end
module M_creusot_contracts__ghost__fn_ghost__qyi3807795101747839371__call__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::Fn<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_FnGhostWrapper = { t_FnGhostWrapper__0: t_F }
  
  type t_I
  
  predicate precondition (self: t_F) (args: t_I)
  
  predicate precondition'0 [@inline:trivial] (self: t_FnGhostWrapper) (args: t_I) =
    precondition self.t_FnGhostWrapper__0 args
  
  meta "rewrite_def" predicate precondition'0
  
  predicate inv (_1: t_I)
  
  predicate inv'0 (_1: t_F)
  
  predicate inv'1 (_1: t_FnGhostWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper [inv'1 x]. inv'1 x = inv'0 x.t_FnGhostWrapper__0
  
  predicate invariant' [@inline:trivial] (self: t_FnGhostWrapper) = inv'1 self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'2 [@inline:trivial] (_1: t_FnGhostWrapper) = invariant' _1
  
  meta "rewrite_def" predicate inv'2
  
  type t_Output
  
  predicate postcondition (self: t_F) (args: t_I) (result: t_Output)
  
  predicate postcondition'0 [@inline:trivial] (self: t_FnGhostWrapper) (args: t_I) (result: t_Output) =
    postcondition self.t_FnGhostWrapper__0 args result
  
  meta "rewrite_def" predicate postcondition'0
  
  predicate inv'3 (_1: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper. forall arg: t_I. precondition'0 self_ arg /\ inv arg /\ inv'2 self_
        -> precondition'0 self_ arg
        /\ inv arg
        /\ inv'2 self_
        /\ (forall result: t_Output. postcondition'0 self_ arg result /\ inv'3 result
          -> postcondition'0 self_ arg result /\ inv'3 result)
end
module M_creusot_contracts__invariant__qyi13867431616591602486__eq__refines (* <invariant::Subset<T> as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset
  
  type t_DeepModelTy
  
  type t_T
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate invariant' (self: t_T)
  
  function view (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function deep_model'0 [@inline:trivial] (self: t_Subset) : t_DeepModelTy = deep_model (view self)
  
  meta "rewrite_def" function deep_model'0
  
  function deep_model'1 [@inline:trivial] (self: t_Subset) : t_DeepModelTy = deep_model'0 self
  
  meta "rewrite_def" function deep_model'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Subset. forall rhs: t_Subset. forall result: bool. result
            = (deep_model'1 self_ = deep_model'1 rhs) -> result = (deep_model'1 self_ = deep_model'1 rhs)
end
module M_creusot_contracts__logic__id__qyi14416423697585690270__ne__refines (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Id
  
  function deep_model [@inline:trivial] (self: t_Id) : t_Id = self
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Id) : t_Id = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Id. forall rhs: t_Id. forall result: bool. result <> (self_ = rhs)
          -> result = (deep_model'0 self_ <> deep_model'0 rhs)
end
module M_creusot_contracts__logic__id__qyi14416423697585690270__eq__refines (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Id
  
  function deep_model [@inline:trivial] (self: t_Id) : t_Id = self
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_Id) : t_Id = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Id. forall rhs: t_Id. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_creusot_contracts__logic__int__qyi8495612394334423323__eq__refines (* <logic::int::Int as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  function deep_model [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: int) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall rhs: int. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_creusot_contracts__peano__qyi14634619887680291373__eq__refines (* <peano::PeanoInt as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  function deep_model [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_creusot_contracts__logic__fmap__qyi17788021891652805456__next__refines (* <logic::fmap::FMapIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use seq.Seq
  use mach.int.Int
  use map.Const
  
  type t_FMap
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate inv'0 (_1: t_V)
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant' [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv k /\ inv'0 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'1 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 (_1: t_FMapIter)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMapIter [inv'2 x]. inv'2 x = inv'1 x.t_FMapIter__inner
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_FMapIter) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'3 [@inline:trivial] (_1: MutBorrow.t t_FMapIter) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'3
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple
  
  function get'0 (self: Seq.seq tuple) (ix: int) : t_Option'0 = if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  function view'0 (self: t_FMapIter) : t_FMap = self.t_FMapIter__inner
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple) (o: t_FMapIter) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get'0 visited i = C_Some'0 { f0 = k; f1 = v }
        -> not contains (view'0 o) k /\ get (view'0 self) k = C_Some v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get (view'0 o) k = get (view'0 self) k)
  
  function produces_trans (a: t_FMapIter) (ab: Seq.seq tuple) (b: t_FMapIter) (bc: Seq.seq tuple) (c: t_FMapIter) : () =
    let ac = Seq.(++) ab bc in ()
  
  axiom produces_trans_spec:
    forall a: t_FMapIter, ab: Seq.seq tuple, b: t_FMapIter, bc: Seq.seq tuple, c: t_FMapIter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_FMapIter) : () = ()
  
  axiom produces_refl_spec: forall self: t_FMapIter. produces self (Seq.empty: Seq.seq tuple) self
  
  predicate ext_eq (self: t_FMap) (other: t_FMap) = forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ext_eq self other = (self = other)
  
  constant empty : t_FMap
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view empty = Const.const (C_None)
  
  predicate is_empty (self: t_FMap) = ext_eq self empty
  
  predicate completed (self: MutBorrow.t t_FMapIter) = is_empty (view'0 self.current)
  
  function insert (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. view (insert self k v) = Map.set (view self) k (C_Some v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  predicate inv'4 [@inline:trivial] (_1: tuple) = inv _1.f0 /\ inv'0 _1.f1
  
  meta "rewrite_def" predicate inv'4
  
  predicate inv'5 (_1: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'5 x]. inv'5 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'4 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_FMapIter. inv'3 self_
      -> inv'3 self_
      /\ (forall result: t_Option'0. match result with
              | C_None'0 -> completed self_
              | C_Some'0 {f0 = k; f1 = v} -> produces self_.current (Seq.singleton { f0 = k; f1 = v }) self_.final
              /\ view'0 self_.current = insert (view'0 self_.final) k v
              end
          /\ inv'5 result
        -> match result with
            | C_None'0 -> completed self_
            | C_Some'0 v -> produces self_.current (Seq.singleton v) self_.final
            end
        /\ inv'5 result)
end
module M_creusot_contracts__logic__fmap__qyi8978282872089338506__next__refines (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use seq.Seq
  
  type t_FMap
  
  type t_FMapIterRef = { t_FMapIterRef__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None
  
  meta "rewrite_def" predicate contains
  
  predicate inv (_1: t_K)
  
  predicate invariant' [@inline:trivial] (self: t_K) = inv self
  
  meta "rewrite_def" predicate invariant'
  
  predicate inv'0 [@inline:trivial] (_1: t_K) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate inv'1 (_1: t_V)
  
  predicate invariant''0 [@inline:trivial] (self: t_V) = inv'1 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: t_V) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate index_logic [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option) : t_V = match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_K) : t_V = unwrap_logic (get self k)
  
  meta "rewrite_def" function lookup
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: t_K) : t_V = lookup self key
  
  meta "rewrite_def" function index_logic'0
  
  predicate invariant''1 [@inline:trivial] (self: t_FMap) =
    forall k: t_K. contains self k -> inv'0 k /\ inv'2 (index_logic'0 self k)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 (_1: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_1: t_FMapIterRef)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMapIterRef [inv'4 x]. inv'4 x = inv'3 x.t_FMapIterRef__inner
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_FMapIterRef) = inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'5 [@inline:trivial] (_1: MutBorrow.t t_FMapIterRef) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'5
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple
  
  type t_FMap'0
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap'0) : Map.map t_K t_Option'1
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'0
  
  predicate ext_eq (self: t_FMap'0) (other: t_FMap'0) = forall k: t_K. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. ext_eq self other = (self = other)
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. len self >= 0
  
  constant empty : t_FMap'0
  
  axiom empty_spec: len empty = 0
  
  axiom empty_spec'0: view'0 empty = Const.const (C_None'1)
  
  predicate is_empty (self: t_FMap'0) = ext_eq self empty
  
  predicate index_logic'1 [@inline:trivial] (self: Map.map t_FMap'0 bool) (a: t_FMap'0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'1
  
  function such_that'0 (p: Map.map t_FMap'0 bool) : t_FMap'0
  
  axiom such_that_spec'0: forall p: Map.map t_FMap'0 bool. (exists x: t_FMap'0. index_logic'1 p x)
      -> index_logic'1 p (such_that'0 p)
  
  function view'1 (self: t_FMapIterRef) : t_FMap'0 = such_that'0 (fun (m: t_FMap'0) -> forall k: t_K, v: t_V. (get'0 m k
        = C_Some'1 v)
      = (get self.t_FMapIterRef__inner k = C_Some v))
  
  predicate completed (self: MutBorrow.t t_FMapIterRef) = is_empty (view'1 self.current)
  
  function get'1 (self: Seq.seq tuple) (ix: int) : t_Option'0 = if 0 <= ix /\ ix < Seq.length self then
      C_Some'0 (Seq.get self ix)
    else
      C_None'0
  
  
  predicate contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) = get'0 self k <> C_None'1
  
  meta "rewrite_def" predicate contains'0
  
  predicate produces (self: t_FMapIterRef) (visited: Seq.seq tuple) (o: t_FMapIterRef) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get'1 visited i = C_Some'0 { f0 = k; f1 = v }
        -> not contains'0 (view'1 o) k /\ get'0 (view'1 self) k = C_Some'1 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'1 o) k = get'0 (view'1 self) k)
  
  predicate inv'6 [@inline:trivial] (_1: tuple) = inv'0 _1.f0 /\ inv'2 _1.f1
  
  meta "rewrite_def" predicate inv'6
  
  predicate inv'7 (_1: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_FMapIterRef. inv'5 self_
      -> inv'5 self_
      /\ (forall result: t_Option'0. match result with
              | C_None'0 -> completed self_
              | C_Some'0 v -> produces self_.current (Seq.singleton v) self_.final
              end
          /\ inv'7 result
        -> match result with
            | C_None'0 -> completed self_
            | C_Some'0 v -> produces self_.current (Seq.singleton v) self_.final
            end
        /\ inv'7 result)
end
module M_creusot_contracts__logic__seq__qyi785709447733932085__next__refines (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate inv'2 (_1: t_SeqIter)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter [inv'2 x]. inv'2 x = inv'1 x.t_SeqIter__inner
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_SeqIter) = inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'3 [@inline:trivial] (_1: MutBorrow.t t_SeqIter) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'3
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  predicate produces (self: t_SeqIter) (visited: Seq.seq t_T) (o: t_SeqIter) = view self = Seq.(++) visited (view o)
  
  function produces_trans (a: t_SeqIter) (ab: Seq.seq t_T) (b: t_SeqIter) (bc: Seq.seq t_T) (c: t_SeqIter) : () = ()
  
  axiom produces_trans_spec:
    forall a: t_SeqIter, ab: Seq.seq t_T, b: t_SeqIter, bc: Seq.seq t_T, c: t_SeqIter. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_SeqIter) : () = ()
  
  axiom produces_refl_spec: forall self: t_SeqIter. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate completed (self: MutBorrow.t t_SeqIter) = view self.current = (Seq.empty: Seq.seq t_T)
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_SeqIter. inv'3 self_
      -> inv'3 self_
      /\ (forall result: t_Option. match result with
              | C_None -> completed self_
              | C_Some v -> produces self_.current (Seq.singleton v) self_.final
              end
          /\ inv'4 result
        -> match result with
            | C_None -> completed self_
            | C_Some v -> produces self_.current (Seq.singleton v) self_.final
            end
        /\ inv'4 result)
end
module M_creusot_contracts__logic__seq__qyi15242110712714185722__next__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_SeqIterRef = { t_SeqIterRef__inner: Seq.seq t_T; t_SeqIterRef__index: int }
  
  predicate invariant' (self: t_SeqIterRef) =
    0 <= self.t_SeqIterRef__index /\ self.t_SeqIterRef__index <= Seq.length self.t_SeqIterRef__inner
  
  predicate inv (_1: t_T)
  
  predicate invariant''0 (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''1 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''2 [@inline:trivial] (self: Seq.seq t_T) = inv'1 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'2 [@inline:trivial] (_1: Seq.seq t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate inv'3 (_1: t_SeqIterRef)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIterRef [inv'3 x]. inv'3 x = (invariant' x /\ inv'2 x.t_SeqIterRef__inner)
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_SeqIterRef) = inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'4 [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef) = invariant''3 _1
  
  meta "rewrite_def" predicate inv'4
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_SeqIterRef) : Seq.seq t_T =
    Seq.([..]) self.t_SeqIterRef__inner self.t_SeqIterRef__index (Seq.length self.t_SeqIterRef__inner)
  
  predicate produces (self: t_SeqIterRef) (visited: Seq.seq t_T) (o: t_SeqIterRef) =
    let visited'0 = visited in view self = Seq.(++) visited'0 (view o)
  
  function produces_trans (a: t_SeqIterRef) (ab: Seq.seq t_T) (b: t_SeqIterRef) (bc: Seq.seq t_T) (c: t_SeqIterRef) : ()
   = ()
  
  axiom produces_trans_spec:
    forall a: t_SeqIterRef, ab: Seq.seq t_T, b: t_SeqIterRef, bc: Seq.seq t_T, c: t_SeqIterRef. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_SeqIterRef) : () = ()
  
  axiom produces_refl_spec: forall self: t_SeqIterRef. produces self (Seq.empty: Seq.seq t_T) self
  
  predicate completed (self: MutBorrow.t t_SeqIterRef) = view self.current = (Seq.empty: Seq.seq t_T)
  
  predicate invariant''4 [@inline:trivial] (self: t_T) = inv self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'5 [@inline:trivial] (_1: t_T) = invariant''4 _1
  
  meta "rewrite_def" predicate inv'5
  
  predicate inv'6 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'6 x]. inv'6 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'5 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_SeqIterRef. inv'4 self_
      -> inv'4 self_
      /\ (forall result: t_Option. match result with
              | C_None -> completed self_
              | C_Some v -> produces self_.current (Seq.singleton v) self_.final
              end
          /\ inv'6 result
        -> match result with
            | C_None -> completed self_
            | C_Some v -> produces self_.current (Seq.singleton v) self_.final
            end
        /\ inv'6 result)
end
module M_creusot_contracts__std__iter__map_inv__qyi8002351551305542163__next__refines (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv = { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed (self: MutBorrow.t t_I)
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate next_precondition (iter: t_I) (func: t_F) (produced: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. produces iter (Seq.singleton e) i -> precondition func { f0 = e; f1 = produced }
  
  type t_B
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate preservation (iter: t_I) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current { f0 = e1; f1 = s }
      -> postcondition_mut f.current { f0 = e1; f1 = s } f.final b
      -> precondition f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize =
    forall iter: MutBorrow.t t_I, func: t_F. completed iter
      -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv (iter: t_I) (func: t_F) (produced: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
      -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition f.current { f0 = e1; f1 = Seq.(++) produced s }
      -> postcondition_mut f.current { f0 = e1; f1 = Seq.(++) produced s } f.final b
      -> precondition f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec: forall iter: t_I, func: t_F, produced: Seq.seq t_Item. produced
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' (self: t_MapInv) =
    reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  predicate inv (_1: t_I)
  
  predicate inv'0 (_1: t_F)
  
  predicate inv'1 (_1: t_MapInv)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv [inv'1 x]. inv'1 x
      = (invariant' x /\ inv x.t_MapInv__iter /\ inv'0 x.t_MapInv__func)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_MapInv) = inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'2 [@inline:trivial] (_1: MutBorrow.t t_MapInv) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'2
  
  type t_Option = C_None | C_Some t_B
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current { f0 = Seq.get s i;
                                                   f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  function produces_trans'0 (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : () = ()
  
  axiom produces_trans_spec'0:
    forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_MapInv) : () = ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. produces'0 self (Seq.empty: Seq.seq t_B) self
  
  predicate completed'0 (self: MutBorrow.t t_MapInv) =
    self.final.t_MapInv__produced = (Seq.empty: Seq.seq t_Item)
    /\ completed (MutBorrow.borrow_logic self.current.t_MapInv__iter self.final.t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ self.current.t_MapInv__func = self.final.t_MapInv__func
  
  predicate produces_one (self: t_MapInv) (visited: t_B) (succ: t_MapInv) =
    exists f: MutBorrow.t t_F, e: t_Item. f.current = self.t_MapInv__func
      /\ f.final = succ.t_MapInv__func
      /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
      /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
      /\ precondition f.current { f0 = e; f1 = self.t_MapInv__produced }
      /\ postcondition_mut f.current { f0 = e; f1 = self.t_MapInv__produced } f.final visited
  
  axiom produces_one_spec: forall self: t_MapInv, visited: t_B, succ: t_MapInv. produces_one self visited succ
      = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'3 (_1: t_B)
  
  predicate inv'4 (_1: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_MapInv. inv'2 self_
      -> inv'2 self_
      /\ (forall result: t_Option. match result with
              | C_None -> completed'0 self_
              | C_Some v -> produces_one self_.current v self_.final
              end
          /\ inv'4 result
        -> match result with
            | C_None -> completed'0 self_
            | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
            end
        /\ inv'4 result)
end
module M_creusot_contracts__logic__fmap__qyi14545271337334171048__produces_refl__refines (* <logic::fmap::FMapIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some tuple
  
  function get (self: Seq.seq tuple) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  function view'0 (self: t_FMapIter) : t_FMap = self.t_FMapIter__inner
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple) (o: t_FMapIter) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get visited i = C_Some { f0 = k; f1 = v }
        -> not contains (view'0 o) k /\ get'0 (view'0 self) k = C_Some'0 v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'0 o) k = get'0 (view'0 self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMapIter. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
        -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__logic__fmap__qyi14545271337334171048__produces_trans__refines (* <logic::fmap::FMapIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap
  
  type t_FMapIter = { t_FMapIter__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some tuple
  
  function get (self: Seq.seq tuple) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  function view'0 (self: t_FMapIter) : t_FMap = self.t_FMapIter__inner
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate produces (self: t_FMapIter) (visited: Seq.seq tuple) (o: t_FMapIter) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get visited i = C_Some { f0 = k; f1 = v }
        -> not contains (view'0 o) k /\ get'0 (view'0 self) k = C_Some'0 v)
    /\ len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'0 o) k = get'0 (view'0 self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FMapIter. forall ab: Seq.seq tuple. forall b: t_FMapIter. forall bc: Seq.seq tuple. forall c: t_FMapIter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__logic__fmap__qyi4821133328050537988__produces_trans__refines (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap
  
  type t_FMapIterRef = { t_FMapIterRef__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some tuple
  
  function get (self: Seq.seq tuple) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains [@inline:trivial] (self: t_FMap'0) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  predicate index_logic [@inline:trivial] (self: Map.map t_FMap'0 bool) (a: t_FMap'0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_FMap'0 bool) : t_FMap'0
  
  axiom such_that_spec: forall p: Map.map t_FMap'0 bool. (exists x: t_FMap'0. index_logic p x)
      -> index_logic p (such_that p)
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'1 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'1
  
  function view'1 (self: t_FMapIterRef) : t_FMap'0 = such_that (fun (m: t_FMap'0) -> forall k: t_K, v: t_V. (get'0 m k
        = C_Some'0 v)
      = (get'1 self.t_FMapIterRef__inner k = C_Some'1 v))
  
  predicate produces (self: t_FMapIterRef) (visited: Seq.seq tuple) (o: t_FMapIterRef) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get visited i = C_Some { f0 = k; f1 = v }
        -> not contains (view'1 o) k /\ get'0 (view'1 self) k = C_Some'0 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'1 o) k = get'0 (view'1 self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FMapIterRef. forall ab: Seq.seq tuple. forall b: t_FMapIterRef. forall bc: Seq.seq tuple. forall c: t_FMapIterRef. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__logic__fmap__qyi4821133328050537988__produces_refl__refines (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap
  
  type t_FMapIterRef = { t_FMapIterRef__inner: t_FMap }
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_Option = C_None | C_Some tuple
  
  function get (self: Seq.seq tuple) (ix: int) : t_Option = if 0 <= ix /\ ix < Seq.length self then
      C_Some (Seq.get self ix)
    else
      C_None
  
  
  type t_FMap'0
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function view (self: t_FMap'0) : Map.map t_K t_Option'0
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get'0
  
  predicate contains [@inline:trivial] (self: t_FMap'0) (k: t_K) = get'0 self k <> C_None'0
  
  meta "rewrite_def" predicate contains
  
  predicate index_logic [@inline:trivial] (self: Map.map t_FMap'0 bool) (a: t_FMap'0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_FMap'0 bool) : t_FMap'0
  
  axiom such_that_spec: forall p: Map.map t_FMap'0 bool. (exists x: t_FMap'0. index_logic p x)
      -> index_logic p (such_that p)
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function view'0 (self: t_FMap) : Map.map t_K t_Option'1
  
  function get'1 [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view'0 self) k
  
  meta "rewrite_def" function get'1
  
  function view'1 (self: t_FMapIterRef) : t_FMap'0 = such_that (fun (m: t_FMap'0) -> forall k: t_K, v: t_V. (get'0 m k
        = C_Some'0 v)
      = (get'1 self.t_FMapIterRef__inner k = C_Some'1 v))
  
  predicate produces (self: t_FMapIterRef) (visited: Seq.seq tuple) (o: t_FMapIterRef) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get visited i = C_Some { f0 = k; f1 = v }
        -> not contains (view'1 o) k /\ get'0 (view'1 self) k = C_Some'0 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get'0 (view'1 o) k = get'0 (view'1 self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMapIterRef. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
        -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__logic__seq__qyi17207334030084003748__produces_refl__refines (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  predicate produces (self: t_SeqIter) (visited: Seq.seq t_T) (o: t_SeqIter) = view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__logic__seq__qyi17207334030084003748__produces_trans__refines (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter = { t_SeqIter__inner: Seq.seq t_T }
  
  function view (self: t_SeqIter) : Seq.seq t_T = self.t_SeqIter__inner
  
  predicate produces (self: t_SeqIter) (visited: Seq.seq t_T) (o: t_SeqIter) = view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_SeqIter. forall ab: Seq.seq t_T. forall b: t_SeqIter. forall bc: Seq.seq t_T. forall c: t_SeqIter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__logic__seq__qyi7064237699691893604__produces_refl__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef = { t_SeqIterRef__inner: Seq.seq t_T; t_SeqIterRef__index: int }
  
  function view (self: t_SeqIterRef) : Seq.seq t_T =
    Seq.([..]) self.t_SeqIterRef__inner self.t_SeqIterRef__index (Seq.length self.t_SeqIterRef__inner)
  
  predicate produces (self: t_SeqIterRef) (visited: Seq.seq t_T) (o: t_SeqIterRef) =
    let visited'0 = visited in view self = Seq.(++) visited'0 (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIterRef. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__logic__seq__qyi7064237699691893604__produces_trans__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef = { t_SeqIterRef__inner: Seq.seq t_T; t_SeqIterRef__index: int }
  
  function view (self: t_SeqIterRef) : Seq.seq t_T =
    Seq.([..]) self.t_SeqIterRef__inner self.t_SeqIterRef__index (Seq.length self.t_SeqIterRef__inner)
  
  predicate produces (self: t_SeqIterRef) (visited: Seq.seq t_T) (o: t_SeqIterRef) =
    let visited'0 = visited in view self = Seq.(++) visited'0 (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_SeqIterRef. forall ab: Seq.seq t_T. forall b: t_SeqIterRef. forall bc: Seq.seq t_T. forall c: t_SeqIterRef. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__array__qyi10624171005586529217__produces_trans__refines (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__array__qyi10624171005586529217__produces_refl__refines (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_map__qyi2751221633790567300__produces_refl__refines (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IntoIter
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_IntoIter) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq tuple) (o: t_IntoIter) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
        -> (exists k1: t_K. deep_model k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2 /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1).f0 = deep_model (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
        -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__collections__hash_map__qyi2751221633790567300__produces_trans__refines (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IntoIter
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_IntoIter) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq tuple) (o: t_IntoIter) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
        -> (exists k1: t_K. deep_model k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2 /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1).f0 = deep_model (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter. forall ab: Seq.seq tuple. forall b: t_IntoIter. forall bc: Seq.seq tuple. forall c: t_IntoIter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_map__qyi17229515035433614012__produces_trans__refines (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_Iter) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_Iter) (visited: Seq.seq tuple) (o: t_Iter) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
        -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter. forall ab: Seq.seq tuple. forall b: t_Iter. forall bc: Seq.seq tuple. forall c: t_Iter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_map__qyi17229515035433614012__produces_refl__refines (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_Iter) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some t_V
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_Iter) (visited: Seq.seq tuple) (o: t_Iter) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
        -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
        -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__collections__hash_map__qyi7200148303891188075__produces_trans__refines (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IterMut
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_IterMut) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some (MutBorrow.t t_V)
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_IterMut) (visited: Seq.seq tuple) (o: t_IterMut) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
        -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut. forall ab: Seq.seq tuple. forall b: t_IterMut. forall bc: Seq.seq tuple. forall c: t_IterMut. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_map__qyi7200148303891188075__produces_refl__refines (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IterMut
  
  type t_K
  
  type t_V
  
  type tuple = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  function view (self: t_IterMut) : t_FMap
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option = C_None | C_Some (MutBorrow.t t_V)
  
  function view'0 (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option = Map.get (view'0 self) k
  
  meta "rewrite_def" function get
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate produces (self: t_IterMut) (visited: Seq.seq tuple) (o: t_IterMut) =
    len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { f0 = k; f1 = v }
        -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
        -> get (view self) k = C_Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
        -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { f0 = k1; f1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1).f0 = deep_model'0 (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IterMut. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
        -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__collections__hash_set__qyi16362841949556730032__produces_refl__refines (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_IntoIter
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_IntoIter) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_IntoIter) (visited: Seq.seq t_T) (end': t_IntoIter) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j) -> i = j)
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_set__qyi16362841949556730032__produces_trans__refines (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_IntoIter
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_IntoIter) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_IntoIter) (visited: Seq.seq t_T) (end': t_IntoIter) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j) -> i = j)
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_set__qyi14856790125802176998__produces_trans__refines (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Iter) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Iter) (visited: Seq.seq t_T) (end': t_Iter) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter. forall ab: Seq.seq t_T. forall b: t_Iter. forall bc: Seq.seq t_T. forall c: t_Iter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_set__qyi14856790125802176998__produces_refl__refines (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Iter) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Iter) (visited: Seq.seq t_T) (end': t_Iter) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_set__qyi1282364555482257102__produces_refl__refines (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Intersection
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Intersection. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_set__qyi1282364555482257102__produces_trans__refines (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Intersection
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Intersection. forall ab: Seq.seq t_T. forall b: t_Intersection. forall bc: Seq.seq t_T. forall c: t_Intersection. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__collections__hash_set__qyi3953735896298504416__produces_refl__refines (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Difference
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Difference) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Difference. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__collections__hash_set__qyi3953735896298504416__produces_trans__refines (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Difference
  
  type t_T
  
  type t_DeepModelTy
  
  function view (self: t_Difference) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference) =
    Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
        -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
        -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
        -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
      -> i = j)
  
  predicate produces (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference) = set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Difference. forall ab: Seq.seq t_T. forall b: t_Difference. forall bc: Seq.seq t_T. forall c: t_Difference. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__deque__qyi7285194934641240501__produces_refl__refines (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__deque__qyi7285194934641240501__produces_trans__refines (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter. forall ab: Seq.seq t_T. forall b: t_Iter. forall bc: Seq.seq t_T. forall c: t_Iter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__cloned__qyi12959622540969022492__produces_refl__refines (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Cloned
  
  type t_T
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_T) self
  
  function iter (self: t_Cloned) : t_I
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate produces'0 (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Cloned. forall result: (). produces'0 self (Seq.empty: Seq.seq t_T) self
        -> produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__cloned__qyi12959622540969022492__produces_trans__refines (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Cloned
  
  type t_T
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_T) self
  
  function iter (self: t_Cloned) : t_I
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  predicate produces'0 (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Cloned. forall ab: Seq.seq t_T. forall b: t_Cloned. forall bc: Seq.seq t_T. forall c: t_Cloned. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__copied__qyi13437018464510937253__produces_refl__refines (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Copied
  
  type t_T
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_T) self
  
  function iter (self: t_Copied) : t_I
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Copied. forall result: (). produces'0 self (Seq.empty: Seq.seq t_T) self
        -> produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__copied__qyi13437018464510937253__produces_trans__refines (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Copied
  
  type t_T
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_T) self
  
  function iter (self: t_Copied) : t_I
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    exists s: Seq.seq t_T. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Copied. forall ab: Seq.seq t_T. forall b: t_Copied. forall bc: Seq.seq t_T. forall c: t_Copied. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__empty__qyi10224556657375706108__produces_refl__refines (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty
  
  type t_T
  
  predicate produces (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Empty. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__empty__qyi10224556657375706108__produces_trans__refines (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty
  
  type t_T
  
  predicate produces (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Empty. forall ab: Seq.seq t_T. forall b: t_Empty. forall bc: Seq.seq t_T. forall c: t_Empty. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__enumerate__qyi17760969447503171583__produces_trans__refines (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Enumerate
  
  type t_Item
  
  type tuple = { f0: UInt64.t; f1: t_Item }
  
  function n (self: t_Enumerate) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Enumerate) : t_I
  
  predicate produces'0 (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate) =
    Seq.length visited = UInt64.t'int (n o) - UInt64.t'int (n self)
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n self) + i /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Enumerate. forall ab: Seq.seq tuple. forall b: t_Enumerate. forall bc: Seq.seq tuple. forall c: t_Enumerate. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__enumerate__qyi17760969447503171583__produces_refl__refines (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Enumerate
  
  type t_Item
  
  type tuple = { f0: UInt64.t; f1: t_Item }
  
  function n (self: t_Enumerate) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Enumerate) : t_I
  
  predicate produces'0 (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate) =
    Seq.length visited = UInt64.t'int (n o) - UInt64.t'int (n self)
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n self) + i /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Enumerate. forall result: (). produces'0 self (Seq.empty: Seq.seq tuple) self
        -> produces'0 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__iter__filter__qyi990465010469908032__produces_refl__refines (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Filter
  
  type t_Item
  
  type t_F
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (_1: t_F) = forall f: t_F, i: t_Item. precondition f i
  
  function func (self: t_Filter) : t_F
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (_1: t_F) = forall f: t_F, g: t_F. hist_inv f g -> f = g
  
  predicate precise (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut f1 i f2 true /\ postcondition_mut f1 i f2 false)
  
  predicate private_invariant (f: t_Filter) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Filter) : t_I
  
  predicate produces'0 (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter) =
    private_invariant self
    -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Filter. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
        -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__filter__qyi990465010469908032__produces_trans__refines (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Filter
  
  type t_Item
  
  type t_F
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (_1: t_F) = forall f: t_F, i: t_Item. precondition f i
  
  function func (self: t_Filter) : t_F
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (_1: t_F) = forall f: t_F, g: t_F. hist_inv f g -> f = g
  
  predicate precise (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut f1 i f2 true /\ postcondition_mut f1 i f2 false)
  
  predicate private_invariant (f: t_Filter) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Filter) : t_I
  
  predicate produces'0 (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter) =
    private_invariant self
    -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Filter. forall ab: Seq.seq t_Item. forall b: t_Filter. forall bc: Seq.seq t_Item. forall c: t_Filter. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__filter_map__qyi11148334412739605610__produces_refl__refines (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FilterMap
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (f: t_F) = forall i: t_Item. precondition f i
  
  function func (self: t_FilterMap) : t_F
  
  type t_Option = C_None | C_Some t_B
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_Option)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (f: t_F) = forall g: t_F. hist_inv f g -> f = g
  
  predicate precise (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
      /\ postcondition_mut f1 i f2 (C_None))
  
  predicate private_invariant (f: t_FilterMap) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_FilterMap) : t_I
  
  predicate produces'0 (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap) =
    private_invariant self
    -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FilterMap. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
        -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__std__iter__filter_map__qyi11148334412739605610__produces_trans__refines (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FilterMap
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate no_precondition (f: t_F) = forall i: t_Item. precondition f i
  
  function func (self: t_FilterMap) : t_F
  
  type t_Option = C_None | C_Some t_B
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_Option)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate immutable (f: t_F) = forall g: t_F. hist_inv f g -> f = g
  
  predicate precise (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
      /\ postcondition_mut f1 i f2 (C_None))
  
  predicate private_invariant (f: t_FilterMap) = no_precondition (func f) /\ immutable (func f) /\ precise (func f)
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_FilterMap) : t_I
  
  predicate produces'0 (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap) =
    private_invariant self
    -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FilterMap. forall ab: Seq.seq t_B. forall b: t_FilterMap. forall bc: Seq.seq t_B. forall c: t_FilterMap. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__fuse__qyi3534357438560453877__produces_refl__refines (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse
  
  type t_Item
  
  type t_I
  
  type t_Option = C_None | C_Some t_I
  
  function view (self: t_Fuse) : t_Option
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse) =
    match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Fuse. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
        -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__fuse__qyi3534357438560453877__produces_trans__refines (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse
  
  type t_Item
  
  type t_I
  
  type t_Option = C_None | C_Some t_I
  
  function view (self: t_Fuse) : t_Option
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse) =
    match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Fuse. forall ab: Seq.seq t_Item. forall b: t_Fuse. forall bc: Seq.seq t_Item. forall c: t_Fuse. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__map__qyi306403796899090344__produces_refl__refines (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Map
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function func (self: t_Map) : t_F
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Map) : t_I
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map) =
    hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
        /\ produces (iter self) s (iter succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func self = func succ
          else
            (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv (func self) (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current (Seq.get s i)
          /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
        -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__std__iter__map__qyi306403796899090344__produces_trans__refines (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Map
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function func (self: t_Map) : t_F
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Map) : t_I
  
  predicate precondition (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map) =
    hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
        /\ produces (iter self) s (iter succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func self = func succ
          else
            (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv (func self) (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current (Seq.get s i)
          /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Map. forall ab: Seq.seq t_B. forall b: t_Map. forall bc: Seq.seq t_B. forall c: t_Map. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__map_inv__qyi10280853954906842925__produces_refl__refines (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv = { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current { f0 = Seq.get s i;
                                                   f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_MapInv. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
        -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__std__iter__map_inv__qyi10280853954906842925__produces_trans__refines (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv = { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once (self: t_F) (args: tuple) (result: t_B)
  
  predicate resolve (_1: t_F)
  
  predicate postcondition_mut (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  function fn_mut_once (self: t_F) (args: tuple) (res: t_B) : ()
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. postcondition_once self args res
      = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  function hist_inv_trans (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. hist_inv self self
  
  function postcondition_mut_hist_inv (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: t_F, args: tuple, res_state: t_F, res: t_B. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv) =
    hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
        /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.t_MapInv__func = succ.t_MapInv__func
          else
            (Seq.get fs 0).current = self.t_MapInv__func
            /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv self.t_MapInv__func (Seq.get fs i).current
          /\ precondition (Seq.get fs i).current { f0 = Seq.get s i;
                                                   f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut (Seq.get fs i).current { f0 = Seq.get s i;
                                                        f1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_MapInv. forall ab: Seq.seq t_B. forall b: t_MapInv. forall bc: Seq.seq t_B. forall c: t_MapInv. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__once__qyi403149096834806456__produces_trans__refines (* <std::iter::Once<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_Once) : t_Option
  
  predicate produces (self: t_Once) (visited: Seq.seq t_T) (o: t_Once) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Once. forall ab: Seq.seq t_T. forall b: t_Once. forall bc: Seq.seq t_T. forall c: t_Once. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__once__qyi403149096834806456__produces_refl__refines (* <std::iter::Once<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_Once) : t_Option
  
  predicate produces (self: t_Once) (visited: Seq.seq t_T) (o: t_Once) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Once. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__range__qyi990280207493253415__produces_refl__refines (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range = { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model (self: t_Idx) : int
  
  predicate produces (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Range. forall result: (). produces self (Seq.empty: Seq.seq t_Idx) self
        -> produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__std__iter__range__qyi990280207493253415__produces_trans__refines (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range = { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model (self: t_Idx) : int
  
  predicate produces (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range) =
    self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Range. forall ab: Seq.seq t_Idx. forall b: t_Range. forall bc: Seq.seq t_Idx. forall c: t_Range. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__range__qyi2076862701479908027__produces_trans__refines (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_RangeInclusive. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__range__qyi2076862701479908027__produces_refl__refines (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_RangeInclusive. forall result: (). produces self (Seq.empty: Seq.seq t_Idx) self
        -> produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__std__iter__repeat__qyi13156433517158091792__produces_refl__refines (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Repeat
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  function view (self: t_Repeat) : t_T
  
  predicate produces (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat) =
    self = o /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> postcondition () (view self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Repeat. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__iter__repeat__qyi13156433517158091792__produces_trans__refines (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Repeat
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate postcondition_once (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
      -> (let self_ = args in inv res)
  
  predicate resolve [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
      -> (let self_ = args in inv res)
  
  function fn_mut_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). hist_inv self b -> hist_inv b c -> hist_inv self c
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      -> hist_inv self res_state
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
      -> (let self_ = args in inv res)
  
  function fn_once (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  function view (self: t_Repeat) : t_T
  
  predicate produces (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat) =
    self = o /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> postcondition () (view self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Repeat. forall ab: Seq.seq t_T. forall b: t_Repeat. forall bc: Seq.seq t_T. forall c: t_Repeat. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__rev__qyi8570485907461319344__produces_trans__refines (* <std::iter::Rev<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev
  
  type t_Item
  
  type t_I
  
  predicate produces_back (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back a ab b
      -> produces_back b bc c -> produces_back a (Seq.(++) ab bc) c
  
  function produces_back_refl (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. produces_back self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Rev) : t_I
  
  predicate produces (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev) = produces_back (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Rev. forall ab: Seq.seq t_Item. forall b: t_Rev. forall bc: Seq.seq t_Item. forall c: t_Rev. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__rev__qyi8570485907461319344__produces_refl__refines (* <std::iter::Rev<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev
  
  type t_Item
  
  type t_I
  
  predicate produces_back (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back a ab b
      -> produces_back b bc c -> produces_back a (Seq.(++) ab bc) c
  
  function produces_back_refl (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. produces_back self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Rev) : t_I
  
  predicate produces (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev) = produces_back (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Rev. forall result: (). produces self (Seq.empty: Seq.seq t_Item) self
        -> produces self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__skip__qyi13252230069947492373__produces_trans__refines (* <std::iter::Skip<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Skip
  
  type t_Item
  
  function n (self: t_Skip) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Skip) : t_I
  
  predicate resolve (_1: t_Item)
  
  predicate produces'0 (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n self)
      /\ produces (iter self) (Seq.(++) s visited) (iter o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Skip. forall ab: Seq.seq t_Item. forall b: t_Skip. forall bc: Seq.seq t_Item. forall c: t_Skip. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__skip__qyi13252230069947492373__produces_refl__refines (* <std::iter::Skip<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Skip
  
  type t_Item
  
  function n (self: t_Skip) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Skip) : t_I
  
  predicate resolve (_1: t_Item)
  
  predicate produces'0 (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n self)
      /\ produces (iter self) (Seq.(++) s visited) (iter o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Skip. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
        -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__take__qyi10011901481142542325__produces_refl__refines (* <std::iter::Take<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Take
  
  type t_Item
  
  function n (self: t_Take) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Take) : t_I
  
  predicate produces'0 (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take) =
    UInt64.t'int (n self) = UInt64.t'int (n o) + Seq.length visited /\ produces (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Take. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
        -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__take__qyi10011901481142542325__produces_trans__refines (* <std::iter::Take<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Take
  
  type t_Item
  
  function n (self: t_Take) : UInt64.t
  
  type t_I
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter (self: t_Take) : t_I
  
  predicate produces'0 (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take) =
    UInt64.t'int (n self) = UInt64.t'int (n o) + Seq.length visited /\ produces (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Take. forall ab: Seq.seq t_Item. forall b: t_Take. forall bc: Seq.seq t_Item. forall c: t_Take. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__zip__qyi9055347977946847871__produces_refl__refines (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Zip
  
  type t_Item
  
  type t_Item'0
  
  type tuple = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. produces self (Seq.empty: Seq.seq t_Item) self
  
  function itera (self: t_Zip) : t_A
  
  type t_B
  
  predicate produces'0 (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans'0 (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb (self: t_Zip) : t_B
  
  predicate produces'1 (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Zip. forall result: (). produces'1 self (Seq.empty: Seq.seq tuple) self
        -> produces'1 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__std__iter__zip__qyi9055347977946847871__produces_trans__refines (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Zip
  
  type t_Item
  
  type t_Item'0
  
  type tuple = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. produces self (Seq.empty: Seq.seq t_Item) self
  
  function itera (self: t_Zip) : t_A
  
  type t_B
  
  predicate produces'0 (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans'0 (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_spec'0:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb (self: t_Zip) : t_B
  
  predicate produces'1 (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Zip. forall ab: Seq.seq tuple. forall b: t_Zip. forall bc: Seq.seq tuple. forall c: t_Zip. produces'1 b bc c
                /\ produces'1 a ab b
              -> produces'1 b bc c
              /\ produces'1 a ab b
              /\ (forall result: (). produces'1 a (Seq.(++) ab bc) c -> produces'1 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__qyi15776886527438550973__produces_refl__refines (* <&mut I as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t t_I. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
        -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__std__iter__qyi15776886527438550973__produces_trans__refines (* <&mut I as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: MutBorrow.t t_I. forall ab: Seq.seq t_Item. forall b: MutBorrow.t t_I. forall bc: Seq.seq t_Item. forall c: MutBorrow.t t_I. produces'0 b bc c
                /\ produces'0 a ab b
              -> produces'0 b bc c
              /\ produces'0 a ab b
              /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__option__qyi16875853811649438191__produces_refl__refines (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_IntoIter) : t_Option
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__option__qyi16875853811649438191__produces_trans__refines (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_IntoIter) : t_Option
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__option__qyi14990757896004605758__produces_trans__refines (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_Iter) : t_Option
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter. forall ab: Seq.seq t_T. forall b: t_Iter. forall bc: Seq.seq t_T. forall c: t_Iter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__option__qyi14990757896004605758__produces_refl__refines (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function view (self: t_Iter) : t_Option
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__option__qyi3871448523939226478__produces_refl__refines (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut
  
  type t_T
  
  type t_Option = C_None | C_Some (MutBorrow.t t_T)
  
  function view (self: t_IterMut) : t_Option
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IterMut. forall result: (). produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
        -> produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__std__option__qyi3871448523939226478__produces_trans__refines (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut
  
  type t_T
  
  type t_Option = C_None | C_Some (MutBorrow.t t_T)
  
  function view (self: t_IterMut) : t_Option
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__slice__qyi18390169926879820046__produces_trans__refines (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter. forall ab: Seq.seq t_T. forall b: t_Iter. forall bc: Seq.seq t_T. forall c: t_Iter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__slice__qyi18390169926879820046__produces_refl__refines (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_ref_seq (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq self) = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
        -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view (self: t_Iter) : Slice64.slice t_T
  
  predicate produces (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter) =
    to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__slice__qyi16967112428427721086__produces_refl__refines (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_IterMut
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_mut_seq (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq self)
        -> Seq.get (to_mut_seq self) i
        = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_spec: forall self: t_IterMut. Seq.length (Slice64.view (view self).final)
      = Seq.length (Slice64.view (view self).current)
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut) =
    to_mut_seq (view self) = Seq.(++) visited (to_mut_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IterMut. forall result: (). produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
        -> produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__std__slice__qyi16967112428427721086__produces_trans__refines (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_IterMut
  
  type t_T
  
  function index_logic [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_logic
  
  function to_mut_seq (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq self)
        -> Seq.get (to_mut_seq self) i
        = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_spec: forall self: t_IterMut. Seq.length (Slice64.view (view self).final)
      = Seq.length (Slice64.view (view self).current)
  
  predicate produces (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut) =
    to_mut_seq (view self) = Seq.(++) visited (to_mut_seq (view tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__vec__qyi9182455043427114830__produces_refl__refines (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter) =
    view self = Seq.(++) visited (view rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
        -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__std__vec__qyi9182455043427114830__produces_trans__refines (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter
  
  type t_T
  
  function view (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter) =
    view self = Seq.(++) visited (view rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
                /\ produces a ab b
              -> produces b bc c
              /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__gt__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  function deep_model [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: int) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ > other)
          -> result = (deep_model'0 self_ > deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__ge__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  function deep_model [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: int) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ >= other)
          -> result = (deep_model'0 self_ >= deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__le__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  function deep_model [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: int) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ <= other)
          -> result = (deep_model'0 self_ <= deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__partial_cmp__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  type t_Option = C_None | C_Some t_Ordering
  
  function deep_model [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall rhs: int. forall result: t_Option. result = C_Some (cmp_log self_ rhs)
          -> result = C_Some (cmp_log (deep_model self_) (deep_model rhs))
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__lt__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  function deep_model [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: int) : int = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ < other)
          -> result = (deep_model'0 self_ < deep_model'0 other)
end
module M_creusot_contracts__peano__qyi18300662544233371341__partial_cmp__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  function eq_cmp'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_PeanoInt) : () = ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. cmp_log'0 x x = C_Equal
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_gt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_ge_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_lt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_le_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. le_log x y = (cmp_log'0 x y <> C_Greater)
  
  type t_Option = C_None | C_Some t_Ordering
  
  function deep_model [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function deep_model
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: t_Option. result
            = C_Some (cmp_log'0 self_ rhs) -> result = C_Some (cmp_log (deep_model self_) (deep_model rhs))
end
module M_creusot_contracts__peano__qyi18300662544233371341__le__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  function deep_model [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.le (view self_) (view other) -> result = UInt64.le (deep_model'0 self_) (deep_model'0 other)
end
module M_creusot_contracts__peano__qyi18300662544233371341__lt__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  function deep_model [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.lt (view self_) (view other) -> result = UInt64.lt (deep_model'0 self_) (deep_model'0 other)
end
module M_creusot_contracts__peano__qyi18300662544233371341__gt__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  function deep_model [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.gt (view self_) (view other) -> result = UInt64.gt (deep_model'0 self_) (deep_model'0 other)
end
module M_creusot_contracts__peano__qyi18300662544233371341__ge__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  function view [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function view
  
  function deep_model [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function deep_model
  
  function deep_model'0 [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.ge (view self_) (view other) -> result = UInt64.ge (deep_model'0 self_) (deep_model'0 other)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__cmp_ge_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate ge_log'0 (self: t_T) (other: t_T) = ge_log self other
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). ge_log'0 x y = (cmp_log'0 x y <> C_Less)
          -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__refl__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall result: (). cmp_log'0 x x = C_Equal -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__antisym1__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. cmp_log'0 x y = C_Less
        -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__cmp_gt_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate gt_log'0 (self: t_T) (other: t_T) = gt_log self other
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). gt_log'0 x y = (cmp_log'0 x y = C_Greater)
          -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__cmp_le_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate le_log'0 (self: t_T) (other: t_T) = le_log self other
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). le_log'0 x y = (cmp_log'0 x y <> C_Greater)
          -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__cmp_lt_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  predicate lt_log'0 (self: t_T) (other: t_T) = lt_log self other
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). lt_log'0 x y = (cmp_log'0 x y = C_Less)
          -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__eq_cmp__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). (x = y) = (cmp_log'0 x y = C_Equal)
          -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__antisym2__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. cmp_log'0 x y = C_Greater
        -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2486556465392689020__trans__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_T) (o: t_T) : t_Ordering = cmp_log self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall z: t_T. forall o: t_Ordering. cmp_log'0 y z = o
              /\ cmp_log'0 x y = o
            -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x > y) = (cmp_log x y = C_Greater)
          -> (x > y) = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x >= y) = (cmp_log x y <> C_Less)
          -> (x >= y) = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x <= y) = (cmp_log x y <> C_Greater)
          -> (x <= y) = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall z: int. forall o: t_Ordering. cmp_log y z = o /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x < y) = (cmp_log x y = C_Less)
          -> (x < y) = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: int) (o: int) : t_Ordering = if self < o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.gt x y = (cmp_log x y = C_Greater)
          -> UInt8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall z: UInt8.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.le x y = (cmp_log x y <> C_Greater)
          -> UInt8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.lt x y = (cmp_log x y = C_Less)
          -> UInt8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.ge x y = (cmp_log x y <> C_Less)
          -> UInt8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.ge x y = (cmp_log x y <> C_Less)
          -> UInt16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.lt x y = (cmp_log x y = C_Less)
          -> UInt16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.le x y = (cmp_log x y <> C_Greater)
          -> UInt16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall z: UInt16.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.gt x y = (cmp_log x y = C_Greater)
          -> UInt16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.gt x y = (cmp_log x y = C_Greater)
          -> UInt32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall z: UInt32.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.lt x y = (cmp_log x y = C_Less)
          -> UInt32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.ge x y = (cmp_log x y <> C_Less)
          -> UInt32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.le x y = (cmp_log x y <> C_Greater)
          -> UInt32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y = (cmp_log x y <> C_Greater)
          -> UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y = (cmp_log x y <> C_Less)
          -> UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y = (cmp_log x y = C_Greater)
          -> UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y = (cmp_log x y = C_Less)
          -> UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.le x y = (cmp_log x y <> C_Greater)
          -> UInt128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall z: UInt128.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.ge x y = (cmp_log x y <> C_Less)
          -> UInt128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.gt x y = (cmp_log x y = C_Greater)
          -> UInt128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.lt x y = (cmp_log x y = C_Less)
          -> UInt128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y = (cmp_log x y <> C_Less)
          -> UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y = (cmp_log x y <> C_Greater)
          -> UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y = (cmp_log x y = C_Less)
          -> UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y = (cmp_log x y = C_Greater)
          -> UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.lt x y = (cmp_log x y = C_Less)
          -> Int8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.ge x y = (cmp_log x y <> C_Less)
          -> Int8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall z: Int8.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.gt x y = (cmp_log x y = C_Greater)
          -> Int8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.le x y = (cmp_log x y <> C_Greater)
          -> Int8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.ge x y = (cmp_log x y <> C_Less)
          -> Int16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall z: Int16.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.le x y = (cmp_log x y <> C_Greater)
          -> Int16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.lt x y = (cmp_log x y = C_Less)
          -> Int16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.gt x y = (cmp_log x y = C_Greater)
          -> Int16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.le x y = (cmp_log x y <> C_Greater)
          -> Int32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall z: Int32.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.gt x y = (cmp_log x y = C_Greater)
          -> Int32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.lt x y = (cmp_log x y = C_Less)
          -> Int32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.ge x y = (cmp_log x y <> C_Less)
          -> Int32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log x y = C_Less)
          -> Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y = (cmp_log x y = C_Greater)
          -> Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y = (cmp_log x y <> C_Greater)
          -> Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log x y <> C_Less)
          -> Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.gt x y = (cmp_log x y = C_Greater)
          -> Int128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.ge x y = (cmp_log x y <> C_Less)
          -> Int128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.lt x y = (cmp_log x y = C_Less)
          -> Int128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.le x y = (cmp_log x y <> C_Greater)
          -> Int128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall z: Int128.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log x y <> C_Less)
          -> Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log x y = C_Less)
          -> Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y = (cmp_log x y = C_Greater)
          -> Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y = (cmp_log x y <> C_Greater)
          -> Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.le x y = (cmp_log x y <> C_Greater)
          -> Char.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.ge x y = (cmp_log x y <> C_Less)
          -> Char.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.lt x y = (cmp_log x y = C_Less)
          -> Char.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall z: Char.t. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.gt x y = (cmp_log x y = C_Greater)
          -> Char.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.le x y = (cmp_log x y <> C_Greater)
          -> Bool.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.ge x y = (cmp_log x y <> C_Less)
          -> Bool.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.gt x y = (cmp_log x y = C_Greater)
          -> Bool.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall z: bool. forall o: t_Ordering. cmp_log y z = o /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.lt x y = (cmp_log x y = C_Less)
          -> Bool.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_B) (o: t_B)
  
  function cmp_gt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_B) (o: t_B)
  
  function cmp_ge_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_B) (o: t_B)
  
  function cmp_lt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_B) (o: t_B)
  
  function cmp_le_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_A) (o: t_A)
  
  function cmp_le_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate ge_log'1 (self: tuple) (o: tuple) = self.f0 = o.f0 /\ ge_log self.f1 o.f1 \/ gt_log'0 self.f0 o.f0
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log'0 self.f0 o.f0 in if r = C_Equal then
      cmp_log self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall y: tuple. forall result: (). ge_log'1 x y = (cmp_log'1 x y <> C_Less)
          -> ge_log'1 x y = (cmp_log'1 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall result: (). cmp_log'1 x x = C_Equal -> cmp_log'1 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_B) (o: t_B)
  
  function cmp_gt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_B) (o: t_B)
  
  function cmp_ge_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_B) (o: t_B)
  
  function cmp_lt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_B) (o: t_B)
  
  function cmp_le_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_A) (o: t_A)
  
  function cmp_le_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate gt_log'1 (self: tuple) (o: tuple) = self.f0 = o.f0 /\ gt_log self.f1 o.f1 \/ gt_log'0 self.f0 o.f0
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log'0 self.f0 o.f0 in if r = C_Equal then
      cmp_log self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall y: tuple. forall result: (). gt_log'1 x y = (cmp_log'1 x y = C_Greater)
          -> gt_log'1 x y = (cmp_log'1 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_B) (o: t_B)
  
  function cmp_gt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_B) (o: t_B)
  
  function cmp_ge_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_B) (o: t_B)
  
  function cmp_lt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_B) (o: t_B)
  
  function cmp_le_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_A) (o: t_A)
  
  function cmp_le_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate lt_log'1 (self: tuple) (o: tuple) = self.f0 = o.f0 /\ lt_log self.f1 o.f1 \/ lt_log'0 self.f0 o.f0
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log'0 self.f0 o.f0 in if r = C_Equal then
      cmp_log self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall y: tuple. forall result: (). lt_log'1 x y = (cmp_log'1 x y = C_Less)
          -> lt_log'1 x y = (cmp_log'1 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall y: tuple. forall result: (). (x = y) = (cmp_log'1 x y = C_Equal)
          -> (x = y) = (cmp_log'1 x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall y: tuple. cmp_log'1 x y = C_Less
        -> cmp_log'1 x y = C_Less /\ (forall result: (). cmp_log'1 y x = C_Greater -> cmp_log'1 y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall y: tuple. cmp_log'1 x y = C_Greater
        -> cmp_log'1 x y = C_Greater /\ (forall result: (). cmp_log'1 y x = C_Less -> cmp_log'1 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_B) (o: t_B)
  
  function cmp_gt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_B) (o: t_B)
  
  function cmp_ge_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_B) (o: t_B)
  
  function cmp_lt_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_B) (o: t_B)
  
  function cmp_le_log (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_A) (o: t_A)
  
  function cmp_le_log'0 (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate le_log'1 (self: tuple) (o: tuple) = self.f0 = o.f0 /\ le_log self.f1 o.f1 \/ lt_log'0 self.f0 o.f0
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log'0 self.f0 o.f0 in if r = C_Equal then
      cmp_log self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall y: tuple. forall result: (). le_log'1 x y = (cmp_log'1 x y <> C_Greater)
          -> le_log'1 x y = (cmp_log'1 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tuple = { f0: t_A; f1: t_B }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_A) (o: t_A)
  
  function cmp_gt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_A) (o: t_A)
  
  function cmp_ge_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_A) (o: t_A)
  
  function cmp_lt_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_A) (o: t_A)
  
  function cmp_le_log (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 (self: t_B) (o: t_B)
  
  function cmp_le_log'0 (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 (self: tuple) (o: tuple) : t_Ordering = let r = cmp_log self.f0 o.f0 in if r = C_Equal then
      cmp_log'0 self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tuple. forall y: tuple. forall z: tuple. forall o: t_Ordering. cmp_log'1 y z = o
              /\ cmp_log'1 x y = o
            -> cmp_log'1 y z = o /\ cmp_log'1 x y = o /\ (forall result: (). cmp_log'1 x z = o -> cmp_log'1 x z = o)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__cmp_le_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(<=) x y = (cmp_log x y <> C_Greater)
          -> Real.(<=) x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__antisym2__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. cmp_log x y = C_Greater
        -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__antisym1__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. cmp_log x y = C_Less
        -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__cmp_lt_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(<) x y = (cmp_log x y = C_Less)
          -> Real.(<) x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__trans__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall z: Real.real. forall o: t_Ordering. cmp_log y z = o
              /\ cmp_log x y = o
            -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o -> cmp_log x z = o)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__cmp_ge_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(>=) x y = (cmp_log x y <> C_Less)
          -> Real.(>=) x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__refl__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall result: (). cmp_log x x = C_Equal -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__eq_cmp__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). (x = y) = (cmp_log x y = C_Equal)
          -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__real__qyi13152894885581180288__cmp_gt_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(>) x y = (cmp_log x y = C_Greater)
          -> Real.(>) x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__antisym2__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. cmp_log'0 x y = C_Greater
        -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__trans__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall z: t_PeanoInt. forall o: t_Ordering. cmp_log'0 y z
                = o
              /\ cmp_log'0 x y = o
            -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o -> cmp_log'0 x z = o)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_ge_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). ge_log x y = (cmp_log'0 x y <> C_Less)
          -> ge_log x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__antisym1__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. cmp_log'0 x y = C_Less
        -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_lt_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). lt_log x y = (cmp_log'0 x y = C_Less)
          -> lt_log x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_le_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). le_log x y = (cmp_log'0 x y <> C_Greater)
          -> le_log x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__refl__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall result: (). cmp_log'0 x x = C_Equal -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__peano__qyi5347411415401763779__eq_cmp__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). (x = y) = (cmp_log'0 x y = C_Equal)
          -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_gt_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). gt_log x y = (cmp_log'0 x y = C_Greater)
          -> gt_log x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__cmp_lt_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate lt_log'0 (self: t_Reverse) (o: t_Reverse) = cmp_log'0 self o = C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall y: t_Reverse. forall result: (). lt_log'0 x y = (cmp_log'0 x y = C_Less)
          -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__antisym1__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall y: t_Reverse. cmp_log'0 x y = C_Less
        -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__eq_cmp__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall y: t_Reverse. forall result: (). (x = y) = (cmp_log'0 x y = C_Equal)
          -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__refl__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall result: (). cmp_log'0 x x = C_Equal -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__trans__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall y: t_Reverse. forall z: t_Reverse. forall o: t_Ordering. cmp_log'0 y z = o
              /\ cmp_log'0 x y = o
            -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o -> cmp_log'0 x z = o)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__antisym2__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall y: t_Reverse. cmp_log'0 x y = C_Greater
        -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__cmp_le_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate le_log'0 (self: t_Reverse) (o: t_Reverse) = cmp_log'0 self o <> C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall y: t_Reverse. forall result: (). le_log'0 x y = (cmp_log'0 x y <> C_Greater)
          -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__cmp_ge_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate ge_log'0 (self: t_Reverse) (o: t_Reverse) = cmp_log'0 self o <> C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall y: t_Reverse. forall result: (). ge_log'0 x y = (cmp_log'0 x y <> C_Less)
          -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__std__cmp__qyi8793870187857001919__cmp_gt_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse = { t_Reverse__0: t_T }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Reverse) (o: t_Reverse) : t_Ordering = match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate gt_log'0 (self: t_Reverse) (o: t_Reverse) = cmp_log'0 self o = C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse. forall y: t_Reverse. forall result: (). gt_log'0 x y = (cmp_log'0 x y = C_Greater)
          -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__eq_cmp__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall y: t_Option. forall result: (). (x = y) = (cmp_log'0 x y = C_Equal)
          -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__cmp_lt_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  predicate lt_log'0 (self: t_Option) (o: t_Option) = cmp_log'0 self o = C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall y: t_Option. forall result: (). lt_log'0 x y = (cmp_log'0 x y = C_Less)
          -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__antisym1__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall y: t_Option. cmp_log'0 x y = C_Less
        -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__cmp_ge_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  predicate ge_log'0 (self: t_Option) (o: t_Option) = cmp_log'0 self o <> C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall y: t_Option. forall result: (). ge_log'0 x y = (cmp_log'0 x y <> C_Less)
          -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__cmp_gt_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  predicate gt_log'0 (self: t_Option) (o: t_Option) = cmp_log'0 self o = C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall y: t_Option. forall result: (). gt_log'0 x y = (cmp_log'0 x y = C_Greater)
          -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__trans__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall y: t_Option. forall z: t_Option. forall o: t_Ordering. cmp_log'0 y z = o
              /\ cmp_log'0 x y = o
            -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o -> cmp_log'0 x z = o)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__refl__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall result: (). cmp_log'0 x x = C_Equal -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__std__option__qyi15687504979643803552__cmp_le_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  predicate le_log'0 (self: t_Option) (o: t_Option) = cmp_log'0 self o <> C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall y: t_Option. forall result: (). le_log'0 x y = (cmp_log'0 x y <> C_Greater)
          -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__std__option__qyi15687504979643803552__antisym2__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function cmp_log (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log x y = o -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. cmp_log x x = C_Equal
  
  predicate gt_log (self: t_T) (o: t_T)
  
  function cmp_gt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_T) (o: t_T)
  
  function cmp_ge_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_T) (o: t_T)
  
  function cmp_lt_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_T) (o: t_T)
  
  function cmp_le_log (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 (self: t_Option) (o: t_Option) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = C_None; f1 = C_None} -> C_Equal
      | {f0 = C_None; f1 = C_Some _} -> C_Less
      | {f0 = C_Some _; f1 = C_None} -> C_Greater
      | {f0 = C_Some x; f1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option. forall y: t_Option. cmp_log'0 x y = C_Greater
        -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__associative__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function and_then_logic (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Ag. forall b: t_Ag. forall c: t_Ag. forall result: (). and_then_logic (op a b) (fun (ab: t_Ag) -> op ab c)
              = and_then_logic (op b c) (fun (bc: t_Ag) -> op a bc)
            -> and_then_logic (op a b) (fun (ab: t_Ag) -> op ab c) = and_then_logic (op b c) (fun (bc: t_Ag) -> op a bc)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__factor__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag. forall factor: t_Ag. forall result: t_Option. match result with
              | C_Some c -> op factor c = C_Some self
              | C_None -> forall c: t_Ag. op factor c <> C_Some self
              end
          -> match result with
            | C_Some c -> op factor c = C_Some self
            | C_None -> forall c: t_Ag. op factor c <> C_Some self
            end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__core_is_maximal_idemp__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  function core (self: t_Ag) : t_Option = C_Some self
  
  axiom core_spec: forall self: t_Ag. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function factor (self: t_Ag) (factor'0: t_Ag) : t_Option = op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Ag. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Ag) (other: t_Ag) = factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag. forall i: t_Ag. op i self = C_Some self /\ op i i = C_Some i
        -> op i self = C_Some self
        /\ op i i = C_Some i
        /\ (forall result: (). match core self with
              | C_Some c -> incl i c
              | C_None -> false
              end
          -> match core self with
            | C_Some c -> incl i c
            | C_None -> false
            end)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__core__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag. forall result: t_Option. match result with
            | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
            | C_None -> true
            end
        -> match result with
          | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
          | C_None -> true
          end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__commutative__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag = { t_Ag__0: t_T }
  
  type t_Option = C_None | C_Some t_Ag
  
  function op (self: t_Ag) (other: t_Ag) : t_Option = if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Ag. forall b: t_Ag. forall result: (). op a b = op b a -> op a b = op b a
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__commutative__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Excl. forall b: t_Excl. forall result: (). op a b = op b a -> op a b = op b a
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__associative__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function and_then_logic (self: t_Option) (f: Map.map t_Excl t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Excl. forall b: t_Excl. forall c: t_Excl. forall result: (). and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
              = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
            -> and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
            = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__core_is_maximal_idemp__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  function core (self: t_Excl) : t_Option = C_None
  
  axiom core_spec: forall self: t_Excl. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function factor (self: t_Excl) (factor'0: t_Excl) : t_Option = C_None
  
  axiom factor_spec: forall self: t_Excl, factor'0: t_Excl. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_Excl. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_Excl) (other: t_Excl) = factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl. forall i: t_Excl. op i self = C_Some self /\ op i i = C_Some i
        -> op i self = C_Some self
        /\ op i i = C_Some i
        /\ (forall result: (). match core self with
              | C_Some c -> incl i c
              | C_None -> false
              end
          -> match core self with
            | C_Some c -> incl i c
            | C_None -> false
            end)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__core__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl. forall result: t_Option. match result with
            | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
            | C_None -> true
            end
        -> match result with
          | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
          | C_None -> true
          end
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__factor__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl. forall factor: t_Excl. forall result: t_Option. match result with
              | C_Some c -> op factor c = C_Some self
              | C_None -> forall c: t_Excl. op factor c <> C_Some self
              end
          -> match result with
            | C_Some c -> op factor c = C_Some self
            | C_None -> forall c: t_Excl. op factor c <> C_Some self
            end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__factor__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap. forall factor'0: t_FMap. forall result: t_Option. match result with
              | C_Some c -> op'1 factor'0 c = C_Some self
              | C_None -> forall c: t_FMap. op'1 factor'0 c <> C_Some self
              end
          -> match result with
            | C_Some c -> op'1 factor'0 c = C_Some self
            | C_None -> forall c: t_FMap. op'1 factor'0 c <> C_Some self
            end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__core__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap. forall result: t_Option. match result with
            | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
            | C_None -> true
            end
        -> match result with
          | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
          | C_None -> true
          end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__core_is_maximal_idemp__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1 = { f0'1: t_K; f1'1: t_V }
  
  function index_logic'1 [@inline:trivial] (self: Map.map tuple'1 t_Option'0) (a: tuple'1) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function filter_map (self: t_FMap) (f: Map.map tuple'1 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'1 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic'1 f { f0'1 = k; f1'1 = v }
          end
  
  function core (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core_total (self: t_FMap) : t_FMap =
    let r = filter_map self (fun (__0: tuple'1) -> let {f1'1 = v} = __0 in core v) in r
  
  axiom core_total_spec: forall self: t_FMap. op'1 (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. op'1 (core_total self) self = C_Some self
  
  function core'0 (self: t_FMap) : t_Option = C_Some (core_total self)
  
  axiom core_spec'0: forall self: t_FMap. match core'0 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  function factor'0 (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None'0} -> C_Some'1 x
      | {f0 = C_None'0} -> C_None'1
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_Option'0) (other: t_Option'0) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. incl'0 a b
      -> incl'0 b c -> incl'0 a c
  
  function incl_op'0 (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : () = ()
  
  axiom incl_op_spec'0: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. op'0 self other = C_Some'1 comb
      -> incl'0 self comb
  
  function factor'1 (self: t_FMap) (factor'2: t_FMap) : t_Option =
    if forall k: t_K. incl'0 (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'1) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'1 (self: t_FMap) (other: t_FMap) = factor'1 other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap. forall i: t_FMap. op'1 i self = C_Some self /\ op'1 i i = C_Some i
        -> op'1 i self = C_Some self
        /\ op'1 i i = C_Some i
        /\ (forall result: (). match core'0 self with
              | C_Some c -> incl'1 i c
              | C_None -> false
              end
          -> match core'0 self with
            | C_Some c -> incl'1 i c
            | C_None -> false
            end)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__commutative__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_FMap. forall b: t_FMap. forall result: (). op'1 a b = op'1 b a -> op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__associative__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FMap. forall b: t_FMap. forall c: t_FMap. forall result: (). and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
              = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
            -> and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
            = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__commutative__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option. forall b: t_Option. forall result: (). op'0 a b = op'0 b a -> op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__core__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option. forall result: t_Option'0. match result with
            | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
            | C_None'0 -> true
            end
        -> match result with
          | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
          | C_None'0 -> true
          end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__core_is_maximal_idemp__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function core (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function core_total (self: t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. op'0 (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. op'0 (core_total self) self = C_Some'0 self
  
  function core'0 (self: t_Option) : t_Option'0 = C_Some'0 (core_total self)
  
  axiom core_spec'0: forall self: t_Option. match core'0 self with
        | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function factor'0 (self: t_Option) (factor'1: t_Option) : t_Option'0 = match { f0 = self; f1 = factor'1 } with
      | {f0 = x; f1 = C_None} -> C_Some'0 x
      | {f0 = C_None} -> C_None'0
      | {f0 = C_Some x; f1 = C_Some y} -> match factor x y with
        | C_Some z -> C_Some'0 (C_Some z)
        | C_None -> if x = y then C_Some'0 (C_None) else C_None'0
        end
      end
  
  axiom factor_spec'0: forall self: t_Option, factor'1: t_Option. match factor'0 self factor'1 with
        | C_Some'0 c -> op'0 factor'1 c = C_Some'0 self
        | C_None'0 -> forall c: t_Option. op'0 factor'1 c <> C_Some'0 self
        end
  
  predicate incl'0 (self: t_Option) (other: t_Option) = factor'0 other self <> C_None'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option. forall i: t_Option. op'0 i self = C_Some'0 self /\ op'0 i i = C_Some'0 i
        -> op'0 i self = C_Some'0 self
        /\ op'0 i i = C_Some'0 i
        /\ (forall result: (). match core'0 self with
              | C_Some'0 c -> incl'0 i c
              | C_None'0 -> false
              end
          -> match core'0 self with
            | C_Some'0 c -> incl'0 i c
            | C_None'0 -> false
            end)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__associative__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Option. forall b: t_Option. forall c: t_Option. forall result: (). and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
              = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
            -> and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
            = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__factor__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option. forall factor'0: t_Option. forall result: t_Option'0. match result with
              | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
              | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
              end
          -> match result with
            | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
            | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
            end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__commutative__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                               f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: tuple. forall b: tuple. forall result: (). op'1 a b = op'1 b a -> op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__factor__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                               f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tuple. forall factor'1: tuple. forall result: t_Option. match result with
              | C_Some c -> op'1 factor'1 c = C_Some self
              | C_None -> forall c: tuple. op'1 factor'1 c <> C_Some self
              end
          -> match result with
            | C_Some c -> op'1 factor'1 c = C_Some self
            | C_None -> forall c: tuple. op'1 factor'1 c <> C_Some self
            end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__core_is_maximal_idemp__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                               f1 = y }))
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'1 }
  
  function core (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core'0 (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. match core'0 self with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  function core'1 (self: tuple) : t_Option = match { f0'0 = core self.f0; f1'0 = core'0 self.f1 } with
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'1 y} -> C_Some { f0 = x; f1 = y }
      | _ -> C_None
      end
  
  axiom core_spec'1: forall self: tuple. match core'1 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  function factor'1 (self: tuple) (factor'2: tuple) : t_Option = match { f0'0 = factor self.f0 factor'2.f0;
                                                                         f1'0 = factor'0 self.f1 factor'2.f1 } with
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'1 y} -> C_Some { f0 = x; f1 = y }
      | _ -> C_None
      end
  
  axiom factor_spec'1: forall self: tuple, factor'2: tuple. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: tuple. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'1 (self: tuple) (other: tuple) = factor'1 other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tuple. forall i: tuple. op'1 i self = C_Some self /\ op'1 i i = C_Some i
        -> op'1 i self = C_Some self
        /\ op'1 i i = C_Some i
        /\ (forall result: (). match core'1 self with
              | C_Some c -> incl'1 i c
              | C_None -> false
              end
          -> match core'1 self with
            | C_Some c -> incl'1 i c
            | C_None -> false
            end)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__core__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                               f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tuple. forall result: t_Option. match result with
            | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
            | C_None -> true
            end
        -> match result with
          | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
          | C_None -> true
          end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__associative__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                 f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: tuple. forall b: tuple. forall c: tuple. forall result: (). and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
              = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
            -> and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
            = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__associative__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  function and_then_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'0 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'1 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Sum. forall b: t_Sum. forall c: t_Sum. forall result: (). and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
              = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
            -> and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
            = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__core_is_maximal_idemp__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function core (self: t_R1) : t_Option'0
  
  axiom core_spec: forall self: t_R1. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core'0 (self: t_R2) : t_Option'1
  
  axiom core_spec'0: forall self: t_R2. match core'0 self with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  function core'1 (self: t_Sum) : t_Option = match self with
      | C_Left x -> map_logic (core x) (fun (l: t_R1) -> C_Left l)
      | C_Right x -> map_logic'0 (core'0 x) (fun (r: t_R2) -> C_Right r)
      end
  
  axiom core_spec'1: forall self: t_Sum. match core'1 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  function factor'1 (self: t_Sum) (factor'2: t_Sum) : t_Option = match { f0 = self; f1 = factor'2 } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (factor x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (factor'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  axiom factor_spec'1: forall self: t_Sum, factor'2: t_Sum. match factor'1 self factor'2 with
        | C_Some c -> op'1 factor'2 c = C_Some self
        | C_None -> forall c: t_Sum. op'1 factor'2 c <> C_Some self
        end
  
  predicate incl'1 (self: t_Sum) (other: t_Sum) = factor'1 other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum. forall i: t_Sum. op'1 i self = C_Some self /\ op'1 i i = C_Some i
        -> op'1 i self = C_Some self
        /\ op'1 i i = C_Some i
        /\ (forall result: (). match core'1 self with
              | C_Some c -> incl'1 i c
              | C_None -> false
              end
          -> match core'1 self with
            | C_Some c -> incl'1 i c
            | C_None -> false
            end)
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__commutative__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Sum. forall b: t_Sum. forall result: (). op'1 a b = op'1 b a -> op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__factor__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum. forall factor'1: t_Sum. forall result: t_Option. match result with
              | C_Some c -> op'1 factor'1 c = C_Some self
              | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
              end
          -> match result with
            | C_Some c -> op'1 factor'1 c = C_Some self
            | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
            end
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__core__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum. forall result: t_Option. match result with
            | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
            | C_None -> true
            end
        -> match result with
          | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
          | C_None -> true
          end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__commutative__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_View. forall b: t_View. forall result: (). op'0 a b = op'0 b a -> op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__core_is_maximal_idemp__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function new_frag [@inline:trivial] (frag'0: t_Frag) : t_View = new (C_None'1) frag'0
  
  meta "rewrite_def" function new_frag
  
  function core_total'0 (self: t_View) : t_View = new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. op'0 (core_total'0 self) (core_total'0 self)
      = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. op'0 (core_total'0 self) self = C_Some self
  
  function core (self: t_View) : t_Option = C_Some (core_total'0 self)
  
  axiom core_spec: forall self: t_View. match core self with
        | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
        | C_None -> true
        end
  
  function factor'0 (self: t_View) (factor'1: t_View) : t_Option = match factor (frag self) (frag factor'1) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth factor'1 } with
        | {f0 = C_Some'1 a; f1 = C_None'1} -> C_Some (new (C_Some'1 a) f)
        | {f0 = a1; f1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'0: forall self: t_View, factor'1: t_View. match factor'0 self factor'1 with
        | C_Some c -> op'0 factor'1 c = C_Some self
        | C_None -> forall c: t_View. op'0 factor'1 c <> C_Some self
        end
  
  predicate incl'0 (self: t_View) (other: t_View) = factor'0 other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View. forall i: t_View. op'0 i self = C_Some self /\ op'0 i i = C_Some i
        -> op'0 i self = C_Some self
        /\ op'0 i i = C_Some i
        /\ (forall result: (). match core self with
              | C_Some c -> incl'0 i c
              | C_None -> false
              end
          -> match core self with
            | C_Some c -> incl'0 i c
            | C_None -> false
            end)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__factor__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View. forall factor'0: t_View. forall result: t_Option. match result with
              | C_Some c -> op'0 factor'0 c = C_Some self
              | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
              end
          -> match result with
            | C_Some c -> op'0 factor'0 c = C_Some self
            | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
            end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__core__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View. forall result: t_Option. match result with
            | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
            | C_None -> true
            end
        -> match result with
          | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
          | C_None -> true
          end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__associative__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_View. forall b: t_View. forall c: t_View. forall result: (). and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
              = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
            -> and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
            = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_mono__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  predicate rel (a: t_Option) (f: t_T) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option. forall f1: t_T. forall f2: t_T. incl f2 f1 /\ rel a f1
          -> incl f2 f1 /\ rel a f1 /\ (forall result: (). rel a f2 -> rel a f2)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_unit__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  predicate rel (a: t_Option) (f: t_T) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function core_total (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. op (core_total self) self = C_Some self
  
  constant unit' : t_T
  
  axiom unit_spec: forall x: t_T [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_T. incl x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option. forall result: (). rel a unit' -> rel a unit'
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_none__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  function and_then_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  predicate rel (a: t_Option) (f: t_T) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option. forall f: t_T. rel a f -> (forall result: (). rel (C_None) f -> rel (C_None) f)
end
module M_creusot_contracts__logic__ra__auth__qyi1963254905082259216__update__refines (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate = { t_AuthUpdate__0: t_U }
  
  type t_View
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function auth (self: t_View) : t_Option
  
  predicate premise (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function core_total (self: t_R) : t_R
  
  axiom core_total_spec: forall self: t_R. op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_R. op (core_total self) self = C_Some self
  
  constant unit' : t_R
  
  axiom unit_spec: forall x: t_R [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_R. incl x x
  
  predicate rel (a: t_Option) (f: t_R) =
    match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function rel_unit (a: t_Option) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_R) : () = ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_R. rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_R, f2: t_R. rel a f1 -> incl f2 f1 -> rel a f2
  
  function frag (self: t_View) : t_R
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise'0 (self: t_AuthUpdate) (from: t_View) =
    match auth from with
      | C_Some auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None -> false
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_AuthUpdate. forall from: t_View. forall ch: (). premise'0 self from
          -> premise'0 self from
end
module M_creusot_contracts__logic__ra__auth__qyi1963254905082259216__frame_preserving__refines (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_View
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_R
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_R t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option'0
  
  function factor (self: t_R) (factor'0: t_R) : t_Option'0
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_R) : t_R
  
  axiom core_total_spec: forall self: t_R. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_R. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_R
  
  axiom unit_spec: forall x: t_R [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_R. incl x x
  
  predicate rel (a: t_Option'0) (f: t_R) =
    match a with
      | C_Some'0 a'0 -> incl f a'0
      | C_None'0 -> true
      end
  
  function rel_unit (a: t_Option'0) : () = ()
  
  axiom rel_unit_spec: forall a: t_Option'0. rel a unit'
  
  function rel_none (a: t_Option'0) (f: t_R) : () = ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_R. rel (C_None'0) f
  
  function rel_mono (a: t_Option'0) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_spec: forall a: t_Option'0, f1: t_R, f2: t_R. rel a f1 -> incl f2 f1 -> rel a f2
  
  function auth (self: t_View) : t_Option'0
  
  function frag (self: t_View) : t_R
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function new (auth'0: t_Option'0) (frag'0: t_R) : t_View
  
  axiom new_spec: forall auth'0: t_Option'0, frag'0: t_R. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'0, frag'0: t_R. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'0; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'0} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  type t_U
  
  type t_AuthUpdate = { t_AuthUpdate__0: t_U }
  
  predicate premise (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  predicate premise'0 (self: t_AuthUpdate) (from: t_View) =
    match auth from with
      | C_Some'0 auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None'0 -> false
      end
  
  type tuple'0 = { f0'0: t_R; f1'0: t_R }
  
  function update (self: t_U) (from_auth: t_R) (from_frag: t_R) : tuple'0
  
  predicate index_logic [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. (exists x: t_R. index_logic p x) -> index_logic p (such_that p)
  
  function unwrap_logic (self: t_Option'0) : t_R = match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_R) -> true)
      end
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function map_logic (self: t_Option'0) (f: Map.map t_R t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function op'1 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_R) -> C_Some'0 z)
      end
  
  function associative'1 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'1:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'1 (op'1 a b) (fun (ab: t_Option'0) -> op'1 ab c)
      = and_then_logic'1 (op'1 b c) (fun (bc: t_Option'0) -> op'1 a bc)
  
  function commutative'1 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'1: forall a: t_Option'0, b: t_Option'0. op'1 a b = op'1 b a
  
  function frame_preserving (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option'0) : ()
  
  axiom frame_preserving_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option'0. premise self from_auth from_frag
      -> op'1 (C_Some'0 from_frag) frame = C_Some'1 (C_Some'0 from_auth)
      -> (let {f0'0 = to_auth; f1'0 = to_frag} = update self from_auth from_frag in op'1 (C_Some'0 to_frag) frame
      = C_Some'1 (C_Some'0 to_auth))
  
  function update'0 (self: t_AuthUpdate) (from: t_View) (_3: ()) : t_View =
    let from_auth = unwrap_logic (auth from) in let {f0'0 = auth'0; f1'0 = frag'0} = update self.t_AuthUpdate__0 from_auth (frag from) in let _ = frame_preserving self.t_AuthUpdate__0 from_auth (frag from) (factor from_auth (frag from)) in new (C_Some'0 auth'0) frag'0
  
  axiom update_spec: forall self: t_AuthUpdate, from: t_View, _3: (). premise'0 self from
      -> (let {f0'0 = auth'0; f1'0 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in rel (C_Some'0 auth'0) frag'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_AuthUpdate. forall from: t_View. forall frame: t_View. op'0 from frame <> C_None
            /\ premise'0 self from
          -> op'0 from frame <> C_None
          /\ premise'0 self from
          /\ (forall result: (). op'0 (update'0 self from result) frame <> C_None
            -> op'0 (update'0 self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__excl__qyi10476702783314713742__frame_preserving__refines (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl = { t_Excl__0: t_T }
  
  type t_Option = C_None | C_Some t_Excl
  
  function and_then_logic (self: t_Option) (f: Map.map t_Excl t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_Excl) (_other: t_Excl) : t_Option = C_None
  
  function associative (a: t_Excl) (b: t_Excl) (c: t_Excl) : () = ()
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
  
  function commutative (a: t_Excl) (b: t_Excl) : () = ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. op a b = op b a
  
  type t_ExclUpdate = { t_ExclUpdate__0: t_T }
  
  predicate premise (self: t_ExclUpdate) (_2: t_Excl) = true
  
  function update (self: t_ExclUpdate) (from: t_Excl) (_3: ()) : t_Excl = { t_Excl__0 = self.t_ExclUpdate__0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ExclUpdate. forall from: t_Excl. forall frame: t_Excl. op from frame <> C_None
            /\ premise self from
          -> op from frame <> C_None
          /\ premise self from
          /\ (forall result: (). op (update self from result) frame <> C_None
            -> op (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__excl__qyi10476702783314713742__update__refines (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_ExclUpdate = { t_ExclUpdate__0: t_T }
  
  type t_Excl = { t_Excl__0: t_T }
  
  predicate premise (self: t_ExclUpdate) (_2: t_Excl) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ExclUpdate. forall from: t_Excl. forall ch: (). premise self from -> premise self from
end
module M_creusot_contracts__logic__ra__option__qyi9919140421117497760__update__refines (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_OptionUpdate = { t_OptionUpdate__0: t_U }
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  predicate premise (self: t_U) (from: t_R)
  
  predicate premise'0 (self: t_OptionUpdate) (from: t_Option) =
    match from with
      | C_Some from'0 -> premise self.t_OptionUpdate__0 from'0
      | C_None -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_OptionUpdate. forall from: t_Option. forall ch: t_Choice. premise'0 self from
          -> premise'0 self from
end
module M_creusot_contracts__logic__ra__option__qyi9919140421117497760__frame_preserving__refines (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option; f2: t_Option }
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : () = match { f0 = a; f1 = b; f2 = c } with
      | {f0 = C_None} -> ()
      | {f1 = C_None} -> ()
      | {f2 = C_None} -> ()
      | {f0 = C_Some aa; f1 = C_Some bb; f2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : () = ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  type t_U
  
  type t_OptionUpdate = { t_OptionUpdate__0: t_U }
  
  predicate premise (self: t_U) (from: t_R)
  
  predicate premise'0 (self: t_OptionUpdate) (from: t_Option) =
    match from with
      | C_Some from'0 -> premise self.t_OptionUpdate__0 from'0
      | C_None -> false
      end
  
  type t_Choice
  
  function update (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update'0 (self: t_OptionUpdate) (from: t_Option) (ch: t_Choice) : t_Option = match from with
      | C_Some from'0 -> C_Some (update self.t_OptionUpdate__0 from'0 ch)
      | C_None -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_OptionUpdate. forall from: t_Option. forall frame: t_Option. op'0 from frame <> C_None'0
            /\ premise'0 self from
          -> op'0 from frame <> C_None'0
          /\ premise'0 self from
          /\ (forall result: t_Choice. op'0 (update'0 self from result) frame <> C_None'0
            -> op'0 (update'0 self from result) frame <> C_None'0)
end
module M_creusot_contracts__logic__ra__prod__qyi12871785784760244066__update__refines (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate = { t_ProdUpdate__0: t_U1; t_ProdUpdate__1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tuple = { f0: t_R1; f1: t_R2 }
  
  predicate premise (self: t_U1) (from: t_R1)
  
  predicate premise'0 (self: t_U2) (from: t_R2)
  
  predicate premise'1 (self: t_ProdUpdate) (from: tuple) =
    premise self.t_ProdUpdate__0 from.f0 /\ premise'0 self.t_ProdUpdate__1 from.f1
  
  type t_Choice
  
  type t_Choice'0
  
  type tuple'0 = { f0'0: t_Choice; f1'0: t_Choice'0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ProdUpdate. forall from: tuple. forall ch: tuple'0. premise'1 self from
          -> premise'1 self from
end
module M_creusot_contracts__logic__ra__prod__qyi12871785784760244066__frame_preserving__refines (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type tuple = { f0: t_R1; f1: t_R2 }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_R1 t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic (self: t_Option'1) (f: Map.map t_R2 tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_R1) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_R2) -> { f0 = x;
                                                                                                                   f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate = { t_ProdUpdate__0: t_U1; t_ProdUpdate__1: t_U2 }
  
  predicate premise (self: t_U1) (from: t_R1)
  
  predicate premise'0 (self: t_U2) (from: t_R2)
  
  predicate premise'1 (self: t_ProdUpdate) (from: tuple) =
    premise self.t_ProdUpdate__0 from.f0 /\ premise'0 self.t_ProdUpdate__1 from.f1
  
  type t_Choice
  
  type t_Choice'0
  
  type tuple'0 = { f0'0: t_Choice; f1'0: t_Choice'0 }
  
  function update (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update'0 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  function update'1 (self: t_ProdUpdate) (from: tuple) (ch: tuple'0) : tuple =
    { f0 = update self.t_ProdUpdate__0 from.f0 ch.f0'0; f1 = update'0 self.t_ProdUpdate__1 from.f1 ch.f1'0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ProdUpdate. forall from: tuple. forall frame: tuple. op'1 from frame <> C_None
            /\ premise'1 self from
          -> op'1 from frame <> C_None
          /\ premise'1 self from
          /\ (forall result: tuple'0. op'1 (update'1 self from result) frame <> C_None
            -> op'1 (update'1 self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__sum__qyi1847493758823096333__update__refines (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateL = { t_SumUpdateL__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  predicate premise (self: t_U) (from: t_R1)
  
  predicate premise'0 (self: t_SumUpdateL) (from: t_Sum) =
    match from with
      | C_Left from'0 -> premise self.t_SumUpdateL__0 from'0
      | C_Right _ -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SumUpdateL. forall from: t_Sum. forall ch: t_Choice. premise'0 self from
          -> premise'0 self from
end
module M_creusot_contracts__logic__ra__sum__qyi1847493758823096333__frame_preserving__refines (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  function and_then_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_R1
  
  function map_logic (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'0
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'0 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R2
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'1 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : () = ()
  
  axiom associative_spec'1:
    forall a: t_Sum, b: t_Sum, c: t_Sum. and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : () = ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. op'1 a b = op'1 b a
  
  type t_U
  
  type t_SumUpdateL = { t_SumUpdateL__0: t_U }
  
  predicate premise (self: t_U) (from: t_R1)
  
  predicate premise'0 (self: t_SumUpdateL) (from: t_Sum) =
    match from with
      | C_Left from'0 -> premise self.t_SumUpdateL__0 from'0
      | C_Right _ -> false
      end
  
  type t_Choice
  
  function update (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update'0 (self: t_SumUpdateL) (from: t_Sum) (ch: t_Choice) : t_Sum = match from with
      | C_Left from'0 -> C_Left (update self.t_SumUpdateL__0 from'0 ch)
      | x -> x
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SumUpdateL. forall from: t_Sum. forall frame: t_Sum. op'1 from frame <> C_None
            /\ premise'0 self from
          -> op'1 from frame <> C_None
          /\ premise'0 self from
          /\ (forall result: t_Choice. op'1 (update'0 self from result) frame <> C_None
            -> op'1 (update'0 self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__sum__qyi15765748900338894532__update__refines (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateR = { t_SumUpdateR__0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum = C_Left t_V | C_Right t_R
  
  predicate premise (self: t_U) (from: t_R)
  
  predicate premise'0 (self: t_SumUpdateR) (from: t_Sum) =
    match from with
      | C_Right from'0 -> premise self.t_SumUpdateR__0 from'0
      | C_Left _ -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SumUpdateR. forall from: t_Sum. forall ch: t_Choice. premise'0 self from
          -> premise'0 self from
end
module M_creusot_contracts__logic__ra__sum__qyi15765748900338894532__frame_preserving__refines (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_V
  
  type t_R
  
  type t_Sum = C_Left t_V | C_Right t_R
  
  type t_Option = C_None | C_Some t_Sum
  
  function and_then_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Sum; f1: t_Sum }
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Sum) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_R) (other: t_R) : t_Option'1
  
  function factor'0 (self: t_R) (factor'1: t_R) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R, factor'1: t_R. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_R. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_R) (other: t_R) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R, b: t_R, c: t_R. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec'0: forall a: t_R, b: t_R, c: t_R. and_then_logic'1 (op'0 a b) (fun (ab: t_R) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_R) -> op'0 a bc)
  
  function commutative'0 (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec'0: forall a: t_R, b: t_R. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R, other: t_R, comb: t_R. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0 = self; f1 = other } with
      | {f0 = C_Left x; f1 = C_Left y} -> map_logic (op x y) (fun (l: t_V) -> C_Left l)
      | {f0 = C_Right x; f1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : () = ()
  
  axiom associative_spec'1:
    forall a: t_Sum, b: t_Sum, c: t_Sum. and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : () = ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. op'1 a b = op'1 b a
  
  type t_U
  
  type t_SumUpdateR = { t_SumUpdateR__0: t_U }
  
  predicate premise (self: t_U) (from: t_R)
  
  predicate premise'0 (self: t_SumUpdateR) (from: t_Sum) =
    match from with
      | C_Right from'0 -> premise self.t_SumUpdateR__0 from'0
      | C_Left _ -> false
      end
  
  type t_Choice
  
  function update (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update'0 (self: t_SumUpdateR) (from: t_Sum) (ch: t_Choice) : t_Sum = match from with
      | C_Right from'0 -> C_Right (update self.t_SumUpdateR__0 from'0 ch)
      | x -> x
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SumUpdateR. forall from: t_Sum. forall frame: t_Sum. op'1 from frame <> C_None
            /\ premise'0 self from
          -> op'1 from frame <> C_None
          /\ premise'0 self from
          /\ (forall result: t_Choice. op'1 (update'0 self from result) frame <> C_None
            -> op'1 (update'0 self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__update__qyi11826117606277287715__update__refines (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  predicate premise (self: t_R) (from: t_R) = forall y: t_R. op from y <> C_None -> op self y <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_R. forall from: t_R. forall ch: (). premise self from -> premise self from
end
module M_creusot_contracts__logic__ra__update__qyi11826117606277287715__frame_preserving__refines (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  predicate premise (self: t_R) (from: t_R) = forall y: t_R. op from y <> C_None -> op self y <> C_None
  
  function update (self: t_R) (from: t_R) (_3: ()) : t_R = self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_R. forall from: t_R. forall frame: t_R. op from frame <> C_None /\ premise self from
          -> op from frame <> C_None
          /\ premise self from
          /\ (forall result: (). op (update self from result) frame <> C_None
            -> op (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__update__qyi5477729486377161480__update__refines (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function index_logic [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate premise (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op from y <> C_None -> (exists ch: t_Choice. op (index_logic self ch) y <> C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Map.map t_Choice t_R. forall from: t_R. forall ch: t_Choice. premise self from
          -> premise self from
end
module M_creusot_contracts__logic__ra__update__qyi5477729486377161480__frame_preserving__refines (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  function and_then_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  type t_Choice
  
  function index_logic [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate premise (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op from y <> C_None -> (exists ch: t_Choice. op (index_logic self ch) y <> C_None)
  
  function update (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R = index_logic self ch
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Map.map t_Choice t_R. forall from: t_R. forall frame: t_R. op from frame <> C_None
            /\ premise self from
          -> op from frame <> C_None
          /\ premise self from
          /\ (forall result: t_Choice. op (update self from result) frame <> C_None
            -> op (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__view__qyi5759646997670148869__update__refines (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate = { t_ViewUpdate__0: Map.map t_Choice tuple }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function index_logic [@inline:trivial] (self: Map.map t_Choice tuple) (a: t_Choice) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise (self: t_ViewUpdate) (from: t_View) =
    auth from <> C_None
    /\ (forall ch: t_Choice. rel (C_Some ((index_logic self.t_ViewUpdate__0 ch).f0)) (index_logic self.t_ViewUpdate__0 ch).f1)
    /\ (forall frame: t_Frag. match op (frag from) frame with
          | C_Some'0 ff -> rel (auth from) ff
          | C_None'0 -> false
          end
      -> (exists ch: t_Choice. match op (index_logic self.t_ViewUpdate__0 ch).f1 frame with
          | C_Some'0 ff -> rel (C_Some ((index_logic self.t_ViewUpdate__0 ch).f0)) ff
          | C_None'0 -> false
          end))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdate. forall from: t_View. forall ch: t_Choice. premise self from
          -> premise self from
end
module M_creusot_contracts__logic__ra__view__qyi5759646997670148869__frame_preserving__refines (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'0 = { f0'0: t_Option'1; f1'0: t_Option'1; f2: t_Option'1 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'1; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some'1 _; f1'0 = C_None'1; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_Some'1 _; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  type t_Choice
  
  type tuple'2 = { f0'2: t_Auth; f1'2: t_Frag }
  
  type t_ViewUpdate = { t_ViewUpdate__0: Map.map t_Choice tuple'2 }
  
  function index_logic [@inline:trivial] (self: Map.map t_Choice tuple'2) (a: t_Choice) : tuple'2 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  predicate premise (self: t_ViewUpdate) (from: t_View) =
    auth from <> C_None'1
    /\ (forall ch: t_Choice. rel (C_Some'1 ((index_logic self.t_ViewUpdate__0 ch).f0'2)) (index_logic self.t_ViewUpdate__0 ch).f1'2)
    /\ (forall frame: t_Frag. match op (frag from) frame with
          | C_Some'0 ff -> rel (auth from) ff
          | C_None'0 -> false
          end
      -> (exists ch: t_Choice. match op (index_logic self.t_ViewUpdate__0 ch).f1'2 frame with
          | C_Some'0 ff -> rel (C_Some'1 ((index_logic self.t_ViewUpdate__0 ch).f0'2)) ff
          | C_None'0 -> false
          end))
  
  function update (self: t_ViewUpdate) (from: t_View) (ch: t_Choice) : t_View =
    new (C_Some'1 ((index_logic self.t_ViewUpdate__0 ch).f0'2)) (index_logic self.t_ViewUpdate__0 ch).f1'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdate. forall from: t_View. forall frame: t_View. op'0 from frame <> C_None
            /\ premise self from
          -> op'0 from frame <> C_None
          /\ premise self from
          /\ (forall result: t_Choice. op'0 (update self from result) frame <> C_None
            -> op'0 (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__view__qyi7400797033094478444__update__refines (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_ViewUpdateInsert = { t_ViewUpdateInsert__0: t_Auth; t_ViewUpdateInsert__1: t_Frag }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  predicate premise (self: t_ViewUpdateInsert) (from: t_View) =
    auth from <> C_None
    /\ (forall f: t_Frag. rel (auth from) f
      -> match op self.t_ViewUpdateInsert__1 f with
        | C_Some'0 ff -> rel (C_Some (self.t_ViewUpdateInsert__0)) ff
        | C_None'0 -> false
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdateInsert. forall from: t_View. forall ch: (). premise self from
          -> premise self from
end
module M_creusot_contracts__logic__ra__view__qyi7400797033094478444__frame_preserving__refines (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'0 = { f0'0: t_Option'1; f1'0: t_Option'1; f2: t_Option'1 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'1; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some'1 _; f1'0 = C_None'1; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_Some'1 _; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  type t_ViewUpdateInsert = { t_ViewUpdateInsert__0: t_Auth; t_ViewUpdateInsert__1: t_Frag }
  
  predicate premise (self: t_ViewUpdateInsert) (from: t_View) =
    auth from <> C_None'1
    /\ (forall f: t_Frag. rel (auth from) f
      -> match op self.t_ViewUpdateInsert__1 f with
        | C_Some'0 ff -> rel (C_Some'1 (self.t_ViewUpdateInsert__0)) ff
        | C_None'0 -> false
        end)
  
  function update (self: t_ViewUpdateInsert) (from: t_View) (_3: ()) : t_View =
    new (C_Some'1 (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  axiom update_spec: forall self: t_ViewUpdateInsert, from: t_View, _3: (). premise self from
      -> rel (C_Some'1 (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdateInsert. forall from: t_View. forall frame: t_View. op'0 from frame <> C_None
            /\ premise self from
          -> op'0 from frame <> C_None
          /\ premise self from
          /\ (forall result: (). op'0 (update self from result) frame <> C_None
            -> op'0 (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__view__qyi5746217084655472194__update__refines (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_ViewUpdateRemove = { t_ViewUpdateRemove__0: t_Auth }
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  predicate premise (self: t_ViewUpdateRemove) (from: t_View) =
    auth from <> C_None
    /\ (forall f: t_Frag. match op (frag from) f with
          | C_Some'0 ff -> rel (auth from) ff
          | C_None'0 -> false
          end -> rel (C_Some (self.t_ViewUpdateRemove__0)) f)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdateRemove. forall from: t_View. forall ch: (). premise self from
          -> premise self from
end
module M_creusot_contracts__logic__ra__view__qyi5746217084655472194__frame_preserving__refines (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'0 = { f0'0: t_Option'1; f1'0: t_Option'1; f2: t_Option'1 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'1; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some'1 _; f1'0 = C_None'1; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_Some'1 _; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  type t_ViewUpdateRemove = { t_ViewUpdateRemove__0: t_Auth }
  
  predicate premise (self: t_ViewUpdateRemove) (from: t_View) =
    auth from <> C_None'1
    /\ (forall f: t_Frag. match op (frag from) f with
          | C_Some'0 ff -> rel (auth from) ff
          | C_None'0 -> false
          end -> rel (C_Some'1 (self.t_ViewUpdateRemove__0)) f)
  
  function new_auth [@inline:trivial] (auth'0: t_Auth) : t_View = new (C_Some'1 auth'0) unit'
  
  meta "rewrite_def" function new_auth
  
  function update (self: t_ViewUpdateRemove) (from: t_View) (_3: ()) : t_View = new_auth self.t_ViewUpdateRemove__0
  
  axiom update_spec: forall self: t_ViewUpdateRemove, from: t_View, _3: (). premise self from
      -> rel (C_Some'1 (self.t_ViewUpdateRemove__0)) unit'
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdateRemove. forall from: t_View. forall frame: t_View. op'0 from frame <> C_None
            /\ premise self from
          -> op'0 from frame <> C_None
          /\ premise self from
          /\ (forall result: (). op'0 (update self from result) frame <> C_None
            -> op'0 (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__core_is_total__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0 = self; f1 = other } with
      | {f0 = C_None'0} -> C_Some'1 other
      | {f1 = C_None'0} -> C_Some'1 self
      | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'0 = { f0'0: t_V; f1'0: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. forall k: t_K [get (merge self m f) k]. match { f0 = get self k;
                                                                                                            f1 = get m k } with
          | {f0 = C_None'0; f1 = y} -> get (merge self m f) k = y
          | {f0 = x; f1 = C_None'0} -> get (merge self m f) k = x
          | {f0 = C_Some'0 x; f1 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'0) -> let {f0'0 = x; f1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  type tuple'1 = { f0'1: t_Option; f1'1: t_Option }
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : () = match { f0'1 = op'1 a b; f1'1 = op'1 b c } with
      | {f0'1 = C_Some ab; f1'1 = C_Some bc} -> match { f0'1 = op'1 ab c; f1'1 = op'1 a bc } with
        | {f0'1 = C_Some x; f1'1 = C_Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : () = ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  type tuple'2 = { f0'2: t_K; f1'2: t_V }
  
  function index_logic'1 [@inline:trivial] (self: Map.map tuple'2 t_Option'0) (a: tuple'2) : t_Option'0 = Map.get self a
  
  meta "rewrite_def" function index_logic'1
  
  function filter_map (self: t_FMap) (f: Map.map tuple'2 t_Option'0) : t_FMap
  
  axiom filter_map_spec:
    forall self: t_FMap, f: Map.map tuple'2 t_Option'0. forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
        = match get self k with
          | C_None'0 -> C_None'0
          | C_Some'0 v -> index_logic'1 f { f0'2 = k; f1'2 = v }
          end
  
  function core (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core_total (self: t_FMap) : t_FMap =
    let r = filter_map self (fun (__0: tuple'2) -> let {f1'2 = v} = __0 in core v) in r
  
  axiom core_total_spec: forall self: t_FMap. op'1 (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. op'1 (core_total self) self = C_Some self
  
  function core'0 (self: t_FMap) : t_Option = C_Some (core_total self)
  
  axiom core_spec'0: forall self: t_FMap. match core'0 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap. forall result: (). core'0 self = C_Some (core_total self)
        -> core'0 self = C_Some (core_total self)
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__unit__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None'0} -> C_Some'1 other
      | {f1'0 = C_None'0} -> C_Some'1 self
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'1 = { f0'1: t_V; f1'1: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. forall k: t_K [get (merge self m f) k]. match { f0'0 = get self k;
                                                                                                            f1'0 = get m k } with
          | {f0'0 = C_None'0; f1'0 = y} -> get (merge self m f) k = y
          | {f0'0 = x; f1'0 = C_None'0} -> get (merge self m f) k = x
          | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'1) -> let {f0'1 = x; f1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : () = match { f0 = op'1 a b; f1 = op'1 b c } with
      | {f0 = C_Some ab; f1 = C_Some bc} -> match { f0 = op'1 ab c; f1 = op'1 a bc } with
        | {f0 = C_Some x; f1 = C_Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : () = ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_FMap. (forall x: t_FMap [op'1 x result]. op'1 x result = C_Some x)
      -> (forall x: t_FMap [op'1 x result]. op'1 x result = C_Some x)
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__core_total__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  function and_then_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  type t_V
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Option'0
  
  function and_then_logic'0 (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  function map_logic (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1 = match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'0
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'0
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'0 comb -> incl self comb
  
  function op'0 (self: t_Option'0) (other: t_Option'0) : t_Option'1 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None'0} -> C_Some'1 other
      | {f1'0 = C_None'0} -> C_Some'1 self
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'0, b: t_Option'0, c: t_Option'0. and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
      = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'0) (b: t_Option'0) : ()
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'0 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'1 = { f0'1: t_V; f1'1: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. forall k: t_K [get (merge self m f) k]. match { f0'0 = get self k;
                                                                                                            f1'0 = get m k } with
          | {f0'0 = C_None'0; f1'0 = y} -> get (merge self m f) k = y
          | {f0'0 = x; f1'0 = C_None'0} -> get (merge self m f) k = x
          | {f0'0 = C_Some'0 x; f1'0 = C_Some'0 y} -> get (merge self m f) k
          = C_Some'0 (index_logic f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'1) -> let {f0'1 = x; f1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'1)
      -> (forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : () = match { f0 = op'1 a b; f1 = op'1 b c } with
      | {f0 = C_Some ab; f1 = C_Some bc} -> match { f0 = op'1 ab c; f1 = op'1 a bc } with
        | {f0 = C_Some x; f1 = C_Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : () = ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap. forall result: t_FMap. op'1 result self = C_Some self
          /\ op'1 result result = C_Some result -> op'1 result self = C_Some self /\ op'1 result result = C_Some result
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__core_is_total__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option; f2: t_Option }
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : () = match { f0'0 = a; f1'0 = b; f2 = c } with
      | {f0'0 = C_None} -> ()
      | {f1'0 = C_None} -> ()
      | {f2 = C_None} -> ()
      | {f0'0 = C_Some aa; f1'0 = C_Some bb; f2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : () = ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  function core (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
        | C_None -> true
        end
  
  function core_total (self: t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. op'0 (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. op'0 (core_total self) self = C_Some'0 self
  
  function core'0 (self: t_Option) : t_Option'0 = C_Some'0 (core_total self)
  
  axiom core_spec'0: forall self: t_Option. match core'0 self with
        | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option. forall result: (). core'0 self = C_Some'0 (core_total self)
        -> core'0 self = C_Some'0 (core_total self)
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__core_total__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option; f2: t_Option }
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : () = match { f0 = a; f1 = b; f2 = c } with
      | {f0 = C_None} -> ()
      | {f1 = C_None} -> ()
      | {f2 = C_None} -> ()
      | {f0 = C_Some aa; f1 = C_Some bb; f2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : () = ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option. forall result: t_Option. op'0 result self = C_Some'0 self
          /\ op'0 result result = C_Some'0 result
        -> op'0 result self = C_Some'0 self /\ op'0 result result = C_Some'0 result
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__unit__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option = C_None | C_Some t_T
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option; f2: t_Option }
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option
  
  function factor (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_T. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some comb -> incl self comb
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : () = match { f0 = a; f1 = b; f2 = c } with
      | {f0 = C_None} -> ()
      | {f1 = C_None} -> ()
      | {f2 = C_None} -> ()
      | {f0 = C_Some aa; f1 = C_Some bb; f2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : () = ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_Option. (forall x: t_Option [op'0 x result]. op'0 x result = C_Some'0 x)
      -> (forall x: t_Option [op'0 x result]. op'0 x result = C_Some'0 x)
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__unit__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                 f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: tuple. (forall x: tuple [op'1 x result]. op'1 x result = C_Some x)
      -> (forall x: tuple [op'1 x result]. op'1 x result = C_Some x)
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__core_total__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                 f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tuple. forall result: tuple. op'1 result self = C_Some self
          /\ op'1 result result = C_Some result -> op'1 result self = C_Some self /\ op'1 result result = C_Some result
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__core_is_total__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple = { f0: t_T; f1: t_U }
  
  type t_Option = C_None | C_Some tuple
  
  function and_then_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_T
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option = match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op (self: t_T) (other: t_T) : t_Option'0
  
  function factor (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_T) (other: t_T) = factor other self <> C_None'0
  
  function incl_transitive (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. incl a b -> incl b c -> incl a c
  
  function associative (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. op a b = op b a
  
  function incl_op (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. op self other = C_Some'0 comb -> incl self comb
  
  type t_Option'1 = C_None'1 | C_Some'1 t_U
  
  function map_logic (self: t_Option'1) (f: Map.map t_U tuple) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. match factor'0 self factor'1 with
        | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
        | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
        end
  
  predicate incl'0 (self: t_U) (other: t_U) = factor'0 other self <> C_None'1
  
  function incl_transitive'0 (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. op'0 self other = C_Some'1 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'0 (op self.f0 other.f0) (fun (x: t_T) -> map_logic (op'0 self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                 f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'1 }
  
  function core (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. match core self with
        | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
        | C_None'0 -> true
        end
  
  function core'0 (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. match core'0 self with
        | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
        | C_None'1 -> true
        end
  
  function core'1 (self: tuple) : t_Option = match { f0'0 = core self.f0; f1'0 = core'0 self.f1 } with
      | {f0'0 = C_Some'0 x; f1'0 = C_Some'1 y} -> C_Some { f0 = x; f1 = y }
      | _ -> C_None
      end
  
  axiom core_spec'1: forall self: tuple. match core'1 self with
        | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
        | C_None -> true
        end
  
  constant unit' : t_T
  
  axiom unit_spec: forall x: t_T [op x unit']. op x unit' = C_Some'0 x
  
  function core_total (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. op (core_total self) self = C_Some'0 self
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_T. incl x x
  
  constant unit''0 : t_U
  
  axiom unit_spec'0: forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x
  
  function core_total'0 (self: t_U) : t_U
  
  axiom core_total_spec'1: forall self: t_U. op'0 (core_total'0 self) (core_total'0 self) = C_Some'1 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_U. op'0 (core_total'0 self) self = C_Some'1 self
  
  constant unit_core'0: () = ()
  
  axiom unit_core_spec'0: core_total'0 unit''0 = unit''0
  
  constant incl_refl'0: () = let _ = unit''0 in ()
  
  axiom incl_refl_spec'0: forall x: t_U. incl'0 x x
  
  function core_total'1 (self: tuple) : tuple = { f0 = core_total self.f0; f1 = core_total'0 self.f1 }
  
  axiom core_total_spec'3: forall self: tuple. op'1 (core_total'1 self) (core_total'1 self) = C_Some (core_total'1 self)
  
  axiom core_total_spec'4: forall self: tuple. op'1 (core_total'1 self) self = C_Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tuple. forall result: (). core'1 self = C_Some (core_total'1 self)
        -> core'1 self = C_Some (core_total'1 self)
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__core_total__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'0 = { f0'0: t_Option'1; f1'0: t_Option'1; f2: t_Option'1 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'1; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some'1 _; f1'0 = C_None'1; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_Some'1 _; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View. forall result: t_View. op'0 result self = C_Some self
          /\ op'0 result result = C_Some result -> op'0 result self = C_Some self /\ op'0 result result = C_Some result
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__unit__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type tuple = { f0: t_Option'0; f1: t_Option'0 }
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple'0 = { f0'0: t_Option'1; f1'0: t_Option'1; f2: t_Option'1 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0'1 = auth self; f1'1 = auth other } with
        | {f0'1 = C_None'1; f1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0'1 = a; f1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0 = op (frag a) (frag b);
                                                                                    f1 = op (frag b) (frag c) } with
      | {f0 = C_Some'0 fab; f1 = C_Some'0 fbc} -> match { f0 = op fab (frag c); f1 = op (frag a) fbc } with
        | {f0 = C_Some'0 fabc1; f1 = C_Some'0 fabc2} -> match { f0'0 = auth a; f1'0 = auth b; f2 = auth c } with
          | {f0'0 = C_Some'1 _; f1'0 = C_None'1; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_Some'1 _; f2 = C_None'1} | {f0'0 = C_None'1; f1'0 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_View. (forall x: t_View [op'0 x result]. op'0 x result = C_Some x)
      -> (forall x: t_View [op'0 x result]. op'0 x result = C_Some x)
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__core_is_total__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset
  
  type t_View = { t_View__0: t_Subset }
  
  type t_Option = C_None | C_Some t_View
  
  function and_then_logic (self: t_Option) (f: Map.map t_View t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Auth
  
  predicate rel (a: t_Option'1) (f: t_Frag)
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic'0 (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. rel a unit'
  
  function rel_none (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. rel a f -> rel (C_None'1) f
  
  function rel_mono (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. invariant' (view self)
  
  function auth (self: t_View) : t_Option'1 = (view self.t_View__0).t_InnerView__auth
  
  function frag (self: t_View) : t_Frag = (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. rel (auth self) (frag self)
  
  type tuple = { f0: t_Option'1; f1: t_Option'1 }
  
  function new_logic (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. invariant' x -> view (new_logic x) = x
  
  function new (auth'0: t_Option'1) (frag'0: t_Frag) : t_View = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                                                                          t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> auth (new auth'0 frag'0) = auth'0
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. rel auth'0 frag'0 -> frag (new auth'0 frag'0) = frag'0
  
  type tuple'0 = { f0'0: t_Option'0; f1'0: t_Option'0 }
  
  type tuple'1 = { f0'1: t_Option'1; f1'1: t_Option'1; f2: t_Option'1 }
  
  function op'0 (self: t_View) (other: t_View) : t_Option = match op (frag self) (frag other) with
      | C_Some'0 f -> match { f0 = auth self; f1 = auth other } with
        | {f0 = C_None'1; f1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {f0 = a; f1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 (a: t_View) (b: t_View) (c: t_View) : () = let _ = match { f0'0 = op (frag a) (frag b);
                                                                                    f1'0 = op (frag b) (frag c) } with
      | {f0'0 = C_Some'0 fab; f1'0 = C_Some'0 fbc} -> match { f0'0 = op fab (frag c); f1'0 = op (frag a) fbc } with
        | {f0'0 = C_Some'0 fabc1; f1'0 = C_Some'0 fabc2} -> match { f0'1 = auth a; f1'1 = auth b; f2 = auth c } with
          | {f0'1 = C_Some'1 _; f1'1 = C_None'1; f2 = C_None'1} | {f0'1 = C_None'1; f1'1 = C_Some'1 _; f2 = C_None'1} | {f0'1 = C_None'1; f1'1 = C_None'1; f2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_spec'0:
    forall a: t_View, b: t_View, c: t_View. and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 (a: t_View) (b: t_View) : () = ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. op'0 a b = op'0 b a
  
  function new_frag [@inline:trivial] (frag'0: t_Frag) : t_View = new (C_None'1) frag'0
  
  meta "rewrite_def" function new_frag
  
  function core_total'0 (self: t_View) : t_View = new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. op'0 (core_total'0 self) (core_total'0 self)
      = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. op'0 (core_total'0 self) self = C_Some self
  
  function core (self: t_View) : t_Option = C_Some (core_total'0 self)
  
  axiom core_spec: forall self: t_View. match core self with
        | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
        | C_None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View. forall result: (). core self = C_Some (core_total'0 self)
        -> core self = C_Some (core_total'0 self)
end
module M_creusot_contracts__logic__ra__fmap__qyi945878506295166927__frame_preserving__refines (* <logic::ra::fmap::FMapInsertLocalUpdate<K, V> as logic::ra::update::LocalUpdate<logic::fmap::FMap<K, V>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_FMap
  
  type t_Option = C_None | C_Some t_FMap
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Option'1
  
  function and_then_logic'1 (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option'1; f1'0: t_Option'1 }
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_V t_Option'1) : t_Option'2 = match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_V t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_V) (other: t_V) : t_Option'1
  
  function factor (self: t_V) (factor'0: t_V) : t_Option'1
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_V. op factor'0 c <> C_Some'1 self
        end
  
  predicate incl (self: t_V) (other: t_V) = factor other self <> C_None'1
  
  function incl_transitive (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. incl a b -> incl b c -> incl a c
  
  function associative (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. and_then_logic'2 (op a b) (fun (ab: t_V) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. op a b = op b a
  
  function incl_op (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. op self other = C_Some'1 comb -> incl self comb
  
  function op'0 (self: t_Option'1) (other: t_Option'1) : t_Option'2 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None'1} -> C_Some'2 other
      | {f1'0 = C_None'1} -> C_Some'2 self
      | {f0'0 = C_Some'1 x; f1'0 = C_Some'1 y} -> map_logic'0 (op x y) (fun (z: t_V) -> C_Some'1 z)
      end
  
  function associative'0 (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  axiom associative_spec'0:
    forall a: t_Option'1, b: t_Option'1, c: t_Option'1. and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
      = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function commutative'0 (a: t_Option'1) (b: t_Option'1) : ()
  
  axiom commutative_spec'0: forall a: t_Option'1, b: t_Option'1. op'0 a b = op'0 b a
  
  type t_K
  
  function view (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] (self: t_FMap) (k: t_K) : t_Option'1 = Map.get (view self) k
  
  meta "rewrite_def" function get
  
  type tuple'1 = { f0'1: t_V; f1'1: t_V }
  
  function index_logic [@inline:trivial] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  function merge (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  axiom merge_spec:
    forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. forall k: t_K [get (merge self m f) k]. match { f0'0 = get self k;
                                                                                                            f1'0 = get m k } with
          | {f0'0 = C_None'1; f1'0 = y} -> get (merge self m f) k = y
          | {f0'0 = x; f1'0 = C_None'1} -> get (merge self m f) k = x
          | {f0'0 = C_Some'1 x; f1'0 = C_Some'1 y} -> get (merge self m f) k
          = C_Some'1 (index_logic f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_logic'0 [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_logic'0
  
  function such_that (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. (exists x: t_V. index_logic'0 p x) -> index_logic'0 p (such_that p)
  
  function total_op (self: t_FMap) (other: t_FMap) : t_FMap =
    merge self other (fun (__0: tuple'1) -> let {f0'1 = x; f1'1 = y} = __0 in match op x y with
      | C_Some'1 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. (forall k: t_K. op'0 (get self k) (get other k) <> C_None'2)
      -> (forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 (self: t_FMap) (other: t_FMap) : t_Option = if forall k: t_K. op'0 (get self k) (get other k)
      <> C_None'2 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 (a: t_FMap) (b: t_FMap) (c: t_FMap) : () = match { f0 = op'1 a b; f1 = op'1 b c } with
      | {f0 = C_Some ab; f1 = C_Some bc} -> match { f0 = op'1 ab c; f1 = op'1 a bc } with
        | {f0 = C_Some x; f1 = C_Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1:
    forall a: t_FMap, b: t_FMap, c: t_FMap. and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'1 (a: t_FMap) (b: t_FMap) : () = ()
  
  axiom commutative_spec'1: forall a: t_FMap, b: t_FMap. op'1 a b = op'1 b a
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_FMap) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  type t_FMapInsertLocalUpdate = { t_FMapInsertLocalUpdate__0: t_K; t_FMapInsertLocalUpdate__1: t_V }
  
  predicate premise (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (_3: t_FMap) =
    get from_auth self.t_FMapInsertLocalUpdate__0 = C_None'1
  
  type tuple'2 = { f0'2: t_FMap; f1'2: t_FMap }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. len self >= 0
  
  predicate contains [@inline:trivial] (self: t_FMap) (k: t_K) = get self k <> C_None'1
  
  meta "rewrite_def" predicate contains
  
  function insert (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. view (insert self k v) = Map.set (view self) k (C_Some'1 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. len (insert self k v)
      = (if contains self k then len self else len self + 1)
  
  function update (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (from_frag: t_FMap) : tuple'2 =
    { f0'2 = insert from_auth self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1;
      f1'2 = insert from_frag self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_FMapInsertLocalUpdate. forall from_auth: t_FMap. forall from_frag: t_FMap. forall frame: t_Option. op'2 (C_Some from_frag) frame
                = C_Some'0 (C_Some from_auth)
              /\ premise self from_auth from_frag
            -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
            /\ premise self from_auth from_frag
            /\ (forall result: (). (let {f0'2 = to_auth; f1'2 = to_frag} = update self from_auth from_frag in op'2 (C_Some to_frag) frame
                = C_Some'0 (C_Some to_auth))
              -> (let {f0'2 = to_auth; f1'2 = to_frag} = update self from_auth from_frag in op'2 (C_Some to_frag) frame
              = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__prod__qyi5623508861439716845__frame_preserving__refines (* <logic::ra::prod::ProdLocalUpdate<U1, U2> as logic::ra::update::LocalUpdate<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type tuple = { f0: t_R1; f1: t_R2 }
  
  type t_Option = C_None | C_Some tuple
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Option; f1'0: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map tuple t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map tuple t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R1
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R1 t_Option) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> Map.get f x
      end
  
  function and_then_logic'2 (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'1
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'2 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'2 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'1 comb -> incl self comb
  
  type t_Option'2 = C_None'2 | C_Some'2 t_R2
  
  function map_logic'0 (self: t_Option'2) (f: Map.map t_R2 tuple) : t_Option = match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'3 (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'2
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'3 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'3 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'2 comb -> incl'0 self comb
  
  function op'1 (self: tuple) (other: tuple) : t_Option =
    and_then_logic'1 (op self.f0 other.f0) (fun (x: t_R1) -> map_logic'0 (op'0 self.f1 other.f1) (fun (y: t_R2) -> { f0 = x;
                                                                                                                     f1 = y }))
  
  function associative'1 (a: tuple) (b: tuple) (c: tuple) : () = ()
  
  axiom associative_spec'1:
    forall a: tuple, b: tuple, c: tuple. and_then_logic'0 (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 (a: tuple) (b: tuple) : () = ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. op'1 a b = op'1 b a
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_None} -> C_Some'0 other
      | {f1'0 = C_None} -> C_Some'0 self
      | {f0'0 = C_Some x; f1'0 = C_Some y} -> map_logic (op'1 x y) (fun (z: tuple) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  type t_U1
  
  type t_U2
  
  type t_ProdLocalUpdate = { t_ProdLocalUpdate__0: t_U1; t_ProdLocalUpdate__1: t_U2 }
  
  predicate premise (self: t_U1) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise'0 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise'1 (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple) =
    premise self.t_ProdLocalUpdate__0 from_auth.f0 from_frag.f0
    /\ premise'0 self.t_ProdLocalUpdate__1 from_auth.f1 from_frag.f1
  
  type tuple'1 = { f0'1: tuple; f1'1: tuple }
  
  type tuple'2 = { f0'2: t_R1; f1'2: t_R1 }
  
  function update (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) : tuple'2
  
  type tuple'3 = { f0'3: t_R2; f1'3: t_R2 }
  
  function update'0 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) : tuple'3
  
  function update'1 (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple) : tuple'1 =
    let {f0'2 = to_auth0; f1'2 = to_frag0} = update self.t_ProdLocalUpdate__0 from_auth.f0 from_frag.f0 in let {f0'3 = to_auth1; f1'3 = to_frag1} = update'0 self.t_ProdLocalUpdate__1 from_auth.f1 from_frag.f1 in { f0'1 = { f0 = to_auth0;
                                                                                                                                                                                                                               f1 = to_auth1 };
                                                                                                                                                                                                                      f1'1 = { f0 = to_frag0;
                                                                                                                                                                                                                               f1 = to_frag1 } }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ProdLocalUpdate. forall from_auth: tuple. forall from_frag: tuple. forall frame: t_Option. op'2 (C_Some from_frag) frame
                = C_Some'0 (C_Some from_auth)
              /\ premise'1 self from_auth from_frag
            -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
            /\ premise'1 self from_auth from_frag
            /\ (forall result: (). (let {f0'1 = to_auth; f1'1 = to_frag} = update'1 self from_auth from_frag in op'2 (C_Some to_frag) frame
                = C_Some'0 (C_Some to_auth))
              -> (let {f0'1 = to_auth; f1'1 = to_frag} = update'1 self from_auth from_frag in op'2 (C_Some to_frag) frame
              = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__sum__qyi3083214512297526849__frame_preserving__refines (* <logic::ra::sum::SumLocalUpdateL<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Sum; f1'0: t_Sum }
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R1
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'1
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'1 comb -> incl self comb
  
  type t_Option'2 = C_None'2 | C_Some'2 t_R2
  
  function map_logic'1 (self: t_Option'2) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'2
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'2 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_Left x; f1'0 = C_Left y} -> map_logic'0 (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0'0 = C_Right x; f1'0 = C_Right y} -> map_logic'1 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : () = ()
  
  axiom associative_spec'1:
    forall a: t_Sum, b: t_Sum, c: t_Sum. and_then_logic'0 (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : () = ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. op'1 a b = op'1 b a
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_Sum) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  type t_U
  
  type t_SumLocalUpdateL = { t_SumLocalUpdateL__0: t_U }
  
  predicate premise (self: t_U) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise'0 (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = C_Left from_auth'0; f1'0 = C_Left from_frag'0} -> premise self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0
      | {f0'0 = C_Right _; f1'0 = C_Right _} -> false
      | _ -> true
      end
  
  type tuple'1 = { f0'1: t_R1; f1'1: t_R1 }
  
  function update (self: t_U) (from_auth: t_R1) (from_frag: t_R1) : tuple'1
  
  predicate index_logic [@inline:trivial] (self: Map.map tuple'0 bool) (a: tuple'0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map tuple'0 bool) : tuple'0
  
  axiom such_that_spec: forall p: Map.map tuple'0 bool. (exists x: tuple'0. index_logic p x)
      -> index_logic p (such_that p)
  
  function update'0 (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum) : tuple'0 =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = C_Left from_auth'0; f1'0 = C_Left from_frag'0} -> let {f0'1 = to_auth; f1'1 = to_frag} = update self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0 in { f0'0 = C_Left to_auth;
                                                                                                                                                                       f1'0 = C_Left to_frag }
      | _ -> such_that (fun (__0: tuple'0) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumLocalUpdateL. forall from_auth: t_Sum. forall from_frag: t_Sum. forall frame: t_Option. op'2 (C_Some from_frag) frame
                = C_Some'0 (C_Some from_auth)
              /\ premise'0 self from_auth from_frag
            -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
            /\ premise'0 self from_auth from_frag
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
                = C_Some'0 (C_Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
              = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__sum__qyi3543961907530750261__frame_preserving__refines (* <logic::ra::sum::SumLocalUpdateR<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum = C_Left t_R1 | C_Right t_R2
  
  type t_Option = C_None | C_Some t_Sum
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple'0 = { f0'0: t_Sum; f1'0: t_Sum }
  
  type t_Option'1 = C_None'1 | C_Some'1 t_R1
  
  function map_logic'0 (self: t_Option'1) (f: Map.map t_R1 t_Sum) : t_Option = match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1 = match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. match factor self factor'0 with
        | C_Some'1 c -> op factor'0 c = C_Some'1 self
        | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
        end
  
  predicate incl (self: t_R1) (other: t_R1) = factor other self <> C_None'1
  
  function incl_transitive (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
      = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. op a b = op b a
  
  function incl_op (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. op self other = C_Some'1 comb -> incl self comb
  
  type t_Option'2 = C_None'2 | C_Some'2 t_R2
  
  function map_logic'1 (self: t_Option'2) (f: Map.map t_R2 t_Sum) : t_Option = match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2 = match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. match factor'0 self factor'1 with
        | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
        | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
        end
  
  predicate incl'0 (self: t_R2) (other: t_R2) = factor'0 other self <> C_None'2
  
  function incl_transitive'0 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. incl'0 a b -> incl'0 b c -> incl'0 a c
  
  function associative'0 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
      = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. op'0 a b = op'0 b a
  
  function incl_op'0 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. op'0 self other = C_Some'2 comb -> incl'0 self comb
  
  function op'1 (self: t_Sum) (other: t_Sum) : t_Option = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = C_Left x; f1'0 = C_Left y} -> map_logic'0 (op x y) (fun (l: t_R1) -> C_Left l)
      | {f0'0 = C_Right x; f1'0 = C_Right y} -> map_logic'1 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 (a: t_Sum) (b: t_Sum) (c: t_Sum) : () = ()
  
  axiom associative_spec'1:
    forall a: t_Sum, b: t_Sum, c: t_Sum. and_then_logic'0 (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
      = and_then_logic'0 (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 (a: t_Sum) (b: t_Sum) : () = ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. op'1 a b = op'1 b a
  
  function op'2 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_Sum) -> C_Some z)
      end
  
  function associative'2 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'2:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
      = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  function commutative'2 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'2: forall a: t_Option, b: t_Option. op'2 a b = op'2 b a
  
  type t_U
  
  type t_SumLocalUpdateR = { t_SumLocalUpdateR__0: t_U }
  
  predicate premise (self: t_U) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise'0 (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = C_Right from_auth'0; f1'0 = C_Right from_frag'0} -> premise self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0
      | {f0'0 = C_Left _; f1'0 = C_Left _} -> false
      | _ -> true
      end
  
  type tuple'1 = { f0'1: t_R2; f1'1: t_R2 }
  
  function update (self: t_U) (from_auth: t_R2) (from_frag: t_R2) : tuple'1
  
  predicate index_logic [@inline:trivial] (self: Map.map tuple'0 bool) (a: tuple'0) = Map.get self a
  
  meta "rewrite_def" predicate index_logic
  
  function such_that (p: Map.map tuple'0 bool) : tuple'0
  
  axiom such_that_spec: forall p: Map.map tuple'0 bool. (exists x: tuple'0. index_logic p x)
      -> index_logic p (such_that p)
  
  function update'0 (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum) : tuple'0 =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = C_Right from_auth'0; f1'0 = C_Right from_frag'0} -> let {f0'1 = to_auth; f1'1 = to_frag} = update self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0 in { f0'0 = C_Right to_auth;
                                                                                                                                                                         f1'0 = C_Right to_frag }
      | _ -> such_that (fun (__0: tuple'0) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumLocalUpdateR. forall from_auth: t_Sum. forall from_frag: t_Sum. forall frame: t_Option. op'2 (C_Some from_frag) frame
                = C_Some'0 (C_Some from_auth)
              /\ premise'0 self from_auth from_frag
            -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
            /\ premise'0 self from_auth from_frag
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
                = C_Some'0 (C_Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
              = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__update__qyi10922308247021603688__frame_preserving__refines (* <snapshot::Snapshot<(R, R)> as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option = C_None | C_Some t_R
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Option
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple = { f0: t_Option; f1: t_Option }
  
  function map_logic (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0 = match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 (self: t_Option) (f: Map.map t_R t_Option) : t_Option = match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op (self: t_R) (other: t_R) : t_Option
  
  function factor (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. match factor self factor'0 with
        | C_Some c -> op factor'0 c = C_Some self
        | C_None -> forall c: t_R. op factor'0 c <> C_Some self
        end
  
  predicate incl (self: t_R) (other: t_R) = factor other self <> C_None
  
  function incl_transitive (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. incl a b -> incl b c -> incl a c
  
  function associative (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
      = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. op a b = op b a
  
  function incl_op (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. op self other = C_Some comb -> incl self comb
  
  function op'0 (self: t_Option) (other: t_Option) : t_Option'0 = match { f0 = self; f1 = other } with
      | {f0 = C_None} -> C_Some'0 other
      | {f1 = C_None} -> C_Some'0 self
      | {f0 = C_Some x; f1 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  axiom associative_spec'0:
    forall a: t_Option, b: t_Option, c: t_Option. and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function commutative'0 (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'0: forall a: t_Option, b: t_Option. op'0 a b = op'0 b a
  
  type tuple'0 = { f0'0: t_R; f1'0: t_R }
  
  predicate premise (self: tuple'0) (from_auth: t_R) (from_frag: t_R) =
    forall f: t_Option. op'0 (C_Some from_frag) f = C_Some'0 (C_Some from_auth)
      -> op'0 (C_Some (self.f1'0)) f = C_Some'0 (C_Some (self.f0'0))
  
  function update (self: tuple'0) (_2: t_R) (_3: t_R) : tuple'0 = self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: tuple'0. forall from_auth: t_R. forall from_frag: t_R. forall frame: t_Option. op'0 (C_Some from_frag) frame
                = C_Some'0 (C_Some from_auth)
              /\ premise self from_auth from_frag
            -> op'0 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
            /\ premise self from_auth from_frag
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update self from_auth from_frag in op'0 (C_Some to_frag) frame
                = C_Some'0 (C_Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update self from_auth from_frag in op'0 (C_Some to_frag) frame
              = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__view__qyi3129231301466035151__inhabits__refines (* <logic::ra::view::InnerView<R> as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option = C_None | C_Some t_Auth
  
  type t_Frag
  
  predicate rel (a: t_Option) (f: t_Frag)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Frag
  
  function op (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. match factor self factor'0 with
        | C_Some'0 c -> op factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
        end
  
  predicate incl (self: t_Frag) (other: t_Frag) = factor other self <> C_None'0
  
  function incl_transitive (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl a b -> incl b c -> incl a c
  
  function and_then_logic (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0 = match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
      = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. op a b = op b a
  
  function incl_op (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op self other = C_Some'0 comb -> incl self comb
  
  function core_total (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. op (core_total self) self = C_Some'0 self
  
  constant unit' : t_Frag
  
  axiom unit_spec: forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = ()
  
  axiom unit_core_spec: core_total unit' = unit'
  
  constant incl_refl: () = let _ = unit' in ()
  
  axiom incl_refl_spec: forall x: t_Frag. incl x x
  
  function rel_unit (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. rel a unit'
  
  function rel_none (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. rel a f -> rel (C_None) f
  
  function rel_mono (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. rel a f1 -> incl f2 f1 -> rel a f2
  
  type t_InnerView = { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' (self: t_InnerView) = rel self.t_InnerView__auth self.t_InnerView__frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_InnerView. invariant' result -> invariant' result
end
module M_creusot_contracts__logic__well_founded__qyi13845007837429003844__no_infinite_decreasing_sequence__refines (* <logic::int::Int as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  use map.Map
  
  predicate well_founded_relation [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int int. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi6309403424797654971__no_infinite_decreasing_sequence__refines (* <u8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt8.t, y: UInt8.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym2_spec: forall x: UInt8.t, y: UInt8.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym1_spec: forall x: UInt8.t, y: UInt8.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt8.t, y: UInt8.t, z: UInt8.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt8.t) : ()
  
  axiom refl_spec: forall x: UInt8.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt8.t, y: UInt8.t. UInt8.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt8.t, y: UInt8.t. UInt8.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt8.t, y: UInt8.t. UInt8.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt8.t, y: UInt8.t. UInt8.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt8.t) (other: UInt8.t) = UInt8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt8.t) (a: int) : UInt8.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt8.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi13365674792282857752__no_infinite_decreasing_sequence__refines (* <u16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt16.t, y: UInt16.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym2_spec: forall x: UInt16.t, y: UInt16.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym1_spec: forall x: UInt16.t, y: UInt16.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt16.t, y: UInt16.t, z: UInt16.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt16.t) : ()
  
  axiom refl_spec: forall x: UInt16.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt16.t, y: UInt16.t. UInt16.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt16.t, y: UInt16.t. UInt16.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt16.t, y: UInt16.t. UInt16.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt16.t, y: UInt16.t. UInt16.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt16.t) (other: UInt16.t) = UInt16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt16.t) (a: int) : UInt16.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt16.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi12322784451431554842__no_infinite_decreasing_sequence__refines (* <u32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt32.t, y: UInt32.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym2_spec: forall x: UInt32.t, y: UInt32.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym1_spec: forall x: UInt32.t, y: UInt32.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt32.t, y: UInt32.t, z: UInt32.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt32.t) : ()
  
  axiom refl_spec: forall x: UInt32.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt32.t, y: UInt32.t. UInt32.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt32.t, y: UInt32.t. UInt32.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt32.t, y: UInt32.t. UInt32.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt32.t, y: UInt32.t. UInt32.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt32.t) (other: UInt32.t) = UInt32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt32.t) (a: int) : UInt32.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt32.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi3704748901488424246__no_infinite_decreasing_sequence__refines (* <u64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt64.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi1252550884029967619__no_infinite_decreasing_sequence__refines (* <u128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt128.t, y: UInt128.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym2_spec: forall x: UInt128.t, y: UInt128.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym1_spec: forall x: UInt128.t, y: UInt128.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt128.t, y: UInt128.t, z: UInt128.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt128.t) : ()
  
  axiom refl_spec: forall x: UInt128.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt128.t, y: UInt128.t. UInt128.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt128.t, y: UInt128.t. UInt128.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt128.t, y: UInt128.t. UInt128.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt128.t, y: UInt128.t. UInt128.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt128.t) (other: UInt128.t) = UInt128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt128.t) (a: int) : UInt128.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt128.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi11167162977841660089__no_infinite_decreasing_sequence__refines (* <usize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt64.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi4052372126950253571__no_infinite_decreasing_sequence__refines (* <i8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int8.t) (y: Int8.t) : ()
  
  axiom eq_cmp_spec: forall x: Int8.t, y: Int8.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym2_spec: forall x: Int8.t, y: Int8.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym1_spec: forall x: Int8.t, y: Int8.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int8.t, y: Int8.t, z: Int8.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int8.t) : ()
  
  axiom refl_spec: forall x: Int8.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int8.t, y: Int8.t. Int8.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int8.t, y: Int8.t. Int8.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int8.t, y: Int8.t. Int8.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int8.t, y: Int8.t. Int8.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int8.t) (other: Int8.t) = Int8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int8.t) (a: int) : Int8.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int8.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi13817872832197934357__no_infinite_decreasing_sequence__refines (* <i16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int16.t) (y: Int16.t) : ()
  
  axiom eq_cmp_spec: forall x: Int16.t, y: Int16.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym2_spec: forall x: Int16.t, y: Int16.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym1_spec: forall x: Int16.t, y: Int16.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int16.t, y: Int16.t, z: Int16.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int16.t) : ()
  
  axiom refl_spec: forall x: Int16.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int16.t, y: Int16.t. Int16.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int16.t, y: Int16.t. Int16.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int16.t, y: Int16.t. Int16.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int16.t, y: Int16.t. Int16.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int16.t) (other: Int16.t) = Int16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int16.t) (a: int) : Int16.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int16.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi14488472979989826699__no_infinite_decreasing_sequence__refines (* <i32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_spec: forall x: Int32.t, y: Int32.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_spec: forall x: Int32.t, y: Int32.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int32.t) : ()
  
  axiom refl_spec: forall x: Int32.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int32.t) (a: int) : Int32.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int32.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi9107029114244384425__no_infinite_decreasing_sequence__refines (* <i64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int64.t) : ()
  
  axiom refl_spec: forall x: Int64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int64.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi7767210905695706209__no_infinite_decreasing_sequence__refines (* <i128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int128.t) (y: Int128.t) : ()
  
  axiom eq_cmp_spec: forall x: Int128.t, y: Int128.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym2_spec: forall x: Int128.t, y: Int128.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym1_spec: forall x: Int128.t, y: Int128.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int128.t, y: Int128.t, z: Int128.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int128.t) : ()
  
  axiom refl_spec: forall x: Int128.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int128.t, y: Int128.t. Int128.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int128.t, y: Int128.t. Int128.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int128.t, y: Int128.t. Int128.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int128.t, y: Int128.t. Int128.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int128.t) (other: Int128.t) = Int128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int128.t) (a: int) : Int128.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int128.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi16083863403565404456__no_infinite_decreasing_sequence__refines (* <isize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_spec: forall x: Int64.t, y: Int64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: Int64.t) : ()
  
  axiom refl_spec: forall x: Int64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log x y <> C_Greater)
  
  predicate well_founded_relation [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int64.t. forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi15685960674935199696__no_infinite_decreasing_sequence__refines (* <&T as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation (self: t_T) (other: t_T)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: t_T) (other: t_T) = well_founded_relation self other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int t_T. forall result: int. not well_founded_relation'0 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'0 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi11731306862075323925__no_infinite_decreasing_sequence__refines (* <std::boxed::Box<T> as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation (self: t_T) (other: t_T)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: t_T) (other: t_T) = well_founded_relation self other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int t_T. forall result: int. not well_founded_relation'0 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'0 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi4207107057392109463__no_infinite_decreasing_sequence__refines (* <() as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  predicate well_founded_relation [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation
  
  function index_logic [@inline:trivial] (self: Map.map int ()) (a: int) : () = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int (). forall result: int. not well_founded_relation (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0 -> not well_founded_relation (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi11248794011242651965__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5, T6, T7) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type t_T7
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6; f7: t_T7 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation'4 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation'5 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation'6 (self: t_T7) (other: t_T7)
  
  predicate well_founded_relation'7 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation'3 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation'4 self.f5 other.f5
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2
      /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation'5 self.f6 other.f6
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3
    /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ self.f6 = other.f6 /\ well_founded_relation'6 self.f7 other.f7
  
  meta "rewrite_def" predicate well_founded_relation'7
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tuple. forall result: int. not well_founded_relation'7 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'7 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi15628048186059727938__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5, T6) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation'4 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation'5 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation'6 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation'3 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation'4 self.f5 other.f5
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation'5 self.f6 other.f6
  
  meta "rewrite_def" predicate well_founded_relation'6
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tuple. forall result: int. not well_founded_relation'6 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'6 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi8633347720896034824__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation'4 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation'5 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation'3 self.f4 other.f4
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation'4 self.f5 other.f5
  
  meta "rewrite_def" predicate well_founded_relation'5
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tuple. forall result: int. not well_founded_relation'5 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'5 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi8393942673489523592__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation'4 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation'3 self.f4 other.f4
  
  meta "rewrite_def" predicate well_founded_relation'4
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tuple. forall result: int. not well_founded_relation'4 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'4 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi949392529840141709__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation'3 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation'2 self.f3 other.f3
  
  meta "rewrite_def" predicate well_founded_relation'3
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tuple. forall result: int. not well_founded_relation'3 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'3 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi10765982677188459404__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type tuple = { f0: t_T0; f1: t_T1; f2: t_T2 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation'2 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation'1 self.f2 other.f2
  
  meta "rewrite_def" predicate well_founded_relation'2
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tuple. forall result: int. not well_founded_relation'2 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'2 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi16996715548001152850__no_infinite_decreasing_sequence__refines (* <(T0, T1) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type tuple = { f0: t_T0; f1: t_T1 }
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation'1 [@inline:trivial] (self: tuple) (other: tuple) =
    well_founded_relation self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation'0 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation'1
  
  function index_logic [@inline:trivial] (self: Map.map int tuple) (a: int) : tuple = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tuple. forall result: int. not well_founded_relation'1 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'1 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__logic__well_founded__qyi8411281253318747442__no_infinite_decreasing_sequence__refines (* <(T0,) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  predicate well_founded_relation (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation'0 [@inline:trivial] (self: t_T0) (other: t_T0) = well_founded_relation self other
  
  meta "rewrite_def" predicate well_founded_relation'0
  
  function index_logic [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int t_T0. forall result: int. not well_founded_relation'0 (index_logic s result) (index_logic s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation'0 (index_logic s result) (index_logic s (result + 1)) /\ result >= 0
end
module M_creusot_contracts__peano__qyi18409208157518949721__cmp__refines (* <peano::PeanoInt as std::cmp::Ord> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      C_Less
    else
      if self = o then C_Equal else C_Greater
  
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Greater -> cmp_log y x = C_Less
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. cmp_log x y = C_Less -> cmp_log y x = C_Greater
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log x y = o
      -> cmp_log y z = o -> cmp_log x z = o
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering =
    cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" function cmp_log'0
  
  function eq_cmp'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Greater -> cmp_log'0 y x = C_Less
  
  function antisym1'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log'0 x y = C_Less -> cmp_log'0 y x = C_Greater
  
  function trans'0 (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log'0 x y = o
      -> cmp_log'0 y z = o -> cmp_log'0 x z = o
  
  function refl'0 (x: t_PeanoInt) : () = ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. cmp_log'0 x x = C_Equal
  
  predicate gt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate gt_log
  
  function cmp_gt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate ge_log
  
  function cmp_ge_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate lt_log
  
  function cmp_lt_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "rewrite_def" predicate le_log
  
  function cmp_le_log'0 (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. le_log x y = (cmp_log'0 x y <> C_Greater)
  
  function deep_model [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.t_PeanoInt__0
  
  meta "rewrite_def" function deep_model
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: t_Ordering. result
            = cmp_log'0 self_ rhs -> result = cmp_log (deep_model self_) (deep_model rhs)
end
module M_creusot_contracts__std__iter__fuse__qyi12953744680688287360__is_fused__refines (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_Fuse
  
  type t_Item
  
  type t_I
  
  type t_Option = C_None | C_Some t_I
  
  function view (self: t_Fuse) : t_Option
  
  predicate produces (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces a ab b
      -> produces b bc c -> produces a (Seq.(++) ab bc) c
  
  function produces_refl (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse) =
    match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  function produces_trans'0 (a: t_Fuse) (ab: Seq.seq t_Item) (b: t_Fuse) (bc: Seq.seq t_Item) (c: t_Fuse) : () = ()
  
  axiom produces_trans_spec'0:
    forall a: t_Fuse, ab: Seq.seq t_Item, b: t_Fuse, bc: Seq.seq t_Item, c: t_Fuse. produces'0 a ab b
      -> produces'0 b bc c -> produces'0 a (Seq.(++) ab bc) c
  
  function produces_refl'0 (self: t_Fuse) : () = ()
  
  axiom produces_refl_spec'0: forall self: t_Fuse. produces'0 self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed (self: MutBorrow.t t_I)
  
  predicate completed'0 (self: MutBorrow.t t_Fuse) =
    (view self.current = C_None
      \/ (exists it: MutBorrow.t t_I. completed it /\ view self.current = C_Some (it.current)))
    /\ view self.final = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: MutBorrow.t t_Fuse. forall steps: Seq.seq t_Item. forall next: t_Fuse. produces'0 self.final steps next
            /\ completed'0 self
          -> produces'0 self.final steps next
          /\ completed'0 self
          /\ (forall result: (). steps = (Seq.empty: Seq.seq t_Item) -> steps = (Seq.empty: Seq.seq t_Item))
end
module M_creusot_contracts__std__iter__range__qyi9685214752154132849__produces_back_refl__refines (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range = { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model (self: t_Idx) : int
  
  predicate produces_back (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range) =
    self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Range. forall result: (). produces_back self (Seq.empty: Seq.seq t_Idx) self
        -> produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__std__iter__range__qyi9685214752154132849__produces_back_trans__refines (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range = { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model (self: t_Idx) : int
  
  predicate produces_back (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range) =
    self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0 -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Range. forall ab: Seq.seq t_Idx. forall b: t_Range. forall bc: Seq.seq t_Idx. forall c: t_Range. produces_back b bc c
                /\ produces_back a ab b
              -> produces_back b bc c
              /\ produces_back a ab b
              /\ (forall result: (). produces_back a (Seq.(++) ab bc) c -> produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__iter__range__qyi12388694168379144585__produces_back_refl__refines (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_RangeInclusive. forall result: (). produces_back self (Seq.empty: Seq.seq t_Idx) self
        -> produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__std__iter__range__qyi12388694168379144585__produces_back_trans__refines (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive
  
  type t_Idx
  
  function deep_model (self: t_Idx) : int
  
  function start_log (self: t_RangeInclusive) : t_Idx
  
  function end_log (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. not is_empty_log self
      -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len (r: t_RangeInclusive) : int = if is_empty_log r then
      0
    else
      deep_model (end_log r) - deep_model (start_log r) + 1
  
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive) =
    Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_RangeInclusive. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive. produces_back b bc c
                /\ produces_back a ab b
              -> produces_back b bc c
              /\ produces_back a ab b
              /\ (forall result: (). produces_back a (Seq.(++) ab bc) c -> produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__std__ops__qyi67194259310281437__hist_inv_trans__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall b: t_F. forall c: t_F. hist_inv b c /\ hist_inv self b
          -> hist_inv b c /\ hist_inv self b /\ (forall result: (). hist_inv self c -> hist_inv self c)
end
module M_creusot_contracts__std__ops__qyi67194259310281437__fn_mut_once__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate postcondition_mut (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate resolve (_1: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once self args res
              = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
            -> postcondition_once self args res
            = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
end
module M_creusot_contracts__std__ops__qyi67194259310281437__postcondition_mut_hist_inv__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. postcondition_mut self args res_state res
            -> postcondition_mut self args res_state res
            /\ (forall result: (). hist_inv self res_state -> hist_inv self res_state)
end
module M_creusot_contracts__std__ops__qyi67194259310281437__hist_inv_refl__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall result: (). hist_inv self self -> hist_inv self self
end
module M_creusot_contracts__std__ops__qyi396835551462182716__fn_mut__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate postcondition (self: t_F) (args: t_Args) (result: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. forall result: (). postcondition_mut self args res_state res
                = (postcondition self args res /\ self = res_state)
              -> postcondition_mut self args res_state res = (postcondition self args res /\ self = res_state)
end
module M_creusot_contracts__std__ops__qyi396835551462182716__fn_once__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate postcondition (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate resolve (_1: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once self args res
              = (postcondition self args res /\ resolve self)
            -> postcondition_once self args res = (postcondition self args res /\ resolve self)
end
module M_creusot_contracts__std__ops__qyi396835551462182716__fn_hist_inv__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall res_state: t_F. forall result: (). hist_inv self res_state = (self = res_state)
          -> hist_inv self res_state = (self = res_state)
end
module M_creusot_contracts__std__ptr__qyi4653477246949472063__sub_offset_logic__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  
  function sub_logic (self: Opaque.ptr) (rhs: Opaque.ptr) : int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_logic (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_logic_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_logic self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Opaque.ptr. forall offset: int. forall result: (). sub_logic (offset_logic self offset) self = offset
          -> sub_logic (offset_logic self offset) self = offset
end
module M_creusot_contracts__std__ptr__qyi4653477246949472063__offset_logic_zero__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_logic (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_logic_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_logic self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall result: (). offset_logic self 0 = self -> offset_logic self 0 = self
end
module M_creusot_contracts__std__ptr__qyi4653477246949472063__offset_logic__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.prelude.Opaque
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall offset: int. UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
          < UInt64.t'int const_MAX
        -> UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T < UInt64.t'int const_MAX
        /\ (forall result: Opaque.ptr. UInt64.t'int (Ptr.addr_logic_u64 result)
            = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
          -> UInt64.t'int (Ptr.addr_logic_u64 result) = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T)
end
module M_creusot_contracts__std__ptr__qyi4653477246949472063__offset_logic_assoc__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_logic (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_logic_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_logic self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Opaque.ptr. forall offset1: int. forall offset2: int. forall result: (). offset_logic (offset_logic self offset1) offset2
              = offset_logic self (offset1 + offset2)
            -> offset_logic (offset_logic self offset1) offset2 = offset_logic self (offset1 + offset2)
end
module M_creusot_contracts__std__ptr__qyi4653477246949472063__sub_logic_refl__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  
  function sub_logic (self: Opaque.ptr) (rhs: Opaque.ptr) : int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall result: (). sub_logic self self = 0 -> sub_logic self self = 0
end
module M_creusot_contracts__std__ptr__qyi16049136019895146802__slice_ptr_ext__refines (* <*const [T] as std::ptr::SlicePointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function thin [@inline:trivial] (self: Opaque.ptr) : Opaque.ptr = Opaque.thin self
  
  meta "rewrite_def" function thin
  
  function metadata_logic (_1: Opaque.ptr) : UInt64.t
  
  function len_logic [@inline:trivial] (self: Opaque.ptr) : UInt64.t = metadata_logic self
  
  meta "rewrite_def" function len_logic
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall other: Opaque.ptr. forall result: (). thin self = thin other
              /\ len_logic self = len_logic other -> self = other
          -> thin self = thin other /\ len_logic self = len_logic other -> self = other
end
module M_creusot_contracts__std__slice__qyi314041225306698538__as_mut_ptr_own__refines (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 (self: Slice64.slice t_T) = inv'1 (Slice64.view self)
  
  predicate inv'2 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  type t_PtrOwn
  
  function val' (self: t_PtrOwn) : Slice64.slice t_T
  
  function fin [@inline:trivial] (self: MutBorrow.t t_PtrOwn) : t_PtrOwn = self.final
  
  meta "rewrite_def" function fin
  
  type tuple = { f0: Opaque.ptr; f1: MutBorrow.t t_PtrOwn }
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches
  
  function metadata_logic (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_logic [@inline:trivial] (val''0: Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val''0)
  
  meta "rewrite_def" function size_of_val_logic
  
  axiom size_of_val_logic_spec: forall val''0: Slice64.slice t_T. 0 <= size_of_val_logic val''0
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant''3 [@inline:trivial] (self: Slice64.slice t_T) = inv'2 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'4 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''3 _1
  
  meta "rewrite_def" predicate inv'4
  
  predicate invariant''4 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self
    /\ metadata_matches (val' self) (metadata_logic (ptr self))
    /\ size_of_val_logic (val' self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr self)) + size_of_val_logic (val' self) <= UInt64.t'int const_MAX'0
    /\ inv'4 (val' self)
  
  predicate inv'5 (_1: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv'5 x]. inv'5 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'5 self.current /\ inv'5 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'6 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = invariant''5 _1
  
  meta "rewrite_def" predicate inv'6
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_PtrOwn) = inv'6 self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'7 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn) = invariant''6 _1
  
  meta "rewrite_def" predicate inv'7
  
  predicate inv'8 [@inline:trivial] (_1: tuple) = inv'7 _1.f1
  
  meta "rewrite_def" predicate inv'8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t (Slice64.slice t_T). inv'3 self
      -> inv'3 self
      /\ (forall result: tuple. self.final = val' (fin result.f1)
          /\ self.current = val' result.f1.current /\ result.f0 = Opaque.thin (ptr result.f1.current) /\ inv'8 result
        -> inv'8 result)
end
module M_creusot_contracts__std__slice__qyi314041225306698538__as_ptr_own__refines (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  
  type t_T
  
  predicate inv (_1: t_T)
  
  predicate invariant' (self: t_T) = inv self
  
  predicate inv'0 [@inline:trivial] (_1: t_T) = invariant' _1
  
  meta "rewrite_def" predicate inv'0
  
  predicate invariant''0 [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv'0 (Seq.get self i)
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'1 [@inline:trivial] (_1: Seq.seq t_T) = invariant''0 _1
  
  meta "rewrite_def" predicate inv'1
  
  predicate invariant''1 (self: Slice64.slice t_T) = inv'1 (Slice64.view self)
  
  predicate inv'2 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''1 _1
  
  meta "rewrite_def" predicate inv'2
  
  predicate invariant''2 [@inline:trivial] (self: Slice64.slice t_T) = inv'2 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'3 [@inline:trivial] (_1: Slice64.slice t_T) = invariant''2 _1
  
  meta "rewrite_def" predicate inv'3
  
  type t_PtrOwn
  
  function val' (self: t_PtrOwn) : Slice64.slice t_T
  
  type tuple = { f0: Opaque.ptr; f1: t_PtrOwn }
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate is_null_logic (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque (self: t_PtrOwn)
  
  predicate metadata_matches [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches
  
  function metadata_logic (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_logic [@inline:trivial] (val''0: Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val''0)
  
  meta "rewrite_def" function size_of_val_logic
  
  axiom size_of_val_logic_spec: forall val''0: Slice64.slice t_T. 0 <= size_of_val_logic val''0
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant''3 (self: t_PtrOwn) =
    not is_null_logic (ptr self)
    /\ ptr_is_aligned_opaque self
    /\ metadata_matches (val' self) (metadata_logic (ptr self))
    /\ size_of_val_logic (val' self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr self)) + size_of_val_logic (val' self) <= UInt64.t'int const_MAX'0
    /\ inv'3 (val' self)
  
  predicate inv'4 (_1: t_PtrOwn)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_PtrOwn) = inv'4 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'5 [@inline:trivial] (_1: t_PtrOwn) = invariant''4 _1
  
  meta "rewrite_def" predicate inv'5
  
  predicate invariant''5 [@inline:trivial] (self: t_PtrOwn) = inv'5 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'6 [@inline:trivial] (_1: t_PtrOwn) = invariant''5 _1
  
  meta "rewrite_def" predicate inv'6
  
  predicate inv'7 [@inline:trivial] (_1: tuple) = inv'6 _1.f1
  
  meta "rewrite_def" predicate inv'7
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.slice t_T. inv'3 self
      -> inv'3 self
      /\ (forall result: tuple. self = val' result.f1 /\ result.f0 = Opaque.thin (ptr result.f1) /\ inv'7 result
        -> inv'7 result)
end
