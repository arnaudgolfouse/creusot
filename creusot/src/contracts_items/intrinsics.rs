//! Special symbols defined in [`creusot_contracts`] and annotated with
//! `#[creusot::intrinsics = "..."]`

use crate::{contracts_items::get_intrinsic, ctx::TranslationCtx, metadata::Metadata};

use rustc_hir::{def::DefKind, def_id::DefId};
use rustc_middle::ty::TyCtxt;
use rustc_span::{DUMMY_SP, Symbol};
use std::collections::HashMap;

macro_rules! contracts_items {
    ($($symbol:literal $id:ident)*) => {
        #[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]
        pub enum Intrinsic {
            $($id),*,
            None
        }

        pub(crate) fn gather_intrinsics<'tcx>(tcx: TyCtxt<'tcx>, ext: &Metadata<'tcx>) ->
            (HashMap<Symbol, DefId>, HashMap<Intrinsic, DefId>, HashMap<DefId, Intrinsic>) {
            let raw : HashMap<Symbol, DefId> = tcx
                .iter_local_def_id()
                .filter_map(|did| {
                    let mut did = did.to_def_id();
                    if let DefKind::Ctor(..) = tcx.def_kind(did) {
                        did = tcx.parent(did);
                    }
                    Some((get_intrinsic(tcx, did)?, did))
                })
                .collect();
            let mut int2did = HashMap::new();
            let mut did2int = HashMap::new();
            let mut missing_items = Vec::new();
            let mut no_items = true;
            $(
                let sym = Symbol::intern($symbol);
                let here = raw.get(&sym).copied();
                let there = ext.intrinsic(sym);
                if here.is_some() && there.is_some() {
                    panic!("An intrinsic is defined twice");
                }
                let did = here.or(there);
                if let Some(did) = did {
                    if int2did.insert(Intrinsic::$id, did).is_some() { panic!() };
                    if did2int.insert(did, Intrinsic::$id).is_some() {
                        panic!("{did:?} has more than one intrinsic declaration.")
                    };
                    no_items = false
                } else {
                    missing_items.push($symbol)
                }
            )*
            if no_items {
                tcx.dcx().struct_span_fatal(DUMMY_SP,
                    "The `creusot_contracts` crate is not loaded. You will not be able to verify any code using Creusot until you do so."
                ).with_note("Don't forget to actually use creusot_contracts: `use creusot_contracts::*;`").emit()
            } else if !missing_items.is_empty() {
                let mut message =
                    String::from("The `creusot_contracts` crate is loaded, but the following items are missing: ");
                for (i, item) in missing_items.iter().enumerate() {
                    if i != 0 {
                        message.push_str(", ");
                    }
                    message.push_str(item);
                }
                message.push_str(". Maybe your version of `creusot-contracts` is wrong?");
                tcx.dcx().struct_span_fatal(DUMMY_SP, message).emit()
            }
            (raw, int2did, did2int)
        }
    };
}

impl Intrinsic {
    pub fn get(self, ctx: &TranslationCtx) -> DefId {
        ctx.intrinsic2did[&self]
    }

    pub fn is(self, ctx: &TranslationCtx, did: DefId) -> bool {
        self.get(ctx) == did
    }

    /// Returns `true` for intrisics whose body is generated by Creusot, so that we do not
    /// validate its body
    pub fn synthetic(self) -> bool {
        matches!(
            self,
            Intrinsic::Resolve
                | Intrinsic::StructuralResolve
                | Intrinsic::SizeOfLogic
                | Intrinsic::Postcondition
                | Intrinsic::PostconditionMut
                | Intrinsic::PostconditionOnce
                | Intrinsic::HistInv
                | Intrinsic::Precondition
                | Intrinsic::MetadataMatches
        )
    }
}

contracts_items! {
    "inv"                       Inv
    "resolve"                   Resolve
    "structural_resolve"        StructuralResolve
    "invariant"                 Invariant
    "resolve_method"            ResolveMethod
    "snapshot_from_fn"          SnapFromFn
    "snapshot_deref"            SnapshotDeref
    "snapshot_deref_mut"        SnapshotDerefMut
    "ghost_new"                 GhostNew
    "ghost_into_inner"          GhostIntoInner
    "ghost_deref"               GhostDeref
    "ghost_deref_mut"           GhostDerefMut
    "index_logic"               IndexLogic
    "precondition"              Precondition
    "postcondition_once"        PostconditionOnce
    "postcondition_mut"         PostconditionMut
    "hist_inv"                  HistInv
    "postcondition"             Postcondition
    "tokens_new"                TokensNew
    "int"                       Int
    "snapshot"                  Snapshot
    "ghost"                     Ghost
    "fn_ghost_wrapper"          FnGhostWrapper
    "namespace"                 Namespace
    "fn_ghost"                  FnGhost
    "size_of_logic"             SizeOfLogic
    "forall"                    Forall
    "exists"                    Exists
    "trigger"                   Trigger
    "implication"               Implication
    "equal"                     Equal
    "neq"                       Neq
    "variant_check"             VariantCheck
    "old"                       Old
    "dead"                      Dead
    "closure_result"            ClosureResult
    "seq_literal"               SeqLiteral
    "metadata_matches"          MetadataMatches
    "metadata_matches_slice"    MetadataMatchesSlice
    "metadata_matches_str"      MetadataMatchesStr
    "well_founded_relation"     WellFoundedRelation
    "ptr_own_as_ref"            PtrOwnAsRef
    "ptr_own_as_mut"            PtrOwnAsMut
    "ptr_own_from_ref"          PtrOwnFromRef
    "ptr_own_from_mut"          PtrOwnFromMut
}
